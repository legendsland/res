<!DOCTYPE html><html><head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Effective Rust_35 Specific Ways to Improve Your Rust Code.Drysdale2024</title>
<style>
@charset "UTF-8";

/* O'Reilly Media, 2023 */

/* Last revision 10/16/2023 */

/* reset */

html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
menu,
nav,
section {
  display: block;
}

body {
  line-height: 1;
}

ol,
ul {
  list-style: none;
}

blockquote,
q {
  quotes: none;
}

blockquote:before,
blockquote:after,
q:before,
q:after {
  content: '';
  content: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

/* end reset */

@page {
  margin: 5px !important;
}

p {
  margin: 10px 0 0;
  line-height: 125%;
  text-align: left;
}

/* author byline */

p.byline {
  text-align: left;
  margin: -33px auto 35px;
  font-style: italic;
  font-weight: bold;
}

/* author byline at end of preface */

div.preface p + p.byline,
div.preface p.byline.cont + p.byline:not(.cont) {
  margin: 1em 0 0 !important;
}

div.preface p.byline + p.byline {
  margin: 0 !important;
}

/* author bylines after A-Head */

div.sect1 > p.byline {
  margin: -0.25em 0 1em;
}

div.sect1 > p.byline + p.byline {
  margin-top: -1em;
}

/* ----------------- inlines; code and monospace in the code section below ----------------- */

em {
  font-style: italic;
  font-family: inherit;
}

em strong,
strong em {
  font-weight: bold;
  font-style: italic;
  font-family: inherit;
}

strong,
span.bold {
  font-weight: bold;
}

em.replaceable {
  font-style: italic;
}

strong.userinput {
  font-weight: bold;
  font-style: normal;
}

span.bolditalic {
  font-weight: bold;
  font-style: italic;
}

a.ulink,
a.xref,
a.email,
a.link,
a {
  text-decoration: none;
  color: #8e0012;
}

span.lineannotation {
  font-style: italic;
  color: #a62a2a;
  font-family: serif;
}

span.underline {
  text-decoration: underline;
}

span.strikethrough {
  text-decoration: line-through;
}

span.smallcaps {
  font-variant: small-caps;
}

span.cursor {
  background: #000;
  color: #ffffff;
}

/* for Learning GNU Emacs, 3e */

span.smaller {
  font-size: 75%;
}

/* added for special formatting in Regular Expressions Cookbook, 1e (9780596802783.EBOOK) */

.boxedtext,
.keycap {
  border-style: solid;
  border-width: 1px;
  border-color: #000;
  padding: 1px;
}

span.gray50 {
  color: #7F7F7F;
  /* 50 % gray */
}

/* ----------------- headings ----------------- */

/* shared heading styles */

h1,
div.toc-title,
h2,
h3,
h4,
h5 {
  -webkit-hyphens: none;
  hyphens: none;
  adobe-hyphenate: none;
  font-weight: bold;
  text-align: left;
  page-break-after: avoid !important;
  font-family: sans-serif, "DejaVuSans";
}

div.toc-title {
  font-size: 1.5em;
  margin-top: 20px !important;
  margin-bottom: 30px !important;
}

section[data-type="sect1"] h1 {
  font-size: 1.3em;
  color: #8e0012;
  margin: 40px 0 8px 0;
}

section[data-type="sect2"] h2 {
  font-size: 1.1em;
  margin: 30px 0 8px 0 !important;
}

section[data-type="sect3"] h3 {
  font-size: 1em;
  color: #555;
  margin: 20px 0px 8px 0px !important;
}

section[data-type="sect4"] h4 {
  font-size: 1em;
  font-weight: normal;
  font-style: italic;
  margin: 15px 0px 6px 0px !important;
}

section[data-type="chapter"] > div > h1,
section[data-type="preface"] > div > h1,
section[data-type="appendix"] > div > h1,
section[data-type="glossary"] > div > h1,
section[data-type="bibliography"] > div > h1,
section[data-type="afterword"] > div > h1,
section[data-type="index"] > div > h1 {
  /* larger chapter title */
  font-size: 2em;
  line-height: 1;
  margin-bottom: 50px;
  color: #000;
  padding-bottom: 10px;
  border-bottom: 1px solid #000;
}

span.label,
span.keep-together {
  font-size: inherit;
  font-weight: inherit;
}

/* ----------------- parts ----------------- */

div[data-type="part"] > h1 {
  font-size: 2em;
  text-align: center;
  margin-top: 0px !important;
  margin-bottom: 50px;
  padding: 50px 0 10px 0;
  border-bottom: 1px solid #000;
}

/* ----------------- images ----------------- */

/* Use this class to set <img> width to 90% */

img.width-ninety {
  width: 90%;
}

img {
  max-width: 95%;
  margin: 0 auto;
  padding: 0;
}

div.figure {
  background-color: transparent;
  text-align: center !important;
  margin: 15px auto !important;
  page-break-inside: avoid;
}

figure {
  margin: 15px auto !important;
  page-break-inside: avoid;
}

div.figure h6,
figure h6,
figure figcaption {
  font-size: 0.9rem !important;
  text-align: center;
  font-weight: normal !important;
  font-style: italic !important;
  font-family: serif !important;
  text-transform: none !important;
  letter-spacing: normal !important;
  color: #000;
  padding-top: 0.25em !important;
  margin-top: 0 !important;
  page-break-before: avoid;
}

div.informalfigure {
  text-align: center !important;
  padding: 5px 0 !important;
}

/* ----------------- sidebars ----------------- */

div.sidebar {
  margin: 15px 0px 10px 0px !important;
  border: 1px solid #DCDCDC;
  background-color: #F7F7F7;
  padding: 15px !important;
  page-break-inside: avoid;
}

aside[data-type="sidebar"] {
  margin: 15px 0px 10px 0px !important;
  page-break-inside: avoid;
}

div.sidebar-title,
div.sidebar h1,
div.sidebar h5,
aside[data-type="sidebar"] h1,
aside[data-type="sidebar"] h5 {
  font-weight: bold;
  font-size: 1em;
  font-family: sans-serif;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
  margin: 4px 0 6px 0 !important;
  page-break-inside: avoid;
}

div.sidebar ol,
div.sidebar ul,
aside[data-type="sidebar"] ol,
aside[data-type="sidebar"] ul {
  margin-left: 1.25em !important;
}

div.sidebar div.figure p.title,
aside[data-type="sidebar"] figcaption,
div.sidebar div.informalfigure div.caption {
  font-size: 90%;
  text-align: center;
  font-weight: normal;
  font-style: italic;
  font-family: serif !important;
  color: #000;
  padding: 5px !important;
  page-break-before: avoid;
  page-break-after: avoid;
}

div.sidebar div.tip,
div.sidebar div[data-type="tip"],
div.sidebar div.note,
div.sidebar div[data-type="note"],
div.sidebar div.warning,
div.sidebar div[data-type="warning"],
div.sidebar div[data-type="caution"],
div.sidebar div[data-type="important"] {
  margin: 20px auto 20px auto !important;
  font-size: 90%;
  width: 85%;
}

/* author bylines in sidebars */

aside[data-type="sidebar"] p.byline {
  font-size: 90%;
  font-weight: bold;
  font-style: italic;
  text-align: center;
  text-indent: 0;
  margin: 5px auto 6px;
  page-break-after: avoid;
}

/* ----------------- code ----------------- */

pre {
  white-space: pre-wrap;
  font-family: "Ubuntu Mono", monospace;
  margin: 25px 0 25px 20px;
  font-size: 85%;
  display: block;
  -webkit-hyphens: none;
  hyphens: none;
  adobe-hyphenate: none;
  overflow-wrap: break-word;
}

pre code {
  font-size: inherit !important;
}

pre + pre {
  margin-top: -25px !important;
}

div.note pre.programlisting,
div.tip pre.programlisting,
div.warning pre.programlisting,
div.caution pre.programlisting,
div.important pre.programlisting {
  margin-bottom: 0;
}

code {
  font-family: "Ubuntu Mono", monospace;
  -webkit-hyphens: none;
  hyphens: none;
  adobe-hyphenate: none;
  overflow-wrap: break-word;
}

code strong em,
code em strong,
pre em strong,
pre strong em,
strong code em code,
em code strong code,
span.bolditalic code {
  /* yes, all of these variations are needed */
  font-weight: bold;
  font-style: italic;
  font-family: "Ubuntu Mono BoldItal", monospace;
}

code em,
em code,
pre em,
em.replaceable {
  font-family: "Ubuntu Mono Ital", monospace;
  font-style: italic;
}

code strong,
strong code,
pre strong,
strong.userinput {
  font-family: "Ubuntu Mono Bold", monospace;
  font-weight: bold;
}

div[data-type="example"] {
  margin: 10px 0 15px 0 !important;
}

div[data-type="example"] h1,
div[data-type="example"] h2,
div[data-type="example"] h3,
div[data-type="example"] h4,
div[data-type="example"] h5,
div[data-type="example"] h6 {
  font-style: italic;
  font-weight: normal;
  text-align: left !important;
  text-transform: none !important;
  font-family: serif !important;
  margin: 10px 0 5px 0 !important;
  border-bottom: 1px solid #000;
}

li pre.example {
  padding: 10px 0 !important;
}

div[data-type="example"] pre[data-type="programlisting"],
div[data-type="example"] pre[data-type="screen"] {
  margin: 0;
}

/* ----------------- title and copyright page ----------------- */

section[data-type="titlepage"] > div > h1 {
  font-size: 2em;
  margin: 50px 0 10px 0 !important;
  line-height: 1;
  text-align: center;
}

/* Styling for subtitle */

section[data-type="titlepage"] h2,
section[data-type="titlepage"] p.subtitle,
section[data-type="titlepage"] p[data-type="subtitle"] {
  font-size: 1.3em;
  font-weight: normal;
  text-align: center;
  margin-top: 0.5em;
  color: #555;
}

section[data-type="titlepage"] > div > h2[data-type="author"],
section[data-type="titlepage"] p.author {
  font-size: 1.3em;
  font-family: serif !important;
  font-weight: bold;
  margin: 50px 0 !important;
  text-align: center;
}

section[data-type="titlepage"] p.edition {
  text-align: center;
  text-transform: uppercase;
  margin-top: 2em;
}

section[data-type="titlepage"] {
  text-align: center;
}

section[data-type="titlepage"]:after {
  content: url('css_assets/titlepage_footer_ebook.png');
  margin: 0 auto;
  max-width: 80%;
}

div.book div.titlepage div.publishername {
  margin-top: 60%;
  margin-bottom: 20px;
  text-align: center;
  font-size: 1.25em;
}

div.book div.titlepage div.locations p {
  margin: 0;
  text-align: center;
}

div.book div.titlepage div.locations p.cities {
  font-size: 80%;
  text-align: center;
  margin-top: 5px;
}

section.preface[title="Dedication"] > div.titlepage h2.title {
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5em;
  margin-top: 50px;
  margin-bottom: 50px;
}

ul.stafflist {
  margin: 15px 0 15px 20px !important;
}

ul.stafflist li {
  list-style-type: none;
  padding: 5px 0;
}

ul.printings li {
  list-style-type: none;
}

section.preface[title="Dedication"] p {
  font-style: italic;
  text-align: center;
}

div.colophon h1.title {
  font-size: 1.3em;
  margin: 0 !important;
  font-family: serif !important;
  font-weight: normal;
}

div.colophon h2.subtitle {
  margin: 0 !important;
  color: #000;
  font-family: serif !important;
  font-size: 1em;
  font-weight: normal;
}

div.colophon div.author h3.author {
  font-size: 1.1em;
  font-family: serif !important;
  margin: 10px 0 0 !important;
  font-weight: normal;
}

div.colophon div.editor h4,
div.colophon div.editor h3.editor {
  color: #000;
  font-size: 0.8em;
  margin: 15px 0 0 !important;
  font-family: serif !important;
  font-weight: normal;
}

div.colophon div.editor h3.editor {
  font-size: 0.8em;
  margin: 0 !important;
  font-family: serif !important;
  font-weight: normal;
}

div.colophon div.publisher {
  margin-top: 10px;
}

div.colophon div.publisher p,
div.colophon div.publisher span.publishername {
  margin: 0;
  font-size: 0.8em;
}

div.legalnotice p,
div.timestamp p {
  font-size: 0.8em;
}

div.timestamp p {
  margin-top: 10px;
}

div.colophon[title="About the Author"] h1.title,
div.colophon[title="Colophon"] h1.title {
  font-size: 1.5em;
  margin: 0 !important;
  font-family: sans-serif !important;
}

/* ----------------- epigraphs, blockquotes, attributions ----------------- */

section.chapter div.titlepage div.author {
  margin: 10px 0 10px 0;
}

section.chapter div.titlepage div.author div.affiliation {
  font-style: italic;
}

div.attribution {
  margin: 5px 0 0 50px !important;
}

h3.author span.orgname {
  display: none;
}

/* to work around bug */

div.epigraph {
  margin: 10px 0 10px 20px !important;
  page-break-inside: avoid;
  font-size: 90%;
}

div.epigraph p {
  font-style: italic;
}

blockquote,
div.blockquote {
  margin: 10px !important;
  page-break-inside: avoid;
  font-size: 95%;
}

blockquote p,
div.blockquote p {
  font-style: italic;
  margin: 0.75em 0 0 !important;
}

blockquote div.attribution,
blockquote p[data-type="attribution"] {
  margin: 5px 0 10px 30px !important;
  text-align: right;
  width: 80%;
}

blockquote div.attribution p,
blockquote p[data-type="attribution"] {
  font-style: normal;
  margin-top: 5px;
}

blockquote div.attribution p:before,
blockquote p[data-type="attribution"]:before {
  font-style: normal;
  content: "\2014";
  -webkit-hyphens: none;
  hyphens: none;
  adobe-hyphenate: none;
}

p.right {
  text-align: right;
  margin: 0;
}

/* ----------------- footnotes ----------------- */

div[data-type="footnotes"] {
  border-top: 1px solid black;
  margin-top: 2em;
}

sub,
sup {
  font-size: 75%;
  line-height: 0;
}

sup {
  vertical-align: super !important;
}

sub {
  vertical-align: sub;
}

p[data-type="footnote"] {
  font-size: 90% !important;
  line-height: 1.2em !important;
  margin-left: 2.5em !important;
  text-indent: -2.3em !important;
}

p[data-type="footnote"] sup:first-child {
  display: inline-block !important;
  position: static !important;
  width: 2em !important;
  text-align: right !important;
  font-size: 100% !important;
  padding-right: 0.5em !important;
  top: -2px !important;
}

p[data-type="footnote"] a[href$="-marker"] {
  font-family: sans-serif !important;
  font-size: 90% !important;
  color: #8e0012 !important;
}

/* Special handling to account for Platform number (in footnote) spacing issue */

p[data-type="footnote"] a[data-type="xref"] {
  margin: 0 !important;
  padding: 0 !important;
  text-indent: 0 !important;
}

a[data-type="noteref"] {
  font-family: sans-serif !important;
  color: #8e0012;
  margin-left: 0;
  padding-left: 0;
}

/*----------handling for reference sections----------*/

div.refentry p.refname {
  font-size: 1em;
  font-family: sans-serif, "DejaVuSans";
  font-weight: bold;
  margin-bottom: 5px;
  overflow: auto;
  width: 100%;
}

div.refentry {
  width: 100%;
  display: block;
  margin-top: 2em;
}

div.refsynopsisdiv {
  display: block;
  clear: both;
}

div.refentry header {
  page-break-inside: avoid !important;
  display: block;
  break-inside: avoid !important;
  padding-top: 0;
  border-bottom: 1px solid #000;
}

div.refsect1 h6 {
  font-size: 0.9em;
  font-family: sans-serif, "DejaVuSans";
  font-weight: bold;
}

div.refsect1 {
  margin-top: 3em;
}

ul.references li {
  list-style-type: none !important;
  text-indent: -24px !important;
}

/* ----------------- lists ----------------- */

dl {
  margin-bottom: 1.5em !important;
}

dt {
  padding-top: 10px !important;
  padding-bottom: 0 !important;
  line-height: 1.25rem;
  font-style: italic;
}

dl.calloutlist dt {
  padding-top: 0 !important;
  line-height: 0 !important;
  margin-bottom: -2.35em !important;
}

/* Make sure code within dt isn't italicized . . . */

dt code {
  font-style: normal !important;
}

/* . . . But not in the Preface */

div.preface dt em code {
  font-style: italic !important;
}

dd {
  margin: 10px 0 0.25em 1.5em !important;
  line-height: 1.65em !important;
  font-family: "Noto serif", serif;
}

dd p {
  padding: 0 !important;
  margin: 0 0 10px !important;
}

dd ol,
dd ul {
  padding-left: 0.25em !important;
}

dd li {
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  line-height: 1 !important;
}

dl.calloutlist dd li {
  padding-top: 1em !important;
}

dl.calloutlist dd li:last-child {
  padding-bottom: 0 !important;
}

dl.calloutlist dd > ul:last-child,
dl.calloutlist dd > ol:last-child {
  padding-bottom: 1.5em !important;
}

dd,
li {
  text-align: left;
}

ul,
ul > li,
ol ul,
ol ul > li,
ul ol ul,
ul ol ul > li {
  list-style-type: disc !important;
}

ul ul,
ul ul > li {
  list-style-type: square;
}

ul ul ul,
ul ul ul > li {
  list-style-type: circle;
}

ol,
ol > li,
ol ul ol,
ol ul ol > li,
ul ol,
ul ol > li {
  list-style-type: decimal;
}

ol ol,
ol ol > li {
  list-style-type: lower-alpha !important;
}

ol ol ol,
ol ol ol > li {
  list-style-type: lower-roman;
}

ul ol li,
ol ol li {
  list-style: lower-alpha !important;
}

ol,
ul {
  list-style-position: outside !important;
  margin: 15px 0 15px 1.25em;
  padding-left: 0.75rem !important;
}

ol li,
ul li {
  margin: .5em 0 .65em;
  line-height: 125%;
}

div.orderedlistalpha {
  list-style-type: upper-alpha;
}

table.simplelist,
ul.simplelist {
  margin: 15px 0 15px 20px !important;
}

ul.simplelist li {
  list-style-type: none !important;
  padding: 5px 0 !important;
}

table.simplelist td {
  border: none;
}

table.simplelist tr {
  border-bottom: none;
}

table.simplelist tr:nth-of-type(even) {
  background-color: transparent;
}

dl.calloutlist p:first-child {
  margin-top: -25px !important;
}

dl.calloutlist dd {
  padding-left: 0;
  margin-top: -25px;
}

dl.calloutlist img,
a.co img {
  padding: 0;
}

/* ----------------- html toc ----------------- */

div.toc ol {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
  margin-left: 0px !important;
  padding-left: 0px !important;
}

div.toc ol ol {
  margin-left: 30px !important;
  padding-left: 0px !important;
}

div.toc ol li {
  list-style-type: none;
}

div.toc a {
  color: #8e0012;
}

div.toc ol a {
  font-size: 1em;
  font-weight: bold;
}

div.toc ol > li > ol a {
  font-weight: bold;
  font-size: 1em;
}

div.toc ol > li > ol > li > ol a {
  text-decoration: none;
  font-weight: normal;
  font-size: 1em;
}

/* ----------------- admonitions ----------------- */

div.tip,
div[data-type="tip"],
div.note,
div[data-type="note"],
div.warning,
div[data-type="warning"],
div[data-type="caution"],
div[data-type="important"] {
  margin: 30px !important;
  font-size: 90%;
  padding: 10px 8px 20px 8px !important;
  page-break-inside: avoid;
}

div.tip ol,
div.tip ul,
div[data-type="tip"] ol,
div[data-type="tip"] ul,
div.note ol,
div.note ul,
div[data-type="note"] ol,
div[data-type="note"] ul,
div.warning ol,
div.warning ul,
div[data-type="warning"] ol,
div[data-type="warning"] ul,
div[data-type="caution"] ol,
div[data-type="caution"] ul,
div[data-type="important"] ol,
div[data-type="important"] ul {
  margin-left: 1.5em !important;
}

div.tip,
div[data-type="tip"],
div.note,
div[data-type="note"] {
  border: 1px solid #BEBEBE;
  background-color: transparent;
}

div.warning,
div[data-type="warning"],
div[data-type="caution"],
div[data-type="important"] {
  border: 1px solid #BC8F8F;
}

div.tip h3,
div[data-type="tip"] h6,
div[data-type="tip"] h1,
div.note h3,
div[data-type="note"] h6,
div[data-type="note"] h1,
div.warning h3,
div[data-type="warning"] h6,
div[data-type="warning"] h1,
div[data-type="caution"] h6,
div[data-type="caution"] h1,
div[data-type="important"] h1,
div[data-type="important"] h6 {
  font-weight: bold;
  font-size: 110%;
  font-family: sans-serif !important;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-align: center;
  margin: 4px 0 6px !important;
}

div[data-type="tip"] figure h6,
div[data-type="note"] figure h6,
div[data-type="warning"] figure h6,
div[data-type="caution"] figure h6,
div[data-type="important"] figure h6 {
  font-family: serif !important;
}

div.tip h3,
div[data-type="tip"] h6,
div.note h3,
div[data-type="note"] h6,
div[data-type="tip"] h1,
div[data-type="note"] h1 {
  color: #737373;
}

div.warning h3,
div[data-type="warning"] h6,
div[data-type="caution"] h6,
div[data-type="important"] h6,
div[data-type="warning"] h1,
div[data-type="caution"] h1,
div[data-type="important"] h1 {
  color: #C67171;
}

div.sect1[title="Safari® Books Online"] div.note,
div.safarienabled {
  background-color: transparent;
  margin: 8px 0 0 !important;
  border: 0px solid #BEBEBE;
  font-size: 100%;
  padding: 0px !important;
  page-break-inside: avoid;
}

div.sect1[title="Safari® Books Online"] div.note h3,
div.safarienabled h6 {
  display: none;
}

.author-date-bib li {
  list-style-type: none;
  margin-left: 0;
  padding-left: 18pt;
  text-indent: -18pt;
}

/* ----------------- tables ----------------- */

div.table,
table {
  margin: 15px 0 30px 0 !important;
  max-width: 100%;
  border: none !important;
  background: none;
  display: block;
  overflow-x: auto;
}

div.table,
div.informaltable,
table {
  page-break-inside: avoid;
}

table li {
  margin: 10px 0 0 0.25em !important;
}

tr,
tr td {
  border-bottom: 1px solid #c3c3c3;
}

thead td,
thead th {
  border-bottom: #9d9d9d 1px solid !important;
  border-top: #9d9d9d 1px solid !important;
  vertical-align: bottom;
}

tr:nth-of-type(even) {
  background-color: #f1f6fc;
}

thead,
tbody th {
  font-family: sans-serif;
  font-weight: bold;
}

td,
th {
  display: table-cell;
  padding: 0.5em !important;
  text-align: left !important;
  vertical-align: top;
  font-size: 95% !important;
  min-width: 6rem;
}

div.informaltable table {
  margin: 10px auto !important;
}

div.informaltable table tr {
  border-bottom: none;
}

div.informaltable table tr:nth-of-type(even) {
  background-color: transparent;
}

div.informaltable td,
div.informaltable th {
  border: #9d9d9d 1px solid;
}

div.table-title,
table caption {
  font-weight: normal;
  font-style: italic;
  font-family: serif;
  font-size: 1em;
  margin: 10px 0 10px 0 !important;
  padding: 0;
  page-break-after: avoid;
  text-align: left !important;
}

table pre {
  font-size: 95%;
  margin: 0 !important;
  padding: 0 !important;
}

table code {
  font-size: 95%;
  word-break: break-all;
}

table.border td {
  border-bottom: 0.25pt solid #000;
}

table.border tbody > tr:last-child > td {
  border-bottom: transparent;
}

/*Custom handling for stafflist tables in the copyright*/

table.stafflist_table {
  text-align: left;
  border: none;
  margin: 0;
}

table.stafflist_table tr,
table.stafflist_table td,
table.stafflist_table th {
  border-bottom: none !important;
  border-top: none !important;
  font-size: 1em;
  margin: 0;
}

table.stafflist_table td {
  margin: 0;
  padding: 0 1rem 0 0;
}

table.stafflist_table tr:nth-of-type(even) {
  background-color: transparent;
}

/* ----------------- Equations ----------------- */

div.equation,
div[data-type="equation"] {
  margin: 10px 0 15px 0 !important;
}

div.equation-title,
div[data-type="equation"] h5 {
  font-style: italic;
  font-weight: normal;
  font-family: serif !important;
  font-size: 90%;
  margin: 20px 0 10px 0 !important;
  page-break-after: avoid;
}

div.equation-contents {
  margin-left: 20px;
}

/* Handling to allow true equations to resize based on screen width (STYL-1022) */

div[data-type="equation"] math {
  font-size: calc(0.35em + 1vw);
}

/* ----------------- inline images and math images used fallbacks from MathML ----------------- */

span.inlinemediaobject {
  /* for iBooks, which overrides height and width on img, per the specs */
  height: 0.85em;
  display: inline-block;
  margin-bottom: 0.2em;
}

span.inlinemediaobject img {
  margin: 0;
  height: 0.85em;
}

div.informalequation {
  margin: 20px 0 20px 20px;
  width: 75%;
}

div.informalequation img {
  width: 75%;
}

/* ----------------- index ----------------- */

div.index {
  text-indent: 0;
}

div.index h3 {
  padding: 0.25em;
  margin-top: 1em !important;
  background-color: #F0F0F0;
}

div.index li {
  line-height: 130%;
  list-style-type: none;
}

div.index a.indexterm {
  color: #8e0012 !important;
}

div.index ul {
  margin-left: 0 !important;
  padding-left: 0 !important;
}

div.index ul ul {
  margin-left: 2em !important;
  margin-top: 0 !important;
}

/* ----------------- syntax highlighting and coloring text in general ----------------- */

/* legacy stuff */

code.boolean,
.navy {
  color: rgb(0,0,128);
  /* navy */
}

code.character,
.olive {
  color: rgb(128,128,0);
  /* olive */
}

code.comment,
.blue {
  color: rgb(0,0,255);
  /* blue */
}

code.conditional,
.limegreen {
  color: rgb(50,205,50);
  /* limegreen */
}

code.constant,
.darkorange {
  color: rgb(255,140,0);
  /* darkorange */
}

code.debug,
.darkred {
  color: rgb(139,0,0);
  /* darkred */
}

code.define,
.darkgoldenrod,
.gold {
  color: rgb(184,134,11);
  /* darkgoldenrod */
}

code.delimiter,
.dimgray {
  color: rgb(105,105,105);
  /* dimgray */
}

code.error,
.red {
  color: rgb(255,0,0);
  /* red */
}

code.exception,
.salmon {
  color: rgb(250,128,11);
  /* salmon */
}

code.float,
.steelblue {
  color: rgb(70,130,180);
  /* steelblue */
}

pre code.function,
.green {
  color: rgb(0,128,0);
  /* green */
}

code.identifier,
.royalblue {
  color: rgb(65,105,225);
  /* royalblue */
}

code.ignore,
.gray {
  color: rgb(128,128,128);
  /* gray */
}

code.include,
.purple {
  color: rgb(128,0,128);
  /* purple */
}

code.keyword,
.sienna {
  color: rgb(160,82,45);
  /* sienna */
}

code.label,
.deeppink {
  color: rgb(255,20,147);
  /* deeppink */
}

code.macro,
.orangered {
  color: rgb(255,69,0);
  /* orangered */
}

code.number,
.brown {
  color: rgb(165,42,42);
  /* brown */
}

code.operator,
.black {
  color: #000;
  /* black */
}

code.preCondit,
.teal {
  color: rgb(0,128,128);
  /* teal */
}

code.preProc,
.fuschia {
  color: rgb(255,0,255);
  /* fuschia */
}

code.repeat,
.indigo {
  color: rgb(75,0,130);
  /* indigo */
}

code.special,
.saddlebrown {
  color: rgb(139,69,19);
  /* saddlebrown */
}

code.specialchar,
.magenta {
  color: rgb(255,0,255);
  /* magenta */
}

code.specialcomment,
.seagreen {
  color: rgb(46,139,87);
  /* seagreen */
}

code.statement,
.forestgreen {
  color: rgb(34,139,34);
  /* forestgreen */
}

code.storageclass,
.plum {
  color: rgb(221,160,221);
  /* plum */
}

code.string,
.darkred {
  color: rgb(139,0,0);
  /* darkred */
}

code.structure,
.chocolate {
  color: rgb(210,106,30);
  /* chocolate */
}

code.tag,
.darkcyan {
  color: rgb(0,139,139);
  /* darkcyan */
}

code.todo,
.black {
  color: #000;
  /* black */
}

code.type,
.mediumslateblue {
  color: rgb(123,104,238);
  /* mediumslateblue */
}

code.typedef,
.darkgreen {
  color: rgb(0,100,0);
  /* darkgreen */
}

code.underlined {
  text-decoration: underline;
  /* guess what */
}

/* Pygments with manni theme */

pre code.hll {
  background-color: #ffffcc;
}

pre code.c {
  color: #0099FF;
  font-style: italic;
}

/* Comment */

pre code.err {
  color: #AA0000;
}

/* Error */

pre code.k {
  color: #006699;
  font-weight: bold;
}

/* Keyword */

pre code.o {
  color: #555555;
}

/* Operator */

pre code.cm {
  color: #35586C;
  font-style: italic;
}

/* Comment.Multiline */

pre code.cp {
  color: #009999;
}

/* Comment.Preproc */

pre code.c1 {
  color: #35586C;
  font-style: italic;
}

/* Comment.Single */

pre code.cs {
  color: #35586C;
  font-weight: bold;
  font-style: italic;
}

/* Comment.Special */

pre code.gd {
  background-color: #FFCCCC;
}

/* Generic.Deleted */

pre code.ge {
  font-style: italic;
}

/* Generic.Emph */

pre code.gr {
  color: #FF0000;
}

/* Generic.Error */

pre code.gh {
  color: #003300;
  font-weight: bold;
}

/* Generic.Heading */

pre code.gi {
  background-color: #CCFFCC;
}

/* Generic.Inserted */

/* Overriding default manni style of #AAAAAA gray for Generic Output with #000000 black, which is better suited to ORM terminal output */

pre code.go {
  color: #000000;
}

/* Generic.Output */

pre code.gp {
  color: #000099;
  font-weight: bold;
}

/* Generic.Prompt */

pre code.gs {
  font-weight: bold;
}

/* Generic.Strong */

pre code.gu {
  color: #003300;
  font-weight: bold;
}

/* Generic.Subheading */

pre code.gt {
  color: #99CC66;
}

/* Generic.Traceback */

pre code.kc {
  color: #006699;
  font-weight: bold;
}

/* Keyword.Constant */

pre code.kd {
  color: #006699;
  font-weight: bold;
}

/* Keyword.Declaration */

pre code.kn {
  color: #006699;
  font-weight: bold;
}

/* Keyword.Namespace */

pre code.kp {
  color: #006699;
}

/* Keyword.Pseudo */

pre code.kr {
  color: #006699;
  font-weight: bold;
}

/* Keyword.Reserved */

pre code.kt {
  color: #007788;
  font-weight: bold;
}

/* Keyword.Type */

pre code.m {
  color: #FF6600;
}

/* Literal.Number */

pre code.s {
  color: #CC3300;
}

/* Literal.String */

pre code.na {
  color: #330099;
}

/* Name.Attribute */

pre code.nb {
  color: #336666;
}

/* Name.Builtin */

pre code.nc {
  color: #00AA88;
  font-weight: bold;
}

/* Name.Class */

pre code.no {
  color: #336600;
}

/* Name.Constant */

pre code.nd {
  color: #9999FF;
}

/* Name.Decorator */

pre code.ni {
  color: #999999;
  font-weight: bold;
}

/* Name.Entity */

pre code.ne {
  color: #CC0000;
  font-weight: bold;
}

/* Name.Exception */

pre code.nf {
  color: #CC00FF;
}

/* Name.Function */

pre code.nl {
  color: #9999FF;
}

/* Name.Label */

pre code.nn {
  color: #00CCFF;
  font-weight: bold;
}

/* Name.Namespace */

pre code.nt {
  color: #330099;
  font-weight: bold;
}

/* Name.Tag */

pre code.nv {
  color: #003333;
}

/* Name.Variable */

pre code.ow {
  color: #000000;
  font-weight: bold;
}

/* Operator.Word */

pre code.w {
  color: #bbbbbb;
}

/* Text.Whitespace */

pre code.mf {
  color: #FF6600;
}

/* Literal.Number.Float */

pre code.mh {
  color: #FF6600;
}

/* Literal.Number.Hex */

pre code.mi {
  color: #FF6600;
}

/* Literal.Number.Integer */

pre code.mo {
  color: #FF6600;
}

/* Literal.Number.Oct */

pre code.sb {
  color: #CC3300;
}

/* Literal.String.Backtick */

pre code.sc {
  color: #CC3300;
}

/* Literal.String.Char */

pre code.sd {
  color: #CC3300;
  font-style: italic;
}

/* Literal.String.Doc */

pre code.s2 {
  color: #CC3300;
}

/* Literal.String.Double */

pre code.se {
  color: #CC3300;
  font-weight: bold;
}

/* Literal.String.Escape */

pre code.sh {
  color: #CC3300;
}

/* Literal.String.Heredoc */

pre code.si {
  color: #AA0000;
}

/* Literal.String.Interpol */

pre code.sx {
  color: #CC3300;
}

/* Literal.String.Other */

pre code.sr {
  color: #33AAAA;
}

/* Literal.String.Regex */

pre code.s1 {
  color: #CC3300;
}

/* Literal.String.Single */

/* Overriding manni default yellow #FFCC33 with brown #AA6600, which is easier to read */

pre code.ss {
  color: #AA6600;
}

/* Literal.String.Symbol */

pre code.bp {
  color: #336666;
}

/* Name.Builtin.Pseudo */

pre code.vc {
  color: #003333;
}

/* Name.Variable.Class */

pre code.vg {
  color: #003333;
}

/* Name.Variable.Global */

pre code.vi {
  color: #003333;
}

/* Name.Variable.Instance */

pre code.il {
  color: #FF6600;
}

/* Literal.Number.Integer.Long */

/* Sanders's additions to manni */

pre code.g {
  color: #005500;
}

/* Generic */

pre code.l {
  color: #CC6600;
}

/* Literal */

pre code.l {
  color: #FF9900;
}

/* Literal.Date */

pre code.n {
  color: #000088;
}

/* Name */

pre code.nx {
  color: #000088;
}

/* Name.Other */

pre code.py {
  color: #9966FF;
}

/* Name.Property */

pre code.p {
  color: #000000;
}

/* Punctuation */

pre code.x {
  color: #FF0066;
}

/* Other */

/* Special handling for sampler TOC entry rendering */

div.blockquote_sampler_toc {
  width: 95%;
  margin: 5px 5px 5px 10px !important;
}

/* keep this body statement last before custom placeholder */

body {
  font-family: serif;
  text-align: left;
}

/* Customizations for specific titles */

/* added for special formatting in Bioinformatics Programming Using Python, 1e (9781449378677.EBOOK) */

.gray-background,
.reverse-video {
  background: #2E2E2E;
  color: #FFF;
}

/* added for special formatting in Working with Microsoft Visual Studio 2005, 1e (9780735649958.EBOOK) */

.light-gray-background {
  background: #A0A0A0;
}

/* preserve whitespace in non-pre elements */

/* Used for special formatting in Using SQLite (9781449394042.EBOOK), which needs verbatim space preserved in a <dt> element, which cannot contain a pre */

/* See EBK-2920 */

.preserve-whitespace {
  white-space: pre-wrap;
}

/* custom class to allow <pre> or <code> content to break (if too long) (STYL-1061) */

pre.break-code,
code.break-code,
.break-code pre,
.break-code code {
  word-break: break-all;
}

/* Added for DOM Enlightenment 9781449342845 */

span.gray {
  color: #4C4C4C;
}

/* Custom widths */

.width-10,
figure.width-10 img {
  width: 10% !important;
}

.width-20,
figure.width-20 img {
  width: 20% !important;
}

.width-30,
figure.width-30 img {
  width: 30% !important;
}

.width-40,
figure.width-40 img {
  width: 40% !important;
}

.width-50,
figure.width-50 img {
  width: 50% !important;
}

.width-60,
figure.width-60 img {
  width: 60% !important;
}

.width-70,
figure.width-70 img {
  width: 70% !important;
}

.width-80,
figure.width-80 img {
  width: 80% !important;
}

.width-90,
figure.width-90 img {
  width: 90% !important;
}

.width-full,
.width-100 {
  width: 100% !important;
}

/* ----------------- Platform-specific overrides ----------------- */

.sc {
  text-transform: none !important;
}

.right {
  float: none !important;
}

/* Fix xref spacing (STYL-1238) */

a.totri-footnote {
  padding: 0 !important;
  display: inline;
}

/* Fix table footnote marker alignment */

table p[data-type="footnote"] {
  padding-left: 1em !important;
}

/* Adjust figure widths without affecting captions (STYL-1238) */

figure.width-10,
figure.width-20,
figure.width-30,
figure.width-40,
figure.width-50,
figure.width-60,
figure.width-70,
figure.width-80,
figure.width-90 {
  width: auto !important;
}

/* Placeholder for custom series CSS: DO NOT EDIT OR DELETE */

/* fonts (keep at bottom); using DejaVu Serif and Sans as a fallback for its rich set of glyphs */

@font-face {
  font-family: "Ubuntu Mono";
  font-weight: normal;
  font-style: normal;
  src: url(/res/dist/assets/fonts/UbuntuMono-Regular.otf);
}

@font-face {
  font-family: "Ubuntu Mono Bold";
  font-style: normal;
  font-weight: bold;
  src: url(/res/dist/assets/fonts/UbuntuMono-Bold.otf);
}

@font-face {
  font-family: "Ubuntu Mono BoldItal";
  font-weight: bold;
  font-style: italic;
  src: url(/res/dist/assets/fonts/UbuntuMono-BoldItalic.otf);
}

@font-face {
  font-family: "Ubuntu Mono Ital";
  font-weight: normal;
  font-style: italic;
  src: url(/res/dist/assets/fonts/UbuntuMono-Italic.otf);
}

/* Kindle-specific styles */

@media amzn-kf8 {
  dl.calloutlist dt {
    margin-bottom: -1em !important;
    page-break-after: avoid !important;
  }

  dl.calloutlist dd ul,
  dl.calloutlist dd ol,
  dl.calloutlist dd li {
    margin-top: 1.2em;
    margin-bottom: 0;
    padding-top: 0;
    padding-bottom: 0;
  }

  dl.calloutlist dd li + li {
    padding-top: 0.15em;
  }
}

@media amzn-mobi {
  dl.calloutlist dt {
    margin-bottom: -1em !important;
    page-break-after: avoid !important;
  }

  dl.calloutlist dd ul,
  dl.calloutlist dd ol,
  dl.calloutlist dd li {
    margin-top: 1.2em;
    margin-bottom: 0;
    padding-top: 0;
    padding-bottom: 0;
  }

  dl.calloutlist dd li + li {
    padding-top: 0.15em;
  }
}

/* Handling for does_not_compile sidebars (STYL-1477) */

aside.does_not_compile div.sidebar {
  border: none;
  border-top: 1pt solid #696969;
  border-bottom: 1pt solid #696969;
  margin: 1.5rem auto !important;
  padding: 0 0 0.25em !important;
}

aside.does_not_compile div.sidebar h1 {
  display: none;
}

aside.does_not_compile div.sidebar h1 + *:before {
  display: block;
  content: "Does Not Compile";
  font-family: "MyriadPro-Semibold", sans-serif;
  font-size: 0.9rem !important;
  text-transform: uppercase;
  color: #fff !important;
  background-color: #696969;
  text-align: center;
  text-indent: 0;
  margin: -1.6em 0 1em -1.25em !important;
  padding: 4pt 0 2pt !important;
}

aside.does_not_compile div.sidebar p {
  font-family: "MyriadPro", sans-serif;
  font-size: 0.9rem !important;
  text-align: center;
  font-weight: normal;
  padding: 0 !important;
  margin: 0 !important;
}

/* Handling for not_desired_behavior sidebars (STYL-1477) */

aside.not_desired_behavior div.sidebar {
  border: none;
  border-top: 1pt solid #696969;
  border-bottom: 1pt solid #696969;
  margin: 1.5rem auto !important;
  padding: 0 0 0.25em !important;
}

aside.not_desired_behavior div.sidebar h1 {
  display: none;
}

aside.not_desired_behavior div.sidebar h1 + *:before {
  display: block;
  content: "Undesired Behavior";
  font-family: "MyriadPro-Semibold", sans-serif;
  font-size: 0.9rem !important;
  text-transform: uppercase;
  color: #fff !important;
  background-color: #696969;
  text-align: center;
  text-indent: 0;
  margin: -1.6em 0 1em -1.25em !important;
  padding: 4pt 0 2pt !important;
}

aside.not_desired_behavior div.sidebar p {
  font-family: "MyriadPro", sans-serif;
  font-size: 0.9rem !important;
  text-align: center;
  font-weight: normal;
  padding: 0 !important;
  margin: 0 !important;
}

/* Variable widths */

:not(figure).width-10,
figure.width-10 img {
  width: 10% !important;
}

:not(figure).width-20,
figure.width-20 img {
  width: 20% !important;
}

:not(figure).width-25,
figure.width-25 img {
  width: 25% !important;
}

:not(figure).width-30,
figure.width-30 img {
  width: 30% !important;
}

:not(figure).width-40,
figure.width-40 img {
  width: 40% !important;
}

:not(figure).width-50,
figure.width-50 img {
  width: 50% !important;
}

:not(figure).width-60,
figure.width-60 img {
  width: 60% !important;
}

:not(figure).width-70,
figure.width-70 img {
  width: 70% !important;
}

:not(figure).width-75,
figure.width-75 img {
  width: 75% !important;
}

:not(figure).width-80,
figure.width-80 img {
  width: 80% !important;
}

:not(figure).width-90,
figure.width-90 img,
figure.width-ninety img {
  width: 90% !important;
}

:not(figure).width-100,
figure.width-100 img {
  width: 100% !important;
}

/*Suppress sect2s from rendering in ToC */

li[data-type="sect2"] {
  display: none;
}</style>
<style>

</style>
</head>
<body>
<div id="book-container"><div id="OEBPS/toc01.html"><div data-type="book">
<nav data-type="toc" epub:type="toc" id="OEBPS/toc01.html.id194"><ol><li data-type="preface"><a href="#OEBPS/preface01.html.file_preface_md">Preface</a><ol>















<li data-type="sect1"><a href="#OEBPS/preface01.html.id2">Who This Book Is For</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id3">Rust Version</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id198">Navigating This Book</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id199">Conventions Used in This Book</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id200">O’Reilly Online Learning</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id201">How to Contact Us</a></li>






<li data-type="sect1"><a href="#OEBPS/preface01.html.id202">Acknowledgments</a></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch01.html.file_types_md">1. Types</a><ol>


















<li data-type="sect1"><a href="#OEBPS/ch01.html.file_use-types_md">Item 1: Use the type system to express 
your data structures</a><ol>














<li data-type="sect2"><a href="#OEBPS/ch01.html.id6">Fundamental Types</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id7">Aggregate Types</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id8">enums</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id9">enums with Fields</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id169">Ubiquitous enum Types</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2: Use the type system to express common behavior</a><ol>


















<li data-type="sect2"><a href="#OEBPS/ch01.html.id13">Functions and Methods</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id14">Function Pointers</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id15">Closures</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id16">Traits</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_transform_md">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a><ol>






















































































<li data-type="sect2"><a href="#OEBPS/ch01.html.id170">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_errors_md">Item 4: Prefer idiomatic Error types</a><ol>













<li data-type="sect2"><a href="#OEBPS/ch01.html.id20">The Error Trait</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id21">Minimal Errors</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id22">Nested Errors</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id23">Trait Objects</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id203">Libraries Versus Applications</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id172">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_casts_md">Item 5: Understand type conversions</a><ol>



















<li data-type="sect2"><a href="#OEBPS/ch01.html.id25">User-Defined Type Conversions</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id26">Casts</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id27">Coercion</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_newtype_md">Item 6: Embrace the newtype pattern</a><ol>

































































<li data-type="sect2"><a href="#OEBPS/ch01.html.id29">Bypassing the Orphan Rule for Traits</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id30">Newtype Limitations</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_builders_md">Item 7: Use builders for complex types</a></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_references_md">Item 8: Familiarize yourself with reference 
and pointer types</a><ol>

















<li data-type="sect2"><a href="#OEBPS/ch01.html.id33">Rust References</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.pointer-traits-sect">Pointer Traits</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id35">Fat Pointer Types</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id38">More Pointer Traits</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id39">Smart Pointer Types</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch01.html.file_iterators_md">Item 9: Consider using iterator transforms 
instead of explicit loops</a><ol>










































<li data-type="sect2"><a href="#OEBPS/ch01.html.id41">Iterator Traits</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id42">Iterator Transforms</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id43">Iterator Consumers</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id44">Building Collections from Result Values</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id45">Loop Transformation</a></li>








<li data-type="sect2"><a href="#OEBPS/ch01.html.id46">When Explicit Is Better</a></li>
</ol></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch02.html.file_traits_md">2. Traits</a><ol>












<li data-type="sect1"><a href="#OEBPS/ch02.html.file_std-traits_md">Item 10: Familiarize yourself with standard traits</a><ol>

























<li data-type="sect2"><a href="#OEBPS/ch02.html.id49">Common Standard Traits</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id57">Standard Traits Covered Elsewhere</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id58">Operator Overloads</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id59">Summary</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch02.html.file_raii_md">Item 11: Implement the Drop trait for RAII patterns</a></li>






<li data-type="sect1"><a href="#OEBPS/ch02.html.file_generics_md">Item 12: Understand the trade-offs between 
generics and trait objects</a><ol>















<li data-type="sect2"><a href="#OEBPS/ch02.html.id62">Generics</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id63">Trait Objects</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id64">Basic Comparisons</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id65">More Trait Bounds</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id66">Trait Object Safety</a></li>








<li data-type="sect2"><a href="#OEBPS/ch02.html.id67">Trade-Offs</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch02.html.file_default-impl_md">Item 13: Use default implementations 
to minimize required trait methods</a></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch03.html.file_concepts_md">3. Concepts</a><ol>


















<li data-type="sect1"><a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14: Understand lifetimes</a><ol>











<li data-type="sect2"><a href="#OEBPS/ch03.html.id71">Introduction to the Stack</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id72">Evolution of Lifetimes</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id73">Scope of a Lifetime</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.algebra_lifetimes_sect">Algebra of Lifetimes</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id75">Lifetime Elision Rules</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id76">The 'static Lifetime</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id77">Lifetimes and the Heap</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id78">Lifetimes in Data Structures</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id79">Anonymous Lifetimes</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id80">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_borrows_md">Item 15: Understand the borrow checker</a><ol>





















<li data-type="sect2"><a href="#OEBPS/ch03.html.id82">Access Control</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id83">Borrow Rules</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id84">Owner Operations</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id173">Winning Fights Against the Borrow Checker</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id89">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_unsafe_md">Item 16: Avoid writing unsafe code</a></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_deadlock_md">Item 17: Be wary of shared-state parallelism</a><ol>



















<li data-type="sect2"><a href="#OEBPS/ch03.html.id92">Data Races</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id96">Deadlocks</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id97">Advice</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_panic_md">Item 18: Don’t panic</a></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_reflection_md">Item 19: Avoid reflection</a><ol>









































































































<li data-type="sect2"><a href="#OEBPS/ch03.html.id100">Upcasting in Future Versions of Rust</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch03.html.file_optimize_md">Item 20: Avoid the temptation to over-optimize</a><ol>












<li data-type="sect2"><a href="#OEBPS/ch03.html.id101">Data Structures and Allocation</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id102">Who’s Afraid of the Big Bad Copy?</a></li>








<li data-type="sect2"><a href="#OEBPS/ch03.html.id103">References and Smart Pointers</a></li>
</ol></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch04.html.file_deps_md">4. Dependencies</a><ol>

















<li data-type="sect1"><a href="#OEBPS/ch04.html.file_semver_md">Item 21: Understand what semantic versioning promises</a><ol>
























<li data-type="sect2"><a href="#OEBPS/ch04.html.id106">Semver Essentials</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id107">Semver for Crate Authors</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id108">Semver for Crate Users</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id109">Discussion</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch04.html.file_visibility_md">Item 22: Minimize visibility</a><ol>











<li data-type="sect2"><a href="#OEBPS/ch04.html.id111">Visibility Syntax</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id112">Visibility Semantics</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch04.html.file_wildcard_md">Item 23: Avoid wildcard imports</a></li>






<li data-type="sect1"><a href="#OEBPS/ch04.html.file_re-export_md">Item 24: Re-export dependencies whose types 
appear in your API</a></li>






<li data-type="sect1"><a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25: Manage your dependency graph</a><ol>

















































<li data-type="sect2"><a href="#OEBPS/ch04.html.id116">Version Specification</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id117">Solving Problems with Tooling</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id118">What to Depend On</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id119">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch04.html.file_features_md">Item 26: Be wary of feature creep</a><ol>











<li data-type="sect2"><a href="#OEBPS/ch04.html.id121">Conditional Compilation</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id122">Features</a></li>








<li data-type="sect2"><a href="#OEBPS/ch04.html.id123">Things to Remember</a></li>
</ol></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch05.html.file_tooling_md">5. Tooling</a><ol>














<li data-type="sect1"><a href="#OEBPS/ch05.html.file_documentation_md">Item 27: Document public interfaces</a><ol>






















<li data-type="sect2"><a href="#OEBPS/ch05.html.id126">Tooling</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id127">Additional Documentation Locations</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id128">Published Crate Documentation</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id129">What Not to Document</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id175">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch05.html.file_macros_md">Item 28: Use macros judiciously</a><ol>
























<li data-type="sect2"><a href="#OEBPS/ch05.html.declarative-macros">Declarative Macros</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id132">Procedural Macros</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.when_macros_sect">When to Use Macros</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id137">Disadvantages of Macros</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id138">Advice</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch05.html.file_clippy_md">Item 29: Listen to Clippy</a></li>






<li data-type="sect1"><a href="#OEBPS/ch05.html.file_testing_md">Item 30: Write more than unit tests</a><ol>
















<li data-type="sect2"><a href="#OEBPS/ch05.html.id141">Unit Tests</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id142">Integration Tests</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id143">Doc Tests</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id144">Examples</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id145">Benchmarks</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id146">Fuzz Testing</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id147">Testing Advice</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id148">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch05.html.file_use-tools_md">Item 31: Take advantage of the tooling ecosystem</a><ol>

































<li data-type="sect2"><a href="#OEBPS/ch05.html.id150">Tools to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch05.html.file_ci_md">Item 32: Set up a continuous integration (CI) system</a><ol>













<li data-type="sect2"><a href="#OEBPS/ch05.html.id205">CI Steps</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id206">CI Principles</a></li>








<li data-type="sect2"><a href="#OEBPS/ch05.html.id207">Public CI Systems</a></li>
</ol></li>
</ol></li><li data-type="chapter"><a href="#OEBPS/ch06.html.file_beyond-std_md">6. Beyond Standard Rust</a><ol>
















<li data-type="sect1"><a href="#OEBPS/ch06.html.file_no-std_md">Item 33: Consider making library code 
no_std compatible</a><ol>

















<li data-type="sect2"><a href="#OEBPS/ch06.html.id153">core</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id154">alloc</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id155">Writing Code for no_std</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id156">Fallible Allocation</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id176">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch06.html.file_ffi_md">Item 34: Control what crosses FFI boundaries</a><ol>



















<li data-type="sect2"><a href="#OEBPS/ch06.html.id158">Invoking C Functions from Rust</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id162">Accessing C Data from Rust</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id163">Lifetimes</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id164">Invoking Rust from C</a></li>








<li data-type="sect2"><a href="#OEBPS/ch06.html.id165">Things to Remember</a></li>
</ol></li>






<li data-type="sect1"><a href="#OEBPS/ch06.html.file_bindgen_md">Item 35: Prefer bindgen to manual FFI mappings</a><ol>









































<li data-type="sect2"><a href="#OEBPS/ch06.html.id167">Beyond C</a></li>
</ol></li>
</ol></li><li data-type="afterword"><a href="#OEBPS/afterword01.html.file_afterword_md">Afterword</a></li><li data-type="index"><a href="#OEBPS/ix01.html.id195">Index</a></li><li data-type="colophon"><a href="#OEBPS/colophon01.html.id196">About the Author</a></li></ol></nav></div></div>
<div id="OEBPS/cover.html"><div>
<figure data-type="cover"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAYmCAIAAAA448DvAAAACXBIWXMAAC4jAAAuIwF4pT92AAEAAElEQVR4nOzdd7xcRfkw8OeZmXPOttvTSEgIJVSpgoigCEpXqkgTEaWpqNh/SlPsFRBeUJDepYTee6+hhZaEhADp7dbdPefMPM/7x9y7uYQk3Oy9SW6yz/dzyeeS7J6ds+XsPDPPPIM33XTT6NGj0zRlZq01CCGEEEIIIYRYqzGzUmrWrFlm9OjRn/nMZ1Z3e4QQQgghhBBCrFLPPfecSdOUiJxzMj0ohBBCCCGEELXAB4BEZPxcIQBYa40xiLi62yaEEEIIIYQQYiVCRKUUM5vKxKAxxkeGQgghhBBCCCHWYj70U70jQJkbFEIIIYQQQojawcwyJSiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUBIRCCCGEEEIIUaMkIBRCCCGEEEKIGiUBoRBCCCGEEELUKAkIhRBCCCGEEKJGSUAohBBCCCGEEDVKAkIhhBBCCCGEqFESEAohhBBCCCFEjZKAUAghhBBCCCFqlASEQgghhBBCCFGjJCAUQgghhBBCiBolAaEQQgghhBBC1CgJCIUQQgghhBCiRklAKIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUBIRCCCGEEEIIUaMkIBRCCCGEEEKIGiUBoRBCCCGEEELUKAkIhRBCCCGEEKJGSUAohBBCCCGEEDVKAkIhhBBCCCGEqFESEAohhBBCCCFEjZKAUAghhBBCCCFqlASEQgghhBBCCFGjJCAUQgghhBBCiBolAaEQQgghhBBC1CgJCIUQQgghhBCiRklAKIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUBIRCCCGEEEIIUaMkIBRCCCGEEEKIGiUBoRBCCCGEEELUKAkIhRBCCCGEEKJGSUAohBBCCCGEEDVKAkIhhBBCCCGEqFESEAohhBBCCCFEjZKAUAghhBBCCCFqlASEQgghhBBCCFGjJCAUQgghhBBCiBolAaEQQgghhBBC1CgJCIUQQgghhBCiRklAKIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUWd0NGHSYGBEYnAPHAAo1AiAo9n9tCZQGhcSg+xZNM4ADAAcKgREcggbQDhyA0xAAYOWWDMwM3P2/uPhflgsZVQKgmZFBIwAu536OAYEUErDmj96Ol3GX5T84JI5ImZAtoEJUi49JBMyMCECATGgsg2ZQzKgVEpFSipkBAWjxvRwCI2jfIiaN1YxZOGJUCJSiAmBANowMQMiOGVGHS78bEwABIoNiYuw1XIJQ1eAJM5ADhYAIDMDKIcQAIYJxAGrxa8/MloERkUgp0oxWKWIKWDGz6uNbTQghhBBCiBUkAeGSEJGZUqUMK4w5jQABkFixD+GURtYIyA5AQx9iNgRWUERtmFgRMiMzgFJKEYEDyCw+CDrGFACYfUv62mSmgImNVkiMyLCMIIqZ2TkVGGAGYEZa4t/7+Hi9xRgAuLA7ZP7o06ESICIFAASsGQKFyMQATET+HJkZmEHZShuMC4A0gAVAUD2h4QpCf2A0jhkRCVEBaFYKcTlPK6FygIpBASpEggTQPycMoBGCFW8HWq0BQDEwIAIpsqFCJABHoMLKS49sA46Zc5Q4VClhwEahRUZwRkk4KIQQQgghVhIJCJcUo1OIoUV2zFqFKUIAoMEBEEAAwI7IlpUCIkCl8BO76wyKQgeQggq0NgAEQDaFlAMMwfSKogjRGUBAYADgvkVozEiMRiM7BmRcdsCDiBgYQABijQjWVTkt+JFHVyEpYGcDUIiqVwCHpJVFJrbGOMCwhKBBBwqQABT0zCUiKLLdvzOgswkrgCBUqDX3cZJ0SUqhS60GrRw6YNLOEANoNn7Gd1knA+hQOQZ2VlGv2U4EANTc9xh9MQfgGABIEQAErNABIDgdqF4vFaNxxBYwzAYKAgJgAKMcKB0jBZLaLYQQQgghVg4JCD+K2TggADKIBn1aH7W1lebM1aUSB0Gay+bWGe6ibAzg53fYOjRquVOFGKfaZZQGsAvmzvtwatOY0UHTKAdAMZve91MKlVrRmIMAfGCnAQnAEhhyoJcys0YAjAyOtNbMgGbFp7w+RoEPAZVhIHK9J/TaFObCIAQIfAxsAAEcp8CglSEiAFBKOQCteuVwGrAAFhwyocWPBMx9ljqnjGJUFAAB5noCqhKAYhfh0qcdLRIqRqMBtAUVwDJu12cEXNZY0N0Jpz749sfsBMh9NFvYmjAEmPfYwzT5w8Clme3WD3fYlR3mrHxMhRBCCCHEylLzPU0GQGA/20fMSmmjAVz7lDeCZ1+edcPdybyp3NaazF8QxEnGaMpGbuiIjuaWsdttW3fQIeZTmwQNTQSgLIMiVggMjAp79fUJGDOYm/LWW3/8m3r86dz8+e8MKYS77rbxL3/lNt6YmBUiEIFS8QsvtN9+u85mgWgFlhAiOsdcKOS22CIYs0606SYABgiAiA0hGGBwyBp821ghMkPnvLntF1+MnR2g9YqmqC5+aABjXWwhrWse/o2vRxuOBWZA9H8GE1/54OrrChwpowkdJ2l7LrfRj06GxmbHqJCAkQAWvvoq3nYbag3MiFC22g0Zuu6RB0NjEyGrKiblAFBrTNKZN16n3p2aQ5xnQkOqZF3TLjvV7/b57qYvgcEwuDSZftWN6Yz3s7lMGJcVAqDiJA7WGdXwnW8xGlAKYflThcSEgEjgELSZPeuDG281bR1RhIlNtDGaqLNcirb8VP7gQ4mJlQJiq5R687UPfvnboi02brdhV5zM+99NuZHXN5/z+7BlWMRVTU4KIYQQQgjxSWo0ICTnmFkb4xwjE0Pq2OjQOEjab7934RVXxffeY4tdMXSvG/N5niUAWAQ0c3YIMOuRhz74x9+jzTZrOeyI+mMOz4wdVwaMyikHRgEhAvhUUmKFmEydPHnfw8uTX0MFMUHatkC9e/krT04Yd/8t+TEbEBESoVIdjz/xwe9/H6x4HmcKkAeYAWBzUL/bl+uOPX7IwYeGWlFaBqU0qSRg5VxAWgcOmEmFwZxZi04/07LrT5zBvQqjDPvidnrDsUAMGtkRGu2mz2j/y987AWzP0who7A9OCBEtMSrrrEalzNNPv3fmmZWcSATQ9U32kH0DRNLMfVmmuWSz2CASYvGf53RNeEkBEIABSAHCn/2s8Uu7siP8eJkWBOUgDbO5iKf+5vSoVxEZBLAA63S2jfjpz12ZICLNalkLNR0QJohKdylbb/T0s05L/32pn8INAFI/VRiEYx98jAkdx45DRMQPps448tvRsd8ad9xxUHZg2rBh5IJf/3r2wYdteM8tkG0EiQmFEEIIIcRKUKNrk5TWWhvH5AwnihCiMDQLHnlk1l57vX/AAW233ATFLm20DrUyWmkFWqHyNU6U1soYrbSKsir71lutvzlj4vY7LDztx+HCeSoTQYrIKarumI4BAN2Hvz2tdfJr+WwUBNooE2WMzYXJpNdm/e63Cv2aQQYAlYm01iqbUUb3/QeNRqNQ6wZtVFl33fVg+9cOe3e/vctTJukglwCBosgBau0CXBxsKqUa6rTWOjDa6Kp/VGBUoHVUAPOxwYXAKK1UJq8DrYxRWqu6wlKimiBQWqswUP5oWqvC0m62IvxJqnxOa6XCUJvAP7cYRcu7lwZTpKFHH7PeyScEADoTaKNUoFRoMNCzzvpjPPE1iFRigZdd+9SR4YA4jetMtOi2GxddelUYBGWjKYzSKKOioAtgyIXn133hs5hYbcIg0ZHSM//w5/DgvYf86KSJm24wbbdt39lm1xmHnND8xz9mxq276JxLwM8hCyGEEEIIMdBqNCBkBgJmZJ2UQ60oLr5/yk/nfvnLpfsfzSjMBbpolEPIpgTOAdHi7jgRE7FzQJQk2BkESRAWFrR/8IdzJn5ud/vwgzqjEmWYtb8xKnQffJjcfNuwQEVJWk45ZVIJm3Jap7F883i3sA0VMhH0VAGFFfxh5wIAICo7W89UMOGiSME997+/x77trz0eaFWmokIOLZNj6KmbCQDgiJ3r509PG6g773SJZ9kR9LrZ0qMa5iVPaqCCHyJ2BK7yp1tKIz/SEOaAig6a/vhH2Gxzii37Zym1RnFde+v7x59sXVcWNS/7OAbAWqtyJp79/oc/+unIJC2Sy4COLEfkTJyO2vOA4d85nmILkQJmbZCLbe1vfzjk2z/iSVMbtt5yg4cf2eC5R5LJj6STXmv5xc8W3nELQM+EsxBCCCGEEAOqRnuZ6MAxk011mCtOnDxt733mnftPTdwa6g6NSUqGQrTKKkSjUStABPIbJCg0GrQGRIfsmNDassYolw3fefPNfb865+y/RkpTSpW5OO4sqa64nbBL61CjAbLkKAgSx1nGtL0LetYLEtNH5sUYGACV6i42s4wfo7VRqoxgA+xCsMx5p4qFoHX6ux/s+7XSa5OMySbsiEgjLicdlQEQ0T/W8h9xiR9WCrG6tX6DC6MGFRsq6bqW0f/+NzEjAyAqBJtyW0aXn32i9bd/I4NAy3wanUoCCB3rGT/8NU3/YFGgwEEIWDZO2bS87shR55/NwMogADCqxECxOG/d0cNh1FA0pnPy1Bmn/HTGQV/Pb/15HjvOmKFByxD+hFWLQgghhBBCVKlGA8JYMzhgk+l67Zm3Djpw/lNPZDIBGx1aChSQQtRQUg6J0tSVLTExKM2snaMkdWAdEecACsyBxojJlUtkTC6NP/zJLyed+qtyqGwMhA6AbBBiri6jgi7nwlQDBBSEoSWlVJtTqpAB6C7ogrh4+o4BkhBChMQRO0qX/ZNYFycWiRNfMQZSyy7qsk2BKc2YN/2kE7DURahQd8cUSw0sCCAETIjZUdmRW+4jfuTHuoylYlpOLdOyjt5Lz14Oy10mid3/vNz5vIGnALSJQhNw4uq/8PmWX/28y5FRWAQM0DiHcUbP/vM5i554grXiNEnAQppaYGeBE5eCBWZMFEa6/aqLO268HsKMZR1ptmwzAEU2w//yJzdufSpTqlSKiKQgZc7WL5g3j9rmxaTNehut8/c/5XKFxu131mE2XTCZFixY/IwIIYQQQggxoGq0qIxyYADhg6lTv36CmvJOcxSpclLUYBVrMjZ0mXLZAKQbbVm/z651o0bl1xvjmhs5jWnmzM7pU/mFV8pPTOgotaYKIh0iqxiYyZLWjTrz4R//nMnUrXv6r5MEAqRw7Lpm7y8mt9yRr4+o5LTVJbTlCDNFCr66dzikmbl7uz3VK5xChIAUZTO5LbcLbEljkFZ26/soBwzGpB/MMTNnxpBYg5oZDMapzUam/MwTs2+6fcQ3v+FsAsuu0KIQkSHcYrNc3TBK4wBcAtyXOSmlgsjGXYUGyDUywJJ703/McrZJXO0QAcAAQhAwOzfy9NO7Hn68/bnnCqHBhHNApDCybdNOPmXrxx+GTBYdM3ACpLQO0SExW4XGxO++Nf0X/1cyrpkMWLcgwkbickK5o7456ohvFF2aw8CRJXQKIk2Uyw/L17eUb7ypcNhROYNmxOjgD3+cctw3t/zRd+bcdj9/cTcEgGVsJSKEEEIIIUR/1GRAyBwAgirNPvr4rncmNoQhJUlJARPX60incZpC8PldWn7yo2jXL2WamnwE43p2kGsCIC6Wp70/94pr5p7/H1g4L4gy9RZTdAlTkcpjdK7tjFMbNhuV/9oxmDgVhCPP+u2M515PZ7xXQshoG6WQSYCGrbfe6WcyIPDSlsyh0pZ4k402fuB2qxBVoAmXOkuEzMDcEXfyE0/NOP1MnvhGiJqJWWNiySB2XXCFOvxQUsssX4qIjrgjyK3/59827vkVShKtNPdt9pgUKE7WIefCOibAtWOpGyKictm6df7zT/rcXpgWCdGQSq21kc6/NmHOGX8dcu4fgsSB0gFYBYlCVhwUEQ3YuSf+zM1dWMjmOS1pxRnMpK5cP3rcyLP/UmTMgIIg1UiaUwINgQLill/++N1Djx4zZvjoW64jMPWf2T77zIsLrrgsvePRsffeIiVGhRBCCCHESlKTASExGZh9+h8+eOxhW9CuyxYVE2IGs51pTEObN/jjb5uP/W6qtQKH5RgUkgJCdqyAFTHoIJfbYNNRv/1d82FHtP/fb+becaMJIGtVyNweUAfFWYUzf3T6+jvspEZv7FIKt9h2vQfGf/CzM+DFV9TCheWWQm6Hz47625l6s82AGZVi55ZoI3bveo+u0KQcAAKqZU6+cQK5QgEPPGSTnbZ5+ZAj3dMvNqAG5cBSVmH5pScXvTSheaedUpcqQP5YWMgAGkGngPkWCLMKsxj0dbMHS8AqF/qjrE1pjQo5oWDrz40849SJ//frxkjblBKAVHEYqvL5/wgP2GHY7geSZZMwKgSny4aygZn117NnPXR3LjKJi7Vj1hpdWgYYe+FfzdARZAk1k7UURAo0ADACWeJPb7PO5efN+Nmfow3/l91rj0wJ2h+4qzh/+ogrLoV1hvttKlf3MyKEEEIIIdZCtdfLdARalV98at5fzi0olXeQsDasWlhDWurYctwmjz/QfNzJsQJrrUpVGkVpEKAOlDIIyigVBqwoIYrRxtnNN1/n1uuG/OKn8xy0hipApQgcE5mgY+YHc352WqpSJkdJV7TZNhvfdfumTz600T3jt3z6yXXvvjXaYtvQlZcz8dMFECITs3EW2SK5Zf04lRIzl1I9fMPNf3taKTKWCRwjotUqtmX39hTbky66rDWECFbFCTBrKCGny3m4yg+QU1gO2JFjx8BqbYoIIdAujKnhpz9a9+C9VZwmocqAaS5jQCrPcfsJv0gWzI4VMGJZBUTA2nS88vKHf/xLo1bGAilLyrA2nNoxp5yU3+9AHbsMc4qkMHROWTKIhpiVxkzsmr7wxfUfG5/dZx/94fS4tTV/yNc2fOzxwjZbg2OJBoUQQgghxEpSKzOEDICpSzUDKcW27f9O02mn0zqIiRSgCdOkDBtsutNd94Wjx7B1kVZsELufIEQADVobAAZGo/zUDnFqrcV0zF/+3lXX3HX6qV1aRSYoOWddms1kum66sfTokY1fPNA4BY4YMRg3DsaNAwAiUgCgo2Wt6mMAA4BcjBBTgwZwOVFBoDQDQNYAc26X3YaPHO2mvZuiisAUgfPg4J23DECMSoNbet4pAIE1iBqRlFZ9myJEAAMKAVH7oYW1Kq2RNeoEkjAa9qffTXv8FVo0TyMUDWuL5SBw706e8cNfj7nmEscQpWSV1Z2lKcd/f2jbgvkZlY0hm+g0IIzTYIsdhp72F51SKYhzmA1Bg4HKfoih0gAAEYBzYTY7/JvHLG4AAxKBlmhQCCGEEEKsLLXS12QA1kjkKFDxs8/MefIFUghEgACGypCUCo3Db/4vjh6TpgkaXSl+gktEOYuLpiArBVopNC4ubnba/7Ucc0LsKCAbOLLIztoywNxzL3NkAXq2ticCR0CklAKllh9B9c7B/MRICwGQARFtmIk22dgwFANMOckwIEBHZxcAGFDLORRB38rILPm4a1UQ2FtKjrJoiXDjT6/zl98GZBPFoEgx5y2kmWj+tVe2XXtZoE1q0yCK5v75b9GLz+ggyJQRlbaGC450FI2++G+mqc66JMBweUsBtQZmto6d838iytygEEIIIYRYuWqlu4kAKZIh0AAdF1/m4iIqhcCOgBzUJTT2tF8VttnZlhOjg74eU4FBZFQ2CIqs1jn7r/UbbV60FGgdokqZ8qjsvY/Eb74OGsERAIBSoNVK7OUzg6Pi5A/LABEHGkH5cjiFPADAAO33XiNYITnKJcbEUP/tb4088ECbuISQtI6ZcynXKTfjp7/qmvQ25qO2x56Y++c/dWVwJjGFQRFsxKpouenXv2jcaVdXKlHAiJ80IY9+30vt/1zLZlyFEEIIIcQgVEMBYZA6CAJaML/tgQdDAL8fHiNox+FW2+R/dEKQcBSYvldzJOeYKACNoIPYYlND06k/SxgAiBxlUDutoNwR3/cAdG8yv2K4Z/s5XHp50Y9JLSCqCa9kpr3jtAoTRwRlUF0ADRuMtX6DimU/1jL/r1Yp0sZBEljNaQqm8ZxzsmM2zFhmTSWkENJyxiSz5876xU9o4fyp3z8pTymgzjtrOQ4UQ2rVbrus+3+nxs6CiRQFCtLVfU5CCCGEEEJ8RK0EhOwjMlTxo4/Fc2eTQmWJGJTCFECfdCJkGstgFa1AMKSUUqgAIQQVhBgS5Y46LPOpLdASK6WcI2RAmHfzzQ6IWTFZoBWYpAsBEjCxozRGSIldiW354z/kyjZJyHIaBuXW+a/8/FepS7JaObYESGCdCdXGGxAsM12xe70igGO2jjBVbBO2S3+4JX4godgxEIAlB0vWSl2jBahBARlwGVTW8pj1Gv95VqBUCMzAMXIpZR0EpfsffveL+0ZvvOkUBglrBVnAgKDU0Dj6nLPTMAIFqJVWuHbV3BFCCCGEEGuDWgkIEYi00gDJ2y+DS61RClgZRZaCIcOG7vfVFJI8MitFfZ4iRA8AFIBici4Mco0H7OMAGBGAwLFlgOnTbNtcVEiUEnMfgwIESAFM0BhqZTIaIoM6iyazlB+d4TBUwJ0PP/ze/l8NHn+YNLrEInIQ6si64Z/6VGHHz5IljcBLy0JEZodYzud0NjBaUSYgE6JZxsP1+gGTsaEKNZeB0rVvozwEMDoDxoAJVcCJG3HIkfkTv11MXFajIshZh2w5TezrLziFlpjJWdSOVdHRyN/9unGr7TVRhEYpUFoD9jUbWQghhBBCiFWjVqqMAiAqTcAdk95lAAeQGnSABiDcdFwwZlSZSwiRBWLwZR9XlGZOFXD9NjssAAzJ16thBRAvaC+/9mb0+RGOFGhUwKYPa8OI2GgIP3jrtV0/VyAEpgSij9+NAQLmCFVrOS299GIeYh1omzoAMAqBgRmGnHgMZguq7DjUCuwynh7Op6XZP/jxnLrmPKftqKk7qXZ5GEArTNLOkX85p/ELOyvLa+sbKlWslHOORvzhb62PPgtvToyUCdmVHKcKQq2ACAEYIIc6sUnz/nsP/f6P07INorX0GRFCCCGEEGuFmumtMgKidcX4zUkAEDh0wAmwASh8ehvHHHLAChVi1YVXlAECzH16+6hlmF0wB5UCJjQqjeNkyrvw+d2ZtAbUfm3gJ0FgRkja2unxZ0oAGpaejokAJYAFABqgXquS0c65DAAqdKhcYsMddyl86xiyDAaYyW93v7TnB1zqOl97HQGKH6+tusxGAgCkAGHHQgWQOhuYtfMdZQBTpRxh0Ni4/rl/e22/Q+qczSFEYC0DMAEAAyil5pKtHzZ0zDn/sGh05AD79HILIYQQQgixWtRKyigAEICNy2rWAgMQkQoRwghKAOGm4yJERSpRpICrC2gYGBCYwI1ZN2huXBwBKIUA1NWeAmhA4xz2NWkUtMVSEOhMthSZxARgAu75AROACcGEpENlwnwYQs6kEWQsBlaBUWQ0W9dYyG94/r90psEhkU6WM+WnCJRSJjIqCiETYq/HWt6PDrrygdWaQs0AbNbayAcZrFMBaZV0Zr+897o//N4Cl1itiaFy0oiIgDmiYf/8Y7D+5rqcIEsVGSGEEEIIMajVSkDoS6oELtUdxQTAGU5Ag4McANU3AoACDkAtb5u4T3gARgaTAmqHKuy9358CMEgJACDYPs8XMYBGNC6Nk1I+sYFN2TqwDqxD62J0yqWxTQ27MiScJlC2URlKSByFRa1tYtOm5qbb/pfZflsmCrSKMMNKLXV6kAG0gkQRkIUk0TbR1lYebjk/7FyUhsaRIsMAitbagBAQcoHSAaDJKqJ1zzi1abttyzYuBSYhUKACCFKN5Fx09PHDDv+Oc45CBVa2jhBCCCGEEIPa2png93EMhKC1jtJ8jttBOwcEqMABmGIRKhU4q+69K2TQHECGnSObApju2AsdAFmTAyBip/s6PagAUgwcQp1RXUjIHHB39E4AAVhjyFoC4MhiqBQCOeZ6C4ktK4Cmz+3efP4/MttuQ8Tqk7Y9RICYkFUmAFYG2rUNlerLYAEjBIGNWDPGDGBobR9fQADUiojrGje64B8z9vtaunCRUuiIU4WYktvsU1v85jSHXGYX6VDLBh5CCCGEEGJwq5WAEJCBmXRYHj4EZ01XCoAA2CSQpFOmArOvGcrMWNUkIQI6ZlKgps+i1nYHYHxqKDsG4EwjAiCT38i+Lw/AAIixYWiLgQEi+MgedhqgDNCoMEa22qRgOVCYQJwL81tuMfI7x+e+9U00GUrKJsz08fnJUhwTAUCYLqvyzNIaGUMRoKVscwCkcW2PCAEAQGHiQO24c/32O3bcd0+XVhqYNAYOcl/aEzYYkzirdSgzg0IIIYQQYvCrmYAQgC2rMJPfZIOOV14qG9BWGdYhQMeLrwxFVEwAUF00CADAoBxrA+2vTErnz9UagAAAyFKkdbjhWAZw2gYc9XUSElERx2NGr/PNIzMMDgk58pOOCNCFOZw+uePaqxSCSUlpKAM2k3q/JbfxDZebMVuQ5bBs4wyYPtSwYYAQgbWqP/IwveFmeVtyiARLzy9d8r4YpLZTb7S5daRVraQgG2cRoAOCGMARBoghuwRAZzQzh4xIjAisJGFUCCGEEEIMarUSECIj2xiDbN0mn1oEN2oEBHbsFEDyzju2dSHWNwbEDMCqymkuTAENdL31GnCKQeBip4yG1AbDWqLNN0mZUWsAZO7bQkVER0wNI8ac9WcASADCXv/IAOQ6Xnt3UvLU07kgBHJB6jqVanh/Qdfv/93y73OILaMxLmTdl5KmCARlNKO/+/3C53bmFV9aagHQsq6RcJARjTOOQ6IyQIY1kY0QGMAkJY0I7Ku0MlU/wCCEEEIIIcSqUCNdeEDQyjgG0JtvnUeViVkpx5SQUcUPP1h4282pUmk5SexSN3foA+Y01NaWOm68AQEcMYCOlQoAcNT62ZEjA6JARaBU30OEFKChtICtS+I4jBNO08U/XUWr6jY+5+xMEKbsLKMiRkgCpT68+PzyI49gEBGnqKgvc1QIYJG1i7mtDVIL5SKn9iMPt+wfSC1bZ5i1QaiNjFFAQNQcZAgSA2C1RQSrgAC0D9s1gALAGnk6hBBCCCHEGqxWuqyEQDpg4PzuO5ohw5GYu7vrqAFK/72cKLZRqDQBJVU9AJQ1tt15H0yY6EJQqQ0RFDgEaNprT2DmPu820RsrhUZjYCAwGASVH8iHmFJ++8+0HP/NwLruZYkMoJARZ512Wlwqah0w44o8KqKuPNZHHm45PxAYNLr66qxrtto8ayGEEEIIsfaolYCQAQi0ctYMHcG7fjFG9FN15Fyosfjk0+1XXRZpVDG4T6rJubSjEyDki60LfvunGFzAGAAAc0DUEWZzB+zvK9YM7PmgYrLQ8NtTefRoJkCl/OkUtC4/+1znf/+jAq1SlpBFCCGEEEIIsSy1EhAqIIUKLRmAdY4/VDEDdRdosYys9MLTzkqnT4VcqFd4L3Fmx6DVh3/6e/srz4cmwBSdRmuUTblhlx3DbbZiZqwizlzOQ5I2upS6cmbI2KazziQiP0enADpZaxPM/dOf42nTINRAtKIHH0wx5MC0hYF9fRzZBUIIIYQQQojeaicgVBoVBAE4V/j8nvW77byAKDDZVBkDxAb0h7PeOfY71LkgDUxqyxZSJnIMxMAWgAEcEbFjYAYmdsAxA6VMSRmNnnvdtfP/+vcoMESOgFMKnHIEevjJp7ggBOpjJZk+n45CgEwQaCRa5+hvhl/cuWwd6QwihJTGGtWsuXP/8HeFSOTYJilYIoZlx4aKwUDIGBCAc0BMDNCXH+ccE1PKQACuvwEXA2gAUsbv2IguYeC+tYQZLENKLl0iORcZQhXEBjSAVi4FX9nnk4+ZgCNmtkAWqkr4FUIIIYQQYrCrlYCwm1IAoLL5IWecXg9hDihERsAwoTSv7COPvnfg0ThzRmAynGJMrMoJOEtIDjhVCMoqKAHEjDG4GOIya3RhdtYV//nwG8dGaQzOWSZCzgVUH7vcPnsUvrJPJiXUAzzrhgiIRqkAAVAH6/71r3UmF2GaapVnsGQ5UDOvurzjgbtSE1jQwAaACQlgaasKGZyCVCcIXUBkgRw7pk/miBIkpkRhbFUpVSs8u/rx8yIACByrIhExWKa+NIQ4ZUyUY02oILXdETgDACCAIgLNAJAthgGR68sRibQlZVN0ZcSyw/6emhBCCCGEEINQjQWEAKg1Oyp8ca+m75zQmsbGQAKYKKVibs4G8x+6Z+Kee7c/fI8LjDXaYoBIDtKUUuVIpcikYlLl1CjMRJkMt86Z893vz/3WSREkjAjMCACIyrn2XMOov/xOmdASrcQ0TKXIuWiHzzWddJxLndFhK3Lk2ADmk+KsU0+NinGitUqBsXuScqlNQQDmjI3yrFQYZAIVKKX0J/0YpSIVsInIZJgjzUH/T4gAUowgmweldJD/xDb4HwyUDRWBYqWTEEgB9uy/6BQUlQ0SLALMz0eslDFBX46pTNAehHGUQZ3BmtmgRQghhBBC1JRa7OaiQiAa+Y/fz3vxmfjVl/KRYQsxYntsc5FO35g4ba+vjPzGN7MnHs+f/QxCGAKkABoAAAgMA6CG8rzZ8+59oHTWn7umvAkBZlOdoCUARDBKzWEad/Zf67fcnso2zeiV+iyjQuNc7vRf0u138YfTXKBDR8qSDbV94dU5F1407Kc/IHJIyOhALW0dHQIR5CDA99+DmR/YOGWFfdwfw6HKYJKkzgwbi9mov+cCYAGi2MLUyTS0zTIqDmA5qa4A4CvsQOKoHIzYGMLIOIRg8UQoA2tUxKAACh1z3MwZlMR9WdJpHJPpVAmUs0PtyBGFfp6bEEIIIYQQg08tBoSASI6woWG7a/875ctfjWd9CIEJHWTQJLHVRgWWpl9+eeaa68Jtt6J9Dxyzy2e4uSFVRlnnnLXvvjPnjnvdMy92vTelAUCHYRe7rKIUIMPKad2eppueeGzLCcfblEzA/Q2S+nA6iuL8sJHr/OHXs47+Tp7CLooTUMgBaJjx1z/XH/LlaPRmjhKlNADhx2qrIDFrMNQ+85f/p/QZaFWqrOrLujlEB0Hexe2Z3IZXXZrf+YuaGFT106FMrBWEcz5465CvZ8sWVWjRAX9SXRxEbR01rLPBdVeqbbdCB0HPOTJAwBg416apoKHt0htmjb8ztEXuw5ytAqU1mFJiDjhi9MXnsr9PjW6wIYQQQggh1k41GRACkAZVsrj5NiOvu3j6Ed8uz5rVGAWdzAjKEMUKM0pRGheff0E9/8JkAD8riG5xmKEAcoFKnQYXRlwmBGWUtdqkafORhw47+3wmQIOAwcrOymXAFLRO0sbDv77w8mvsQw/rwETWOZeQATN35owz/zX2ivMgodSEGe3oY3EeI2iCLmCYOc//I37irFz3Q4MG6AQIITTEGgCY+5sfy9DFpKfNiFfkQA5At5UpsBkAqxZPD/rot4ycJbAASftc1Q62DwdEgBSAAQPgXOsMBATm2suwFkIIIYQQa7ma7eGyinQ7Ob3r3mPGX5fbZDOOU0AHoWFGZGbnUKExSmuttCatUlDOKG20MtoYjVqVmFJIyXUa5VBj5KDo0hE/+sG4/17usjnEVTSbpIADrQk1msLwP/2pPd+Ydw4RFFGYoorC2dddVr7/IZ3NOCSAZYZZCIAK/fo5XIEfrZTCMBzAk0UA1LgCzTAalcJoeW3wIaJS2PdTU1qpTKgUohmAtZFCCCGEEEIMQjUaEPp94utAo6P6HXcd+/DD6uCvBzFTKaZQASpABGZ2RM4BuYA5AtbE7Bw4x84BUZPVAaAxOscMie0cMmzcFVc2nPOvUiYLPRsD9r+ln3gLJlYW0kAlqa3f4TPDv3dCkZhQWY2JQkSqS+N5PzuTSsUMIvfOlfx4C5mBaMV+/F2Wk16KvR+rz88JVdGSPhx2xU6Qwe9X2ZdNJySTVAghhBBCrIFqNCDUpAAA0WUVpklqRraMvfH6hv9eGozZII2tDwYwMKA1KEAFyu8+TwyADMhKKWMWRJgQZ6xrVTo89PDNHn80/82jqcyBI676eVXo95TwP6ovmZtKpQiZhAwQORr+q1PcBpuDcypQ6MhaDjKm+Ppzcy+8kDQCdwdvCIzMvR+ruh8EZkTkpYWX/jbd5U3Z37jXzbqjrO6/7H9LeImFgagqbajyh9E3fhnBngLAxY+OgH6cQQghhBBCiDVGjQaEAAAKGJEQTKhDa7WDdb9z7KdeemrDf/yDt9kWA0OJddYRaXIBcagxIIOsOM+ccdSVWh3boKlRHXXEJo88sN7/rg3GbWKcNSFopVRVTyw7ImKKEyZm6zTzQi4QsyJVWnakgQA60FqhNloBZJvW2fBXP16kdVh2CVBqXblsLcC0P/45efVlUKEFpQBKFMUEzEz+Qav9KROHzJ3oXFp20BMWIgCATRNgtlzWjjWxYY4duKQTINEEjgNCUACdmHHMbF31zXBEzAkoVaIUANkSxGg7WwmYWdmUqzwypC5mZpeCA+LKS8AA4FTa2qbAMgexU86VyVrm2KYA0JeKNUIIIYQQQgwGNVpUxlfC1D3pjGCyAADOwZARjT/5ScPJJy969on0wUdKT0+In3/SxUmaxAYgYO0402kQx40ZvdsOmS22bzhkHxq+IQCA4wAJtIHqgmytAaBu373Wa7pEZbK+io2y7eXciJQ4JGWUA9TLPBsAMKhAg4Yycf7oIzYfM4Tmt9WZfE7HyrLCzNy0mIYBsrKKFXBm5PDRV16q04RVd9nRvmRcfgymVud0WjQYbbIVQ/cTC0oBAG213ZjLrsIWdrEmCkwaAxTKhaHMQYYQDVjlDHPDF3bOXXsVGlNpwgq3BBEpJaPNeutZYmTLEGGYG/nb36nZMziygcr0Ke3zowfVCbq8DbssDd/AMkYI3ZEuAnGUaBjxf6eqI77hchRyoLJkFrnSplvFAJHMEwohhBBCiDUEPv300zvttBMRoSS8AQBzkjhSRgcQAFiCZP4HUC7Z9g4olZ0KguYhJsxCXS6sb3AAhoGYrKOIFYQDPN1aAggAdAqsWaEF7FNpE7YATBB0b/7gfI2WnnqbbDk2AMAhsIZlRpgrxAJoHyo5Br34LUQWlAHoKViaAGiAlCBACAgscKoBgSJQy0zK7DMGSAAMgCZwKlHWACg0AAApQHU1Ybjn2dMAHAP22j+EE041hhoAoB2gvufvHQA7MAPzvAohhBBCCLGyEJFS6plnnqnVGcJlQVQRM8REKinbIIxg2GgDkPvYDdMk1c66UKHmCIhRI/R3x0FmYupeNIgAhhQwICsXsAPdx6jGmpRcObLGETitNQM7AM3sWKnAAQaEoNCSVb0mzaqeIgQgbR0ajLVDHYa9gi9km1qHqJkgcBywc2BzQQjaMYZMGIIiBsup6bXmcoVn8vy9CAJSoIAMImunU8NAjpkxIEVVbY1oiRUyoysrUJHpfWpgkhCBHYCFgl/pqZgVawTQQU1nYgshhBBCiDWKBIRLMhxodgxIIQJTjhgYAAiQyPf6fRkVrchkANAlxAYRB2C6DUEBKD9bxgCsrNYqpsSwQexrjKHZaCwAozJMyIQYIFsFzrBmpQGRARwZ1ICqUhwTAbiKoAmhDM6oQAOGzMwfCYWSQIepjhGMZqeIMUIIHSKB1qCMQXSsGUDpj2TDVjVZiAoInEVSDIEzCRrFAErFGgLLRlUToYVMqVHsICAg9ZE4lSFgANYAGpG4CA6VyTpMFGMfZ3KFEEIIIYQYBCQg/BgERI0A6iNRhIaPzvss3n89UANWQwQXR0YIEIBGwFAFK5RRqXxVTAUIGAAyAGjUPqtz8dYPSwmQqjuJDGjobt+SCcchIAYQgf93xd2/gK4s3tQ+H3MAmgEACnTkj6wg03PYLACYajOhlTIAYHzWKH70X7qfQL9sMuufTw2BlJMRQgghhBBrFAkIq4RL+W3AHwIrf/bjIIv/XBmWc+QlHnplh0pLPX4/H/QT747L/V8hhBBCCCEGOVnsJIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUBIRCCCGEEEIIUaMkIBRCCCGEEEKIGiUBoRBCCCGEEELUKAkIhRBCCCGEEKJGSUAohBBCCCGEEDVKAkIhhBBCCCGEqFESEAohhBBCCCFEjZKAUAghhBBCCCFqlASEQgghhBBCCFGjJCAUQgghhBBCiBolAaEQQgghhBBC1CgJCIUQQgghhBCiRklAKIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQiGEEEIIIYSoURIQCiGEEEIIIUSNkoBQCCGEEEIIIWqUBIRCCCGEEEIIUaMkIBRCCCGEEEKIGiUBoRBCCCGEEELUKAkIhRBCCCGEEKJGSUAohBBCCCGEEDVKAkIhhBBCCCGEqFESEAohhBBCCCFEjZKAUAghhBBCCCFqlASEQgghhBBCCFGjJCAUQgghhBBCiBolAaEQQgghhBBC1CgJCIUQQgghhBCiRklAKIQQQgghhBA1SgJCIYQQQgghhKhREhAKIYQQQgghRI2SgFAIIYQQQgghapQEhEIIIYQQQghRoyQgFEIIIYQQQogaJQGhEEIIIYQQQtQoCQiFEEIIIYQQokZJQCiEEEIIIYQQNUoCQrGWYObevxOR/5vev/v/XeKWH7/7YEZE/pclTmRZt3TO9T59IUTNqlwS/S9E5C8OlauKEEKI2mRWdwOEGDCVng0iKqV8v8c5h4jMjIi9b+l/8f/knFNK9b7BoFU5l8qf/u8/HvL5p0IpGfQRQnTHgV7lArJGXPSEEEKsbBIQirUEIvoQiIiA2fX0dZRSywmKfLiotR78Y+S9R/d96OtPDXsscXullD8pZpawUIga13uATGsNPekDAGCMkfhQCCFqmQSEYs3Wu4vjwx7f16mI4ziOY2ttmqaVXCmtdRRFxpgoivxg+aANmXxaV6UP9/Eem7W2WCwmSWKt9X/jbxNFUSaT0VpXenuruOVCiMHAjx/5C0jvy+MSFz1/IR20V0IhhBArT00HhIuz7KSvvIReGZWruyHcuxmV/EgiAkStFCIaYwAgTZIFCxcuWrhw0uTJ77z99qxZszu7OtMkaW1r6+rqiuM4iRMiB4j+LvlcLk3tF3f74plnnmmt1Vqv4qip98MxM/Q8MgJWcl99lOu7aMVisXXRotbW1rfeevvNt96cO3duEsft7R3FYrGzsyNOEmstE6HPfWWur68vlctHHnnkSSed5JxbIk4WQqyVlriO+c++1rq1tfWtN9987PHHp02bliRJuVw2xmQymeHDhu36xS9uvdVWw4YPBwByDnvlz8tYkhBC1IIaDQh7F+SQLJmPYwRgqOQlrsZnqPcaOUR0RACM0D1dZq2dNm3aww8//OEHH7w18Y3XX389SRLnXJIkvliCUsporXrm1jz/6iulFrW2jh4zGlbfQrve4W6lzAOi0kr5EyyVSlPffffJx594b9q0119/fdKkSWmapmlqra1EjH5Q/+Mv0yzEBQsWfPELu66GExNCrA6VhAJ/NfCZBdOmTbv6mmvuufOu9997zzlnrVWolFb+xlrryy+5tLm5eZ999jns8MO322F7APBjZL3zS4UQQqzFajcgVEp1p9j1Ls0hAACAiVGhjzFW+wixXxzoA7wwDAGAnHv4oYefevLJhx5+ePasWQsXLrRpmstmoyhSShljstls5e5LrSnqezlxkvS+5SqGiNZaY0xl6aNCNNoAQFdn12OPPfrM08888MADra2trQsXxnHc0NDg8z+NMb0j2CVi5sr/GmPy+bx/xoQQtaBy0SYiY0ypVLr4Pxf9+9//njV7dkNdXS6Xg6XlfRBRV1fXZZdddsvNN39l//1/+vOfrTt6dBzHQRCsjpMQQgixqtVoQOj74lrrKVOm/PjHPy51dimtQaJCDzG1tr6h/tprry0UCs651dscP6HnuybT3p06fvz4u+6665133il1ddUV6pRWzY2NleLpPr76xDb72MnHmavkJJbeBl/Mxr8VfeLrG69PvPHGGx968MF3J09JbZrNZoMgKBQK9fX1/k3r471lnWDv6LcSRa+a0xFCrHb+854kSSaT+eCDD37w3e898cST2WxmxJChxMu7MGqtm5ubieiaq6565rln//HPf+68887WWllSKIQQtaBGA0LoSSAkoknvvNPR2ma0Juk6AwCAQkzIFerqVnvhTV8wJggCpdQLL7541RVX3Hf3PYsWLYqiKJfNFjJZcg4AbJxqox2RMcbXzVsjOjH+7ZemaRRFAPDQAw/ccN31jz36aGtbWyaI6goFhZikKTAQMBBVygBKjCeEWBbnXCaTefvtt7/+9cPmfDhj+NCh1tpSsWgCs9TV8pV8GWNMmqaNjY2zZs064ogjzj7nnEMOPjhN0zXiciqEEKI/ajogBAClVCabpbS7psjqbtSggIiBtXX5gkIFq3x9HXcXjkFr08AEQRC88frECy644O677+7s6KgrFJqbm51zzjnq3lmBUaMjp5Ty0aBf8TII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9MzKaiK69dZbL7vsshdfesmW43wuV19XV6ny4j81K+NtUMnm8i0h57RS9XV1CJBae8cdd9xzzz3bbrftt4751lf3/2ommwWfkbgSxieIe0qeusXpr32Ci29cxaWpMuPtA3IAUIiumpm5xZgZtWLmJI794q4+3lGp7k3gtDHOOXIrHhAykEIgZ3tmkpd1BKUUMW2zzdaf+tSnXnv11bpCHVlbRdZG5fhG64WLFt52661bbL75mhIGMJHWet68ec88+2wmk4nLcZWFprt3/wRidtYefPDBgOifhIEdQavkEcyfP/+W8eOvuuKKdydNds4V8vmG+np/ra7MB/o120EQpGk6UM0wxlTm8BGQibVShVzBhMHMmTPPP//8a66++oADD/zGt47ZeuutAcDfeI14MwixRpOAUKyY7m8F7l7szn38jsDFkzlQ7TLxyjKn7qUF/ft6YgRWS6ZJd6cUEisGQGTVhy/3nsS5fq5zqDwzSilWqv8pZ8ysem301+/jAfQqG+MP68gZE2itZ86cecWll1191VXz5s/PZDKNjY0M4Kz1EQL0JAv53sbAxoSVPmt32wAZOLGpQmSAMAxbWlo62tvPP++8m2++6Ygjjjzm2G+NHDWKHTEu7omuEWtUKtmMlejF1+yx1t5+++2XXnzxCy+8GBiTzWZNJuufat+Nw/5t97J8lbUG3fWEiAAgTVNfmaapoYGIXp3w8g9fePGii/5zzLHHHnbYYT6/F3sZoN4/U88PwArMr/ezAdxT1bb7w+s/yP18sivJdcZYa1ck1RkBgByRc0opp2iFP/kIitkwqJ5dVZcVWvtPdC6f3/+A/V95+WVUyFVVQKkMulmmMAgee/iRU374o1whn1prjBnks/n+nXPf3fdMnzatpaXFpraaMjDM/nKklCqWyutvuMEXvrgr+y/Zas+/99I7ZmZgcuRrwCyYP/9/199wxRWXT5o0qa5QVygU/MhRpRBX5Qrvs2b8ks7Ke7s/KjvQ+gciZEtOa+2cs85moqiQz6dpeuWVV952++0HHHDAid/97kbjNoKe1JL+f88KIZZFPldixfivp6q3X1/ilyrbsNK6tov/ZwW/+fpZe71y3/6v0/jIMQc69KrMo3qBCbo6O88555w9v/zls//xz3K53NLcnAnDytRE73NZqWtrK/OElYlo/8CVnfFaWlraWtv+8fe/77/f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LQDU19fX19dX/UBRGKZpGmYirqrZ3bN5STJy5Mix66/w5XEt41+RQw89dPwttwTGlOK4itVclcWuxpj2tra777579y9/CfpdSbgKCOCItFbTpk57+ZVXcrlcP9/biFgul3faaaett9na76nT53uyc+53v/t9sVRqamysehfEisoHHxHbWtv22mevM878zUbjNvIDYf7ioHqWSg7IpclfbfxlZPSY0edfeMGee+99xplnzJoxs7GhwfXvjPzKzCAI6uvrzzvvvD323mv99deXaFCIvlgzRhzF4MHMxEzWOevIOftJP6mvJmktAIRhmCRJf67OSqlSqURESZx84kN/4o8HPVO7vVcB+WzSPh6HiDo7OohJK111R8E/uta6VC4TUZKmA3J2Pgl2WQ/qY79LLrn0rbfeaqivr6wEq6L9ldSd7t26nIui6Jxzz/3nv84dPnx4OS4TE/YMEkPPxNFAfU/7ta++3AIRffs7377l1vFbbrVla1ubn42EfvQj/Ts2m81OnDjxkv9e4kNZ6rXv9opChX6GUGt98003Pf/cc4VCoXdB+eoaycy976y1bmtrq6srnPGbM++4684jjzoyl8/FSeLIEZMJAsbF63aWn3JWGSuBj+5D7St/WucYcZ999hk/fvw5557b0NCwqLU1jCKlVeW1riIdoPdD+zL3kydPGn/zLb3XO/VuMzNX80mx1r9nfMpD1Wu/fWMymUwcx0SUpP26QLnuX6x1LrXp6t2Crwr+7fTZnXbaYostOjo7dbW1PSqThIW6uocfemj27Nl+WSmswulBAGBgchaVeuiBBz54//1MJtPPoBQRkzg+/IgjAIGI+pijTERa6dtuvfXRxx5tqG/oT3p55bPjE1Cdc3Ecn3raqVdedfVG4zaKk8QRaWMQVeX2A/uE+4E8R5Sm6f4H7H/77bfvseceC+fP1z2X66r52U5jzIL588877zw/xEnEvAbVdRBidZCAUKwYRFQKldHaaKW16euPIef6md+CAMgcGKOUUkbpFXj0pf9UNkOv7IznfwcAv8NSnw6ilFIqCAPrHAH3pVLcxylEZLDWotasUCnVz1OrnN1S83x8POOrdU+fPv3KSy+tL+QrBRuqeWkQKy9uFEXtnR2j1htz3f9uOOzII/yW4lEYKaUqm8tXIooqHuvj/Mvn4xPfn3DOfepTn7r5ppv22HPPufPm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0TZAKkUpHThwoG3bmRft1EQzxpSUjuMUFhbW1NTccvMtI4844qabblq1ahU0qIBiM1JKLDmDEEIIIZRTMCBEhBCitYYeg9DyW0lpWVYqlWKM3XPvvWecfZZUinHYNIYRYavHKdNaDx8+vFOXLtF4PMOYkBKqtCKMEkZt4XDDKC4s3LZx093/d8fow0f+6eRTZs2aVVFRwRjjnDPGHCGElEIIqRREiQTLzyCEEEIItRDsQ4jqFwOVUo7jQOcAy++vrKwsKyt76OGHDz50sFKKN3FzOdSclJJak247dR84cODMGTPCgYDI0mY/SqnSSgvl9/uDoZCS8rW5c2fNnr1Lz54H7L//2HHj9t5n765du7o/7zgO/BYksmKPQYQQQgihZoYBISKMsfqFQaUCgYDWuqKyctCgQffee+9OO/ewU7bls1r6HFE2Ucq0klrrE044YdasWSrbS3NKa86YFIIQEgqFQoRs3rDxf2tffPH5F7rv1H3P3r0PGXzI4SNGdurU0R8M1P+O1lIpkt62ihBCCCGEmgcGhIhoraGHhGmaiUTCTqXOOvusy6+4IhgMCiG4gVVk2hrGmFZKK33AwAOHDBny7jvv5OXlZbEiqNbatm2fZUmlpJQG40GfLxIMCim3bdm6ds2aN16bd8uNN/Xt23effvv1H9B/2NBh4XAYyttA9rImmhFKMThECCGEEGpiGBC2I261GEjP00pxbiitKKGMMsLo1m3b9th99xtuuGHEESOV1kLKrJSgRLlGE804V0pZlnXu+ed99NGHSiuSLkCa+fGhFK2QkjHGKCWUOkIIJbUmls/y+X2EEK31woULF7z/XigUKioq2mfvfYYNG9p33337DxjgJo4KKSihlFGtCSYtI4QQQgg1BRzutyP1caDWkJXHGNdKWaYphIhGo9RnnvXnsy+++OKioiJoRs+ww0QbBbWBOONKqUGDBh07ffrDDz3UsaxDKpFw281nwr3GtNaEUqUV5YwQQilpWGU0GAyGw2EpZW1V9TtvvfXq7NllZWW77LLL/gccMGTIkN333LNrt/rdhlJJIUTD+re42xAhhBBCKCswIGxHoJDjT2Eh50rI6toaovXBhwy+9MrLBwwYQAixbduycNNgu0ApVVpfeOEF776zYM2qVcVFRclkstliLaUUxIemafp8vlAopLVeunTp0qVLH33kke49euy7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xauuuurkE0687pq/CxTpTIaZqdffFXoFwwY0g02eaWWV1rqhrn72azNO/+hHb7z+P1ZtMlEcx3EfC977yuJTyf0DtpNjHQTB6pUrP3vupxcvXJRKpsrl8mb1J0JsdG19/S4TdgGA/s3haZu95957RVoDANOmGuSBCZiZqzKZljXNp5162vXXX18oFOy4RQAm0sZora0DrTbGEPX0HJHpGZxG9xJrHcexvQtOEzocDofD4XgnThBu5xiir33twiFDhkS2httmw8zZqqp//vOfs2bN8jyvfzQhIiLGcVxbW3vIoYd0dXX1Y2EDawGrrq5+8cUXzz7rrF/89GfLli71PS/wfdKaeg2GG7N8t0F0dlUtGG3hvskvT/7K+V8+95xzZs+e3dDQ0F/JV/sRZpZCrFi58te/+lVHZ2d9Q4Ptk808rNY6W1WVy+e/c8klnz7nnJdefEkI4XmeQLSa2Z7ifekiG+ppPX6lpx556OEzTj391Vdfra6piXW8meraOqAOaGraddfdAED2UwYji73pI0eO7JuddXMOqLUOw7BcKn3jootPP/W0a66+evnSZXEcCyGUlDamV0mppJRCCBRSCCGEFEJK+dYHlPI9z/d9G0Xcj4mgHA6Hw+FwbDf0Q00CxzaLECLWumnAgG99+9vf+sY3amtrNz/wzxijpOzo7v7973//73//uz+a2bOYttFr55577h233U5E1vcVNsmTsy82kwozZ7PZOI7/8pe//O9//zvllFNOPuWUgw45uG8b4iiS67FMWjNaX7tlV3vnE089ccdttz/77LOlYrG6utrGVW65lJubjO2B0aNGffrTn7727/9IJ5P9FUHHzFZaP/H4E8899/zxxx//yXPOOfzIIyofiKKoch8rjen55rrHsT8EQWB/mDJlyn/+9a977rpbeV4mk7GBeZvbXMRyFO2xxx5+4Mc69pS3uQdc59gIAMOHD29oaIiKRU95BJtljrMW+ECpgY1NM6ZPn/Hqq3++/I+Dhw3Zd599d9555zCRqKmuTmcy2UwmCEMpBABYm6EhKpfKpVKxUCwW8vlyFLW2t+2xxx7777//pmdndTgcDofDsf3iBOF2jhRojDn77LNvu/XWKVOmZLPZzbe8MXBVNvvIw4/c/8ADJ590UiUCbZOp6BNm3nOvvQ8++JBnnnk6kUhsgonpXbFJX6x1pSqbLReL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3XXPffvvt++TTz8xaOCgXC4rhKBIqARH2oFQIJ/PXvbrq99//30AuOmmm/acOrW5udkvJeonvjjn0LP0tHfdS3+sC6GIEKJQNdS/ZuMMIW6kUHcUAPoUL91clZofVuHprF27du7cue3t7QAgpfQ8jzEmpRw0aNCQIUOKi4uj0aK2trWmGVCSI6KS0g/+ABQgAChCQCmpFChCpVJACVcSCbrcqx80cPCQIVdefdVJJ510wfkXAsCeU/d45JFHDjjgwKuuuvKkk07ylwH3Hq7eG1kI3XWlGU3TtG9JB4Sapv2EFRpISCn9g/JAIND7+kLGgFJCkEx//vmFCxegUmf+/JRQKJRKpa2ABYoWhasqSmoe+vvDAHD80YedcPyxiXgn9xwpuFLCybqWZUkBCqRUnkJACohoBYrtVPqNN9566933hZD7H7DLPvvsXV1Tmctl3LTd3tZmMlIUMNetXGYnu7baamRZWYknXNf2V0NxJZSUEgGsQMC2bVBgBSzX9To72ikBSoTrusLzhORceIzSrUYO9zxHCK7AmjJx/IxPF61vanHsPCICGP4EUSmkACmVQiU827HzObDz8Vgsl80aRM75bF4q5yDy6pLQ7tsO7+rszMdaoyUlS5py/3hjjsf57qMH7r3TOEHJglUNM+Z+uePEsW42i1IyxnL5vJAIaLW1t3meCAbM4487ZtKk7VvbWwQXhdjGj6CCodAzTz/9whPP7zR2yJ67bD9n7rK35yx89InHPUXOOOtUVzhGoKS9udEwjTtvuz4csmgosnjxshn/fL1hfcvCxV82NzdvPWL4vbf/bp+994yUR6Un7FQmYzssYIICRqiUwnacgEFdCSWVtYuWLjvh56fMn7fo6MOnnXHycaWRUEd7SzyZXrFi+V5Tdz/kkGkl5aWJWJwxSin1pJRCWeFAc3Prdddd//77M3bccccpU6bsueeezc3NftSneoENG833SQb6FzaON74hAulTjeYnpBAn//73v1+xYsWMGTMOPPBAv8QoIvpvwGOOOebmm2+eN2/26FFbxeOJYDAopCSEFWI0pWBz82gRCQBUVFRce81vp06desUVVzzzzDP33XffDpN23GHSjrfddts111zzz3/+8+677x4wYEA2m+3d4aP3/Ww8ufd/dUmnpmnad0IHhJqm/YT1PrD2m1w/9NBDe+6559ChQwvr2fxj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Wttabc+ToDO5bCQeP/KII9776NPW9kxFj75ZL+CgpNZKK1BSYeJJaMm5NS3Z1Y3p1bVtNU3Z9U3Z5gzP+cgVBBHT94WScuSAHgiUwdjapvZZ335XXZraamDfxtq1ELiMaNfLaQ2EmEpiJdHAAUPOPe/i+romKaRpmolEAmOE8UY/6jbjJm4zYZucbQvBtYZYLDZv3g8NtetS8YjggVRaqQ7foeyam/3zUv633RV55JHHrwf9rQeQx09QSoWtsTHGPOADB/Q545wzHnzgycP2/6PJ4sywcln7nrvvveOO26NRIxaNXnPNtRddctnQ4cPLy1Oe4xiGgQEyrY1HHX7EzDmL95k85ekH74slUw21DXvvtds2E8bM/GbW519+PWnSpLXtLZoghKkGoISC0hqULzkmWCmFpWAYB573hz333HOvPQ888JDXXnvrk08/zeVye+21V58+ffbYY48nnnjijDPOLC0ticej6XT63HPP23///desWd2nT9+2tjZCSEdunt68PdGmcMctWXN/BTYGTCq49tobXnvpqauvumzk8CH1NesLiwovv+wy13MJxhrC5vObvl5rrXVYEkBKufFPHT39AAH6Sac3TdN13fCvUnBMDRZJgJPr3bPynRnzP/tyNiORhYvmzZ8/d+999m1razMMowuZDIvR/Zx07HjQmYv+w9nomLTwF9AaY6Q1CC0BwHXdnj37PP/SywdM/uMlN9y1z97b29n21StrlWZFxQlGYUNNU//egxXw2T/MWbhiHQCmiJx53jXprEOI8fo7X77x7mc9q0pOPOqQCeNGFSYSy5YtHTFiBMY48HyqkRBhP3gZCF8besjQYevWruLCTxq4f58+S5ctsz2PEUJx1AfFkQoQwjIgWlGMlJRCSVujJp+2usAdR0oeTcT8jGMa1GDMMAgycARhRzNNWeBkm5ubKqtLMUaglO/7lBIAUFJq0EorhJBtOxY299hjz4VzlmTaWnr3KP9uwZoNGzZ8/vnnU6ZMUVLiTWvaedchhDEGrSRljFB6xNT9jzvqiHRzI2illZ47d57jOM1NzfF4ovtadFFr8t6/PPL4nwBCSCnFObcsy7btrbYa+uhTT03eY4858xZOHDVIBh5AGGEuhRCUUYxwmDknufDsHCAUldqKxg1GtNYIASVUKqVBKkQwpghhjBCg0ECHMMYYE9OMaKnX1DQ3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tj3jX3XNdT17VU8YPzqbyWDKPN8viCeWLF3S3NJcUlrUt/8ACXL27B+WLl1+8smnCs4feeShbK69T++el116YZ8+vQLOo0ZEa40w9jxv//0nP/nC2yvXrHzjzTdPOuWkdHsaI6Q32cvCuJUOdD4/88gjj98P8oTw944uzjG0KYcQOrRPhAIu29rTF154yeefTXvgocefeOyhjLcByQADIMo6Csx0eBJgS5oQQogQopQiGC/68ccJEyYQSsMYuU1taskmu6omQiDMmOAEOzwILMvq3aePY7tmJCKV0Dxob9xw8JTJNbX1PSvL77v79iOOOvb662/MZrNnnXWW1kAp3XXXXa699tqdd965uLi4s5OwgxOqX9FWsfP8UEqFEJFIZPr06fPmzrng7FMMg2GCCSEgxBbfizEWHk+lUtGYcemV17/8/NNeOt3WVIcAdpowbLcdtlKIzFuy4vGnn1u4aGXGVkuXLLnp1geJATKAOIsVlhVtv+MO2++4PShtWRYARCKRvn37CiGCIIjFYtBJQ90ic+juoPiPIFzoMIBWKXXaaadN3HbibbfdOu3L6QtXrJ6xYMXYwT3TLU2ggVGqlcKbKBdILEEpIbjvMtcQnscilmlaGBABQFppahJKAANiRCsS8EApSUD179uztKy0qb7uxXc+mzhmJDOtSCRimqbtIK00xlgrFRZM0FrjsLMcgOBBz17VxSVFdjaIRGJffvl1eVnPktJS20ljjAA0pUwITimNJWIIIJtxX3nltRUrV1QUFyPOFQMGIgK2BSQVjdhALZb0fLLg+x++n/UtM02P+xbRnAvDMDChFSUxU2eG96peua6mxUVpJzd67Kjtt982l27HBGNCMcZCiHQm3b9/78svPf/CS69K2841V1/l2rmjjz46m80ihML+ch33EXSyfHcoOl3Y4H98fUNorTucqI7jWJbV+az4f4NphAGZH7z/wbq1q668+EwMeNqXM3fYfvuTTzldSqm0Qhp3L6D1C7om2rzSPeoWzv3r500pFc5/Q0PD9OnTtdYNDY2O4xQWFmsNGP/r89952+Tx76O796nLnRJKGUm1G7jxZPzsc84+/YxzPvl+/l7bjuLpJswUlxwpojCWCEmMpFQAWoPS2vQwIoxw33IRAq0YJcQ0KcUIYYxJaEWFsJWTUgaliggNGmGUoHLY0L4ms+o2pJfNn790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7re/aACYzxWgHpHMxpBDogPFHBoY1jX181+4WgL5jrbxfbb1ta2t7S4kmKKGB0Zznu/5dhkqqgSAYEVwySFHEEoIK8skEggBBGCFAR7uACkFFxokhiGzDAihYMkYQvJwoSMJAYECIOThkM2wcEsNba3hZCqTy2AFYYIglIqChZAEkgqR5py2dkTDMTWT9kdG7HHjIogkDnUP9PYPlizv7HNWLVt+vKZrGJP5C2ft2LFn8+bN+XKZD6Slqk+c0CEFFBBDgLRwKBqPv71x4+o1LwIAFixYsHjxYkqpoii1q+ER86066FXHXVjjtPzeQ/bu7Ef/NRJVHZfqCn788qV+wO78818VhK+95upUXSSdHiWEAMgq06zSKFVVS2X36dWvEFX98Y9/ePppZ/b19j311FPLli2T7/bErmWJR9/REc2WNYGsR2whjlHEY/hvxTFCeAz/ZNSqSKsssdYvotZOWFWX1h6gw3X8EEKGYZbL1qRJk377m9/u2r3rC5+/5hvfu+mNV9d94qMfOeGEedlcWlLfE76UACIMpABCAilVRRseGT7uuKVSylKxWJGtAAAEkZAg4GK0r6epof7zn/noDT/7w5tvr600duaMcd+//isKREEZe0THmlqJwvJ9b+b0qWPHdvUPZzduP/DSa2/t6x296ee3/vmev3zvW9/+/Be+Yrk0CALDMHzfr7UT1m62YE1Bjqp8rw3RgRBqmsYYLRYKU6dN//c77vj81R//zBe/9s2vfbG9ualsWYVSKRaNPPTgXz//pW989Zvf796371//5XrPExBjAuHwwMDZZ50xceKEQjbd2dkxdmyXWypMmDh+woSutzbvpJRGwrGVK0/duGHjk4+/lMmnFy+c29yUdH03oGDHtoOpVKq1tcWyBYHALhYsywYARKORt996+/XX1i5avNjngapq1A/K5bLruXfeedfoyO62usZUKiSkzObK8UT8uGXHW7aFMeYQYoyBEMNDw6qq+pSW82UJUSQR1YiWHh6lLCAKyhWKZVe2trZlRkbKJcvdn00kw0EANF0PR8Ou70IEEURSAgmQ63pDw8MASEwgURD1fYJQEFT2E5D5gWmGeweHhvp725qTLtUG92cBiYZCYcf3X331lauu+qhwHCklkFJXVQLxtq3bFEVRdcX13H37eh1blwBqKs7n+wf6ul2HAikUVY2EwvXNZrZU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TM/3tbAqyqJDPMCIIAmeZ3k+mDJ12pFDPel0pq4+5kOnr7+wf8/+5rGX+pADEPIC77m0s7OLF3A4rgVBIElyT29ve0ebKEs7tmxPDw+EQnJYlRwbDmQK/f0DU6ZNzGYyPMeRIAAcZ1l2T2+vJGn5nNGZzwqCoKq8aiLAZEb83bt2VtZV1zc3mKYpCALP8bt37F63ap0sSLIk5ouFJx57/IrLL586beoll13S1dlJfLJvz55ivqAqcuAT07aXnX9O85hG23MRjwGAYVmsqqo8vO9AX28fRjgai2maRoIAc5gxACH0fU/iOFVRssHQkqVLps2awQhZtPisY8eP5QuFSCxa0ItLli2bv3A+I4QG5N033zqwd191ba2syIVCgQTE9wNJ5YumpUVjrRMnjBvTKonSI489pmoaj/lwSOREpJt+srL60suviEUjmXT2+edfzGaysUQsFpJLenGor59QEg2r4WiEADaczuUcoqqxopU/cuTIuIljCiWTAEK8gOf4aVNnvbf+4HC6YFr5WKxu4uRGQMmh/fsYA7GwKslRVRY4SLPZNPH8kKZijNKDGZ4XiOtXJJOMMcoozwEESHdPNyEEMAgwgABgBCGAFABAgecFruNSykyzuG//gdnz5hEQmLbPCzKgzLQtwgDH86Zheq7fduIElEOO6zY01KuaZpkWgGjErAEAMARBQHiekxWV57i7775rxcrVkZCy/NKL77z5lilTJpX0gsBhJRKjPj128Igky4V8PhKNjLbho9ngKSv18hLc8wOB5//yyJ9XrF75r1//wvyZMwa7OiCDgsA7nhtNxCVRLBV1SiljACPEI3yis5MTBE1TPd/nsZDLZb/21W/09fcOHTm8e/u2dC6XTKUYYCFV8f2gprZmxoyZZ509d9HiReeff8Eb7741b958iKAf+ACAcqNBQAhCyHO9UEgNguCXv7zvjw/9ccGChT/+0Y96ursHhocRgolUhaZKjAa6XlJVTZGkRYvOuv32O3S9hDEHIXJdt8x2eF4QBAFjZNv2D77//aefeWbc2HHjx7cCwAYGBl3X27Nn99hx4yZOnNTb05PL5+782B2XLb+8MpXq6xvo7jpRVZnatOm93u7umsrEmJamL3zmrgXz5371a19/5tWVEOIj7R0XLZpCGQkCn75foYoAYZARyAlDBW/OmOqpjRVWLk15RVAkTURF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euqpc845J5/PPfbY48uWLdu4cWMpIXv+wvPu+863KsoiQFDq2LlMmlMqI0AARxABIBilnuMySjFGCCjUdTyEkNzbNJgIwRHk0UjIr6oVibK2buvym+6qqS179emn053dhmVBICAUnLNoILhizfpPVq5TVX3jl1uOH2l88De/nTX77Nb2EwAJBPDJ1PlXcMtp0Lr39P5DBNi73XuB/iEa/K+KUkmn7ThPPvVUbV39pInjV65cec01V2NMGKMlKv2r7/o/l4x+9V3/tcf7r/jn8T8ZEAIAuBBACIxxNpO//NJr9m5f/9iD95XFcDFvaL4AUXz+YNQfCBOJEEUvq6h+4sm/ff/nv/3lD++55967kz2dnHmqogghGOee52IkASEgZJw5WMJADq/duueTZSueee5Fj4NgKHTLzbd961t35bJZx3G54IKXxJCcUoow9lyXC2F0dRKMGGPBYGjatCmm7V515eULz5sPgeAcNp5ofuyxxxobjzPGWlu77rzrPllCVRXll1y06NKLFiIgBvav01WlULQoY55DOQMYSVAolmECIUMEOKcQACYAIgRwhhHinEuySl3IuUAACU4JAEAIKCsCQIRQUNVUVRWe63qu45RQInNcmzNOJEIoBNDnMUYshxCoq/LuvXvXrtvgekJW5fLa+JnTpr/5+ocP/OgXPr+/tbXrwgtmjxjasGDO1BkzJx08dOzLDZufeXrJylXrvn7rldPOOCOfSVlGQQDAPAqhIARxJhhAACIAGKeMccoYLZXIly4hFxAKDjkCnHHPAxByz8Uu4QhA2JuzRAhBjCUhBONIOKZCyB23XD1t8rjHnnzu2eee3bFr5xuvvjqooSGfSQKsybLieUwwpivS+g0bvrz0ym9+4+vf+959VTX9bMdBCAkOhWCEnEw9AgB6HUd750LQx24UAFAijkp73bt9MvnNOWPMNItEwr/41a+2btn60osv/+mpZ8+aNv6vTzwypH//bDJ1xQWzJo8f9t7HK1989e29+w/3q6up7x8fOiAc8aE9O7u4Z/brXwNl1TMzikwY40IAhFCxkHVdLxQKLzpvPpHlD9//uJDLDR00wPOcfLJgFFOSLKmKxqjIFKhlMdu1BwweetW1F/sDSk9Pj64qQIDnnnv96KGDmiQpsqIAmggJSSHpvNfaYafzyHVsXbPj8QDG2Wwh2zBsyDXXXiOg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+P8cJv1fQVCl9ERpjVq6uEKI0pOm7dx8801HjxypTkSGDqi2c9lwpPzVt17uSmYuvOCC3k84bcXyVUzYu6vwVB8L8BVM+C80+N8u/nsDQgihEIhSKslyd3fHDddcddakUXfdeTOlLBiJISITSfYo+9uzzwysr/v+979nGvlUMilJEiESZaWcFECY+MMKROpHn65++aW3mzvbFy9efOPimwb0b2htbe/pSW7ZsnXJkiVTpkyGfUq//mH0RYN/v5MnJaN9nwRfuWGEEIqiAAAymUwoFNq9e/e777571lln3XffffX19Z7nlTqbeZ63b9+el19+ORQKcc6vvPLK669fDCHMZrOlLhcvvvji3r17jx49Wl1dffHFF86fP7++vr7kWco537Dhy5deelmWpW9/+15CcDabBQB4nqfr+vvvv//a66+fPWvWddddFwgEsplMqbuu67qDBw364Q9/6PP5KKVtbW3oVP+ivumivsinNBKahmnb6MILLohGo88+/+zGzTu+fuddLz7310H96wSzsMQ55xgjTpnreRAhCSEgECYIEUIkTBkTnDFdcyyVea6mO2ahSByJM8+VJA14ggsuBCHEpdwTCGOCiSSVDIIQLtVkEkKIrAAAEEKSRLhAfj0gEU1RHAixBHFHzoQItrd2J3uS8UgYcuZaloyxQAgrMgDCNA2EkW3YmLjjx44e/cjvRowe8dhjTxYN+7vfvX9gff2Fl1xcOkvFYrE0BPeFdiWSsPcS99343w6dEEKMAYTAdd2GhoYxY8aMnzB+8+aNnm0+v+TVJa+8fdttN1x68YXfvPvrFy6a9c4HS196/aMtO3bKEJ41bdruA4fyzy257LJL6+pqspnUyNGDR4346ccfLFvz+QbuoULeLebturryBQvnD+w3xDRNy7KKhcL6LzccOdjc1eXFwwHHdrBu19bHYJctVFn3Yw07UX/4wOEWxrxsNisRAk7224SMUdu2S3sdjcg4oWKseUw6dKTdoabP5/f7gz6fbjlgzfptq9at8fvC1ENBDVUkdMewOaXNTW0IQSCAEAIiSDAmEslmM+PHjxs3bty6z1eXVUUBpJlcz4yzZ15z7bVG0eCCe5SOHjN6+NChP33gR6mu7gDSwyHf+nVfTJ42ZdiI4fliUSKSqulWwdyxfauk4Ei02rQNM29ToVgWz6SzjAG/38KSRIjy5bov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kUjU//a++wdPHIuGeFSPDA7nN25485prPjAymtp35Jhtey89+6JdKcbqA8mYjLnwEWd+UcI4rOnp0fTAwHBre5vjeghjxhlHoFIxCdQcD9rZkucLNRgyqs4zT7209tUNllXlgkUjMQJBJlNxbCtbyM5dcmFre3Mqm3U8VyLUdj1FkhGEzGeqIu3avcMWzKWB4axZtfym7rbPfOEzj9730HNPvxPRKReVYLyRCyWbzrtOJh7TOUeqmiyXctFk9C//7mvN7U3Qh67nY4wggoCgJatXbNn09pZNbw309fOC15gIt9VrzTHVrlQKDlrz0pqdu3a3tLX3Heu3y6MNEdqYiPSNFGP19ctWrqhWS3JAsawq5zwajUAmMvnsspUrL7n00mgyriia61VVVa2UKpxDAARHHFKQqI85zLMcm0iwFnnBGVOIahvuE79/PJ9Jt7XEm6MqMNyjw9k7H340XygKACAH02fOXLJ46djo8Izzldlz507oaOvt7S8Uy719J7Zt3VIqltLZSm/f5toE8db2PafnkSeee3X54gVLLlikqkpnV5dKsQR8PRgMBPSQHmK+rcparR46IZQjYpkmgKBcLgsOI5GoEqIQMc5c4THf8xBCmqYBRDiUTNOoVCoAgL/51o9+c89vLccHAKiqHgwFJk2ceO11102dMsX3/UqlAiGsCYSc9p6N5z/glJgkfLck5tnmOzwlGzae8o2PLTx91WebTOMPAs4iGON5GjhFC8+mgjWcoVxydqLg2USlti5WkxsFANRaQwiBkMAYO7ajB0MAANe1KaWu60mSvGvnjn/97r8sXbI4FNIJIT1HDl151dXHjh3/0Y9+cPXV1ziOJcsqAOBv/vpr77zz9nPPPQ8A9H3/rl//4stf/uoVV1z+F1/+8sBAn+95qqrdcsstixctevDBhyRJzqRT3/jG1399190XXXThU888M2PGdM/zGecII84F4xwjxDmrJSvWGrmvt//Xd94lI3DjVRcmE3rRINhzhQDCZwRjADjRVNPHL76+qbWtZXlLO4aCYdkHqK6u8alXNr761ubVK1b94uf/Jssyglq5XH7iiSc8z7/gggvAqXSYWoAPeA/jdjydO03C0bu9suOrepzxk/E9ewbet5z/XPHfghD+H8T7I/V/LPipbIpaSXjHrX7xC1+4//77AQAXXbT0wx/+cFNT05SpU9taW51KJZfPU0qBELVywgRjIQQ8FUIJIEIQyTSxY9uJOz785cHUSFdbR644lIzXt7W1q5QMDqeMqslch1KCIa9RJcE4FEBwzjzP9zzu+czzHNfjtuV7fjZr5PLFaDR54cqVAPrlUgFAXBN/QxAKVFtFZhgjAITHmM2Y4LitsXHXjl0joyMoqggVeQAiKmGIHFnTZI1KkpDw6ac251wAwX03oMi2bQIgOlraP/+Rm6+8aNnhnhOvrNt0bHB4aGhwaAjs33/g0Sef6+qaYFaNq6++4uJLlrsOhkBWAjoAvFgoAwD/o271qeaFEFGKOeeUYAGAz5jHXNNyEIQQYsbYwoULFy5cKITwPKdmx5TLZUJovmSoinLx6lUL5s/bu2f3xg3rDx3ueXXtm6+uffMXv7zzlptvvPnG66IRrSHZkAiEGPehAB5jvsUdy0QKcWzLFkCRqeDM92xZlv75619bvmjBr++9/3j/iO35m/b07Dx0fHJ7/bRJLd3NwYZmOV3OHjiwv3vXlNlzplpm3nPZnFmz3nprq2B+W3MyoOG+dOG119bdesvNEGLTtGSJnopGgoRgiCWjYheLJT0gRaOK60Z2797b3Fy/fOUSz+OWwZ97+oWqUejuijmigjgORgKaLmGMERJISEAIiUgIC0+woK4pKldVLRyJXnDBBYeOHDnS01My7VLeiIb8nGkmm5o/dvsdM2bN4FAIAAGqRQJBIaDneYm65Je/+mXHcjZt3Pi7Bx9KpasRFTY1B7IFMTaW10LBL/3ll2ZOm8pMx/ZFLp+TKC0UC089+dz+vburB/unT2wWEqVSIZM7IYAZj+meLZgLXM9JZTKt3V00EK6azqTuaEddo1mhFi8SiUaiCoS8znI58Eb7D5042oMBDqlAlYGjKxs3vTVr9rSurokP3v/Igb17Ozua2pvaxtKZobHUW5s2aoGIWeWdLfFIOOzaJUSEZfJS2TerEECoh0PTpkw92tP/xqvPeJwIwSSEIWexkNrcojYlCBJm1kTDY5mApl7/wWvmzJudK+TzpeIHrru2LpH87d33mJYpOGxubp53/gImRH1dveCMC59zUCiUgkG9q6vbshwBMMEUIeT7nu26N95y/bKl5//4e/+WGx3M5836uEexqagqglImXRQUYRsUCyXPYxSD+mQkHNSJLBDiQkg+40BwCpFh2UPZXKFMPvih2y69egVCECPqOHY8Ee+c3HVk/z5NpaLqahJ55JEnDxw8Vs7lBvt6AQCY4rq6aGNj0qxy33aJhCVNkhSsBvDYUGn/3n0Turtdv8QZC4UDIyNj+3bvTURDlgnK5Yrj+QBbiqIkgjGEgU2Yqsm27bmeU8yWw+HQJZdcPKl7xssvvdHU2tQ5oa1QKiCEPM+TKK2vq1/z0tonHnksGo1DIfmM3XzbBy+8dJVZLm3fvLOjI14XkwEPFk1pJFu94eZr7ar53LNP47QVCRiVirH6isvaJ7QPjY6eHNkA1AYmxujSyy++cOWy4aHhl154dcc7W2QgT+qQJ3ZFUiWYCMu5QnX/9j2BkNrWmmiu0y3HK5ZyzR2TgsFg1alCF3R1dOqKJhhLZ3MzZ8y4/Y7buQCmbZWrBoK+ZVoP3v+A7zhaSHc813PtfCbf2TGBMY9bnDMOIUAIyZL67FPPbd++vam+OZmIOp4XikRwpmK6XufEdk2Wm1s7b/3QR2RZE8KDEPmeZztud3c3IXjxovOvu+aaWk51KpWqVCoIId/3DcMoFApDQ0MDA4PPv7Lu+VdOxnDqmsR9X1WVeCwWi0UjodCkrvaxdKaxoaGjs2P3vkPHjp2wLatqmswXHR3t3f8ve+8dJVdxJvBWurFzmhyUc45kkTOInDFgw9rGNg6s0653nW2Mc8I22WAwtkkiCUmABJJAOefRBE3q7pnO4aZK74+WZscS9u6e98476119h9NU37l9+/atUtX3qy9NaPMFdeo5F5x1zrRpU3P53M6dqzu7jxzpTw4NDXV1dnke60vnAACLTzllyVlnxeOxaDQWDocBAMVisbYHB/86Xma0oe/vb52P3kA/7uCHbr4fBxXyhGISx0ECHBW2959a80acD2v4cRwrHucROvIncIxhNE2rRX/UaLBm3ANSCMH9geC2bVsyw8PnX3CBlEdthr/61S/L5bKmaQiRbGb4I7d/xHPd5ctfv/jiiyl1Nc3o6jr8nW9/+4knn/rJj3+45OxzKpXSnXfc+cKLL33q3k88+OAPCVF/89BvHnzwwXg8PnPmjKf/8AcpJOd82bJljzzy2APf//ZnPvM50+enlEophZAACAiRQvDOnTt+8IMHH330UV3HlFJd15968sn9+/deccHZixctlE4JmlJBoFQqOnaVUarpQQbJLx/6zew588475yzolHUVQ92sa25a/f7Gb/7gZzNmzPzZT38U9Pu279i+YsXKt95ahRD5t3/7d7/fVyqVa/ut8FgSHfjX2YCOg/bRHfT3BZ4goy8ITirY/9vlfxAQfuhQGz21wf+m7+jJsft/TWrOMbVcz089+6caDd51+80/+smD0Xi8Wi571Os/0qMpWm1xGok0GNlArU2aUkrbtmLx8Nr3V15w4Zk33XTLxAljy7nBTCZHKX/66T/s7+hGEB44eDiXzbY1N7pWFQghuZCcc844ZdyjzKPMo9T1uOMAgPKZrF2pJGIJBcNyuQqBZNQ7Op4RAgIBIABAQkIJGSYYAGDbVjgSIRgPDw6GYIQwlQNoqAaGyLY8oXuqpksMAIRCCOp5EGOX0oG+I00Ndbqq+nT1UHaH6TcnN8ZntJ1y0enz3tu47UBfctPOvYPJTCqVTKWSAIBUX1dYqZ56+iVHBtMvvPryrFmzzj7rbC54bc2rbXaOvB7dZgYAjEpLI6WshUtZllWrjYsQ4Jy7rosQwhjFwkEAoed5Lc2N48a0X3DB+UNDQ3v37j1w4MDGrbt+9ZvHH3786dbWprkzZk1oHzd2fGsorEdiodmTJkci0VIprxMkuKSUK4qmENX1vICp3XXbtWefsSiXL6Yz2af/8urK1e9t7xjc018+bXZp5vj6cFOCpcsvvvg8hEtnzJhBMFZVIx6NM7eKkS8eNUq2d+jAoV27di9ZcpZlVzijUjByzBPM1IPpZNKynEgEJepC5TJwPevdd9fu339AN/ypVD6fzbY0N+qGUqwQz6EQ2uWKHfSpsZAaCvoxZpQVpdAENJKpXGdn36LTl8ycOydfKt11992Uer1Hev745O/digWBuHrpVXPmz00PDQEIBQS1DVkIEEIEIiQhLFWrSIKlVy3NZoorXlqVK3rRumCxxDKFwo133TJ56tR8oaQiJBGub6xnjMXq4l/79jd++9Aj7yxffiRZmTa5Pepzjxw88pPv/mLugoUTpk1MNCYM3ScAZFAKojMhpfAIomGdxQ3MUazkgqFcRQrc2lSvtCvVqiU5DfpVMxTZ35EeTLOHH3pWcMuyy80N8WDAl0wPFUoly3EkBIVCxXGBZYvhTCkc0tKZcipdzOfdckm4nhsMqIm6YFtrU1ura1ueoeuMeUyweCTgA57kVCJDSLfiWDNnzJ0+a9bA4CBRFcG5Va1OmzrV7/fbVdt1nEhdvLGx0XWcPz/1XF9PV3tzk+Myx/WamxM+n8/xPIyREJwzqmoaozSZHmxpq5s9d+arXR2MqUJSRdOrljqYzA9nK1Xb4UJCiH2mX3DR3dsbiZiGLn0+tb4+bGgqxEjTsZW3KlTUj6k/97Jzim5ZUB7w+QUUBzsP79q3KxRSfCaMhSIQ0VQZ7ti6XZW8OR5VCKCqMDRzMFWwK47ncUXlug8YuqaZ2G+ab698a87cua1jx3jcxQj+8eU3C9nMhLGNAGqZ4eIdH71V0cnvn3yksa0hnogzhhQFpbPkUGf+wgsvuPGmG//8pxcefegpj9nNbfX3fPzO+YsWMMqhlNnh4Rf++PyKN9b4TN2nIavimap+6qkLTdPctXWbbdNguDx2fIK7/vSOlOnTLrhyiaGG1m/YVLEYlJZu6mPHj7dsGyFEEK65wAEAIATM8wpuQVPVcRPG33zrLYf2deYKpXzZiyfMBmIUMBAeCGoRblLNxABpkAhNx1a5UioUoomoamqe7UohMtns2PHj7rz7o45tVayqomue54RDwXVr1nYc2BsPafVhtWLxYhase3d9+7h2VcEE6aCWsYOQzs7D77+/PhaLASCHM7lBWi5U2ZF0TiXaUCqnEnLvp77geV7VsnAt5wqECCHbtmtWNYRQOBxGCEWjUU3TaqF6NRRhjHHODx3ct3Xr1kKh6Pf5BAAHDnc3NNRjhC2r+ubq9W+ufh8iJAUHAEBFkceSPQIAOo70rnr3aPvnv36mvqHOsqxyqaJoqqJqVrkcr2+YMXP++Ze1JuLx0047DQLIOKtVjR8BpA+1/PxXVJoTz/lP/aFOVPdHN060Gv0d3vhbQAj/2mX0RBQ8EQvBsRq5AIBQKOQ4Tu0GuBCmYQCAfvDA977y1X995JHfQYhd19Z18yc/+fH777//1FNPJeoa1qx+6557Pp5IJN5ZvXr8+AkAAM74d77zb7/85a8E53/60x+vveYaIcSTTzy+devWZ/7w1C233u55DgDgIx+5feu2bbNnzfzhj34y8oguu+zyrVs3zZm7oFIuSEEFp5puCuYJIShzN2zc9P3vfueCCy8yTdPzPFVVC4XCq8te9OvKdUsv9keiCERRxd30wbqxrU2KDrSgatny5z//3bgx7ZdddAagVRULAGE8Hu3qTX7rR7+ZNGXqI489On7S2Pu/+OXf/u5hTdO+8pUvX3XV1Z5HS6VyLTcBQmgkdHC0Yjy6a07spr9DgCNvT+z3vzW0Tsr/MvkfBIQjctzOFvgb21on5aQcJ/CoSwx84403f/3rX/tM40cPfPuOO25lQvT3dPl8PkqpqWsQEiGg53maplFKwbEptbb2cM4UosTjcaK4N9+y1HUu7enu3bT1/YA/2N3VMziY2tvRPZhMAQBOWbwwFo97ngcEqNGgYFxyLrmQjAvGam+BkEByDDEC0nMsx6oSDBzbU4jKuQBAQiBrRIgAgAAgCDnnmCiCQ845wdirWtw1kQ6ZRK6wGYBQUz2XC7diu4RSZjuW53q256WHs5qCU9mq59gNYX8k5I9GAvmhlG7osXjT+WcsuMQX2H/o0LI33kkO5Q739Fc8rii4kux8/flnnnrhzd6hzOtvvJ4cSF5z7TW6bjDOOGMQwtFVjEewsIbTtX+tNTjknOu6fjSXBoBCiGg0WimXdu/c3tnZlcvlKpWq4fMNDA5OnTq1ra3tnHPODkXiy156CUh6pPNI5+EjtX5EEKiqcsqiuf/y5S9OnzJBNzSCgODAsi0IkaYZQvBcsZxoqEvUxWfNnr5o8eKde/b/4lcPr3rn3Xc3HFi74cCsSWMntrdiWH755WXbtm/HmKSH0q7t1od9foMqqpkv+kpl/u6764vFUjQWmT5tsmmolWqVM64oBGOeyQ16nkNwdHi4wDhTFNV1aU/3IFYAkCjgDwiOU8nSUE5yJij1MMFJ4cbCoXjM9gelz4cDGvJc2TeQmzhp+m133AZVYjsWpUIKOX3e7I/7P/XNr3xtwuSJc+fMGc5mBAREIYwxACRBGB4L6BRQIogEkLlCfvrs6WveWmtTr2xbhYoIx2JzF8z3BJNQSigBBrZnI4TKVlkTzoXnLtm85gOrVGGeNb6tfjCFD+3et2PLvmDM19Aci4SjhULhyJEjCuPRWExTCRUOgHrZUnIFODhUHsoNMw4UBdbFzXjMjCQiGENNQ1PH1/lAJlOsAoXX14f9vqBtef0DyWAkevudd5x/8YXZbGnL1o19A+lSTo0EA9mynRoaqm+snzW1XSHKvh17u7sGuFOeObMNhW0uKqYvni9Yg0OZQsbyYS0cNooOBwDpPl03dZW7jkellIFAYDBbsKpVjIjP5+/t7R0YGEimkstffbmhLiEY9zzhuEwI4ff77WIBHltHavoZRqbrwXiiASApiUsUw7F495FcruwgVVlyxpmVqhWNJs5Zcq6A4J133t65bVvZsgoVr7O7Kx4LxuOBaNgw9IQCsk61ZJXzscZ6XrZWr1r9wQcfpNNpyyrXh1VN5RpkrQ2BWAyWyljTTSlxsVzmHsyU87lsWQio+335suMNWaaqaZoaDARyhcJvH/rtORdeEI749u/eu3XDjngoGgmgkssQFuVy2SsIjEMODXf2VBj3dF3lApqGls/ln//L8++881Z9IoAVX2oo/dMHf7H02qVEJZ2HDu3fszebzQUNX0tzJBw2uzsylSrtH+iNNtb3DwwKjoK+sKlphUoBcI9z2LG7y6441WLZrwds29Z9ZjQRt1yXAwkhOhpeDCGUUlNVLoRDqVsu+YNGLBFMdg9hFC8U+MBQOpXKMUYg1miJpjynIRwLRIOG4S9ks3/505+vunbp+g/Wr3vrPadqN7Q2f/zee82Av5jPYoV4niuBkBLs27sfCh4PGUFDYgmDmrlnx4EHf/DDurpINJQIh0OU0lw2u2ffAQmApmmVQtl2LN1v7u8b7B3MQoggADfdcGM4HK/aVUIwRlgIAY5uvqHaZFXTqmtmFsdxRkfW1TTjadNnzpgxiwth6LpHqe06hmESQqjnHThwQNU0Xdf7+/oCgaDP79uxffsHH3zQ3d1tGmY4EolG4+FwGGMsOHVshwueiCcuuvjiQDC0f/++SZMmR6MRRSG2ZVWrVXmsQmDNSglGhXDX5sO/syH+tzSi41T5v/+p0TR43OuJeHAiaRzHG6ORb/SZI29HRw8eh5QjZ4JjdQsBAI7rvPraq9dcfQ2E0HVdTdOGhjPP//lPX/nqv95y80233XY7hFDXzYce+tX99//zb3/70BlnLunp6br55lvHjB3z+htvRCJRxrw9u3fdffc9W7ftuPaaq7/73e9MnjLNdW0Fk6VXX3Ptddc1NrYAAFRVr5SLU6fNWLlyFQCgs7NDUZT00HDHgc5Vb61Ip5NDmSFd07lHFVWVQvj9vlR6yLatgx2dAIB8oTRt+sxLL73E87yvf/3rW3bu+vKnPnL+ksWAqJt37PvGN36gQPbvX/5sOOjvTJe++b2fTx7b8tn77i3kswBDiNVEY0umyj/zlW+2jZ3y8O+fHje25Q9/eOKJJ5647NJLP3nvJ8eOHZvPFxjjtfGA8dF6wqNXZDAq185oGe0X+p+aB0e3wd/dLDgp//vkfyIQ/i350AnxxHP+/7mZk/I/TRBClFJFUd56a/WVV1wJAP/h97/zic98fnjgMJfS7/dTSiWQnHMhOOdcURTHcWquJlICCaSQUgoZCAQqlcpzzz23d//B5a+vTKaHsoUchggQKSUQTCqqAgBorI996t6Pa5omPKdW91AKIaWQQoxk/pKCC86lkNSjhkpMXU2n0x98sHHJ2adLySzLAbXFXoKaMoIgxIRgjBUMuZR+f6DjYHdffy/BAAophIBSUCm4Qpjn5rI5m4pqGdi2oygkFAp5gmzfc8DU9fnz5gwOp7NDpbpEOJIrJWJm0G8Wi47frwcCZkvE95nbrzzSl9zT0ffGuq22VQLM2bl3R2ooo2qqVbEe+s1Db7/z9qfu/eSihQtdCD3Pg8c2rUcMqrWg9pF/j7Xo9lrIB8ZYSK5oajAU3Lf/4J//9NzmjVuZoKM7a8vW7QAABBCGWFXlmWcsmDp+TCZfSubzCKh79x0aGEyuWbtp++575s2ZccrC+QvmzGytjzc3NytEAs4owBKRsuNBICq2jQU7dc7UWT/7/vvvf/DKW+9ni9bh/Ts2b902f/YMXTd6OnsghIQgTdE0XSsUSwh7gWA8ZDHHdd5etRITcmjGtIsuOq+urk4K6XmeosJsNoUxZoykBku26yqK4jNNx6WqBgIBv1URyVQWQgp0ddq0qT6f2dLa3N+f3r3rULIz4zeMQCA4pkUqhHAGp02f1tTSdCSZ1A2DUYoxZpwe6jqkGKR3oO+V11659dbbCqWiQ12IEYKIcwFhrWyloFwCQVVMXMbGjW3TdFiuFgT0204BY59CFMGlBIhyiSBDCArBNVXD0vVrGDJqGBjLal0DiCYCDo0O5yrZrNN36MgR0YkgMg0tWm801gWBLEusllzZnUql+iuWzcaMbRozaWpf72DXoY6BlKWQvC+gRPyyrd43Z3okXwk7wguGAgN91b4jfU3j2j792c+2jRkzlM2FouYXv/rZ3/7iN8MDw0Cw/kz67HOW3HDzDYbP8Jv6js07fv3z3+Ry1WQy21yneY5IJUsD/ZV0oVqgtk4twYZCkQDnQFG17u5egGFTS2ulXO483Pn2mytK5XJ9ot6ybCkFhLClpSUajWRzOSmAY7u6YVaqlVw+T1QiIAAIIIQ5ZYxzSr0gSSiKDoBQVIpJIJnMF0tU9/tvu+vGCy46x7JsziVGCgf8Y5PvyA1fZVe8zFB+4/sb1763ejifjEUDsTAP6b7hfHbFK6/MXbhozfIVmzdsMkxTUZS2+rqmBk3Bkro2xlpI9aL1WsmBh/rT+ZLtWZxxPm3mjGuuuzYci6SGh7s7evfu2tN9sANjEQoFB/t7nnzsYUVTqMXCZjQS1uob/CLrhCP+dWs/EABbNu0cSBGCEQK0WAGcIQm2bt9KMAkG9EQdCgcjfgNnsqU//uEZJoWpaYaqTxw3MR4igbDQTJLxK7l8ef26ddNmzU4nU5QzTrX+I0WCQaIu5iTLv/zBQxgKDQGfIhyIi46lKkRTFcezATpaMgEAiKQAQkCEIEJIwS61LCenatj1cHK42D9cStQ33HjzLZgorkeL6cxbb6w43D0YDEcMPbhhw6ZNmzdRziKaGYuEXMfyqFNxMICSUk9CSAjKDmUGegcMDYf8OnPLGjaiIZ+QbimbGk71cgdLCGrV23TTCPgDqVQqHo2dc87Zm3bsTmV3SwwViO+87c6LLrkkny/opia44FLUcksSdDTr50h09NHszULUKLGmDdemOMu2hZCqqliFIgRCxbBSyGKMpQTTp072KJVCtDU3csaE4JMnXHPukjOTycFgMBQKhTHC/kDI8zwIpKIotcTOUkrXcxfNm+NRapUKDmWEKKqqUEpHE2Dtlk5UdeSHJV0f/Vf01wlg0F9Hf/0dO+Fx1Ac+DAXBCf6iH2rW+9D2iSbB0dBY+0Ujv3o0DTLGAoHAw7/73bJXXrlq6VVCCNM0i8XiZZdcsnv3nm9/65tf/spXMYKVSul73//+o4888vOf//RjH7s7M5y+4rLLqpXKL3/xi0gk6rmubTv3fvKz8Xjd/n27p0ydUfvVtWDC1pY2AEBXx8H3N2x49913D3d2csZnzJzZ1Xl448ZNwYBRyJdKVRsB0FwfbWlpAi4PBwKmaWKshMPB1qZ6TVXOOeNUzun7G7d+6UtfPO/cc95b+96vfv3rye2Nd952KyTKrx594rePP3fOmad++u67wqYmvOpPvvbTQCj0z/d/EkBgGEHs06Oh4P7OI1974OeqL/rY40+0jxu/aePavzz/wh+eeWb27Nme5+Xzec7/I160tuCO0OCH9uPfIvYPZfiRk8GHmQePGxUn5X+r/E8EwhHw+1umwv9PvuL/k+uclP8JUhsnjDGEUKFQ+OY3v8UFbWttufraa/PpFONY0wnnAgAIJORC1JDNdV0ppQRHJ1YgJeMAY+XBH/74lVdf273vwMj1/T4zGDIKeUtRcSwaBRC2NyZuuObypvoIdz0EEQecCSqA4IJRRqXkQnImGJdCRdCSwGEsYKL6uO9gT27VynWdXX1XLj3X7wu4risEl5IThRxdGglGhEgpIqFQerjwwssv2p47pimiGLrLhQqoBEQiMpAcqjgoX3KbG0IzpkyfOHFiPJ7ggp5xyizBRWtrayqVWv3W5p6ermrMV3a8aNCJ6ZCWQTmnCSOEEeOWPS7uP21G+57DBzyoHhmuUqTEgqGmpsT+PfsPH+64/wtfuG7plfd8+r54PJ7JZGoLT82psvao4bFcBTV1aiTXGedcNdWB/oG//PnFzZu2lEsFAFBQN9qaE+2t9bFYhDFJKS8Ui3v3HhwseNSlnd1dc8bXN/hkJBiHUglpk3uivsF0ZWA4tXrNutVr1vn9QQXLq5Ze/NGP3Bj0q9FQHAIEoQQQAIwgVEuVsqqqF1x87pJzF9tOOZXK/OY3j3d39ZyxYEq1TmEUQsGKVZqp0r4hQWnZMFgwCGNhf3N9pJAv7925u5ArtLa2Lly4sL6+cd2azXt3dfh9fscRliXPPX/J4sWnJJODTz/9tOdoTEOVaq6uMTpz5oxxE8bNnTsHaypEGBGUSqYOHexcu3Z9Z1e3A8JhXRq6tubdd+adder4yVM8y9KDhFO67q23X/nT85oRYAK+vuxN6bLzLrwgUp+o2JVK1dZUHUFAGVUUBQqBIBScB0zf6hUrpVvVjYCpNTQlvF0dg28tX3HzbbcxSQzTMFRcKBalAB73oqHY9q73KWO6YWgGUggRAnkeJViBiCmGKTnzGb5wMBhNwKDpAMoYNQ93DqUKVqKh7o6lSxcsWqAbZqlYOHTw0JYNm/v7jmSHUkdy0rGJJ43GYMCHnGK13NFdkLrvo/d+ItHYMJhOGrrhWHZ9Q8PiMxY//LuHh8tDl11xxW233SaEcGzHqlYXnX7K2vc2rl61Ilbk0Xi0s793KFtND1da2lpvuezceKIul80dOHgg1T98+NCRL33ui42N9ZMmTh5KZQ4d3gmQjEfrc4WiRa27/+mehqZ6AMAXv/Hvmzds2rBuQ7FQDkaifcnBw92ds+fNLRSLTAqMMQRAMBaNBMul9J4du1Wk+TVCgeMIVq16X/n85087e97wcBEcDUKmEkAhXcOn66YWbQhOmTvxlHMXvPzCS4c7Ot1MpiURVQx19YqVa99ZoxCcqI9JIFVV9xuKLjllimFGHMflkjOGe3qLyZTVMqb9vPOWmH7/tFkz/JGQZ9n+cHja3NlnnXf6d//16+WKNaY+NK6xbTCbBdCAUWTqrKle57Qa9GkhfziToedcdFrVy0ZCidmzZmOCbduuWPTggYPvrHwjEPDFIr6mBlPlMtxsNNS7eSuSyQLmWtTjEIKgqfpMkC2VADah6h46eLiSLc6eOX3d2nf7U0MDSQARMnRNV6AkhoJZIu4LB9W+gXKxxF598cXb776TSGl5NsFEwQQAWHNj4EJSKuOh0Dsr3kz3Do9taEzn85lKoaG5/mP33D195syqVUWIQACnzZvx5OOP93X3B4xgU0PYtvIq9umqkc3lAcLUq6oUMe55HpcCRGPx3bt3D/f118UMiKBLsct4KKqGY4R6qutyRoEnhM2o7XiConR/snVMyyc/9cnh9PDvHn9GMA6lbG9uOe/Cc4EiVV3hnEMAATgWaoWg4KJmiKtZS2puokcj0wCoIUotSTXGmCiIelRVVSklEwIrBoQQSFmu2DUVwitbAAAAYNUuqLpvwqRpQkjOGWUsm8/VFGhpWUcXEggggFXHhRBChHWd1LwqRpMbPJYn5jizDPhrdfxEff1D+Q18mKoDR1HliRf8Oxw4cvxvAeFxsHfc8Q89p9YFx9LzEF3XbduudQeGyAgE3l3z7je+8Y0vfenLtVogjLF/+7d/6x8Y/GDDhrlz57quRwj56U9+8v3vPfCn55694cabmec51eq1S6++7IorFyxcDABQNU3VtJeXvRqPh123vH7d6gMHDraPnbB29bt7d+5K1NVVK+V3Vq8ZGE6PPKK169YrAMycNObyS8+LRUKuU21IxMe3tyhIcgkamlr8wZCUSAApKJcQuNyLhP3Pvbzyk1/45m233dLdfURB8Dc//E53f/rTt3+zvaXuR9/9yjlnLjChfqCj92sP/rxQrjzxsx82x/xFu6yFzLpYfMO2PZ/64jemzZj9+BNPxGKR3s79Pk1/4MGfRaPRoaGhmi8xQrAWx1FLJwP+GvKP47rRJsHRFsIROc42ONLRI3six42ckzT4f0H+JwLhSTkp/12pzZKKovzrv/7runVrDUM797xz4om4U60QBbFjfo9CSikE4LX/117ZCNUwygKBIGfe7n0HGurrvvYvXwiZfrtqTZ8+qb4+ls+V4vGYqqp9vX2aqflMkyCIoMQQUnl0r44LfmzL7uhMLY45o0KEJo4bx4WayRb37dmJsHf9ddcRrDiMQQg5F1ICTdMIUaSU0UhTLlt87OGn7IqTiEbj4YBOMBCMCQmIzOXy2Uyx6ol5ixcvvewiQojrurbtQAQnTpyAEBaCT5o8ceLkCWvfXff+2vf7+6vVoJ/F1bqgJh0HuQIRwF3PcyoBnz5nxnTbchBkUlCMUCBSR8VBILmA6LmXXu9Jpu+666758+cDABzHsW17ZDmp+VyNrElCCEVRIISqqkKMnn3mj2vfXYsACJnKOafOOOuMxY3xsN/UVB0w4TqOl83kzzu97YMdXStX7+noGtq2u3v29LHlfMl2XATJhPFj2tpo74BP0VQAwZ59nfmi98TTf3l79bvt7W2fu+eOmZMnGD5DCIYRFkip7SiXy2UAMEbhxkbjG9/46oYP1qUObgoYSoWivgE7ZzmVihMOhcLhcGdXV6UMIlFo+oAeIHUokslkksnBrq4un8/X39evabqmqZnh3OlnnHbRRRd6njd16pTrrrvmuT++kM1kFI3cddddbW2tjudUKlVp26qmAQiamlrGj5s0f/7Ct99+562336xQHvVFk9nio796dOa8KX7TjwDct29fx44DAdNsrKvDCAxKb9Wbb274YMPkGbNuvuX2lrq459lCCs/1GOUAAohgXTS24YMNf/j905FAQDN8hXK1SmEsVrdm9Zo9e/YQhYQioUsuvnjRosWlcklRFATE8tdfo7QSiUaD/mg6XekfHC5UaDZfdRhvamqUDPUP9mdyRiCn1YWUaRPG5rLWUKYYqot//gtfaGxprlpWsVRSVXX+/PkL5y/0XOdIT88zTz490NcjgeMfj8MRvZyp5guFmz9y05j2tlKprCpqzcO5XCidd855XtWVUl582aW1rP2qqjLGy4Xy9OnT1ry1gnpOT09//2DKY3D+wtn/9IlP1jcmqtUqBHDptVcvf2XF7379UCziZ25h7ZrXNWLWJ0KUiWrVDoXDH7vpY6ecdmq5WoUQJurjt99x28TxE376g58EZQBysX/PviVnLpFMSAwZpSpRCETvr/3g5edfLgznG5tiioY9D9oOC4b9iYa6YqlamzpqFm8BAJSAUlpzMnQ9a/yECV/+8pcf/MGDh/buMnwBogPLcbmEhWLeoi7BipXNJiHsAqKpKRaLGLGYH3BzaLhcKFfMgPmZz39m2rQpyVSKC1HI5hSEOQSlTCaoGYlEojC0y6eG68IhQzc9QX0mhAJiLgnXK1SUq9VwPHHN9VdH4wHPFRBCz/MwRi4TZ5x1umDO6pVv6RpxXU1yDiEPBuNlh1fLGde1QpFIfyrJqtr4yS29/blk0nE5uuTy64iqzJ47995P3bt65dpSsUQIHh7OYAyDAdxYH22uD0hZCRZ12xarlq/yhxJ3fPSuqlP0PA8KICSXEHquq2lGe1NzOpVe/spKHWuKopTKLgT6/fffX9/YkEolEcacC0ZZXSJxww03/OqnP+FefyRYN6YpASSq2nq+bFmOVcgVm5tai8WcPxTgXHR2HH7l1eexxlTTLFVlLmNTAYiiYIx13XRdS9FoIBzxAWNgYKBctE85bfHlSy8PRYJ/efGFVDErIZAcDGTT333g+5dffvmsWbNqmUio50kpMYSCcS5EbbKqgd+IDi2PxZDXVO0ak9RmM3CC/W2kjRA8FgZOOOeMsdqnauq3lEcTfox8ENRcb4/td8MTcoHIE9KEjv4rGIV5J/IbGFWX77jzP/SCJzbgX9uIRh88Dg6PYw94gmHwbwHh6A/WHoKu61JKTdMsy+rr62tqaoIQ1vwhv/3Nb33z299avHDRrbfcAgDYtGnTV77yldWrV3/uc5+bO3duLXmMFGLmzJmrVi4//4KLAQBEVVvGjPvG976XTg9v3rKFssL2HdsH+pOCi76BoQ0btnd1HAJAAISAOFqOWFfAxNbGSY3jIMSqRqZMndyQiAX8vkQs2t7WigkWiEApKpWS4zFFUYrliieAVxtLEkgJkIJt1/vDs3+GEK54881y1b7thqsnLVp4ySWXN0Yizz/5iFepcCbf+2DLzx5+ZN+Rnp9+7+tjJtTb5SxSoD8SGRjKff3bD0yaOPGZZ56JxeJDwymMSTgcllKmUqnaY68NrRM1H3iC0Rj+DTmu40YPj9FYOHpUjJx2Uv6PyP9QIDw5Ck/Kf0tq68rhw4f/8Ic/IIRMn/973/sOYx5ljqIQISRjTAghhJCcyVri8mMpmwEAnHPGmVUqccc685RFv/H7qlV74ey582ZNZdQhGBOIwViy8o3ljNEF8xc4jEkgVQUJRo9dTAghpJBCCHmsLaWkjCGEFEyqXkUl6uQxjSG/KiXt7Ojt6e6bMWM6IcRx7WOFizBjoqGhvr8v++ijjxeyuca6WEtTPGTWag0BKRFGiHNQLDinLDnjhpuutsvlUqlcIzLXcRE5Oq1zTrAGLrjknAkTJr77zvqent5UwdUUXB8xuRSOxzCECEhTwYhIx3KbG6LJolUqlteveS8SDZ9/xoJ3Vq/PlqsffPDB9m3bPvHJT86ePbuhoSGRSOTz+ZouhY6lNh3ZaEcIVavVP/3pucOHu/bv3w8BaGuI3f/Zj00dF6kUi5w6djHPqobHgOdRA/iaI/5rLmxijvb6e5v2dw2MHdusICQUhXJuWQUgWEtdyGOUqMr8WROGsu5gcrC3b6i3b6jrQMd5Z5269MpLp0wap2CIsAoRIpioKgFAQZAIKQWSs2bPiSP/wc4DuXQ2k3UcB152+TkLF52CENq/f//mjds6OztyhVxDY6yhsUGwrEe9fD4/MDCQiNchhLK5zIRJYy+++LxypSiEqFTL8xfMq1TcV5a9GgwHtm/foaqKbuqKqiIIAQQSgGq1Wi5V/P7AjTfe2Nl5KNXVEw4anDvD6b5Vr+xXiM4F1HQzXhcO+ci4CT6fyVpaIkOZ+r5k+v133laBOnbi2EIh09TUPGPG9Ig/YLmOZHzbps0v/unPPtNUVK1Qqgxlcy51ocDBQDCXTgFJuw5aHQcP3XDD9acsPuVw/8C6te92d3bUxc1EwmdXWX/a6erPI8UYP2329JnTTjllEZTy4L5927dt37h5C/d8plEtVGwG0JKzz2kbOyaZTCqahlXChbQcR3AOAZw+e97tH0M/+cGDFQtVbVsP4MywpeuBRacuFPI/tFvXobFIbMfWbc2NLQsXLqCAO64DAHBdlzE3FonVLMmKqjouKpXoJz/9qXMuPN9y7PTwECbEdRwmeaVSkYKGg9qE9pZSISQoCcYC3f3p4eHsFVctveKKK7p6egSQAAKHujwzPGXalOb25kIuFw+G169Zo2A8bvx4l9FQMBgOhg4ePPDc089IJhvqEj4fEpxIqCOsVYpFlzqYqPJYvoq/8kmpFbk29GKxmIjGpk+ftmvblsHUkAAwWyhFovHzL7t82ozpQALXdRzL2bhu4749WzJ5PIbXNybqCuViJl+5896Pb921dfW6d6+79lrXsVWiyJqvNRWBQCAYDDLBmRDlqtOXzFge1RUZDftjYZ+CZW7IqlSrS6+9PhwNDqaTPjPkuk7NK95ltGKXr7hq6d7d+/K5bCGEWxI+KIFjs0rJLhQKl1952bU33fi1r/1rdiDDDg9linYwGr/ptlunz5xu25YQct7CBdNnLgASIoTSQ0OPPvzb3FBfJKLaNsC81N7SJLhkMr72ndXDQ5kzlyycNm2GrmkIQoAR9PsLmcKaN1du+GBjKZtta4gE/CSZY/5AxDSNYrFECGGcM0aFFIPJgeamhpaW9kM79+Wz0i4xaoMyLSq6xqqVxx99fN7cuaZPUxRNSrB+/YZCPheNBPOl6nCmVClXsKpKKWuO6BBAgkgszv0+n1MKNjT5b7zlRo95pUoJaWTs2FYp4ZGBVKlq7dq1q6OjY9asWVdeeWVdXV0kFEYQ1jzuEMGVakVRlJoNcMRGV9sTrNHgiDfjyBpR82P8UIHwrxL919rH5sYP0aePZub5j4//TTvMcUr5cXr8h+r3IwcB+PASguBvY+Fx1z8RJ8AoqyD4awshHGXxO+5TozlwJCwQjoLMmuNusVi8/fbbs9nsO++8gxDy+Xwvv/TSv3/j62eecebrr79mmj4h+J49e7q7u6+44oq77rpLCBEIBGo3f9FFFwEA1q9fu2fXTk8ij/JXX35p+9Yt1PM0jBDEuVFViGMhv0/XFCwjfn3W1HFRP2mNBfw+H4OmqmCEMMZE01XDMFWdUKvEMEaqKqTUDY1SjBBUVIWoqkCcQAgEAwCrhhkMBFtaxsgt+89ZctZdt990+uKFD/7qoVQq96unv08rJQTIexu3fPpLX6talWee/d2C2VMLqX7NNH2+sAe1f/32v4cTDc8//4LuDwwkBwk+Wm6klpVtJDrj2Ba2OM6BboThR7pgtGHwOHvgh1oIj+um0SPhxCF6Uv4Xy/9QIDxO/tPQwQ+Vk+P4/4jUlNGe7u4777yzVCoBAM45Z0kg6KuUighBzpkQgHFOPY9xjgQHjHEpj1m3jrqbupRSu4o8J5VKqooynC984lNf+MPvH6qrC3QdOpJO5ecumNPTn4IInxGI2vkhhSB0NK2pHKkIhOB/TNw1N1SEIAcAAKmqKnNc4FajITUSCRQq6LVX3+zsPDx+3NhxE9o1VQWAIAQDfn+5WH78iUdzhUxzc7i5PhAyhXAdKQBGSEACofRsV0HG5EmTBXQcxzINnTLmeZwoWACBEEQYScEdF2LMx08aP2ZMyw9/9MuKzWxXVMoVQ9MkRgIAySkGEksBBMJYhEKGZwvbsZZeeMavvvUvuw92/f6V1b995BGP0p///OcY47PPOfsbX/9GQ0NDpVKphV8CADBCQsqaguXz+X/2s5+/+eZyAAAAcMGsad/8l/smjWvp6+9UdA4EgYoGICAqgEihTDCPowo5+7T5HQN9HT3JoWylMWS40kNQqAoQDgQcCIdalqNi3BbTGkPjBoeKuVxpIFN66sU331j9/kXnnn7OmadMGdeeqKuzaZUQYvpMTIiq6EKqPkMfMy3INE78ID9c6eotCoTi9XXDQ8Nz5s2bNm1SV2fXH//451Sq7Lm4VC62trZddNFFu3fv2bF9Z7Vq+f3m0qWXS0gdx9Y0lRBYLOYWLlywdcv2oeHUyy+/XCzmb77tFup5EgDBOcSoVsWxVCxBRKLRWNeePQGfaGmLFyqGa+vZQtmhEkDN4pWhiiW7pF9DdfHQ2DYZjbb6DOP9995av17xqGvoent7e7wuUXWsXC6fTWegBP6Az2OMARSM1s2cM1uX+L01b+sqbkzEbcq7k7knHnvylWWvlktF27Z8ur+pORHw4XzO6urrr2tquv2jd0+eOgMgyZnn2s45551/1tlnP/zkw2vffId29PijQUnkxEkTbcdRDV0iyISo5fIiGAGAh3OFxramQCScG/KwoiEomFAkQgc7D8Qb60KhYE3XjUS0fbsP/PSnP3cse+yY9hvvuOnU004t5AuqqipKsL+/f/ny5eFwCGM0lKo0NrbPX7jQ8ayqU4FQkVICCAGG3Uc6FYIMFeoK1cMQcFX1EwVJgrU17743ecakyVOnesxjjBODcMao5ZkBI510g2bQdfkbryxnkgGCMIC6pnPKCYRtY2OGpqZTQ/lhrBgmVjUGci+//vLnP//Puq5TSmvJSMDRbPISHltBCCYQoobGJl03IcKFfKF97PjP3ve5QEPMoR6QQAhumuaiM05f9cbyN158aXDA9exc1RahWN3chfPXb1rrj4YFhrI2UwFIOfcHgoPJwb7+fmgE847IFXLJ4apAChRuyZH+SFhIOpytRGOxeQtnFSsF0/RTxoSUmq67jguI5JKFI+EJkyevW/2u5EghkDMPCJ/gUCFkKDNshgIXXH7pcw/90XV1yvRLr7zirHPOHBxMEkURUrqeR0zV8VwM0YQZ7dfcdO3vfvbb4XQxZirxoN+lmfYxfk9aubLYtGH9ju2bWloaJ02eNGn8xHhTQ2o4/eZLr3UeOBzQ/aYBTT/1RyROutlsdefOnXPmzS9WygACIAVjDCEgpYAEeRrJOna+d0BQVTMVjznhYNCzvDVvr3aFi6DCOFeIEg7U25ZbKhfC8fAZi8+cNGmq4ziDg4PDmUwoFNq3Z28mP8wYta3S9KbxjmdX7KovYJx37pJSspQ80tc8JXowPXAklbEdZ+PGjXv37dU1bdqkKWeecUZ9fb1t2/5wsLWtvWYB1lRVSAkRAscUbELwiMtorfdVVa1UKuKYNWlkxRmtk6ATovVGsPC/rrqcqH+fSGuj2/9FIPxQGjyODE+EQDAqPcl/CwiPu7HR54z+7LEGZOxokcbvfe/7K1as+N3vfmcYhpTy8ccf/+x9nz3t1NMee/RRfyAAJQAIfvSjH73zzjvR0dxvfNeuXY88+uj+ffusajk9NNzT0yPE0aft11BbU0JS5bSF06ZOmb5z557BwcFoJBIJmfXRYCxgKEgQoqtYlZwx5noWo6hMbYgJIRgxbkKsSKIyh+s68QFPQoSJxgBijHqc6RAgjImiSA4gUv2B0O59Hes+2Awh2rN7V1Pdp3sP73/1+Vd+/N2vn7V4Tldvf9ZyP/VvX86Uy/9836fPnjVhOJfH2B8JBtZu2fsv3/uh49GXX34pFIvn8+VwOIyRrFatWiFKCOGIj+hfqRZ/PWxOJPC/I8cVhPw7w2l04784jE/KP7T8YwDhyeF4Uk4UeSw5W22L8VvffWD9+vUAgHnzZv/kwe9x2yYACgFozSfTc6GQglHqUSCBOGonZEJwIIXgzLUqtsMKHk2E9DtuuvJXT/xx+969jz3x9Kfv+9QFS2+yq+6m9W/e8/GPlUtF1y6pBCEghZBcCtexXafKmMeoJ7mAAEopZc1ACABEUAIhoFRUIoVwHMwZa6mLUsvrz+Y3bN62aeuusWMnTZg43tARpdR13a6uzsFMuikWaY1GQ6Ziu1UosBCSEASArDowVXKNRKhtXBt3qa7plDIhBZASQQQFkkwAgIAQCoHUscueGwkGE3XR4f09MBESAHhCSCCZBBwCCRCUUmAAgezt7PcEAgA4rlf0SmPa679z/311Ad+DP/2ZIwGQ6K1VbzmV8vU33DBrztx4POFRz/U827IBkJQyVdVKpeyBA7sBAIrqC/jQfffcMmVie7lSjUbrK8RghisYK5XzgrtACsA9iAXFiqmKsxdN7+xKOpSpOrI8qBFVCskJ8jyqKipkjDEKINOJPr6tvrUx4e9LD2ZymXzpmReWv/rWuovPOm3mjKkTx7W1tTbathWLRV0hhMREVdQEDnotbz3/0uzJU7OF3Dur1ixatNgf9hdKOQzB1Nkz7/QF3njtzXQyJSRoaW2eNn1Ka1vjKaee8uwzz2VzQx2HO087/RSMa0ZXrutad/dAeigVjUVDodCGjZsmThxz3vnnZ0sVCTHnABEoOVcJEZ5bLTGMsKZzAJk/aJSrwGO8YrnVasEFLBaPdXRnsUChoDNmrN5cH5w1va61JZYtCgDVfC6fHBjo7TmiYEPVWMgvg/4wZbB3MH/plZdffd11TAp/QE/nM7s3b62P8ynjY36DVyusULbDeqStvi4WU+rqNCFFOlV0PHbjrbdOnTU9mR0mEGEIIYBDxZxpmjffeltLU9vyV18/khxobGluaGi0bRcR4lKKAIAQEqxQzxNAIkwUYtQ1NA307S1VZDgWD4e04Wzuud8/t/z1VU1NTfX1DaqmQoq2bdzsIzIWC+aTyUcferjz4GEEUWtbKxDihb/8JZUcikXCubyTK+VPmTlFN/SKVcFIEQA7jqNremogtXvrPkNTojGVA0aFablS5+W6WLBo8+HswI8e+P61N9w8a+48j3rZYu79994/vP9QuVgOGaQlwdtb9WIR2JbCBRHco56tGNgwcEMcD/Rb5SqEhEPL0pDWGGpZv2p9LBS9/SM3Y6hWHatW50NgISWEElHGAOeqpg4PJ994/UVVQ6VyORyNfPLTnzCjvmxmSB5Ti61qmSjK9Tdd33nw0M6tO2N1QSYFkEo5X776iqWUiXKppBACAOCCYgQUwR//3aN9R/ri9XXFsp1Mp+YvOuWqq6/7yx//2HFwd7boBXxaxXIXnTo3EkuULQsrAAoBgPQ8VyHYEQBBVCqUBo70GZomgZrKCddlmil9phKL+Ldt2v6T7/3Ydi2kSKxKiERrS2shXyJEwQRTyhCEgksFK4zS3HB20aJTNi7YuWn9ikTECJoRhCCUsL0xUR+F7Y2RZH4g09c/2DX0hlihakTFChBizJg2BEF9PYmqTAHCNIJ9Q6lkamAOmE3tsqpgj3LOhWn4Nm7Y2N3dKYRVrcJ5i2ZGIvGWplbbclatXAUwamtrVVGV2q6m6lWPD+XLXMBzzz173sK5sXiEUoEwnjR5PJDQHzCmT5vw9O+flshlyGkfM0bXDMqF54pEouHjn/3kunfe3bxx0zS91W+q/cl0vuJWypVK2X4vs379hg2m6XcdNxgOnn/B+a7rHunpaWhomD51oqqqgWDAcz2sqMPD+UxmKJvNua5nVcvRWCQRT5x73rnRaMy2j+YAG60x/335L5523EdO/PjfAb/RrAX+GgxOvIfjzgEn8OFxXwH+OjJtNHIc90UfSoNglK115PpSipHLM0YD/jAX9JVly376kx994uP3/NM//ROQ8tVXX/nBA9//yO03feUrX21tHwcAyOaHuroPZjPFwb6h7HBuz/59/YP969e967pe7adpEMwY39ja3FjIDiUioQXzZ9THg061bGgKxu65p04qlRqQREgiRl0CBQLStaklmJBSSoAxIhgIALigiulDgEAAMSISSCYEYxBi6LmukBII6dk21Q1FMzBCAJmaphOMY9HAtKmTBoY2dvUlz730KiSFTeErr7/d3Fg3ffpkV+TPWjQzHIx/+uM3F6t5AHkwGtnb2feZL30tmcm9+urL48aNL5XLlFl9Ham333770KFDn/rUp4LBoG3bI7br0RxYw8K/NUKO66zRtsG/RYngr822f39knpT/rfKPAYQn5aScKCOu8xjj1Wvee+W11zDG0Wj4gQe+09xQnxkaArXSCEJS5nquixBybAsBLDiXjArGpKCMUcmZFJzblmV5xbIDWWXKpAlnnL74rbfXP/7Uc43NYz5736ei4cCECWOHUwOSMyGY4MDxPCG4kMx1bUpdKTiQEkgJAYQQAghgLe0JgoggAjAAQkKAFJVwBCQd3xaNJsLFipPJFLsPHujqOOhxCyGMEFJVNew36kP+qGlwu0oglEACIIBkUHDLEgxACVjVtUM+v808xjkhGGIkmSQYCQERgAARKalpmtRjUoBQMOI6ezgzMDaZkEACCAEgRFIpOWeShQPBhkSoJ1XESH/zrfeuvvqcxTNns2L2Mx+/ze+DL762YvP2fQCAdR9sXPfBxomTJk6bMXPBvLkL5s+LxxOYYMGB63i6Hrjg/CWvvPxmOlfCUEslB44cSTQ0t0nq+P0BYBqe47jMkzYW0oUK9KTrEg8xNnlMW2tjfHh4aFKLT1EQAljFiouloinAk0IiALAUQAjJXIdL2d4QiIdVm8m+5HCuUP7zqyv+8uqKGVPGX3vNZQtmzvQ8GQj5dVMXzPNDpS42Yf3GHo+a4ydP3bVj78GDh865YAmHHoSkUrSnz5hRrVSf/v3Tfr+/p+dIb39vQ31dKnVwODOkqsprr79BKW9taQ6FgrpuWNXqpk1bEEaxWMy2Hcu233h9BWVwzryF4UjAkxwQqSsaAfB3D/1mx7YDY1pCegCWKqC7L5fJF23bi8YTMydNmbdw/qxZM1PJ5Msvvrh3z17nsI8AFIsY2VwxW6BCQCGkQohC1JAvGAjKcFT16Xpn17DgfGx7mxBsOJuRSmTS1Klb1m+uWlXO9bEtdZWq7O7NVWwoOeScFoquX4sP59y6uvrW5jaCsK6ojLGajsaYdKiHEVp67TXzFyx4Zdkrc2fPjUaihVIJCoQQwhIIJrjkAECFYNt1IoFAc1PLRm+TxzWCzUAQRMKWR3FpOJcZSNdKcCpAVQkIBGFLQ6xccnvT+ddfWIYxVlXVcVxNU+vjccpYqWQ1tzVdsfRyLiUAWAjgcaqquqEZ6/fss0rFiRPiAsue/jxjvqFcUeVWPBYxDTMSRlbFevS3vwnHEwhjp1QRjOkKDgfMiN+sj4UZKquY2FqACaSqQDDHZ2qqxm1qHelLnXHWRaedt+AHD/zIH9QiJuQisOzFV450H/7oPR8bP3Hi0PAwFRRi5Hnc0A3T8CmqQiD5/SOP7d91aEx7W2oodeqcM1raW1LZYU1VgAC1ODEEkRCikM8DKLAKPeHqpjrcXzh8oGP8hPZ8JqOqKqjZP5HUVaW/p6/nUEciFgfUdezqJVdcdv0tN4Z8ofMvOP/A/p2poSwLByn1FEU1dF+xYknKgWBCAgih7bqUy1Aw/PbbKw4c2Nfe3Dqctw/3FD3qqGpWIVjX/Ylo/Y5NW4S0gqEA4xUAmOd6iqI51EMSEEKEEEBACICKNcaY6zrnXHDGgb0bhnPVumgdwOpAKlkslEPBcCQamdg2xhzrH0oXi5wWKw6RREDucU8CXq3qPiGJJlUsFQVk0lnusbA/5Dq2ThBQ0JvL31z+xpsKUYNm4LLLLlm4aB7nVDBh+vw93Z3r128M+PWGehMZGEjoUM+yywsXn3L5FZe5rlUultExlgAIZdLVGVNmnXfuRStWrtLNYCaT41xKATXVsG3KIF1yyflTpk/93S9/NaGlrS4Sc5iouHTv/v1MAC54uVIEAGYyQ8/98dmRReSNNwDBSAgBEQQAci5OXGj27tl93+c+Fw5HPc8DH2b3q6V8HJHRDPZfl2O89FcxhKMPjuj34D8DwtFq/XGcBk50jf4wnBj9weNO+E+BsLYij9xDzS+XMaYoSjAYBEDatlWzuAaD4R3bdn7+819Y8947l15y0Xe+8x3GKMHowosu/OCM96PRBABgy9bNL7/8yksvv9jb11UpOiOPCwFw23WXjm1v3rd3X1Njw4T2lrFtDZI6xXweY1Qu54tD/QG/KagCuOScAQ5t2wESEEURHEkooZBACgQkgEByJiSGGGOEhQQIQO55nuvohEAgKMUEIUwIBEByLoXwPKpqJkYIYo0oarVaHj+2/bmnHn3ymedXvf3OmWecNjQ09PDDTz7/+ptvrHxr1qypl11y/rf//ZuJWLiUy3DKNJ9RcayvfuO7uUr1d488fuaZZ3ieu3Xzpn/+4hc7O7uvuebae+652zTNkVLAI7153MAb6anRFr+R1xNTyIz0y3E0eNxoGf0V8mSxt/9LchIIT8o/sEAIaznK/vD009n0IADgrDNOP3vJWcPpNIKQcU4p5Yx7rh0IBp995hnOxVVLlxayJSkEo67k1HNdTj0oueSUSPDOWysVTZkwdfrppyzcvqsjO5z+wYM/ev6Z3y65YEnv4SNBv+k5wvMYdV1KKedUCOZRl1MGICREYUJCKRBCGGGBiQRccoEAkRAiCHQdQAAqFSaBwIraqKGojhuCim3TsuNUXUNKoeuGoihhvxHyGZ70ABBIcCEBBgBwAYH0q9hHRCqfffrxpz5xzx2KSqSknsdrSgkEEiIAoIAQQoQ9l0qJDNMfDoV9uimZcCxL0VRMsJQASYCAVAminqer+oxpUzOlbZYjC2Vr1cq186bOLFUyyMtcf+1Fp58xb9krr1GhbNi2f//BQx2HOjoOdSx78cVEPDZ37ty5c2eHw9GJ48ZpKo8EtCWnzXt3/dbhbK5vuDShygNVK+TXEUKMOgYmIc4gkHbVEwAgiAgUEONEPFwXj2AkE9FoaijLGcAQEIwQAlJgKQWCpBatyYVkAmDhmlgYCg60xSsJenCg4NrO7gOdyUeeOf/M02dMmTBvzuzW1gaCoE/R44HgN7/6z1/8xrc3a3vGNtQPptIYqz4jwDkHPiilTKWHOBd+f2B4OPPU75++++6PffDB+1WrFIm06bqxYsVbGBJd1zDGEKJKtRQMBfr7+03T1HXd9eRzf3xx3dotY8aMaWxpiCTCQIJt27fv2LE9Fm+MxxDAID1E02mh+dXbb7xl3sIF0VgUEswoq2+omzRpwssvLXtl2evptJscqAwXbAoFQtIwzFAsWiqXk9k+Bv119U0YO0JUEISDA30LT10cCQUiRpjbNkaerocULdQ7kEtl8rmC7VCZygLY6/p8JOhzIDarleKvf/XL0888a/bc2f6A3+NMMKYcq8GdTqZCofA/3X0PgtC27Wg4UiwVPepJhEbyJFFKTdNknjfQ2xvy+zU9ms273UdSVU+Wy0XEpG7oCEpN0VVdJ6poaArFEpGyNRD0+T3P8zzXrlQRwaqhA4yYxzHBn7nvM81trZbrcMElhBhj6rkuQl1d3YouNEPr7Ezlc47jFgWEsUhoy96+aCThM33BgBJLBMrlsuQ8Hvb7A9gwUDDg59x3uKfMkWc5vJArOsJx3aqmKCpBjU0JQyMAY9utMIcyV0Lktk+MkCSSaqDj4OF/+5d/v/Kqqy697LKwobmuCzUMIUolhw4c3rd9044dm3c0xcdiQBj1WppbXNeFAGKMuRQQIgAAlBIAqRBl0aLFO7buqBSqsWhE0worV76+YNF8zdQwwhBCx3EBlKrP3Ll9h+vY4UAgky1Pnjr5I7ffXraryXJq5pyZp5x6+qb31ypE9ZuBrZu3HD50qK65qWpVCSGCcSkBJiQWCRdyhdVvv91Q31CqVBxXtra2h0IBxmk+n8tlS5IXY4lQMBRORIJdXUOSoYHB5OwF86A9SsODoObOgAm2rcrs2ZOmzZi+e/O2I0cKFciG8kWfaaaTWZgsjokkpkzkE8ZrQzmjVHRKTsW2qwBKXdfLOceOqePH+A3DSvjhlve3DA8OzZo91x8IuV6ho+PQls3bfabpOu68+fPmzptbKBYAEIwKIcHChYt2bN+dzeZN4k+ENY9Sl0IhcFtrm+fRcqVi+kx+zAlQSok01fEcQojgzBcMrV79zphxYyZPnWLZtsRIAlAqFCvlioQQSaAjfdyEtts/dvOOPZs7u4c2bdrS0dEZ8Psty/Fcu1Kxa8/AA5hxqWkGgNB1rLpYcOzYcYsWLggGQ+FY4mc/+3k2m92ybcfq1atvvuW2WtFCNKoAT03+ToThf9dlFP114N+JeHYcg42u6QdOiC0cfYW/bzMEo0yCx33quKsdB4Qnymg4HLlaIBDQNG3ZsmWpVPLuuz9WqVRN0/fSSy987K6788XCj3744P3//EUAAACiUCgODvQXCvk58wJ/eObZL33pi8V8rna3i+fPC4e0bC5z+pypE1qbJ02cAAE/fdY4IAGnbrWYgZxLzvPlsqDU0EKMCl2BUELBARQAQ4wQxBDVJjTAj/6oWnAHkAAjKAGUUjBGESeQUsK5ig2AECKKompQwbLmjgORBBATBSLkuq5pmFXLVgn51F03fOIj1yiKalvWWYvn79p/6LUVb2/YumvD1t2P/eGFh376/dPmzSik+0Ph+t/+9KGN2/Z985tfv/Mjt2cyg9/61rcfeeSRUCj81a9+5c4774IQ5vP52ng70VMUfhjG146caAMc6YuRsh/HEWCtMdJZx42KExHxpPwvlpNAeFL+gaW277hv377ly18HAPpN/aYbrgWCCcElgIwxSiml1KcbB/buW/nmyq985cvFfJ5Sj1GXOQ5jHnMc6roYSgVD6nrBgLl596FdHUduvXHp6afOWf7Gmkyh8OCPfz5j9iTTNBljQgqCkc0opy7jVAomGJVSQgAABKimLiCMMMaYCwAQEhgTCGu5zTGnLoJS01RKPeZ5pq4rKtF1GkUBziTjXNM0jEC5wvqHckhFEZ9PERCQo9GJCGO/CpqjPoeB5EBqxRtv33Dz1Zqmep4npWSUMeYhjAAAQAoEFQCgphn79u7fumUbIUTXNL+pMC6kkBBCJAGCSHChIMgRdOyK51IAVABAsegIgDxuq4ykBweZ637slhsEJDdc7eTyhY2bt617f8OOvR3DmezKVW+tXPUWAMCnatddc/7EiS3hAGmpj2WyuWXL16SGsrdef0Vg0jgJsZCIEKybpm1bNgAASISRgVSBkaKQYMCXzw1Fw6FKxXJsDwEpoeBcSgKhRFxAxjjGWEAhJCeqCgHwXFdXsKFrZjCUyeZ7+4eyw9kXXn79NVU5bfGCm29YOnPaJKJDQ9o3X3MxVOAn7/uSVS5fec3SRKLuSE8FQmT6TChga2sLRpgzGYslhofTv3/y6YWL5nJBB/rTCKrhUExKDyFYKVcUVcEEFUslTVWHh4dN02eYRijSmM8m04OdEBOACFaIhEBRVc8t54YJgUqu4LqS3njdTZdfeXm+lC87FSklRsS2Lb9p3nzbzVt27RzqG1SREozU3/axm2N1UUZ5LJY40nPk6SceyySTfi03ts3wm6qhw1eWvYwUMmP2rOUvvbn+vXcJlqZpDqbyHT1DFnWb29rPv/hiIFFPx+GDBw8c6eqpi9cF/IG+nt7fbP/llMmTb/rIbROmTXFsWzAOIUQYUcpc19FU9cW/vNDX2ztv4YLZc+dEQiHLtv/KECHB7x9/csumLY2JukLBO3iot2hZLWPGTp01KxGOaZoGIerr7+3qOJLLpk1TAaA4mMyWGQiFw1NnTp0wYcLw0NC7a96t2la5XL74kosnT5s2nMtgjD1GESacckVVbNvu7e1VFD2btQtFYIYb5kyZMmP2tNYxk/fu3L1pzVvp/ow/qE2f3kIQcKvCVJCiOhKB3t7SwGAhW6oIyRxK28eMOWXOzEKpGNDNVCq1d/duAkAiUb9z9/a9+3aafsPnC+SzjucJ09SgDFLGnv3DM5s3bb74oosa6ut7+wY2b9raPzAwNDyoYuTT9VhUCkmZkJFoRNN0UCkDCQhBNVUNIygEdz1v/rx57WPaC8l+o1Gtbwh0dHZu+GDDDbddNzg4KKUEUESC8Wx6aM077/gMHUEBgJw4cSIAAEKoaArA4Nrrrz+wd1+57KoY25bzwx/88Ev/+pX2sWMzmaymGopCqra1fdOWl55/MTeUQQgFQ6Hb7/nI9BnTAgGTcUap3d878NtfPmJVK/XxWF0Ul/L+/mR5/8GDl8BLEEBSyqMJNiUA8Ki9iGClkKsWi1UOiCNFqeJcfMmVixbMy+Uzr7+xPNk9AHv41EljeweHM/l8Y0vz2XPOnjZ1Sq6Qf+zhp7JVL27TRDiMGO45UujYt+vQoYMel0i6AMJAIIQAYghNmjSpWq16rkcUrBBSqVRaWlomTZq0d+8+14MccgGo5XBFMUKhoJDCMEwgj7LWUVVYSk1Vc7mcqmq6riuKsm/vnukzZ3ieRzQVIOwPBLb2bXJctyEWyDOvv6uvNJw9f8npp59Grr/misHBlGn6FURee+W1d999z+f3OZbteJQQQgjx+/1z582+6NILGhoao5FIIODftH1vbYlBECYHB9ExS91oV70T5TgC/G8BITzBUHMciY2mrBOBcDSSgb8GhpE7GcE8NCrC8DjAGN0+kQ9HE8XfAsIRu1YtmsPv9xeLxW9/+9vf/e53Tz31lLvv/piqKpnM8COPPBKvi952+42f/dxnOOfPPfvsw48+4rrO7j37mpsax7SPXfXWWwDI6WNbpowfGw74zjvvrEjIYLSqYCiFqJYyggvAGeNUJaoQAgCIEDQUhUPIKXNthwouAeecSwahhABIUQvI4xxKVOvJY08cQYgAgFIKfiy3EEJIVTXNMFRNU3UNESwFkBJAhCBRJcQIQkVRJACcc5tR6tlcCMdxTNO8+OKzzzt/yUfvuOWdNevWrv/g9eUrPvnpL3zhvk9edcVl33rw1z/99SOfuffjX/j85wuFzIsvvrh8+Ztf/epXL7nkkubmllKpXEugCmsuTlLWmHD0cDpuVMBRRr8PLTJRO0gIOdFIOHIRMIoPjxsY/8UxfFL+0eUkEJ6Uf1yRECHP837+818kk0kIwAPf+84lF1+YHhggRBFCcMY454xSm3O7at10ww3NjU3pdBJIzj3Xcx3OXO441HE4AkghCoZLzjpj497OLTv2njp/5kVLFh051LvnYNeW3Qf7hnJtsTouJSGEM4YhFABAKQAEGEIJwdGq9EdnTyGlJIRgFUPdRykTQjiOY1sVn9+PCK5WKhABCQHlwmVcQICkUJCEgnNql8qVI6lKzmMVakfMQICoUBGaqgEIMFEjKotHwjY0PXdo+/adZbsQjUWj0WhrS2siEQ0EfVICx7YpZybxGYb5zjtrXn/tDYK1cNCvKaqCiZD02K0iJCWCUFWV4UKpVCgCIRECkKjvrd98qKOrtTFkVz274mQzQ+XhnGFqvqDZENKvu2TJjVect3n/wJYde/K5bMfhDl01+vp6CZLxcMCO+ieObdm9v7O3f2BwYGDyuNb6+njQ7yOKKjkjRNF13VYUIDgEACEsOdV9vjFj2jdu3lnIFxvr6lOpFMEIQSCE9BBiCHqMU6YAgLPZbFdPOhQNRyIBzqDPULAAPmirESPqH2PZrLMvU3HoynfXHT6078v3f3b6nEkxjniydOOVF+3auffnDz/x5NPPtLW1XnDOmdlyzq44WOJTFp+ydcOW7Vt31DUkAEQIkfPPP2/x4kX79na8terdYrHo88nWttZCIZ8eGp4wYcJpp53V2NiwdevWNe+tqVQLwUBi5vSxnlWybFGoCNtzGATxugSrllPJsmvpRVpuHd94+plLBpKDSIEASQgRAlJRie3YiqbMXzjz9Z4eCMmpC+eecfZZA8l+TdWsqjNn/jy74v7iRz/lniaZFglF6xyWzQ8vf+21F158QToo6FfHtNVHwsHDXX0Vh5159tm33fURzTQglODsMziVL7/4wrJlL8aCiXgs1trU1NvT/bOf/OT6W24+84wzIYKqonqSR4OhdCr9+J8fW7F8uYrx1q1bGptb5sybN3/RfIRgpVKtr693Hfe5Z5/dv2tXPBYxDDNfqCha8O7b7lh8xqmG3wcRqXlJM04LKeu3v/hlx+EdVpV7HF9wxcVLzj4rkahHGPk0feasWU88+eT4SRNvuPGmbCGLMfIokwgxzhjjPiM4lBpOJQfDaoi6asXid37illPPWlgqF12uXXTlZafNnfKDb/+0VCkMpQdMVakUmOmHiYZAfzLbn4LZgjN2Qtv8hadohjJ77sxES6uUCAPk2s7unbteefHl/t7ucNAnpVANpVRy00fsilcWKoj56zFSmuqaOw91/brjIUKIVbEM3fT5/A3xeoxFJKS1N4f2HewxdDObySKEVIVAiQAAENWqMUiMMGfM7/NDCD2HagTHgr5MMLBmzdqWsU0zZs4UnGNC7Kr16rLXMunspAnt3PM8z2toaEQYCyG5EBzxWCI+Y/aczR9sbmqNUc47e3oee/iRj9z1UV8gkMlkOzoOr1//ft+hDk0hmqbFE4nPfP6z9WOaS8Vi0copigKIe+qZC3oO9/7+kSdCptGccH06CQdDhw939nR3t7S05HN5hJAQQkiIEYIQcs78vnBvZ7Knqz8UDmXz6TOXnPfpT3y8UMyYxuTJk8d95wcPZnP57n43mbGDkdj9X7y/saGeC16tll9/Y2V6sK9QskyshU19wrg6l4qhQrnqUpX4FKJjTJKD6cbWlrr6hG1bqooZYwCBmmU1EAxSyjBWIOQAStflhmFGwmHOmAQSIQQgggBIKBhjuqan00N79uzWNC0ajnie23H48ODgYENjo+25mqF1d3Vu3PC+aegtLUEMWLXXee3FN++450Yj4vcb+pSJ4zXd2LF1e39P54QxzaqmUkajAX80EvUH/Kefelr7hPEMw3KxBAR77tlnvvadH5dKlVpWyVmzZgEAamV1ak/vb65J/y+AcKRxIm6BUUlcRrPfCBAexwbgb5egGHkLTkDB4+7hvwWE4ISAQ4yxYRjU855++ulvfuMbiqp8/OP/dPvtt2GsGIZiGL6bb75506a1ll29aunVmeHM5s1bBAAIAJ+pI8nT3QfPWzz7tPmzZ06bGAua3CtblQLNFSTnBSiplEgiBJCqaApRXMooA0wAQDkCEkoIBMRIoa4njlrYQI0GJQBSHt0N+Y8fCwAmGGMkIThaKQpjRVEIIYqq+gNhVVMVTal5tUAAmZAIYymAhBJBWCvAi4jKhKCCEt3nMGEPpwmCAVW74cLT77zpymeeW3TXJ//5q19/4OE/vLh3967bb7n1+z/4YX9/7y233Lb0qqVr1qxWFKVSqQwPDwOANE07WvnmhOrzowfMcRw+engcx3vHWQtPHGPH9Sk4SYP/J+UkEJ6Uf1ShUmqYrHxn9Z+e+xOG8J67P3L77TcXCjlGqRSCc06pRz0PQpjNF2KJeGtrSyrZD4RgruPZlnAcz7a4XaacQQShoWtmoJzLR1W09KKzX3x99R3xxklTx+8+sH9o2F296oN7P3ZjuUQ5FxJBrGiex7nkEHKIIEHS8zyJsCQQAgABDpo+6niD/cmqyxVFTQ4OdnV1AqiYZghhhgHzmapfhZgxFUIpEJCQUw4V5ElloIgzVdra1lxXV9/d3ZXJ5TFRHbuMEIIADBpmJM/GN0eaYngg52zdtltRVMGBafgTddGW1jpKWX//gOd5gWDYNIzOjg7TNCI+tTEoDQNZjGFMCEQAAgmhgBQywQRiAo5paRvOVo4M5YlmpHPFte9vvfumKyxWsKsVu5Knktm2lqvqpuYnWFdVbU5LdNHY86ngVcdxqZPKDDoOLeQqBjbHj2s959xTt+0+JDyXEC2XL/hNH5ZIMEmwouk+RbMo5QhCDRoclASg1Wq16slswWtOGLaGbAxNLD0H2owQFTjAForqMAEAwYQMDle6+vOqhkJBHxK8OawJCRRdDfrJpElN+zv7mAN7krmf/eb3n/vM3XOntEmF8/Tgx++4ua+z58W3V3/1G9/ds/vSy6+8dMyYsan+NGLeLbffQrl38NChcZMmXHPddVRiiNVTzzht7IRxjz32eC6dyRWyuUI+Em3+6N0fx9grW/aFl58vNbn8hbeA7YQUl4dlIhb2OvKpqnPFNddecO7pXtX95c9/VSgWOeXjmsYI6XLqKViHEgKEYC02CmPPo5efd/nWdduSqVRn56HUQMofDJeKxXK1mi907Ny+gyjYBeBgj8U4V3TDNENCCJUYvgRrb/TVBX3lilcsML/Pd92116qqMpwd1lVNUKEoZOn1Vxcqpbdef7u5MaEFtPFj6voGs3956tl3Xl/VNnbspElTmpsb+/t7V765PJ/NjWuqi8YCpYozmO5/9ZW+Fa8vM0yjVKnWNTTZjmcX8nVh0NwQKFl6rm/w0/d94uwLzh8u5PKlEiJIco4h4oy3tjXfcPM13/neHkaQA9zTFi6eMmFyR+dhRVPzUoyfOeXBn/4YMYgh1kxUqhSFABBALoUWMCtluuzPywxJFcLzpcyceTOnzZw+NFyklBIk8o4drqsPNoYzhzN9Sek6JatSjkf96QIulHguW56zaP5dn/hoPBqjjNm2XczlAYBCcKIoC0+ZO3P6xG987bvZoYEpk+olVA7s7xszfsIZZy9ODw+uWbnR0NGEtnhbgqTzli1lU7MvoJomDvYkU0UH56turjikIF1VwO8ff66pqXX2gonZIpMSSMChIgFlCtY0Xc3l8pWKQ0xpKlYYy6RmpDLlB77xwJVXXjlz5kwA4LIVfzq4p7shXO83cNqGis9MNDd4lCIEJVBcLoMhNHHK2HdXfxCNQAj0UiGS7h388QPfB6piV+1SrujTw4moX9X17v7MpUvObBzfPNCfNDVdwSqRWEgwlM7MnTf99USgbDmFaiKaEIlh2DFQXvbCsk/fe09DXUICIgHwBKOUVi2LqIquq/t2b3WdKjcVVfNdfMVlqdyw57m5ciUcqYv7or1DpULZpq590eUXx+sT6XyGcS8QDNbF2vo7e6BkEgPGmEIMAKzmuKpqhkOpAjSrAtMYl10LqTxg+u2KhaDKOcMYeh7L5gqKqvkUaGLN8VxdIyWrXMxnx40bkxoeUogiBIcI6ZqBCcTYeOut9blMob2lGXGq6epwNvfSCy+dcurprmszz934/hYrnx8/vi5gaLAxVqwMHO48/KtfPH3WhafHopFgOOhR56mn/uCVrLbm+mR2eOy0yZ/4+MeFEKZpeC4t2CWAhB4IP/3ci99/4Me25wEAdM24//4vnH/+BcVicaQ4YS0u7kNXpQ+N8ho5eFxekOPADJzAbMdp/Ceq9SeaDY8jxtFq/cg5o62F4AQ3UfBhpAc+jEBOPHjcCY899tjDDz9cyue//e//dvMdtwOAAQB7Dhzq7+15e9XK3/32d+VKFQAZ9mvXLb3g7LnXjG2oo4zX6v2ahiqlQAhXq9Wh4TyAECPMGAcAcpcCISWEAkKXMSQhP5oUQAjPY5QKKWuF+wTgEkgJhARCCCCPgjwCUtZKvAJ49D9UM0VDADHEqgqxihRN9wdUw4cVhagqwJgQDATCEErKCCFCcMkgIBAIgTHiHgUAKBAhAAHCAmgQQpeCkmv7Rb6xMaH7VMvlfT1dP/vJj2+9/Y5CsfTY47+fO2/+7bff4XleuVyllBKiUEqP1a76DyAEJ4TzwRN2B0baJ5aaQKMEjvIgHd3L4G9sH5w4XE/K/1Y5CYQn5R9SpJQEIsdzf/ubXxdLhaa6+D1332lVim61AoF0PYdzQSn1XFfT9VdfedlQlSsvv8y1K5Jz5rquVeW27dmW5FQASRBBGGMMGxvq7/7YHdgXsuhTa9etu+XmW957b106W/jlLx46b8kp7W1tXimvYOJJiSDCCEEEAZaMcUJUAKTrugT6NT28Y+euXbt2Z7N5jwoIoeM4lHq64a9UswRx6tp+n97SGG6sT2gqtq0yghAr2BVgKFPIF4qaplxx5aWTJ03p7eurVqvU47lcjjFWKpU+2LCxWCr3Izpm7JhQzLXLZc65bXvVaiXTVxnsSQEgNU0FAFaLvRhJv6b4DKU+FvYpopZOXVEUBJEEEiJECAEQul4l4FeqVE4Y35Qtl8uOBwBcvnLVNZeegxXpsqpHqxwyO1NUkOaqeWToqmGWbQVwaag6koS6HqEYCqn6A2WInUxu9oypmhFYseLtTVt3TJk8xom5fkMDAEAACcGGrlPXZtRzmU2Z5zMD6eF8yKdOnjSO00o4GJIV2+aMIOnXiCdUDYOYtIvMGl8XaArrru1WbdeizJOwXLXTmQomkNhWoVhpbExMbol39AzZVOzv7PrDH/8S+uhtk8a2sIpl+nw/+9m34L9854VXV/z5+Tf7Dh+57IpLFy1eLDAcymVnzph55llnTZo8WSLoeQ7RtIpdbWlruWLp0t8/8oxrKxoO54aL76xac8aZp0KpI6jrSpBzTgjmnEmEHGpTWgWSB/yGpigMUogg54wzThkD/7HEYi4EBJIDDiHyPE/XTb/Pr6lqV3fX2ndWx2PxP/3pT67neq7nUR4KB7P5jFWtEqJAhCWQqqpqqqbpccaAx4lAAhIGgeJ5nuu6hmEIygghlDIJwJ133eVUvNVvr2SsLhwwx49ryxcK+UJqy4Yj7697W9dMSqmuG+FoRFUU6IFEKBgL+2234lm4WnUDUdMqVTEEY5rj45sjPt3YtP1QfX1kxsyZxUIRglqGEq4qKgbQE9K2K23trQ11zZbl6iiyavmb0XC4vbnFch2IEFGV4nD2Vz/92UBv/0WXXnzDzbd4lAuIuGCWV/rzc89u3rx+XGu950mX0QsvvBATwql7VKcBwLIcwTiBiDPuDwQmTZ50cN9ulxVt15u7YM4nPvVxYqi5XBYiKKUkRGOM14xg2WyuPp5YsHj+i38+VChZAAJKndlzZl9/9z8d3LL+nVWriK6p/mpDi95sm9wVXHqGP97Tl7cdR/WFNVPPD/VHAqFQIOo5uTffWDFuXJvP5yOK4nmObVcJxIx6pqaXy+VcLtfUFBEqwoBPHBMwcl6eGCuXL3vz9ZcIIbZnx8LxlkYSjqIjfUwlqqYomqZVqhVN91HGoIS5oayKhUtZIV8SALvMA5KaAgUVpXlcvU+V/kikb7CkK2pTY1OlVFWIAiGEANasHlLK1rbW9jHte3btK5f98bDZWBcrubmN69fTipw+e6qEUtWxoumtra1Nzc2U0g/Wr1u14rVwyOfaViwaDUUiNqeMM1XXJEYEIttxorGo5TpGwOcyChEkkHBKdYMhRC2HW5ZpOTKdy1UrpUDA1A09GsYYCgi5gnEpa731+vszZk1vbExgjDijmm5mhjL9fb1Bn276uZTMH9CNimN5YNmy1xTVmD5rBuVc0zhnspi3ensHt27dTghpbW9Lp1PDmaFQNOY3fOlU6uWXnvccoaCAoeGJE8Y3NRuYUH8ATJrYYA7mU8Pdf3q6W9M1CCDCSHp0QktDQzySTRbdjG4a/nwhXyiUBBcAgpb2tldeWfGt7zwgAMQYhULh++6774ILLigUCiMhWOC/oxzDYxlcTgTI/zdAeCIJjAbFkXOOuxT4sBjFE78UnAAGx5HDhwLn6OsLIXRd7+/vf+3VV6+88sqvfOXLGJNcrrBt++7nnn3q1Zefl5IpmBhYkoB+wZmLrlt6UV3UzxzXsR0AgOdRxmguW5Y1jAMAI6QoiuQCS8CFgALUqjDUfCkZO7oFzIWAQkAhj7mFcgBF7X7k0dP/o9dGMxIAQAqIFIwJUoiGMVEIMQxD07SaWVhKSRAGCEkJKBcCAoiwoeuScc/1JJAAAEopIWTkgWCMAYC1ilMY42Qq7VHOGf/Uvffdd999HZ1dnuddf/31EyZMyGazlUpV01SEEKV05IYhhKNt0Sd25UgXjI4PHIHAD80pCj9MjhuEJ+X/rJwEwpPyDylSSozQL3790CuvvAoAuP3WG8e3taZTSQQE9WzAEaWMM8YYpZZ1/pLTOaNDyT5OXe5Rp1r1bIt7DnNdKWVNT0UIAymDPhMqzIWAOvYHG7ZccP6Fl1xy8TPPPtc9kPzW937y1JOPKI5DAPeIwhUugQKRBEBCSAyDMMZ8vkAp77722sode/a4HjN8/lA0YFt2W0v7aaedOnXqdC5Ef2+vVa288fprPYNpJpWWhphh+qxKQVEM6uJ0uuBQetUVV7S3t6aGBoMhfyQSkkK2tzfXAgAaGuqXLVs2XLJj5XIi4keG33UpAD7OwmXLrnoOFxxBoGkqQn7X9RQMQgE/BEICObJIAAAxQgAhAQCAQBGKRykQ3pi2+sM9g6VkEWGlo7tvy669py+a5VIqILQd2wAKAcTzKJXMtqtcgQpRFKgRqGjYsKr0YE/PtkOdPen0zHFt9dFoKd3vUrp+845LLjh9TFurFEqtKLmEQFVVQginHiQccqVSEb19qXDYHwpodq4EhEAAabopuA2AQLqvaCOAvFgsbjuuphJAAPcrLiAuxDaVLgMAQo9zZOQ4dXVCJo5r6RoYqljehs07U+nhpReff+VF53p2OdFY9y9f+GR/b/+uA71NPclnfv/se++uDcVCBw8dSvUOXHHl0hmzZpUqZUXFCELOUdW2Z86e1dT2XiqZCvoMXWPLX3t15/btdQ31mq4f7u7y+XWfz1CIzgAlAMYi5mCx/M6qVXOmTX7j1eX9/X3xeCKfy1erFc9za0AuhKeoipAAcAmhxIriuk7VqkIIdUP/07N/FJSFwmEEoYZJ0B8YyqTGjh9//vnnRKPRzs6e4eHhZHLw4MGD+a5q1lSs+pAeMF3qGmaAEIIRptxDCKuKigiyqpaqajffcQtR0d6dO4Zz1UTU3zq1qVgOO5RVLbtckZRLJkDZsYaGKqrkiob8PjVeFwoHwrpiutQTHCAFAynsCoUCGQZK50vDQ8NTZkxL57MCAckFgMJ23IDfryhk1bpV+WxGVwyTKFs3bt67e/eiU09hnGuGMX/e/BWvv7pn17ZYKPTasmWD/YMTJ0+1HC81lOw9cnDgSM/4MQ2RYKize3DS5Elt48Zajg0RQhBQxkJ+/+DAYE9Pd8wfHBxKX3Xu1XPnz//Wtq314WjVzZ52+imaoQ7nc4auHas5LgCQtRKRCJNipbL4tAWr335zeLgaCqmmT1u5cuW5F5yzdevuQpGEQ9HkACvlhF/16kKa5IK65bKbL5fsO2+9bcl5Z93/qfusst3UFGWusnv75i9+7lBDW8PiU045ZfEpiVhMSMkll1xu3bRZUKYggAnmXISDGBHgN7RKRZFSeJ4XDNXFg+GQ3/JANRTQjyQzK5ev+Pi990ZCYQCgPxrbsG79yuXLW5rC5ao3nKtI7GubML5Szg/3p+PB0JjGOlPLVxkTzPHcailfUDGxIEBHlTmJEJJCEkza2tp2bN3l2gxwHgmYDXFFSO3g3n2bN603A7oAwnVpNBKt5csdSg8qiNfVNyC/r7+39ze/+c1nPv9Z5PNxLrZt2TYwMBCJRDKFfNPY9glTJ1NeK+TDFVWrlDJCco/CvfsHStVqlVHTNHKVkt8vdd2nmVLTeMiHREW8/+66rVs2hSKBsRPGnrXknJ7ew2+8/hpnNBQyFY0JAXU9XN8QlKiUzeSfe+5P5+fy0USslBvs7unt7uwvlxzHdUPh4F0fvdP2nK1bNx/ae1hVlERTE+NMSoaQjATNhnoVozTjCkZmJKwaWqwh4cuXhG25rutRimKNZmuLiPjcpgbUdWT3G6+9cfXVSx3HpZRChaxbt/VHP/mlkEDTNNux77333ksvvXRoaEhRlBF++2/pzXCUhfA4jDzOTAf+Bg2CE5xFT2TCv3X8OIT4UAA48es+tP234PA4FKy9JYRwwZuaml56+WUAwMo17/zge99P9g4cOrh/2rjWz3zsxsaGRCwcLuRyWLJENAKEk+sf8jzGoea5LoQQIQhBLRBDAgk4gpALIQSQUkgpGD9amk8ILjgQ9GixPimkAICDWtUnKaUEvPaoJZBA/sc9g1GWt9ojJAgTRcEKUXVd1XRV02p2YM64QlRV0TzGAeeqZuq6buh6b19fR8ehaZMn+n2+arVaozLOee35/0fnQiClkEAEAgEhUTgcPOeccwcGBqqWFQwEEonEs88+W1dXN3PmzFKphBCqeZ8eV3Vw9G7CcaPiOOojhKBjsYKjy9OfaCGEoyyKcNT2wYkD4KT835GTQHhS/vGktrJWK/YTjz3BOZ88vu3WW28sZIc8uyKoJzh1HS6YpIxxwRmlAHHmedVS0bWrnDHPtrljI8kBE5KoWDk68WGMmGcHfMFsKrtv757Jkyc+9tjjN1x/Q2tzc3f/4CvLVy1/8+0LlpxuF7OapjHGhGAACQQhwYRSqqk6F2zlijd37NwhMF56w9ULFi+ORYMSAEKwz/S51OVSNLbXqURpaGv42YO/7ksVAwGfGTMNQ2cCVKpetUrnLp6/cNF8x7E1VQGSua4LoBBcOB4gBM+fP3vDhi3dvd1CSOhVHSEkQkBCjoBpqoYOAEBccIQQkMAkikoQFA5GWAACjiUBRxDBGssCKQWQro6Byt3KcCUfi0S7kwVEiON6L7y60qt6r7z88vj2hgljmiwNrdqzw6/h9qaGtqYG4DqO4O9u37rzYK8E2PHsvoFhmwMBgE+KRNBMhM1o0J+v2D3dXTOmT5dCKFJ4bgWrmAsBIYII214hEW3efzjd1Tc4d9ZEgqXgHpACQ+IxrgKuKDhvOa+s2ZItWq1NCU1RIARSQM4FZa5lVSiTNkNCCgmk7boEQCSgouG2pni+mE/l3I6egUee/svMiWOmTRo72D80pq355huv3Pgv39/d3XXKnLkdh7pUyVVVaW5pXbVq1azZs9rGtJftCsK4lkbC8Bsz503qev5QfTzQ3BRNJ2WlUhjak2SCK5oaj0YMQwGCCSkVBcaiRqMbG0gOvPLSy52dRwhRMcYIo8MdHYPJ5ITxE0rFgqKqAELGGQQQIQQR1Ii2cOGiF154fvz48bfe97nHHnu0UCxGI1FVUZL9/a2trZ+7/7PxhrhtObPmzGWMeZ7b2dm14q2VW9ZulB7U/Ew1IpVKZfPmLRcvvYS5XHJQtasKUU3TtB2bQ/DZL/7zs0889eLzy/L5oeZ4rC6uU65K4BsYdJJD2Xy+PH3OwgWL5lvV8qG9BzsOHDp4sKCoOYCx43qKpkuEbctOD+abm+uUcNDLpp555pkbbr1p7ORJAAGnWoEANNTX2VXrJz/9xcYNGwwVBUNqwMS5QsijdNXyFQIIRTVWr3gbSq+1qSEWCuUr1R07Nm7a/D7lEkJiIJSIBRsaI06FFQrFK+fP9wf8qUIOIoSExAg7rvv68jeo40EfhAgxAPpTSSYgk8BxHUAARBJjICXHBErOmERHi4JKKSWsuPaYca1z5s9e+9aWWFwNBEEmU/36v32TQyoBS6fzSZcRjkNNRj4hp9THEBOcSULMZGrA9KuG4aMua6xDkVgon1eyWdpx4MCu7dvXvPXOtCkzOJAVuzTQNzDQO+gzfM1BM4BgmZKqy1XdbDUV2BCUUnoeM0xJKARCBdiub0QlO/Leu+9phn7q6afl89nkQGrNqrVIwJBfrVJZsfmd99x20WUX9g4ceuC7Pyhk7HzJ89UTXYWhoDmQKnYe7jz/4nM1TaMeJRhDIDGElFFFVaLRqJQSSIV6HuKytd4XisJKVXUdfzZXQdiAElLPGx5IYkzqo9FwnJh62HVELBrdvn7DL21vypQp23fsGOjvxxBAolApPvW5++qaG8uVogqRzzAK2VxqMB8MxHLFcjgSaWxviSXiE8ZOXLfug+7u3sF+V21QQn7e2qwlmFauVIsVr1DIrluf3r2/w3McLETQNBrroj6TQlfN55gtCEZafaKh6lgvL1uGCeE2gAj4A3o0ZiIUTKdzEsjTzzpjwvRJP/y3B4EEQAKVQMYYAlJFqlVgkXAQAigFgUAENTXi9zXUcc9lCKqew5kiBfRsV1HNIDFzr73yWjFXAADMmztnKFf4zJf+pVKtarpuO/bChYtOO+20fL5QyzpTs9X8d5nwvwiEx2HhhzLYh+r0o4+DE9ARfBjOgb/W+4/7ipGf+aF8+NcNAOF/5KtEo3LJQAg1VQMAFIvFZ/743P3//FWnmp81rvHH//qJqRPHq4riOjan5aawzgS0qkXPqWIMJACAUyAoF5IKwY8lP8MYIYA8xjjnQMpanqHa3iIXQggBAR3BJsFrhWCAqJUBRvBo/GAtgVLt+UAAAJRQYkxq2d4QQgRpiqoghaiqpmu6qio1QxtRFOoxRdHCwbBu6vliddvOPRs2vL9p06bJk6eMa2/z+/yKotQyBdS6lXMBjtrrIUSQcVGtVGfPmjmmvZly3NbaijFubGiglN5///2rVq369a9/fdTBVQgI4Uh7JJfMcQNjNHuPNgke9zraTnhiMfoTrYXH9fVxA/Wk/F+Qk0B4Uv6RpDbtc84VRdm/f29ff28iFvvhd78e9ynDQ0OcM0E9q1qmLuNMMMoE51JwylxGqefaruM41Sr3XME5BhICiSEgBALOAecIYkU3DZ8ZjdDP3Hv3xGkzn33uzzt3bZ8zb05X3wCl7M1Vby295IJqYRBhglSVQCkYpdSVQChE0XRjzZp3N27bLhWy9Nprrr/xxrJdlcyTUgrJS9USYxQiyCiTHEyeNvmCSy986U9/LhSqzYkAIgRBveRWXAhnzpweCvnzuTwAEACoKFgCXvuXyhizXVvRFCiBoqgMegBgCFGt5gSCxPM4QkghmuBCAqqgWngDFkJALIVgGCMp5bF4eiiEoJQLADDBQ0OZquMFojEAJafe4nkzb7vuqqBuXHf1pZl0n65qjNOgDymQQKAUSrR/MJMvlXMFNxSMGYYaMuSsiWNURS8WyqGIzy2VwgY5de7Udzfu3NfRf34xr2gY6H6PIcQYRlIh0JN2JKDvPdz/y0df0Ak8fd5UJKEEBBGgKYIRzKEiPRb0qbMmtmQqLJvJ5K2qoqjM8QxdN3RMoMYpa/SblAvb87Aa1InuM4zOzk6nUhrbXOd5wwWLF6vVF155PXjLDT5/oLf7yOQJ4xobYslUtmQXLjxjjpVMqZp5OFvkXPQnU+2TxksHUsYURZFCeJ53+lmnbli/KZtNN9Q1zZk1JjOU4zBMuXRc7nhKOmflEVdVPRRSFEWTrCooTw2lzr/o3Of++OdkajAWixdLxScffuTSS69oax8TiUQFZKFwUErp9/sPHtj/kwd+EEvU/fOX7x8/YWKiru4Txr0//tGPy5Wyqigu9ZZetbS+vn44N6woasHK1npuzNjWe++9Z+9pZzz58O8L5Wo4ElQIePrJp/YeOHjNjdeObRsHNe5xy6NcCGkYsFzKZrJpzlnQF0VCWJUKBABgUrVpajg3ecaMj378o9FE3HGccy68OJvObd60ddeujZVK+ZTp00897TSsqAcOHHrjhZf60rnmtoZwINzZ2fnDB380ZvKkc849d9rEiQTBzkOH//iHZ/fs3BsPGw0N+tjWxuTAsO1Uq7ZjGroQggoqIIj4Iipyx7WHPc9frQYdz5NSElXHGPlNIAVIdud9oVDjmJaqbSEEHc8hAviD4d07dmx8b21TNJyI+ql031u92ucPxSLxcqHU3tY6bmw78zwFqxAAwSVACIxO/AEBVlC16i5adMp7b2/yKEskYkJY+Xzm2huuLziZaskO+cJ93X3b9+xnEiKeGz+hoakhUs5a7yxfKZgbS8S3dfbgQ7iuMaTq2uSpDR6PDAxkhtPJ5d29QAKiSiBkPBY39ACCxmDaKjjUdinnZSyZrusASMt2wwFcH40ausqEYqqoPmpK7rz15qo333ibEA0IpBFSl4jFEr5CZw5J1XXKWKFtbePa28fsyewpOhxmsKaDWDxcVyhv27jxVw6/5tarWltaHNvijEvIIuHI9q27V61crWqKT+cYaYIzyKVfAcGEOTBgS6lmC1nmAVVRfKYej4aCQX/FKgwOpl2Xa5rR1FDf1dFxaN9+AIGuan6fr38ofe6lFzU2NZUdixACuFSIum/3vnRqyDC0SrV450dvnT51CnVdhJQ5c2f9/Be/7uvsBs1Nis9gVOjIjEc1l8PksJUryOFiQVOJkEJAWLY801SrJZYeKmarDkSYUxYIBhvrGl3PC9YZwQCByPHpWu9ATiKSyZQQ1KAAFHLXdpysXSrlFYIlh31HipFQsKU5EQ6qmoZURbq8CpwyRgAC3aOyZ2AwW/YqlgCUA0wEwbqK3lq1UtXNt99Zva+js1yt6prmOM5pp532hS98PhQKVirVmi5dW31GogePU5pHwO9DlenjAOzEPx33elzjv2Ih/FuWnw+95olACEYBxkhbnlD6nHNeQwshBICIMwaAJESBEAomVVUjKgIAcAA2bN708G9/88Ha9Qc6Our8/jtuvuqyC0+ti2m5TD6XZ5pCOPUcizpcQgC4gB5jgnLOGMEECokAhBxIIbngTEqCsYIRURTKeKFie4xiBDGCGEohBBeSYCQ4F4LVIgKFEARJwJnLuKZpUAIMAIJIAiQkkBBDhIlChBCqqiKCMcIEK4QoSFEUVceKoigKwUhTkKbgUF2D49i79x/ctmN7LpPN53KzZs74zre+0drS4lZLrmMxzjBCR9PWiKMPjQtOFOK6lAseiUR37e/o6x8868yzI5HE+xs+ePe99zZs2DAwMPDDH/5w/vz56XQaADCSU/TvGAZHvx3p7uNo8LjGcWPjQ0faf03/Oin/y+UkEJ6UfxgZvc/KOV/99opCsXjFZZcunjs7n+yhLmee6zmWVSlZ1Sr1KKdUMg4AEJxRRl3X9SiTngc4kwCw2kLLPEkw50wwxrkAhEgA2tuaDZ+RzpVnzZj22BNPXnv9jf6AXik7r762/KO33jhjSkOuUCGa4VG3atmGoSEMpUBCws7DvbmS9ZGPfXTp1Venh7MSSvVoEQgEICBYl7VshJJRJqZMG6cbiutQIaSmKIJhjgDWsGPbqqJCBA1Nt20XYywl5FxwznRV97jIZociPlNTFKT+P+z9Zbxc1309Dm88OAyXQfeKmWzZsiUzU+w4jh074MThtknbtE37K6WY9tc2cZiaOI5jjB0zyUwyiSy80tVlvsMzhzc9L0ZWVTvp5//ieT5P+6/WC+lo5szM1Zx9z95rf9d3Lah8qYSCUgIppFJEB1JyoTgiCCsEAIQISQAgJQAqCJCUEiEogYAKKICkBAqoSPk8Ah1deUqNPUdGEUCJuP7JG69d1pP3HFdmMBE08lwd4S2rl07OVUenpmcKBwt1XyOaRrCJqCF4HBOhAISisy2NEAm9ulMvp+3kulVL9xwcHhk8sqK3zY8kNeJAAgBVGIaYYA6tH9x17+HJqYs2r7l483qn5lDNZsyFIASCYV1jQhkcnLGkJwLCD7sEQH7EQ9fFCEgFIsGZ4FEUSYgiiRSinucBBBYvXuCFXGGzJZ+pjExBRJ94+e229tYrztsaOaKtu+/Pv/y7f/4Ptx48NPDhyzb2JttKZcd2EQSw4focKRZFCTuhgCKURiFvyXeed+65D9x9J48kVGF7i1n3RLHohQ6bq9U8L+ART8TimbRlmKRcdLu7eq790LXtHa1Kih27do+PjSfjibnxqZ//+Ce6adtWTLO0ngU9vT29lNJXXn45dMOh6tCeve9s3Hza6PjoiuVLt565+aknnkSxWHt7x8rVq13HMzSTi0jXqJBSCB4EHmZ09brVn/7iLT/54Y89tx6zTdOyX3/llcHDR9av2XDa5o29i9oSiZyhGVJFr7344qsvPN+aScdjNpcCKEApCSNed0Jq2Fdec00ym5iamaKIUo2kWxOXffDC8y8+2/e8dDrDoiji0eKrFkER/fru+5yC29WaSMVwoeIe3LnryL6DrfkWjEC5VIiiqCvf2tli5toIEsCpqEiw8y84d/MZm3fv3B2B6OjI+JE9Qx15o+HMJyxLjyOELQSRUIKDCEYBl/GIIwFxPBmjlGAW5pIpinF5vvjEww/rECfjZipj+TyamC40oqpBNcnYgp7evq7emUKRaoZQAgAFEZZSNMNamvUAgCAAuDXfaZokDDmhxPe8dDp+zjnnx9tToe8amh4E/l0/v+fxhx+Vworn0zwUBMt6tQEF/fwXv3BX+v5D+47s2T9laCCZKq9a1rphVb/jiGrNZVEkVBSzkxFT1Zq3d6jmuB4TDCLEpdCIFkUNgjEieHpeluuivdNszaQIAz0tNGnCaiOquwxpWDew5KyjjVgxJ53SGjX8wH2/DHi5OMeH9g9YBpmcnhnjIBXX2jtSne25sbHiW69tP3xkYMtZZ2zatDGfT2u6fuTQ8L/831t56HR0ZlIpDSATaVxEDHLg+f7sdKPqBsvWL1uxfM3OHbsnx0caPnE8r1KucSkMyyzMzpiaoaQCABBCDMskCAMlF/T0Qox4FNmmKXn0nVu/s3vHTk1DbW25Vau3LFu20PUagisFI4hp2anELII1c64aFkouUaFNRLo1BZTyHK+vt/f6G65947U3du/aPTlXhiDj+OG856xat7a9rbNWqR88sH92ZjadSkrlWLF4wtKEF9k6Nix921PPOq535VUXXHn1FXfdeU9LS9fmLVvzLXkhgr279xw+dHh2f8E27EwylkjABf1ZyULJOCTZg4MT04Wqbpn5tlZN17p7uj3H3bN7dzab9xg/PDJWrDu6rgVhuHHj+r/926/puu44DYQQpbipxeWcgxPa8MD7fFne4xkDAGg2d4ETmgnf89oTn30/TzsRv5EQgnd74d5zwm98E/BfMoH3PAXeJaInamWb0lnOOYTQMg2E/hORcBqNpx95+r57HxgcOjo6MmhgsXHtki/e/OVcwuzq7hUCHB6eNiiMmXoUMgmgQpQgKRiDAGJAIABKSR7xJi+iqBmOoqBSddcfnC4Nj0/PlavFRm1Df8eiztZUKmlrGEIFpYoioRGMARCcvVu+xIjqpk4CnwGFGVcsDDPpOEZY0zQhBULUNDWFINGpFBJTSg1TQWTFU4Ztp3O5VDrlhb4VTzz42NM//vGPu7vazj773A9ccfmalUv9IIzCqFEpQiCO1QYxPtZtKAQEiGAskBKCKwg0w5gplP7vN74bBJFTr5bK9S996fcnJsdvuummb33rW5Zlzc3NIYSa/+sTZaLHB8yJA+P4BXp/xfg4CfyvR877x8N7PuU34iRp/N+Ak4TwJP7HAELY1FRgjKenp395930J2/zMR68rF+YadYdxEfp+GLiu0/BcV3DOQ6Y4l1KyZvuWEIILIAUAx6ZqAICUx8QnXMowCKjrmKYJAdAo1ijJZVJnb92yoLtr6ZJFO3funysUb/3292/72a2EMI1SH0GlJIQg8ANNM0vF4tjYaHtb26ZTTo3CUAqONfruj978SwGgEIIAYAhBPJ6wbVtIDiE0LAsLkk8YM9N85653Nm/enM+112pVTaMQAiEQhMqybAjh3h27a5Vq2tZtW9MIDsJQQaUAbrppAyXhu/Phf7r7A6ggQhDquiGkkDwSSiqomrM7RkRISQgxTCP0pQLE9aKpYmH18i4S0NAPIy+igHBovnlgcnJqhglAdGPjhiVrVq1OxONTE5PvvLNnqlapNxwuFcI0m4jHdUV0S0JEKJmZm3t1x972fBaxmiklJSRgMpXvOXx08LGXXjtwZLQ1l772qosJwYhCIgDGQGIYk5QxQbCpGWbEosgpAhZiiDQeYV3zwsj1PSElwlgwjSs4V6yUak4j8CHFQcj9kCkAMKUSIgAAl+jp5187Y9XiXCpWmhg8/7TVIx/98L/98CdOqLfmDFCpESg1DMaHRwysZdIZp+FACHVdBxBKpTw3IETTNJMQ7Da8qUl/phC5QZTryFx44UYC0SuvvFpv1BkzIy7O3LK1pa21Uquv3bBh9br137r124X5Yl9fH6W4WikqWfMqcOfU5Pbnn4cQplKZTLy9WC2U58oiYJZhlsuVs88+5+WXXpZKhVFoGIaCirNmX1xT94QJoZGUxXJ53fr1113/4dt+ejuLVFu7lcksGB2bfPXlZ1595dl0Lt3a1kGIGXpwbOSQrWvZNNV0JJQECHKlhFI8inRMYqbtOV7MthWXUqgojDzHhQokk/FKpQghhBjNzMycf/6F8+NTr774am+7WL0oVyxb9QYvlBv12gxnRNfNeCKuoKpFTFYkAXK6UFp5yrqbP3Wz53mLlywWSjac4J/+9uuF2XEvTFq2EfIQcIkxIIjqSjKFQ6GEpgE/PLj7HR2SmlOfm5s/dPDQ1OTE3MxsJputev74nv0QkngiTSm1TUOI4MiRwfGJ6UQ63fA9THCzb+fYchkiCCGXAkMcRRGAilIdKa44d1y3u79LM/Xi/LwSvCaVoekf/+THatXyzjd2DA6UEUBTc7Onbznt6uuuzra2fObzn6hVSqEf3XfX/W+9ucOGteVLrXwSJg2KNZMTND5em5ytVmsuRmjJsoX9ixa1dnTkWvJu3ZmZnonHE/FEbNuTL4wMHlaAJSyLYkYBziVIOq1JhIJA1GvCCdH8OKsWpBbTE2lSreMH73uIMzuTog3X7evvj8Vje3ft5RK2t2c6uvKptDdbKD324P3PPfVUMpGlGi4WS5yLfD6eyVtlR5Qb1UQsRrChGzjwvYZfW7R46Zd/9w+6evKnbFz913/+d6EHhOLEpLfc/JllK1Zsf+P1IwODLbm8bdtv79gxNDiYTaYMy8rn8nHT1jH2nMZ3vveDPTt2ZdIpDNHv/u7vxeJ6rV6WUlGim7b99NPPOg23PdlSLLO647i+Lzk0iemw0GMsnYl/9nOfzmYy/b39C3p6Hrj/fs+LXN/vaO/85Cc/FY8ngALjo2Mvv/DC9u3bHY9GDOTSei5ttuZhFWsAAQAASURBVHaYNX+uXi8//OD9g0f3f/JTn/rrv/5L27ZisbiUQtPoxvUbD+4/MD4yMnhkbHR4JB4jfigW9rZB6NSrTsN1CcWf+vSnehf0N82QTNN67PEnb//FHUPjkz7nmOIwjDSNXnDBBYlEolAoNOeIZgIqALBpGfJ+cnW8kvYeRnfizHVsAjiBEx5Xdb7/zP+HhPDEp+D/M0IIfhMbfM/Be549ToCbb95s0LUsa3Zm6ujRoXq99s7efe/s2fWHf/g7P/vJTx749aOrViy88IyNqz513ZrVS6XwapViuVLdsXPXjrf31OvuB668MBVr5UxApaSSUCEFIGOch5EQoumt2ZyRK1GACXEcN5GIzZRL+w8fsuOppcv61sWtJfFYAmMBVOj7pk6lqGEFqdIQJtDUhVSu55NY9uh0uVIYb+vs/vUTz81VHFMnV15w2qnrVgHuxjUaMaIZhoSAapRqum5YdjxOTatSqSpFxg6PPP/8c9mWlk9/5jPMb3zq4zdd88EPJBIJp1qanZsLokinVEqJEZRSRlFEMFEAIoybMvWQMYKR4FJhmm/tvvV7f/P0868RBK66+momok988hNrVq9et25do9Foute+q379D2fR3zYwjl/l99cD3yMNPU4Of9vweM8I+Y1D9zc+chL/b8VJQngS/8MgpUQIvfXWW3v37v3KF2/ZuGLh5NhwFEYs8H3PjQIvcl3mHasQcsaAkFIIBZQSsmk9feK9lnOJieCcsSjSDVMjCCoBpDA1SjFIJZMXXXiBEGLdmlW7dh2gWH/oiaeX/tt3v/yFT3uNhm3bMcPwPMf13IRhHDp4ZG5+bsHCZclk0vVcTMjxLb7mDfc9ChwhRL1e723L57JZKVyFcE9bZm62ODo6+eSTz114wdmU6omEFUUBADqEcHJy4tFHHzl44Kipay0tcV1DKhKaph0jdYQIHgkm378CAEoJqTRqhGE0NjaYy+cTcVNwJgGSQjW/UozR9MRUKpPFCCrFGZMvvvwmEVGMWNlMHFgpweHhobl9RwssYgiDXCy59ewz+3q7A9df0Nux+cxNpWrV9YMjR4ZeeX37VLHYkrBbMzGqa7OTRwEE+4+MnHPmafm4EUmu7Dixkg8+8eLP731wvlRry1i33HhpV0vKdx2EAEIQE8CZxAhxBN/cuafqy4V9PR0ZUwdECq6Z2AmYTglGFpNcCIUUChj3PQcoGbdMCRRWSKdUSKkZejaVmC+WSg02OV956uU3rrn4bOx75cLspnWLNYSefnnnzR84EyIRM0jM0I4cPHTbj/798quuSCQSTasAybnkinMJIaxUam35nJK47kiB6Aeuv/yUU1enkynbMGPxxC/vvMOy04ZF8m2tTEQKyHKtmsvklq9cMTb+dGG+0NGaPmXtMh7UIyYVwGEUhkGgaTqXNIjUwL69zz/13LkXnmcYtFwsASl1yywVy/fcfc9HP35TJCIAmpYKxxp1MEYRBBPT06vXrc23tFdn5w091pJP5hOW44lCuV6vRUOHRoiGRMjiMZJJ2ot6sgQDzgCAWAEIETapVqk1Qt9PxuOzs3OWYTPJIAAEYSFYpVKilERRhAEBACAI8y0tGBOEII/8ZEyPGXpHa2q+4U5N+0EEZmZnFGAIIKBEJpGtev7CJf2GbXiB23Drdizu1ute4GLNLJRFsTLvea6QwjTNZCyRsXVbpwbFCVMFDfDgPb96/KFHEcENx9EoRQhl0xnPcTwedfUulFyMj41bmp5KdMYTsfHJqdt/fscXv/R7qVSy4TgYIQHUsfIghAAASiiXIp/JzU9NO67TmUvykAEAMrks0TXAgG4YkgvGGOfssssv3b1zTySA13CXrVn5R3/2VSbFbGmeEKjZZibf9onP3DJXLE+NDBEdLOrPapjxwJ8uuyNDjYorTj1jwwc/8MH2jk7DNgMWCSGBRKcSrJQihHT1L/72v35rfnIoPlVZ3J9X0tdN0/HlfKFaqYbFIvd9ACDGuozFagbNpZKxzljWqaHp+cmNp276vT/8fWJo991194O/etAbDrIZK2bBVcvbGrWgWGwEjUqD+7FYDJOY77vDo5Va1ccIYQjyuUxnR6vrc6Z4ELks5E8//fwD998vlTItfXxq8oqrL9981lbHdc+7+KKLLrlMcE41bcPpm+656+7BA4eorr/95pujE+NxXX/91VcP7NvbkstGYZTJpePxuOvVCCGWaQNJ7rnr3pdefdWMxecqBSWAH4otZ5++efPpD93/aLlU002zUi298spLl192ZTIeX7hwoQJQQa3eKJ51wQW6bcyV5jHCLW0tN3zspt6+3ocefmyu0HAaYaXqL+hMLOnNFatqvuy9s2fP0NDQhg3ra7Vao16LeCQhRACcctqmTadtCnz20osvPf3k45PTVV23FvckG069XGmccfaWRUuW1BsNCIDwpRt4Bw8fOXB0RGEkIeQRv/baay6++OK+vj4hRGdnp+u6hmE0KQrn8ljlitLj7V7v523NNf17uFzzNvweBvgeySg6wf/zxBe+nxCeeNw84f1phOg3JUmA95G94xPTiR/0G+1zmpUr3dB1XQcAPP3007/zxc8PDY8eP2H50gW/9zuf/93PfbKvp0vxoFGtP/TQo4VCYX62KATp7W07/4ItqbQRtxKIY10HImICCh5FQEjJjv3uNT+l+T1PjI23trZSCMMg6kgnbzh7vW6ZUvIw8iXnTAiqmwRYQKcYGUrBmVJtujDvuN6Ctszino4X39759FtHlnZmVq5cs3LZwg2xmG1o61ctswxDMaXplBo6oTokCBEccm6a9sGhkR07d83Oly659DKqG8uWLd+4aZNS6obrrzYMo1Quz85UKYYIAl3DQjAAFQDHIx+VVBIiYhiGECKMIsE4xoQasce3vXDPA48BAPKtbWedc64E4sYbb+SMlUql5s38RGfR402Dv81I5kRed2Kv4G/khO/He8bJiSur9wyV3yiNPon/d+MkITyJ/zE4LqKoVqt/8Rd/sWH9upuu/1BhaiT0nFCoqNEIfC8KA+b7IooU4yKKZMTejYw/ZlINIALH7ndSCNBswCMSAAA5Z2HgU12npmFoeiqZDBmrVuoQYadeV0opAKWEt37nJ9dedVlPR7vTqBEEMSamYXLGpVK6pheLRdd12zvbC8UiwIgrefxGfMK8CwzT2LHjbSllW1tba2trtTpHJdAhWNLfUz88/+yzL+/auSObTS7oa1+ydIlTZ3v37Rs4dCiMwpiV6u7M9nTYiodQYaBEU9x1rIX92P0bgvfanUPBlRSKYA1IJIUUUiqgpIIAQCEEExxAIKWMIh8AiYnx2ut7tm/foUG4aGGHQWna1kNuHBqZScWN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"></figure></div></div>
<div id="OEBPS/titlepage01.html"><div data-type="book">
<section data-pdf-bookmark="Effective Rust" data-type="titlepage" epub:type="titlepage"><div class="preface" id="OEBPS/titlepage01.html.id192">
<h1>Effective Rust</h1>

<p class="subtitle">35 Specific Ways to Improve Your Rust Code</p>

<p class="author">David Drysdale</p>
</div></section></div></div>
<div id="OEBPS/copyright-page01.html"><div data-type="book">
<section data-pdf-bookmark="Effective Rust" data-type="copyright-page" epub:type="copyright-page"><div class="preface" id="OEBPS/copyright-page01.html.id193">
  <h1>Effective Rust</h1>
  <p class="author">
    by 
    <span class="firstname">David </span>
    <span class="surname">Drysdale</span>
  </p>
  <p class="copyright">Copyright © 2024 Galloglass Consulting Limited. All rights reserved.</p>
  <p class="printlocation">Printed in the United States of America.</p>
  <p class="publisher">
    Published by 
    <span class="publishername">O’Reilly Media, Inc.</span>, 1005 Gravenstein Highway North, Sebastopol, CA 95472.
  </p>
  <p>
    O’Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles (<a href="http://oreilly.com">http://oreilly.com</a>). For more information, contact our corporate/institutional sales
    department: 800-998-9938 or 
    <em data-type="email">corporate@oreilly.com</em>.
  </p>
  <ul class="stafflist">
    <li>
      <span class="staffrole">Acquisitions Editor:</span>
       Brian Guerin
    </li>
    <li>
      <span class="staffrole">Development Editor:</span>
       Jeff Bleiel
    </li>
    <li>
      <span class="staffrole">Production Editor:</span>
       Katherine Tozer
    </li>
    <li>
      <span class="staffrole">Copyeditor:</span>
      Piper Editorial Consulting, LLC
    </li>
    <li>
      <span class="staffrole">Proofreader:</span>
      Dwight Ramsey
    </li>
    <li>
      <span class="staffrole">Indexer:</span>
      Ellen Troutman-Zaig
    </li>
    <li>
      <span class="staffrole">Interior Designer:</span>
       David Futato
    </li>
    <li>
      <span class="staffrole">Cover Designer:</span>
       Karen Montgomery
    </li>
    <li>
      <span class="staffrole">Illustrator:</span>
       Kate Dullea
    </li>
  </ul>
  <ul class="printings">
    <li>
      <span class="printedition">April 2024:</span>
       First Edition
    </li>
  </ul>
  <!--Add additional revdate spans below as needed.-->
  <div>
    <h1 class="revisions">Revision History for the First Edition</h1>
    <ul class="releases">
      <li>
        <span class="revdate">2024-04-01:</span>
         First Release
      </li>
    </ul>
  </div>
  <p class="errata">
    See 
    <a href="http://oreilly.com/catalog/errata.csp?isbn=9781098151409">http://oreilly.com/catalog/errata.csp?isbn=9781098151409</a>
     for release details.
  </p>
  <div class="legal">
    <p>
      The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.
      <em>Effective Rust</em>, the cover image, and related trade dress are trademarks of
      O’Reilly Media, Inc.
    </p>
    <p>
      The views expressed in this work are those of the author and do not
      represent the publisher’s views. While the publisher and the
      author have used good faith efforts to ensure that the information and
      instructions contained in this work are accurate, the publisher and the
      author disclaim all responsibility for errors or omissions, including
      without limitation responsibility for damages resulting from the use of or
      reliance on this work. Use of the information and instructions contained
      in this work is at your own risk. If any code samples or other technology
      this work contains or describes is subject to open source licenses or the
      intellectual property rights of others, it is your responsibility to
      ensure that your use thereof complies with such licenses and/or rights.
      <!--PROD: Uncomment the following sentence if appropriate and add it to the 
        above para:-->
      <!--This book is not intended as [legal/medical/financial; use the appropriate
        reference] advice. Please consult a qualified professional if you 
        require [legal/medical/financial] advice.-->
    </p>
  </div>
  <div class="copyright-bottom">
    <p class="isbn">978-1-098-15140-9</p>
    <p class="printer">[LSI]</p>
  </div>
</div></section></div></div>
<div id="OEBPS/preface01.html"><div data-type="book">
<section data-pdf-bookmark="Preface" data-type="preface" epub:type="preface"><div class="preface" id="OEBPS/preface01.html.file_preface_md">
<h1>Preface</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>The code is more what you’d call <em>guidelines</em> than actual rules.</p>
<p data-type="attribution">Hector Barbossa</p>
</blockquote>

<p>In the crowded landscape<a data-primary="Barbarossa, Hector" data-type="indexterm" id="OEBPS/preface01.html.id208"></a> of modern programming languages, Rust is different.  Rust offers the speed of a compiled
language, the efficiency of a non-garbage-collected language, and the type safety of a functional language—as well as a unique solution to memory safety problems.  As a result, Rust <a href="https://oreil.ly/KKcb6">regularly polls as the most loved programming language</a>.</p>

<p>The strength and consistency of Rust’s type system means <a data-primary="type system" data-type="indexterm" id="OEBPS/preface01.html.id209"></a>that if a Rust program compiles, there is already a decent
chance that it will work—a phenomenon previously observed only with more academic, less accessible languages
such as Haskell.  If a Rust program compiles, it will also work <em>safely</em>.</p>

<p>This<a data-primary="safety" data-type="indexterm" id="OEBPS/preface01.html.id210"></a><a data-primary="type safety" data-type="indexterm" id="OEBPS/preface01.html.id211"></a><a data-primary="memory" data-secondary="safety of" data-type="indexterm" id="OEBPS/preface01.html.id212"></a> safety—both type safety and memory safety—does come with a cost, though.  Despite the quality of
the basic documentation, Rust has a reputation for having a steep on-ramp, where newcomers have to go through the
initiation rituals of fighting the  borrow checker, redesigning their data structures, and being befuddled by
 lifetimes.<a data-primary="borrow checker" data-type="indexterm" id="OEBPS/preface01.html.id213"></a> A Rust program that compiles may have a good chance of working the first time, but the struggle to get it to
compile is real—even with the Rust compiler’s remarkably helpful error diagnostics.</p>






<section data-pdf-bookmark="Who This Book Is For" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id2">
<h1>Who This Book Is For</h1>

<p>This book tries to help with these areas where programmers struggle, even if they already have experience with an
existing compiled language like C++. <a data-primary="C++" data-type="indexterm" id="OEBPS/preface01.html.id214"></a>As such—and in common with other <em>Effective &lt;Language&gt;</em>
books—this book is intended to be the <em>second</em> book that a newcomer to Rust might need, after they have already
encountered the basics elsewhere—for example, in <a class="orm:hideurl" href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em></a> (Steve Klabnik and Carol Nichols, No Starch Press) or  <a class="orm:hideurl" href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/"><em>Programming Rust</em></a> (Jim Blandy et al., O’Reilly).<a data-primary="The Rust Programming Language (Klabnik and Nichols)" data-primary-sortas="Rust Programming" data-type="indexterm" id="OEBPS/preface01.html.id215"></a><a data-primary="Programming Rust (Blandy et al.)" data-type="indexterm" id="OEBPS/preface01.html.id216"></a></p>

<p>However, Rust’s safety leads to a slightly different slant to the Items here, particularly when compared to  Scott Meyers’s original <em>Effective C++</em> series.  The C++ language was (and is) full of footguns, so <em>Effective
C++</em> focused on a collection of advice for avoiding those footguns, based on real-world experience creating software in C++. <a data-primary="Effective C++ (Meyers)" data-type="indexterm" id="OEBPS/preface01.html.id217"></a><a data-primary="Meyers, Scott" data-type="indexterm" id="OEBPS/preface01.html.id218"></a>Significantly, it contained <em>guidelines</em> not rules, because guidelines have exceptions—providing the
detailed rationale for a guideline allows readers to decide for themselves whether their particular scenario warranted
breaking the rule.</p>

<p>The general style of giving advice together with the <em>reasons</em> for that advice is preserved here. However, since Rust
is remarkably free of footguns, the Items here concentrate more on the concepts that Rust introduces. Many Items
have titles like <em>“Understand…”</em> and <em>“Familiarize yourself with…”</em>, and help on the journey toward
writing fluent, idiomatic Rust.</p>

<p>Rust’s safety also leads to a complete absence of Items titled <em>“Never…”</em>. If you really should never do
something, the compiler will generally prevent you from doing it.</p>
</div></section>






<section data-pdf-bookmark="Rust Version" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id3">
<h1>Rust Version</h1>

<p>The text is written for the  <a class="orm:hideurl" href="https://doc.rust-lang.org/edition-guide/rust-2018/index.html">2018 edition of Rust</a>,
using the stable toolchain.<a data-primary="2018 edition of Rust" data-type="indexterm" id="OEBPS/preface01.html.id219"></a><a data-primary="backward compatibility" data-type="indexterm" id="OEBPS/preface01.html.id220"></a>  Rust’s  back-compatibility
<a href="https://oreil.ly/husN4">promises</a> mean that any later edition of Rust, including the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">2021 edition</a>, will still support code written for
the 2018 edition, even if that later edition introduces breaking changes.<a data-primary="2021 edition of Rust" data-type="indexterm" id="OEBPS/preface01.html.id221"></a>  Rust is now also stable enough that the
differences between the 2018 and 2021 editions are minor; none of the code in the book needs altering to be 2021-edition
compliant (but <a href="#OEBPS/ch03.html.file_reflection_md">Item 19</a> includes one exception in which a later version of Rust allows new behavior that wasn’t previously
possible).</p>

<p>The Items here do not cover any aspects of Rust’s <a href="https://oreil.ly/a9r1B"><code>async</code> functionality</a>, as
this involves more advanced concepts and less stable toolchain support—there’s already enough ground to cover
with synchronous Rust.  Perhaps an <em>Effective Async Rust</em> will emerge in the future…</p>

<p>The specific <code>rustc</code> version used for code fragments and error messages is 1.70.  <a data-primary="rustc" data-type="indexterm" id="OEBPS/preface01.html.id222"></a>The code fragments are
unlikely to need changes for later versions, but the error messages may vary with your particular compiler version.
The error messages included in the text have also been manually edited to fit within the width constraints of the book
but are otherwise as produced by the compiler.</p>

<p class="pagebreak-before less_space">The text has a number of references to and comparisons with other<a data-primary="statically typed languages" data-type="indexterm" id="OEBPS/preface01.html.id223"></a><a data-primary="Java" data-type="indexterm" id="OEBPS/preface01.html.id224"></a><a data-primary="Go" data-type="indexterm" id="OEBPS/preface01.html.id225"></a> statically typed languages, such as Java, Go, and C++,
to help readers with experience in those languages orient themselves.  (C++ is probably the closest equivalent language,
particularly when  C++11’s move semantics come into play.)</p>
</div></section>






<section data-pdf-bookmark="Navigating This Book" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id198">
<h1>Navigating This Book</h1>

<p>The Items that make up the book are divided into six chapters:</p>
<dl>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch01.html.file_types_md">Chapter&nbsp;1, “Types”</a></dt>
<dd>
<p>Suggestions that revolve around Rust’s core type system</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch02.html.file_traits_md">Chapter&nbsp;2, “Traits”</a></dt>
<dd>
<p>Suggestions for working with Rust’s traits</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch03.html.file_concepts_md">Chapter&nbsp;3, “Concepts”</a></dt>
<dd>
<p>Core ideas that form the design of Rust</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch04.html.file_deps_md">Chapter&nbsp;4, “Dependencies”</a></dt>
<dd>
<p>Advice for working with Rust’s package ecosystem</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch05.html.file_tooling_md">Chapter&nbsp;5, “Tooling”</a></dt>
<dd>
<p>Suggestions for improving your codebase by going beyond just the Rust compiler</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="#OEBPS/ch06.html.file_beyond-std_md">Chapter&nbsp;6, “Beyond Standard Rust”</a></dt>
<dd>
<p>Suggestions for when you have to work beyond Rust’s standard,
safe environment</p>
</dd>
</dl>

<p>Although the “Concepts” chapter is arguably more fundamental than the “Types” and “Traits” chapters, it is deliberately
placed later in the book so that readers who are reading from beginning to end can build up some confidence first.</p>
</div></section>






<section data-pdf-bookmark="Conventions Used in This Book" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id199">
<h1>Conventions Used in This Book</h1>

<p>The following typographical conventions are used in this book:</p>
<dl>
<dt><em>Italic</em></dt>
<dd>
<p>Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
</dd>
<dt><code>Constant width</code></dt>
<dd>
<p>Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>
</dd>
</dl>
<aside class="does_not_compile pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/preface01.html.id226">
<h1></h1>
<pre data-type="programlisting">// Marks code samples that do not compile</pre>
</div></aside>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/preface01.html.id227">
<h1></h1>
<pre data-type="programlisting">// Marks code samples that exhibit undesired behavior</pre>
</div></aside>
<!--PROD: Please reach out to author to find out if they will be uploading code examples to oreilly.com or their own site (e.g., GitHub). If there is no code download, delete this whole section. If there is, when you email digidist with the link, let them know what you filled in for title_title (should be as close to book title as possible, i.e., learning_python_2e). This info will determine where digidist loads the files.-->
</div></section>






<section data-pdf-bookmark="O’Reilly Online Learning" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id200">
<h1>O’Reilly Online Learning</h1>
<div class="ormenabled" data-type="note" epub:type="note"><h6>Note</h6>
<p>For more than 40 years, <a class="orm:hideurl" href="https://oreilly.com"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>
</div>

<p>Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit <a class="orm:hideurl" href="https://oreilly.com"><em>https://oreilly.com</em></a>.</p>
</div></section>






<section data-pdf-bookmark="How to Contact Us" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id201">
<h1>How to Contact Us</h1>

<p>Please address comments and questions concerning this book to the publisher:</p>
<ul class="simplelist">
  <li>O’Reilly Media, Inc.</li>
  <li>1005 Gravenstein Highway North</li>
  <li>Sebastopol, CA 95472</li>
  <li>800-889-8969 (in the United States or Canada)</li>
  <li>707-827-7019 (international or local)</li>
  <li>707-829-0104 (fax)</li>
  <li><a class="email" href="#OEBPS/mailto:support@oreilly.com"><em>support@oreilly.com</em></a></li>
  <li><a href="https://www.oreilly.com/about/contact.html"><em>https://www.oreilly.com/about/contact.html</em></a></li>
</ul>

<p>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a class="bare" href="https://oreil.ly/effective-rust"><em class="hyperlink">https://oreil.ly/effective-rust</em></a>.</p>
<!--Don't forget to update the link above.-->

<p>For news and information about our books and courses, visit <a class="bare" href="https://oreilly.com"><em class="hyperlink">https://oreilly.com</em></a>.</p>

<p>Find us on LinkedIn: <a class="bare" href="https://linkedin.com/company/oreilly-media"><em class="hyperlink">https://linkedin.com/company/oreilly-media</em></a>.</p>

<p>Watch us on YouTube: <a class="bare" href="https://youtube.com/oreillymedia"><em class="hyperlink">https://youtube.com/oreillymedia</em></a>.</p>
</div></section>






<section data-pdf-bookmark="Acknowledgments" data-type="sect1"><div class="sect1" id="OEBPS/preface01.html.id202">
<h1>Acknowledgments</h1>

<p>My thanks go to the people who helped make this book possible:</p>

<ul>
<li>
<p>The technical reviewers who gave expert and detailed feedback on all aspects of the text: Pietro Albini, Jess Males,
Mike Capp, and especially Carol Nichols.</p>
</li>
<li>
<p>My editors at O’Reilly: Jeff Bleiel, Brian Guerin, and Katie Tozer.</p>
</li>
<li>
<p>Tiziano Santoro, from whom I originally learned many things about Rust.</p>
</li>
<li>
<p>Danny Elfanbaum, who provided vital technical assistance for dealing with the AsciiDoc formatting of the book.</p>
</li>
<li>
<p>Diligent readers of the original web version of the book, in particular:</p>

<ul>
<li>
<p>Julian Rosse, who spotted dozens of typos and other errors in the online text.</p>
</li>
<li>
<p>Martin Disch, who pointed out potential improvements and inaccuracies in several Items.</p>
</li>
<li>
<p>Chris Fleetwood, Sergey Kaunov, Clifford Matthews, Remo Senekowitsch, Kirill Zaborsky, and an anonymous Proton Mail
user, who pointed out mistakes in the text.</p>
</li>
</ul>
</li>
<li>
<p>My family, who coped with many weekends when I was distracted by writing.</p>
</li>
</ul>
</div></section>
</div></section></div></div>
<div id="OEBPS/ch01.html"><div data-type="book">
<section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch01.html.file_types_md">
<h1><span class="label">Chapter 1. </span>Types</h1>


<p>This first chapter of this book covers advice that revolves around Rust’s  type system.  <a data-primary="types" data-secondary="defined" data-type="indexterm" id="OEBPS/ch01.html.id228"></a>This type system is more
expressive than that of other mainstream languages; it has more in common with “academic” languages such as
 <a class="orm:hideurl" href="https://ocaml.org/">OCaml</a> or  <a class="orm:hideurl" href="https://www.haskell.org/">Haskell</a>.</p>

<p>One core<a data-primary="algebraic data type" data-type="indexterm" id="OEBPS/ch01.html.id229"></a><a data-primary="enums" data-type="indexterm" id="OEBPS/ch01.html.id230"></a> part of this is Rust’s  <code>enum</code> type, which is considerably more expressive than the enumeration types in
other languages and which allows for  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em></a>.</p>

<p>The Items in this chapter cover the fundamental types that the language provides and how to combine them into data
structures that precisely express the semantics of your program.  This concept of encoding behavior into the type
system helps to reduce the amount of checking and error path code that’s required, because invalid states are rejected
by the toolchain at compile time rather than by the program at runtime.<a data-primary="type system" data-secondary="encoding behavior into" data-type="indexterm" id="OEBPS/ch01.html.id231"></a></p>

<p>This chapter also describes some of the ubiquitous data structures that are provided by Rust’s standard library:
<code>Option</code>s, <code>Result</code>s, <code>Error</code>s and <code>Iterator</code>s.  <a data-primary="data structures" data-type="indexterm" id="OEBPS/ch01.html.id232"></a>Familiarity with these standard tools will help you write idiomatic
Rust that is efficient and compact—in particular, they allow use of Rust’s  question mark operator, which
supports error handling that is unobtrusive but still type-safe.<a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id233"></a></p>

<p>Note that Items that involve Rust  <em>traits</em> are covered in the following chapter, but there is necessarily a degree
of overlap with the Items in this chapter, because traits describe the behavior of types.<a data-primary="traits" data-type="indexterm" id="OEBPS/ch01.html.id234"></a></p>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 1: Use the type system to express 
your data structures" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_use-types_md">
<h1>Item 1: Use the type system to express 
<span class="keep-together">your data structures</span></h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>who called them programers and not type writers</p>
<p data-type="attribution"><a href="https://oreil.ly/hHj5c">@thingskatedid</a></p>
</blockquote>

<p>This Item provides a quick tour of Rust’s <a data-primary="@thingskatedid" data-primary-sortas="things" data-type="indexterm" id="OEBPS/ch01.html.id235"></a><a data-primary="types" data-type="indexterm" id="OEBPS/ch01.html.ix_typ"></a>type system, starting with the fundamental types that the compiler makes
available, then moving on to the various ways that values can be combined into data structures.</p>

<p>Rust’s <code>enum</code> type then takes a starring role. Although the basic version is equivalent to what other languages provide,
the ability to combine <code>enum</code> variants with data fields allows for enhanced flexibility and expressivity.<a data-primary="enums" data-secondary="enum types" data-type="indexterm" id="OEBPS/ch01.html.id236"></a></p>








<section data-pdf-bookmark="Fundamental Types" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id6">
<h2>Fundamental Types</h2>

<p>The basics of Rust’s type system are pretty familiar to anyone coming
from another statically typed programming language (such as C++, Go, or Java).<a data-primary="static typing" data-type="indexterm" id="OEBPS/ch01.html.id237"></a><a data-primary="C++" data-type="indexterm" id="OEBPS/ch01.html.id238"></a><a data-primary="types" data-secondary="fundamental" data-type="indexterm" id="OEBPS/ch01.html.ix_typfnd"></a><a data-primary="types" data-secondary="fundamental" data-tertiary="integer types with specific sizes" data-type="indexterm" id="OEBPS/ch01.html.id239"></a><a data-primary="integer types" data-secondary="specific sized, signed and unsigned" data-type="indexterm" id="OEBPS/ch01.html.id240"></a><a data-primary="i8 type" data-type="indexterm" id="OEBPS/ch01.html.id241"></a><a data-primary="i16 type" data-type="indexterm" id="OEBPS/ch01.html.id242"></a><a data-primary="i32 type" data-type="indexterm" id="OEBPS/ch01.html.id243"></a><a data-primary="i64 type" data-type="indexterm" id="OEBPS/ch01.html.id244"></a><a data-primary="i128 type" data-type="indexterm" id="OEBPS/ch01.html.id245"></a><a data-primary="u8 type" data-type="indexterm" id="OEBPS/ch01.html.id246"></a><a data-primary="u16 type" data-type="indexterm" id="OEBPS/ch01.html.id247"></a><a data-primary="u32 type" data-type="indexterm" id="OEBPS/ch01.html.id248"></a><a data-primary="u64 type" data-type="indexterm" id="OEBPS/ch01.html.id249"></a><a data-primary="u128 type" data-type="indexterm" id="OEBPS/ch01.html.id250"></a>
There’s a collection of integer types with specific sizes, both signed
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.i8.html"><code>i8</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.i16.html"><code>i16</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.i128.html"><code>i128</code></a>)
and unsigned
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.u16.html"><code>u16</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.u32.html"><code>u32</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.u128.html"><code>u128</code></a>).</p>

<p>There are also signed  (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.isize.html"><code>isize</code></a>) and unsigned
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a>) integers whose sizes match the pointer size on
the target system.<a data-primary="integer types" data-secondary="matching pointer size, signed and unsigned" data-type="indexterm" id="OEBPS/ch01.html.id251"></a><a data-primary="types" data-secondary="fundamental" data-tertiary="integer types matching pointer size on target system" data-type="indexterm" id="OEBPS/ch01.html.id252"></a><a data-primary="casts" data-type="indexterm" id="OEBPS/ch01.html.id253"></a>  However, you won’t be doing much in the way of converting between
pointers and integers with Rust, so that size equivalence isn’t really relevant. However, standard collections return their size
as a <code>usize</code> (from <code>.len()</code>), so collection indexing means that <code>usize</code> values are quite common—which is
obviously fine from a capacity perspective, as there can’t be more items in an in-memory collection than there are
memory addresses on the system.<a data-primary="collections" data-secondary="length returned as usize" data-type="indexterm" id="OEBPS/ch01.html.id254"></a><a data-primary="usize" data-type="indexterm" id="OEBPS/ch01.html.id255"></a><a data-primary="integer types" data-secondary="converting larger to smaller, compile-time error" data-type="indexterm" id="OEBPS/ch01.html.id256"></a><a data-primary="mismatched types error" data-type="indexterm" id="OEBPS/ch01.html.id257"></a></p>

<p>The integral types do give us the first hint that Rust is a stricter world than C++. <a data-primary="types" data-secondary="fundamental" data-tertiary="stricter conversions in Rust" data-type="indexterm" id="OEBPS/ch01.html.id258"></a>In Rust, attempting to
 put a larger integer type (<code>i32</code>) into a smaller integer type (<code>i16</code>) generates a compile-time error:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id259">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="mi">42</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i16</code> <code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:18:18
   |
18 |     let y: i16 = x;
   |            ---   ^ expected `i16`, found `i32`
   |            |
   |            expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value
      doesn't fit
   |
18 |     let y: i16 = x.try_into().unwrap();
   |                   ++++++++++++++++++++</pre>

<p>This is reassuring: Rust is not going to sit there quietly while the programmer does things that are risky.<a data-primary="type conversions" data-secondary="error attempting to convert larger integer type into smaller integer type" data-type="indexterm" id="OEBPS/ch01.html.id260"></a>  Although we
can see that the values involved in this particular conversion would be just fine, the compiler has to allow for the
possibility of values where the conversion is <em>not</em> fine:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id261">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="mi">66_000</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i16</code> <code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="c1">// What would this value be?</code></pre>
</div></aside>

<p>The error output also gives an early indication that while Rust has stronger rules, it also has helpful compiler
messages that point the way to how to comply with the rules.<a data-primary="compiler messages on errors" data-type="indexterm" id="OEBPS/ch01.html.id262"></a>  The suggested solution raises the question of how to
handle situations where the conversion would have to alter the value to fit, and we’ll have more to say on both
 error handling (<a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>) and using  <code>panic!</code> (<a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>) later.</p>

<p>Rust also doesn’t allow some things that might appear “safe,” such as putting a value from a smaller integer type into a
larger integer type:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id263">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">42</code><code class="k">i32</code><code class="p">;</code><code class="w"> </code><code class="c1">// Integer literal with type suffix</code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i64</code> <code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:36:18
   |
36 |     let y: i64 = x;
   |            ---   ^ expected `i64`, found `i32`
   |            |
   |            expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
36 |     let y: i64 = x.into();
   |                   +++++++</pre>

<p>Here, the suggested solution doesn’t raise the specter of error handling, but the conversion does still need to be
explicit. We’ll discuss type conversions in more detail later (<a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>).<a data-primary="types" data-secondary="fundamental" data-tertiary="floating point types" data-type="indexterm" id="OEBPS/ch01.html.id264"></a><a data-primary="types" data-secondary="fundamental" data-tertiary="bool" data-type="indexterm" id="OEBPS/ch01.html.id265"></a><a data-primary="types" data-secondary="fundamental" data-tertiary="unit" data-type="indexterm" id="OEBPS/ch01.html.id266"></a><a data-primary="floating point types" data-type="indexterm" id="OEBPS/ch01.html.id267"></a><a data-primary="unit type" data-type="indexterm" id="OEBPS/ch01.html.id268"></a><a data-primary="bool type" data-type="indexterm" id="OEBPS/ch01.html.id269"></a><a data-primary="f32 type" data-type="indexterm" id="OEBPS/ch01.html.id270"></a><a data-primary="f64 type" data-type="indexterm" id="OEBPS/ch01.html.id271"></a></p>

<p>Continuing with the unsurprising primitive types, Rust has a
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a> type, floating point types
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>),
and a  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Unit_type">unit type</a>  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a>
(like C’s  <code>void</code>).<a data-primary="void (C)" data-type="indexterm" id="OEBPS/ch01.html.id272"></a></p>

<p>More interesting is the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> character type, which holds a
<a class="orm:hideurl" href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode value</a> (similar to Go’s <a class="orm:hideurl" href="https://golang.org/doc/go1#rune"><code>rune</code> type</a>). <a data-primary="Go" data-type="indexterm" id="OEBPS/ch01.html.id273"></a><a data-primary="Unicode" data-type="indexterm" id="OEBPS/ch01.html.id274"></a><a data-primary="types" data-secondary="fundamental" data-tertiary="char" data-type="indexterm" id="OEBPS/ch01.html.id275"></a><a data-primary="char type" data-type="indexterm" id="OEBPS/ch01.html.id276"></a>Although this is stored as four bytes internally, there are again no silent
conversions to or from a 32-bit integer.</p>

<p>This precision in the type system forces you to be explicit about what you’re trying to express—a <code>u32</code> value is
different from a <code>char</code>, which in turn is different from a sequence of  UTF-8 bytes, which in turn is different<a data-primary="u32 type" data-type="indexterm" id="OEBPS/ch01.html.id277"></a><a data-primary="UTF-8" data-type="indexterm" id="OEBPS/ch01.html.id278"></a>
from a sequence of arbitrary bytes, and it’s up to you to specify exactly which you mean.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id279" id="OEBPS/ch01.html.id279-marker">1</a></sup>  Joel Spolsky’s <a href="https://oreil.ly/wWy7T">famous blog post</a> can help you understand which you need.</p>

<p>Of course, there are helper methods that allow you to convert between these different types, but their signatures force
you to handle (or explicitly ignore) the possibility of failure.<a data-primary="u32 type" data-secondary="values not valid for Unicode code points" data-type="indexterm" id="OEBPS/ch01.html.id280"></a>  For example, a  Unicode code point can always be represented in 32 bits,<sup><a data-type="noteref" href="#OEBPS/ch01.html.id281" id="OEBPS/ch01.html.id281-marker">2</a></sup> so <code>'a' as u32</code> is allowed, but the other direction is trickier (as there
are some <code>u32</code> values that are not valid Unicode code points):</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32"><code>char::from_u32</code></a></dt>
<dd>
<p>Returns an <code>Option&lt;char&gt;</code>, forcing the caller to handle the failure case.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked"><code>char::from_u32_unchecked</code></a></dt>
<dd>
<p>Makes the
assumption of validity but has the potential to result in undefined behavior if that assumption turns out not to be
true.<a data-primary="unsafe functions" data-type="indexterm" id="OEBPS/ch01.html.id282"></a><a data-primary="Option type" data-type="indexterm" id="OEBPS/ch01.html.id283"></a>  The function  is marked <code>unsafe</code> as a result, forcing the caller to use <code>unsafe</code> too (<a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>).</p>
</dd>
</dl>
</div></section>








<section data-pdf-bookmark="Aggregate Types" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id7">
<h2>Aggregate Types</h2>

<p>Moving on to aggregate types, Rust has a variety of ways to combine related values.<a data-primary="types" data-secondary="fundamental" data-startref="ix_typfnd" data-type="indexterm" id="OEBPS/ch01.html.id284"></a><a data-primary="types" data-secondary="aggregate" data-type="indexterm" id="OEBPS/ch01.html.id285"></a><a data-primary="aggregate types" data-type="indexterm" id="OEBPS/ch01.html.id286"></a><a data-primary="array type" data-type="indexterm" id="OEBPS/ch01.html.id287"></a>  Most of these are
familiar equivalents to the aggregation mechanisms available in other languages:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.array.html">Arrays</a></dt>
<dd>
<p>Hold multiple instances of a single
type, where the number of instances is known at compile time.  For example, <code>[u32; 4]</code> is four 4-byte integers in a
row.<a data-primary="tuple type" data-type="indexterm" id="OEBPS/ch01.html.id288"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.tuple.html">Tuples</a></dt>
<dd>
<p>Hold instances of multiple
heterogeneous types, where the number of elements and their types are known at compile time, for example,
<code>(WidgetOffset, WidgetSize, WidgetColor)</code>.  If the types in the tuple aren’t distinctive—for example, <code>(i32, i32, &amp;'static str, bool)</code>—it’s better to give each element a name and use a struct.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/keyword.struct.html">Structs</a></dt>
<dd>
<p>Also hold instances of heterogeneous
types known at compile time but allow both the overall type and the individual fields to be referred to by
name.<a data-primary="struct types" data-type="indexterm" id="OEBPS/ch01.html.id289"></a><a data-primary="tuple struct" data-type="indexterm" id="OEBPS/ch01.html.id290"></a></p>
</dd>
</dl>

<p>Rust also includes the  <em>tuple struct</em>, which is a crossbreed of a <code>struct</code> and a tuple: there’s a name for the overall
type but no names for the individual fields—they are referred to by number instead: <code>s.0</code>, <code>s.1</code>, and so on:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Struct with two unnamed fields.</code>
<code class="k">struct</code> <code class="nc">TextMatch</code><code class="p">(</code><code class="kt">usize</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="p">);</code><code class="w"></code>

<code class="c1">// Construct by providing the contents in order.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">m</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">TextMatch</code><code class="p">(</code><code class="mi">12</code><code class="p">,</code><code class="w"> </code><code class="s">"needle"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">());</code><code class="w"></code>

<code class="c1">// Access by field number.</code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">m</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">12</code><code class="p">);</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="enums" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id8">
<h2><code>enum</code>s</h2>

<p>This brings us to the jewel <a data-primary="enums" data-type="indexterm" id="OEBPS/ch01.html.ix_enum"></a>in the crown of Rust’s type system, the  <code>enum</code>. With the basic form of an <code>enum</code>, it’s hard to see what there is to get excited about. As with other languages, the <code>enum</code> allows you
to specify a set of mutually exclusive values, possibly with a numeric value attached:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">enum</code> <code class="nc">HttpResultCode</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">200</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">NotFound</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">404</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Teapot</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">418</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HttpResultCode</code>::<code class="n">NotFound</code><code class="p">;</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">code</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="mi">404</code><code class="p">);</code><code class="w"></code></pre>

<p>Because each <code>enum</code> definition creates a distinct type, this can be used to improve readability and maintainability of
functions that take  <code>bool</code> arguments. Instead of:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="n">print_page</code><code class="p">(</code><code class="cm">/* both_sides= */</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"> </code><code class="cm">/* color= */</code><code class="w"> </code><code class="kc">false</code><code class="p">);</code><code class="w"></code></pre>

<p>a version that uses a pair of <code>enum</code>s:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">Sides</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Both</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Single</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">Output</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">BlackAndWhite</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Color</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">print_page</code><code class="p">(</code><code class="n">sides</code>: <code class="nc">Sides</code><code class="p">,</code><code class="w"> </code><code class="n">color</code>: <code class="nc">Output</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>is more type-safe and easier to read at the point of invocation:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="n">print_page</code><code class="p">(</code><code class="n">Sides</code>::<code class="n">Both</code><code class="p">,</code><code class="w"> </code><code class="n">Output</code>::<code class="n">BlackAndWhite</code><code class="p">);</code><code class="w"></code></pre>

<p>Unlike the <code>bool</code> version, if a library user were to accidentally flip the order of the arguments, the compiler would
immediately complain:</p>

<pre data-code-language="text" data-type="programlisting">error[E0308]: arguments to this function are incorrect
   --&gt; src/main.rs:104:9
    |
104 | print_page(Output::BlackAndWhite, Sides::Single);
    | ^^^^^^^^^^ ---------------------  ------------- expected `enums::Output`,
    |            |                                    found `enums::Sides`
    |            |
    |            expected `enums::Sides`, found `enums::Output`
    |
note: function defined here
   --&gt; src/main.rs:145:12
    |
145 |     pub fn print_page(sides: Sides, color: Output) {
    |            ^^^^^^^^^^ ------------  -------------
help: swap these arguments
    |
104 | print_page(Sides::Single, Output::BlackAndWhite);
    |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre>

<p>Using the newtype pattern—see <a href="#OEBPS/ch01.html.file_newtype_md">Item 6</a>—to wrap a <code>bool</code> also achieves type safety and maintainability; it’s
generally best to use the newtype pattern if the semantics will always be Boolean, and to use an <code>enum</code> if there’s a chance that a new
alternative—e.g., <code>Sides::BothAlternateOrientation</code>—could arise in the future.</p>

<p>The type safety of Rust’s <code>enum</code>s continues with the  <code>match</code> expression:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id291">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">msg</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">HttpResultCode</code>::<code class="nb">Ok</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"Ok"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">HttpResultCode</code>::<code class="n">NotFound</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"Not found"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// forgot to deal with the all-important "I'm a teapot" code</code>
<code class="p">};</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0004]: non-exhaustive patterns: `HttpResultCode::Teapot` not covered
  --&gt; src/main.rs:44:21
   |</pre>

<pre class="pagebreak-before less_space" data-code-language="rust" data-type="programlisting"><code class="mi">44</code><code class="w"> </code><code class="o">|</code><code class="w">     </code><code class="kd">let</code><code class="w"> </code><code class="n">msg</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w">                     </code><code class="o">^^^^</code><code class="w"> </code><code class="n">pattern</code><code class="w"> </code><code class="err">`</code><code class="n">HttpResultCode</code>::<code class="n">Teapot</code><code class="err">`</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">covered</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w"></code>
<code class="n">note</code>: <code class="err">`</code><code class="n">HttpResultCode</code><code class="err">`</code><code class="w"> </code><code class="n">defined</code><code class="w"> </code><code class="n">here</code><code class="w"></code>
<code class="w">  </code><code class="o">-</code>-&gt; <code class="nc">src</code><code class="o">/</code><code class="n">main</code><code class="p">.</code><code class="n">rs</code>:<code class="mi">10</code>:<code class="mi">5</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w"></code>
<code class="mi">7</code><code class="w">  </code><code class="o">|</code><code class="w"> </code><code class="k">enum</code> <code class="nc">HttpResultCode</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w">      </code><code class="o">--------------</code><code class="w"></code>
<code class="o">..</code><code class="p">.</code><code class="w"></code>
<code class="mi">10</code><code class="w"> </code><code class="o">|</code><code class="w">     </code><code class="n">Teapot</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">418</code><code class="p">,</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w">     </code><code class="o">^^^^^^</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">covered</code><code class="w"></code>
<code class="w">   </code><code class="o">=</code><code class="w"> </code><code class="n">note</code>: <code class="nc">the</code><code class="w"> </code><code class="n">matched</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">of</code><code class="w"> </code><code class="k">type</code> <code class="err">`</code><code class="n">HttpResultCode</code><code class="err">`</code><code class="w"></code>
<code class="n">help</code>: <code class="nc">ensure</code><code class="w"> </code><code class="n">that</code><code class="w"> </code><code class="n">all</code><code class="w"> </code><code class="n">possible</code><code class="w"> </code><code class="n">cases</code><code class="w"> </code><code class="n">are</code><code class="w"> </code><code class="n">being</code><code class="w"> </code><code class="n">handled</code><code class="w"> </code><code class="n">by</code><code class="w"> </code><code class="n">adding</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">arm</code><code class="w"></code>
<code class="w">      </code><code class="n">with</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">wildcard</code><code class="w"> </code><code class="n">pattern</code><code class="w"> </code><code class="n">or</code><code class="w"> </code><code class="n">an</code><code class="w"> </code><code class="n">explicit</code><code class="w"> </code><code class="n">pattern</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="n">shown</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w"></code>
<code class="mi">46</code><code class="w"> </code><code class="o">~</code><code class="w">         </code><code class="n">HttpResultCode</code>::<code class="n">NotFound</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="s">"Not found"</code><code class="p">,</code><code class="w"></code>
<code class="mi">47</code><code class="w"> </code><code class="o">~</code><code class="w">         </code><code class="n">HttpResultCode</code>::<code class="n">Teapot</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">todo!</code><code class="p">(),</code><code class="w"></code>
<code class="w">   </code><code class="o">|</code><code class="w"></code></pre>

<p>The compiler forces the programmer to consider <em>all</em> of the possibilities that are represented by the <code>enum</code>,<sup><a data-type="noteref" href="#OEBPS/ch01.html.id292" id="OEBPS/ch01.html.id292-marker">3</a></sup> even if the result is just to add a default arm <code>_ =&gt; {}</code>.
(Note that modern C++ compilers can and do warn about missing <code>switch</code> arms for <code>enum</code>s as well.)</p>
</div></section>








<section data-pdf-bookmark="enums with Fields" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id9">
<h2><code>enum</code>s with Fields</h2>

<p>The true power of Rust’s <code>enum</code> feature comes from the fact that each variant can have data that comes along with it,
making it an aggregate type that acts as an  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data type</em></a> (ADT).  <a data-primary="algebraic data type" data-type="indexterm" id="OEBPS/ch01.html.id293"></a>This is less familiar to programmers of mainstream
languages; in C/C++ terms, it’s like a combination of an <code>enum</code> with a <code>union</code>—only type-safe.<a data-primary="C++" data-secondary="combination of enum with union" data-type="indexterm" id="OEBPS/ch01.html.id294"></a></p>

<p>This means that the invariants of the program’s data structures can be encoded into Rust’s type system; states that
don’t comply with those invariants won’t even compile.  A well-designed <code>enum</code> makes the creator’s intent clear to
humans as well as to the compiler:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="p">{</code><code class="n">HashMap</code><code class="p">,</code><code class="w"> </code><code class="n">HashSet</code><code class="p">};</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">SchedulerState</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Inert</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Pending</code><code class="p">(</code><code class="n">HashSet</code><code class="o">&lt;</code><code class="n">Job</code><code class="o">&gt;</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">Running</code><code class="p">(</code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">CpuId</code><code class="p">,</code><code class="w"> </code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Job</code><code class="o">&gt;&gt;</code><code class="p">),</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Just from the type definition, it’s reasonable to guess that <code>Job</code>s get queued up in the <code>Pending</code> state until the
scheduler is fully active, at which point they’re assigned to some per-CPU pool.</p>

<p>This highlights the central theme of this Item, which is to use Rust’s type system to express the concepts that are
associated with the design of your software.</p>

<p>A dead giveaway for when this is <em>not</em> happening is a comment that explains when some field or parameter is valid:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id295">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">DisplayProps</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">monochrome</code>: <code class="kt">bool</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// `fg_color` must be (0, 0, 0) if `monochrome` is true.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">fg_color</code>: <code class="nc">RgbColor</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>This is a prime candidate for replacement with an <code>enum</code> holding data:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">Color</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Monochrome</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Foreground</code><code class="p">(</code><code class="n">RgbColor</code><code class="p">),</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">DisplayProps</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">color</code>: <code class="nc">Color</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This small example illustrates a key piece of advice: <em>make invalid states inexpressible in your types</em>.
Types that support only valid combinations of values mean that whole classes of errors are rejected by the compiler,
leading to smaller and safer code.<a data-primary="enums" data-startref="ix_enum" data-type="indexterm" id="OEBPS/ch01.html.id296"></a></p>
</div></section>








<section data-pdf-bookmark="Ubiquitous enum Types" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id169">
<h2>Ubiquitous <code>enum</code> Types</h2>

<p>Returning to the power of the  <code>enum</code>, there are two concepts that are so common that Rust’s standard library
includes built-in <code>enum</code> types to express them; these types are ubiquitous in Rust code.<a data-primary="enums" data-secondary="enum types" data-type="indexterm" id="OEBPS/ch01.html.id297"></a></p>










<section class="pagebreak-before less_space" data-pdf-bookmark="Option<T>" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id10">
<h3><code>Option&lt;T&gt;</code></h3>

<p>The first concept is that of an  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>: either there’s
a value of a particular type  (<code>Some(T)</code>) or there isn’t  (<code>None</code>). <em>Always use
<code>Option</code> for values that can be absent</em>; never fall back to using  sentinel values (-1, <code>nullptr</code>, …) to
try to express the same concept in-band.<a data-primary="enums" data-secondary="enum types" data-tertiary="Option" data-type="indexterm" id="OEBPS/ch01.html.id298"></a><a data-primary="Option type" data-type="indexterm" id="OEBPS/ch01.html.id299"></a></p>

<p>There is one subtle point to consider, though.  <a data-primary="collections" data-secondary="of zero things" data-secondary-sortas="zero" data-type="indexterm" id="OEBPS/ch01.html.id300"></a>If you’re dealing with a <em>collection</em> of things, you need to decide
whether having zero things in the collection is the same as not having a collection. For most situations, the
distinction doesn’t arise and you can go ahead and use (say) <code>Vec&lt;Thing&gt;</code>: a count of zero things implies an absence of
things.</p>

<p>However, there are definitely other rare scenarios where the two cases need to be distinguished with
<code>Option&lt;Vec&lt;Thing&gt;&gt;</code>—for example, a cryptographic system might need to distinguish between <a href="https://oreil.ly/vuLlo">“payload transported separately”</a> and “empty payload provided.”  (This is related to the
debates around the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Null_(SQL)"><code>NULL</code> marker</a> for columns in  SQL.)</p>

<p>Similarly, what’s the best choice for a <code>String</code> that might be absent?  Does <code>""</code> or <code>None</code> make more sense to indicate
the absence of a value?  Either way works, but <code>Option&lt;String&gt;</code> clearly communicates the possibility that this value may
be absent.<a data-primary="String type" data-secondary="absence of a value" data-type="indexterm" id="OEBPS/ch01.html.id301"></a></p>
</div></section>










<section data-pdf-bookmark="Result<T, E>" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id11">
<h3><code>Result&lt;T, E&gt;</code></h3>

<p>The second common concept arises from error processing: if a function fails, how should that failure be reported?<a data-primary="enums" data-secondary="enum types" data-tertiary="Result" data-type="indexterm" id="OEBPS/ch01.html.id302"></a><a data-primary="Result type" data-type="indexterm" id="OEBPS/ch01.html.id303"></a><a data-primary="errors" data-secondary="processing if function fails, using Result type" data-type="indexterm" id="OEBPS/ch01.html.id304"></a>
Historically, special  sentinel values (e.g., <code>-errno</code> return values from Linux system calls) or  global
variables (<code>errno</code> for POSIX systems) were used. More recently, languages that support multiple or tuple return values
(such as  Go) from functions may have a convention of returning a <code>(result, error)</code> pair, assuming the existence of
some suitable “zero” value for the <code>result</code> when the <code>error</code> is non-“zero.”</p>

<p>In Rust, there’s an <code>enum</code> for just this purpose: <em>always encode the result of an operation that might fail as a
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a></em>.  The <code>T</code> type holds the
successful result (in the  <code>Ok</code> variant), and the <code>E</code> type holds error details (in the  <code>Err</code> variant) on
failure.</p>

<p>Using the standard type makes the intent of the design clear. It also allows the use of standard transformations (<a href="#OEBPS/ch01.html.file_transform_md">Item 3</a>)
and error processing (<a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>), which in turn makes it possible to streamline error processing with the <code>?</code> operator as well.<a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id305"></a><a data-primary="types" data-startref="ix_typ" data-type="indexterm" id="OEBPS/ch01.html.id306"></a></p>
</div></section>
</div></section>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 2: Use the type system to express common behavior" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_use-types-2_md">
<h1>Item 2: Use the type system to express common behavior</h1>

<p><a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> discussed how to express data structures in the type system; this Item moves on to discuss the encoding of
<em>behavior</em> in Rust’s type system.<a data-primary="types" data-secondary="expressing common behaviors" data-type="indexterm" id="OEBPS/ch01.html.id307"></a></p>

<p>The mechanisms described in this Item will generally feel familiar, as they all have direct analogs in other
languages:</p>
<dl>
<dt>Functions</dt>
<dd>
<p>The universal mechanism for associating a chunk of code with a name and a parameter list.</p>
</dd>
<dt>Methods</dt>
<dd>
<p>Functions that are associated with an instance of a particular data structure. Methods are common in programming languages created after object-orientation arose as a programming paradigm.<a data-primary="methods" data-type="indexterm" id="OEBPS/ch01.html.id308"></a></p>
</dd>
<dt>Function pointers</dt>
<dd>
<p>Supported by most languages in the C family, including C++ and Go, as a mechanism that allows<a data-primary="function pointers" data-type="indexterm" id="OEBPS/ch01.html.id309"></a>
an extra level of indirection when invoking other code.</p>
</dd>
<dt>Closures</dt>
<dd>
<p>Originally most common in the Lisp family of languages but have been retrofitted to many popular<a data-primary="closures" data-type="indexterm" id="OEBPS/ch01.html.id310"></a><a data-primary="Lisp" data-type="indexterm" id="OEBPS/ch01.html.id311"></a>
programming languages, including C++ (since C++11) and Java (since Java 8).<a data-primary="C++" data-type="indexterm" id="OEBPS/ch01.html.id312"></a></p>
</dd>
<dt>Traits</dt>
<dd>
<p>Describe collections of related<a data-primary="traits" data-type="indexterm" id="OEBPS/ch01.html.id313"></a> functionality that all apply to the same underlying item. Traits have rough equivalents in many other languages, including abstract classes in C++ and interfaces in Go and Java.<a data-primary="Go" data-type="indexterm" id="OEBPS/ch01.html.id314"></a><a data-primary="Java" data-type="indexterm" id="OEBPS/ch01.html.id315"></a><a data-primary="interfaces" data-type="indexterm" id="OEBPS/ch01.html.id316"></a><a data-primary="abstract classes" data-type="indexterm" id="OEBPS/ch01.html.id317"></a></p>
</dd>
</dl>

<p>Of course, all of these mechanisms have Rust-specific details that this Item will cover.</p>

<p>Of the preceding list, traits have the most significance for this book, as they describe so much of the behavior provided by
the Rust compiler and standard library.  <a data-type="xref" href="#OEBPS/ch02.html.file_traits_md">Chapter&nbsp;2</a> focuses on Items that give advice on designing and
implementing traits, but their pervasiveness means that they crop up frequently in the other Items in this chapter too.</p>








<section data-pdf-bookmark="Functions and Methods" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id13">
<h2>Functions and Methods</h2>

<p>As with every other programming language, Rust uses  <em>functions</em> to organize code into named chunks for reuse,
with inputs to the code expressed as parameters.<a data-primary="types" data-secondary="functions" data-type="indexterm" id="OEBPS/ch01.html.id318"></a><a data-primary="functions" data-type="indexterm" id="OEBPS/ch01.html.id319"></a>  As with every other statically typed language, the types of the
parameters and the return value are explicitly specified:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Return `x` divided by `y`.</code>
<code class="k">fn</code> <code class="nf">div</code><code class="p">(</code><code class="n">x</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mf">0.0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Terminate the function and return a value.</code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kt">f64</code>::<code class="n">NAN</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="c1">// The last expression in the function body is implicitly returned.</code>
<code class="w">    </code><code class="n">x</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">y</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Function called just for its side effects, with no return value.</code>
<code class="sd">/// Can also write the return value as `-&gt; ()`.</code>
<code class="k">fn</code> <code class="nf">show</code><code class="p">(</code><code class="n">x</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"x = {x}"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If a function is intimately involved with a particular data structure, it is expressed as a  <em>method</em>. <a data-primary="types" data-secondary="methods" data-type="indexterm" id="OEBPS/ch01.html.id320"></a><a data-primary="methods" data-type="indexterm" id="OEBPS/ch01.html.id321"></a>A method
acts on an item of that type, identified by <code>self</code>, and is included within an <code>impl DataStructure</code> block.  <a data-primary="self keyword" data-type="indexterm" id="OEBPS/ch01.html.id322"></a><a data-primary="struct types" data-secondary="methods added to" data-type="indexterm" id="OEBPS/ch01.html.id323"></a><a data-primary="enums" data-type="indexterm" id="OEBPS/ch01.html.id324"></a>This
encapsulates related data and code together in an object-oriented way that’s similar to other languages; however,
in Rust, methods can be added to <code>enum</code> types as well as to <code>struct</code> types, in keeping with the pervasive
nature of Rust’s <code>enum</code> (<a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">enum</code> <code class="nc">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Rectangle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">width</code>: <code class="kt">f64</code><code class="p">,</code><code class="w"> </code><code class="n">height</code>: <code class="kt">f64</code> <code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">radius</code>: <code class="kt">f64</code> <code class="p">},</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">area</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">Shape</code>::<code class="n">Rectangle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">width</code><code class="p">,</code><code class="w"> </code><code class="n">height</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">width</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">height</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">Shape</code>::<code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">std</code>::<code class="kt">f64</code>::<code class="n">consts</code>::<code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The name of a method creates a label for the behavior it encodes, and the  method signature gives type
information for its inputs and outputs.  The first input for a method will be some variant of <code>self</code>, indicating
what the method might do to the data structure:</p>

<ul>
<li>
<p>A <code>&amp;self</code> parameter indicates that the contents of the data structure may be read from but will not be modified.</p>
</li>
<li>
<p>A <code>&amp;mut self</code> parameter indicates that the method might modify the contents of the data structure.</p>
</li>
<li>
<p>A <code>self</code> parameter indicates that the method consumes the data structure.</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Function Pointers" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id14">
<h2>Function Pointers</h2>

<p>The previous section described how to associate a name (and a parameter list) with some code. <a data-primary="function pointers" data-type="indexterm" id="OEBPS/ch01.html.id325"></a><a data-primary="types" data-secondary="function pointers" data-type="indexterm" id="OEBPS/ch01.html.id326"></a>However, invoking a
function always results in the same code being executed; all that changes from invocation to invocation is the data that
the function operates on.  That covers a lot of possible scenarios, but what if the <em>code</em> needs to vary at runtime?</p>

<p>The simplest behavioral abstraction that allows this is the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.fn.html"><em>function pointer</em></a>: a pointer to (just) some code, with a type that reflects the
signature of the function:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">sum</code><code class="p">(</code><code class="n">x</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="c1">// Explicit coercion to `fn` type is required...</code>
<code class="kd">let</code><code class="w"> </code><code class="n">op</code>: <code class="nc">fn</code><code class="p">(</code><code class="kt">i32</code><code class="p">,</code><code class="w"> </code><code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="o">=</code><code class="w"> </code><code class="n">sum</code><code class="p">;</code><code class="w"></code></pre>

<p>The type is checked at compile time, so by the time the program runs, the value is just the size of a pointer.<a data-primary="fn (function pointer) types" data-type="indexterm" id="OEBPS/ch01.html.id327"></a>  Function
pointers have no other data associated with them, so they can be treated as values in various ways:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// `fn` types implement `Copy`</code>
<code class="kd">let</code><code class="w"> </code><code class="n">op1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">op</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">op2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">op</code><code class="p">;</code><code class="w"></code>
<code class="c1">// `fn` types implement `Eq`</code>
<code class="fm">assert!</code><code class="p">(</code><code class="n">op1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">op2</code><code class="p">);</code><code class="w"></code>
<code class="c1">// `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"op = {:p}"</code><code class="p">,</code><code class="w"> </code><code class="n">op</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Example output: "op = 0x101e9aeb0"</code></pre>

<p>One<a data-primary="type conversions" data-secondary="explicit coercion to fn type" data-type="indexterm" id="OEBPS/ch01.html.id328"></a> technical detail to watch out for: explicit coercion to a <code>fn</code> type is needed, because just using the name of a
function <em>doesn’t</em> give you something of <code>fn</code> type:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id329">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">op1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">sum</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">op2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">sum</code><code class="p">;</code><code class="w"></code>
<code class="c1">// Both op1 and op2 are of a type that cannot be named in user code,</code>
<code class="c1">// and this internal type does not implement `Eq`.</code>
<code class="fm">assert!</code><code class="p">(</code><code class="n">op1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">op2</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0369]: binary operation `==` cannot be applied to type
              `fn(i32, i32) -&gt; i32 {main::sum}`
   --&gt; src/main.rs:102:17
    |
102 |     assert!(op1 == op2);
    |             --- ^^ --- fn(i32, i32) -&gt; i32 {main::sum}
    |             |
    |             fn(i32, i32) -&gt; i32 {main::sum}
    |
help: use parentheses to call these
    |
102 |     assert!(op1(/* i32 */, /* i32 */) == op2(/* i32 */, /* i32 */));
    |                ++++++++++++++++++++++       ++++++++++++++++++++++</pre>

<p>Instead, the compiler error indicates that the type is something like <code>fn(i32, i32) -&gt; i32 {main::sum}</code>, a type that’s
entirely internal to the compiler (i.e., could not be written in user code) and that identifies the specific function
as well as its signature.<a data-primary="type coercion" data-type="indexterm" id="OEBPS/ch01.html.id330"></a>  To put it another way, the <em>type</em> of <code>sum</code> encodes both the function’s signature <em>and</em> its
location <a href="https://oreil.ly/HWXcL">for optimization reasons</a>; this
type can be automatically  <em>coerced</em> (<a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>) to a <code>fn</code> type.</p>
</div></section>








<section data-pdf-bookmark="Closures" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id15">
<h2>Closures</h2>

<p>The bare function pointers are limiting, because the only inputs available to the invoked function are those that are
explicitly passed as parameter values.<a data-primary="types" data-secondary="closures" data-type="indexterm" id="OEBPS/ch01.html.id331"></a><a data-primary="closures" data-type="indexterm" id="OEBPS/ch01.html.id332"></a> For example, consider some code that modifies every element of a slice using a function pointer:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// In real code, an `Iterator` method would be more appropriate.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">modify_all</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u32</code><code class="p">],</code><code class="w"> </code><code class="n">mutator</code>: <code class="nc">fn</code><code class="p">(</code><code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">mutator</code><code class="p">(</code><code class="o">*</code><code class="n">value</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This works for a simple mutation of the slice:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">add2</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">2</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"></code>
<code class="n">modify_all</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="n">add2</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">]);</code><code class="w"></code></pre>

<p>However, if the modification relies on any additional state, it’s not possible to implicitly pass that into the function
pointer:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id333">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">amount_to_add</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">3</code><code class="p">;</code><code class="w"></code>
<code class="k">fn</code> <code class="nf">add_n</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">amount_to_add</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">];</code><code class="w"></code>
<code class="n">modify_all</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="n">add_n</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">]);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0434]: can't capture dynamic environment in a fn item
   --&gt; src/main.rs:125:13
    |
125 |         v + amount_to_add
    |             ^^^^^^^^^^^^^
    |
    = help: use the `|| { ... }` closure form instead</pre>

<p>The error message points to the right tool for the job: a  <em>closure</em>. <a data-primary="lambda expressions" data-type="indexterm" id="OEBPS/ch01.html.id334"></a>A closure is a chunk of code that looks like
the body of a function definition (a <em>lambda expression</em>), except for the following:</p>

<ul>
<li>
<p>It can be built as part of an expression, and so it need not have a name associated with it.</p>
</li>
<li>
<p>The input parameters are given in vertical bars <code>|param1, param2|</code> (their associated types can usually be
automatically <a data-primary="associated types" data-type="indexterm" id="OEBPS/ch01.html.id335"></a>deduced by the compiler).</p>
</li>
<li>
<p>It can capture parts of the environment around it:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">amount_to_add</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">3</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">add_n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">|</code><code class="n">y</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// a closure capturing `amount_to_add`</code>
<code class="w">    </code><code class="n">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">amount_to_add</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">add_n</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">z</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">);</code><code class="w"></code></pre>
</li>
</ul>

<p>To (roughly) understand how the capture works, imagine that the compiler creates a one-off, internal type that
holds all of the parts of the environment that get mentioned in the lambda expression.  When the closure is created, an
instance of this ephemeral type is created to hold the relevant values, and when the closure is invoked, that
instance is used as additional context:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">amount_to_add</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">3</code><code class="p">;</code><code class="w"></code>
<code class="c1">// *Rough* equivalent to a capturing closure.</code>
<code class="k">struct</code> <code class="nc">InternalContext</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// references to captured variables</code>
<code class="w">    </code><code class="n">amount_to_add</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="k">impl</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">InternalContext</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">internal_op</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// body of the lambda expression</code>
<code class="w">        </code><code class="n">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">amount_to_add</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">add_n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">InternalContext</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">amount_to_add</code>: <code class="kp">&amp;</code><code class="nc">amount_to_add</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">z</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">add_n</code><code class="p">.</code><code class="n">internal_op</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">z</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">);</code><code class="w"></code></pre>

<p>The values that are held in this notional context are often references (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>) as here, but <a data-primary="references" data-secondary="mutable" data-type="indexterm" id="OEBPS/ch01.html.id336"></a><a data-primary="move keyword" data-type="indexterm" id="OEBPS/ch01.html.id337"></a>they can also be mutable
references to things in the environment, or values that are moved out of the environment altogether (by using the <code>move</code>
keyword before the input parameters).</p>

<p>Returning to the <code>modify_all</code> example, a closure can’t be used where a function pointer is expected:</p>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
   --&gt; src/main.rs:199:31
    |
199 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |         ----------            ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer,
    |         |                                           found closure
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected fn pointer `fn(u32) -&gt; u32`
                  found closure `[closure@src/main.rs:199:31: 199:34]`
note: closures can only be coerced to `fn` types if they do not capture any
      variables
   --&gt; src/main.rs:199:39
    |
199 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                                       ^^^^^^^^^^^^^ `amount_to_add`
    |                                                     captured here
note: function defined here
   --&gt; src/main.rs:60:12
    |
60  |     pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
    |            ^^^^^^^^^^                   -----------------------</pre>

<p>Instead, the code that receives the <a data-primary="traits" data-secondary="Fn, FnOnce, and FnMut" data-type="indexterm" id="OEBPS/ch01.html.id338"></a>closure has to accept an instance of one of the <code>Fn*</code> traits:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">modify_all</code><code class="o">&lt;</code><code class="n">F</code><code class="o">&gt;</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="p">[</code><code class="kt">u32</code><code class="p">],</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">mutator</code>: <code class="nc">F</code><code class="p">)</code><code class="w"></code>
<code class="k">where</code><code class="w"></code>
<code class="w">    </code><code class="n">F</code>: <code class="nb">FnMut</code><code class="p">(</code><code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">mutator</code><code class="p">(</code><code class="o">*</code><code class="n">value</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Rust has three different <code>Fn*</code> traits, which between them express some distinctions around this environment-capturing behavior:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></dt>
<dd>
<p>Describes a closure that can be called only
<em>once</em>.  <a data-primary="FnOnce trait" data-type="indexterm" id="OEBPS/ch01.html.id339"></a>If some part of the environment is <code>move</code>d into the closure’s context, and the closure’s body subsequently
moves it <em>out</em> of the closure’s context, then those moves can happen only once—there’s no other copy of the
source item to <code>move</code> from—and so the closure can be invoked only once.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></dt>
<dd>
<p>Describes a closure that can be called repeatedly
and that can make changes to its environment because it <em>mutably</em> borrows from the environment.<a data-primary="FnMut trait" data-type="indexterm" id="OEBPS/ch01.html.id340"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></dt>
<dd>
<p>Describes a closure that can be called repeatedly and
that only borrows values from the environment immutably.<a data-primary="Fn trait" data-type="indexterm" id="OEBPS/ch01.html.id341"></a></p>
</dd>
</dl>

<p>The compiler <em>automatically</em> implements <a data-primary="()" data-type="indexterm" id="OEBPS/ch01.html.id342"></a>the appropriate subset of these <code>Fn*</code> traits for any lambda
expression in the code; it’s not possible to manually implement any of these traits (unlike  C++’s <code>operator()</code> overload).<sup><a data-type="noteref" href="#OEBPS/ch01.html.id343" id="OEBPS/ch01.html.id343-marker">4</a></sup></p>

<p>Returning to the preceding rough mental model of closures, which of the traits the compiler auto-implements roughly<a data-primary="references" data-type="indexterm" id="OEBPS/ch01.html.id344"></a>
corresponds to whether the captured environmental context has these elements:</p>
<dl>
<dt><code>FnOnce</code></dt>
<dd>
<p>Any moved values</p>
</dd>
<dt><code>FnMut</code></dt>
<dd>
<p>Any mutable references to values (<code>&amp;mut T</code>)</p>
</dd>
<dt><code>Fn</code></dt>
<dd>
<p>Only normal references to values (<code>&amp;T</code>)</p>
</dd>
</dl>

<p>The latter two traits in this list each have a trait bound of the preceding trait, which makes sense when you consider
the things that <em>use</em> the closures:</p>

<ul>
<li>
<p>If something expects to call a closure only once (indicated by receiving a <code>FnOnce</code>), it’s OK to pass it a closure
that’s capable of being repeatedly called (<code>FnMut</code>).</p>
</li>
<li>
<p>If something expects to repeatedly call a closure that might mutate its environment (indicated by receiving a
<code>FnMut</code>), it’s OK to pass it a closure that <em>doesn’t</em> need to mutate its environment (<code>Fn</code>).</p>
</li>
</ul>

<p>The bare function pointer type <code>fn</code> also notionally belongs at the end of this list; any (not-<code>unsafe</code>) <code>fn</code> type
automatically implements all of the <code>Fn*</code> traits, because it borrows nothing from the environment.<a data-primary="fn (function pointer) types" data-type="indexterm" id="OEBPS/ch01.html.id345"></a></p>

<p>As a result, when writing code that accepts closures, <em>use the most general <code>Fn*</code> trait that works</em>, to allow the
greatest flexibility for callers—for example, accept <code>FnOnce</code> for closures that are used only once. The same
reasoning also leads to advice to <em>prefer <code>Fn*</code> trait bounds over bare function pointers (<code>fn</code>)</em>.</p>
</div></section>








<section data-pdf-bookmark="Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id16">
<h2>Traits</h2>

<p>The <code>Fn*</code> traits are more flexible than bare function pointers, but they can still describe only the behavior of a
single function, and even then only in terms of the function’s signature.<a data-primary="traits" data-secondary="defined" data-type="indexterm" id="OEBPS/ch01.html.id346"></a><a data-primary="types" data-secondary="traits" data-seealso="trait bounds; trait objects; traits" data-type="indexterm" id="OEBPS/ch01.html.id347"></a></p>

<p>However, they are themselves examples of another mechanism for describing behavior in Rust’s type system, the
 <em>trait</em>. <a data-primary="functions" data-secondary="related, defined by a trait" data-type="indexterm" id="OEBPS/ch01.html.id348"></a>A trait defines a set of related functions that some underlying item makes publicly available; moreover,
the functions are typically (but don’t have to be)  <em>methods</em>, taking some variant of <code>self</code> as their first
argument.<a data-primary="self keyword" data-type="indexterm" id="OEBPS/ch01.html.id349"></a><a data-primary="methods" data-secondary="functions in traits" data-type="indexterm" id="OEBPS/ch01.html.id350"></a></p>

<p>Each function in a trait also has a <em>name</em>, providing a label that allows the compiler to
disambiguate functions with the same signature, and more importantly, that allows programmers to deduce the intent of the
function.</p>

<p>A Rust trait is roughly analogous to an “interface” in Go and Java, or to an “abstract class” (all virtual methods, no data members) in C++.  Implementations of the trait must provide all the functions (but
note that the trait definition can include a default implementation; <a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>) and can also have associated data that
those implementations make use of.  This means that code and data gets encapsulated together in a common abstraction, in
a <em>somewhat</em> object-oriented (OO) manner.</p>

<p>Code that accepts a <code>struct</code> and calls functions on it is constrained to only ever work with that specific type.<a data-primary="struct types" data-secondary="traits versus, for flexible code" data-type="indexterm" id="OEBPS/ch01.html.id351"></a>  If there
are multiple types that implement common behavior, then it is more flexible to define a trait that encapsulates that
common behavior, and have the code make use of the trait’s functions rather than functions involving a specific <code>struct</code>.</p>

<p>This leads to the same kind of advice that turns up for other OO-influenced languages:<sup><a data-type="noteref" href="#OEBPS/ch01.html.id352" id="OEBPS/ch01.html.id352-marker">5</a></sup> <em>prefer accepting trait types over
concrete types</em> if future flexibility is 
<span class="keep-together">anticipated</span>.</p>

<p>Sometimes, there is some behavior that you want to distinguish in the type system, but it cannot be expressed as
some specific function signature in a trait definition. For example, consider a <code>Sort</code> trait for sorting
collections; an implementation might be <em>stable</em> (elements that compare the same will appear in the same order before
and after the sort), but there’s no way to express this in the <code>sort</code> method arguments.<a data-primary="sorting, using marker trait in" data-type="indexterm" id="OEBPS/ch01.html.id353"></a><a data-primary="marker traits" data-type="indexterm" id="OEBPS/ch01.html.id354"></a><a data-primary="traits" data-secondary="marker" data-type="indexterm" id="OEBPS/ch01.html.id355"></a></p>

<p>In this case, it’s still worth using the type system to track this requirement, using a <em>marker trait</em>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">Sort</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Rearrange contents into sorted order.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">sort</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Marker trait to indicate that a [`Sort`] sorts stably.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">StableSort</code>: <code class="nc">Sort</code><code class="w"> </code><code class="p">{}</code><code class="w"></code></pre>

<p>A marker trait has no functions, but an implementation still has to declare that it is implementing the
trait—which acts as a promise from the implementer: “I solemnly swear that my implementation sorts stably.”  Code
that relies on a stable sort can then specify the <code>StableSort</code> trait bound, relying on the honor system to preserve its
invariants. <em>Use marker traits to distinguish behaviors that cannot be expressed in the trait function
signatures</em>.</p>

<p>Once behavior has been encapsulated into Rust’s type system as a trait, it can be used in two ways:</p>

<ul>
<li>
<p>As a <em>trait bound</em>, which constrains what types are acceptable for a  generic data type or function at
compile time<a data-primary="trait bounds" data-type="indexterm" id="OEBPS/ch01.html.id356"></a></p>
</li>
<li>
<p>As a  <em>trait object</em>, which constrains what types can be stored or passed to a function at runtime<a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch01.html.id357"></a></p>
</li>
</ul>

<p>The following sections describe these two possibilities, and <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a> gives more detail about the trade-offs between them.</p>










<section data-pdf-bookmark="Trait bounds" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id17">
<h3>Trait bounds</h3>

<p>A  <em>trait bound</em> indicates that generic code that is parameterized by some type <code>T</code> can be used only when that
type <code>T</code> implements some specific trait.<a data-primary="types" data-secondary="traits" data-tertiary="trait bounds" data-type="indexterm" id="OEBPS/ch01.html.id358"></a> The presence of the  trait bound means that the implementation of the
generic can use the functions from that trait, secure in the knowledge that the compiler will ensure that any <code>T</code> that
compiles does indeed have those functions.<a data-primary="monomorphization (generics)" data-type="indexterm" id="OEBPS/ch01.html.id359"></a><a data-primary="T (target type) in generics, monomorphization into particular type" data-type="indexterm" id="OEBPS/ch01.html.id360"></a>  This check happens at compile time, when the generic is
 <em>monomorphized</em>—converted from the generic code that deals with an arbitrary type <code>T</code> into
specific code that deals with one particular <code>SomeType</code> (what C++ would call <em>template
instantiation</em>).<a data-primary="explicit constraints on target type" data-type="indexterm" id="OEBPS/ch01.html.id361"></a></p>

<p>This restriction on the target type <code>T</code> is <em>explicit</em>, encoded in the trait bounds: the trait can be implemented only by
types that satisfy the trait bounds.<a data-primary="C++" data-secondary="explicit constraints on template types" data-type="indexterm" id="OEBPS/ch01.html.id362"></a> This contrasts with the equivalent situation in C++, where the constraints on
the type <code>T</code> used in a 
<span class="keep-together"><code>template&lt;typename T&gt;</code></span> are <em>implicit</em>:<sup><a data-type="noteref" href="#OEBPS/ch01.html.id363" id="OEBPS/ch01.html.id363-marker">6</a></sup> C++ template code still compiles only if all of the referenced functions are available at compile time, but
the checks are purely based on function name and signature.  (This <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Duck_typing">“duck typing”</a> can lead to confusion; a C++ template that uses <code>t.pop()</code>
might compile for a <code>T</code> type parameter of either <code>Stack</code> or 
<span class="keep-together"><code>Balloon</code></span>—which is unlikely to be desired
behavior.)</p>

<p>The need for explicit trait bounds also means that a large fraction of  generics use trait bounds.<a data-primary="trait bounds" data-secondary="use with generics" data-type="indexterm" id="OEBPS/ch01.html.id364"></a><a data-primary="generics" data-secondary="trait bounds" data-type="indexterm" id="OEBPS/ch01.html.id365"></a>  To see why this
is, turn the observation around and consider what can be done with a <code>struct Thing&lt;T&gt;</code> where there are <em>no</em> trait bounds
on <code>T</code>. Without a trait bound, the <code>Thing</code> can perform only operations that apply to <em>any</em> type <code>T</code>—basically just
moving or dropping the value.  This in turn allows for generic containers, collections, and smart pointers, but not much
else.  Anything that <em>uses</em> the type <code>T</code> is going to need a trait bound:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">dump_sorted</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="n">collection</code>: <code class="nc">T</code><code class="p">)</code><code class="w"></code>
<code class="k">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="nc">Sort</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">IntoIterator</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>::<code class="n">Item</code>: <code class="nc">std</code>::<code class="n">fmt</code>::<code class="n">Debug</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Next line requires `T: Sort` trait bound.</code>
<code class="w">    </code><code class="n">collection</code><code class="p">.</code><code class="n">sort</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Next line requires `T: IntoIterator` trait bound.</code>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Next line requires `T::Item : Debug` trait bound</code>
<code class="w">        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"{:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>So the advice here is to <em>use trait bounds to express requirements on the types used in generics</em>, but it’s
easy advice to follow—the compiler will force you to comply with it regardless.</p>
</div></section>










<section data-pdf-bookmark="Trait objects" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id18">
<h3>Trait objects</h3>

<p>A  <em>trait object</em> is the other way to make use of the encapsulation defined by a trait, but here, different
possible implementations of the trait are chosen at runtime rather than compile time.<a data-primary="types" data-secondary="traits" data-tertiary="trait objects" data-type="indexterm" id="OEBPS/ch01.html.id366"></a><a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch01.html.id367"></a>  This <em>dynamic dispatch</em> is
analogous to using virtual functions in C++, and under the covers, Rust has “vtable” objects that are
<em>roughly</em> analogous to those in C++.<a data-primary="C++" data-secondary="virtual functions" data-type="indexterm" id="OEBPS/ch01.html.id368"></a></p>

<p>This dynamic aspect of trait objects also means that they always have to be handled indirectly, via a  reference
(e.g., <code>&amp;dyn Trait</code>) or a pointer (e.g., <code>Box&lt;dyn Trait&gt;</code>) of some kind.  The reason is that the size of the object
implementing the trait isn’t known at compile time—it could be a giant <code>struct</code> or a tiny <code>enum</code>—so
there’s no way to allocate the right amount of space for a bare trait object.</p>

<p>Not knowing the size of the concrete object also means that traits used as trait <a data-primary="Self type" data-type="indexterm" id="OEBPS/ch01.html.id369"></a>objects cannot have functions that return the  <code>Self</code> type or
arguments (other than the  <em>receiver</em>⁠—​the object on which the method is being invoked) that use <code>Self</code>.  The reason is that the compiled-in-advance code that uses the trait object would have no idea how big that <code>Self</code> might be.</p>

<p>A trait that has a  generic function <code>fn some_fn&lt;T&gt;(t:T)</code> allows for the possibility of an infinite number of
implemented <a data-primary="generics" data-secondary="trait having generic function" data-type="indexterm" id="OEBPS/ch01.html.id370"></a>functions, for all of the different types <code>T</code> that might exist.  This is fine for a trait used as a trait
bound, because the infinite set of <em>possibly</em> invoked generic functions becomes a finite set of <em>actually</em> invoked
generic functions at compile time.  The same is not true for a trait object: the code available at compile time has to
cope with all possible <code>T</code>s that might arrive at runtime.</p>

<p>These two restrictions—no use of <code>Self</code> and no generic functions—are combined in the concept of
 <em><a href="https://oreil.ly/gaq4l">object safety</a></em>.  Only object-safe traits
can be used as trait objects.<a data-primary="object safety" data-type="indexterm" id="OEBPS/ch01.html.id371"></a></p>
</div></section>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 3: Prefer Option and Result transforms 
over explicit match expressions" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_transform_md">
<h1>Item 3: Prefer <code>Option</code> and <code>Result</code> transforms 
<span class="keep-together">over explicit <code>match</code> expressions</span></h1>

<p><a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> expounded the virtues of <code>enum</code> and showed how <code>match</code> expressions force the programmer to take all
possibilities into account. <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> also introduced the two ubiquitous <code>enum</code>s that the Rust standard library<a data-primary="types" data-secondary="preferring Option and Result transforms over explicit match expressions" data-type="indexterm" id="OEBPS/ch01.html.ix_typOptRes"></a> <a data-primary="types" data-secondary="preferring Option and Result transforms over explicit match expressions" data-type="indexterm" id="OEBPS/ch01.html.id372"></a><a data-primary="Option type" data-secondary="preferring Option and Result transforms over explicit match expressions" data-type="indexterm" id="OEBPS/ch01.html.ix_Opttrns"></a>provides:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a></dt>
<dd>
<p>To express that a value (of type
<code>T</code>) may or may not be present</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a></dt>
<dd>
<p>For when an operation to
return a  value (of type <code>T</code>) may not succeed and may instead return an  error (of type <code>E</code>)</p>
</dd>
</dl>

<p>This Item explores<a data-primary="match expressions" data-secondary="explicit, preferring Option and Result transforms over" data-type="indexterm" id="OEBPS/ch01.html.ix_mtch"></a> situations where you should try to avoid explicit <code>match</code> expressions for these particular <code>enum</code>s,
preferring instead to use various transformation methods that the standard library provides for these types. Using these
transformation methods (which are typically themselves implemented as <code>match</code> expressions under the covers) leads to
code that is more compact and idiomatic and has clearer intent.</p>

<p>The first situation where a <code>match</code> is unnecessary is when only the value is relevant and the absence of value (and any
associated error) can just be ignored:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">S</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">field</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">S</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">field</code>: <code class="nb">Some</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="k">match</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s</code><code class="p">.</code><code class="n">field</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">println!</code><code class="p">(</code><code class="s">"field is {i}"</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>For this situation, an  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>
expression is one line shorter and, more importantly, clearer:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s</code><code class="p">.</code><code class="n">field</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"field is {i}"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, most of the time the programmer needs to provide the corresponding <code>else</code> arm: the absence of a value
(<code>Option::None</code>), possibly with an associated error (<code>Result::Err(e)</code>), is something that the programmer needs to deal
with. Designing software to cope with failure paths is hard, and most of that is essential complexity that no amount of
syntactic support can help with—specifically, deciding what should happen if an operation fails.<a data-primary="Option::None variant" data-type="indexterm" id="OEBPS/ch01.html.id373"></a><a data-primary="None variant of Option" data-type="indexterm" id="OEBPS/ch01.html.id374"></a><a data-primary="Result::Err variant" data-type="indexterm" id="OEBPS/ch01.html.id375"></a><a data-primary="errors" data-type="indexterm" id="OEBPS/ch01.html.id376"></a><a data-primary="failures" data-secondary="designing software to cope with" data-type="indexterm" id="OEBPS/ch01.html.id377"></a></p>

<p>In some situations, the right decision is to perform an  ostrich maneuver—put our heads in the sand and
explicitly not cope with failure. You can’t <em>completely</em> ignore the error arm, because Rust requires that the code deal
with both variants of the <code>Error</code> <code>enum</code>, but you can choose to treat a failure as fatal.<a data-primary="panics" data-secondary="on failure" data-secondary-sortas="failure" data-type="indexterm" id="OEBPS/ch01.html.id378"></a> Performing a  <code>panic!</code> on
failure means that the program terminates, but the rest of the code can then be written with the assumption of success.<a data-primary="Error trait" data-type="indexterm" id="OEBPS/ch01.html.id379"></a><a data-primary="Err variant of Result" data-type="indexterm" id="OEBPS/ch01.html.id380"></a>
Doing <a data-primary="match expressions" data-type="indexterm" id="OEBPS/ch01.html.id381"></a>this with an explicit <code>match</code> would be needlessly 
<span class="keep-together">verbose</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="nb">Err</code><code class="p">(</code><code class="n">_e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">panic!</code><code class="p">(</code><code class="s">"Failed to open /etc/passwd!"</code><code class="p">),</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="c1">// Assume `f` is a valid `std::fs::File` from here onward.</code></pre>

<p>Both <code>Option</code> and <code>Result</code> provide a pair of methods that extract their inner value and <code>panic!</code> if it’s absent:
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a>.  <a data-primary="expect method" data-type="indexterm" id="OEBPS/ch01.html.id382"></a><a data-primary="unwrap method" data-type="indexterm" id="OEBPS/ch01.html.id383"></a>The latter allows the error
message on failure to be personalized, but in either case, the resulting code is shorter and simpler—error
handling is delegated to the <code>.unwrap()</code> suffix (but is still present):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code></pre>

<p>Be clear, though: these helper functions still  <code>panic!</code>, so choosing to use them is the same as choosing to <code>panic!</code>
(<a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>).</p>

<p>However, in many situations, the right decision for error handling is to defer the decision to somebody else.  This is
particularly true when writing a library, where the code may be used in all sorts of different environments that can’t
be foreseen by the library author.  To make that somebody else’s job easier, <em>prefer <code>Result</code> to <code>Option</code></em> for
expressing errors, even though this may involve conversions between different error types (<a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>).<a data-primary="Result type" data-secondary="preferring to Option for expressing errors" data-type="indexterm" id="OEBPS/ch01.html.id384"></a><a data-primary="errors" data-secondary="preferring Result to Option for expressing errors" data-type="indexterm" id="OEBPS/ch01.html.id385"></a></p>

<p>Of course, this opens up the question, What counts as an error?  In this example, failing to open a file is definitely
an error, and the details of that error (no such file? permission denied?) can help the user decide what to do next.  On
the other hand, failing to retrieve the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>first()</code></a>
element of a slice because that slice is empty isn’t really an error, and so it is expressed as an <code>Option</code> return type in
the standard library.  Choosing between the two possibilities requires judgment, but lean toward <code>Result</code> if
an error might communicate anything useful.</p>

<p><code>Result</code> also has a <code>#[must_use]</code>
<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute">attribute</a> to nudge library
users in the right <span class="keep-together">direction—</span>if the code using the returned <code>Result</code> ignores it, the compiler will generate a
warning:</p>

<pre data-code-language="text" data-type="programlisting">warning: unused `Result` that must be used
  --&gt; src/main.rs:63:5
   |
63 |     f.set_len(0); // Truncate the file
   |     ^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
63 |     let _ = f.set_len(0); // Truncate the file
   |     +++++++</pre>

<p>Explicitly using a <code>match</code> allows an error to propagate, but <a data-primary="errors" data-secondary="propagation with use of explicit match expression" data-type="indexterm" id="OEBPS/ch01.html.id386"></a>at the cost of some visible boilerplate (reminiscent of
 <a class="orm:hideurl" href="https://blog.golang.org/errors-are-values">Go</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="nb">From</code>::<code class="n">from</code><code class="p">(</code><code class="n">e</code><code class="p">)),</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The key ingredient for reducing boilerplate is Rust’s  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark operator, <code>?</code></a>.  <a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id387"></a>This piece of
 syntactic sugar takes care of matching the <code>Err</code> arm, transforming the error type if necessary, and building the <code>return Err(...)</code> expression, all in a single 
<span class="keep-together">character</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Newcomers to Rust sometimes find this disconcerting: the question mark can be hard to spot on first glance, leading to
disquiet as to how the code can possibly work. However, even with a single character, the  type system is still at
work, ensuring that all of the possibilities expressed in the relevant types (<a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>) are covered—leaving the
programmer to focus on the mainline code path without distractions.</p>
<p>
What’s more, there’s generally no cost to these apparent method invocations: they are all  generic functions marked
as <a class="orm:hideurl" href="https://oreil.ly/FoRaC"><code>#[inline]</code></a>, so
the generated code will typically compile to machine code that’s identical to the manual version.
</p>

<p>These two factors<a data-primary="inline functions" data-type="indexterm" id="OEBPS/ch01.html.id388"></a> taken together mean that you should <em>prefer <code>Option</code> and <code>Result</code> transforms over explicit <code>match</code>
expressions</em>.</p>

<p>In the previous example, the error types lined up: both the inner and outer methods expressed errors as
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>. That’s often not the case: one function may
accumulate errors from a variety of different sublibraries, each of which uses different error types.</p>

<p>Error mapping in general is discussed in <a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>, but for now, just be aware that a<a data-primary="errors" data-secondary="mapping" data-type="indexterm" id="OEBPS/ch01.html.id389"></a> manual mapping:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to open password file: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">))</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>could be more succinctly and idiomatically expressed with the following
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>.map_err()</code></a> 
<span class="keep-together">transformation</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">e</code><code class="o">|</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to open password file: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Better<a data-primary="From trait" data-type="indexterm" id="OEBPS/ch01.html.id390"></a> still, even this may not be necessary—if the outer error type can be created from the inner error type
via an implementation of the  <code>From</code> standard trait (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>), then the compiler will automatically perform the
conversion without the need for a call to <code>.map_err()</code>.</p>

<p>These kinds of transformations generalize more widely. The question mark operator is a big hammer; use transformation
methods on <code>Option</code> and <code>Result</code> types to maneuver them into a position where they can be a nail.</p>

<p>The <a data-primary="transformations" data-secondary="Option and Result, methods for" data-type="indexterm" id="OEBPS/ch01.html.id391"></a>standard library provides a wide variety of these transformation methods to make this possible. <a data-type="xref" href="#OEBPS/ch01.html.fig_1_1">Figure&nbsp;1-1</a>
shows some of the most common methods (light rectangles) that transform between the relevant types (dark
rectangles).  In line with <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>, methods that can  <code>panic!</code> are marked with an asterisk.</p>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_1">
<img alt="The diagram shows mappings between Result, Option and related types.  Gray boxes show types, and white rounded boxes show methods that transform between types.  Methods that can panic are marked with an asterisk. In the middle are the Result<T, E> and Option<T> types, with methods ok, ok_or and ok_or_else that convert between them. To one side of Result<T, E> are the or and or_else methods that transform back to the same type. To one side of Option<T> are various methods that transform back to the same type: filter, xor, or, or_else and replace. Across the top and bottom of the diagram are various related types that can covert to or from Result and Option. For Result<T, E>, the map method reaches Result<T, F>, the map, and and and_then methods reach Result<U, E>, and the map_or and map_or_else methods reach U, with all of the destinations at the bottom of the diagram. At the top of the diagram, Result<T, E> maps to Option<E> via err, to E via unwrap_err and expect_err (both of which can panic), and to T via a collection of methods: unwrap, expect, unwrap_or, unwrap_or_else, unwrap_or_default (where unwrap and expect might panic).  The E and T types map back to Result<T, E> via the Err(e) and Ok(t) enum variants.  For Option<T>, the map, and and and_then methods reach Option<U>, and the map_or and map_or_else methods reach U at the bottom of the diagram. At the top of the diagram, Option<T> maps to T via the same collection of methods as for Result: unwrap, expect, unwrap_or, unwrap_or_else, unwrap_or_default (where unwrap and expect might panic).  The T type maps back to Option<T> via the Some(t) enum; the () type also maps to Option<T> via None." src="data:image/png;base64,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">
<h6><span class="label">Figure 1-1. </span><code>Option</code> and <code>Result</code> transformations<sup><a data-type="noteref" href="#OEBPS/ch01.html.id392" id="OEBPS/ch01.html.id392-marker">7</a></sup></h6>
</div></figure>

<p>One common situation the diagram doesn’t cover deals with references.<a data-primary="references" data-type="indexterm" id="OEBPS/ch01.html.id393"></a> For example, consider a structure
that optionally holds some data:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">InputData</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">payload</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>A method on this <code>struct</code> that tries to pass the payload to an encryption function with signature <code>(&amp;[u8]) -&gt; Vec&lt;u8&gt;</code>
fails if there’s a naive attempt to take a reference:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id394">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">InputData</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">encrypted</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">encrypt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">payload</code><code class="p">.</code><code class="n">unwrap_or</code><code class="p">(</code><code class="fm">vec!</code><code class="p">[]))</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0507]: cannot move out of `self.payload` which is behind a shared
              reference
  --&gt; src/main.rs:15:18
   |
15 |     encrypt(&amp;self.payload.unwrap_or(vec![]))
   |              ^^^^^^^^^^^^ move occurs because `self.payload` has type
   |                           `Option&lt;Vec&lt;u8&gt;&gt;`, which does not implement the
   |                           `Copy` trait</pre>

<p>The right tool for this is the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref"><code>as_ref()</code></a>
method on <code>Option</code>.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id395" id="OEBPS/ch01.html.id395-marker">8</a></sup> This method converts a reference-to-an-<code>Option</code> into an <code>Option</code>-of-a-reference:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">encrypted</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">encrypt</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">payload</code><code class="p">.</code><code class="n">as_ref</code><code class="p">().</code><code class="n">unwrap_or</code><code class="p">(</code><code class="o">&amp;</code><code class="fm">vec!</code><code class="p">[]))</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id170">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Get used to the transformations of <code>Option</code> and <code>Result</code>, and prefer <code>Result</code> to <code>Option</code>.  Use <code>.as_ref()</code> as needed when transformations involve references.</p>
</li>
<li>
<p>Use these transformations in preference to explicit <code>match</code> operations on <code>Option</code> and <code>Result</code>.</p>
</li>
<li>
<p>In particular, use these transformations to convert result types into a form where the <code>?</code> operator applies.<a data-primary="? (question mark) operator" data-secondary="converting result types to form where ? applies" data-type="indexterm" id="OEBPS/ch01.html.id396"></a><a data-primary="match expressions" data-secondary="explicit, preferring Option and Result transforms over" data-startref="ix_mtch" data-type="indexterm" id="OEBPS/ch01.html.id397"></a><a data-primary="Option type" data-secondary="preferring Option and Result transforms over explicit match expressions" data-startref="ix_Opttrns" data-type="indexterm" id="OEBPS/ch01.html.id398"></a><a data-primary="types" data-secondary="preferring Option and Result transforms over explicit match expressions" data-startref="ix_typOptRes" data-type="indexterm" id="OEBPS/ch01.html.id399"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 4: Prefer idiomatic Error types" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_errors_md">
<h1>Item 4: Prefer idiomatic <code>Error</code> types</h1>

<p><a href="#OEBPS/ch01.html.file_transform_md">Item 3</a> described how to use the transformations that the standard library provides for the  <code>Option</code> and
 <code>Result</code> types to allow concise, idiomatic handling of result types using the  <code>?</code> operator.  <a data-primary="types" data-secondary="idiomatic Error types, preferring" data-type="indexterm" id="OEBPS/ch01.html.ix_typiderr"></a><a data-primary="errors" data-secondary="preferring idiomatic Error types" data-type="indexterm" id="OEBPS/ch01.html.ix_erridtyp"></a>It stopped
short of discussing how best to handle the variety of different error types <code>E</code> that arise as the second type argument
of a <code>Result&lt;T, E&gt;</code>; that’s the subject of this Item.<a data-primary="Result type" data-secondary="error types as second type argument of" data-type="indexterm" id="OEBPS/ch01.html.id400"></a></p>

<p>This is relevant only when there <em>are</em> a variety of different error types in play.  If all of the different
errors that a function encounters are already of the same type, it can just return that type.  When there are errors of
different types, there’s a decision to make about whether the suberror type information should be preserved.</p>








<section data-pdf-bookmark="The Error Trait" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id20">
<h2>The <code>Error</code> Trait</h2>

<p>It’s always good to understand what the standard traits (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>) involve, and the relevant trait here is
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>.  <a data-primary="Error trait" data-type="indexterm" id="OEBPS/ch01.html.id401"></a>The <code>E</code> type parameter for a
<code>Result</code> doesn’t <em>have</em> to be a type that implements <code>Error</code>, but it’s a common convention that allows wrappers to
express appropriate trait bounds—so <em>prefer to implement <code>Error</code> for your error types</em>.</p>

<p>The first thing to notice is that the only hard requirement for <code>Error</code> types is the  <a data-primary="trait bounds" data-secondary="for Error types" data-secondary-sortas="Error" data-type="indexterm" id="OEBPS/ch01.html.id402"></a>trait bounds: any type that
implements <code>Error</code> also has to implement the following traits:</p>

<ul>
<li>
<p>The  <code>Display</code> trait, meaning that it can be <code>format!</code>ed with <code>{}</code></p>
</li>
<li>
<p>The  <code>Debug</code> trait, meaning that it can be <code>format!</code>ed with <code>{:?}</code></p>
</li>
</ul>

<p>In other words, it should be possible to display <code>Error</code> types to both the user and the programmer.<a data-primary="Display trait" data-type="indexterm" id="OEBPS/ch01.html.id403"></a><a data-primary="Debug trait" data-type="indexterm" id="OEBPS/ch01.html.id404"></a></p>

<p>The only method in the trait is
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source()</code></a>,<sup><a data-type="noteref" href="#OEBPS/ch01.html.id405" id="OEBPS/ch01.html.id405-marker">9</a></sup> which allows an <code>Error</code> type to expose
an inner, nested error.  This method is optional—it comes with a  default implementation (<a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>)
returning <code>None</code>, indicating that inner error information isn’t available.</p>

<p>One final thing to note: if you’re <a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch01.html.id406"></a>writing code for a  <code>no_std</code> environment (<a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a>), it may not be possible to
implement <code>Error</code>—the <code>Error</code> trait is currently<a data-primary="std library" data-type="indexterm" id="OEBPS/ch01.html.id407"></a><a data-primary="core library" data-type="indexterm" id="OEBPS/ch01.html.id408"></a> implemented in
<code>std</code>, not  <code>core</code>, and so is not available.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id409" id="OEBPS/ch01.html.id409-marker">10</a></sup></p>
</div></section>








<section data-pdf-bookmark="Minimal Errors" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id21">
<h2>Minimal Errors</h2>

<p>If nested error information isn’t needed, then an implementation of the <code>Error</code> type need not be much more than a
<code>String</code>—one rare occasion where a “stringly typed” variable might be appropriate.  <a data-primary="errors" data-secondary="preferring idiomatic Error types" data-tertiary="minimal implementations" data-type="indexterm" id="OEBPS/ch01.html.id410"></a><a data-primary="String type" data-type="indexterm" id="OEBPS/ch01.html.id411"></a>It does need to be a
<em>little</em> more than a <code>String</code> though; while it’s possible to use <code>String</code> as the <code>E</code> type parameter:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">e</code><code class="o">|</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to open password file: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>a <code>String</code> doesn’t implement <code>Error</code>, which we’d prefer so that other areas of code can deal with <code>Error</code>s.  It’s not
possible to <code>impl Error</code> for <code>String</code>, because<a data-primary="orphan rule" data-type="indexterm" id="OEBPS/ch01.html.id412"></a> neither the trait nor the type belong to us (the so-called  <em>orphan
rule</em>):</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id413">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">error</code>::<code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="nb">String</code><code class="w"> </code><code class="p">{}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:18:5
   |
18 |     impl std::error::Error for String {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead</pre>

<p>A  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/items/type-aliases.html"><em>type alias</em></a> doesn’t help either,
because it doesn’t create a new type and so doesn’t <a data-primary="type aliases" data-type="indexterm" id="OEBPS/ch01.html.id414"></a>change the error message:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id415">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">MyError</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code><code class="p">;</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">error</code>::<code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:41:5
   |
41 |     impl std::error::Error for MyError {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^-------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead</pre>

<p class="pagebreak-before less_space">As usual, the compiler error message gives a hint to solving the problem.  Defining a tuple struct that <a data-primary="tuple struct" data-type="indexterm" id="OEBPS/ch01.html.id416"></a>wraps the
<code>String</code> type (the  “newtype pattern,” <a href="#OEBPS/ch01.html.file_newtype_md">Item 6</a>) allows the <code>Error</code> trait to be implemented,
provided that <code>Debug</code> and <code>Display</code> are implemented too:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">MyError</code><code class="p">(</code><code class="nb">String</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">std</code>::<code class="n">fmt</code>::<code class="nb">Result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">error</code>::<code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="n">MyError</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">).</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">e</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">MyError</code><code class="p">(</code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to open password file: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">))</code><code class="w"></code>
<code class="w">    </code><code class="p">})</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>For <a data-primary="From trait" data-type="indexterm" id="OEBPS/ch01.html.id417"></a>convenience, it may make sense to implement the  <code>From&lt;String&gt;</code> trait to allow string values to be
easily converted into <code>MyError</code> instances (<a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">msg</code>: <code class="nb">String</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>When it encounters the  question mark operator (<code>?</code>), the compiler will automatically apply any relevant
 <code>From</code> trait implementations that are needed to reach the destination error return type.<a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id418"></a>  This allows further
minimization:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_user</code><code class="p">(</code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="n">UserId</code><code class="p">,</code><code class="w"> </code><code class="n">MyError</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">e</code><code class="o">|</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to open password file: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The error path here covers the following steps:</p>

<ul>
<li>
<p><code>File::open</code> returns an error of type <a class="orm:hideurl" href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>.</p>
</li>
<li>
<p><code>format!</code> converts this to a <code>String</code>, using the <code>Debug</code> implementation of <code>std::io::Error</code>.</p>
</li>
<li>
<p><code>?</code> makes the compiler look for and use a <code>From</code> implementation that can take it from <code>String</code> to <code>MyError</code>.</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Nested Errors" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id22">
<h2>Nested Errors</h2>

<p>The alternative scenario is where the content of nested errors is important enough that it should be preserved and made
available to the caller.<a data-primary="nested errors" data-type="indexterm" id="OEBPS/ch01.html.id419"></a><a data-primary="errors" data-secondary="preferring idiomatic Error types" data-tertiary="nested errors" data-type="indexterm" id="OEBPS/ch01.html.id420"></a></p>

<p>Consider a library function that attempts to return the first line of a file as a string, as long as the line is not too
long.<a data-primary="strings" data-secondary="library function returning first line of file as string" data-type="indexterm" id="OEBPS/ch01.html.id421"></a> A moment’s thought reveals (at least) three distinct types of failure that could occur:</p>

<ul>
<li>
<p>The file might not exist or might be inaccessible for reading.</p>
</li>
<li>
<p>The file might contain <a data-primary="UTF-8" data-type="indexterm" id="OEBPS/ch01.html.id422"></a>data that isn’t valid  UTF-8 and so can’t be converted into a <code>String</code>.</p>
</li>
<li>
<p>The file might have a first line that is too long.</p>
</li>
</ul>

<p>In line with <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>, you can use the <a data-primary="enums" data-secondary="nested error types in" data-type="indexterm" id="OEBPS/ch01.html.id423"></a>type system to express and encompass all of these possibilities as an
 <code>enum</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Io</code><code class="p">(</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">Utf8</code><code class="p">(</code><code class="n">std</code>::<code class="n">string</code>::<code class="n">FromUtf8Error</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">General</code><code class="p">(</code><code class="nb">String</code><code class="p">),</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This <code>enum</code> definition includes a  <code>derive(Debug)</code>, but to satisfy the <code>Error</code> trait, a 
<span class="keep-together"><code>Display</code></span>
implementation<a data-primary="Debug trait" data-type="indexterm" id="OEBPS/ch01.html.id424"></a><a data-primary="Display trait" data-type="indexterm" id="OEBPS/ch01.html.id425"></a> is also needed:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">std</code>::<code class="n">fmt</code>::<code class="nb">Result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">Io</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"IO error: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">Utf8</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"UTF-8 error: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">General</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"General error: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>It also makes sense to override the default <code>source()</code> implementation for easy access to nested errors:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">error</code>::<code class="n">Error</code><code class="p">;</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">source</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="p">(</code><code class="k">dyn</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="o">'</code><code class="nb">static</code><code class="p">)</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">Io</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">e</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">Utf8</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">e</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="n">MyError</code>::<code class="n">General</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The use of an <code>enum</code> allows the error handling to be concise while still preserving all of the type information across
different classes of error:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">BufRead</code><code class="p">;</code><code class="w"> </code><code class="c1">// for `.read_until()`</code>

<code class="sd">/// Maximum supported line length.</code>
<code class="k">const</code><code class="w"> </code><code class="n">MAX_LEN</code>: <code class="kt">usize</code> <code class="o">=</code><code class="w"> </code><code class="mi">1024</code><code class="p">;</code><code class="w"></code>

<code class="sd">/// Return the first line of the given file.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">first_line</code><code class="p">(</code><code class="n">filename</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">MyError</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="n">filename</code><code class="p">).</code><code class="n">map_err</code><code class="p">(</code><code class="n">MyError</code>::<code class="n">Io</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">reader</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">BufReader</code>::<code class="n">new</code><code class="p">(</code><code class="n">file</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="c1">// (A real implementation could just use `reader.read_line()`)</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">buf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[];</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">reader</code><code class="p">.</code><code class="n">read_until</code><code class="p">(</code><code class="sc">b'\n'</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">buf</code><code class="p">).</code><code class="n">map_err</code><code class="p">(</code><code class="n">MyError</code>::<code class="n">Io</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from_utf8</code><code class="p">(</code><code class="n">buf</code><code class="p">).</code><code class="n">map_err</code><code class="p">(</code><code class="n">MyError</code>::<code class="n">Utf8</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">result</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">MAX_LEN</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">MyError</code>::<code class="n">General</code><code class="p">(</code><code class="fm">format!</code><code class="p">(</code><code class="s">"Line too long: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">len</code><code class="p">)));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>It’s also a good idea to implement the  <code>From</code> trait <a data-primary="From trait" data-secondary="implementation for suberror types" data-type="indexterm" id="OEBPS/ch01.html.id426"></a>for all of the suberror types (<a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">e</code>: <code class="nc">std</code>::<code class="n">io</code>::<code class="n">Error</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code>::<code class="n">Io</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">string</code>::<code class="n">FromUtf8Error</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">e</code>: <code class="nc">std</code>::<code class="n">string</code>::<code class="n">FromUtf8Error</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code>::<code class="n">Utf8</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This prevents library users from suffering <a data-primary="orphan rule" data-type="indexterm" id="OEBPS/ch01.html.id427"></a>under the  orphan rules themselves: they aren’t allowed to implement
<code>From</code> on <code>MyError</code>, because both the trait and the struct are external to them.</p>

<p>Better still, implementing  <code>From</code> allows for even more concision, because the  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark operator</a> will
automatically perform any necessary <code>From</code> conversions, removing the need for <code>.map_err()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">BufRead</code><code class="p">;</code><code class="w"> </code><code class="c1">// for `.read_until()`</code>

<code class="sd">/// Maximum supported line length.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="n">MAX_LEN</code>: <code class="kt">usize</code> <code class="o">=</code><code class="w"> </code><code class="mi">1024</code><code class="p">;</code><code class="w"></code></pre>

<pre class="pagebreak-before less_space" data-code-language="rust" data-type="programlisting"><code class="sd">/// Return the first line of the given file.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">first_line</code><code class="p">(</code><code class="n">filename</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">MyError</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">fs</code>::<code class="n">File</code>::<code class="n">open</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"> </code><code class="c1">// `From&lt;std::io::Error&gt;`</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">reader</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">io</code>::<code class="n">BufReader</code>::<code class="n">new</code><code class="p">(</code><code class="n">file</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">buf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[];</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">reader</code><code class="p">.</code><code class="n">read_until</code><code class="p">(</code><code class="sc">b'\n'</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">buf</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"> </code><code class="c1">// `From&lt;std::io::Error&gt;`</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code>::<code class="n">from_utf8</code><code class="p">(</code><code class="n">buf</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"> </code><code class="c1">// `From&lt;string::FromUtf8Error&gt;`</code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">result</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">MAX_LEN</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">MyError</code>::<code class="n">General</code><code class="p">(</code><code class="fm">format!</code><code class="p">(</code><code class="s">"Line too long: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">len</code><code class="p">)));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Writing a complete error type can involve a fair amount of boilerplate, which makes it a good candidate for automation
via a  <em><code>derive</code> macro</em> (<a href="#OEBPS/ch05.html.file_macros_md">Item 28</a>).  However, there’s no need to write such a macro yourself:
<em>consider using the  <a class="orm:hideurl" href="https://docs.rs/thiserror"><code>thiserror</code></a> crate</em> from  David
Tolnay, which provides a high-quality, widely used implementation of just such a macro. The code generated by
<code>thiserror</code> is also careful to avoid making any <code>this​er⁠ror</code> types visible in the generated API, which in turn means that
the concerns associated with <a href="#OEBPS/ch04.html.file_re-export_md">Item 24</a> don’t apply.</p>
</div></section>








<section data-pdf-bookmark="Trait Objects" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id23">
<h2>Trait Objects</h2>

<p>The first approach to nested errors threw away all of the suberror detail, just preserving some string output
(<code>format!("{:?}", err)</code>).  The second approach preserved the full type information for all possible suberrors but
required a full enumeration of all possible types of suberror.</p>

<p>This raises the question, Is there a middle ground between these two approaches, preserving suberror information
without needing to manually include every possible error type?</p>

<p>Encoding the suberror information as a  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/types/trait-object.html"><em>trait object</em></a> avoids the need for an <code>enum</code> variant for every
possibility but erases the details of the specific underlying error types. The receiver of such an object would have
access to the methods of the <code>Error</code> trait and its trait bounds—<code>source()</code>, <code>Display::fmt()</code>, and <code>Debug::fmt()</code>,
in turn—but wouldn’t know the original static type of the suberror:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id428">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">WrappedError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Wrapped</code><code class="p">(</code><code class="nb">Box</code><code class="o">&lt;</code><code class="k">dyn</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">General</code><code class="p">(</code><code class="nb">String</code><code class="p">),</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">WrappedError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">std</code>::<code class="n">fmt</code>::<code class="nb">Result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">Self</code>::<code class="n">Wrapped</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"Inner error: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="bp">Self</code>::<code class="n">General</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>It turns out that this <em>is</em> possible, but it’s surprisingly subtle. Part of the difficulty comes from the object safety
constraints on trait objects (<a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>), but Rust’s  <em>coherence rules</em> also come into play, which
(roughly) say that there can be at most one implementation of a trait for a type.</p>

<p>A putative <code>WrappedError</code> type would naively be expected to implement both of the 
<span class="keep-together">following</span>:</p>

<ul>
<li>
<p>The <code>Error</code> trait, because it is an error itself.</p>
</li>
<li>
<p>The <code>From&lt;Error&gt;</code> trait, to allow suberrors to be easily wrapped.</p>
</li>
</ul>

<p>That means that a <code>WrappedError</code> can be created <code>from</code> an
inner 
<span class="keep-together"><code>WrappedError</code></span>, as <code>WrappedError</code> implements <code>Error</code>, and that clashes with the  blanket reflexive implementation of <code>From</code>:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id429">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">Error</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">WrappedError</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="k">impl</code><code class="o">&lt;</code><code class="n">E</code>: <code class="o">'</code><code class="nb">static</code> <code class="o">+</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">WrappedError</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">e</code>: <code class="nc">E</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code>::<code class="n">Wrapped</code><code class="p">(</code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">e</code><code class="p">))</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0119]: conflicting implementations of trait `From&lt;WrappedError&gt;` for
              type `WrappedError`
   --&gt; src/main.rs:279:5
    |
279 |     impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: conflicting implementation in crate `core`:
            - impl&lt;T&gt; From&lt;T&gt; for T;</pre>

<p class="pagebreak-before less_space">David Tolnay’s <a class="orm:hideurl" href="https://docs.rs/anyhow"><code>anyhow</code></a> is a crate that has already solved these
problems (by adding an extra level of <a href="https://oreil.ly/aWecz">indirection via <code>Box</code></a>) and that adds other helpful features (such
as stack traces) besides.<a data-primary="anyhow crate" data-type="indexterm" id="OEBPS/ch01.html.id430"></a><a data-primary="Tolnay, David" data-type="indexterm" id="OEBPS/ch01.html.id431"></a>  As a result, it is rapidly becoming the standard recommendation for error handling—a
recommendation seconded here: <em>consider using the <code>anyhow</code> crate for error handling in applications</em>.</p>
</div></section>








<section data-pdf-bookmark="Libraries Versus Applications" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id203">
<h2>Libraries Versus Applications</h2>

<p>The final advice from the previous section included the qualification “…for error handling <em>in applications</em>.”
That’s because there’s often a distinction between code that’s written for reuse in a library and code that forms a
top-level application.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id432" id="OEBPS/ch01.html.id432-marker">11</a></sup></p>

<p>Code that’s written for a library can’t predict the environment in which the code is used, so it’s preferable to emit
concrete, detailed error information and leave the caller to figure out how to use that information. This leans toward
the <code>enum</code>-style nested errors described previously (and also avoids a dependency on <code>anyhow</code> in the public API of the
library, see <a href="#OEBPS/ch04.html.file_re-export_md">Item 24</a>).</p>

<p>However, application code typically needs to concentrate more on how to present errors to the user. It also potentially
has to cope with all of the different error types emitted by all of the libraries that are present in its dependency
graph (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).  As such, a more dynamic error type (such as
<a class="orm:hideurl" href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html"><code>anyhow::Error</code></a>) makes error handling simpler and more
consistent across the application.</p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id172">
<h2>Things to Remember</h2>

<ul>
<li>
<p>The standard <code>Error</code> trait requires little of you, so prefer to implement it for your error types.</p>
</li>
<li>
<p>When dealing with heterogeneous underlying error types, decide whether it’s necessary to preserve those types.</p>

<ul>
<li>
<p>If not, consider using <code>anyhow</code> to wrap suberrors in application code.</p>
</li>
<li>
<p>If so, encode them in an <code>enum</code> and provide conversions. Consider using 
<span class="keep-together"><code>thiserror</code></span> to help with this.</p>
</li>
</ul>
</li>
<li>
<p>Consider using the <code>anyhow</code> crate for convenient idiomatic error handling in application code.</p>
</li>
<li>
<p>It’s your decision, but whatever you decide, encode it in the type system (<a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>).<a data-primary="types" data-secondary="idiomatic Error types, preferring" data-startref="ix_typiderr" data-type="indexterm" id="OEBPS/ch01.html.id433"></a><a data-primary="errors" data-secondary="preferring idiomatic Error types" data-startref="ix_erridtyp" data-type="indexterm" id="OEBPS/ch01.html.id434"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 5: Understand type conversions" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_casts_md">
<h1>Item 5: Understand type conversions</h1>

<p>Rust type conversions <a data-primary="type conversions" data-type="indexterm" id="OEBPS/ch01.html.ix_typcnv"></a>fall into three categories:</p>
<dl>
<dt><em>Manual</em></dt>
<dd>
<p>User-defined type conversions provided by implementing the <code>From</code> and <code>Into</code> traits</p>
</dd>
<dt><em>Semi-automatic</em></dt>
<dd>
<p>Explicit casts between values using the <code>as</code> keyword</p>
</dd>
<dt><em>Automatic</em></dt>
<dd>
<p>Implicit  <em>coercion</em> into a new type</p>
</dd>
</dl>

<p>The majority of this Item focuses on the first of these, manual conversions of types, because the latter two mostly
don’t apply to conversions of user-defined types.<a data-primary="type conversions" data-secondary="manual" data-type="indexterm" id="OEBPS/ch01.html.id435"></a><a data-primary="type coercion" data-secondary="implicit coercion" data-type="indexterm" id="OEBPS/ch01.html.id436"></a><a data-primary="as keyword" data-type="indexterm" id="OEBPS/ch01.html.id437"></a>  There are a couple of exceptions to this, so sections at the end of
the Item discuss casting and coercion—including how they can apply to a user-defined type.<a data-primary="semi-automatic type conversions" data-type="indexterm" id="OEBPS/ch01.html.id438"></a><a data-primary="automatic type conversions" data-type="indexterm" id="OEBPS/ch01.html.id439"></a></p>

<p>Note that in contrast to many older languages, Rust does not perform automatic conversion between numeric types. This
even applies to “safe” transformations of integral types:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id440">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code> <code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:70:18
   |
70 |     let y: u64 = x;
   |            ---   ^ expected `u64`, found `u32`
   |            |
   |            expected due to this
   |
help: you can convert a `u32` to a `u64`
   |
70 |     let y: u64 = x.into();
   |                   +++++++</pre>








<section data-pdf-bookmark="User-Defined Type Conversions" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id25">
<h2>User-Defined Type Conversions</h2>

<p>As with other features of the language (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>), the ability to perform conversions between values of different
user-defined types is encapsulated as a standard trait—or rather, as a set of related  generic traits.<a data-primary="type conversions" data-secondary="user-defined" data-type="indexterm" id="OEBPS/ch01.html.id441"></a><a data-primary="user-defined type conversions" data-type="indexterm" id="OEBPS/ch01.html.id442"></a></p>

<p>The four relevant <a data-primary="traits" data-secondary="in user-defined type conversions" data-secondary-sortas="user-defined" data-type="indexterm" id="OEBPS/ch01.html.id443"></a><a data-primary="From trait" data-secondary="use in user-defined type conversions" data-type="indexterm" id="OEBPS/ch01.html.id444"></a><a data-primary="TryFrom trait" data-secondary="use in user-defined type conversions" data-type="indexterm" id="OEBPS/ch01.html.id445"></a><a data-primary="Into trait" data-type="indexterm" id="OEBPS/ch01.html.id446"></a><a data-primary="TryInto trait" data-type="indexterm" id="OEBPS/ch01.html.id447"></a>traits that express the ability to convert values of a type are as 
<span class="keep-together">follows</span>:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a></dt>
<dd>
<p> Items of this type can be
built from items of type <code>T</code>, and the conversion always succeeds.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom&lt;T&gt;</code></a></dt>
<dd>
<p> Items of this type
can be built from items of type <code>T</code>, but the conversion might not succeed.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a></dt>
<dd>
<p> Items of this type can be
converted into items of type <code>T</code>, and the conversion always succeeds.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto&lt;T&gt;</code></a></dt>
<dd>
<p> Items of this type
can be converted into items of type <code>T</code>, but the conversion might not succeed.</p>
</dd>
</dl>

<p>Given the discussion in <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> about expressing things in the type system, it’s no surprise to discover that the
difference with the <code>Try...</code> variants is that the sole trait method returns a  <code>Result</code> rather than a guaranteed
new item.  The <code>Try...</code> trait definitions also require an  associated type that gives the type of the error <code>E</code>
emitted for failure situations.<a data-primary="errors" data-secondary="in type conversions" data-secondary-sortas="type" data-type="indexterm" id="OEBPS/ch01.html.id448"></a><a data-primary="Result type" data-secondary="returned in type conversions" data-type="indexterm" id="OEBPS/ch01.html.id449"></a></p>

<p>The first piece of advice is therefore to <em>implement (just) the <code>Try...</code> trait if it’s possible for a
conversion to fail</em>, in line with <a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>.  The alternative is to ignore the possibility of error (e.g., with
<code>.unwrap()</code>), but that needs to be a deliberate choice, and in most cases it’s best to leave that choice to the caller.</p>

<p>The type conversion traits have an obvious symmetry: if a type <code>T</code> can be transformed <code>into</code> a type <code>U</code> (via <code>Into&lt;U&gt;</code>),
isn’t that the same as it being possible to create an item of type <code>U</code> by transforming <code>from</code> an item of type <code>T</code> (via
<code>From&lt;T&gt;</code>)?</p>

<p>This is indeed the case, and it leads to the second piece of advice: <em>implement the <code>From</code> trait for
conversions</em>.<a data-primary="From trait" data-secondary="implementation for type conversions" data-type="indexterm" id="OEBPS/ch01.html.id450"></a><a data-primary="trait coherence rules" data-type="indexterm" id="OEBPS/ch01.html.id451"></a><a data-primary="Into trait" data-secondary="automatically provided with From trait implementation" data-type="indexterm" id="OEBPS/ch01.html.id452"></a>  The Rust standard library had to pick just one of the two possibilities, in order to prevent the system
from spiraling around in dizzy circles,<sup><a data-type="noteref" href="#OEBPS/ch01.html.id453" id="OEBPS/ch01.html.id453-marker">12</a></sup> and it came down on the side of automatically providing <code>Into</code> from a <code>From</code> implementation.<a data-primary="automatic type conversions" data-secondary="Into trait automatically provided from From implementation" data-type="indexterm" id="OEBPS/ch01.html.id454"></a></p>

<p>If you’re consuming one of these two traits, as a trait bound on a new generic of your own, then the advice is reversed:
<em>use the <code>Into</code> trait for  trait bounds</em>.  <a data-primary="trait bounds" data-secondary="using Into trait for in type conversions" data-type="indexterm" id="OEBPS/ch01.html.id455"></a>That way, the bound will be satisfied both by things that directly
implement <code>Into</code> <em>and</em> by things that only directly implement <code>From</code>.</p>

<p>This automatic conversion is highlighted by the documentation for <code>From</code> and <code>Into</code>, but it’s worth reading the relevant
part of the standard library<a data-primary="blanket trait implementations" data-type="indexterm" id="OEBPS/ch01.html.id456"></a><a data-primary="Into trait" data-secondary="blanket trait implementation" data-type="indexterm" id="OEBPS/ch01.html.id457"></a> code too, which is a  <em>blanket trait implementation</em>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="p">,</code><code class="w"> </code><code class="n">U</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">Into</code><code class="o">&lt;</code><code class="n">U</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">T</code><code class="w"></code>
<code class="k">where</code><code class="w"></code>
<code class="w">    </code><code class="n">U</code>: <code class="nb">From</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">into</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">U</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">U</code>::<code class="n">from</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Translating a trait specification into words can help with understanding more complex trait bounds.  In this case, it’s
fairly simple: “I can implement <code>Into&lt;U&gt;</code> for a type <code>T</code> whenever <code>U</code> already implements <code>From&lt;T&gt;</code>.”</p>

<p>The standard library also includes various implementations of these conversion traits for standard library types. <a data-primary="TryFrom trait" data-secondary="implementations for standard library types" data-type="indexterm" id="OEBPS/ch01.html.id458"></a><a data-primary="From trait" data-secondary="integral conversions where destination type includes all possible values of source" data-type="indexterm" id="OEBPS/ch01.html.id459"></a><a data-primary="TryFrom trait" data-secondary="implementations for source not fitting destination type" data-type="indexterm" id="OEBPS/ch01.html.id460"></a> As
you’d expect, there are <code>From</code> implementations for integral conversions where the destination type includes all possible
values of the source type (<code>From&lt;u32&gt; for u64</code>), and <code>TryFrom</code> implementations when the source might not fit in the
destination (<code>TryFrom&lt;u64&gt; for u32</code>).</p>

<p>There are also various other blanket trait implementations in addition to the <code>Into</code> version previously shown; these are
mostly for  <em>smart pointer</em> types, allowing the smart pointer to be automatically constructed from an instance of
the type that it holds.<a data-primary="blanket trait implementations" data-secondary="for smart pointer types" data-secondary-sortas="smart" data-type="indexterm" id="OEBPS/ch01.html.id461"></a><a data-primary="smart pointer types" data-secondary="blanket trait implementations for" data-type="indexterm" id="OEBPS/ch01.html.id462"></a>  This means that generic methods that accept smart pointer parameters can also be called with
plain old items; more on this to come and in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>.</p>

<p>The <code>TryFrom</code> trait also has a blanket implementation for any type that already implements the <code>Into</code> trait in the<a data-primary="TryFrom trait" data-secondary="blanket implementation for any type implementing Into trait" data-type="indexterm" id="OEBPS/ch01.html.id463"></a>
opposite direction—which automatically includes (as shown previously) any type that implements <code>From</code> in the same
direction.<a data-primary="Infallible error type" data-type="indexterm" id="OEBPS/ch01.html.id464"></a> In other words, if you can infallibly convert a <code>T</code> into a <code>U</code>, you can also fallibly obtain a <code>U</code> from a
<code>T</code>; as this conversion will always succeed, the associated error type is the helpfully named <a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/enum.Infallible.html"><code>Infallible</code></a>.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id465" id="OEBPS/ch01.html.id465-marker">13</a></sup></p>

<p>There’s <a data-primary="From trait" data-secondary="reflexive implementation" data-type="indexterm" id="OEBPS/ch01.html.id466"></a><a data-primary="reflexive implementation of From" data-type="indexterm" id="OEBPS/ch01.html.id467"></a>also one very specific generic implementation of <code>From</code> that sticks out, the  <em>reflexive implementation</em>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">t</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">T</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">t</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Translated into words, this just says that “given a <code>T</code>, I can get a <code>T</code>.” That’s such an obvious “well,
duh” that it’s worth stopping to understand why this is useful.<a data-primary="newtype pattern" data-secondary="function operating on it" data-type="indexterm" id="OEBPS/ch01.html.id468"></a></p>

<p>Consider a simple newtype <code>struct</code> (<a href="#OEBPS/ch01.html.file_newtype_md">Item 6</a>) and a function that operates on it (ignoring that this function would be
better expressed as a method):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Integer value from an IANA-controlled range.</code>
<code class="cp">#[derive(Clone, Copy, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">IanaAllocated</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">u64</code><code class="p">);</code><code class="w"></code>

<code class="sd">/// Indicate whether value is reserved.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">is_iana_reserved</code><code class="p">(</code><code class="n">s</code>: <code class="nc">IanaAllocated</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">s</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">65535</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This function can be invoked with instances of the <code>struct</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IanaAllocated</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"{:?} reserved? {}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="n">is_iana_reserved</code><code class="p">(</code><code class="n">s</code><code class="p">));</code><code class="w"></code>
<code class="c1">// output: "IanaAllocated(1) reserved? false"</code></pre>

<p>but even if <code>From&lt;u64&gt;</code> is implemented for the newtype wrapper:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">IanaAllocated</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>the function can’t be directly invoked for <code>u64</code> values:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id469">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="n">is_iana_reserved</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:77:25
   |
77 |     if is_iana_reserved(42) {
   |        ---------------- ^^ expected `IanaAllocated`, found integer
   |        |
   |        arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:7:8
   |
7  | pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
   |        ^^^^^^^^^^^^^^^^ ----------------
help: try wrapping the expression in `IanaAllocated`
   |
77 |     if is_iana_reserved(IanaAllocated(42)) {
   |                         ++++++++++++++  +</pre>

<p>However, a  generic <a data-primary="generics" data-secondary="generic functions" data-type="indexterm" id="OEBPS/ch01.html.id470"></a>version of the function that accepts (and explicitly converts) anything
satisfying <code>Into&lt;IanaAllocated&gt;</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">is_iana_reserved</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">s</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code>
<code class="nc">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="nb">Into</code><code class="o">&lt;</code><code class="n">IanaAllocated</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">into</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="n">s</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">65535</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>allows this use:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="n">is_iana_reserved</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>With this trait bound in place, the reflexive trait implementation of <code>From&lt;T&gt;</code> makes more sense: it means that the
generic function copes with items that are already <code>IanaAllocated</code> instances, no conversion needed.</p>

<p>This pattern also explains why (and how) Rust code sometimes <em>appears</em> to be doing implicit casts between types: the
combination of <code>From&lt;T&gt;</code> implementations and <code>Into&lt;T&gt;</code> trait bounds leads to code that appears to magically convert at
the call site (but is still doing safe, explicit, conversions under the covers).<a data-primary="From trait" data-secondary="From implementation and Into trait bounds" data-type="indexterm" id="OEBPS/ch01.html.id471"></a><a data-primary="casts" data-secondary="Rust code appearing to make implicit casts" data-type="indexterm" id="OEBPS/ch01.html.id472"></a> This pattern becomes even more
powerful when combined with reference types and their related conversion traits; more in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>.</p>
</div></section>








<section data-pdf-bookmark="Casts" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id26">
<h2>Casts</h2>

<p>Rust includes the  <code>as</code> keyword to perform explicit
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"><em>casts</em></a> between
some pairs of types.<a data-primary="type conversions" data-secondary="casts" data-type="indexterm" id="OEBPS/ch01.html.id473"></a><a data-primary="casts" data-type="indexterm" id="OEBPS/ch01.html.id474"></a><a data-primary="as keyword" data-type="indexterm" id="OEBPS/ch01.html.id475"></a><a data-primary="explicit casts" data-type="indexterm" id="OEBPS/ch01.html.id476"></a></p>

<p>The pairs of types that can be converted in this way constitute a fairly limited set, and the only user-defined types it
includes are “C-like”  <code>enum</code>s (those that have just an associated integer value).<a data-primary="enums" data-secondary="C-like, casts between" data-type="indexterm" id="OEBPS/ch01.html.id477"></a><a data-primary="C" data-secondary="C-like enums" data-type="indexterm" id="OEBPS/ch01.html.id478"></a> General integral conversions are
included, though, giving an alternative to <code>into()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code> <code class="o">=</code><code class="w"> </code><code class="mi">9</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u64</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">z</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">into</code><code class="p">();</code><code class="w"></code></pre>

<p>The <code>as</code> version <a data-primary="lossy conversions" data-type="indexterm" id="OEBPS/ch01.html.id479"></a>also allows lossy conversions:<sup><a data-type="noteref" href="#OEBPS/ch01.html.id480" id="OEBPS/ch01.html.id480-marker">14</a></sup></p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code> <code class="o">=</code><code class="w"> </code><code class="mi">9</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u16</code><code class="p">;</code><code class="w"></code></pre>

<p>which would be rejected by the <code>from</code>/<code>into</code> versions:</p>

<pre data-code-language="text" data-type="programlisting">error[E0277]: the trait bound `u16: From&lt;u32&gt;` is not satisfied
   --&gt; src/main.rs:136:20
    |
136 |     let y: u16 = x.into();
    |                    ^^^^ the trait `From&lt;u32&gt;` is not implemented for `u16`
    |
    = help: the following other types implement trait `From&lt;T&gt;`:
              &lt;u16 as From&lt;NonZeroU16&gt;&gt;
              &lt;u16 as From&lt;bool&gt;&gt;
              &lt;u16 as From&lt;u8&gt;&gt;
    = note: required for `u32` to implement `Into&lt;u16&gt;`</pre>

<p>For <a data-primary="From trait" data-secondary="preferring from / into conversions over as casts" data-type="indexterm" id="OEBPS/ch01.html.id481"></a><a data-primary="as keyword" data-secondary="preferring from / into conversions over as casts" data-type="indexterm" id="OEBPS/ch01.html.id482"></a><a data-primary="Clippy" data-type="indexterm" id="OEBPS/ch01.html.id483"></a><a data-primary="casts" data-secondary="preferring from / into conversions over as casts" data-type="indexterm" id="OEBPS/ch01.html.id484"></a>consistency and safety, you should <em>prefer <code>from</code>/<code>into</code> conversions over <code>as</code> casts</em>, unless you
understand and need the precise <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics">casting semantics</a> (e.g., for C interoperability).
This advice can be reinforced by Clippy (<a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a>), which includes several lints about <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#/as_conversions"><code>as</code> conversions</a>; however, these lints are
disabled by default.</p>
</div></section>








<section data-pdf-bookmark="Coercion" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id27">
<h2>Coercion</h2>

<p>The explicit <code>as</code> casts described in the previous section are a superset of the implicit
<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/type-coercions.html"><em>coercions</em></a> that the compiler will silently perform:
any  coercion can be forced with an explicit <code>as</code>, but the converse is not true.<a data-primary="type conversions" data-secondary="coercion" data-type="indexterm" id="OEBPS/ch01.html.id485"></a><a data-primary="type coercion" data-type="indexterm" id="OEBPS/ch01.html.id486"></a>  In particular, the integral
conversions performed in the previous section are not coercions and so will always require <code>as</code>.</p>

<p>Most coercions involve silent conversions of <a data-primary="references" data-secondary="coercions of reference types" data-type="indexterm" id="OEBPS/ch01.html.id487"></a><a data-primary="pointers" data-secondary="coercion of pointer types" data-type="indexterm" id="OEBPS/ch01.html.id488"></a>pointer and reference types in ways that are sensible and convenient
for the programmer, such as converting the following:</p>

<ul>
<li>
<p>A mutable reference to an immutable reference (so you can use a <code>&amp;mut T</code> as the argument to a function<a data-primary="mutable references" data-secondary="conversion to immutable" data-type="indexterm" id="OEBPS/ch01.html.id489"></a>
that takes a <code>&amp;T</code>)</p>
</li>
<li>
<p>A reference to a raw pointer (this isn’t <code>unsafe</code>—the unsafety happens at the point where you’re
foolish enough to <em>dereference</em> a raw pointer)</p>
</li>
<li>
<p>A closure that happens to not capture any variables into a bare function pointer (<a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>)</p>
</li>
<li>
<p>An <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.array.html">array</a> to a
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a></p>
</li>
<li>
<p>A concrete item to a <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a>, for a
trait that the concrete item implements<a data-primary="traits" data-secondary="coercion of concrete item into trait object" data-type="indexterm" id="OEBPS/ch01.html.id490"></a></p>
</li>
<li>
<p>An item lifetime to a “shorter” one (<a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>)<sup><a data-type="noteref" href="#OEBPS/ch01.html.id491" id="OEBPS/ch01.html.id491-marker">15</a></sup><a data-primary="subtyping" data-type="indexterm" id="OEBPS/ch01.html.id492"></a></p>
</li>
</ul>

<p>There are only two coercions whose behavior can be affected by user-defined types. <a data-primary="user-defined types" data-secondary="coercions affected by" data-type="indexterm" id="OEBPS/ch01.html.id493"></a>The first happens when a
user-defined type implements the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> or the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait.  <a data-primary="Deref trait" data-type="indexterm" id="OEBPS/ch01.html.id494"></a><a data-primary="DerefMut trait" data-type="indexterm" id="OEBPS/ch01.html.id495"></a><a data-primary="smart pointer types" data-secondary="user-defined types acting as" data-type="indexterm" id="OEBPS/ch01.html.id496"></a>These traits indicate that the user-defined
type is acting as a <em>smart pointer</em> of some sort (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>), and in this case the compiler will coerce a reference to
the smart pointer item into being a reference to an item of the type that the smart pointer contains (indicated by
its <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html#associatedtype.Target"><code>Target</code></a>).</p>

<p>The second coercion of a user-defined type happens when a concrete item is converted to a  <em>trait object</em>. <a data-primary="type conversions" data-startref="ix_typcnv" data-type="indexterm" id="OEBPS/ch01.html.id497"></a><a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch01.html.id498"></a><a data-primary="vtable" data-type="indexterm" id="OEBPS/ch01.html.id499"></a>This
operation builds a  fat pointer to the item; this pointer is fat because it includes both a pointer to the item’s
location in memory and a pointer to the  <em>vtable</em> for the concrete type’s implementation of the
trait—see <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 6: Embrace the newtype pattern" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_newtype_md">
<h1>Item 6: Embrace the newtype pattern</h1>

<p><a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> described  <em>tuple structs</em>, where the fields of a <code>struct</code> have no names and are instead
referred to by number (<code>self.0</code>).  <a data-primary="tuple struct" data-type="indexterm" id="OEBPS/ch01.html.id500"></a>This Item focuses on tuple structs that have a single entry of some existing type,
thus creating a new type that can hold exactly the same range of values as the enclosed type.  This pattern is
sufficiently pervasive in Rust that it deserves its own Item and has its own name: the <em>newtype pattern</em>.<a data-primary="types" data-secondary="newtype pattern" data-type="indexterm" id="OEBPS/ch01.html.ix_typnew"></a><a data-primary="newtype pattern" data-type="indexterm" id="OEBPS/ch01.html.ix_newtyp"></a></p>

<p>The simplest use of the newtype pattern is to indicate <a class="orm:hideurl" href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">additional semantics for a type</a>,
over and above its normal behavior.  To illustrate this, imagine a project that’s going to send a satellite to
Mars.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id501" id="OEBPS/ch01.html.id501-marker">16</a></sup>  It’s a
big project, so different groups have built different parts of the project. One group has handled the code for the
rocket engines:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Fire the thrusters. Returns generated impulse in pound-force seconds.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">thruster_impulse</code><code class="p">(</code><code class="n">direction</code>: <code class="nc">Direction</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="mf">42.0</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>while a different group handles the inertial guidance system:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Update trajectory model for impulse, provided in Newton seconds.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">update_trajectory</code><code class="p">(</code><code class="n">force</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Eventually these different parts need to be joined together:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">thruster_force</code>: <code class="kt">f64</code> <code class="o">=</code><code class="w"> </code><code class="n">thruster_impulse</code><code class="p">(</code><code class="n">direction</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">new_direction</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">update_trajectory</code><code class="p">(</code><code class="n">thruster_force</code><code class="p">);</code><code class="w"></code></pre>

<p>Ruh-roh.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id502" id="OEBPS/ch01.html.id502-marker">17</a></sup></p>

<p>Rust includes a  <em>type alias</em> feature, which <a data-primary="type aliases" data-type="indexterm" id="OEBPS/ch01.html.id503"></a>allows the different groups to make their intentions clearer:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Units for force.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">f64</code><code class="p">;</code><code class="w"></code>

<code class="sd">/// Fire the thrusters. Returns generated impulse.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">thruster_impulse</code><code class="p">(</code><code class="n">direction</code>: <code class="nc">Direction</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="mf">42.0</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Units for force.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">NewtonSeconds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kt">f64</code><code class="p">;</code><code class="w"></code>

<code class="sd">/// Update trajectory model for impulse.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">update_trajectory</code><code class="p">(</code><code class="n">force</code>: <code class="nc">NewtonSeconds</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, the type aliases are effectively just documentation; they’re a stronger hint than the doc comments
of the previous version, but nothing stops a <code>PoundForceSeconds</code> value being used where a
<code>NewtonSeconds</code> value is expected:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">thruster_force</code>: <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">thruster_impulse</code><code class="p">(</code><code class="n">direction</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">new_direction</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">update_trajectory</code><code class="p">(</code><code class="n">thruster_force</code><code class="p">);</code><code class="w"></code></pre>

<p>Ruh-roh once more.</p>

<p>This is the point where the newtype pattern helps:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Units for force.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">PoundForceSeconds</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">f64</code><code class="p">);</code><code class="w"></code>

<code class="sd">/// Fire the thrusters. Returns generated impulse.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">thruster_impulse</code><code class="p">(</code><code class="n">direction</code>: <code class="nc">Direction</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">PoundForceSeconds</code><code class="p">(</code><code class="mf">42.0</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Units for force.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">NewtonSeconds</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">f64</code><code class="p">);</code><code class="w"></code>

<code class="sd">/// Update trajectory model for impulse.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">update_trajectory</code><code class="p">(</code><code class="n">force</code>: <code class="nc">NewtonSeconds</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>As the name implies, a newtype is a new type, and as such the compiler objects when there’s a mismatch of
types—here attempting to pass a <code>PoundForceSeconds</code> value to something that expects a <code>NewtonSeconds</code> value:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id504">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">thruster_force</code>: <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">thruster_impulse</code><code class="p">(</code><code class="n">direction</code><code class="p">);</code><code class="w"></code>
<code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="n">new_direction</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">update_trajectory</code><code class="p">(</code><code class="n">thruster_force</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0308]: mismatched types
  --&gt; src/main.rs:76:43
   |
76 |     let new_direction = update_trajectory(thruster_force);
   |                         ----------------- ^^^^^^^^^^^^^^ expected
   |                         |        `NewtonSeconds`, found `PoundForceSeconds`
   |                         |
   |                         arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:66:8
   |
66 | pub fn update_trajectory(force: NewtonSeconds) {
   |        ^^^^^^^^^^^^^^^^^ --------------------
help: call `Into::into` on this expression to convert `PoundForceSeconds` into
      `NewtonSeconds`
   |
76 |     let new_direction = update_trajectory(thruster_force.into());
   |                                                         +++++++</pre>

<p>As described in <a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>, adding an implementation<a data-primary="From trait" data-secondary="from / into conversions" data-type="indexterm" id="OEBPS/ch01.html.id505"></a> of the standard <code>From</code> trait:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="nb">From</code><code class="o">&lt;</code><code class="n">PoundForceSeconds</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">NewtonSeconds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">from</code><code class="p">(</code><code class="n">val</code>: <code class="nc">PoundForceSeconds</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">NewtonSeconds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">NewtonSeconds</code><code class="p">(</code><code class="mf">4.448222</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">val</code><code class="p">.</code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>allows the necessary unit—and type—conversion to be performed with <code>.into()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">thruster_force</code>: <code class="nc">PoundForceSeconds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">thruster_impulse</code><code class="p">(</code><code class="n">direction</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">new_direction</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">update_trajectory</code><code class="p">(</code><code class="n">thruster_force</code><code class="p">.</code><code class="n">into</code><code class="p">());</code><code class="w"></code></pre>

<p>The same pattern of using a newtype to mark additional “unit” semantics for a type can also help to make purely Boolean
arguments less ambiguous.<a data-primary="bool type" data-secondary="making Boolean arguments clear with newtype" data-type="indexterm" id="OEBPS/ch01.html.id506"></a><a data-primary="newtype pattern" data-secondary="making Boolean argument clear with" data-type="indexterm" id="OEBPS/ch01.html.id507"></a>  Revisiting the example from <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>, using newtypes makes the meaning of arguments clear:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">DoubleSided</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">bool</code><code class="p">);</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">ColorOutput</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">bool</code><code class="p">);</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">print_page</code><code class="p">(</code><code class="n">sides</code>: <code class="nc">DoubleSided</code><code class="p">,</code><code class="w"> </code><code class="n">color</code>: <code class="nc">ColorOutput</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="n">print_page</code><code class="p">(</code><code class="n">DoubleSided</code><code class="p">(</code><code class="kc">true</code><code class="p">),</code><code class="w"> </code><code class="n">ColorOutput</code><code class="p">(</code><code class="kc">false</code><code class="p">));</code><code class="w"></code></pre>
<p>If size efficiency or binary compatibility is a concern, then the  <a class="orm:hideurl" href="https://oreil.ly/PhmcH"><code>#[repr(transparent)]</code> attribute</a> ensures that a newtype
has the same representation in memory as the inner type.
</p>

<p>That’s the simple use of newtype<a data-primary="repr(transparent)" data-type="indexterm" id="OEBPS/ch01.html.id508"></a>, and it’s a specific example of <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>—encoding semantics into the type
system, so that the compiler takes care of policing those semantics.</p>








<section data-pdf-bookmark="Bypassing the Orphan Rule for Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id29">
<h2>Bypassing the Orphan Rule for Traits</h2>

<p>The other
<a class="orm:hideurl" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">common</a>,
but more subtle, scenario that requires the newtype pattern revolves around Rust’s  orphan rule.<a data-primary="orphan rule" data-secondary="bypassing for traits" data-type="indexterm" id="OEBPS/ch01.html.id509"></a><a data-primary="traits" data-secondary="bypassing orphan rule for" data-type="indexterm" id="OEBPS/ch01.html.id510"></a><a data-primary="newtype pattern" data-secondary="orphan rule and" data-type="indexterm" id="OEBPS/ch01.html.id511"></a>  Roughly speaking,
this says that a crate can implement a trait for a type only if one of the following conditions holds:<a data-primary="traits" data-secondary="attempting to implement foreign trait for foreign type" data-type="indexterm" id="OEBPS/ch01.html.id512"></a></p>

<ul>
<li>
<p>The crate has defined the trait</p>
</li>
<li>
<p>The crate has defined the type</p>
</li>
</ul>

<p>Attempting to implement a foreign trait for a foreign type:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id513">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code><code class="p">;</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">rand</code>::<code class="n">rngs</code>::<code class="n">StdRng</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"&lt;StdRng instance&gt;"</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>leads to a compiler error (which in turn points the way back to newtypes):</p>

<pre data-code-language="text" data-type="programlisting">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
   --&gt; src/main.rs:146:1
    |
146 | impl fmt::Display for rand::rngs::StdRng {
    | ^^^^^^^^^^^^^^^^^^^^^^------------------
    | |                     |
    | |                     `StdRng` is not defined in the current crate
    | impl doesn't use only types from inside the current crate
    |
    = note: define and implement a trait or new type instead</pre>

<p>The reason for this restriction is due to the risk of ambiguity: if two different crates in the  dependency graph
(<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) were <em>both</em> to (say) <code>impl std::fmt::Display for rand::rngs::StdRng</code>, then the   compiler/linker
has no way to choose between them.<a data-primary="linker" data-type="indexterm" id="OEBPS/ch01.html.id514"></a></p>

<p>This can frequently<a data-primary="serde crate" data-type="indexterm" id="OEBPS/ch01.html.id515"></a> lead to frustration: for example, if you’re trying to serialize data that includes a type from
another crate, the orphan rule prevents you from writing <code>impl serde::Serialize for somecrate::SomeType</code>.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id516" id="OEBPS/ch01.html.id516-marker">18</a></sup></p>

<p>But the newtype pattern means that you’re defining a <em>new</em> type, which is part of the current crate, and so the second
part of the orphan trait rule applies.  Implementing a foreign trait is now possible:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">MyRng</code><code class="p">(</code><code class="n">rand</code>::<code class="n">rngs</code>::<code class="n">StdRng</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyRng</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">write!</code><code class="p">(</code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="s">"&lt;MyRng instance&gt;"</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Newtype Limitations" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id30">
<h2>Newtype Limitations</h2>

<p>The newtype pattern solves these two classes of problems—preventing unit conversions and bypassing the orphan
rule—but it does come with some awkwardness: every operation that involves the newtype needs to forward
to the inner type.<a data-primary="newtype pattern" data-secondary="limitations of" data-type="indexterm" id="OEBPS/ch01.html.id517"></a></p>

<p>On a trivial level, that means that the code has to use <code>thing.0</code> throughout, rather than just <code>thing</code>, but that’s easy,
and the compiler will tell you where it’s needed.</p>

<p>The more significant awkwardness is that any trait implementations on the inner type are lost: because the newtype is a
new type, the existing inner implementation doesn’t apply.<a data-primary="traits" data-secondary="newtype and traits implemented on inner type" data-type="indexterm" id="OEBPS/ch01.html.id518"></a><a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch01.html.id519"></a></p>

<p>For derivable traits, this just means that the newtype declaration ends up with lots of  <code>derive</code>s:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">NewType</code><code class="p">(</code><code class="n">InnerType</code><code class="p">);</code><code class="w"></code></pre>

<p>However, for more sophisticated traits, some forwarding boilerplate is needed to recover the inner type’s implementation,
for <a data-primary="types" data-secondary="newtype pattern" data-startref="ix_typnew" data-type="indexterm" id="OEBPS/ch01.html.id520"></a><a data-primary="newtype pattern" data-startref="ix_newtyp" data-type="indexterm" id="OEBPS/ch01.html.id521"></a>example:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">fmt</code><code class="p">;</code><code class="w"></code>
<code class="k">impl</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Display</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">NewType</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">fmt</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">fmt</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 7: Use builders for complex types" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_builders_md">
<h1>Item 7: Use builders for complex types</h1>

<p>This Item describes the builder pattern, where complex data structures have an associated  <em>builder</em> type that
makes it easier for users to create instances of the data 
<span class="keep-together">structure</span>.<a data-primary="builders" data-type="indexterm" id="OEBPS/ch01.html.ix_bldr"></a><a data-primary="builder pattern" data-type="indexterm" id="OEBPS/ch01.html.id522"></a><a data-primary="types" data-secondary="using builders for complex types" data-type="indexterm" id="OEBPS/ch01.html.ix_typbld"></a><a data-primary="struct types" data-secondary="using builder pattern with complex structs" data-type="indexterm" id="OEBPS/ch01.html.ix_strctbldr"></a></p>

<p>Rust insists that all fields in a  <code>struct</code> must be filled in when a new instance of that <code>struct</code> is created. This
keeps the code safe by ensuring that there are never any uninitialized values but does lead to more verbose boilerplate
code than is ideal.</p>

<p>For example, any optional fields have to be explicitly<a data-primary="None variant of Option" data-type="indexterm" id="OEBPS/ch01.html.id523"></a> marked as absent with <code>None</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Phone number in E164 format.</code>
<code class="cp">#[derive(Debug, Clone)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">PhoneNumberE164</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="nb">String</code><code class="p">);</code><code class="w"></code>

<code class="cp">#[derive(Debug, Default)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">given_name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">preferred_name</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">middle_name</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">family_name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">mobile_phone</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">PhoneNumberE164</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="c1">// ...</code>

<code class="kd">let</code><code class="w"> </code><code class="n">dizzy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">given_name</code>: <code class="s">"Dizzy"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">preferred_name</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">middle_name</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">family_name</code>: <code class="s">"Mixer"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">mobile_phone</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>This boilerplate code is also brittle, in the sense that a future change that adds a new field to the <code>struct</code> requires
an update to every place that builds the structure.<a data-primary="Default trait" data-type="indexterm" id="OEBPS/ch01.html.id524"></a></p>

<p>The boilerplate can be significantly reduced by implementing and using the
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait, as described in
<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">dizzy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">given_name</code>: <code class="s">"Dizzy"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">family_name</code>: <code class="s">"Mixer"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="o">..</code><code class="nb">Default</code>::<code class="n">default</code><code class="p">()</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>Using <code>Default</code> also helps reduce the changes needed when a new field is added, provided that the new field is itself of
a type that implements <code>Default</code>.</p>

<p>That’s a more general concern: the automatically <a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch01.html.id525"></a>derived implementation of <code>Default</code> works only if all of
the field types implement the <code>Default</code> trait. If there’s a field that doesn’t play along, the <code>derive</code> step doesn’t
work:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id526">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Default)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">given_name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">preferred_name</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">middle_name</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="nb">String</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">family_name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">mobile_phone</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">PhoneNumberE164</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">date_of_birth</code>: <code class="nc">time</code>::<code class="n">Date</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">last_seen</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">time</code>::<code class="n">OffsetDateTime</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0277]: the trait bound `Date: Default` is not satisfied
  --&gt; src/main.rs:48:9
   |
41 |     #[derive(Debug, Default)]
   |                     ------- in this derive macro expansion
...
48 |         pub date_of_birth: time::Date,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not
   |                                       implemented for `Date`
   |
   = note: this error originates in the derive macro `Default`</pre>

<p>The code can’t<a data-primary="orphan rule" data-type="indexterm" id="OEBPS/ch01.html.id527"></a> implement <code>Default</code> for <code>chrono::Utc</code> because of the  orphan rule; but even if it could, it wouldn’t
be helpful—using a default value for date of birth is going to be wrong almost all of the time.</p>

<p>The absence of <code>Default</code> means that all of the fields have to be filled out manually:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">given_name</code>: <code class="s">"Robert"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">preferred_name</code>: <code class="nb">Some</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">()),</code><code class="w"></code>
<code class="w">    </code><code class="n">middle_name</code>: <code class="nb">Some</code><code class="p">(</code><code class="s">"the"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">()),</code><code class="w"></code>
<code class="w">    </code><code class="n">family_name</code>: <code class="s">"Builder"</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">mobile_phone</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">date_of_birth</code>: <code class="nc">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="w"></code>
<code class="w">        </code><code class="mi">1998</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="mi">28</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="w">    </code><code class="n">last_seen</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>These ergonomics can be improved if you <em>implement the  builder pattern for complex data structures</em>.</p>

<p>The <a data-primary="builder pattern" data-type="indexterm" id="OEBPS/ch01.html.id528"></a>simplest variant of the builder pattern is a separate <code>struct</code> that holds the information needed to construct the
item.  For simplicity, the example will hold an instance of the item itself:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">DetailsBuilder</code><code class="p">(</code><code class="n">Details</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">DetailsBuilder</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Start building a new [`Details`] object.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="w"></code>
<code class="w">        </code><code class="n">given_name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">family_name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">date_of_birth</code>: <code class="nc">time</code>::<code class="n">Date</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">DetailsBuilder</code><code class="p">(</code><code class="n">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">given_name</code>: <code class="nc">given_name</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">            </code><code class="n">preferred_name</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">middle_name</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">family_name</code>: <code class="nc">family_name</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"></code>
<code class="w">            </code><code class="n">mobile_phone</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">date_of_birth</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">last_seen</code>: <code class="nb">None</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="p">})</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The builder type can then be equipped with helper methods that fill out the nascent item’s fields.<a data-primary="builders" data-secondary="helper methods for populating fields" data-type="indexterm" id="OEBPS/ch01.html.id529"></a><a data-primary="Self type" data-type="indexterm" id="OEBPS/ch01.html.id530"></a> Each such
method consumes <code>self</code> but emits a new  <code>Self</code>, allowing different construction methods to be chained:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Set the preferred name.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">preferred_name</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">preferred_name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">preferred_name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">preferred_name</code><code class="p">.</code><code class="n">to_owned</code><code class="p">());</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Set the middle name.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">middle_name</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">middle_name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">middle_name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">middle_name</code><code class="p">.</code><code class="n">to_owned</code><code class="p">());</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>These helper methods can be more helpful than just simple setters:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Update the `last_seen` field to the current date/time.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">just_seen</code><code class="p">(</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">last_seen</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">time</code>::<code class="n">OffsetDateTime</code>::<code class="n">now_utc</code><code class="p">());</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The final method to be invoked for the builder consumes the builder and emits the built item:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Consume the builder object and return a fully built [`Details`]</code>
<code class="sd">/// object.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">build</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Overall, this allows clients of the builder to have a more ergonomic building 
<span class="keep-together">experience</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">also_bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">)</code><code class="w"></code>
<code class="p">.</code><code class="n">middle_name</code><code class="p">(</code><code class="s">"the"</code><code class="p">)</code><code class="w"></code>
<code class="p">.</code><code class="n">preferred_name</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">)</code><code class="w"></code>
<code class="p">.</code><code class="n">just_seen</code><code class="p">()</code><code class="w"></code>
<code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>

<p>The all-consuming nature of this style of builder leads to a couple of wrinkles.<a data-primary="builders" data-secondary="issues with" data-tertiary="separating out stages of build process" data-type="indexterm" id="OEBPS/ch01.html.id531"></a>  The first is that separating out
stages of the build process can’t be done on its own:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id532">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">);</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="n">informal</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">builder</code><code class="p">.</code><code class="n">preferred_name</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0382]: use of moved value: `builder`
   --&gt; src/main.rs:256:15
    |
247 |     let builder = DetailsBuilder::new(
    |         ------- move occurs because `builder` has type `DetailsBuilder`,
    |                 which does not implement the `Copy` trait
...
254 |         builder.preferred_name("Bob");
    |                 --------------------- `builder` moved due to this method
    |                                       call
255 |     }</pre>

<pre class="pagebreak-before less_space" data-code-language="text" data-type="programlisting">256 |     let bob = builder.build();
    |               ^^^^^^^ value used here after move
    |
note: `DetailsBuilder::preferred_name` takes ownership of the receiver `self`,
      which moves `builder`
   --&gt; src/main.rs:60:35
    |
27  |     pub fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
    |                               ^^^^</pre>

<p>This can be worked around by assigning the consumed builder back to the same 
<span class="keep-together">variable</span>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">);</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="n">informal</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">preferred_name</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>

<p>The other downside to the all-consuming nature of this builder is that only one item can be<a data-primary="builders" data-secondary="issues with" data-tertiary="only one item built at a time" data-type="indexterm" id="OEBPS/ch01.html.id533"></a> built; trying to create
multiple instances by repeatedly calling <code>build()</code> on the same builder falls foul of the compiler, as you’d expect:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id534">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">smithy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Agent"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Smith"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1999</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">June</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">).</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">clones</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="n">smithy</code><code class="p">.</code><code class="n">build</code><code class="p">(),</code><code class="w"> </code><code class="n">smithy</code><code class="p">.</code><code class="n">build</code><code class="p">(),</code><code class="w"> </code><code class="n">smithy</code><code class="p">.</code><code class="n">build</code><code class="p">()];</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0382]: use of moved value: `smithy`
   --&gt; src/main.rs:159:39
    |
154 |   let smithy = DetailsBuilder::new(
    |       ------ move occurs because `smithy` has type `base::DetailsBuilder`,
    |              which does not implement the `Copy` trait
...
159 |   let clones = vec![smithy.build(), smithy.build(), smithy.build()];
    |                            -------  ^^^^^^ value used here after move
    |                            |
    |                            `smithy` moved due to this method call</pre>

<p class="pagebreak-before less_space">An alternative approach is for the builder’s methods to take a <code>&amp;mut self</code> and<a data-primary="Self type" data-type="indexterm" id="OEBPS/ch01.html.id535"></a> emit a <code>&amp;mut Self</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Update the `last_seen` field to the current date/time.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">just_seen</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="bp">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">last_seen</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">time</code>::<code class="n">OffsetDateTime</code>::<code class="n">now_utc</code><code class="p">());</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This removes the need for self-assignment in separate build stages:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">);</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="n">informal</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">builder</code><code class="p">.</code><code class="n">preferred_name</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">);</code><code class="w"> </code><code class="c1">// no `builder = ...`</code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>

<p>However, this version makes it impossible to chain the construction of the builder together with invocation of its
setter methods:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id536">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">)</code><code class="w"></code>
<code class="p">.</code><code class="n">middle_name</code><code class="p">(</code><code class="s">"the"</code><code class="p">)</code><code class="w"></code>
<code class="p">.</code><code class="n">just_seen</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:265:19
    |
265 |       let builder = DetailsBuilder::new(
    |  ___________________^
266 | |         "Robert",
267 | |         "Builder",
268 | |         time::Date::from_calendar_date(1998, time::Month::November, 28)
269 | |             .unwrap(),
270 | |     )
    | |_____^ creates a temporary value which is freed while still in use
271 |       .middle_name("the")
272 |       .just_seen();
    |                   - temporary value is freed at the end of this statement
273 |       let bob = builder.build();
    |                 --------------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value</pre>

<p>As indicated by the <a data-primary="let keyword" data-type="indexterm" id="OEBPS/ch01.html.id537"></a><a data-primary="builders" data-secondary="support for building multiple items" data-type="indexterm" id="OEBPS/ch01.html.id538"></a>compiler error, you can work around this by <code>let</code>ting  the builder item have a name:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">builder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DetailsBuilder</code>::<code class="n">new</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="s">"Robert"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="s">"Builder"</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">time</code>::<code class="n">Date</code>::<code class="n">from_calendar_date</code><code class="p">(</code><code class="mi">1998</code><code class="p">,</code><code class="w"> </code><code class="n">time</code>::<code class="n">Month</code>::<code class="n">November</code><code class="p">,</code><code class="w"> </code><code class="mi">28</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"></code>
<code class="p">);</code><code class="w"></code>
<code class="n">builder</code><code class="p">.</code><code class="n">middle_name</code><code class="p">(</code><code class="s">"the"</code><code class="p">).</code><code class="n">just_seen</code><code class="p">();</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="n">informal</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">builder</code><code class="p">.</code><code class="n">preferred_name</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">builder</code><code class="p">.</code><code class="n">build</code><code class="p">();</code><code class="w"></code></pre>

<p>This mutating builder variant also allows for building multiple items.  The signature of the <code>build()</code> method has to
<em>not</em> consume <code>self</code> and so must be as follows:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Construct a fully built [`Details`] object.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">build</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Details</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The implementation of this repeatable <code>build()</code> method then has to construct a fresh item on each invocation. If the
underlying item implements  <code>Clone</code>, this is easy—the builder can hold a template and <code>clone()</code> it for each
build.<a data-primary="Clone trait" data-type="indexterm" id="OEBPS/ch01.html.id539"></a>  If the underlying item <em>doesn’t</em> implement <code>Clone</code>, then the builder needs to have enough state to be able to
manually construct an instance of the underlying item on each call to <code>build()</code>.</p>

<p>With any style of builder pattern, the boilerplate code is now confined to one place—the builder—rather
than being needed at every place that uses the underlying type.</p>

<p>The boilerplate that remains can potentially<a data-primary="macros" data-type="indexterm" id="OEBPS/ch01.html.id540"></a> be reduced still further by use of a  macro (<a href="#OEBPS/ch05.html.file_macros_md">Item 28</a>), but if you go down
this road, you should also check whether there’s an existing crate (such as the
 <a class="orm:hideurl" href="https://docs.rs/derive_builder/"><code>derive_builder</code></a> crate, in particular) that provides what’s needed—assuming
that you’re happy to take a<a data-primary="derive_builder crate" data-type="indexterm" id="OEBPS/ch01.html.id541"></a><a data-primary="struct types" data-secondary="using builder pattern with complex structs" data-startref="ix_strctbldr" data-type="indexterm" id="OEBPS/ch01.html.id542"></a><a data-primary="builders" data-startref="ix_bldr" data-type="indexterm" id="OEBPS/ch01.html.id543"></a><a data-primary="types" data-secondary="using builders for complex types" data-startref="ix_typbld" data-type="indexterm" id="OEBPS/ch01.html.id544"></a> dependency on it (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).</p>
</div></section>






<section data-pdf-bookmark="Item 8: Familiarize yourself with reference 
and pointer types" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_references_md">
<h1>Item 8: Familiarize yourself with reference 
<span class="keep-together">and pointer types</span></h1>

<p>For programming in general, a <em>reference</em> is a way to indirectly access some data structure, separately from whatever
variable owns that data structure.<a data-primary="references" data-type="indexterm" id="OEBPS/ch01.html.ix_refr"></a>  In practice, this is usually implemented as a  <em>pointer</em>: a number whose value
is the address in memory of the data structure.<a data-primary="pointers" data-type="indexterm" id="OEBPS/ch01.html.id545"></a></p>

<p>A modern CPU will typically police a few constraints on pointers—the memory address should be in a valid range
of memory (whether virtual or physical) and may need to be  <em>aligned</em> (e.g., a 4-byte integer value might
be accessible only if its address is a multiple of 4).</p>

<p>However, higher-level programming languages usually encode more information about pointers in their type systems.  In
C-derived languages, including Rust, pointers have a type that indicates what kind of data structure is expected to be
present at the pointed-to memory address.  This allows the code to interpret the contents of memory at that address and
in the memory following that address.</p>

<p>This basic level of pointer information—putative memory location and expected data structure layout—is
represented in Rust as a  <em>raw pointer</em>.  <a data-primary="raw pointers" data-type="indexterm" id="OEBPS/ch01.html.id546"></a><a data-primary="pointers" data-secondary="raw" data-see="raw pointers" data-type="indexterm" id="OEBPS/ch01.html.id547"></a>However, safe Rust code does not use raw pointers, because Rust provides
richer reference and pointer types that provide additional safety guarantees and constraints.  These reference and
pointer types are the subject of this Item; raw pointers are relegated to <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a> (which discusses <code>unsafe</code> code).</p>








<section data-pdf-bookmark="Rust References" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id33">
<h2>Rust References</h2>

<p>The most ubiquitous pointer-like type in Rust is the  <em>reference</em>, with a type that is written as <code>&amp;T</code> for some type
<code>T</code>. <a data-primary="borrow checker" data-type="indexterm" id="OEBPS/ch01.html.id548"></a><a data-primary="alignment" data-type="indexterm" id="OEBPS/ch01.html.id549"></a><a data-primary="lifetimes" data-type="indexterm" id="OEBPS/ch01.html.id550"></a>Although this is a pointer value under the covers, the compiler ensures that various rules around its use are
observed: it must always point to a valid, correctly aligned instance of the relevant type <code>T</code>, whose lifetime (<a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>) extends beyond its use, and it must satisfy the borrow checking rules (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>).  These
additional constraints are always implied by the term <em>reference</em> in Rust, and so the bare term <em>pointer</em> is generally
rare.</p>

<p>The constraint that a Rust reference must point to a valid, correctly aligned item is shared by  C++’s reference
types. However, C++ has no concept of lifetimes and so allows footguns with dangling references:<sup><a data-type="noteref" href="#OEBPS/ch01.html.id551" id="OEBPS/ch01.html.id551-marker">19</a></sup></p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id552">
<h1></h1>
<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++</code>
<code class="k">const</code><code class="w"> </code><code class="kt">int</code><code class="o">&amp;</code><code class="w"> </code><code class="nf">dangle</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w"> </code><code class="c1">// on the stack, overwritten later</code>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="c1">// return reference to stack variable!</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>Rust’s borrowing and lifetime checks mean that<a data-primary="borrow checker" data-type="indexterm" id="OEBPS/ch01.html.id553"></a><a data-primary="lifetime checks" data-type="indexterm" id="OEBPS/ch01.html.id554"></a> the equivalent code doesn’t even compile:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id555">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">dangle</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="kt">i64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="kt">i64</code> <code class="o">=</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w"> </code><code class="c1">// on the stack</code>
<code class="w">    </code><code class="o">&amp;</code><code class="n">x</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0515]: cannot return reference to local variable `x`
   --&gt; src/main.rs:477:5
    |
477 |     &amp;x
    |     ^^ returns a reference to data owned by the current function</pre>

<p>A Rust reference <code>&amp;T</code> allows read-only access to the underlying item (roughly equivalent to 
<span class="keep-together">C++’s</span> <code>const T&amp;</code>).  A
 mutable reference that also allows the underlying item to be modified is written as <code>&amp;mut T</code> and is also subject<a data-primary="mutable references" data-type="indexterm" id="OEBPS/ch01.html.id556"></a>
to the borrow checking rules discussed in <a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>.  This naming pattern reflects a slightly different mindset between
Rust and C++:</p>

<ul>
<li>
<p>In Rust, the default variant is read-only, and writable types are marked specially (with <code>mut</code>).</p>
</li>
<li>
<p>In C++, the default variant is writable, and read-only types are marked specially (with <code>const</code>).</p>
</li>
</ul>

<p>The compiler converts Rust code that uses references into machine code that uses simple pointers, which are eight bytes
in size on a 64-bit platform (which this Item assumes throughout).<a data-primary="stack" data-type="indexterm" id="OEBPS/ch01.html.id557"></a>  For example, a pair of local variables together with
references to them:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">x</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">pt</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="k">u64</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">ref_x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">x</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">ref_pt</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">pt</code><code class="p">;</code><code class="w"></code></pre>

<p>might end up laid out on the stack as shown in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_2">Figure&nbsp;1-2</a>.</p>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_2">
<img alt="Representation of a stack with 4 entries, each shown as a rectangle representing 8 bytes. Starting from the bottom, the first entry is labelled pt, and the 8 bytes it represents is split into two 4-byte values, 1 and 2. Above that, the next entry is labelled x and holds the value 0.  Above that is an entry labelled ref_x, whose contents are just an arrow that points to the x entry below it on the stack. At the top is a ref_pt entry, whose contents are an arrow that points to the pt entry at the bottom of the stack." src="data:image/png;base64,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">
<h6><span class="label">Figure 1-2. </span>Stack layout with pointers to local variables</h6>
</div></figure>

<p>A Rust reference can refer to <a data-primary="Box type" data-type="indexterm" id="OEBPS/ch01.html.id558"></a>items that are located either on the stack or on the heap.<a data-primary="heap" data-type="indexterm" id="OEBPS/ch01.html.id559"></a><a data-primary="stack" data-type="indexterm" id="OEBPS/ch01.html.id560"></a>
Rust allocates items on the stack by default, but the  <code>Box&lt;T&gt;</code> pointer type (roughly equivalent to C++’s
 <code>std::unique_ptr&lt;T&gt;</code>) forces allocation to occur on the heap, which in turn means that
the allocated item can outlive the scope of the current block.<a data-primary="C++" data-secondary="unique_ptr" data-type="indexterm" id="OEBPS/ch01.html.id561"></a>  Under the covers, <code>Box&lt;T&gt;</code> is also a simple eight-byte
pointer value:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">box_pt</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">20</code><code class="w"> </code><code class="p">});</code><code class="w"></code></pre>

<p>This is depicted in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_3">Figure&nbsp;1-3</a>.</p>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_3">
<img alt="The figure shows a representation of the stack on the left, with a single entry labelled box_pt. The contents of this entry is the start of an arrow that points to a rectangle on the right hand side, inside a cloud labelled 'Heap'. The rectangle on the right hand side is split into two 4-byte components, holding the values 10 and 20." src="data:image/png;base64,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">
<h6><span class="label">Figure 1-3. </span>Stack <code>Box</code> pointer to <code>struct</code> on heap</h6>
</div></figure>
</div></section>








<section data-pdf-bookmark="Pointer Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.pointer-traits-sect">
<h2>Pointer Traits</h2>

<p>A method that expects a reference argument like <code>&amp;Point</code> can also be<a data-primary="traits" data-secondary="pointer" data-type="indexterm" id="OEBPS/ch01.html.id562"></a><a data-primary="pointer traits" data-type="indexterm" id="OEBPS/ch01.html.id563"></a> fed a <code>&amp;Box&lt;Point&gt;</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">show</code><code class="p">(</code><code class="n">pt</code>: <code class="kp">&amp;</code><code class="nc">Point</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"({}, {})"</code><code class="p">,</code><code class="w"> </code><code class="n">pt</code><code class="p">.</code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="n">pt</code><code class="p">.</code><code class="n">y</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="n">show</code><code class="p">(</code><code class="n">ref_pt</code><code class="p">);</code><code class="w"></code>
<code class="n">show</code><code class="p">(</code><code class="o">&amp;</code><code class="n">box_pt</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">(1, 2)
(10, 20)</pre>

<p>This is possible because <code>Box&lt;T&gt;</code> implements the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>
trait, with <code>Target = T</code>.  <a data-primary="Deref trait" data-type="indexterm" id="OEBPS/ch01.html.id564"></a>An implementation of this trait for some type means that the trait’s
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref()</code></a> method can be used to create a reference
to the <code>Target</code> type.  There’s also an equivalent
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait, which emits a <em>mutable</em> reference to
the <code>Target</code> type.<a data-primary="mutable references" data-type="indexterm" id="OEBPS/ch01.html.id565"></a><a data-primary="DerefMut trait" data-type="indexterm" id="OEBPS/ch01.html.id566"></a></p>

<p>The <code>Deref</code>/<code>DerefMut</code> traits are somewhat special, because the Rust compiler has specific behavior when dealing with
types that implement them.  When the compiler encounters a dereferencing expression
(e.g., <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator"><code>*x</code></a>), it looks for
and uses an implementation of one of these traits, depending on whether the dereference requires mutable access or not.<a data-primary="type coercion" data-type="indexterm" id="OEBPS/ch01.html.id567"></a>
This <em><code>Deref</code>  coercion</em> allows various smart pointer types to behave like normal references and is one of the few
mechanisms that allow implicit type conversion in Rust (as described in <a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>).<a data-primary="smart pointer types" data-secondary="behaving like references" data-type="indexterm" id="OEBPS/ch01.html.id568"></a></p>

<p>As a technical aside, it’s worth understanding why the <code>Deref</code> traits can’t be generic (<code>Deref&lt;Target&gt;</code>) for the
destination type.  If they were, then it would be possible for some type <code>ConfusedPtr</code> to implement both <code>Deref&lt;TypeA&gt;</code>
and <code>Deref&lt;TypeB&gt;</code>, and that would leave the compiler unable to deduce a single unique type for an expression like <code>*x</code>.
So instead,<a data-primary="associated types" data-type="indexterm" id="OEBPS/ch01.html.id569"></a> the destination type is encoded as the  associated type named 
<span class="keep-together"><code>Target</code></span>.</p>

<p>This technical aside provides a contrast to two other standard pointer traits, the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> traits.  <a data-primary="AsRef trait" data-type="indexterm" id="OEBPS/ch01.html.id570"></a><a data-primary="AsMut trait" data-type="indexterm" id="OEBPS/ch01.html.id571"></a>These traits don’t induce special
behavior in the compiler but allow conversions to a reference or mutable reference via an explicit call to their
trait functions (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref()</code></a> and
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut()</code></a>, respectively).  The destination
type for these conversions <em>is</em> encoded as a type parameter (e.g., <code>AsRef&lt;Point&gt;</code>), which means that a single container
type can support multiple destinations.<a data-primary="String type" data-type="indexterm" id="OEBPS/ch01.html.id572"></a></p>

<p>For example, the standard  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> type implements the
<code>Deref</code> trait with <code>Target = str</code>, meaning that an expression like <code>&amp;my_string</code> can be coerced to type <code>&amp;str</code>.  But it
also implements the following:</p>

<ul>
<li>
<p><code>AsRef&lt;[u8]&gt;</code>, allowing conversion to a byte slice <code>&amp;[u8]</code></p>
</li>
<li>
<p><code>AsRef&lt;OsStr&gt;</code>, allowing conversion to an OS string</p>
</li>
<li>
<p><code>AsRef&lt;Path&gt;</code>, allowing conversion to a filesystem path</p>
</li>
<li>
<p><code>AsRef&lt;str&gt;</code>, allowing conversion to a string slice <code>&amp;str</code> (as with <code>Deref</code>)</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Fat Pointer Types" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id35">
<h2>Fat Pointer Types</h2>

<p>Rust has two built-in  <em>fat pointer</em> types: slices and trait objects.<a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch01.html.id573"></a>  These are types that act as pointers but hold additional information about the thing they are pointing to.<a data-primary="references" data-startref="ix_refr" data-type="indexterm" id="OEBPS/ch01.html.id574"></a></p>










<section data-pdf-bookmark="Slices" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id36">
<h3>Slices</h3>

<p>The first fat pointer type is the  <em>slice</em>: a reference to a subset of some contiguous collection of values.  <a data-primary="fat pointers" data-secondary="slice" data-type="indexterm" id="OEBPS/ch01.html.id575"></a><a data-primary="slices" data-type="indexterm" id="OEBPS/ch01.html.id576"></a>It’s
built from a (non-owning) simple pointer, together with a length field, making it twice the size of a simple pointer (16
bytes on a 64-bit platform).  The type of a slice is written as <code>&amp;[T]</code>—a reference to <code>[T]</code>, which is the
notional type for a contiguous collection of values of type <code>T</code>.</p>

<p>The notional type <code>[T]</code> can’t be instantiated, but there are two common containers that embody it.  <a data-primary="arrays" data-type="indexterm" id="OEBPS/ch01.html.id577"></a>The first is the
 <em>array</em>: a contiguous collection of values having a size that is known at compile time—an array with five values
will always have five values.  A slice can therefore refer to a subset of an array (as depicted in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_4">Figure&nbsp;1-4</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">array</code>: <code class="p">[</code><code class="kt">u64</code><code class="p">;</code><code class="w"> </code><code class="mi">5</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">];</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">slice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">array</code><code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="mi">3</code><code class="p">];</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_4">
<img alt="Representation of a stack holding seven 8-byte quantities, divided into two groups.  The bottom group is labelled array and covers the top 5 entries in the stack, which hold the values 0 to 4.  The top group is labelled slice and covers the bottom 2 entries in the stack. Of these 2 entries, the top one holds an arrow that points to the second element in the array chunk, counting from the bottom; the bottom entry holds a value labelled len=2." src="data:image/png;base64,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">
<h6><span class="label">Figure 1-4. </span>Stack slice pointing into a stack array</h6>
</div></figure>

<p>The other <a data-primary="Vec type" data-type="indexterm" id="OEBPS/ch01.html.id578"></a>common container for contiguous values is a  <code>Vec&lt;T&gt;</code>.  This holds a contiguous collection of
values like an array, but unlike an array, the number of values in the <code>Vec</code> can grow (e.g., with
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>push(value)</code></a>) or shrink (e.g., with
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop"><code>pop()</code></a>).</p>

<p>The contents of the <code>Vec</code> are kept <a data-primary="heap" data-type="indexterm" id="OEBPS/ch01.html.id579"></a>on the heap (which allows for this variation in size) but are always contiguous, and
so a slice can refer to a subset of a vector, as shown in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_5">Figure&nbsp;1-5</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">vector</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code>::<code class="n">with_capacity</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="o">..</code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">vector</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">i</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">vslice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">vector</code><code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="mi">3</code><code class="p">];</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_5">
<img alt="The diagram shows a stack on the left, and a heap on the right, both arranged as vertically stacked rectangles where each rectangle represents an 8-byte quantity.  The heap on the right has 8 entries within it: from bottom to top the first 5 contain values from 0 to 4 consecutively; the top 3 entries are all labelled (uninit).  The stack holds five 8-byte quantities, divided into two groups.  The top group is labelled slice and holds two entries.  Of these 2 entries, the top one holds an arrow that points to the second element in the heap chunk, counting from the bottom; the bottom entry holds a value labelled len=2. The bottom group of the stack is labelled vec and hols three entries. The top entry holds an arrow that points to the bottom element of the heap chunk; the middle entry has a value capacity=8; the bottom entry has a value len=5." src="data:image/png;base64,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">
<h6><span class="label">Figure 1-5. </span>Stack slice pointing into <code>Vec</code> contents on the heap</h6>
</div></figure>

<p>There’s quite a lot going on under the covers for the expression <code>&amp;vector[1..3]</code>, so it’s worth breaking it down into its
components:</p>

<ul>
<li>
<p>The <code>1..3</code> part <a data-primary="range expression" data-type="indexterm" id="OEBPS/ch01.html.id580"></a>is a  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expression</a>; the
compiler converts this into an instance of the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range&lt;usize&gt;</code></a> type, which holds an inclusive
lower bound and an exclusive upper bound.</p>
</li>
<li>
<p>The <code>Range</code> type<a data-primary="Range type" data-type="indexterm" id="OEBPS/ch01.html.id581"></a>
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/struct.Range.html#impl-SliceIndex%3C%5BT%5D%3E-for-Range%3Cusize%3E">implements</a>
the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/slice/trait.SliceIndex.html"><code>SliceIndex&lt;T&gt;</code></a> trait, which describes indexing
operations on slices of an arbitrary type <code>T</code> (so the <code>Output</code> type is <code>[T]</code>).</p>
</li>
<li>
<p>The <code>vector[ ]</code> part is an <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions">indexing expression</a>; the
compiler converts <a data-primary="array expression" data-type="indexterm" id="OEBPS/ch01.html.id582"></a><a data-primary="Index trait" data-type="indexterm" id="OEBPS/ch01.html.id583"></a>this into an invocation of the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a>
trait’s <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a> method on <code>vector</code>, together with
a dereference (i.e., <code>*vector.index( )</code>).<sup><a data-type="noteref" href="#OEBPS/ch01.html.id584" id="OEBPS/ch01.html.id584-marker">20</a></sup></p>
</li>
<li>
<p><code>vector[1..3]</code> therefore invokes <code>Vec&lt;T&gt;</code>’s
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Index%3CI%3E-for-Vec%3CT,+A%3E">implementation</a> of <code>Index&lt;I&gt;</code>,
which requires <code>I</code> to be <a data-primary="SliceIndex type" data-type="indexterm" id="OEBPS/ch01.html.id585"></a>an instance of <code>SliceIndex&lt;[u64]&gt;</code>.  This works because <code>Range&lt;usize&gt;</code> implements
<code>SliceIndex&lt;[T]&gt;</code> for any <code>T</code>, including <code>u64</code>.</p>
</li>
<li>
<p><code>&amp;vector[1..3]</code> undoes the dereference, resulting in a final expression type of <code>&amp;[u64]</code>.</p>
</li>
</ul>
</div></section>










<section data-pdf-bookmark="Trait objects" data-type="sect3"><div class="sect3" id="OEBPS/ch01.html.id37">
<h3>Trait objects</h3>

<p>The second built-in fat pointer<a data-primary="fat pointers" data-secondary="trait objects" data-type="indexterm" id="OEBPS/ch01.html.id586"></a><a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch01.html.id587"></a> type is a  <em>trait object</em>: a reference to some item that implements a particular
trait.  <a data-primary="vtable" data-type="indexterm" id="OEBPS/ch01.html.id588"></a>It’s built from a simple pointer to the item, together with an internal pointer to the type’s  <em>vtable</em>,
giving a size of 16 bytes (on a 64-bit platform).  The <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> for
a type’s implementation of a trait holds function pointers for each of the method implementations, allowing dynamic
dispatch at runtime (<a href="#OEBPS/ch02.html.file_generics_md">Item&nbsp;12</a>).<sup><a data-type="noteref" href="#OEBPS/ch01.html.id589" id="OEBPS/ch01.html.id589-marker">21</a></sup></p>

<p>So a simple trait:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">trait</code><code class="w"> </code><code class="n">Calculate</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">l</code>: <code class="kt">u64</code><code class="p">,</code><code class="w"> </code><code class="n">r</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">mul</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">l</code>: <code class="kt">u64</code><code class="p">,</code><code class="w"> </code><code class="n">r</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>with a <code>struct</code> that implements it:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">Modulo</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">u64</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">Calculate</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Modulo</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">l</code>: <code class="kt">u64</code><code class="p">,</code><code class="w"> </code><code class="n">r</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">(</code><code class="n">l</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">mul</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">l</code>: <code class="kt">u64</code><code class="p">,</code><code class="w"> </code><code class="n">r</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">(</code><code class="n">l</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="mi">0</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">mod3</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Modulo</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"></code></pre>

<p>can be converted to a trait object of type <code>&amp;dyn Trait</code>.  The <a class="orm:hideurl" href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>dyn</code> keyword</a> highlights the fact that dynamic dispatch is involved:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Need an explicit type to force dynamic dispatch.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">tobj</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Calculate</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">mod3</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tobj</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">result</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"></code></pre>

<p>The <a data-primary="stack" data-type="indexterm" id="OEBPS/ch01.html.id590"></a>equivalent memory layout is shown in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_6">Figure&nbsp;1-6</a>.</p>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_6">
<img alt="The diagram shows a stack layout on the left, with a single entry labelled mod3 with value 3 at the top, and below that a pair of entries jointly labelled tobj.  The top entry in tobj holds an arrow that points to the mod3 entry on the stack; the bottom entry in tobj points to a composite rectangle on the right hand side of the diagram labelled Calculate for Modulo vtable.  This representable of a vtable contains two entries, labelled add and mul. The first of these holds an arrow that leads to a box representing the code of Modulo::add(); the second holds an arrow that leads to a box representing the code of Modulo::mul()." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABW0AAAKXCAIAAAB2W/8VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzdf2xc9Z0v/JMrJKQSkjiPoNwWNo7NVRGETbo2W0oe3ThgN09XusR3ubZg75YYtbUfsbfF3WqxVboXsy3VDFW7pjzlPnaLMLRPQZ5lm3Cl3Qs24Kye0G7xtEkJCPTUTrJQVIIUJyFB4i8/f5x2cjIznhzP77Ffrz+imeM5Zz5zPDk+532+P9YsLi4GAAAAADH8u1oXAAAAADQMOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwBWlK6urjURtS4HAABWGjkCAAAA1Ez0Tlj1Vy/CRdV5G6DOpVKpdDqdTqfn5+fn5+eDIGhqamprawv/7enpaWlpqXWNAABA7WmPAKtdKpVqbW3t7e1NJpPT09NhiBAEwcLCwvT0dCqVGh4ebm1tHRgYqG2dAMSXTCbXLG18fLzWBS7PCvs49S+dTieTydbW1uh+bm9vTyaTyWSy1tVxzsLCQvhLqdCpmv96LEV7BFjVxsfHY/7VyeQL0XUXFhYyT4eGhspZGQBQC8PDw3nDgrDdYviCEydONDU1Vb00si0sLAwPD9e6ClYjOQKsXqlUqpToOpVKTU9PZ57KEQCg0Q0MDFzwJnPY7bE69UD9iN5Cc96rXwOsXlkBdlNTUyKRmJ2dXfyDqampycnJ/v5+gyMANJahoaHF842NjdW6qOKtsI9Tt1KpVDREGBoaOnHiRGafz83NJRKJ/v7+zs7OGhZJNfmvFxX29g3Vupba0x4BVqlUKhXtqtDS0jI7O5t1eyE8Uejp6QmCINr0AID45ufnwwZc0QNpZ2dnZ2dnW1ubS7LGFf4lTafTqVRqbm5uBWTu0e4Mk5OT4QlARktLy2q4B5tMJjNXiVNTU3n/h6bT6fb29vDx0NBQIpGoXn1QH+QIsEpljXeQSCQKt1F0pguwXPPz88PDw6lUKvdHmVihra1taGgo64KNhjA9Pb2SxpnLDH8QBEFnZ+eq/U5GT5Cmp6fznv9E/1NndhqsKvo1wCqV9WdPTABQXtPT0+3t7XlDhKh0Or2SrkVpXFntZWpYSW1Fc4Sl/m9G/1/nDkQNq4EcAVap6FQLQRDEHzApMwNQVk+H6DxAueM8hz3Kurq6opNIhXMUXfAkOwiC+fn5ZDKZtXpXV9fw8PBy7wNMT09HS+3q6lrW6gBxTE9Pd3V1ZY60LS0tiUQi2tU8kUhkLtVW7Y1f6lZbW1utS6iZaC4QzoGd9YJ0Oh19jRyB1UmOAARBTqxQRul0euPGjb29vclkcnp6OutP7/j4eG9vb/RsO1c4K/Lw8HDW6tPT08lkMpzOOn49WVNUrIaunkCVzc/PRzPKnp6eubm5oaGhaGI7NDQ0NTU1Ozvb09MjR6AeZI2aVMNKaisrF8jNEXKXVO4kinJZWFjI3EPauHFj4Rdn7lqFo2DkvYVW+KZU5v7Zxo0bMy9rb28fGBiIOeLYwsJCODt7ZiPh6iW2XwtPvNvb2zMl9fb2FrdN4yPAKpV1ipBKpfr7+yvxRgsLCxf8+xreuJudnc1dt6urq4w9D5PJZPT8wKDTQCX09vZmHhceg62trW1ycrIqRQEXljlJ6OzsTKfT4bVc1n/hsB1lU1NTW1tbeE04Pz+/mltwNITw9xWeUi4sLKTT6aV+ZfPz89GvQRHvtXHjxrynvuEQJOPj4z09PYWP/HnzgswIJuPj41NTU8udezWdTg8MDGSdVIfbDCdqmZycXFaAqD0CrFJZR4r4HQSamprCYcZzJ3fIKGJa6bw9hPNWlXmX5b7FwsJCtOVCOM/lcjcCUNj4+HjmwBV2Z6htPUB80b5I4ZlGVteGzLVcZ2dn5lRK14aGEG35VaBRQPRHxTUWu+D9s7C1QoEXFG4gkE6nC7fkXWqVAqf6RWxTjgCrVNaRcWFhob29fXh4+IJ/C/v7+6empqamprJy3KmIaNOGpqamoaGhycnJubm5TMfgEydOjI2NZcUNWcf03HGww4msM++yuLg4OzsbvxnF8PBw9PiY1cYYoCyiY76UONH6+Ph4Mpns7e1dk2NgYGBZXbrKKJlMZlr5ZrXsDX+Uu0qmkXBra2uBLVdn5JpS9ur8/Hz09dE/UtHhe7IUbsYcZtxZ9YSdAcv2mcv3cS74q0mn08lkMtqWu7W1NZlMLqtpYTgo0lK/psxvqhK9CaJnQZkzpehvMPM4eh5VuJKy7JOwiXsRX5K6+t8XKssOKUL0FlScHCFswhAEwdDQUHj6Gt3CYsTU1FR0Cy0tLf39/YlEInpunEgkovfwslrIZmlqaurv74+ePGedXS9rgN6FhYXe3t7Mt7S/v392djbc7OTkZOZ8PpxgKOY2g+D8XQCsKkvd0g9bWy139SIKyDrsNjU1RX+alXQkEokiPlRmeVaniba2tiIKBihsbm4uc5xpaWkpZVMnTpy44FlcU1NTnMN1KBpqjI2NFVFPzNw2zHmjMmfPhfdJZgudnZ0V+jgl7tXo7ze+3B2SUXiMnmX9fotQxMcp8Ks5ceJE4Zu3PT090aFG824h/qBFWecM5ZL5XvX39584cSK83xB9r/Ciq6mpKfo/YqlTlNL3yeLi4tTUVMzW5v39/bmrl/1/XylHkrLskFJE9+RSr8ncZMrdn0vlCDGdOHEiehMu62sT3fhSOyG688MvYZzaos3icr+rJ06ciO6W+PtfewRYvRKJRN4b8qlUqre3N8yGK1pAtE1gcH6cv7CwEL2n19LSUuKAiFkJq5bGQCVED1wljp7Y1NR0wTZT4V2mKkwbOT093draGueNwr5vla6naPWzV+fn5y84TnBYSa0anixLOp2+4CynqVSqvb29wD3nrO6HhVVoPILoqUjmy5zp2jA/P5/p1BD9Ii3VGb70fTI+Pt7V1bUy+k2UZYeUKHpYzltJOChG+Ljsh7KwiW7maYE2EUsdpvr7+zPpVdapcgGZo1ne0+msqmJuM9CvAVaztra2paKE4A+tm1pbW2OOK1ucpSL2rDctcQzIVCoV3aDhFYEKiZ7ul36dEw6vkHv7KJFIRDee1Wmr7FKpVFa/2aGhodz7kIlEYmhoqP6PrqXs1aw7utG/TdG+e1ly90nuKMLRaUGnpqaiVzvhdEXl3AUlfJyshoSZj9Pb25v58re1tUW/HtHm3PPz89H21YVrC39NuXdHx8bGhoaGqpAjBDldGzKXWOHvNPO5cj9RWfZJODBe5mlnZ2e0fcrY2Fj9/3fLqMSXpAjRPZY3rYj+X6vE7i19dp5oVXECpug0pUudTkerWkaIs9QhD1glZmdnL/jHOG+7tdL7NRTYSFZ7gQKNQuNsMJpWZDUDAyij6CGowIVlWRRoH5tXca2R5+bmonFzZ2dnEZ+rfvo1XNCy9mrMHKHwii0tLZm+ylHRv4Nxdkjpiv440YuQpUqN7ti8ze8Xz+9nsdRrKi2zEzJd4qNdGzKfIjyRyPyOcj91WfZJnJ0WHfa/nvs1lOtLUrrMAS1vF9fMMTxvkSX2awgttR/ibzzvFpZaPXokKXA6ndkt8Y822iPAatfW1jY7Ozs2Nlag913p09XmVWBKyKzlpdx2yBrJxvCKQOVEjzbLmkCrCNGz+co1A46OZtfW1ha/q3aDqsJenZ+fj/5JjY5zFhW95T49PV3pIeiKFk4aFz4OB3TI+7LoNHXj4+N121A/U1im2vACOJwAMvwt9PT0FD6RKMs+if7SW1palhq0tSHmm6yrL0km0YjeqA9F5+ao57YeRU8UUuBDZb5I8Q81cgQgCIKgv79/bm4uazDYqLK0m52enk4mkwMDA11dXRs3bty4ceNSR6us5UVf+YdjPmeelj7OAkCdaGtryxwbK3TCnXvFW4l3qStV2KvRXVq4fX70L3JF+xiWItqbukBSn9UHuwqDehQn91Qnc+mVGWgp92Is66tSln2S9T2JU3zdqqsvSfR/XO5MYZnHpXdAqJxl5QjLPXTEP9uXIwDndHZ2jo2Nzc3N5aYJYRJf3GbDkZM2btzY1dU1PDw8Pj4+PT1d0d68GePj49E3qud0GWC5MqfjFTqiZg0bubJbImRUeq9G/5gWvla5YF/uehC/P3nMWfdqK/eXnml9kPnRBa8wy7JPGuWaNo66+pJEd+ZS+7ylpaUsh7uwgUMymRweHg5voa1Zs6b0zRZtqblpLzg9bV5yBCBb2Hwu2rosVNxJTDqdDuOD6gQHWbICkUyjRIBGEZ6DZp3zbdy4MdrjoEKiN7tWWA5bq70a7dCXmZ1+KdErmfr847WwsJAp7IIfJ9rWoz4/TrBEeBS98szbqSH6P6Us+yT6PWlpaWno/pj19iWJzimzVI5QenAzPj7e3t6euYWWTCardgutauQIQH6dnZ1Z7eiKO6APDAzkrtjW1hZuv9J3t3I7MmRNAAlQRtFjWumt4sML3fAcNOtHCwsLVchnqzncQ9XUdq9mXXAWuD0YqlwlZRHdV3G+IdHr4focIuGCOUI0UMt7eV+WfbLcjdSzOvySZH6J0Yxjfn4+83alxKbhzBR5z35XGDkCsKSsOLaIo3nW/f+mpqZwaN/Z2dmpqanoND+Vk9UTb3p6um6bUwKNLnq0KfEksr29PfdCt4Ya/WImVPO9WnRIUZ9X3VFx7pnX+bdoqd9OdAT7pYaRyrvuCtgn5VUnOyRv14boSJCl5AjJZDLaIyz4w525RCIRtvYtesulizkRQ8ytyRGAJZV+KM86kk5OTi71BzhL1l+aUu4OZQ3bEwRBdDZmgDKKNtkt5cIv615WT09PdN74zGxe1WztXP/XsRdUD3u1oRuoFxbnL3Wdf4uiH2G5v6m8H38F7JPyqpMdEh3+IJMjZA4OpYQIWcN7JxKJEydOhHfOhoaG+vv7V1IHMTkCUEHRO/8tLS3xj55Z3edKvK2X1YEiawRygHKJHuWygtT4ssa1HRsbm5yczO2vW4VZbKNHzrK09q9h9+A62avRXZp3+vrSbxJW03KboK+k5vpLKcs+KWPLprxvVE31+SXJ/N/PDFtQlhkfs2amqNDxZFn9Lyo3XKscAVhS1uGmxAx1WX8MyjLEY1TuKAkrbLQboB5kDRJWXC+qrLHNYzbjuqAiTmejx+1SeoRlthMdPa5Ey/04Fdqry9XU1BSdV7LR/xJFh82LdjXPK51OZz5v4cH2aqWUO+GZdcuyT7I2UkphZf/ft9z/evX5Jcm6uo6+bymDLFZnlo3ol624FctCjtB4csfgmZmZqXVRrExZZ43VvHWQlVmU3nygv78/+geplGksWZFmZmYaboQz6lM0tSyuK36FbsdFzzhjXk5Ez4NTqVTR56DlHX4ytNyPU4m9WtznykQYCwsLRTdaqR/xJ+qLP/lfoyvLPilL46agAv/7ijiS1OGXpLOzM2/mG82CS1ShHCS6i+K8RfQ15R0gTI4Aq1QymSz85ySdTmedARc+WuU9XS764NXS0pLVzbjA6XjMP2OJRCL69IJ7AKAI/f39mdPQcObw5W6h7L0Jcjcbs5FXtD/awsJC0YPLRN+6XFfOy/04ldirxTU+j14dVWHyzkqLtuwo8HEWFhai/xdq1R6ksOhZwXJHBIx+8LLsk2iKV8oZS9n/9xVxJKnPL0m0a0Pmg1SuEUG5RH+Jy+3XkEqlynjAkSPAKjU9Pd3a2hqOXJ1KpTIH0IWFhenp6YGBgfb29qy7N1kH9KyD1/DwcHt7e9cfhAuzooes8+noFDu5st4unKMr6/CXTqcHBgZitizo7OyM1pz15wqgLLLGdh0eHi483ezAwEDWyX30yBk9PpcoOgt9/JnMowns9PR0V1dXEdczWVdEZflEy/04ldir0W3Gb+PW2dmZ2SHz8/PF7dL6ET09CGe8y/uyrq6uzO+ov7+//gdHKGWcxbLsk7a2tsz3ZGFhoejvSdn/9xVxJKnPL0nm/290Jq/4jSDy/jqix4RKzPs4Pz+f+XuRdcutgOjOL2dr3GWN70I9yP0lvvTSS7Uuisaz3NZiuYNaz83NLfXizAxJudPbdHZ2JhKJRCKRN/HNeou8x8e2trYwEcj8GUskEkt9rqwNzs7OZm1tamqq3LuWhvTSSy9d8AsJ8WUloS0tLeHA3ZkXTE5OZi7Rh4aGCq+eSCRmZ2ezXjM3N5c5DLa0tCy3qs7Ozrm5ucyPwsNy7rssLi6OjY1l/dcI5zDLetns7Gwikejs7Mz9e5H3E0X3RlhAtLZKfJxK7NXopU5nZ2fWBsMycv/QnDhxIusaqb+/P5wXOSoc5r2trS1rX1VIdP9Ed+YFZX2ctra26GfJmuO5paVlqY8TPa/o7+8v9fMsX/SrHuf0IHqSk/XrK8s+yf2eFP6Ps9ROK/v/viKOJOX6kpTRiRMngvNd8L981o7KfPCpqamw4OhXaKlfx1K7OnoGu1TB0RPjrK9cgdWzzsZzj96hubm5vMf2pThJajxBDjkCRVhWjpB7chPKPbnMPTIu642ytj87OxvnhkD8HGEx569pzLNVVjw5AmWXNbxrAU1NTVnr5l4/FBYzRyiQ/4aWOoOcnJyMX0zejSzrE8U8Mi/341Riry71d7BAGZni43efzpvvlF3ROcLi4uLs7GycfdvS0lJgyzXPEaJXicvNEfIma2XZJ/G/tEvttLL/7yvuSFKWHVJeWSeNuZFulgIfPHxBVjYxNDSU+Sxzc3NjY2NZyeNSxSQSiUw2sfiHlDZ6Spz7ayocQ2TdvWtrawvfIhS9vSdHWMlyv7hyBIqQFf0upaWlpfCf0qmpqZ6ensym2tra+vv7o6tkpadZR7GsBgK525+bm7tgEhGNOS6YI+T+Dch764zVRo5AJUxOTsY50i514R2/p27MHGExXzOxqAKn0XNzczHr6enpybuFEydOxEyW4ye8y/04ldirWYPv5CpwSXzBdUNLpfnlVUqOsBhj3/b09BS+ybzCcoTFcuyTcCMxRwoosNPK/r+vuCNJWXZIGWX9B4xzQrhUQHzBF1xwVy9rcvTcvVQ4RyhwNp5FjrCS5f6+5QgULcwgswYOCDsO5G3wWbSxsbHoW/T09CzrrGhqampoaCi6hZaWlp6enkQiUbXQmpVNjkDlhF0YslpXhT0dLngknJubW6ojWFNTU+IPlnW4DrcZrSezqQuue+LEiUQikfdEObzBdcGNhH93clcPd0h4iyz+Zynu45R9r4YbzM2M4vyKFxcXw7fLLaa/v7+IHVK0EnOEUO6N0/A3G2dn1jxHiH6xy5IjhErZJxnhdyz3UjPzjY2ztfL+7yv6SFKWHVIWWfeWYq41OTnZ09MT1t/U1JR7Tlsg94n+Z8/KEWJGnENDQ3mjljjdIi6YcSy18bzWLOa7LqWe5U5F9tJLL3V0dNSiFoAVYmZmZufOnVkL/YkEAJZrenp6fHw8Mw5leIvugoNHhjNQLiwshGM0RmejDEdVjDYBLs78/Pz4+Hg6nU6n02FtTU1NYXnL3bgcofHIEQDKTo4AABCTeR8BAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAENdFtS4AAIDaOHny5MGDB2tdBcAK1NHRUesSKmjN4uJirWtgedasWVPrEgBWBX8iWdlGR0dHRkZOnTpV60IAVqD169dPTEx0d3fXupCKkCM0HjkCQHX4E8nKtmHDBiECQOVs3bp1pbb5kiM0HjkCQHX4E8nK5owCoNJW6rmEcRYBAACAuIyzuBJ8Yeibm6/ZUusqABrYkTcO/zD59VpXAUvau3dvR0fHhg0bKrT9Bx/fe/0N2yu0cYDV49VXDtx318ocEyFKjrASbL5mi7/9ALCCjY6O9vX1jYyMDA4O1roWAFY7/RoAABrAqVOnvvKVrzQ3N8/MzNS6FgBWNTkCAEDDOHbs2M6dO7u7u48ePVrrWgBYpeQIAAANZt++fZs3bx4ZGTl58mStawFg1ZEjAAA0pAceeKC5uXliYqLWhQCwusgRAAAa1alTp+66665t27YZNAGAqpEjAAA0tkOHDu3cubOvr8+gCQBUgRwBAGAleOKJJ7Zt22bQBAAqTY4AALBCnDp16oEHHti2bdvevXtrXQsAK5YcAQBgRTl27Nh//s//uaOj4+DBg7WuBYAVSI4AALAC7d+//5Of/GRfX59uDgCUlxwBAGDFeuKJJ5qbm0dGRmpdCAArhxwBAKhHJ0+eHBkZaW5uXsOaNfv37y96T4aDJjQ3N5sbEoCyuKjWBQAA5NHR0XHo0KFaV7FyHDt2bOfOnTt27JiYmGhubq51OQA0MO0RAIC6Mzo6KkSohP3792/evHlwcNCgCQAUTY4AANQd0xZW1MMPP6xJAgBFkyMAAKw6p06dqnUJADQqOQIAwOqyadOmn/70p7WuAoBGJUcAAFgt1q9ff//99x89erS7u7vWtQDQqMzXAACwKuzZsyecSrPWhQDQ2OQIAFBZR48eHRkZmZiYqHUhK8GePXv6+vpqXUUNDA4OljKBxY4dO0ZGRjo6OspXEQCrlxwBACrl5MmTo6Ojo6Ojp06dkiOURXNz8+q8GN6wYUNxK27atGlkZGR1hi8AVIgcAQAqYu/evYODg8eOHat1Iaxe999//+DgYNEZBADkJUcAgDI7ePDg4ODg/v37a10Iq9fu3btHR0cNhQBAJcgRgIp45rHvnTl96pnHvhdduH3XrVdfu3VXz51r17k5xsp08uTJwcHBJ554otaFsHpt3bp1dHR0dfb+AKA65AhAOZ05ffKZxx7Jig8yDjz37IHnnn3i77+x5yt/e9vnv1zl2qDSRkZGwqEQal0Iq9T69etHRkYGBwdrXQgAK5wcoSTT09PpdHp6enp6enpxcbHW5UCN/eb1Q3/d2xnnlU/8/TcO/vxfvvGDf6h0SVAdMzMzfX19hkKghu65556RkRFDIQBQBf+u1gU0tnQ6PTw8PD09XetCoC5cceWm+B0WDv1s/xN//42K1gNVcPTo0Y6Ojp07dwoRqJUdO3YcOXJkdHRUiABAdWiPAJTN2nUbbvv8l8J0YOund2y78T9GOy88l3ry4M/3H3ju2cySZx773m2f/5KxEmhQJ0+eHBkZefjhh2tdCKvXpk2bJiYmDIXACnb2/VOv/uLAkTcPB0Ew/8bhs6dPbb5my9p16y//2B9tvmZLyzVbal0grFJyhIoLOz6Mj4/Pz89nFvb397e0tAwNDdWwMKiE7bt2H/z5v+z5yt9efe3WrB/t6rlzV8+dz9345Pcf+Gpm4XOpJw2UQCMaHR0dGRkxFAK1sn79+sHBwZGRkVoXAhVx9v1TL+x9+oW9Tx1587WsHx2efTnz+CNr1914y5/d+rkBgQJUmRyhggr0ehgfHw//nZycbGtrq3ppUClXXLmp8KgHu3ru/H+ff/bQz34/H97v3tYUnAYzMzMzODh46NChWhfC6rVnzx69GFipzr5/6geJr7+47+k4L/7gzOkX9z394r6nt7TfdMdf3Xv9DdsrXR40ohIH9cu7uhyhgnp7e6NtEHLNz893dXXNzs62tLRUrSqouW03/kc5Ao3o6NGjg4OD+/btq3UhrF47duwYHR3dtm1brQuBinhh79M/SNz3wZnTy13x8OzL993V/ambPzv44COXXLq+ErVB4wpvb5d3deMsVlCm20J/f//U1NTiH4yNjWXaICwsLAwMDNSuRgAuLBwKYfPmzUIEaqW5ufmnP/3pzMyMEIEV6ez7p0bv+9LDX/9S/hBh3UeDK/84uPYzwSf/PLjyj4Mr/zjvRv71xX++57ad828crmytgPYIFdXf3z89PT00NJTVc6G/v7+/v7+9vT2dTgd/aCiidwOrx5nT57qU5w6jAPVmYmJiZGSk9OkY1qxZU5Z68tJbfsWbmJiodQlQKWffP/W1vt25QyEEl7UGn/zz4Kqtwbor8qw2dyD4zYHg9eejy46/89bX+nZ/a2KfEROgorRHqKwCwx9EB1kMAwVYDc6cPvlc6snMUzkC9WxmZqajo+Ouu+6q/zkdT5069cADD/T19dW6EIDlyR8iXNYa9Hwn+Mux4Lpd+UOEIAhatwe77g0+/+Pg2s9EF39w5vTX+nZrlQAVJUeoGQ0QWIXOnD6Z/OoXzpw+GT694spN23fdWtuSoICdO3fu37+/1lUswxNPPHHw4MFaVwGwDD9IfD07RPjknwd/ORZcGe9Ow7orgl33Bj3fCS6+JLMsjBKO//atslYKnFPXOUIymUwmk2sient7U6lUEATpdHpgYCCzPJlMLiwsFNjU/Px8MplsbW3NrNLe3n7BtTJSqdTw8HBWJeGcC0WL+dawMhz62f5nHvveX9z0HzIjLK5dt+He7z5W26pg5ZmZmal1CQBxPfujseypGT7zN0HH3cve0JVbg78cCy5rzSz44Mzp0fv+W8kFAvnV7/gI4+PjucNCplKpVCrV2dmZNZni8PDw+Pj41NRU3okPkslk7qbS6XQ48mQikYh2MciysLDQ29ubO3djWMkyPk+O6Da1TWBFeuax7z3x99/I+6Mrrtx073cf06kByu7kyZO1LgEglrPvn/rJ9x86b9Fn/ia4bleRm1t3RdDzneDHA8Hpd8MFh2dffvZHY7d+zojmUH513R5hKblX9UEQzM/P553Noqurq/AsF8PDw11dXXl/tLCw0N7envftSpROp5PJZPi4s7NTjsCqsvXTO8b/16wQAQBWsx8kvn7e7Aw33ll8iBC6eG1w699FF/zk+w+dfZJLxPEAACAASURBVP/UUi8HitYAOUJTU9Pc3Fw4Y2JPT09meX9/f9bCVCo1Pz8fXXd4eDiTArS0tIyNjWUmX0wkEpnGC9PT03mzht7e3swG29raslYv7uI/bATR3t4e9msIqypiO9C4Dv1s/1/c9B+ioy1CfXrppZe2bhV4AZTf8d++dV6Phstag0/fWYbtXtYa3HhuOx+cOf3C3qcLvBwoTmPkCJkL/ugldyKRCB9MTk42NTWFj6NtB6anpzP3/Nva2mZnZ/v7+zM/HRoamp2dzWQByWQyK4OYnp7ObK2zszPv6tElhWWGZgjHZchsdqm+GLCynTl98vsPfPX7D3y11oVAIR0dHQcPHnz88cfXr19f61oAVpSfv/hP5z0vYkyEpXz6zmDdRzPPnv2RO3Y0gHA4v6zBAUPDw8MxO9SXOKjfslav3/ER8srkBUEQzM/PZ1KAzs7OcOdGBy+M7u5o1hDd2uTkZGvr70dkSSaT0ZwiusuWajJQSgTQ0tLS2dkpRGAFu+3zX77t818OH//m9UOHfrb/4M//JTPOYhAEz6WeXLtuw56v/G2NCoRY+vr6uru7R0ZGHn744VK289JLL5WrpCAIBgcHDx06VMYNAlTTC3ufOvfksta4szPEdOOdwfPfDh8ef+et+TcOt1yzpZzbh3ILr+Hz/ii8Cd3W1jY5ObnUxWOJg/oVsXqD5QhR0cggNyMIIjlCT0/PUnu8paWlp6cnfGUqlYrmBZn9WGD1UoQDOiSTycnJyc7OzrJvH+rK1dduvfrarbd9/su/ef3QoyNf/c3rv7/+eeax72278T9u/fSO2pYHhW3YsGF0dHRwcLCvr6/omSA7OjrKW1IZtwZQTcd/+9Z5cz1+8s/L/AZXb8/kCEEQ/OuL/yRHoM5d8HoznU53dXXNzs7mXvmGg/plNa6Pr7jVGzhHKCydTmeChsIDGbS1tWXaMqTT6fDF8VePaW5uLnwwPz8f5jrpdDp80/ALYahFVomrr936dz/8h7/u7fzd28fCJf/rH56UI9AQmpubZ2ZmZmZm+vr6jh07VutyWAlmZmZGR0dnZmZOnarxUHD33dVd2wJY1a7eXuYNXrw2aL0pmHs5fPbqLw7cUb5uE1AJYVv1zs7OrHvYyWRyfHw8vMgP+z5kevdnZA3q19/fn+l9n0wmMxeeSylu9QYYH6E40dYKhS/Ro7+nzFrxV1+ulpaWcGyF6Degt7e3jG8BdW7tug2Z/g5BEBz62b/UsBhYro6OjqNHj95///0GTaBEe/fu3blz5759+2oeIkAtrftocPHa8m/2sqszD4+/81b5tw9l1dbWNjU1NTQ0lNUwIbxyzCzMHa2gxEH9il59xeYI8Rtm5O0TUXSzkPiGhoYyUULYSKHS7wj1o/W6c90gz5w23T2NZ2Rk5OjRo3v27Kl1ITSwwcHBWpcAdSAyJmI5XXXuTEOOQENramrKXMkvLCxEb3gHJQ/qV/TqKzZHiD+iQdZvYrmrlyI6jWUVkguoH2vX6dpNw9uwYcPExMSvfvWrHTt0zGHZZmZm9I6BIAiCK7fVugKod9EG8llXryUO6lf06o2XIyz+QeGxCaOtDAp3CIlewGfWir96KUzWwKo195px5lkhtm3bNjMz89Of/nTTpk21rgUAaGB5p35sb29fqul6iYP6lbJ64+UIMbW1tWWygMJBQOanTU1Nmd0XXT13AoxyydsUAlaD//UPT2YeX31tWad6glro7u4+ePCgQRMAlu2939S6Aqi9VCq1cePG4eHh3Nkf0+l07rAIoRIH9Stl9RWbIwSRXgOpVGqpXgPRgQmivQyiT6enpyvUJCEaLGmbwArwXOrJJ/7+Gxcc7+D7D3z10M/OzZy3fdetFa4LqmHDhg0jIyMHDx40aALAMnx4piKbPfW7imwWKmB8fLy3t7eIe8wldo0vZfWVnCMMDQ1lHuf9xSwsLEQnSoi+Pnf1so9fkE6nM2lTU1NT4W4a0BB+9/axZx773l/c9B++/8BXn3nse1k//c3rh5557Hv9/0f7c6lzjRHWrtuwq+fO6pYJFdTc3DwxMfHSSy8ZNAEglrd/XZHNvjeXebil/aaKvAWUw8LCQrQNQk9Pz+Tk5OL5lppwocRb0aWsflEpb1znwhkWk8lkEATpdLq9vX1oaCg6GWZmKs4gCHLn2IiuPj8/39ramkgk+vv74w+d0NraGr5dVkIRzq4Rbjnz7nmnjYDG8pvXfz/qQZgUPPH337jgKn91/3eMucjK09HRMTMzMzExMTg4aEo/luull16qzhvt3Lkz8/gLQ9/cfM2W6rwvHHnj8A+TXz/3/O1DwZXl7uQ4dyDz0HebejY+Pp654Z1IJLKuHEM9PT15uzZkXZku9850Kauv5BwhCIJEIpFOp8MBDubn5wcGBgYGBnJf1tnZmZmCcanVgyDI219lKel0en5+Pnx94bU6Ozvzfl2g4Sx39MSh7zymUwMrWF9fX3d39+jo6AMPPFDrWmgkHR0d1X/Tzddsuf6G7dV/X1an62/Y/pPvP/TBmdO/f/7ac2XOEd6bC06/G327cm4cyiraan6pdgdLCQf1C7cwPT293IvKUlZfyf0aQlNTU3kzgoxEIjE1NVX06kuJOTpj4XeHxnLb578Uc9DE7btu/e7ktBCBFS8cNOHIkSMGTQCIuvGWPzv3ZO5AmUdJ+OUz0WfX/6kcgRWrxEH9il595ecIQRAMDQ3Nzc0lEoloz4W2trZEInHixIkL5i5DQ0OLi4uJRCK3pUe4kXA7S62VSCRy+yyEyxcXF7VEYCW57fNf/u7k9E9e/v/2fOVv93zlb3NfEC7/ycv/39B3HjNNA6tHOGhCrasAqCO3dN9+7smHZ4OfPbn0a5fpvbng9eczz27effsll5pJh/oVvVRcan7HAkoc1K/o1eu3X0N/f3/8dh1jY2NjY2MFXhAOdlDKRXtxq4erCAtYVdau23Db578cBEH4LwBAlutv2H75x646/s5bv3/+q38MrtsVXNZahk0/91D02a2fy9OpGepHT09Pphf8wMDA/Px8T09P1iyMBaZyKHFQv6JXXxXtEQAAgLpyz4OPnPf82f9eht4Nzz0UnanhUzd/tsUgi9S3lpaWaD/6ZDLZ3t6+5nzRSQZzZTWcHx4e3rhxY3T1ws0ciltdjgAAAFTb9Tds/9TNnz33/PS7QeqrJUUJM49GezR8ZO26Lw49WEKBUCVDQ0OFG9dfUNGD+hW9uhwBAACogcEHH/nI2nXnnr83F6S+Gm1QsAzPPRT86h+jC744/ODlH7+qtAKhSvr7+8PB9fL2iA/bLCw19F6ouEH9il69fsdHAAAAVrBLLl3/rYl9g/9l57lF780Fqb8Obrwz+JPb4m7lvbms7gxBENy8+/bzhnKERhCGCKW0LKjamIDaIwAAALXRcs2We755/kAJH54N9v+P4LH/Grz23AVWDhOEHw/khgiDWYMvAGWlPQIAAFAzt3TffvnHr3rwS3d+cOb0uaWn3w2e/3aw/9Hgyq3BlVuDy68+96NTvwvemwvmDgSn383dmhABqkCOAAAA1NL1N2z/1sS+h+/7b0fefO28H3x4Nph7OZh7Oc5GPrJ23ReHH9SdAapAvwYAAKDGWq7Z8vAzM3fc/TfnjbwY26du/uz3npkRIkB1aI8AAADUhTvuvvfWzw08+6OxF/Y+ffydt+KsEg6peP0N2ytdG5AhRwAAAOrFJZeuv+Pue++4+95XXzlw+JUDr/7iwPwbh88bOiEINn/ius3XXH/9DdtvvOWzl1y6vlalwqolRwAAAOrO9Tdsv/6G7XfcXes6gBzGRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEdVGtC6DxvLD36ePv/Fv4eMsN26+/YXtt64nv1VcOHH7lQPj48o/90S3dt9e2nviO//atF/Y9lXl6x9331rCY5Xrq0Ycyj2/ZfcflH7+qhsUsi6969TX0Vx1Ylh8k7jvyxuHw8S3ddzTQkapxK39h79Mv7P39MXbzNVu+OPxgbeuJb/6Nwz9M3Jd5+q2JfTUsZrm+1rc78/gLww+2XLOlhsUsi686BcgRWLYX9j51ePbl8PEddwcNdHF1+JUDTz367fDxlvabGuho+O47/5apPGi0i6to5Vtu2N5QOYKverU19FcdWJYjbxzOHGOv/9OGOcAGjVz58Xf+LVN5Yzn7/qkGrTwIgmjlZ98/VcNKlstXnQL0awAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4lqzuLhY6xpYnjVr1mQt2fyJ6y65dH3VCjjy5uGz758OH1/+sasu/9hVVXvrEh1/563j77wVPr7k0nWbP7GltvXEd/b9U0fefC3zdEv7TTUsZrkOz76ceVzl72qJfNWrr4Zf9ay3DtXzn8iOjo79+/fnLr///vtHRkaqXk75rfgPODMzs3Pnzrw/qtoXL/eMAoDyqudziVJcVOsCKIPcc9+qiV6uNJaz75+OXt82lsatvIbf1RL5qtdE41YOALCC6ddAkS65dF2tSyiSymuicYtXefU1buUAAKuBHIEiZdp7NxyV10TjFq/y6mvcygEAVgP9GlaCPXv2NDc317oKgAZ29OjRJ554otZVQM18Yeibm69pmLFUAOrWkTcO/zD59VpXUXFyhJWgr6+vo6Oj1lUANLCZmRk5AqvZ5mu2XH/D9lpXAUBj0K8BAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxHVRrQsAAAA4z9n3T736iwNH3jz86i8OBEFw/J23jr/z1pb2m4IguPzjf9RyzZYtN2xvuWZLrcuEVUqOAAAA1ItXXznw7I/G/vXFf8790eHZl4MgCGZffnFfEATB5R+76tbPDdzSffsll66vbo2w2unXAAAA1N6rrxz4Wt/u++7qzhsi5Dr+zls/TH79811/8tSjD519/1SlywMy5AgAAEAtnX3/1A8S9913V/fvWxwsxwdnTj/16LfvuW3n/BuHK1EbkEu/BgAAoGaO//atB7/8uSNvvpbnZ+s+Gly5NVh3RXDxJcH6K4Ljc8GHZ4L3fhO8/evsjbzz1uB/2XnPNx+5pfv2ahQNq5scAQAAqI35Nw5/rW/3B2dOn7f04kuCa3cF1+0KLms9b3nr9t8/+PBM8JsDwc+fDE6/G/35w1//UhAEogSoNDkCAABQA2ffP5UnRLj2M0HH3cHFawutefHa4LpdwXW7gteeC/Y/Gnx4NvMTUQJUgfERAACAGsgOES6+JLj1gWDXvRcIEaKu2xV8/v8Jrvzj6LKHv/6lV185UL4ygWxyBAAAoNqeevSh88ZEuPiSoOe753ouxHfx2qDnu8G1n4kue/BLd5rBASpHjgAAAFTV8d++9dSj3z73PAwRskZDWJZd90ZbJXxw5vRPvv9QCQUChcgRAACAqvpB8r7znu+4u6QQIXTr3wXrPpp59j9/PH78t2+Vuk0gHzkCAABQPcd/+9a/vvjP555f+cfBdbvKsN2L1wa77o0u+MmjmiRAIV1dXWuWMD4+XmBFOQIAAFA9+370f5/3/PyL/5JcuTXau+HnL/xT2bYMRMgRAACA6jmvMULrTcG6K8q59T+5LfPwgzOnRQlQCXIEAACgSo7/9q3j70SGLShigobCWrdHR0kwASQUMDU1tRgxNzcXc0U5AgAAUCXzb7x63vOry50jBEFw5dbMwyNvHC7/9mHVkyMAAABVcuTNyIX9Za3BxWvL/x6RqR8Oz75c/u3DqidHAAAAquTM6VPnnlx8SUXe4/KrK7JZ4A/kCAAAQJWc19HgMhf80JDkCAAAAEBccgQAAKBKrv/TyMCK7/2mdoUAxZMjAAAAtfDh2Yps9rh4goaRTCaTyeSaiN7e3lQqFQRBOp0eGBjILE8mkwsLC1mrz8/PZ14wPT291FtkXlOusi8q14YAAAAK2/yJLeeevDcXfHim/FM2vDeXebil/aYybxzKZ3x8fHh4OGthKpVKpVKdnZ1ZucDw8PD4+PjU1FRLS0sVa8xPewQAAKBKWq65/rznvzlQ/veYO7fNzddsKfBCqFt5GxfMz8/n5g41IUcAAACq5PKPX3X5x6469/z158r8BnMHot0lrr9he4HXQp1oamqam5tbXFxcXFzs6enJLO/v789amEql5ufna1TmOXIEAACgej5182fPPXn719FuCGXwy2cyDz+ydt2Nt/xZOTcOldHU1JTprTA2NpZZnkgkwgeTk5NNTU3h46XGQagmOQIAAFA9uz/3f573fOb7Zdv03IHg7V9nnt3SfXvZtgzVkskLgiCINj3o7OwMH+SOtlh9cgQAAKB6Lv/4VTfvjlzhv/3raCOC4n14JnjuoeiC7MACGk00MojmCzUnRwAAAKrqL+6+97zn+/9HGXo3PPvfoyMj/Ke/7L/841cVeDlQNDkCAABQVZd//Ko77v6b8xal/rqkKOG5h6I9Gi7/2FV/8Vf3Fng5UAo5AgAAUG133H3v5k9cd+75h2eD1F8Hry1/+obTvwt+PBC8/nx02T0PPnLJpetLrhHIT44AAADUwLcm9p03B+SHZ4Pnvx08+9+D07+Lu4lfPhP8eCCrIcM933zEdI+sQtUcf/Giqr0TAABAxiWXrv/a9578Wt/uD86cPrd07uVg7uXg2s8Ef3JbcFlr/jU/PBO89lzwq38MTr+b9ZN7vvmIaRpodIuLi0WsJUcAAABWvpZrtjw29cuv9e0+8uZr5/3g9eeD158PLr4kuHJrcNnV55Z/eCZ4+9BSIykIEVhtlpoksvStFSZHAAAAauaSS9c//MzMDxL3/c8fj2f/7MOzv2+ecCGbP3HdPQ/+Xy3XbKlIiVCvmpqaWlpawgRhenq69K1lHhdOJYyPAAAA1NgXhx988PG9W9pvWu6KH1m77o67/+bhZ2aECKxOnZ2d4YN0Op1KpUrcWltbW/igcCohRwAAAGrv+hu2f2ti34OP7715d6y+CZs/cd0Xhr752NQv77jbFI+sXj09PZnHvb29w8PDWQMlLKudQjSVGBgYiG5keHg4mUyGT+UIAABAvbj+hu2DDz7y7OH3Hnx871Kvue3zX/7hc798+JmZWz83YH5HVrnOzs6hoaHM02QyuXHjxjURy8oR+vv7M4/Hx8czG+nq6komk+l0OvyRHAEAAKg7BeZu/JP//ebLP37VUj+F1SaRSESjhFK0tLSMjY0t9dPMoAlyBAAAAGhgiURidnY2kUjkzrnQ2dmZSCQSicTcXP6JTrL09/fPzs5mBRM9PT2JRGJqaip8ar4GAAAAqLb+/v5oP4LCxsbGCrQUCIKgra2tra2tLA0Twk0lEomlXqA9AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBcF9W6AAAAVp0X9j59/J1/Cx9vuWH79Tdsr2098TVu5a++cuDwKwfCx5d/7I9u6b69tvWsEk89+lDm8S2777j841fVsJhl8VWnADkCAADV9sLepw7Pvhw+vuPuoIEuURq38sOvHHjq0W+Hj7e03+Tiqjoy+zwIgi03bG+oHMFXnSXp1wAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxHVRrQsAAKDGfpi475JL11fzHY+8eTjz+IW9T7/6iwPVfPdSNG7lx995K/P4yJuHv9a3u4bFlKj639iyaKyyfdWLc/b9U9V8u1qRIwAArHZH3nythu9+/J23ouf9DaRxKz/7/unDsy/Xuori1fYbW7QGLTvwVSeHfg0AANTGJZeuq3UJRVI5y9K4u13lpdi0aVOtS6gUOQIAwGq0Z8+eWpcQnH3/dK1LKJLKWZbG3e0qL0VfX1+tS6gU/RoAAFajiYmJvr6+mZmZWhcCS3rggQfyLt+zZ09zc3N1a4Hl6e7u3rZtW62rqBQ5AgDAKtXR0dHR0VHrKmBJS+UIfX19vrpQQ/o1AAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuOQIAAAAQFxyBAAAACAuOQIAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADikiMAAAAAcckRAAAAgLjkCAAAAEBccgQAAAAgLjkCAAAAEJccAQAAAIhLjgAAAADEJUcAAAAA4pIjAAAAAHHJEQAAAIC45AgAAABAXHIEAAAAIC45AgAAABCXHAEAAACIS44AAAAAxCVHAAAAAOKSIwAAAABxyREAAACAuC6qdQEAAADLsHPnzlqXAPVl69atg4ODfX191Xk77REAAACggR06dOiuu+4aHBysztvJEQAAAKDhPfzww0ePHq3CG8kRAAAAYCWYmJiowrvIEQAAgHq0fv36WpcA5CFHAAAA6lFHR0etSwDykCMAAAD1qGqDxgHLIkcAAADqUUdHx+OPP653A9Sbi2pdAAAAQH59fX19fX0zMzO1LgTqy+Dg4KFDh2r17nIEAACgrhkoAbJs2LChhu+uXwMAAAAQlxwBAAAAiEuOAAAAAMQlRwAAAADiMs5i/Tp69OjBgwc3bNhgXBkAAADqhByhvhw9enTmD44dOxYEwT333CNHAAAAoE7IEerCwYMHJyYmZmZmcqcAPXjwYE1KAgAAgFxyhFo6evTo6Ojo3r17w6YHee3fv7+aJQEAAEABcoTamJiYmJiYiJkRzMzM6NoAAABAPTBfQ7VNTEw0Nzffdddd8Rsa6NoAAABAndAeoXomJiZGRkYKdGHIa9OmTRs2bKhQSQAAALAscoRqmJmZGRwczB1DcSmbNm3q+IPm5uYLvl6DBYASOZACAMQkR6iskydPjoyMPPzww3FevHXr1r6+vu7u7jjZQdRXvvKVYooDAACAZZIjVNDBgwe7u7sv2JFh06ZNg4ODRcQHAAAAUGVyhEqZmJgYHBw8depUgdfs3r17cHDQXAwAAAA0CjlCRYyOjhbua7Bnz56RkRENEAAAAGgscoTy6+vre+KJJ5b66Y4dO0ZHR7dt21bGd3zw8b3X37C9jBsEWG1efeXAfXd117oKAIAGIEcos9HR0aVChPXr14+Ojvb19VW3IgAAACgbOUI5TUxMLNWdYceOHRMTEzoyAAAA0ND+Xa0LWDkOHjw4ODiY90d79uyZmZkRIgAAANDo5Ahl09fXl3d2hscff3xiYqLq5QAAAED5yRHKY2Rk5NChQ7nLH3/8cQMiAAAAsGLIEcrg6NGjDzzwQO7yPXv2CBEAAABYSeQIZTAyMpK7cOvWrbozAAAAsMLIEUp19OjR3Ike169fv3fv3prUAwAAAJUjRyjV6Oho7sLBwUGzMwAAALDyyBFKldt5Yf369UtNAAkAAAANTY5Qkr179+bO9Tg4OLhhw4aa1AMAAAAVJUcoyczMTO5CjREAAABYqeQIJcnNEXbv3q0xAgAAACuVHKF4J0+ePHToUNbCjo6OWtQCAAAA1SBHKN7BgwdzF8oRAAAAWMHkCMXLmyNs27at+pUAAABAdVxU6wIa2MmTJ7OW7NixoyaVQN06+/6p+TcOZ55+9GN/dPnHr6phPQAAQInkCMXLHWTRCIsQBMHx37718xf/6dVXDrz6iwMfnDmd+4It7Tdd/6fbb9l9h0wBAAAajhyhnHRqYJV79ZUDz/5o7F9f/OfCLzs8+/Lh2ZefevTbW9pvuqX7jlu6b69OeQAAQOnkCEAZHP/tWz9I3nfBBCFLGCi8sPepLww/2HLNlgrVBgAAlJFxFoFS/fyFf/rybR3LDREyDs++PPhfdj716EPlrQoAAKgE7RGAkjz16ENPPfrtPD+4rDVo3R5ctTW4rDW4eG0QBMGHZ4L35oLjvwnePhTMvZyznW+/+9u3Bh98pPIlAwAAxZMjAMUbve9LL+57OnvptZ8JPn1nsO6K7OUXrw2u3BpcuTX4k9uC078LXns++NUzwYdnMz8PNyVKAACAeiZHAIr0wt6ns0OEy1qDXfcGl7VeeOV1VwSfvjO47jPBcw8Fb/86s1iUAAAAdc74CEAx5t84/PDXv3Teoms/E/R8J1aIkLHuiqDnu8GNd0aXvbjv6Rf25rRxAAAA6oMcoXgbNmzIWnLy5MmaVALV960vn3fxH1z7mWDXvb8fB2G5Pn1n8Jm/iS74QeK+4799q4TqAACASpEjFG/btm1ZSw4ePFiTSqDKnnr0oePvHN2xfwAAIABJREFURK7zr/zjYNe9JW3xul3BJ/888+yDM6d/YvoGAACoS3KEctIegdXg7Pun9j05du75xZcEt/5dGbbbcXe0T8SL+57WJAEAAOqQHKF4HR0dWUsOHTpUi0Kgql7Y+/QHZ06fe77j7iK7M+TquDv6TJMEAACoQ3KEMjt69GitS4DKemHvU+eerPtocN2usm36yq3BtZ/JPPv5C/9Uti0DAABlIkcoXm57hECOwEp3/LdvHXnztXPPI4MalEcklfjgzGlRAgAA1JuLal1AY9u0adOxY8eiS2ZmZvLmC7AyvPrKgfOeX729zG9w5dbg4kuCD8+Gz5798diRNw+X+S0gn3fzjccxMjJS9ULiElsDALUiRyjJtm3bsnIEUzawsh1/59/OPbmsNVh3Rfnf48qtwdzL4cPDr7x8+JWXy/8WEM8DDzxQ6xIAAOqOfg0lMfUjq82rv4i0R1j30Yq8x2VXV2SzAABAOcgRSpKbIxw7dkxbU1aLCl3wX9564dcAAAA1IkcoSd6hEDRJgJKUaxZJAACgAuQIJdmwYcOmTZuyFs7MzNSiFgAImpuba10CALDCyRFKldskQY7AanH6dxXZ7FuHKrJZWAXWr1/f3d1d6yoAgBVOjlCq3Bzh0KFDJ0+erEUtUHGbr9ly7kmFcoQKbRZWgdHR0Q0bNtS6CgBghTPvY6nyDpGwd+/evr6+apcClddyzfXnnrz96+DDM+UfzuDtc+0R/reP/vt/f9XmMm8f8jn7/qkjb76WtXDHjh01KaYIzc3NIyMjOjUAAFUgRyhVc3Pzpk2bjh07Fl04MzMjR2BFOq89QhAEvzkQXLernG9w+nfB6Xczz/7yS1+7pfv2cm4flvDqKwfuuyu7R4B+agAAufRrKANDJLB6tFyz5fKPXXXu+evPlfkNfvZk9NmNt3y2zNsHAFaNNRFdXV21LgdWDjlCGeTmCMeOHTP7IyvVeQ0E3v51tBtCqU7/Lpg7kHn2qZs/e8ml68u2cQAAoBzkCGWQd4gETRJYqW7Zfcd5z2ceLdumZx4NPjybeXbr5wbKtmUAoJJSqdTw8HBXV1d7e3t4/7+1tbWrq2tgYGB8fHx+fr7WBQLlZHyEMmhubt66deuhQ+fdlZ2YmBgcHKxVSVA5l3/8qpt33/7ivqd///y9uWDm0aDj7lK3+9pzwdzLmWdb2m+6/obtpW4TAKiwZDKZNymYn5+PLkwkEkNDQ9UtDagU7RHKw+yPrCpfHP7mR9auO/f8V/8YvFbaQAnvzQXPfzu64I6/urekDQIAFbawsNDe3j48PBynucH09HQVSgKqQ45QHt3d2aN8B0Gwd+/e6lcCVXDJpeu/OPzgeYue/3bxUcLcgSD119EF/+kv+zVGAIB6trCw0NXVlU6na10IUANyhPLo6OhYvz57QDg5AivYLd2337z7/BkZn/928NxDwYdnlrehnz0ZPHt/dFiEzZ+4LjukAADqTG9vb1aI0NTUNDQ0NDU1deLEicXFxcXFxdnZ2cnJyf7+/paWllrVCVSC8RHKpru7+4knnoguMdQiK9vgg48ceePVI2++dm7R688Hbx8KbrwzuG7Xhdd/+1Aw82jw3lx02eZPXPetiX3lrhQAKKfx8fGsfgptbW2Tk5NZeUFbW1tbW1tPT08QBFouwEqiPULZ5A6RcOrUKU0SWNm+NbFvS/tN5y06/W7w/LeDx/5rMPNo/ikh35sLfvlM8Nh/DVJfzRsimOsRAOpcMpmMPm1qapqamirc6KCtra3CRQHVoz1C2XR3d991111ZC/fu3Zt36ARYGS65dP23Jvb9IHHf//zx+Hk/OP1u8Kt/DH71j0EQBOs+Gqz7aBAEwYdns4KDqE/d/NnBBx8RIgBAnUulUlkDKyYSiaamplrVA1Sf9ghls2HDhh07dmQt1LWB1eCLww9+7eEnLv/YVfl/fPrd4O1fB2//eqkQ4SNr131h6Jv3fe9JIQIA1L+sHg0tLS39/f1Fb21+fj6ZTHZ1dW3cuHHNmjVr1qxpb28fGBhIpVIxt5BKpQYGBtrb28PVN27c2NXVFXMWidD09HR0C5kazDEBS9EeoZy6u7v3798fXXLs2LGDBw9u27atViVBddx4y59d/6fbn/3R2L4nxz44czrmWh9Zu273nQO3fm5AggAAjSLr6rqzs7PoTSWTyeHh4ayF6XQ6nU6Pj4+3tbWNjY0V6BCRTqcHBgayRl5YWFiYnp6enp7O6nyR18LCQm9vb25ekKmhp6dnbGxMawvIoj1COeXtwjAxMVH1QqAGLrl0/R133/v0z+fu+eYjn7r5sx9Zu67Aiz9182fv+eYjj0398o677xUiAECjWFhYyLrPX/TABwMDA7khQlQ6nS4wtWThn8YRTl1ZuNFBKpXq6uoq+i1gpdIeoZyam5u3bt166NB5Y8vp2sBqc0v37bd03x4Ewfwbh8++f+rwKwcyP9r8iS2XrFt//Q3ba1cdAFC83Ov24uZ0TCaT4+PnDa7U0tLS0tKysLAQfYvwUn9ubi6rRUDYjmBhYSG6sKmpKQw1sjaylNypK8O2FVmrp9PpZDI5NDS0jI8HK50cocw6Ojr+//buP6qt80z0/XZCTkiMJdQGJzSoCFLPJOAEObi9hP5AnmJKu9YZkxtM3LPmjmVmjO/tvR3LY5+aabuwYE06uI1P5emcnGvcg8WZs25c7NzIM2t1qE3GotO4vqlJhH+QdJyAKLRu47RIMk5I48T3j91sv+wthJC2tPXj+1ldXdJG+9UjsR37ffbzPq8qjzA2NhYMBm02m0ERAYapfHCtJElkDQAAyBmqqbuU0LqGiYkJsRLBYrEMDg4q46hWK8zOznZ2dh46dEgcoa+vTyyLsFgse/fuFaf6s7Ozct+ExWJQbV1ZW1t76tQpJVsxPDwsliGQRwBUWNegM6fTqT3I7o8AAADIAfE3L4xB1blATCJImim9JEnHjh1T5S9UI/T29qrm+RaLJXb3R7EaQt63UnzHxsbG3t5e5amclYj9oYC8Qh5BZ3a7vby8XHWQpQ0AAACATJyTNzY2aisa5PoC5alqGq9KK9TW1i53w4iJiQlx5UJHR4e2k+LmzZvFp8k0YgByD3kE/TkcDtWREydOhEIhI2IBAAAAMsjw8LCYBVhsWYRqGi/WQaim9KpXxhmD+DRqDJWVlWJygTwCICKPoL+ouzZQkgAAAACoJuSLbfegat+oanwYzwgxqFZJLDaCeFzbGALIZ+QR9Bc1j0CLBAAAAEA1IY/RplH8kViPEGcWIAZVJkK7qGHJU4A8Rx4hJTZt2qQ6Qj0CAAAAkNiEPMa6hniyACqqTMSKRaiWPwBQkEdICW2LhKmpqWAwaEAoAAAAAADohzxCSrC0AQAAALlH1bZAonEAkJcKjA4gN9lstvLy8qmpKfGg3+93uVxGhQQAAAAkSbuIYHR0NEaPg6zQ29trdAhAliGPkCotLS0HDx4Uj9AiAQAAAFlNW48gdi7IUnv37jU6BCDLsK4hVbQtEsLhcCAQMCIWAAAAQAeVlZWqkoTl9k3UZiLiIW7KoBohgYUVqgKKHEiFAGlGHiFVtHkEiZIEAAAAZDnVJPzYsWPLOl2VBYixJ4L4IzF5oRoh+R0Z2dMRWC7yCKlSXFxcU1OjOkg9AgAAALKaKo8wOzvb19cX/+lxZgFUx8U3TT6PIFY3SDFzGQCiIo+QQtqSBOoRAAAAkNU2b96sWtrQ2dkZ/+KCOOfwquPiWaoRllsQIUUrqWDXCWBZyCOkkDaPMDU1FQqFjIgFAAAA0IHFYlE1Jpydnd24cWPsugClZqGyslKcxg8PD2sTARMTE/v371eeqk5RZQFGR0cTSCV0dHSI8e/YsSPGi2dnZ+mhAIjII6SQ3W7XHmRpAwAAALJaR0eHdnHB+vXrd+zYMTw8rNzbHx4e7uvr27Fjx0c+8hFxoi7O4SVJ2rFjh5gIGB4ebmtrEwsEVGkLVVpBHkHMO8iDbNy4McZH2Lx5s/j02LFjGzdu1BZHDA8P79ix44EHHiCPAIjY9zGFbDab2WwOh8PiwUAgELUFIwAAAJAVLBbL4ODgxo0bVcsB+vr64umVsHnz5sbGRmXSPjs729bWVllZWVlZOTs7q6prqK2tVeUdJEnau3evOOefnZ3t7Ozcv3+/vORhdHR0yXUKjY2Ne/fuFbMPw8PDw8PDFotFWTdB3wRgMdQjpJa2JCEYDBoRCAAAAKCb2traU6dOqRolxG9wcFDV5mBiYmJ4eFibRDh16pT29MbGxt7eXtXB2dlZORcQZ7OD3t5eVV2DOAhJBCAG8gippS09YF0DAAAAckBtbe0bb7yhLRbQslgsqmm/xWI5deqUanGByubNm2OkKvbu3atNJajeMcYLZKdOnVryNfJQqqwHkOdY15BaNptNdSQH8giHe78x+dpF+fHnW778+ZYtxsYTvxd8R1/wPSs/rnhw7fbOp4yNJ34Tr138fu83lKff8p4wMJjl+rpzk/L4LzufqnxwrYHBLAuXevpl9aUOAHnIYrEcOnSot7f32LFjo6OjExMTypoC+VZ/Y2NjZWVl1HyBvDhC7pI4Ojqq3P9vbGysra3dvHnzklP3vXv3bt68ua+vTzldXpXQ2NjY0dEhJyBUvRWiDtLR0SEPIscvH6+trZUbMWj3pwBAHiG1tHkEVbuEbDT52sWL587Ijx/+1KeNDWZZ3vzVL5TIs8v1a+EsjVySJDHy69ey6frnUk+/rL7UASBvWSyWeKoSoqqtrU3mVn9lZeWSBQVL0u5AASA21jWkljaPINEiAQAAAACQtcgjpBZ5BAAAAABALiGPAAAAAAAA4kUeIeXMZrPRIQAAAAAAoA/yCClnt9tVR/x+vxGBAAAAAACQLPIIAAAAAAAgXuQRUi4QCKiOFBcXGxIJAAAAAABJIo+QcuFwWHVEu9IBAAAAAICsQB4BAAAAAADEizxCamkXNUisawAAAAAAZC3yCKkVDAa1B1nXAAAAAADIUuQRUku7xWN5ebkRgQAAAAAAoAPyCKmlzSNQjAAAAAAAyF7kEVIoGAyOjY2pDjocDiNiAQAAAABABwVGB/AH+/fvlySps7Ozt7d37969RoejD4/Hoz3Y0tKS/kgAAABSxOfz+f3+QCAQCAS0210DQLYwm812u93hcLS0tFBFHlum5BE6OzuNDkFnoVDI6/WqDtbU1NhsNgOiAQAA0FUoFPJ4PF6vd2pqyuhYAEAH4XB4ZGRkZGSku7u7vLzc5XK5XC6jg8pQOb6uYceOHStWrFixYoVc75BObrdbm5J3Op1pDgMAAEB3Ho/HZrN1d3eTRACQk6ampnbt2mWz2Xw+n9GxZKJcziN0dnb29fUpj9OZSggEAgcPHlQdNJvN5BEAAEBWC4VCDodj165dLGEAkPOmpqYef/xxp9MZCoWMjiWzRFnXMDExcezYsYmJib6+vlOnTjU2NqY/LF2Mjo6KTycmJtLzvqFQKGoTBKfTWVxcnJ4YAAAAdCcnEbRtpFfedvtnV5k+cWfhmjvvMiQwAEje5XffCbx9/ZW3r1//4H3x+MDAQCAQ8Pv9zOYU0fMIudGtoLa2dnh4WHlaWVmZhjeV/37V1viZzWa3252GAAAAAFIhahLh3jvu2PbRe79othgVFQDoxX73ys2We+Y+eP/frkWO/PY3v3nvPeVHY2NjDoeDVIIil9c19Pb2dnR0KI/TsA3EYkl6SZLcbjfXHAAAyF7af+Q4P7p6sPJBkggAcknRbbd/0Wzpt61ptdwjHh8bG6PtoiKX8wiSJB06dOjmzZs3b95MQxIhGAwulkRoaGjgmgMAANnL5XKJ/8hZedvtB62V2+6518CQACB1im67/aurSzvvKxMPDgwMeDweo0LKKDmeR0gbn89nt9ujJhHMZjNNPgEAQPZSNZBeedvtf//xSvvdKw0MCQDS4ItmiyqV4Ha76bkokUdIXjAYbGlpefzxx6N2LTabzayiAQAAWU1VVvnV1aWfuLPQqGAAIJ2+aLY4P7paeRoOhylJkJQ8Ql9f34oPbdy4Ufnxxo0bV0Sj7KeoNTExsX///gceeEB58fr16/fv3z87OxtnTH19fTt27BDfrrOz89ixY7HPGh4ejhqqSN8tG4LBoNvtrqioOHHiRNQXyEkEu92u45sCAACkUzAYHBkZUZ7a715JQwQAeWXbPffee8cdylOPx0NJQpT9GpKxf/9+7V4Po6Ojo6OjnZ2d8TQ7jLpVxP79+yVJamxsHBwctFiM/6srEAh4PJ6BgYEYryGJAAAAcoDqztvfLCzxBYB88PX7rDun/3BPOhwO+3w+p9NpaEQG03Ndw8aNG2NvGNnZ2SkWOyzX8PDw+vXr469r0F0wGPR4PHa7fd26dbGTCDU1NSQRAABADvD7/crjzxSZ7rvjPxgXCwAYw373SrEkgf53f8gjdHR03PzQqVOnlB+fOnXqZjTKfoqKzs7O4eFh+XFlZaWyUcLNmzd7e3srKyvlHw0PD8fONUiSVFtbK55+6NCh2tpa+UcTExM7duyIelZjY2PUUA8dOrTM72SBUCjk8/lcLpfdbq+oqNi1a1fUZoqirVu3kkQAAAA5IBQKif/y+UyRycBgAMBAny0yK4/FBGt+0qceYXh4WF56IElSbW3tuXPnxETD3r17z507p+QC9u/fH6NPQUdHh+p0+UhjY6P89NixY0rCIkX8fr/H45FzBxaL5fHHHz948OCS6QNJksrLy59//nmv10tjRQAAkAMCgYD4dB17NADIV58VEqnhcDgYDBoXi/H0ySOITRCjtjCwWCyDg4PKUyXpoKVULqiIZQUxujwmSU4BbNiwYdeuXXHmDmRms3nfvn2BQKClpSVFsQEAAKSZ6h/KLGoAkLc+UbhgnxryCDpQ8gibN29eLBFQWVm5efNm1evjJ56eonqEYDC4bdu2qNs3xiBnEOS9GyhDAAAAuUT8h7KdYgQAeazottuNDiGD6JBHGB0dVXofKosXolJ+Ojs7Ozo6utw3SvL0JS23W0ZNTc2RI0fIIAAAAAAA8ocOeQRxA4XYeQSxVCGBbReSPF13oVAoGAyydygAAAAAIH8UJD9EjKaJKtq+CcuS5OlLamlpcbvd8a9rmJqa6u7u7u7u3rp1q9vtttlsqYwulm9sM6wpw7PPfOfZZ75j1Lsn4+K5M3+6tsToKBKUvZEbeK0miUvdENkbOQAAQA7ToR5hsYYIWkkWEaS6BsFms/n9/vLy8uWeODAwUFFR4XQ6qU0AAAAAAOQ2HfIIYplA7LYFYuVCAsUFSZ4eD7vdHgwGJycnT58+vW/fvk2bNpnN5qVPkyRJkgYGBmw2m8fjSUVgAAAAAABkAh3WNdTW1losFrlYIHYeQfmpxWKJ3UkhKmWbhsROj5/NZrPZbA6HQ34aCAT8fr/f7z9x4kTsE8Ph8K5du3w+n8/no/MiAAAAACD3RMkjJNDOcPPmzX19fZIkHTt2bGJiIupKh4mJCXF7yOUGOjo6quQREjg9GXa73W63u1yuUCgk5whiJxRGRkbkJRJ2uz09Ef7l3r+teHBtet4LAHLS5GsXv7//m0ZHAQAAkAWWyCP09fXFM2nfu3evnEeQJKmtre3UqVOqdQezs7NtbW3i65cV5ejoaDKn66W4uNjpdDqdzmAw6PV6PR7PYk0Zw+HwunXrjhw54nQ60xBYxYNrH/7kp9PwRgAAAACAPBe9P0JjY6P8YHh4eMeOHWJVwvDwcGdn5/79+8XXV1ZWKnP70dHR9evXK2kFSZL279+/fv16ZVHD3r17Y7RmVIoOlNE6OzvXr1+vNEeIfXp62Gw2t9sdDAb37dsXo4HCtm3bvF5vGuMCAAAAACC1oucRxBv+fX19H/nIR1Z8aOPGjfv379f2Qejt7VWyDxMTEzt27FBO6ezsVLIAjY2Nvb29MQIaHh5eIVi/fr2Ys+jo6Ih9ejoVFxfL2YSdO3cu9ppt27b5fL50RgUAAAAAQOosWo8Qe7oubp2gOHXqVOyzent7T506taz4RIcOHTp06FDCp6dIcXGxx+N55ZVXFtsw0ul0BgKBNEcFAAAAAEAqLLrv4969e8+dO9fb26vqdCCnGM6dO7fYWW+88UZvb6+49KC2tra3t/d3v/tdjL4Gv/vd73p7e3t7e7UbMWzevLm3t/fmzZsdHR1xfSYj2O32QCCwadMm7Y/C4XB6uiQAAAAAAJBqsfZ9rK2tra2tXW5TQ7lXwnLPslgs8ilG9VBMXnFxsc/nczqdAwMDqh+NjY253W63221EXAAAAAAA6CZWHiE3iE0i09CgUW6sqE0ldHd3O51Om82W6gAAAACQpUrbWgvMJkmSKna7Lnf1XBk8nqI3stTXPdzfF+MFkwc804f7U/TuiIeOF4NeQ63p6Zqfnon/wrBuby8wmSYPeBJ7O2Sy3M8jKDtHaFdMpIjH4wkEAmNjY6rjbreb7RsAAACwmHuamyz1dUZHgYyg48WQ/FAFJtMjR/qKqqskSZo9c3bu0viSpxRVV1XsdskPXnXtuRGJJBMAMs2i/RGyi7zLQ2dnp7jf5PDw8MaNG5WWkGlrr1BcXOz1erX7QQ4MDASDwfTEAAAAAADJK7SWPfrcUTmJIElSlefpApNpyVOqPE/Ljy31dY8c6Su0lqU2SqRXjuQRjh07JknS/v37xf0mN27cODw8LL+gtrY2nW0a7Xa7y+XSHqceAQAAAEC2KLSWPdK/IAtwdejkksUFN8KRd6ZnlKdF1VWP9PctmX1AFsmRPMLo6GiMn9bW1g4ODqYtGJnL5dKWJJBHAAAASB1Lfd3nXjsv/6/+pZ/EeGX9Sz9RXlnS3JS2CDPE7JmzP37wEdX/UteOAVmqwGRSJREud/XE0+/gRiRyob3j6tBJ5UihteyRI6QSckeO5BHOnTt36tQp7baR8p6R586dS0OHRZXi4mJtScLU1FQgEEhzJAAAAHlCnKUUmEyLJQiKqqvEV1JxDUSlWo+w3B6Nr7r2iK8vqq5a09OlZ3wwTo7kESRJamxs3Lt377lz524KBgcHDdxI0ul0ag/6/f50xwEAAJAfVBkBZUW3iiq/wD1SQKtit0v8E5TYRg+Xu3rEqoSS5ibr9nZ94oOhciePkIFsNltNTY3qIHkEAACAFFFlBEqfbI36MlXveuoRAJWi6ipxwj99uD/hZS+vuvaI+ztU7HbxJy4HkEdILYfDoTrCugYAAIAUUc1PCkwmbUlCUXWV6uBdzGqAhZTdFiRJmrs0Hk9PhBjGF+77uKab1Q1ZjzxCamnzCFNTU0YEAgAAkPuUjMD8h73itS0SlGIE5TXcHQVEpW2tyh+KG5HIuGtPkgPOT89c7upRnlrq6/KwuWmOIY+QWjabTXuQpQ0AAACpoKxrUJZkq5YwSJJU/Fid6jX0RwBEqhUN88IOjgm7OnRSbJRAl4RsRx4htex2u9EhAACAfMHySeUm6tylcbmOWrWKocBkkjMLNyIR1aZ06Y0UyFAlzU1iMcKVH+i2G6i4OKKoukqb40MWKTA6AAAAAOhD3nPa7XZrV1bmAzEXcO3S+OyZs3LttKW+TmnzplRTz545Ky7YvstaFvumq6W+Tu48pxQv3IhEpg/3z10anz1zdllxWre3Fz9WJ06iZs+cDf307PTh/iXPXdPTVdr2h+aRkwc8MU55uL9PeYvYr9Sdjt+VrLSttWKPSx4tyc+S5FClba0FZlOhtUz5LSiuDp2cuzR+5QfHxetqSclcDCka6j7ho00f7l/Wx4ltfnrmyuBx5au7p7kpsesBmYA8QsqZzeZwOCweCQQC+fm3OwAASLWRkZENGzZs3brV7XZHXV+Zw1TLE94aOilnDUqam5SpVPGHs6zQwglMjKUNRdVVf9TTpe3XWGAyVex2SZI0d2n837t6xI70iylta13TE6XDnKW+zlJfV7HbpUsBuYF0/K4U1u3t8rmyit2uApMpsbZ/SQ71kOfpGKv6S5qbSpqbKna7pg/3xzOmjheDjkMpBTsyHYsRZNOH+5U8Qklz0+TTHh3zFEgn1jWknHZpQygUMiQSAACQJwYGBux2u9vtNjqQtLrDvCAXoNzqLKquktME4hxJXNQgLZ5HKG1rffS5o9qJsaiouurR545qb1CrrOnpijrZE2X18godvyuRdiG9WOmwLEkOFeds3Lq9/dHnjsZ+jY4Xg77XlZgouTp0UvdJ/vz0jJJFUuUskF3IIxiguLjY6BAAAECOC4fD3d3dNpvN5/MZHUuaFJYtmCyJHRBKn2yVJMlSXydPGlWLGiRJKjBHmUwudps3KnHFgVbFbteyJs9ZR8fvSlRoLYs6z1+1Nla2IkVDxT+pLqquEgsfVHS8GHS/roqFif2yykbiJ6bwYmedkMlY15ByIyMjqiM0X0TOu/CzFy/+7MULL7048drFt+cW/KW7dn19xYNrH/7kp+s+/yWjwgOA/DE1NfX44483NDR4PJ6c/xeINhcQ+rBFgjxdUSYtoZ+elRbeXtbOMAutZaqJ8dWhk28JPedLmpvua2sVb6iu6ema/elZ7V3rkuYm1Z3wK4PH3xo6qVRMlDQ33dPclL074en4XanMT8/ciES0v51rF5c9xU1+qPnpGbnjwPz0jKqepbSt9Z7mJvEDWre3R20uoOPFkIrr6i6hciFFzQtmz5yt2P2Hx5b6uskDqXgTpBx5BAC6uX4t/E//eOgF39E3fzW92Gsunjtz8dyZf/6ffXcXmeo+/6X/9JWvrb7fms4gASAPjYyMrFu3bufOnW63O6/qIq8OnZTntyXNTZdNJrkqQdIsapCi5SBUM7TLXT1XBhesFZf3sVMtubdub7/c1RN7qAvtHaoZmjzUdHVVlefpbFzaoON3pTV9uF91bz/h5n9JDqXauVB0ZfD4lcHjqg9oqa/Tvl7Hi0H366rAZFJybTcikRTVI4jDZuPVDhnrGgDo49lnvv3wXhxUAAAgAElEQVQXGx999pnvxEgiiN6ei/zriaN/+YVHPd/46vVr4aVPAAAk5+DBgzabzeNJpEFdVhDnJPKN7huRiDKzKn2yVb4XPXdpXHsbXHWbWtWQf/pwv2piLP5I7Idf2taqmhrJmxcoTycPeBa7zTt3afydLOyzqON3tdhZl7t6lNn+5AFPYk0W9R1qsfHFS0v76XS8GFJxXWn/BKWIMniByUQqIUuRR0itqNs451vzZOS8idcu7nzC8ewz31EtYYjTv544+hcbHz37wg91DwwAoBIOh3ft2mWz2fx+v9Gx6C/q6nd5CYMkScqN4qi3lFXniqXg8p6FMd5XdU9bVUZe/NitWvclh8pGOn5Xi7kyePzMpz7z4wcf+fGDjyT5Beo4VFTi1aWdIet4MaTiuhI7lb4XTuE2Cu/EXFKErEAeIbWibs1AHgG55AXf0a87N03+/JL6B3eulB6ol+r+XNp84Nb/Gv4PqapJMt2reu3bc5Fv7dz6T/94KE1BA0B+m5qa2rBhg8PhCAaDRseip6gTEu3GdfGs+hbv9GqbMqqIVQ+SpnWc+FT3XfQygY7fVQ6I/fF1vBhScV2JnUrnZ1JYjyB+S3dEa3GKzEd/hNTS1iOUl5cbEgmQCi/4jh785lfVR8sekaq+IFV/IcoJZTV/eDAzJv10QJo5L/7w+/u/OfHaRddT30tFqAAAlZGRkYqKin379rlcrtxomhB1QiJPXJUGeOK2c6K7Ft46XiVM0uJZJT53aVy5tb5q4dz4rnTVihtFx+8qKxRay0qam1SrOWSTBzximYCWjhdDVl9Xum8nifSjHiG1tGl+ihGQM86+8EN1EuHOlVLTf5Y2/5foSQRRWY20+b9Imw+oahP+9cRRqhIAIJ3kvSG9Xq/RgehgsQJpZWmDpFnUsNgETKxIj3NuHPVc1dOU3uM1io7fVYYrqq56uL/vU6d+uNhuixW7XeKWDVo6XgypuK6Y3iN+5BFSS1uPkPNbLiFPvPnLac83FiYRSh6Q/uzQ0hkEUVmN9GeHpAfqxWPf3//NCz97UY8YAQBxCYfD27Zts9vt2d40QdlzQTUdmj7cL6+H//GDjyzWV0+7XwMgstTXPfrc0dhpgmwn/sER1zjoThw8pY0YkDqsa0gtbR6BegTkBs83/q8FXRVLHpA2H5DuLFr2QHcWSX/aI/3o29L4rRtET331z//7qZdXrjLrESkAZBmHw5HwuWNjY8mcu2HDhk2bNnk8niz954pSj3Bj+TMTmr0hhkJr2cP9feKRyQOeuUvjql4bJc1N97W1Zm+uQZzSp7RtgTg4RRBZijxCCgWDwXBYvZsd9QjIAS/4jl48d+bW84STCIovfE16d0564w9jvj0X+X/+67e3dz6VXJgAkJVGRkYMfPcTJ074/X6Xy5V1TROSTwQUmEzKlGZ+ekapGy+qrlqyNaPY9E61VmK5Q8UvQxYF6PhdZSxlsw9JkuanZ863d0SN/OrQyUJrWYw8go4XQyquK/FDpbQFphL5jUgkW64BqLCuIYWiFgcmc5MByBDPPvPtW0/uXCl94WtJJRFkX/ia2Cvhn/9n35u/nE52TADA8oXD4e7ubrvdnl1NE5JfmCCOcE1Ywx/PhEp8zbWFPQKWO1RsYqlFSivP46fjd5WxxNTA5AFPwlNfHS8Gfa8r2Y1IZC4Fw6oUVVcpWT+SCNmLPEIKaRc11NTURH0lkEVe8B1981fCDH/dE1LJAzqMe2eR5PiKeODEP/7fOgwLAEjI1NTUtm3bsiuVoCNxNmWpr4td7FBgMonzTFWvwWUNtSSxCHzVWp2neQuSFHEXO+j4XWWmQmuZ+KGSyX3oeDHoe10p3hEm9ilaoCEOq2N5DtKMPEIKaesRWNSAHHD2X39468mdK6VH/1fdhn7g01LZI8qz/+9f/0W3kQEACZmamjI6hHiJ2+DFv+JanDWJMzFxW4cCk8m6vT3GINbt7Yudqx1qTU9XnLFFJc4eC0ymqLsGJGxBkiLue9E6fleLKW1rrX/pJ5977fznXjsfe/w0DJXMXpU6Xgz6XleKkDCxj72HZcKKlrlRKDITeYRUCYVC2l5HLGpAtrt+Lbxger/uCR1WNIiqbm338Oavpideu6jn4ACQMbKlkWGWllIm1gFe7P02Pz1zZfC48tS6vX2xGbt1e7s4Hb0yeFzbH0EcqqS56SHP0wmEJ7t2cVyc7Vu3t+vYJUG1PD7O29E6fleLnbWmp0vJPlTsdondCpYlsaHmp2dU33li7y7pejHoe10pxPSEpb5O9x4cBSZTSXOT/PhGJEI9Qvaiz2Kq+Hw+7UHyCMh2F15auCNjdZPOb1D9BWnkGend6/Kzf/7HQ3/SskXntwCimYyWtMr2PfCyWigUMjqE1LLZbA0NDca2VIytoaHB7Xb7/f5k9oBIJ903XJg+3F/S3KQMu6anq7i+7q2hk8pES9uc/0YkMn24f8mhSpqbVp364ZXB46oXF1VX3bXUtO1GJHJ16KQyUS+0lj363NHpw/2qoUqam5YcSks1qVvT3TV5wKN8XjmzUPxY3YX2DtWJOn5XWtp5u3V7+/Th/gT6/Cc81OyZs8rst6i66lOnfnhl8PjVoZPaPMiSPQV0vBh0HEohX2DKhy1pborz1xSn0idv5ZiuDp1ks4bsRR4hVbT/+iwvL8+Wmw/AYiZ/Lsy1TPdKpvv0f4+yGmXjhhdOHH3hxFH93wKIz4YNG4wOAbnM5/M5HI4MnKWXl5e73W6n0yllVTYt+TyCqm3h/PTM5a4e8R5vSXNTSXPTQ4uPcLmrJ+oNdu1QhdayhO+rq2aPBSZTMrfoRfL9YWW2X2gte8jztPbzFlrLtDUXen1X2veK+ptdtXbZOxQkM5T8nYtDJfyd63gx6HtdKd4S8gjW7e1XfnBcr9m+atnLW/GtakFmIo+QKtq/dylGQA5YsNBAl/aKWiWfUPIIAJDDiouLA4GA1+sNBoN6jen1epPsaLBv376s2/Exda4OnSzo6olz5fnlrp4Yq/2vDp2UXHt0qTyfn5551bXn4f6+5IfSmjzgsdQvkcFfVV2lTQHo+F2J5DUF2vn/tYvLXlefzFBzl8Yvx/3plqTjxaDjUOKYFR9uKllgMlXscV3u6tFl5NInW5Xvf+7SOIsashp5hJQIBALav8XJIyAHXI+Ebz0p+URK3mN1atITAJCR5Nv+evH7/QnnETZt2uTxeLK3djL5fR+jujJ4/Nql8T/q6YpRrz53afzfu3qW7Bh3dejkO09sqdjtSr4N/uyZsxfaO9Z0d+m+fH3u0viF9o7EkhQ6flei6cP9qhvsiS1qSHKoK4PH52dm9PrOdbwYdBxKMX24X0malLa1vjV0Mvk5v1wrIb5FkgPCWOQRUiJqESB5BCAu+jZuBAAspaamxuPx5NI/VOZnEtmUfrFMxNyl8Zef2GKpryuqrhK3G5BX+C/rtqo8Sy+0lpU0NxU/Vqed+E0e8EiSdCMcEVvoRTV75uxLG79U2tZaaC2L2vkv/qG0I5/51GdKn2wtaW4SMwJyW8TY0z8dvyvF9OH+G+FIxR6XPNrkAU/CU9Akh5K/c/nTFVVXiSsdFErzyCW/eR0vBh2HUj5F6ZOtym9/TXfXy09sSXJ1Q5VQNDF75mycBSnIWCtu3rxpdAw5yOFwqDon1dTUBAIBXQZfsWKF6shTR3wPf/LTugwOxPZ156aL5z5cdFD359Jjf67/e8yMScd26z8sgJywb98+t9ttdBSZS/svkNjMZrPb7Xa5Fl1N7Xa7u7u75cf2u1cetFYmGyKAbFBUXfXoc7dWuMglMAmPVrHbJWa7Xtr4pXi6Y2Sghp9fUB6fPn3a2PTrYv/BT89flOz7qL9QKKT9jeZSjh/4g3fnUjLsm6+nZFgAOUHfVQB5bufOncFgMEYSAUDemrs0LhZrWOrrEm4Podrvc/KAJ0uTCBCRR9AfixqQwyoeXHvrydXUTPgjv0nJsACy386dO7N39X5GaWhomJyc9Hg89FMEsJjJAx6xk0VpW2sCqYTStlaxLcLVoZN0RsgN5BH05/P5VEfMZnNLS4shwQD6uvf+j996MnM+Je8xk3FboAEwXE1NzZEjRzwej9GBZL3y8vLTp0/7/X4yMgCWdH5bh1g7sNxUgnV7u/h6edsLPeODceizqD9tHoFiBOSMtapOHG+8KD2ga2+OyK+lq28oz3b+7fc+37JFz/GBRVz42Yvf2KZO+NJCCLnEbDa7XC66SwCI341I5Hx7xyP9fcouFaVtrQUm06uuPUue+5DnabEV5fz0zLhrT5LNGpE5qEfQmd/vD4fDqoMUIyBnVD649u4ioZ316y/q/AaXFjTvpYEoAOhi69atwWCQJAKA5ZqfnjnfvqAqYVV1lbITx2IKrWWrhM0+tIMg25FH0Jm2GEGiHgG5pe7zX7r1ZPykFPm1bkO/Oye98pzyrOKPq1ffb9VtcADISw0NDa+88orX66UVAoDEzE/PvPzEFmXPznjKCuTqA/nx7JmzLz+xhSRCjiGPoDNtHqGmpoYliMglf/q/7Vjw/Eff1m3ol/9f6d3rwhv977qNDAD5p7y8/Pnnn/f7/Xa73ehYAGS3G5HIhfaOK4PHVc0XY5i7ND55wDN9uP9CewfLGXIP/RH0FAwGp6amVAfZoQo5pvLBtWvX1188d+YPz2fOSy8/Jz36RLLjzoxJZ/+H8mz1x6x0RgCAxMitEFwuFzUIAHS03C6JbM2Qw6hH0BOLGpAnXE/9w4LnI/9NbI6YiKtvSP+0oP3vX+7926QGBIB8tXXr1kAg4Ha7SSIAAFKEPIKevF6v6kh5eTnFhMg9q++3fvkr/3nBoWN/nfh+jVffkI79tbii4X/5ky8u6MIAAIiP1+v1er0sqAQApBR5BN2EQqGxMfU8ip0akKu+/JWvVfxx9a3n716Xju2WXn5u8TMW8caLqiTC6o9ZXU99T48YASDvkEEAAKQBeQTdRF3UQB4BOexb3hMLUgmSJI38t2UUJkR+Lf1Tl/RP+8Qkwt1Fpq///f9Yucqsa6QAAAAAdEMeQTfaPILZbKY5AnLYylXmKKmEmfPSsd3Ssb+WLv1Iencu+plvvCj96NvSf/8z6Y0z4uG7i0zf8p6ofHBtykIGAAAAkCz2a9CN3+9XHaEYATlPTiU89dU/v7V9g2zmvDRzXjr5HankAenOlVKZXZIk6err0rtz0sz5qENV/HH1zqf+gSQCAGQUsVnj5fl5AyMBAGQO8gj68Pl84XBYdZBiBOQDOZXw7DPffvaZ70T5sbyPwyK5A8V//LOO//R/fo3lDACQacR20dc/eN/ASADAWK+/uyCXmud74rCuQR/aYgSJegTkky9/5Wvf/9HLf7Jpy3JPXLu+/qkjvu2dT5FEAIAMpGrc+G9zEYMCAQCDvfL2ghW7eb4rH3kEfWibIzQ0NOR5jgr5ZvX9VtdT3/v+j17+j3/Wsfpj1tgvvrvI9CebtniOn/6W98TDn/x0eiIEACyXzWYzm2/leX9CHgFAvgq8fas1eENDg4GRZALWNeggGAxOTU2pDlKMgPy0+n7r9s6ntnc+9eYvpy/87MU3f/WL3/xy+s1f/kKSpNX3f/ze+62rP/bxigfX0gcBALJFS0vLwMCA/PjfrkW+uvr9ottuNzYkAEizX7/3ezGRylyPPIIOoi5qoDkC8tzq+62fv3/ZyxwAAJlGzCNc/+D9Y797a9s99xobEgCk2ffevCI+JY/AugYdaBc1lJeX5/mCGQAAkBtaWlrKy8uVp97fvqlqNgYAuS3w9nWxGKGhoUHVOyYPkUfQgbYegWIEAACQM9xut/j0765Mz7F3A4D88Pq781//5YI17Kr/JOYn8gjJCgQC2h0fKXQBAAA5w+l0ik3FXn93fucvJkglAMh5r787/3dXpsVdb3fu3Mk9Y4k8QvJojgAAAHKe1+sVN26QUwkscACQwwJvX/+rhf+hKy8vpxhBRh4hWdo8Qk1NDTs+AgCAXGKz2VQNoV5/d/4vgpePvPUbChMA5Jhfv/f7v/v1zM7pCbESwWw2+3w+Jnoy9mtIViAQUB2hGAEAAOQeh8Nx5MiRbdu2iQe9v33z2OxvP7vK9Jki07q7V7IlJIDs9ev3fv/K29d/MhcRuyrKzGaz3++nlb6CPEJSgsHg1NSU6iB5BAAAkJOcTqfNZmtpaRGbQ13/4P2h8OxQeFZ+uvK229cUFhoUIAAk4vL8/PXFS6vKy8t9Ph9JBBF5hKRoixEk8ggAACB3ORyOQCDgdDpHRkaivuD6B+8H3r6e5qgAIEU2bdrk9XpZzqBCf4SkaPMI5eXlXGQAACCH2Ww2v9///PPPl5eXGx0LAKRKQ0PD6dOn6YkQFXmEpGibLFLuAgAA8kFLS0swGDx9+vTWrVtJKADIGeXl5Tt37nzllVf8fj+V5othXUNSgsGg6gh5BAAAkD8cDof87+xQKCTXaQYCgVAoZHBYALAcNpvNZrNJkmS326k+iAd5hKTQZBEAAECSpOLiYvlfQfxbCAByHusaEqdd1CBRjwAAAAAAyGnkERIXtWaPMhgAAAAAQA5jXUPitJs1NDQ0GBJJmr3gO/rmr34hP177yU8//MlPGxtP/C787MWLP3tRfrz6Yx//fMsWY+OJ35u/nH7hxLPK0y9/5WsGBrNczz7zbeXx5zd9efX9VgODWRYu9fTL6ksdAAAgT5BHwLK94Hv24rkz8uMvf0XKosnVxZ+9+Owz35Efr11fn0WTq9/86hdK5FK2Ta7EyNd+8tNZlUfgUk+3rL7UAQAA8gTrGhKnrUegOQIAAAAAILeRR0ictj8CzREAAAAAALmNPAIAAAAAAIgX/REAAACQOP+HAoFAOBw2OhwASFB5ebnNZnM4HC0tLaxYj408AgAAAJYtFAp5PB6v1zs1NWV0LACgg6mpqampqZGRke7u7vLycrfb7XQ6jQ4qQ7GuAQAAAMvj8XhsNlt3dzdJBAA5aWpqatu2bTabzefzGR1LJiKPAAAAgHiFQqGWlpZdu3axhAFAzpuamnr88cepStBiXQMAAADiEgqFHA7H2NiY6vjK227/7CrTJ+4sXHPnXYYEBgDJe+Xtudffnf/JXER1fGBgIBAI+P1+tudTkEdInPYyCgQChkQCAACQalGTCPfecce2j977RbPFqKgAQC/2u1dKkjT3wfv/Ep498tab1z94X/nR2NiYw+EglaBgXUPitD08Q6GQIZEAAACkmjaJ4Pzo6sHKB0kiAMglRbfdvtlyz+ADf9y88D9uY2NjLpfLqKgyDXmExGlzUSMjI4ZEAgAAkFJut1tMIqy87faD1spt99xrYEgAkDpFt93+N/eVdd5XJh4cGBjweDxGhZRRyCMkLuqeoixtAAAAOSYYDHZ3d4tH/v7jlXIBMADksC+aLapUgtvtpghdIo+QDIfDoT3o9/vTHQcAAEAqqUp5O+8r+8SdhUYFAwDp9EWzpdVyj/I0HA5TkiCRR0hSTU2N6ojX6zUiEAAAgJQIBoMnTpxQntrvXklDBAB55aurS++94w7lqcfjoSSBPEJStCUJY2NjwWDQgFAAAABSQHXn7W8WlvgCQD746uqPKY/D4bDP5zMwmExAHiEpTqdTe5CSBAAAkDPENZv2u1fed8d/MC4WADDGZ4tMYkkCeQTyCEmx2+3l5eWqgxS6AACA3BAKhcRtGppNrGgAkKc+W2RWHtMUjzxCsrQlCeFw2O12GxAKAACArlQbUa1jjwYA+eqzRSblcTgczvM7x+QRkqXqYCw7ePAgG0ACAIBsp+r6xKIGAHnrE4UL9qnJ8+keeYRkFRcXb926VXvc6XTmeY4KAABkOzGPYKcYAUAeK7rtdqNDyCDkEXTg8XjMZrPq4NjYWNRSBQAAAAAAshd5BB0UFxdHbYgwMDAQdUMHAAAAAACyFHkEfbhcroaGBu1xUgkAAAAAgFxCHkE3Xq9Xu7pBkqSBgYGWlhZ6JQAAAAAAcgB5BN3YbDafzxf1RydOnHA4HHne0hMAAAAAkAPII+jJ4XAcOXIk6o/GxsbWrVsXtY0CAAAAAADZgjyCzpxO52KpBEmSuru7bTab3+9PY0QAAAAAAOiGPIL+YqcSpqamNmzY4HA4yCYAAAAAALJOgdEB5Can02mz2VpaWsLhcNQXjIyMbNiwoaamxuVysaEDAAAAJEkqbWstMJskSarY7brc1XNl8HiK3shSX/dwf1+MF0we8Ewf7k/RuyN5hvwG1/R0zU/PxD+sdXt7gck0ecCjbxjIBNQjpIrcWLGmpibGa8bGxrZt21ZcXOx0OunCCAAAkOfuaW6q2O2q2O0yOhBggQKT6dHnjpa2tVbsdhVVV8VzSlF1VcVul3V7+8P9fQUmU6ojzHZZt7sfeYQUstlsgUBg3759sV8WDocHBgbWrVtns9lcLtdimz4AAAAAQJoVWssefe6okj6o8jy9ZF6g0FpW5Xlafmypr3vkSF+htSy1UWYzt9tts9mMjmJ5yCOknNvtnpycbGhoWPKVU1NTBw8efPzxx1esWNHS0uLxeOihAAAAAMAohdayR/oXZAGuDp28EYnEPutGOPLO9IzytKi66hGqEqLx+Xw2m627u3ux5fAZi/4I6SDv0eD3+10u19jYWDynnDhx4sSJE/LjI0eO0EMBAABgSeKi8RuRyJlPfWaxV9a/9BNlVvOqa8/VoZPpiC9jzJ45++MHH1EdXNPTVdrWakg8WK70/AYLTCZVEiHOth03IpEL7R0PeZ4uaW6SjxRayx450nd+W8eSOYg8EQgEXC7XyMiI0YEkiDxC+sgdE3w+n8fj0feK+X7vN1auMus4YGyTP7+oPH7Bd/TCSy+m7a2T9OavppXHkz+/+HXnJgODWZbr1xZkKLMocpU0X6tJ4lJPPwMvddVbA8hS4g3PApOppLkpaoKgqLpKfCUV10BUqvUIy+39+aprzw0htVFUXbWmp+tV1x6do8w2oVDI7XYfPHjQ6ECSQh4h3VpaWlpaWvx+v9frHRgYiOcUu90e+wWTP7+kR2iJePNX0+KMJYtcvxa5eO6M0VEkKHsjN/BaTRKXuiGyN3IARlFlBIqqq6LmEZR7pDLKrQEtVUvFxDYQudzVI2f05KclzU1z29vzeSsQj8fjdruzbhWDFv0RjOFwOLxe7+zs7JEjR2Lv6SDFkUcwxMpV2fo3LpEbInuDJ/L0y97IARhOlREofTJ6jbelvk58Sj0CoFJUXWXd3q48nT7cn/AupK+69sxdGleeVux25eefOL/fb7PZdu3alQNJBIk8grGUHR8nJye/+93vbtoUpYI3ngaNhrh+LVuXNhG5IbI3eCJPv+yNHIDhVPOTApNJu0ddUXWV6uBdeTmrAWJQdluQJGnu0vjkAU8yo4279ohtEdZ0dyUzWtYJBoMOh2PDhg1TU1NGx6Ib1jVkBHnHR5fLJUmSz+fz+/2BQEDuoRBPMcLWrVuzbqcQAMgowWAwzrVmADKZkhGYn56RcwolzU3ivVBJKEZQXpOfd0eBxZS2tSp/KG5EIuNJdzSYn5653NXzkLAT5GK9S3JMKBTyeDzd3d1GB6I/8ggZR26gID+Wq1+WPMXpdDocjpRGBQC5ze/3k0cAcoCyruHq0Em5KttSXzd5YMFrih+rU72G/giASLWiYV7YwTFhV4dO3jN0UmmUYN3envN5BK/X63K5cmMVgxbrGjKaw+Gg0AAAACBOyk3UuUvjch21ahVDgckk1yPciETEaQwlCYCspLlJLEa48oME2yJoiYsjiqqrVG1Kconf77fb7du2bcvVJIJEPQIAAAByg5gLuHZpfPbMWfnmp6W+TlnaoNwOnT1zVlywfZe1LPZNV0t9ndx5TileuBGJTB/un7s0Pnvm7LLitG5vL36sTpxEzZ45G/rp2Xia2K8RdtGbPOCJccrD/X3KW8R+pe50/K5kpW2tFXtc8mhJfpbEhpLvz2s/0dWhk/JlY93eXtLcJGes5B9d+cFx8QJTZP5v8L62W91Jpw/3R/0UiZmfnrkyeFz5+Pc0NyV2PWSyYDDodrvzocKRPAIAAABygWp5wlsfFlGXNDcpc7DiDydmoYUTmBhLG4qqq/6op0vbr7HAZKrY7ZIkae7S+L939ai6MERV2ta6pidKhzlLfZ2lvq5it0uXAnID6fhdKazb2+VzZRW7XQUmU2Jt/xIb6nOvndcelD9RxW7X5AGP2E1A+ZF1e/v5bR3L+qSZQCnYkelYjCCbPtyv5BFKmpsmn/bomKcwltwKwePx5HANgog8AgAAAHLBHeYFuQDlVmdRdVWByXQjEhHnSFeHThYIr18sj7DYzF9UVF316HNHL3f1xN4YT7wRvZisXl6h43clEtfqK0cSu0+u41AKMTEhKjCZqjxPv/zEluyaJysFO5IkXR06qXvw89Mzc5fG5UyT/OcxN7okeL1et9ud5HYMbrd7Wa8PBoPJvF2SyCMAAAAgFxSWLZiEyx0Q5HlR6ZOt04f7LfV1cr5AXtSwII9gjpJHiGdirJBfudj0uGK3a8kkQlbT8bsSFVrLoqZ4Vq2tWm5JvI5Dxf+O8oWXisFTpFgoRkhRMcXVoZNKxUpRdVW25xECgYDL5ZI32ktSdm3rQJ9FAAAA5AJtLiAklCQo/y9JUuinZyVJEhcRaGeYhdYy1cT46tDJV117fvzgI/L/XnXtUc0/1/R0RS0oKGluUt0JvzJ4/EJ7hzhUVs+mdPyuVOanZ6LeEr92cdlT3OSHmp+eefmJLfInutDeIY42Pz0j/0Jf2vgl8ZNmXfLoLuGXkqL0ijhsVrdanJubczqd69at0yWJkHXIIwAAACA3KZPzkuamApOp9MlW1XGFNgehmvlf7upRzfavDp280N6hWl2vrZzXHrzQ3nG5q0ecTcmz7pef2JKl/RF0/K60tPfzE16JkORQ70zPKLfoZ8+cFXsHTB7wyL/Q+emZV0o1rt4AAAsOSURBVF17lDEXK4LITAUmk5JruxGJpKgeQRw2qxfybNmyJR/6KS6GPAIAAABygTgnkSfkNyIRZbpe+mSrPKObuzSuna6rJnuF1rLShV3rFyvCnz7cL85OVS33pA83L1CeKhNOrblL4+9kYR5Bx+9qsbMud/UoM/PJA57EmizqO5S0+HxYvOqkrJoqa/8EpYgyeIHJlEXfj8r169eNDsFI5BEAAACQC6Le+JWXMEhCP7yoKwhU54rd5uRt/GK8r+qetniuJEnFj92q3F5yqGyk43e1mCuDx8986jPygoIkv0Adh4pRyCD+6I5orTcykxjqe+EUtod8J+aSomyxcuVKo0OIzmazpeFdyCMAAAAgF0SdkGg3rotn1bdYQSA3ZYzxYtX9Z9Wuh+JT3XfRywQ6flcwltipdH4mhfUIWZpnUfn+97+/detWo6NQM5vNLS0taXgj8ggAAADIBVEnJKqJ67ywxF1018Li6lXC/DaeVeLia1YtnBvfla5acaPo+F0hT2TXXpiLue+++7xe7+nTpxsaGoyO5Q/MZrPX6y0uLk7De7HvIwAAAHLBYgXSoZ+eVdrCqxY1zE/PRF2eLR5c7txYNeCCNeepvMdrFB2/KxgrN6b3aeZwOPx+v9frdbvdU1NTyQyVTD6iuLjYbrc7nc70LGqQyCMAAAAgNyh7LqimQ6r2frHPBfKW+AdHXOOgO3HwlDZiSBun09nS0uLxeLq7uxMexO/36xdRyrGuAQAAALlAqUe4sfyZSfY2ewP0Ik7pU9q2QBw8Z4ogiouL3W735OTkpk2bjI4lHcgjAAAAIOslnwgQRxAbGcTTC1B8jaoJwnKHil+GLArQ8bvKNxnyG1Sk7lpVUT74jUgkx64Bm83m8/lOnz5dU1NjdCypRR4BAAAAWS/5hQniCNeENfzLnRtfW9gjYLlDxSaWWqS08jx+On5X2WX2zFl5/8hlbSGZgb9BxY1IZE7XyzWqouoqJWeXY0kEhcPhCAQC3/3ud81ms9GxpAp5BAAAAGABcTZlqa+LXexQYDIpfRwlTa/BZQ21JLEIfNVanad5C6a4cd8q1/G7ygcZ+BsUvSNM7MXflI7EYePZhDV7uVyuYDC4c+dOowNJCfIIAAAAyHri9orxr7gWZ03iBFjc1qHAZLJub48xiHV7+2Lnaoda09MVZ2xRiRPvApOptK01mdFUFkxx474XreN3tZjSttb6l37yudfOf+6187HHT+dQicnA36AoJEzsix9LSR6haJkbhWa14uJij8czOTmZOXtD6oU8AgAAAHJKYh3gxd5v89MzVwaPK0+t29sXm+9Zt7eL09Erg8e1/RHEoUqamx7yPJ1AeLJrF8fFuaJ1e7uOa+xVy+PjvB2t43e12FlrerqU7EPFblfFblc8gaV0qIRl4G9QJGZ2LPV1undwKDCZSpqb5Mc3IpHcrkdQ2Gw2v99/+vTp8vJyo2PRDXkEAAAAZD3dN1yYPtwvzvfW9HQ95HlamQJJklTS3PRwf584Eb0RiURdJ68aqqS56VOnfqi9GV5UXXXXUtO2G5GIONMrtJY9+txR7VAlzU1LDqWlmtSt6e4SP29RdZV1e/vD/X3aE3X8rrS0n05V1BA/HYdKWGb+BhcLTzxdF6VP3soxXR06mTObNcTD4XAEg8F9+/blRtOEAqMDAAAAAJKV/GxQ1fRufnrmclePWDtQ0txU0tz00OIjXO7qiXqDXTtUobUs4Zvh04f7S5qblM9bYDLpdV9dvj+s3MQutJY95Hla+3kLrWXamgu9vivte0X9za5aW7XcW9k6DpWkDPwNit4aOqmkD6zb26/84Lhes33Vspe34lvVkmPcbrfL5XK5XAMDA0bHkhTqEQAAAIAorg6dvNzVE+eLL3f1xFjtf3Xo5KuuPbpENT89o9dQWpMHPEu+JurCex2/K9H89EzUSey1i8teV6/jUEnKzN+g4urQSSXLUGAyVezRbelH6ZOtSvZk7tJ4nixq0CouLvZ6va+88kpWN00gjwAAAICsl/y+j1FdGTz+8hNbYneDm7s0/vITW8QeAVFdHTr58hNbdJk7zZ45e6G9IxV75s1dGr/Q3pHYuTp+VyLt8gfVMgpDhkpSZv4GFeIXVdrWqsvGDXINTtS3yE92u93v9z///PNZ2jSBdQ0AAADIKfMziUzPFstEyFNfS32dvLxcuaEqr/Bf1m1VeY5XaC0raW4qfqxOOz2TbybfCEeWnGnPnjn70sYvlba1FlrLou47EP9Q2pHPfOozpU+2ljQ3ia315baIsad/On5XiunD/TfCkYo9Lnm0yQOehKegOg6VvMz8DSqvLH2yVTl3TXfXy09sSTLhUiUse5k9czbOgpSc19LS4nA4PB6Px7N0IUlGWXHz5k2jY8DyrFixQnXk9OnTDofDiFgAIEf4/f4NGzaoDvJXJOB2u7u7u+XH9rtXHrRWGhsPgPQoqq569LmjylO5gCLh0Sp2u8RcyUsbv5SKWow0aPj5BeWxvlOwYDBos9n0Gi0NWNcAAAAAALhl7tK4WLlgqa9b09OV2FCq/T4nD3iyNImQUtmVRJDIIwAAAAAAVCYPeMRuF6VtrQmkEkrbWsW2CFeHTtIZITeQRwAAAAAAqJ3ftqAZ5HJTCdbt7eLr5y6Nx7+pBzIceQQAAAAAgNqNSOR8uzqV8JDQMTGGhzxPi5UI89Mz4649huyOgVQgjwAAAAAAiGJ+ekaVSlhVXaXsxLGYQmvZKmGrCO0gyHbkEQAAAAAA0c1Pz7z8xBZlz854ygrk6gP58eyZsy8/sYUkQo4pMDoAAAAAAEDmuhGJXGjvWNPTNT89IzZfjGHu0vjkAU+ByTR5wJPq8JB+5BEAAAAAAEtYbpdEtmbIYaxrAAAAAAAA8SKPAAAAAAAA4kUeAQAAAAAAxIs8AgAAAAAAiBd5BAAAAAAAEC/yCAAAAAAAIF7kEQAAABCdzWZTHl+enzcuEABABiGPAAAAgOjEPML1D96f++B942IBACMF3r4uPhX/85iHyCMAAAAgOtU/lF9Z+M9oAMgfl999R3xKHgEAAACIwmazlZeXK09/MhcxMBgAMNBQeFZ53NDQYGAkmYA8AgAAABblcDiUx0Ph2V+/93vjYgEAYwTevv76u7d6xLS0tBgYTCYgjwAAAIBFuVwu8emR375pVCQAYJQjv/2N+JQ8AnkEAAAALMput4sVvEPh2QBdEgDkk2Ozb4n/3du6dWueN0eQyCMAAAAgNrfbLT79+i+nxPpeAMhhr787f+StBXVYqv8k5ifyCAAAAIjF4XBs2rRJeXr9g/f/6hcTpBIA5LzX353/q19MXBe2vN23bx/FCBJ5BAAAACzJ6/WKGzfIqYR/Y/sGALnr2OxbfxG8LCYRampqKEaQkUcAAADAEoqLi30+n9lsVo5c/+D9b/5y6huscQCQcwJvX985PfEPb14RD5aXl/v9foMiyjgrbt68aXQMAAAAyAKBQMDhcITDYdXxT9xZ2Gy2rLnzrk8UFhbddrshsQFAMn793u9//d57r7w99y+R2d+8957qp+Xl5T6fz263GxJbBiKPAAAAgHgFAgGn0zk2NmZ0IACQJjU1NX6/v7i42OhAMgjrGgAAABAvu93u9/t37txpdCAAkA779u0LBAIkEVSoRwAAAMCyBYNBt9s9MDBgdCAAkBJbt251u93szhAVeQQAAAAkKBgM+nw+n88XCAS0fRMAILuYzWaHw9HS0tLS0kINQgzkEQAAAKCDUCgUCASMjgIAEuRwOIwOIWv8/z/7xpVGc6awAAAAAElFTkSuQmCC">
<h6><span class="label">Figure 1-6. </span>Trait object with pointers to concrete item and vtable</h6>
</div></figure>

<p>Code that holds a trait object can invoke the methods of the trait via the function pointers in the vtable, passing in
the item pointer as the <code>&amp;self</code> parameter; see <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a> for more information and advice.</p>
</div></section>
</div></section>








<section data-pdf-bookmark="More Pointer Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id38">
<h2>More Pointer Traits</h2>

<p><a data-type="xref" href="#OEBPS/ch01.html.pointer-traits-sect">“Pointer Traits”</a> described two pairs of traits (<code>Deref</code>/<code>DerefMut</code>, <code>AsRef</code>/<code>AsMut</code>) that are used when dealing
with types that can be easily converted into references.<a data-primary="pointer traits" data-type="indexterm" id="OEBPS/ch01.html.id591"></a><a data-primary="traits" data-secondary="pointer" data-type="indexterm" id="OEBPS/ch01.html.id592"></a>  There are a few more standard traits that can also come into
play when working with pointer-like types, whether from the standard library or user defined.</p>

<p>The simplest of these is the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a> trait, which
formats a pointer value for output. <a data-primary="Pointer trait" data-type="indexterm" id="OEBPS/ch01.html.id593"></a>This can be helpful for low-level debugging, and the compiler will reach for this
trait automatically when it encounters the <code>{:p}</code> format specifier.<a data-primary="Borrow trait" data-type="indexterm" id="OEBPS/ch01.html.id594"></a><a data-primary="BorrowMut trait" data-type="indexterm" id="OEBPS/ch01.html.id595"></a></p>

<p>More intriguing are the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a> traits, which each have a single method
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a> and
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a>, respectively). This method<a data-primary="AsRef trait" data-type="indexterm" id="OEBPS/ch01.html.id596"></a><a data-primary="AsMut trait" data-type="indexterm" id="OEBPS/ch01.html.id597"></a>
has the same signature as the equivalent <code>AsRef</code>/<code>AsMut</code> trait methods.</p>

<p>The key difference in intents between these traits is visible via the  blanket implementations that the standard
library provides.<a data-primary="blanket trait implementations" data-secondary="AsRef and Borrow traits" data-type="indexterm" id="OEBPS/ch01.html.id598"></a><a data-primary="blanket trait implementations" data-secondary="AsMut and BorrowMut traits" data-type="indexterm" id="OEBPS/ch01.html.id599"></a>  Given an arbitrary Rust reference <code>&amp;T</code>, there is a blanket implementation of both <code>AsRef</code> and
<code>Borrow</code>; likewise, for a mutable reference <code>&amp;mut T</code>, there’s a blanket implementation of both <code>AsMut</code> and <code>BorrowMut</code>.</p>

<p>However, <code>Borrow</code> also has a blanket implementation for (non-reference) types: <code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code>.</p>

<p>This means that a method accepting the <code>Borrow</code> trait can cope equally with instances of <code>T</code> as well as references-to-<code>T</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">add_four</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">std</code>::<code class="n">borrow</code>::<code class="n">Borrow</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;&gt;</code><code class="p">(</code><code class="n">v</code>: <code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">borrow</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">4</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">add_four</code><code class="p">(</code><code class="o">&amp;</code><code class="mi">2</code><code class="p">),</code><code class="w"> </code><code class="mi">6</code><code class="p">);</code><code class="w"></code>
<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">add_four</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code><code class="w"> </code><code class="mi">6</code><code class="p">);</code><code class="w"></code></pre>

<p>The standard library’s container types have more realistic uses of <code>Borrow</code>.  For example,
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>HashMap::get</code></a> uses <code>Borrow</code> to allow
convenient retrieval of entries whether keyed by value or by reference.</p>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a> trait builds on the <code>Borrow</code>
trait, adding a <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned()</code></a> method that
produces a new owned item of the underlying type.  <a data-primary="ToOwned trait" data-type="indexterm" id="OEBPS/ch01.html.id600"></a><a data-primary="Clone trait" data-type="indexterm" id="OEBPS/ch01.html.id601"></a>This is a generalization of the <code>Clone</code> trait: where <code>Clone</code>
specifically requires a Rust reference <code>&amp;T</code>, <code>ToOwned</code> instead copes with things that implement <code>Borrow</code>.</p>

<p>This gives a couple of possibilities for handling both references and moved items in a unified way:</p>

<ul>
<li>
<p>A function that operates on references to some type can accept <code>Borrow</code> so that it can also be called with moved items
as well as references.</p>
</li>
<li>
<p>A function that operates on owned items of some type can accept <code>ToOwned</code> so that it can also be called with
references to items as well as moved items; any references passed to it will be replicated into a locally owned item.</p>
</li>
</ul>

<p>Although it’s not a pointer type, the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> type is worth mentioning at this point, because it provides an alternative
way of dealing with the same kind of situation.  <code>Cow</code> is an <code>enum</code> that can hold either owned data or a reference to
borrowed data.<a data-primary="Cow enum" data-type="indexterm" id="OEBPS/ch01.html.id602"></a><a data-primary="clone-on-write" data-type="indexterm" id="OEBPS/ch01.html.id603"></a> The peculiar name stands for  “clone-on-write”: a <code>Cow</code> input can remain as borrowed
data right up to the point where it needs to be modified, but it becomes an owned copy at the point where the data needs to
be altered.</p>
</div></section>








<section data-pdf-bookmark="Smart Pointer Types" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id39">
<h2>Smart Pointer Types</h2>

<p>The Rust standard library includes a variety of types that act like pointers to some degree or another, mediated by the
standard library traits previously described.<a data-primary="smart pointer types" data-type="indexterm" id="OEBPS/ch01.html.id604"></a><a data-primary="pointers" data-secondary="smart pointer types" data-type="indexterm" id="OEBPS/ch01.html.id605"></a>  These  <em>smart pointer</em> types each come with some particular semantics and
guarantees, which has the advantage that the right combination of them can give fine-grained control over the pointer’s
behavior, but has the disadvantage that the resulting types can seem overwhelming at first (<code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code>,
anyone?).</p>

<p>The first smart pointer type is  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>, which is a
reference-counted pointer to an item (roughly analogous to C++’s  <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr&lt;T&gt;</code></a>).  It implements all of the
pointer-related traits and so acts like a  <code>Box&lt;T&gt;</code> in many ways.<a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch01.html.id606"></a><a data-primary="shared_pointer (C++)" data-type="indexterm" id="OEBPS/ch01.html.id607"></a><a data-primary="C++" data-secondary="shared_pointer" data-type="indexterm" id="OEBPS/ch01.html.id608"></a></p>

<p>This is useful for data structures where the same item can be reached in different ways, but it removes one of Rust’s
core rules around ownership—that each item has only one owner.<a data-primary="ownership" data-type="indexterm" id="OEBPS/ch01.html.id609"></a>  Relaxing this rule means that it is now possible
to leak data: if item A has an <code>Rc</code> pointer to item B, and item B has an <code>Rc</code> pointer to A, then the pair will never be
dropped.<sup><a data-type="noteref" href="#OEBPS/ch01.html.id610" id="OEBPS/ch01.html.id610-marker">22</a></sup>  To put it another way: you need <code>Rc</code> to support cyclical data structures, but the downside is that
there are now cycles in your data structures.</p>

<p>The risk of leaks can be ameliorated in some cases by the related
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a> type, which holds a non-owning reference to
the underlying item (roughly analogous to C++’s  <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr&lt;T&gt;</code></a>).  <a data-primary="weak_ptr (C++)" data-type="indexterm" id="OEBPS/ch01.html.id611"></a><a data-primary="C++" data-secondary="weak_ptr" data-type="indexterm" id="OEBPS/ch01.html.id612"></a><a data-primary="Weak type" data-type="indexterm" id="OEBPS/ch01.html.id613"></a>Holding a weak reference doesn’t
prevent the underlying item from being dropped (when all strong references are removed), so making use of the <code>Weak&lt;T&gt;</code>
involves an upgrade to an <code>Rc&lt;T&gt;</code>—which can fail.</p>

<p>Under the hood, <code>Rc</code> is (currently) implemented as a pair of reference counts together with the referenced item, all
stored on the  heap (as depicted in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_7">Figure&nbsp;1-7</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">rc</code>::<code class="n">Rc</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">rc1</code>: <code class="nc">Rc</code><code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">rc2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rc1</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">wk</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Rc</code>::<code class="n">downgrade</code><code class="p">(</code><code class="o">&amp;</code><code class="n">rc1</code><code class="p">);</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_7">
<img alt="The diagram shows a stack on the left and a heap on the right. The stack holds three entries, labelled rc1, rc2 and wk.  All three of these entries hold arrows that point to an object in the heap, however the arrow from the wk entry is dashed rather than solid.  The object on the heap is a composite rectangle holding three component values: an entry labelled strong=2, and entry labelled weak=1 and an entry labelled 42." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIMAAAI+CAIAAACg7V0xAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzdf3BT5533/UttetMpjn90BsIkpnJkuuEBE8m16QbcjbXBjrM7s8YTIwb67Brv48S+FwopMEV+SgkhNB07GUJDCnvbwXM7bLZkLNw17txtHJtgd+rALnZXCsaTzGJhBYdxYCb+Ac7TbJv6+eOkx4ejH9aPo3Mk+f2aTEfnWDr6QoWPP76u63uZZmdnBQAAAABAR18yugAAAAAAWHBIYgAAAACgN5IYAAAAAOiNJAYAAAAAeiOJAQtXaWmpScHocgAAABYQkhgAAAAA6O0eowsAko/L5RocHBwcHPR6vV6vVwiRlZVVUFAg/a/D4bBYLEbXCACA3lTTK+bdKinS5wMpxsSHHgify+Wqr6+X0lcItbW1TU1N+pQUi9LS0p6eHvmQ7wYAgFiQxICIMCYGhKu5ubmuri6cZ/pHtebm5omJCfnQ6XRqWRkAAACSDUkMCIvL5QozhgV7uXL0iSQGAACwwJHEgLDU19crD7OyspxOZ0lJSUFBgXSmp6dnYmKip6dHmbgAAACAgEhiwPxcLpdywqHFYhkYGMjKylI+p6SkRAjhcDiEEIQxAAAAhEYXe2B+qnVfDQ0NqhimIqUyAAAAIBiSGDC/wcFB5SFBCwAAADEiiQHzU7Y9FEKEHhBTamxsNJlMJpNJNV/RpNDY2Kh6ldQrv7S0NDc3V35abm5uXV2dy+UK5329Xm9jY6PqCqWlpfX19apUGVpPT4+y1NLS0vBfCwCAVnp6eurq6goLC+VbUmFhYV1dXejlAFHcT0tLS/3velLzZPki0hVYiQANzAKYj2oQ7JNPPgnzhQ0NDfP+G2xoaJCf77/8zF9JSUnoAuZ9U/kdVX8u/0uptqju7u4O++8MALDgqG43mjz/k08+CT0VxeFw+N8Wo76fKt+rpKSku7tbdStUqq2tje4vCpAwJgbMT/VdOMyBqShMTEyoxt/89fT0BBubmpiYKCwsVLV5jFpjY6NygVxtbS3TMgEAepqYmCgtLZ134Mv/thjj/VQyODhYWlrqv0eorLm5Wat7LhYmkhgwP1USC3+OX1ZWVklJSUlJiX+jRVn4cx1lg4ODzc3N/ucDFia/UURvMTExoZw2mZWVFc74HgAAGtq8ebP/Um3lFjKSwcFB/6n+4Qh2P5XMm+WEEI2NjUxTRPSMHpQDksDIyIj/vx2n0zkyMhLmFeadBygZGBhwOp1tbW3KK3/yySdNTU2qwOZwOFSv7e7u9q9QNe9iYGCgtrY2nNmJtbW1yi8pp1ACABBQpD9khn5+U1OT8qsFBQXKm5rqrpeVlaV8bdT3U9Wd0WKxNDQ0DAwMSF8dGRnx75/sf0cGwkQSA8ISbEzJ4XC0tbVF+vIoCgh9y5mdnZW2MosoOwWramBgQHXzi6JgAMBCo7pFxvh85cBXVlaW/5ou1WSNcG7Hs/PdT8NZGd7W1qaqPPwF5IASsxOBsATbQ8zlcm3evDk3Nze6eRHhKykpUU6SVE2ZmJiYUK5es1gsTqcz6vdSzXpnXiIAIAqm+YR4rdfrVc5LrK2t9b8Lq34FGebCgdD3U5WAt36Hw6EKbExQRHRIYkBYCgoKQmzo7PV66+vrc3Nz4/q9OET7JtX7quYWRsTlcimvRqMOAID+VPe1gHcii8WivC+Hv01LiPtpmFQhMERXDyAEkhgQrtra2u7ubtUqYSWv11taWhpi7W/8qO4BIYqcl3JAjEYdAABDqIaqgt3XlOfDabChFVWW0/OtkUpIYkAECgoKBgYGmpqaQvw6ra6uLh5hLHRD3jDvWPNSda53Op1RtHYEACBGqgGucG5GYY6JhdPgfl6qMbrwh+MApXuMLgBIPrW1tbW1tT09PS6XK1g3eYfDEWOG6enpGRwc9Hq90lz50LeNKO5Y/rxer3K1W4yLzQAAC9ysX08OlRBLxVR3vdCLykKL6H4K6IkkBkRJ2tLE6XQ2Njaq8tjExERzc3N0MUZ6bWNjo/63iubmZuWbsjwMAJC8DLyfAmFidiIQE4vF0tTU1N3drRqGim6iwuDgYGlpaX19vSG3DVWfj+bmZqZbAACSkbH3UyBMjIkBGpAGx5S9LqLLMHV1df4vLCgoyMrKKigocLlcce3OJE1HVE5QrK+v998wGgAAnUXaPsrY+ykQJpIYoA2Hw6FMYlF8i1eNQUl9C5XjVNI09xjrDM3pdCrnKPb09PT09DBNEQBgrIgm/CfC/RQIB7MTAW3EvjmJcmtmIURbW1v424Kp5kZGPRkjKytLdberq6uL7lIAAERN9UvAiIJTLPfTMGnVshgLHEkMSBTKXSwtFktEI1Gqe0As67ucTqcyVXq9XkN2SAMAQBbRfS2W+2l09bDjC6KT4rMTW1tbR0dHhRB/+Hz2K182CSHsdrvdbje2KqQk1TflGL/vRzrC5t8vJJYCnE6ncihMk6b8SDHPPfec9ED+7lpdXZ2Tk2NgSQBSieo3jD09PQ6HI4rrxD5jJSDVTT9O74KUl/pJrK+vT3WSJIZ4UP4GTuj+TVmVu6LuoS+pra1VTrKPpSk/UtWhQ4dUZ+x2O0kMgFZU9zWXy9XQ0JA4vxNUTYBkQTWiw+xEYH6NjY2hZ6gPDg4qWw6K+aaMq57s/xJVrpuXxWJRvly1R7NKOKvIVF2q5v0bAABAW8rFXRMTE6HXLU9MTMj3qVjup+FQdQQpKSlJnIiI5EISA+bX09OTm5tbWFjY2NjocrmUg0U9PT11dXWFhYXKeGOxWFSLg1W/Lauvry8sLCz9M+mkKrypopTX6w2dhVTvWF9f77+d5eDgYF1dXTjrvqR9q+XDiYmJENEOAADNqaYjulyu0tJS/2Ql3Yhzc3MDJjER+f1USdlPWD6jbJXsXycQPtPs7KzRNcSR3W5XzU48ePCgvLwBCFPAb/0htLW1qb4ve73e3NzcgE8uKSmR9uzq6emRU5n8JSkODQ4OqiZCCCH8//EWFhYG2z5Fuoh0O2loaJCmGqr+XKoLDg4OFhYWKs90d3czAQMSk8mkOnP+/HnmfgMLnOo7w7w/ZM77fOm3iqqT0p5g0mPlXUy+ScVyPw14x5fvffKdVFZQUDAwMBDsDwiEluLrxAD9NTU1+f96zGKxNDU1hZ5ZId0nlDcAaTuviN66tLTUfxws/CsoFRQUSAvG5DONjY0kMQCAbhoaGgYHB1W3QmlCSohXxX4/VQn22qysrLa2tqgvCzA7EZhfSUlJOB04LBZLd3d3sE1Lamtru7u7HQ6HfCkp6ig7YbS1tQVbYBbOb92k58wblsKfzq7q0tHT0+P/q0QAAOKnu7tbtXTZn7R3s/IGGuP9NBwFBQXd3d10TUQsmJ0IhKunp0f+zZz86zFp7p/06zetNnZsbm52uVzyWzgcjpKSkoh2pZR++af8PaLU0qOgoEAZBYGoMTsRgJ6kLr6Dg4Ner1ee61FQUCBtFxZsq5Uo7qeq2YkjIyPS+6rupw6Hg+VhiB1JDAAQMZIYgJQUegU1oC1mJwIAAACA3khiAAAAAKA3khgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgN5IYAAAAAOjtHqMLAAAAABJCd3e30SVgAWFMDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAAAAAQG8kMQAAAADQG0kMAAAAAPRGEgMAAAAAvZHEAAAAAEBvJDEAAAAA0BtJDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAAAAAQG8kMQAAAADQG0kMAAAAAPRGEgMAAAAAvZHEAAAAAEBvJDEAAAAA0BtJDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAAAAAQG8kMQAAAADQG0kMAAAAAPRGEgMAAAAAvZHEAAAAAEBvJDEAAAAA0BtJDAAAAAD0do/RBQAAgETkdrsnJyeNrgIAUk1OTk5OTo4QQsymtOLiYoP/pgFgYTh//rzR3/KhmWvXrpnNZqM/UwCQsoqLi2dnZ5mdCAAA7tLa2urz+YyuAgBSVl9fX29vL0kMAADcpbe31+gSACDFkcQAAAAAwAALrmPHYxu3bKjYYnQVAJDc9v9jhdElQCdbt/9g6/Z9RlcBAKngh9UbhwbelQ8XXBK774Hla9YWGV0FAAAAgAWN2YkAAAAAoDeSGAAAAADojSQGAAAAAHojiQEAAACA3khiAAAAAKA3khgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgN5IYAAAAAOiNJAYAAAAAeiOJAQAAAIDeSGIAAAAAoLd7jC4AwJzLl/rlx4vvzbCszDOwGAAAAMQPSQww0sztqYvnfn3xnV9d/o/+T+9M+z/hwYdW560t2lCxlVQGAACQSkhigDFufnT95ydefOfsm6Gfdu2DK9c+uPLLN5qX3r986/Z9Gyq26FMegGTxve99r62t7dy5c2vWrDG6FgBABFgnBuht5vbUaw37nyr71rwxTOnmjeuv/GjnU49/6+K5X8WvNgDJ6NatWw8//PDDDz9sdCEAgAiQxABded8feqbyr3/5RnN0L7954/pPntn20/07Z25PaVsYgGR3+fJlk8n0ve99z+hCAABhYXYioJ9zHW++8qOdAb6Qfp/ILRIrikT6fSJ92Rcnb42Im1fFmEeM9IvPZpRPf+fsm9fev/yT1rOL782If9UAksnx48dPnjz5xhtvbNq0yehaAAChkMQAnQSOYdkPi3XbRLY1wAuW5IoluWJ1mfjsjrjaL/pOKPPYtQ+u/LB6I2EMgL/PPvvM4XCYzeZf/vKXLB4DgITF7ERAD5cv9atj2KLFovyQcLwcOIbd9cw0sbpM1PyryH9SeVoKY1pXCiBF+Hy+hx9+uLi42OhCAACBkcSAuJu5PfXCzqq7Ti3JFTX/KnKLIrjKojRh3y4e/4Hy3LUPrrzWsF+LGgGkpt/85jdf/vKXWTwGAAmIJAbE3Qs7q+7aK2xJrnAcEYvSornW6jLx903KE798o1m5HzQAqPzpT386fvx4enr6mTNnjK4FADCHdWJAfF2+1D808O7ccfp90ccwyZJc8fgPxNsvySde2b/z5Nu/i6FGAKnv9u3bLB4DUoznQt/VYU97y6t3piflk9Z1xbZHHrWuK16xar7lDzAaSQyIr9PHX7zruPz5mGKYZHWZGOkXI18EvJs3rp/reJNNnwHMS1o89uSTT7a3txtdCxJCe8sxIcT4mK/Ldar5rYFl2WajK0JY+rs621uOXR32+H/Jc6HPc6FPHD1cVFa+bfez/H+ayJidCMSRekAs/0mxJFebS5ftE4sWy0ed//K/tLksgAXgF7/4xVe+8pXGxkajC4HxXj96+PWjh7tcp4wuBBFo3FvTuLcmYAxT6u/qfPapyvExnz5VIQokMSCOznW8edfxuqogT4zcojSRXykfXfvgivf9Ic0uDiDV/fGPf6yvr09PT798+bLRtQCIwIGnN/V3dYb55PEx34t7auJaD2LB7EQgji6e+9XcwarHNZiXqPStJ8XFud9idre/sf7xv9Py+kAk3G630SXMSahi4s3jmef34iHcvn374YcfNpvNo6Oj2lUEII5mpiaVh5U1u6RVYdJhf1fnb98+q4xqV4c9/V2dRWXlulaJ8CR0EmtsbKyvrxdCNDQ0OJ1Oo8sBIuN9f+iulokrIulZH45FaSJ3vbxa7P+cbvk/p1s0fgsgbLt37za6BETJ5/OZTKYdO3b87Gc/M7oWAPPY93JL7ROFQoiisvIdB4+kpWcqv1pUVl5UVt6+6tjrRw/LJ3/79lmSWGJK3NmJ9fX1UgwDktTNjz686zii3cPCtGSF9tcEsCAdP378K1/5Cp3ugQS3LNu8bfeBbbsPOI+0qGKYrLJmlzxKJoQYuRL9yDniKhHHxLxeb11dXU9Pj9GFADG59oFi4ZZWjTpUllvFxbhcGMAC9Mc//tHhcCxZssRsptkakLgqa3bN+5wnNlV5LvRJj2nakbASLonV19fTzQkpSNHnEAAS2a1bt27dumV0FQhFaj2vnH4mSUvPrKzZKYRYscqqHBJRqn2iMNjP5dKct4CWZZub3xoIXdX4mK+/66z4c098/ydI+1yJMIKE/zZZ0h8txJ9Lpct1Snptf1enf4/BbbsPpKVnljkia6PV39U5Pjaq2rxLhPfXrr+09AyjS8D8EiWJeb1el8vFdEQgMtls2ghAe1/60pf+9Kc/GV0FAmhvOeYfwGR3piflr27bfSCckZPY9Xd1ui/2hdMHX9rnyrquOERhV4c9J57b65+d5D/ailXW7c8dCbFncei/Ion0hPaWYzsOHgknO3ku9L1+9HCwrvHKv3YhxI6DRyLNePHGlmIJK1HWialWhWVlZXV3dxtYD5Acbo0YXQGAVLNjx46/+qu/MroKBHDg6U3zZgzZsuyceNYyJ8wYJgsRorpcp/ZsLgm9TdbVYc+ezSWabIA2PuY78PSmeS/V3nLswNOb5t28K9EoC06ckTqoJMqYmMPhcLlc0mOn09nQ0GBsPUBy+OyO0RUASB1r1qx57733hBB2u93oWqDW3nJMXvYTjtzVCTppItisuS7XqeOH9oZ5EemZmgw9HT+0N3e1NVg+DGeEbV4Hnt4U0f93StZ1xYdfi6aPjjJhfudxGicmqABJTJooKITo6enxb5thsVhqa2tLSkoKCgpCXFda6+U/21CKWLW1tVlZWcrzDocjKyvL6XT6fwlIUkvv/8bcwdh7cXmPm1fjclkAC8ySJUvOnTu3Zs0aowtBUO0tr8qPpYVJRWUbVbPO5JVaXa5TwSakqZZ7lectUX4pxmlsK1ZZpW7pwWpzX/xNwPGZ8TGfKoYVlZV/5/GNcu/1/q7Ot86cUuaZ44f2WtcVhy54Wba5smaXKrC1txzrcp1SLpZrbznmPBJgG5irwx5VDLOuK/7O4+WqC3a5TrW3HEuorhjKP6B1XTFjYgnrriTW09NTWloa+gVer7e+vn5gIOiqzdAtN+Rs5r8/2CeffDJPsUBSWfrA8ruOb41o30FRMTsxr3D9T1rPanx9IAjlT2+S8+fPGz6QYjKZAp5PhNri53vf+97x48ejfvk999xz+vTpTZs2aVgSNHd12KPsXfFyW0/ABCIFDxFeb714KCorD/bWUm3Bvir1IJH5L7X6Ypusu0eopIVeIeq5b3mO/7iZlM2efWpuwmF/V+edg5P+HeFVMSzYArAyR9Vv3+5MnCQ2PuaTK09Lzwz9VwRj3bVObHBwMMyXWSwW/5Nerzc3NzeczoclJSVhvhGQvNasLfpaWvrc8ZUu7d9jpF9++ODKPO2vDyClPfnkk3/4wx+IYYlvZmquWV9aekaKNWBQ9Vr0H8VSfkmZ5VRDW+FLS8/ctvuA8oznwm9Uz7k67FEOwYWoKqGMj/mefapSzu07Dh5JsU9Ligm6TkyaRqgauZImLg4ODvpPIPR6vaWlpV6vV3kFi8XicDjkM4ODgz09PS6XK/TMRiBlrPl20b+/8+svDoa7hH27lle/0iU+m5GPNlRs1fLiAFKa2WweHR01ugqEa3HG3HCNNOKhChJJTZpRKZE7wgdTWbNT7lAvvTa6AUDruuK09Ez5OuNjo35VdYZfVWjRLfSKwviY78U9NXI6razZJU/vRGIK2jvR6XT6TyC0WCxOp7Otrc3/+fX19XIMKykp+eSTT5xOpzKGCSEKCgqcTmeImY1Ainnksb+dO/hsRlzQoNfTnItzV1t6/3ILY2IAwnDvvfe+9957xLDksmKVVTmy0d5y7Lvrv5loa5OidneXv0f9ZwkqpaVnWtc9GvC1kVJe5870VIiqyhxVoatKBNJomFx2maMqleJ6qtKmi/3g4KDc+bCgoKC7u5uuG4AQYkPFlqX3K1aL/We7Zt0OL5wS0x8r30ibywJIXffcc09DQ8P09DSdOZKRarWPtIdV7ROFUiRLuh7rSiNX5ooP0eM+4HOUr42UstG/arNmIcTH10cVz0z0CX5SDJOTeVFZOcvDkoI2SUyOYeLP0xoBSLZu3zd38NmM6HxWg4veGlEOiH0tLb38H+o0uCyA1PXoo4/+4Q9/8J/tgmQRrJu5FMn2bC6pfaJQ1fciWShH9iJNYrGMCgbrp+9/5QRPYqoYZl1XHLAVJBKQNklMbnZvsVjoxgEobajY8uBDq+eOx94TXS/GdMVbI8K1R3niuzv2Lb431O0EwEJmNpvfe++9vr4otzNC4rCuK25+ayDYyh9p/dh3139Tk12PkSxUMazMUaXbsjTETpskNjExIT2gFQfg75kXfnbX8fDb0YcxKYYpGnXkFa5nQAxIEG6322azmUwmk8mUk5PjdruNrWfRokUul2t0dJTpiCljWbbZeaSl+a2BYEuA7kxPHj+098DT9MOMlXJhmP8qsgThH8OYlJhcgvZOjIjcq4PlYYA/y8q8Z3786is/UrRdGn5bTI+Lsn0ifVkEF7rSJfpOKGPY19LS97/K7z6BhOB2u/Pz8+VDn89nt9t7e3ttNpv+xXzpS1/6p3/6p5/97GfzPxVJSN6bS+q03t7yqmqZk+dCX+PemmSZorYs2yxniavDnnm3IVYuiovfvMG09IwQnRUjcuDpTcqG+BEJNitVCHFnepIYluy0GROTtxeTB8cAKG2o2PLYxrubaoy9J96oExdOhdXDY8wjXHvE2y+pYthPWs8yLxFIEBUVFaozU1NT1dXV+lfy6KOPfv7558SwhWDFKmtlza6fv/tfzW8NqJq593d1KvuwJ7Lc1XPrvsJpPaJ8jvK12lJeOTH/Jo8f2qtcG0YMS0baJDF5KEy5nxgApe+/8Ko6jH02Iy6eEi3/t+h6UYz0B4hkt0bE79rFG3XCtVeMvaf8ihTD6FwPJIjJyUmfL0DnAI9H1452LAlbsJZlm7ftPvByW49yTl04qUb5fGW3QD0pO3B4LvzGv42h0p3pSeUuzOF0+Ii9qqvDnkQLY+0tx+SSVqyyOo+cNLYeREebJCZ36ZD2btbkmkDq+f4Lrz7z41fVZz+bEcNvi86D4kSFOLFRuPZ88d/REvFGnej7Z3FrRPWKBx9afay9lxgGQHbPPfewJAwrVlnLHFXyYXhJbG5ihVGt8IvKNsqP70xPtrf43SgVVFMxla/VlmoPseOH9ob4+5mZCpUeNaf8W0pLz9z3ckvib3eGgLRZJ1ZSUtLY2Cg9rq+vZ+9mIJgNFVseXJn3yv7vXfvgSoAvfzajGvvyt3X7D+7qjA8gAWRmGvZjkN1uF0IwFzHl7dlcUuaoUgatgCJdQ5W72irPcOtynTJkC+Nl2eYyR5Xc8rG95Zh0xv+Z7S3HlJ36yxxV8VwnlllZs/P1o4elwzvTk3s2l1TW7FK+qedC39Vhj/86PRXNmxl2uU7J71hZszPBm+wjBM3GxJTDYqWlpSwYA4KxrMx7pb33mR+/etemz2F4bOOWk12/I4YBUNq0aRMxLOVdHfZcHfYcP7S3PG/J60cPt7cc8//Rv73l2J7NJcrOEOH8gK7am+vZpzappuGNj/mkK8f2J5hHZc0u1QBU494aZSX9XZ0Hnt4k5yLxRVK6a2mc5vyTXnvLsdonCsvzlkj/SSWFjmHxoBw2nDecI5FpMyYmhGhqaiosLJQCWE9Pz9e//vWGhgaLxeJwOJRPa2xs9Hq9WVlZbACNBW5DxZYNFVsuX+o/1/Hm0KX+mzeuB3vmgw+t3lCx9ZHH/nbpA5ElNwBAahi5MjfSJQ0KKTNJQGnpmeH8jF5UtlF5qavDnsa9NWJvgGeOj/niN/ayLNu84+CRxr018pkvOo4EqkSy4+CReI8FpaVnPn+yXdmfMBH0d3Uqs993138zzBcefu3MvH0poTPNkpjFYunu7t68ebPctKO+vj7Yk1XxTFJXV9fc3Bzw+fX19cqrNTU11dbWxlYvkBDWrC1as7ZICHHzo+sf3/jw2vtDM7e/2LRk6f3fWPrAcumrAICFLIok4DxyMpx5hlJDfOWUv2BGrnjimnyKysp3TB85fih49lLYcfBIsB2utbUs2/xyW8/xQ3tDd+xIS8/UbWQsxpb6SCiaJTEhREFBwcDAQH19fbBAJRscHNTwfYEUsPSB5eQuAEBAK1ZZreuKw9yTyrqueNvuA+E3FZQ2iQ4njMVbmaMqd7X1xHOhemOsWGXd/tyR+LVM9JeWnuk80jK+29ffdba/q1NZW1FZubSRQCw7hmEh0zKJCSGysrKampqampoaGxsnJibkNh4yaVIiI1oAAABhKiorLyorvzM9KbW1CNgiorJmV1p6hnVdcRQpZdvuA2WOqv6us+6Lv1ElCmmtVLxXZMlWrLK+3Nbj3wlD6p8hJVJ9KlGRd9M25N2Rqkyzs7NG1xBHdrtdta0KfecAIHbleUtUZ86fPy818TOQyWQKeF6f2oK9ezLeZ5V3T+6bwLy+u/6bcmhkORZC+GH1xqGBd6XHBw8e1KZ3IgAAALAAeS70KYcoc1frN3MSyY4kBgAAAERjfMyn7DKyYpWVTZYRPo3XiQEAsDBZrVaPR91mwGxmx1UgWV0d9ry4p0baDMB/z2upe4eq0wm7eyEiJDEAADTQ2tpqt9unpqbkMxkZGR0dHQaWBCAWH1/3jY/5pP3W5t3ATQixYpWVJIaIMDsRAAAN2Gy23t5eeRDMarX29vbabDZjqwIQtRDN9P2tWGV9/uSZ+BWDlMSYGAAA2rDZbKOjo0ZXAUAb4SexbbsP0OAeUSCJAQAAAGqHXzszPubr7zorAs1OXJZtluYiksEQNZIYAAAAEIC8qzVxC/HAOjEAAAAA0BtJDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAG243W6bzWYymUwmU05OjtvtNroiAEDiIokBAKABt9udn5/v8XyxFazP57Pb7anZqAwAACAASURBVIQxAEAwJDEAADRQUVGhOjM1NVVdXW1ELQCAJEASAwAgVpOTkz6fz/+8PEQGAIAKSQwAAAAA9EYSAwAgVpmZmUaXAABIMvcYXUCKu3ypf+hSv/R46f3f2FCxxdh6wnfzo+vnzp6WD7du32dgMZE6feJF+fGGjVuXPrDcwGIicq7jzZs3PpQe560tWrO2yNh6wpe8H/XkrTyp/5ECIZzrePNcxxef7QdX5j1d/4Kx9YTP+/7QyYb98uFPWs8aWEykfli9UX78VP0LlpV5BhYTkdca9l97f0h6vKFiaxJ9G+ejboiE+qiTxOJr6FL/6RMvSY/zCtcn0XeHj298KFcuku2HPGXleWuLkiqJnR4aeFd6vHW7SKIklrwf9eStPKn/kQIh3LzxofydMLnM3J5K0sqFEMrKZ25PGVhJpK69PyQXv+bbSXPfFHzUDZJQH3VmJwIAAACA3khiAAAAAKA3khgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgN5IYAAAasFqt/ifNZrP+lQAAkgJJDAAADbS2tmZkZCjPZGRkdHR0GFUPACDBkcQAANCAzWbr7e2VB8GsVmtvb6/NZjO2KgBAwrrH6AIAAEgRNpttdHTU6CoAAMmBMTEAAAAA0BtJDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAANCG2+222Wwmk8lkMuXk5LjdbqMrAgAkLpIYAAAacLvd+fn5Ho9HOvT5fHa7nTAGAAiGJAYAgAYqKipUZ6ampqqrq42oBQCQBEhiAADEanJy0ufz+Z+Xh8gAAFAhiQEAAACA3khiAADEKjMz0+gSAABJhiQGAAAAAHojiQEAAACA3khiAAAAAKA3khgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgN5IYAAAAAOiNJAYAgAasVqv/SbPZrH8lAICkQBIDAEADra2tGRkZyjMZGRkdHR1G1QMASHCm2dlZo2uII7vd3tfXpzyz9P7lS+9frlsBN29cv3njuvR48b3pDz6Up9tbx2jm9tS1D67Ih3mF6w0sJlJDA+/Kjx98aPXiezNCPDmhXPtgaOb2tPRY589qjJL3o568lRv7j1T5r0xy/vx5u92uZw3+TCZTwPO61eZ2uysqKnw+nxDCarW2trbabDYd3ldz3/nOd/r7+42uAgBS2cGDB8VsSisuLjb6LxkAFoTz588b/S0/6C8WE6G25PLQQw/p+eEBgAWorq6O2Yl6WHxvutElRCl5KxfJXDyV64/KAaXf//73RpcAAClucnKSJKYHeb5Z0kneykUyF0/l+qNyQGnZsmVGlwAAKW7lypX3GF2D3oqLiw1fyQAAye7QoUNGl4A4+upXvyo/fmzjlg0VWwwsBgBSxsmG/co13gsuidnt9ueee87oKgAguZHEFo77Hli+Zm2R0VUAQCpQtZFjdiIAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAaMPtdttsNpPJZDKZcnJy3G630RUBABIXSQwAAA243e78/HyPxyMd+nw+u91OGAMABEMSAwBAAxUVFaozU1NT1dXVRtQCAEgCJDEAAGI1OTnp8/n8z8tDZAAAqJDEAAAAAEBvJDEAAGKVmZlpdAkAgCRDEgMAAAAAvZHEAAAAAEBvJDEAAAAA0BtJDAAAAAD0RhIDAAAAAL2RxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwBAA1ar1f+k2WzWvxIAQFIgiQEAoIHW1taMjAzlmYyMjI6ODqPqAQAkuHuMLgAAgFRgs9l6e3srKip8Pp8Qwmq1tra22mw2o+sCFhbPhb6rwx4hRJfr1H3Lcw6/dsboioCgSGIAAGjDZrONjo4aXQWwoF0d9rx+9LD0+L7lOYbWAsyD2YkAAAAAoDeSGAAAAADojSQGAAAAGKPLdao8b4n0n9G1QG+sEwMAAAAM0N5yTF7VhgWIJAYAAADo7fihvV2uU0ZXASORxAAAAAD9eC70HT+0d3zMZ3QhMBhJDAAAANDD1WFPe8ux/q5OowtBQqBjBwAA2nC73TabzWQymUymnJwct9ttdEUAEkV/V2fj3po9m0uIYZCRxAAA0IDb7c7Pz/d4PNKhz+ez2+2EMQBCiDvTk8cP7VVlsKKy8sOvnTGqJCQCkhgAABqoqKhQnZmamqqurjaiFgCJJS09s6isXD6UMpjzSMt9y3OMKwrGY50YAACxmpyc9PkCLL6Xh8gAw8nbVS3LNje/NRD+Cw88vclzoU963Dl0K9jTxsd8/V1n3Rd/Iz9ZCLFilbWorNy6rnjFKms479XlOnVnenJ8zOffVLCorHzFKmuZoyotPTP84kOQpgvKh2WOqh0Hj2hy5YAqa3b1d3VW1uwsKtu4LNscvzdCEiGJAQAApL5l2WapWd+d6amIXjgzNSlfIeATAk69k1wd9lwd9oijh4vKynccPBI6RDXurQmxhqq/q7O/q/P1o4cra3Zt230gkj9BAJ4LfcoYJpUX4zVDW5Zt/vm7/xXXt0DSYXYiAACxyszU5pf0QPzIKejO9OSd6cnwXyg3Ww84lc5zoa/2ibXzdqHo7+rcs7kkdN/2ZdkBru+vveXYns0l4TwzGM+FvgNPb5IPreuKnUdaYrkgEB3GxAAAAFLffcvNV4e/mC57Z3oq/Dl+cmxLS89QfUkVaUIbH/M9+1RliImR/tcP5uqw5/Wjh6MbGVPVXFRWHjCGKedkRsq6rphWHAgHSQwAACD1KUecPr4+GuZSJeUolmrManzM17j3KeUZ67pi2yOPVtbskg7vTE92uU61t7wqZ7nxMV97yzH5Cf4VSldYlp2j7G8hhOhynfrt253KaNTecqyyZmeka8a6XKeOH9orH8Z7bRgQGrMTAQAAUp9yxMl/luB313+zPG9Jed4S1cTFj6+PBryCEKK95Zjyydt2Hzj82hllykpLz6ys2dX81iVlu472lleDVSh1FKys2aWKYUKIMkfV4dfOqAbBPBd+E+xSAb1+9LAyhm3bfYAYBmMtuDGx1tbW3t5eo6sAAADQlXJESxW3rg575DNdrlPKNBVsTEzV3nDb7gPBRrrS0jP3vdxS+0Sh/NZXhz1htlJUqazZ1eU6JZc0PjYa/mtV7UCcR1r88x6gswWXxHw+X8BGwwAAACnsvuVz0xFV7ROVEUVeS/bnZ85lNuUV+rvOyo+t64qDxTDJsmxzUVm5/C6eC33RJTEhRFHZxvaWY9Lj0P0/ZHemJ599apP850pLz3QeOWldVxz6VSz0gg6YnQgAAJD6lAvDVKNJyljV39WpTF/KzKaMT+6LczMDbY88Gsa75yjePfrfiYff1UN+rz2bS+QYtizb/PzJM/PGMEAfC25MDAAAYAFKS8+UtxT7+PpcFro67FFFI8+F38gz95QZRvmckStzQ2evHz38+tHD4VcSuoe+tEN0wM2dt+0+oEyA8/r4+uiezSXy261YZX3+5BmtNoYGYrfgklje2vVr1hYZXQUAJLfTJ14yugQAEbtveY4UupRTEP23Avvt22flJCZ37Mhdfdd8woh2JFMJtrW01Js+RO/4iPKe8Bt827b7ADEMCWXBJbE1a4u2bt9ndBUAkNxIYv6sVqvH41GdNJvDahQO6GPFKqucc8bHfNIwlzz0VOaokh73d3XeOTgphRY5zIS57XLUItqaLDoHnt4UorMIoL8Fl8QAAIiH1tZWu90+NTX3y/6MjIyOjg4DSwJUlIuspC3F5FVhaemZOw4ekQ/7uzrLHFXKobMQPTYOvxbryqvxMZ8qhm3bfWDFKqvqsv1dnW+dORX+hsvWdcUrVlnlDh9CiNePHr4zPRXdltCA5khiAABowGaz9fb2VlRUSB16rVZra2urzWYzui5gjjJNjY/5rEL89u0venWUOaqk/5Vyy2/f7ixzVCmXkykbJwoh0tIz5QmKV4c9MSax148+Lz9elm1+/mR7wI2ni8rKx8dGw09iQohtuw/YHnm0ce9TcrXtLcfGx0adR1pCv/DA05sieiMl67piWi8iHPROBABAGzabbXR0dHZ2dnZ21u12E8OQaJRrvcbHfHemJ+VFYtLCMHl5mOdC3/iYT9liUTUmpryUqvF9FJR7NG/b/WzAGBY167ril9t6lPX3d3XGeyYkEA6SGAAAwIKQlp4pt6wYHxuVV4hJs/iEECtWWeXE0t91Vo5Y/lMTlZ3r+7s6YwljUiaUD1WtQTSxLNv8cluPcuBOh2VpwLxIYgAAAAuFdd0XCerj63Nt4r/zeLn8BHlYrMt1Sp6d6J+Oiso2Kg9PPLc3lm6KSsr++No6/NoZaRKmhDAGw7FODAAAYKGQWyDKo1hp6Zly+hJClDmqpGbx42M+IeTGierpgsuyzUVl5fLkxqvDnmef2rT9uSMhGnsEL8msXHXW3nJMWY+2dhw8IhTtIj0X+o4f2iudVGGhF3TAmBgAAMBC4Z+UisrKlbtsqYKZJGBDjm27n1W+8OqwZ8/mkuOH9ip7FUruTE+2txxrbznWuLcmYFXySJ10ndonCttbjql2A5O/GvAK4dtx8IhyZKzLdSrSbcoArTAmBgAAsFAoM49EGUskT2yqUm33HLCFxrJss/PISdUEP2m4KVi2CdaKo7Jml/Idx8d8rx89HL+AtOPgkfExn9wasb3l2LJss//fg+bm7cdYnrdEebgs29z81kCci4KRGBMDAABYKJRNO4SiV4eSdV2xMjKtWGVVvkT1zMOvnQn2VX8Bh7mktwg4RTB+nEdOKv/gxw/tjX20DYgUSQwAAGABUQ6Lbfp/dgZ8jnKAKPReYdZ1xc1vXaqs2RXmuwdr7FHmqDr82hlt+9eHkJaeue/lFmWGfHFPjVZNR4AwkcQAANCGtIeYyWQymUw5OTlut9voioAA5LGgZdnmYCmrzFElp5R5m3CkpWdu232gc+jWtt0Htu0+4P+EorLybbsPHH7tTOfQrRADaNZ1xc1vDRx+7cy23QeCNe0oc1RJ77Lj4JEYh9GWZZuV1UpTImO5IBAp1okBAKABt9udn58vH/p8Prvd3tvby/7OSDSVNbvmHcJKS8/8+bv/FcWV5f+NmnVd8Rf5MKqcFc6fTlbmqNJheZiMfoxQYUwMAAANVFRUqM5MTU1VV1cbUQsAIAmQxAAAiNXk5KTPF6AVgcdDDwAAQGAkMQAAAADQG0kMAIBYZWaG28UbAAAJHTsA49386Lr3/cvXPhj6+KPrNz/6UDq55ttFi+/NeHBl3pq1RcaWBwAAAM2RxADDzNyeOtfx5rmO09c+uOL/1aGBd+XHf/nY32zYuOWRDX+rY3UAAACII5IYYICZ21M/P/7iL99oDvP5//7Or//9nV8vvX/5U84fk8cAAABSAOvEAL1dPPermtJvhR/DZDdvXP/JM9t+WL3x5kfX41EYAAAAdMOYGKCrn+7f+c7ZNwN/Lf0+kX6fyLYJIcT0uJgeF7dGxGczqmcNDby7q9K+/9VTrB8DAABIXiQxQCczt6d+WL0xwJKwJbki/0mx3CrSlwV42a0RcaVLDHcpI9mnd6b3/2PFMz9+dUPFlniWDAAAgHghiQE6eWFnlTqGpd8nyvaJbGuoly3JFfbtYl2V+N0vxMVTyq+88qOdQgjCGAAAQDJinRigh5/u36nshSiEEPlPipp/nSeGyRaliXVV4u+bxJJc5enXGvZ73x/SrkwAAADohCQGxN3Fc79Srw17/AfCvj3iCy3JFY4jyjD26Z3pn+yqmrk9FXONAGJltQb4xYrZbNa/EgBAUiCJAfE1c3vqp/t33nXq8R+I1WVRXm5RmiqM3bxxvfNfmmIoEIA2WltbMzIylGcyMjI6OjqMqgcAkOBIYkB8df5L06d3pueOVz0efQyTSGFs0WL5xOkTL9HXHjCczWbr7e2VB8GsVmtvb6/NZjO2KgBAwiKJAXE0c3vq7CnFgFX6fdFMSvS3KE2U7VOeOPsv/0uDywKIjc1mGx0dnZ2dnZ2ddbvdxDAAQAgkMSCOLp779V0DYo9UiUVp2lw6t0hkPywfnesIskcZAAAAEhJJDIijcx2n5w7S74t1XqLKtyrlh5/emb547ldaXhwAAADxRBID4uiuzvX5T2p89dwikX6ffHT5Ur/G1wcAAEDcsLMzEC/qaLQ8DitGsq1i+G3p4S/faP7lG83avwUQnr/+6782ugSkiMuX+of+/P1z6f3fSKL9629+dP3c2bmpEFu37wvx5ERz+sSL8uMNG7cufWC5gcVE5FzHmzdvfCg9zltbtGZtkbH1hI+PuiES6qNOEgPi5Zpyz+VFi1WbMmtDkcQAIDUMXeo/feIl6XFe4fok+vH04xsfypWL5PvxdK7yvLVFSZXETsszULZuF0mUxPioGyKhPurMTgTi5a4Nl+MRw4QQGcviclkAAADEGUkMSGaKdWIAAABIIiQxIJmlMyYGJBBpDzGTyWQymXJyctxut9EVAQASF0kMSGZjHqMrAJJATk6ODu/idrvz8/M9ni/+Vfp8PrvdThgDAARDEgN0Mf2x0RUAC9QzzzyjTxKrqKhQnZmamqqurtbhrQEAySixkpjX621sbCwsLDQpbN68ubGx0ejSgIg9+FDe3MH0x+KzO9q/x3XGxIBQnnnmmZ/+9Kc6vNHk5KTP5/M/Lw+RAQCgkihd7L1eb319vcvl8v+Sy+VyuVz19fVtbW0Oh0P/2oDoWFauuev4ar9YXabxe4zMbVn2f+X/5d/v+n81vj4QxP5/VI//HD161GaLw6Z5McjJydFnNAwAgCgkRBLr6ekpLS2d92mbN28mjCGJLH1g+dL7l9+8cf2L4xGtk9j0uLg1Ih8VPf53SbSJClKPzWaz2+1GV2GYzMxMo0sAACSZhJidaLFYsrKypMdOp7OtrW32z9ra2goKCuRn1tfXG1QjEI2/fOxv5g5G3hXT41pe/cIp5dEjj/2tlhcHAABAPCVKEmtqaiopKRkZGWloaFCOejkcjoGBATmMeb3egDMYgcS08R/+513HvSc0u/T0uBh+Wz76y8f+xthN4gEAABCRhEhiQgiHw9Hd3W2xWAJ+tampSX48ODioV1FArJY+sDyvcP3c8ci7ypVdMel6UXlU/g912lwWAAAAukiUJBZaQUGBPH1xYmLC2GKAiDxV/8Jdx10vKhd3Ran3hBh7Tz7KK1zPCjEAAIDkEiCJSa3kGxsbS0tLTX5yc3MbGxvnHZiSruD/cuk8aQoLh2Vl3t/9fe3c8WczwrUnpjB2pUv85y+UJ77/ws+ivxoAAACMcFfvxHB6GErt5gcGBoI9ob6+PsT2X3LLDafTGX6VExMTcngLNoMRSFjf3bFv6FL/tQ+ufHEshTHHy2JJbsTX6j2himFPOX/MCjEAAICkc9eYWPhLsALGIa/XK42YzfvykpKSMN9I0tzcLD+miz2SzuJ7M5554WdfS0ufO/XZjHijTlw4FcF2z7dGxBt1qhj22MYtrBADAABIRkH3E2toaBB+I1dS68LBwUF51ZbyS6WlpV6vV3kFi8WiDE6Dg4M9PT0ul0vZmH5e0mxJ6XFtbS1jYkhGlpV5P2k9+8PqjZ/emZ47e/GUGO4S+U+K1WViUVrQF98aEb9rV3ZKlDy2ccv3X3g1PvUCAAAgvoImsYCzBy0WS7BZhfX19XIMKykpaWtr809rBQUFBQUFkc5L3Lx5szQ1MSsrK6LXAgklcBib/lj0/bPo+2eR/bDItomluXORbGpc3BoRI/1i+mP/qxHDgERjtVo9Ho/qpNlsNqQYAEDiC5rEIjI4OChv81VQUNDd3a3JZYUQmzdvludMNjU1MSCGpGZZmdfS/bsXdlYNDbyr/trYe8p2iCF8LS39uzv2MSkRSDStra12u31qako+k5GR0dHRYWBJAIBEpk0Xe+Vuy9K0Rk2Ulpb29PTIl2WFGFLA4nszftJ69pkfv7r0/mjabOQVrj/W3ksMAxKQzWbr7e2VB8GsVmtvb6/NZjO2KgBAwtJmTEzOSxaLJdJuHMEoY5jT6WReIlLJhootGyq2nOt48/SJF2/euB7OSx7buGVDxRb2DQMSmc1mGx0dNboKAEBy0CaJyS3mI2rFEYIyhtXW1mo4zgYkDimPed8fGrrUf/lS/7X3h1SpLK9w/dIHvrFmbdEjG/5m8b0ZRtUJAAAAzWmTxOReHf5dOqKgimFNTU2xXxNIWJaVeZaVeUw4BAAAWFC0WScmN9KQB8eiRgwDAAAAkPK0SWLyUJhyP7Eo1NfXE8MAAAAApDxtkpjcpUPauzm6i/T09Mg7ODscDmIYAAAAgFSlcRITQtTX10d3kbq6L9bJWCwWYhgAAACAFKZZElMOi5WWlka6YKy5uVme2djU1KRJ5w8AAAAASEzaJDFxd3zq6en5+te/3tjYqNzxWdLY2FhXV+c/bibPaSwoKNBqRzIAAPTkdrttNpvJZDKZTDk5OW632+iKAACJS5su9kIIi8XS3d29efNmeWgrxDRFh8OhOiMnscHBQZPJFPq9SkpKuru7YygWAACNud3u/Px8+dDn89nt9t7eXpvNZmBVAICEpdmYmBCioKBgYGCgtrZ23mcODg4qD71eb+zt7wEAMFBFRYXqzNTUVHV1tRG1AACSgJZJTAiRlZXV1NQ0Ozvb0NDgdDr9n9DQ0NDQ0DAwMKDt+wIAYKDJyUmfz+d/3uPx6F8MACAp3DU70el0BoxPUZCu09DQEM6TLRbL7OysJu8LAAAAAIlP4zExAAAWoMzMTKNLAAAkGVNqD0bZ7fa+vj7lma3bf7B1+z6j6gGA1FCet0R15vz583a73YhaEkWwdlPJeJ9V3j2/8j8W/Y9Fi/R89//+7LM//Pdn0uMvf/nLX/3aYj3fPRaff/757z+dkQ8X35tuYDGRmrk9LT/+6tcWf/nLXzawmIj8/tOZzz//XHqs/8c1FnzUDWHsR/3/+3TmT3/+uB48eFCz3okAACA1jI+Py4//8N9zPyzq7/PPP1f+2JRckrdy5Q/ZycXYj2ss+KgbwtiP+uTkJLMTAQDAXT799FOjSwCAFHfz5k2SGAAAuMvSpUuNLgEAUtxf/MVfMDsRAADcJS0tTX6cV7h+zbeLDCwGAFLGuY43b964Lh+SxAAAQFBrvl1EpysA0MTl/+hXJjFmJwIAAACA3khiAAAAAKA3ZifG182Prn9840Pp8eJ7Mywr84ytJ3wzt6e87w/Jh2vWJtMigcuX+uXHlpV5i+/NMLCYiHjfH5q5PSU9vu/+byx9YLmx9YQveT/qyVt5Uv8jTUlWq9Xj8ahOms1mQ4oBACQ+klh8nTt7+vSJl6THeYXrf9J61th6wud9f2j/P1bIh51DtwwsJlLKyl/43x1J9BPqyYb9QwPvSo+Taxfy5P2oJ2/lSf2PNCW1trba7fapqSn5TEZGRkdHh4ElAQASGbMTAQDQgM1m6+3tlQfBrFZrb2+vzWYztioAQMJiTAwAAG3YbLbR0VGjqwAAJAfGxAAAAABAbyQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAAAAAQG8kMQAAAADQG0kMAAAAAPRGEgMAQBtut9tms5lMJpPJlJOT43a7ja4IAJC4SGIAAGjA7Xbn5+d7PB7p0Ofz2e12whgAIBiSGAAAGqioqFCdmZqaqq6uNqIWAEASIIkBABCryclJn8/nf14eIgMAQIUkBgAAAAB6I4kBABCrzMxMo0sAACQZkhgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgt3uMLgAAAACYx4GnN3ku9EmPyxxVOw4emfclngt9V4c97S2v3pmelE9a1xXbHnnUuq54xSprvGoFwkMSAwAAQEJTxrBw9Hd1trccuzocYEM/z4U+z4U+cfRwUVn5tt3PLss2a1cmEBmSGAAAABLX8UN7I4phjXtr+rs6531af1fnyBXP8yfbCWMwCuvEAAAAkKDaW451uU6F//wDT28KJ4ZJxsd8L+6piaouQAMkMQAANGC1BlhzYjbzu3Ygel2uU68fPRzRS2amJpWHlTW7Dr92pnPolvSf80hLUVm58glXhz3hJzdAWyQxAAA00NrampGRoTyTkZHR0dFhVD1Asrs67Dl+aK/0eFm2ucxRFc6r9r3cIj0oKiv/+bv/tW33Aeu6YvmrRWXlziMt23YfUL7kt2+f1ahkIDIkMQAANGCz2Xp7e+VBMKvV2tvba7PZjK0KSFJ3pifleYNp6Znhr+Zalm3etvvAtt0HnEda0tIzAz6nsmaXMp6NXAnQ2APQAR07AADQhs1mGx0dNboKIBUcP7R3fMwnPX7+5JmImmpU1uya9zlPbKqSu4DIbwTojDExAAAAJJD2lmPy2q1tuw/EY+OvtPSM+Z8ExBlJDAAAAIni6rBH7tJRWbMrnAGuGNHFHkYhiQEAACBRyMvDVqyyqlpraEi56bNyzRigJ5IYAAAAEsLrRw/Lq7a2P3ckfm+k3KPsO4+Xh3gmED8kMQAAABjv6rCnveWY9DhOy8MkXa5Tct6zritmTAxGIYkBAADAeCee+2L3sBWrrPFbHjY+5pPXoaWlZ+44GMeRNyC0BdfF/vKlfnHiRV3f7s9u3rh+Wse3jtHNj64rD5OocpV3Ot4cUvy/kOBu3pj7a9f5sxqj5P2oJ2/lKfOPFACEEO0tx+S1W/Gblzg+5nv2qco705PS4Y6DR2jXAQMtuCQ2dOndoUvvGvLWN29cP33iJUPeOnbJW/m5s28aXUKUDPysxih5P+rJW7lI5n+kqcTtdldXV3s8HiGE2Wzu6OhgZ2cgHHemJ9tbXpUelzmq4jQvcXzM9+KeGnleYmXNrqIyVojBSMxO1MNXv7bY6BKilLyVi2Qunsr1R+WIndvtzs/Pl2KYEMLn89ntdrfbbWxVQFJ4/ehhaZwqLT0zTv0SpdEweditzFEVv8aMQJhIKbsHXQAAFG9JREFUYnr4/aczRpcQpeStXCRz8VSuPypH7CoqKlRnpqamqqurjagFSCbjYz65k2Flzc609Mx4vMWzT1XKo2FFZeUsD0MiWHCzE81mc05OjtFVAEBy6+vrM7qExDI5Oenz+fzPy0NkAIKR+yWmpWeWOao0v74qhlnXFTuPtGj+LkAUFlwSq66ufu6554yuAgCSm8lkMroEAKngzvSkPCB2Z3ryu+u/Gc6rulyn5FftOHgkRH5TxbAyRxWjYUgczE4EACBWmZnaz6cCFoI701PxuzgxDAmOJAYAAIBUc2d6khiGBEcSAwAAQKo5fmivcm0YMQwJaMGtEwMAAECCWJZt7hy6Fc4z21uOvX70sPR43gGu9pZj/V2d0uMVq6zOIydjrBOIB8bEAAAAkDqU+0SnpWfue7klHp3xgdiRxAAAAJA6ulynpH2ihRCVNTuXZZuNrQcIhiQGAACA1CEPiAkh4rFBGaAV1okBAAAgRfR3dcoDYkKIMDcoE0Icfu2MdV1xfIoCAmNMDAAAAClifGzU6BKAcJHEAADQgNVq9T9pNrNABQAQGEkMAAANtLa2ZmRkKM9kZGR0dHQYVQ8AIMGxTgwAAA3YbLbe3t6KigqfzyeEsFqtra2tNpvN6LqAFFFZs6uyZpdWTwMSAUkMAABt2Gy20dFRo6sAACQHZicCAAAAgN5IYgAAAACgN5IYAAAAAOiNJAYAAAAAeiOJAQAAAIDeSGIAAAAAoDeSGAAAAADojSQGAIA23G63zWYzmUwmkyknJ8ftdhtdEQAgcZHEAADQgNvtzs/P93g80qHP57Pb7YQxAEAwJDEAADRQUVGhOjM1NVVdXW1ELQCAJEASAwAgVpOTkz6fz/+8PEQGAIAKSQwAAAAA9EYSAwAgVpmZmUaXAABIMiQxAAAAANAbSQwAAAAA9EYSAwAAAAC9kcQAAAAAQG8kMQAAAADQ2z1GFwAAADDn5kfXP77xofR48b0ZlpV5xtYTvpnbU973h+TDNWuLDCwmUpcv9cuPLSvzFt+bYWAxEfG+PzRze0p6fN/931j6wHJj6wkfH3VDJNRHnSQGAAASyLmzp0+feEl6nFe4/ietZ42tJ3ze94f2/2OFfNg5dMvAYiKlrPyF/92RRD9bn2zYPzTwrvR46/YfbN2+z9h6wsdH3RAJ9VFndiIAAAAA6I0kBgCABqxWq/9Js9msfyUAgKRAEgMAQAOtra0ZGXetN8jIyOjo6DCqHgBAgltw68RaW1t7e3uNrgIAkGpsNltvb29FRYXP5xNCWK3W1tZWm81mdF0AgAS14JKYz+eT7pEAAGjLZrONjo4aXQUAIDkwOxEAAAAA9EYSAwAAAAC9LbjZiXlr1yfRFhkAkJjkPXAAAEB0FlwSW7O2KIm2/AOAxEQSAwAgRsxOBAAAAAC9kcQAAAAAQG8kMQAAAADQG0kMAABtuN1um81mMplMJlNOTo7b7Ta6IgBA4iKJAQCgAbfbnZ+f7/F4pEOfz2e32wljAIBgSGIAAGigoqJCdWZqaqq6utqIWgAASYAkBgBArCYnJ30+n/95eYgMAAAVkhgAAAAA6I0kBgBArDIzM40uAQCQZEhiAAAAAKA3khgAAAAA6I0kBgAAAAB6I4kBAAAAgN5IYgAAAACgN5IYAAAAAOiNJAYAAAAAeiOJAQAAAIDeSGIAAGjAarX6nzSbzfpXAgBICiQxAAA00NrampGRoTyTkZHR0dFhVD0AgARHEgMAQAM2m623t1ceBLNarb29vTabzdiqAAAJ6x6jCwAAIEXYbLbR0VGjqwAAJAeSGGA87/tDQ5f6ve8P3fzoQ+X5Nd8uWnr/N9asLVr6wHKjagMAAEA8kMQAw9z86PrPT7x48dyvPr0zHfAJQwPvSg8efGh1+T/8z0c2/M3iezMCPhMAAADJhXVigAFufnT9hV1VT5V9652zbwaLYUrXPrjyyo921pR+6/SJF3UoDwAAAPHGmBigt9MnXjx94qUoXvjpnenTJ166eO5Xz7zwM8vKPM0LAwB/l/+jXwhdfwd0+VK//PjmjetJ9Buomx9dVx4mUeUq73S8OaT4fyHB3bwx99d++VK/SJ6/dj7qhtP/o678uAohTLOzs3q+vc7sdntfX5/yzNbtP9i6fZ9R9WCBm7k99cLOKnnOoVr2w2LJCrEo7YvD6XFxa0TcGgn43Gd+/OqGii3xKROYX3neEtWZ8+fP2+12I2qB9vzvngAAbR08eJAxMUAnM7enfli98doHV9RfyF0vVpeJ3KLAL5seF1f7xX/+Qkx/rDz9yo92CiEIYwDiITMz0+gSxFe/tvj3n84YXUU0krdykczFU7n+krdykRjFZ2Zmsk4M0EPgGJb9sKh5Q5Q/HzSGCSHSl4lvVYqafxXF/yQWLVZ+5ZUf7TzX8WZ86gWwoH3/+983ugRh+A9JUUveykUyF0/l+kveykViFF9dXc2YGKCHn+7fqY5hxf8kvlUZwSW+VSlWFInOg8r5iq/8aOfSB5avWRs8yAHQkdvtrq6u9ng8Qgiz2dzR0ZGkOzvb7fZ/+7d/a21tnZycNLoWAEg1OTk53//+9zMzM0liQNx1/kvTv7/z67tOPf4Dsbos4gulLxN/3yS6XhTDb8vnXthZ1dL9O7rbA4Zzu935+fnyoc/ns9vtvb29SRrGKioqKioqjK4CAFIZsxOB+Jq5PfXz43f3FIouhsnK9onsh+WjT+9Mv9bwo+ivBkAj/rllamqqurraiFoAAEmAJAbE12sNP7prx7BHqmKKYZLy50X6ffLRO2ffVPWTBaCzyclJn8/nf16aqQgAgD+SGBBHM7en3jmraKqxJFesq9LguovSRNldmzH8PGm38gAAAFiYSGJAHKl7G9q3a3bpbKtyjuLFc7+auT2l2cUBRCgR2r4DAJILSQyIo3Mdp+cOluSKbKuWV1+3TX746Z3pi/9/e/cXGteV3wH8qgS2WLbGU4h3ide1drywplGwQQ5JNy+qLW1JIHWglbHalKQPlsEsuyHF0ZA8bF5kNN6XJNu6SOyy3hDqIpHETh8Wr5S1DHG7EE3+bNTghXgWGm+I7YeJ7WipoVR9uJvx1cQznpFmzmjkz+fp3jv3/uZHLDn+cs49582fV7kXAIBVRRKDZlm4fnXJyvV/9p0Gf8HXdyTfFvvg7XMNrg8AQNNYxR6apXB+fsn5N5uw69e2h6J3X4sPf/P+29//677yXcu+ZNM9W5596eXM9p4q9xTOz7/43HeVUqr2UlEUffTRR319fVVuSO61VUUt23CtzlIAUJeOxcXFVvfQRH19fWfPnk1eGTp0eOjQM5XuhwY6cezoiWM//MPJVzqjQ6ca/x0XzkVv/KDeh9at7zpy/FSlf38Xzs8/9Td/oZRS9Zbq7Ox86623KmWVsr22qkulUlW24Wq7Umv7/7MALJvZiRDE3duaUvYr65fx0O8/v/bic9+t9OmR79WxuqNSSpUsLCxU2Turrj2Cq2/DtQZKAUAkiUF7W27AqzTZbOH61cuf1Lc1mVJKlVSa41dpr607uRQArJYklsvlcrlcR0dHLpdrdS8AAADNtVqSWDabzWazre4C2s2VC8t7btM9W255vXND6hvfulcppZZXauvWrbe8vnHjxh076tvCYc2U2rt3b11fAcCdY7UkMVjjrl1qStkbny/joXXru5596eVKn35/9J/Wre9SSql6S3V2dp48ebLSp8ePH0+lUjWWSqVSa6aU98cAqEQSg2bpuT+xbP21S9G1Txv/HR/ffGvlT+7+WqXBjaRvfOveKmvlRVGU2d5z5PgppZSqq1QURS+88EKVRd537tw5OztbaUwpaceOHVWWKGyXUqlU6oknnnj99dclMQAqWS2r2Hd0dMQHY2NjIyMjjSprFXtaaOH61aE//+bN8+8cju79ywZ/xysHSxMUd+/d/9TojxpcHyr4q567y66cOXOm+n5iAECSMTFolvLXbD483eAvuHIh+Z7Yffc3YedoAACaQxKDJnpwzyM3Ty7+Orp46yWwl+mdV5d+18ONLA4AQDNJYtBEe/YOLTn/z581rPSVC9GHvyid7d67v3NDrQsPAADQcpIYNNGmzVt2791/8/zir8sGspbv9NHk2Z7H9le6EQCAVUgSg+b627IVYs7+y7I3Abvp9NFkkQd2P+wlMQCA9rLSJDYzM9PxhXw+X8sj9d4fKxQK27Ztix/ctWtXoVBYbssQ1KbNW4YOHV5yaerpFYWx00eT8xLXre86MDK6/GoAALTCSpNYOp0uHReLxdven0xQyWdv+9TAwED8bG9v7/T0dCaTqbNTaJmhQ88sWUTxxkI09XR04VzdhW58XhbDoig6kB3dtLmm7Z4AAFg9VprEkomolnGqZFqrMU3l8/myGFZ7hINVonx73BsL0Rs/iE4fjW58XmuJi+9Hrxwsi2GPPj7sDTEAgHbUgDGxUi6qa0ysxhg2MzNTimH9/f1iGG2qc0Pq2ZdeXre+a8nVD38R/eTvotlj0bVPqz184Vw09XQ09Y/RtUvJy7v37j+QNS8RAKAt3bXyEplMJn7jqyyJDQwMzMzM9Pb2zs3NlS7WlcRyuVw2m42Ph4eHx8fHV94ttEpme89Lr86Ofu/vf/ub/7p59cZC9O5r0buvRV1fjb6+I+r6WrRlRxRF0dVPo2uXoisfRRffj24sfLna0KHDQ2VrgQAA0D4amcSSsxOLxeLMzEwURfl8Pp/P9/b2lq7HB6UrlWSz2VwuFx+PjY2NjIysvFVorU2btxw5fupf//nov78yUf7ZtUt/mHn4q9sUWbe+66nRHy3ZMxoAgHbTgFXsS6NbySQ2NTVVOo4jWdk9VSYZFovFgYGBUgybnp4Ww1gzOjekDmRHR396cskaHjV79PHhn0y/I4YBALS7BiSxUqZKJrFk+rplEqs0OzGfz+/atSt+JJPJzM3N9ff3r7xJWFXuu/+hF1+dffbFnz2w++Fa7l+3vuvRx4d/fPqdA9nRzg2pZrcHAECzNWB2YnLmYaFQyGQyxWKxbEwsvh4lklil2YnJB8fHx287iRHa14N7HnlwzyML16/+6s2fF85/8Nvz8wvXr5beIuvZ9e3OrlRme88Dux/JbO9pbasAADRWI5NYFEVx4iqlqeHh4YmJiSiKpqamRkZGisVi/J5YOp2uZcWOgYGBycnJwcHBlTcJq1bnhtSex/bviSxGDwBwB2nM7MSyCYpxEstkMmNjY/FH8ZV4YY+o6sKJY2Njw8PDpdN9+/aVXhgDAABYGxqQxKLEsFihUCgUCvFbXoODg+l0Oh7Ryn8hvq36q1/j4+OTk5Ol02w2e/DgwYb0CQAAsBo0PomVpibGGaw0t3Bqaqq0hP1td2ceHBycm5srDZ1NTEwIYwAAwJrRmCSWXMg+fjGst7c3jmf9/f3xpxMTEzWOicV6e3unp6dLGU8YAwAA1owGj4nl8/n4VbHku17xcWmv56jqe2JJmUymLIxls9mGNAwAANBCDUtiyQmHpdfDYslU9uWbq0un08kwlsvlLOABAAC0u8YksWjpWvbxWh2l03Q6nQxj9e7UnE6nJycnS8No2Ww2uecYAABA22lKEhsZGSn7NDlEVuPUxKRMJpNcTfHgwYOlHaIBAADaTuOTWGmJjqT+/v7SUFgys9VVf2xsLD4uFov79u1bbqcAAAAtdlejCg0ODi4uLla5YXp6usqn1Z+NjYyMfHm0DQAAoO00bEwMAACAGkliAAAAoUliAAAAoUliAAAAoTVsxQ5u6fLvPr70yX/Hx50bUpntPa3tp3YL168Wzs+XTu+7/6EWNlOvD94+VzrObO/p3JBqYTN1KZyfX7h+NT7+6j1/umnzltb2U7v2/VFv387b+pcUAJDEmuvNUydOHPthfNyz69tHjp9qbT+1K5yff+4fHiudvjF/pYXN1CvZ+ehPT7bRv1B/PPbc/Nx/xMdDhw4PHXqmtf3Urn1/1Nu387b+JQUAzE4EAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAITRIDAAAI7a5WNxDaB2+fi44dDfp1X7j8yccnAn71Cl3+3cfJ0zbqvMwvT/7bfOJPYZW7/MnN/+yBf1ZXqH1/1Nu38zXzSwoAd6aOxcXFVvfQRH19fWfPnm11FwBr35kzZ/r6+lrdBQC0DbMTQ/jjdZ2tbmGZ2rfzqJ2b13l4OgcAApPEQvif3y+0uoVlat/Oo3ZuXufh6RwACOyOe09s69at3d3dre4CoL2Z+A0AK3THJbEnn3zy+eefb3UXAO2to6Oj1S0AQHszOxEAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACA0SQwAACC0jsXFxVb30ETvvffeZ599FkXR//7f4l1/1BFFUXd3d3d3d4vbAmhzs7Oz8UHpb9edO3du3LixlT0BQFv5fwgF24/0WVXlAAAAAElFTkSuQmCC">
<h6><span class="label">Figure 1-7. </span><code>Rc</code> and <code>Weak</code> pointers all referring to the same heap item</h6>
</div></figure>

<p>The underlying item is dropped when the strong reference count drops to zero, but the bookkeeping structure is
dropped only when the weak reference count also drops to zero.</p>

<p>An <code>Rc</code> on its own gives you the ability to reach an item in different ways, but when you reach that item, you can
modify it (via  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.get_mut"><code>get_mut</code></a>) only if there are no other
ways to reach the item—i.e., there are no other extant <code>Rc</code> or <code>Weak</code> references to the same item.  That’s hard
to arrange, so <code>Rc</code> is often combined with <code>RefCell</code>.</p>

<p>The next smart pointer type,  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>, relaxes the
rule (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>) that an item can be mutated only by its owner or by code that holds the (only) mutable reference to the
item.  <a data-primary="interior mutability" data-type="indexterm" id="OEBPS/ch01.html.id614"></a>This  <em>interior mutability</em> allows for greater flexibility—for example, allowing trait
implementations that mutate internals even when the method signature allows only <code>&amp;self</code>.  <a data-primary="isize" data-type="indexterm" id="OEBPS/ch01.html.id615"></a><a data-primary="Ref type" data-type="indexterm" id="OEBPS/ch01.html.id616"></a><a data-primary="RefCell type" data-type="indexterm" id="OEBPS/ch01.html.id617"></a>However, it also incurs
costs: as well as the extra storage overhead (an extra <code>isize</code> to track current borrows, as shown in <a data-type="xref" href="#OEBPS/ch01.html.fig_1_8">Figure&nbsp;1-8</a>), the
normal borrow checks are moved from compile time to runtime:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">cell</code>::<code class="n">RefCell</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">rc</code>: <code class="nc">RefCell</code><code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">b1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rc</code><code class="p">.</code><code class="n">borrow</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">b2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rc</code><code class="p">.</code><code class="n">borrow</code><code class="p">();</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch01.html.fig_1_8">
<img alt="The diagram shows a representation of a stack, with three entries in it, each containing two 8-byte values. The top entry is labelled rc, and holds the value borrow=2 above a value 42. The middle entry is labelled b1, and holds two values with arrows: the top arrow leads to the 42 value in rc, the bottom arrow leads to the rc entry as a whole. The bottom entry is labelled b2 and holds the same contents as b1: a top arrow to 42 and a bottom arrow to rc." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuEAAAP4CAIAAAD8jLUiAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzdf3BbdX7/+0/u7vdLh4RY3pkNXDasFCedZSCslDq0QDqVDA5p97ZYNJiBnW0s3yzJ/cKFyGUWe0ppjr+UHRuGjQIXvtfezfg47SxMvClyvnN3a2LwcWcNbIkbqQSGnRLnaBO4ITuDpZAw3fYyuX+cRTk+R7YlW9I553Oejz8Y6SPp6K0ERy9/fq64dOmSAAAAcJn/xekCAAAASiCjAAAANyKjAAAANyKjAAAANyKjAKi+rVu3rjBxuhwAnkRGAQAAbvRlpwsAcNnIyMj09PT09PTMzMzMzIwQorGxsbm52fhve3t7U1OT0zUCQJ2sYH8UwA1GRkZ6enqMXLKAXbt2DQwM1Kek5di6dev4+HjxLv/OAFgC+lEA5w0ODu7evbucZ9pDzODg4OzsbPFud3d3NSsDAOeQUQCHjYyMlBlQ5nu5uceCjAJAGmQUwGE9PT3mu42Njd3d3a2trc3NzUbL+Pj47Ozs+Pi4OYsAgPTIKICTRkZGzMM3TU1Nx44da2xsND+ntbVVCNHe3i6EIKYA8A/WHgNOsswv6evrswQUCyOvAIAfkFEAJ01PT5vvEkEAoIiMAjjJvCRHCLFwJ4pZf3+/sYWrZfTHvLtrf3+/5VXGCuetW7euX7+++LT169fv3r17ZGRk0TedmZnp7++3vHzr1q09PT2WsLWo8fFxc6lbt26t6OUA/ID5KICLzM7Olh9TKjI9Pb1161ZLJDLMzMwMDg4ODg62trYeOnRovgL6+/st03sNxmTe/v7+vr6+8lcVWZYysRwJgB39KICTLPvGltOZsTSzs7MlA4rZ+Ph4yf6M2dnZzZs3lwwoS9Pf32+eiLNr1y4GuQDY0Y8COMmSUXp6epqbm4urjhfQ2NhofK9PT0+bw4f5y34JXTLT09ODg4O7du2yVGUfyim+UaVLjWZnZ82DUI2NjX19fZXWCcAXLgFwzsmTJ+0/ld3d3SdPnizzCpYeiPmeduzYse7u7kOHDpmv/MknnwwMDFiiTHt7u/mFR48etZf3ySefWC6+a9euvr6+cqqyBCDzqwDAjPN6AIdZjrYpav9CRS9fwk+0ZYinsbHxk08+Kd699957zSNQZU46ma+q6enpzZs3F9ubm5uPHTtWacEAfIL5KIDD5tsTZWRk5N57712/fr19eU51tba2moeczCNHs7Oz5oDS1NS0zMmtlkktjPIAWAAZBXBYc3PzAlu3zczM9PT0rF+/vqY7zFqmxRRZ3tQyTFMpy9FCTJUFsDAyCuC8Xbt2HT16dIGpsjMzM1u3bh0cHKxnVcK2DW45k3kXYO5EYaosgEWRUQBXMGZmDAwMzNelIYTYvXt3LWLKAsuSLe3LySiW9cbd3d012gkGgDSYMwu4zvj4+MjISMk40tjYePLkSfO3+xLmzI6Pj09PT8/MzMzMzFiWLlsusuQJuZYXnjx5cvPmzcU3ampqKrmgCQDM6EcBXKe1tXVgYODkyZP2+R+zs7NL7koxNib5yle+YuxePzg4OD4+vujGblUxODg43yYuADAfMgrgUk1NTQMDA0ePHrWMiVR6Mk7xVUY0qU8osbCErcHBwaV9CgC+QkYBXK21tdWy3Hdp3+67d++2v7C5udm4/gKTYKrCvmi5ijvrA5AVGQVwO8s2bpa1NuWw9Fs0NjYODAxcunTp2LFjR48e7evrq3VGEbZJssZJhLV+UwCeRkYB3G75AcJyVOGhQ4fK3OnEMsy0nHGixsZGS1eK5ehjALAgowDyM/dYNDU1lT9l1bLYeJmTSCyDSjMzM/Xf8QWAh3Du8RIpimLc+M/PL/2XL60QQiQSiVAo5GBJkJUlGSxzUUxFvTL26brLfPfu7m5z90lPT097ezsbpaBI13VVVYXpn1Zh+vcWfkNGWaLe3l5LSywWI6OgFizzNuowd6TIkkgGBweXeV7Prl27zJNjjKXUy7wmZKLruv1fVzKKbzHWAzjJsvuq3fT0tOVMwYU3ey15AKH5JRXNVG1qajK/dmZmZoEDDsucrWLZAn/RPwEAvkVGAZw0Pj6+fv36zZs39/f3j4yMmDsYxsfHd+/ebd6eVQjR1NRkme5q6ero6enZvHnz1i8YjZZYY8kZxoaz81Voebuenp7+/n5LHJmeni5/n/7W1lZzzcbOcuW8EIDfsBf+Eq1YscLSMjExEYvFnKgFHmbZM35Rhw4dsi9FXr9+fcknt7a2Hj16VAgxPj5ezCvFh4ygMD09bVn1I2x73m/evLnk3irGPJLibvp9fX3FUZuFN9Gfnp7evHmzueXo0aNsPgshhKZpLS0tlka+p3yLfhTAMwYGBiwBRXyxHe3CL7R0XQghxsfHe3p6enp67AGl5Pvap7VOT08be5wsYUFyc3OzpXuGrhQAdmQUwEmtra3lzIFtamo6evTofJua7Nq16+jRo+3t7cVLGSHAPBf10KFD801kMY5cXuDdjScs2s9R0fIcyzxZ4xjF8l8OwA8Y61kixnpQRcZBxMbgSHGIxBhMMbpAFp4nW77BwcGRkZHiW7S3t7e2tpa5n5v4YnPYYqnii0m1zc3N5oQELBljPTAjoywRGQUAqo6MAjPGegAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUQAAgBuRUeaVyWRUVU0kEpFIRFVVp8sBAMBfvux0Ae6Sz+fT6bSmael0ulAoFNszmcyir21paallaQAA+AsZRQghdF1Pp9Oqqmaz2ZJPKCejAACAKlpx6dIlp2twkqqqqqpOTk4u+kzLH9SKFStqVhQA4DKff0/5mU/7UXRdV1U1lUqZB3QWlslkIpFITasCAABFvssouq4rijI8PFzpCxfNKN/t/tt1129cRmkA4Hen3j/xo/6/droKuIWPMko+n0+lUr29vRW9KhwORyKRWCwWi8UWfua66zfedPOWpdcHAABM/JJR0ul0IpEoc2QnGAzGYrF4PB6LxQKBQK1rAwAAdvJnlHw+n0gkRkdHF31mMBiMx+PGhih1KAwAACxA8oySyWTi8Xgul1v4aR0dHYlEYtHRHAAAUDcyZxRVVZPJ5ALjOw0NDclkMplMMqADAIDbSJtRVFXt7Oyc71HSCQAALidnRlk4oLS1tamqSjoBAMDNJMwoCwSUhoaGdDrNvBMAANxPtnOPM5lMMpks+VA0GtV1nYACAIAnSJVRjGXGJSfJdnR0aJrG+A4AAF4hVUZRFKXkwcUdHR2qqta9HAAAsHTyZBRd1/fv329vJ6AAAOBF8mSURCJhbwyHwwQUAAC8SJKMkslkJicnLY3GKh5H6gEAAMskSUZJpVL2RkVRQqFQ3WsBAABVIENGyefzw8PDlsZgMDjfImQAAOB+MmSUkgM6iqLUvRAAAFA1cmaUhoaGklNoAQCAV8iQUTRNs7TE43EnCgEAAFXj+YySyWTsG8uSUQAA8DrPnylo70QRZBS/yr45+cF7WSHE2MjBq68LPfnDnzhdEQBg6TyfUfL5vKUlHA47Ugkc98F72eF9Txq3r74u5GgtAFxH13VVVVlR4SGeH+ux96OwJwoAwCyfzyuKsm7dupJd73Atz/ej2EUiEadLAAC4haqqyWTSPnMR7uf5jKLrutMlAHA1Y6LS4QPPXzh/eWg4fGs0cssfhW+NbriB0WFpaZqWTCaz2azThWCJPJ9RcrmcpSUWizlRCADXmRo7cvjAc8ZMaovsm5PZNyfFvie3bLuro+tvrlkbrH95qB1d1xVFsW9BDm/xfEYBgJL6H905NXZk0adNjR05+W72v//oMDFFDvl8PpVKpVIpBnck4Pk5swBg98QD95QTUAxnz+Se/sudNa0H9aGqaiQS6e3tJaDIgX4UABK6WJizK8H2nY8Ys0+Mu1NjR37+6qg5xHzwXnZq7MiWbXfVtUpUTyaTSSaTk5OTTheCavJ8P0owaO2eZRYtgMd+cMC4sWXbXT9+4986up4oBhSjsfvZAx1dT5hf8vNXR+taIqokn88nEolNmzYRUOTj+X6UUChkmTZLRgFwzdqgEUG273xkvuds3/lI5q1/yr752y+2k++y+sN7FEVh6onEPJ9RAKCkBdJJ0R/fs6OYUc6esS4ShJul0+lkMmlf2gmZeD6jhEIhS/9eJpNxqhi4jbHu1DztYMu2uzbcEC7n28vMvsHGqtWB7Tsf3nBD2DyCUI6zZ3JTY6PGjbGRg/YnGPt2iDK+Yqt4qaV9wLs2ftW4cc3a4OA/Hlv4LcyeeOCeYjI4cuLX5b+w6latbnDw3bE0uq4nEglGdvxAhoxiabGf4AMf+vi0XvwGNZsaOzI1dmR435MP7X12W/uORa/zwXvZF5VH7RtsXDifN84G2nBD+EHl2UX3AZsaO5J5a7JkkrAw9u0I3xqdL1hU8VJieR/wmrVBo+/hwvnKetqLE1pdtdzXVcWgJGNL+/379ztdCOrE83Nm7RmFfhSIMvrtX+h9tP/RRZabjo0c/Mt7W0vuAFb0wXvZv7y3ddHEUGaqKFog9FTxUsv8gKtWB4wbF87nzVu4Lqr4t+P40Y/mz15plxjqLJVKhUKhZQaUycnJFXC9RCJhdDdI2I9SKBTy+XwgEHCiHHjJ1NiR4bVPWhZ3FI2NHHyh99EyL2U8s5yOmTJVcQxivkst/wNefV2w+B1/4XyhGFkWZRpRulybeQCoUuFbo0/+8CdLeKE5e/3hnSw8dim2tPeb4eHhTCajaZrnM0rJne8zmQw74kMIsWXbXX94Z1tx04vsm5M/f/WI+Wvp8IHnzNtmFJ09k7N8f1suNTV25B9/ctD8nfpC76PhW6PljBdsuCFsXGfLtjbL840pJpm3/qnM3+mXfKmqfMBr1oaKtz8+rZc5VmLu4jJfof7GRg4WiwnfGqUfxbVaWlqcLgH1ls1mVVX1fEYRQgSDQcvUbk3TyCg+d83a4GM/OGAZ5jC+h/7wzrueeOCeYuPwvid/YPtyOnzgOfNd++SVLdvu2rLtrsMHnjMmbRRf9dDeZxetbcu2u+abIHLN2uD2nY+UP6V3yZeqygc094KcPZOzDCl9+7bfNfpLfvzGv5m7WD4+rZe8Qp2dPZMrfrRVqwPl/MUBqKd0Ou35+ShCiEgkYmlhSgquvi403zyM8K1R8/jOB+9lLRMyLMtktu98ZL5BHEsIMP9e7mbV+oDmXhDLfJQP3ssWWyxzWdzQj3L2TO5vvru9WOFDe59lwizgQjL0o0QikdHRORtEaprmUC3whu07HzGvs50aO2IONMaCXoOxBHfBSz08NnLQdKnRShc211+1PuDV113+Xrcs7bFsM29+yJxmzFdY2oSSJTBO5ylGpe07H2ELfMCdZOhHsQ/rFAoFdpvFwsw9B5Yv0blrPf5o4amgq1YHwrf+0XyXcqdqfUBz38PZM7r5VeYYNDV2xJxLzGlm0TXbVWf0oBQ/xbb2HfNNmoZ7vPLKK/ZjT+AHMmQU+1iPoCsFizHPhDDPkBBz90Qv50vU/BxP7KderQ+4anWgGFM+Pn15BOeD97KWMa/sm/9kftS4Uf/hFSOgFGvbsu0upqF4Qjwe13V97969DQ3suecvMoz1BAKBcDhsWZamaVoikXCoIniA+XvX8oVqvlvpV7hX5qMUby/zA159XchoMfevmAd6DD9/dbQ4nlJMhOtvrGsniiWghG+Ndj97oJ4FYJkURUkkEoqiDA8PL/ki4XA4lUpVsSosn6qq8/2dypBRhBCxWMySUdLptFPFAP6x4Yaw+bwbo2ukOEl2W/sO4/bU2JELe/PGoFIxJdRzwqwloGxr30EPiheFQiFVVY2ksrS98AOBAKs+3WaBcQ8ZxnrEPFNSWN0D1Jp9yKw4+8RY0Fuc7GJ0rpi7W+o2GYWAIplYLKZp2tDQEEM/0pOnH8XeqGlayakqgJh/7qcwHUNjPG3Rrb0WuJQ7VfEDWoaBwkL8/NXfzpY1ZiVva99h7MXy81ePbGvfYZ62Yl7UI2q2z+yF83kCipQSiUQ8Hk+lUr29vU7XglqRpB/FmJJiaWS4Bwswf+9aJkaY75azTmeBS7lTFT+g+e7ZM7kL5/PFyShfbIB7eZPfs2dy5uU/9elHeaH3UfMcFAKKTAKBgKIop06damtrc7oW1IQkGUWU6kqZnJzkDGSUdOF83rzSxPJlab6bffOfFj4tb+FLuVMVP+Cq1YHiaM7ZM3pxJkr41qjxzA03hIsvmRobLcad+vxBHT7wXDEzbbgh3P3sj+rwpqizUCiUTqcnJibsv6nC6+TJKPF43N5IVwpKeqH3UfMX85Ztc34JM9+9cD5/+MDzC1zKvBec/VLuVN0PWNw95ePTl7evNZ/PV+xKGRs5WBzrqUOHk/mjrVodeOwHB8o/9RCeE4vFMpnMvn37mKQiE0nmowghYrFYQ0NDoTBns0tWIMOu/9Gd5sWx29p32OejFBekCCEOH3jOaLFf6vCB58wH39gv5U7V/YDF5TnFPpJVqwPmnVu3te8wTsY5eyYnRHFRj/U6Vd9n1rw97vadD3virwbLlEwmjVU/+/fvd7oWVIE8/Sii1HAP/Si+9fFp3bJLx9kzucMHnvv2bb9rbl+1OlBy6/rtOx8x/879Qu+jlmQzNXbkiQfuMZ+3N9+l3KmKH9A+arNl213mi1sii6EOhwyb+4fmO5AI8gkEAqlU6tSpU9EoB1l7njz9KEKIeDxuObinUCik0+mSw0CQ29kzuf5Hd4pHF3nafIfJXbM2+NDeZ/sf3VlsmRo7MjV2ZIELeutcuip+QPNO+QZ7IPjje3ZYImOt/6wsG/B/+7bfLfOFT/7wJ3XIT6i1UCikaZrRlZ7LeWBnRZQkVT9KySzCpviYT/ezBxY4TK6ijdIf2vus586lq9YHNE+bFabZsmbhW6PmULLhhnCtp4ZYzg+CP8ViMTbR9zSpMgorkFGm8K3RwX88tmiq2Na+4weHxhdegbLhhvAPDo17dCihWh/Q3JVyz/9e+hRl8xXoqEA9KYqi63pHR4fThaBiUo31CCESiURXV5e5JZfLZTIZNnPzg+07H9m+85HiTEnzXApD+NZo5JY/2rKtrfyBBuMbOvvm5AfvZc0rXFatDmzf+fCGG8Je/7qtygfccEPYGMq5Zm1wvudva99RvL4nVmhDJoFAQFXVZDKpqqrTtaACKy5duuR0DdWk6/q6dessjXv27Kn6IVIrVqywtDw1lL7p5i3VfRcA8JV33p56vNM6al+V76lMJpNMJgUTANxHUZSSmwVHo1GpxnqEEKFQyD7cw/+RAOBb+Xw+kUhs2rRpaccQwkGyZRRRagVyNpvVdd2BUgAAjlIUJRQKDQ8PO10IlkLCjFJy0zZmzgKAr2iaFgqFent7LXt7wkMkzCiRSCQYtM6IZJ4UAPiEruuxWKylpYWdUbxOwowiSm2UwnAPAEgvn88nk8l169Yx9UQOfskogpmzACC1VCoVCoU4qUcmcmYU43xBSyNTUgBASpqmRSKRrq4upp5IRs6MIkp1pViO8gEAeJ2u6/F4vKWlJZvNOl0Lqs9HGUXQlQIAssjn84qirFu3jt8/JSZtRrHvkiKYkgIAUlBVNRKJlNycFDKRNqMEAoG2tjZLI/0oAOBpmqbFYrHOzk7WFfuBbGcKmsViMUsfYC6X03U9FAo5VBEAYIl0XVcUZZk7xmaz2ZK97C4UiUSSyaTPv7BkzijxeNxyBrIQIp1OG8dKAQC8QlGUVCq1/GU7+XzeK1unTE5OqqpqLFlyuhbHSDvWI4QIhUL2DWeZkgIA3uLbLe0LhULJ9R/+IXNGEaVW95BRAMBb/Dz1JJfL+flrS/KMYh93LBQKmUzGiVoAAEAFfJdRBF0pAAB4geQZJRAIhMNhSyMZBQA8xL6RBHxC8owiSnWlMNYDAB6STqcnJibsayAgPZnXHhtisZjlGMxcLpfP5wOBgFMlVcVr6ZfPffQr4/bGm7fcdPMWZ+sp3ztvT514e8q4vebar98Rv8/Zesp37sPTr42+VLx7/4OPOVhMRbxbuRDipRefLt6+o+3+NV+7zsFiKsIPaRXFYjFd11OplKIoy1ngEwwGE4lE9eqqJrbNtZM/o5RcWZ7JZLyyjc98Xku/dOLYG8bt+x8UHvrn78TbUy+9+Ixxe+Pm29zwz1+ZPv7oV8XKhae+6b1buRDCXPnGm7d4KqPwQ1plyWQykUgoimL5zbN8oVBIUZSqFlU1ZBQ7+cd6QqFQQ0ODpZEpKQDgRYFAIJVKnTp1KhqNOl0Lak7+jCJKdaXouu5EIQCAKgiFQpqmvfLKK0xSkZsvMop9WIeMAgBeF4/HdV3fu3evvbMccvBFRrFPjyWjAIAcFEXRdb2jo8PpQlB9vsgo9rEeP++sDACSCQQCqqoeP36cSSqS8UVGKbnMOJ/P178SAECNRCIRTdOGhoaYpCINX2SU+ZYf178SAEBNJRKJTCbDJBU5+CKjAAD8IxAIKIqSyWTYRN/ryCgAAAmFQiFjE337qW3wCjIKAEBasVgsk8kMDQ0x9ONFZBQAgOQSiYSxk4rThaAy8p/XAwCAMUmFFZ3e4ot+FJbwAADEPFtRwLV8kVFKBmevn3sMAIDcfJFR7KccM3kKAACX80VGsY/1lNzVDQAAuIcvMoq9H4WBHgAAXE7+jKKqaqFQsDTSjwIAgMv5IqPYG+PxeN0LAQAAFZA8o2iaNjk5aWns6OhwpBgAAFA+yTNKMpm0NyYSiboXAgAAKiNzRlEUJZvNWhqDwSATZgEAcD9pM4qqqr29vfZ2RVHqXgsAAKiYnBklk8mUHOWJRqMM9AAA4AkSZhRVVTdt2mRfbyyESKVS9a8HAAAsgWwZJZlMdnZ2lnxo3759bIsCAIBXyJNRNE2LRCL79+8v+WhHR0fJ0R8AAOBOMmQUXdcTiURLS4t9FY+hra2t5E5uAADAtb7sdAHLkslkUqnU8PDwAs/p6OggoAAA4DmlM8rMzMzIyIgQYnx8fHx83PJoU1PTrl27Wltbm5ubF7h0f3+/EKKnp8fS3tfXJ4TYtWtXY2Pj0orO5/OqqqqqOl/HSREBBQAAj7JmlPHx8a1bty78mpmZmZ6enmPHjs33hJ6eHiOgzPeocaO7u7vsOoUQIpPJaJqWTqft29vbNTQ0pFIpVhoDAOBR1owyPT1d5iubmprsjTMzM1u3bp2ZmVn05a2treW8i6ZpRjTRNK3kcuKSotGoqqqhUKjM5wMAALdZaD6KMShj6e0whoGmp6ftIzX2gNLX19fU1NTe3l5smZ6eHh8fHxkZWWCcSNd1RVE0TcvlchV9GEH3CQAAslhx6dIl8/3+/v7iWIzloUXde++9xiwWIURra+uhQ4eWMOMkn8+HQqHyu0yKGhoakslkMpkMBAKVvnYJVqxYYWn5nSuv/NKX6jcH+d8/u/j5558bt//Lf73iv15xRd3eepn+4ze/+c//+I1x+0tf+tLvXLnS2XrK9/nnn//7ZxeLd1detdrBYiri3cqFEBc/PV+8/TtXrvzSl77kYDEV4Yd0CT7//P/7988+szRW+mXkUfavFcPExITcx8wpilLy7JpoNFq179Tp6eliQGlubj569OjSrqOqaqUBJRwOJ5NJx/tO7D9XdfOf/3H5HxRv+fzzz83fQN5C5fVnTlrewg8psARVyyjFgCK+GCRamnw+X9Hzw+GwqqpsIAsAgGSqtodbcYlyU1NTmfNhS6p0oms2m920aVMsFmONMQAAMqlaP8rs7KxxY+FNUxaVSCQ0TVt4Wza7ycnJyclJRVFSqVQ8Hl9OAUt2R9t9a752nSNvDQByOPfh6ddGX3a6CrhF1TJKcTnPkndmK1JVNR6PZ75Q/uqeXC539913R6PRVCpV/9Gf2+P33XTzljq/KQDI5J23p8goKKraWE9xu5Rih8pyxONxRVHS6bSu67Ozs6+88sqePXvC4XA5r52cnNy0aZOiKMsvAwAAOKVqGaXYfVLOBm4VCQQC8Xg8lUplMpnZ2dmhoaG2trZFX9Xb2xuLxSqdgQsAAFyiahmlOE/W2KWtWpe1CAQCiUQinU4bYSUYDC7w5MnJyUgkkslkalQMAAConepnFFHqHMGqM8KKrusTExPRaHS+p+VyuVgsRkwBAMBzqplRzF0pW7durcrElEXFYjFN0yYmJuabrVIoFIgpAAB4TtUyihBiYGCgOCtlfHz8K1/5Sn9/v3lvN0N/f//u3bur29dipJC9e/eWfLRQKMTjceamAADgIdXMKE1NTUePHjWfh9zT03PvvfeumKunp2dwcLDqU2uFEIqiHD9+vOQklVwu5/hm+QAAoHzVzChCiObm5mPHju3atWvRZ05PT1f3rQ3GJNmS4z6jo6PsRQsAgFdUOaMIIRobGwcGBi5dutTX19fd3W1/Ql9fX19f37Fjx6r+1oZAIKBpWsmYkkwmGfEBAMATrBmlu7v70heWeenu7u6+vr5LNt3d3d3d3cvfjnYBRkxpaGiwtBcKhVQqVbv3BQAA1VL9fhSXCAQC6XTa3p5KpehKAQDA/aTNKEKIWCzW0dFhaSwUCiWzCwAAcBWZM4oQIpVK2Ud8GO4BAMD9JM8oxlk/lsZsNqvruhPlAACAckmeUYQQyWTS3qhpWt0LAQAAFZA/o0QiEfuubmQUAABcTv6MIoSIxWKWFo7vAQDA5VjnAMIAACAASURBVHyaUbLZrBOFAACAcvkio4RCIXsju6QAAOBm/s0oDPcAAOBm/s0oAABfyefz7OHpLb7IKAAAn1NVNRKJsIent5BRAAAyy2QysViss7Mzl8s5XQsq82WnCwBQTU88cE/2zUnj9rb2HQ/tfXbRl2TfnPzgvezhA89fOH95Inn41mjklj8K3xrdcEO4VrUCNZbP55PJ5PDwsNOFYInIKIA8zAGlHFNjRw4feO6D90osxc++OZl9c1Lse3LLtrs6uv7mmrXWjRABl1MUJZVKFQoFpwvB0vkio5RcZhwIBOpfCVA7L/Q+WlFA6X9059TYkUWfNjV25OS72f/+o8PEFHiFpmmJRIKRHQn4Yj5KyWXGkUik/pUANXL4wHNjIwfLf/4TD9xTTkAxnD2Te/ovdy6pLqCudF2PxWItLS0EFDn4oh8FkNvYyMHhfU9W9JKLhTmdi9t3PmLMPjHuTo0d+fmro+YQ88F72amxI1u23bX8aoFayOfziqLs37/f6UJQTb7oR7GfIBgOMw0QkvjgvewLvY8at69ZG9zWvqOcVz32gwPGjS3b7vrxG//W0fVEMaAYjd3PHujoesL8kp+/OlqlkoEqS6VSoVDIowHFSFcLTD/40z/9U0VR/Lk3ui8yiq7rlhYmo0AOF87ni6Mwq1YHyp81cs3aYEfXEx1dT3Q/e2DV6tI/Dtt3PmIOLiff5ZQruI6maZFIpKury6NzY436e3t7F6j/4sWLvb29oVBIVdU6luYKPs0o9lMGAS96offRs2d+O+7+33/0k4qmtW7f+cj2nY8s/Jw/vudyr0zxjQA30HU9Ho+3tLR494xYVVXLnzpTKBQ6OzsTiUSNi3IXX2SUyUnrYgd2x4cEDh94rjhlpKPriVpsZLJqdUPVrwkskzE4sm7dutFRD48/qqra2dlZ6auGh4eTyWQt6nEn+TMKi3ogpQ/eyxbnyZbTI7J8rD2GG6iqGgqFent7nS5kWTKZzBICimH//v3+OXVI/nU9ZBRIqTgNZcMNYcvk1ioyb+9mnpsC1J+maYqi2PvFKzI5OblixYpqleSUu+++u6bXDwaDsVhMURTHxxzk70exL+qJRvmnFt42vO/J4uyQB5XFd7tfMvOeK394JwuP4Qxd1xOJREtLyzIDCsqUy+WGh4cjkYh9Nmed+TGj0IkCT/vgvezhA88Zt2s0DcUwNnKwmITCt0bpR4FTIpEIZ+7UX6FQcHzui+QZRdd1+5RpFvXA015UfrsbyoYbwrWbhnL2TK4432XV6kA5ZxMCNeLRdcUScHxWsuQZxd6JIuhHgZeZjwCs3SjP2TO5v/nu9uIxyA/tfZYJswDqT/KMYp/8HAwGHZ8EBCzNhfP5wweeN25va99Ro1Ee43Se4ijP9p2PsAU+UGvB4Ly/Bvh5Y3TJM4q9HyUejztRCFAFw/ueNPo2Vq0O1Ggtj9GDUuyq2da+o3aLhoAy7d271+kSam6BPWR7enoaGny6U5HMGUXTNPsoJpNR4FFnz+SKq2y273x4vg3sl/kWf/Pd7cUelC3b7mIaCtxAUZRTp061tbU5XUhNNDQ0DA0NLfDddM0116iq6s+YIvP+KCV3uSGjwKOKa3lWrQ6UeXBgRSwBJXxrtPvZA1V/F2BpQqFQOp3WNC2RSJS5eXxJ4XA4lUpVsbDli0Qiix4hF4/H8/l8yRmWVZHJZLq6ump08eWQOaOU3BmF0wThRRfO54udKBfO57992++W86qxkYPFVz2099kFko0loGxr30EPClwoFovpup5KpRRFWdpin0Ag4N3fVL1b+ZJJO9aj67r9oCkmo8CjLpyv4dpLAgq8JZlM6rq+Z88epwtBzUmbURjoAcpx4XyegALPCQQCqVTq1KlT7BsuNx9llGAwyM4ogMULvY+a56AQUOAhoVBI07RXXnllgYW78DQ556Pk83n7sQ4M9MC7rlkbPHLi1+U88/CB54r7wy7aKXL4wHNTY0eM2xtuCHc/+6Nl1gnUXzwej8fjiqKkUil2pJWMnP0oDPQAizLvCLdqdeCxHxyoxXpmoD4URdF1vaOjw+lCUE1+ySgNDQ30owBmYyMHi7vdb9/5MLvdw+sCgYCqqsePH2eSijTkzCj2Y5AIKIBFsRNFCFGLDVcAR0QiEU3ThoaGmKQiAQnnozDQAyxqauxIsRNFCFHmhitCiCd/+JPwrfySCrdLJBLxeDyVSjFJxdMk7EcpmVHoRwHMzp7RnS4BqK1AIKAoSiaTkXUTfT/wRUZpa2tje1kA8CFjE/2JiQk/nx7sXbJllHQ6be/WoxMFAPwsFotlMpmhoaGVK1c6XQsqINt8lJJHLjEZBf6xfecj23c+Uq2nAdLI5/OZTObixYtOF4IKSNiPYmkJh8OhUMiJWgAArqCqaigU2r9/v9OFoDJS9aNkMhn7md2JRMKJWgAAztM0LZlM2o+YhSdIlVFKDvQwGQUAfEjX9WQyad8uCx4iVUZRVdXSEgwGGegBAF/J5/OpVKq3t9fpQrBc8mSUfD5v782jEwUAfEVVVUVR7OP+8CJ5MgpbtwGAn2mapiiK/dB7eJc8GcU+GaWhoYFVxwAgPV3XFUUZHh52uhBUmcwZhU4UAJCeoigcyiMrSTJKyVXHdKIAgMTS6XQymWTqicQkySisOgYA/8hkMslkkqkn0pNkn1l7RgmHw5wjCACSyefzyWRy06ZNBBQ/kLYfhYEeAJBMKpVSFGU5U0+M2bVlPjkQCMTjcTbZcpAMGUXXdfv/smQUAJCGpmmJRGL5U09yuVxFe7sZE3I5U8UpMoz1cNYxAEgsFou1tLQ4Mje2UCh0dnbqul7/t4aQI6NkMhlLC5NRAEAajk89sR+0gvqQM6NEIhFHKgEAyKdkbz3qQIaMYo/YZBQAALzO8xml5DAhGQUApBEMBp0uAc6QM6MwYRYApKHr+t69exsaGpwuBPXm+bXH9skoPkncM++fuPjpb1dcX33t19d87Tpn6ynfuQ9Pf/zRr4zbK69qaLp+o7P1lO/ip4WZ908U79508xYHi6mIdysXQrzz9lTxdtP1G1de5ZkvKn5Iq0hRlGQymUwml3lwYCAQCIfD8z2q6zo767uK5zNKPp+3tPhkv50f9T1+4tgbxu37H/ze/Q8+5mw95Xtt9KWXXnzGuL1x823fV0edrad8M++feLzz8gELR0782sFiKuLdyoUQ5sqfGkp7KGDxQ1pdgUBAVdVEIqEoypJX+oTD4QUmwCqKUtHuKag1z4/1sKgHAPwjFotpmjY0NOSTLnOf83xGsfejsDMKAMgtkUhkMhkmqUjP8xkFAOBDgUBAUZRMJtPW1uZ0LagVz2cU+1gPi3oAwCdCoVA6nZ6YmFhgJiy8y/MZZTkHYAIAJBCLxTKZzNDQEEM/kvF8RgEAQAiRSCR0Xd+zZ4/ThaBqyCgAAEkEAoFUKnXq1KloNOp0LagCCTMKh2gDgJ+FQiFN0yYmJlif7HWezyj2sExGAQDEYjFd1/ft28ckFe/yfEYBAGA+yWRS1/WOjg6nC8FSeD6j2HdsW2CfYwCA3xib6B8/fpxJKp7j+Yxi3/mesR4AgEUkEtE0TVVVpwtBBSTMKLlcjpgCALDzyaGz0pAwowiGewAA8D7PZ5RQKGRfXZZOpx0pBgAAVIvnM4oQIh6PW1pGR0cZ7gEAwNNkyCglDxFMpVJ1LwQAAFSNDBklHo/bh3tUVaUrBQAA75IhowghEomEpaVQKCSTSSdqAQAAVSBJRkkmk/bdjkdHR5k8CwCAR0mSUQKBQMlek0Qikclk6l8PAABYJkkyihAimUzaZ6UUCoV4PJ7P5x0pCQAALJk8GSUQCJRcy5PL5WKxGDEFAABvkSejCCHi8XjJwy2z2WwoFGLQBwAAD5EqowghUqlUOBy2txcKhVgsxmlSAAB4hWwZJRAIaJpmn5gihCgUCp2dnUxPAQDAE2TLKEKIQCCQTqftS5ENo6OjoVCIXWgBAHA5CTOKECISiWiaVnLQRwhRKBS6urpCoRBDPwAAuJacGUUsFlOEELlcrrOz0+hTYfQHAAC3kTajCCECgUAmk9mzZ88Cz8nlckafSiKRYFNaAADcQ+aMYkilUq+88sp801MMhUJheHj47rvvJqwAAOAS8mcUIUQ8Htd1feEOFUMulzPCyooVK+LxeCqVYlcVAAAc4YuMIr7YhfbUqVPRaLTMl4yOjnZ1dW3atGnFihWxWEzTtFoWCAAA5viy0wXUVSgU0jRN0zRFUSYnJ8t/4eTk5KLzal9Pv3zi7anlFViBcx+dLt5+5+0p8eLTdXvrZXrH9Kd07qPTL3mn8nMfnjbfpfL6q/NP2TLxQ7oElv9X4XeX/OrUqVMdHR0Lz1MxO3XqlPnlNf1LAQAU1e17Ye/evSULiEajdXj3+T7+xMRErd96YmLCwT/8Bf7Y/TLWY2fsj6Lr+tDQUFtb28JPbmhoCIVCdamrMr9z5UqnS1giKq8/71YuvFw8lQNL5t+MYggEAsZCntnZ2QXCSiQSqXNhZfr3zy46XcISUXn9ebdy4eXiqRxYMn/NR1mAEVYSiYQQIp1OG9NWstms8WgsFlv0CuFwOBAI1LJGAJBcPp8v/sMLkFFKiMfj8XjcuG2EleLdBaRSqXKiDABgPpqmtbS0OF0F3IKMsohYLEbyAACg/vw+HwUAALgTGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGQUAALgRGWVx+Xw+n887XQUAAP7yZacLcCld1zVN0zQtk8lks9l9+/Ylk8mFX5LJZOpTGwDIin9IYUZGmSOdTmualk6nc7mcub2cH5uurq6a1QUAgO+QUYQQIv2FQqFQ8glEewAA6szXGUXX9VQqparqfNGkKJvN1qckAABg8OmcWU3TYrHYunXr9u/fv2hAKb6kxkUBAIDLfNePommaoiiTk5OVvjCTycRisQWe8NRQ+qabtyy9MgDwvXfennq8M+50FXALH2WUTCaTTCYrSifBYDAWi8VisUgkEolEalcbAACw8EVGyefzqVSqt7e3zOe3tbXF4/FYLBYKhWpZFwAAmJf8GSWTySQSiXImvRrRJB6PBwKBOhQGAAAWIHlGUVU1mUwuPCs2GAwmk8lEIkE0AQDAPWTOKMlkcv/+/Qs8IRqNJpPJeJz5WQAAuI60GSWRSAwPD8/3aDAYVFV14XU6AADAQXLuj7JAQGloaNi3b5+u6wQUAADcTMJ+FEVR5gso0WhUVVVW6wAA4H6y9aOk0+n51hjv2bNH0zQCCgAAniBVP0o+n08kEiUfGhoamu8hAADgQlL1oyQSiZLLjAkoAAB4jjwZRdO00dFRe/u+ffsIKAAAeI48GSWZTNobOzo6SrYDAACXkySjaJpm3+0+GAymUilH6gEAAMskSUZRFMXemEql2N4eAACPkiGj6Lo+OTlpaYxGo2xyDwCAd8mQUdLptL2RaSgAAHianBklGAzSiQIAgKfJkFHsAz0EFAAAvM7zGUXTNHsjGQUAAK/z/F74mUzG3siZxkDRzPsnLn5aOPH2VLFl481bVl7V0HT9RgerAoBFeT6j6LpuaYlGo04UArjLa+mX33r9p+/889RnF87bHnxGCHHlqtU3/f6WW27/1h3x++pfHgAsyvMZxd6PwsnG8LOLnxaO/N3A6MGBUtFkjs8unP/F6z/7xes/+2Hf4207dt/1F7tXXtVQnyIBoByen49iR0aBb7312k93bv29l158ZtGAYvbZhfMvvfjMnu0tb73209rVBgCV8nxGKTkfBfCbi58WUo8//P09HfOmk9VXi7XfFGu/KVZfXfLxcx+d/v6ejtTjD9ewSgCohOfHegqFgqWFCbPwm4ufFv4q0Xbql+9aH1h9tVi/RWzYItaGrQ+dyYoPpsTJKXH+Y3Pz66Mvn3r/ne+ro4z7AHCc5zMK4HOlA8rqq8UtO8SN2+Z92dqwWBsWsQfFu2PirYPmpHLql+/+VaKNmALAcZ4f6wF8LvX4w9aAsunPxXcGFgooZjduE98ZEJv+3Nx26pfvMugDwHFkFMDDXnrx6V+8/rM5TXd+T8QeFFesquAqV6wSsQfFnd8zt/3i9Z8d+buBatQIAEvk+YwSDlsH2plFC5849+Hpl158Zk7Tnd8rt/vE7sZtlpjy4xeePvfh6aVWBwDL5fmMEggELC35fN6RSoA6Sz3+f865H/1vSw8ohhu3iVt2FO99duH8j198elkXBIBl8HxGAfxp5v0TJ469cfn+2m+K39teheveukOs/Wbx3uujL9OVAsApns8okUjE0lLylEFAMtbJItseq9qlYw+Z79GVAsApns8o9rEewA/m7Al7w51i9TVVu/RX14v1t5V+IwCoI89nFHs/yuTkpCOVAHXzzttzTwpc5jQUO9MFP7tw/h3TmckAUDee38OtZD+Kruuc2gOJnTCHhitWlthGdpnWbxFXrBS/uWjc2//4w2uuva7KbwGUcvFT69bhoo67h+u6Xp83Qpk8n1FK/r+byWTIKJDYzPsnLt+pekAxfHW9OPOvxs1zH50+9xEzZ+EYesd9y/NjPYItUuA/F8+bftf86oaavMda6ygqANSZDBnF3mXC0h7IrWR/OABIRoaMYh/uoWMQcptzQM+a9c4VAgA1JENGsS/tEQz3QGrrvnHj5TvnTjpXCOALdZu0CwsZMkrJ/3sY7oHEVl7VUPP3+M2Fmr8F4BGJRMLpEnxKhowihIhGo5YWMgoktnK1KaOcqU2X4a8/qMllAU9paGgYGhpioahTPL/22BCLxSxzUEZHR50qBqi1pus3/uL1n/32zhcrhKvpNxfMl/29Lbd/I9xc/XcBbD7+8PTroy9bGvfu3etIMYFAIB6PE1AcJE9G6e3ttTRqmsYgIqT0B7d/66UXn7l8/+SUWL+lmm/wwZyNZXd0PdF0/cZqXh+YxztvT9kziqIoTtQC50ky1lMyi6TT6boXAtRD0/Ub52z8+i+Hq/wG740Vb6659joCCgBHSJJRBFNS4DN/cPufXL5z5l/FmWzVLn0max7ouSN+X9WuDACVkCejxONxS0s2m+XwBciq7S/+jzn3x56uzkqc31wQY0+bG+5ou78KlwWAysmTUViBDF9Z87Xrbm8z9XCc/1hoL1bhutqL4vzHxXt/9p1da77GaYIAnCFPRolEIsFg0NLIlBRI7IGev71y1erL9997dbkTU8aeFu+9Wrx35arV337osWVdEACWQZ6MIkp1pYyOjubzeSdqAWpu5VUNyaeen9M0+T8sIzUVmBtQhBDJp56vx2ZxADAPqTKKfUqKYLgHUrvljm/92Xd2zWl671Ux8pfi/NkKrnL+rPj73ZaA8mff2XXLHd+qRo0AsETyZxSGeyC3B3qemjMxRQhx5l/Fge+INw8unlTOnxVjT4sD3xG/nnPoz+1t9z3Q81S1KwWAykiyh1tRW1ubZYdZMgqkZ4z4WHe+euugeOugWH+bWBsWazaIteHLD53JinMfiDNZcfIN+9Vub7vPOoQEAE6QLaPE43FLRikUCul0umQXCyCN5FPPN12/8Uf9f2194OQbJYNISVeuWv1Az1NsiALAJaQa6xFMSYGP3fUXu1M/mdi4+balvXzj5tueO6wRUAC4h2wZJRAIhMNhSyPDPfCJpus3fl8dfWooXVFS2bj5tqeG0t9XR9kKBYCryDbWI4RIJBJdXV3mllwul8lkIpGIUyUB9XTTzVtuUkfPfXj6tdGX3vnnqRPHSo/1bNx82y13fOuW279FNAHgThJmlHg8bskoQghVVVOplCP1AI5Y87Xr7n/wsfsfFEKIcx+e/vijXxUfuvrar5NLALifhBklFAqFw+Fsds4Ra+l0mowC31rztesIJQA8R7b5KAb7zNlcLsf5ggAAeIhfMopg5iwAAJ4iZ0Ypeb6gqqpO1AIAAJZCzowiSnWlZLNZzhcEAMArfJRRBMM9AAB4h7QZJRaLNTRYj5Vnw1kAALxC2owiSnWl0I8CAIBXyJxRYrGYpaVQKGQyGSdqAQAAlZE5ozAlBQAA75I5o5Q8X5ApKQAAeILMGUWU6kqZnJx0pBIAAFARyTOKfUqKoCsFAAAvIKMAAAA3kjyjCCGi0ailhaU9AAC4n/wZxd6VQj8KAADu92WnC6i5WCzW29trbikUCrquh0Ihhyqqjh/2PX7q/RPG7Tvi998Rv8/Zesr3Wvrl19IvGbfXXb/xgZ6nnK2nfDPvn/hR3+PFu99XRx0spiLerVwI8VeJtuLt7/Y81XT9RgeLqQg/pMAyyZ9RIpGIvVGCjHLq/RMnjr1h3L7p97c4W0xFzn30q2Ll3nLx0wKV15+58oufFhyspFL8kALLJP9YTyAQCAaDlkaGewAAcDn5M4oo1ZWi67oThQAAgHKRUQAAgBv5IqPYp56w/BgAAJfzaUYpFLw08w4AAB/yaUYRDPcAAOBuZBQAAOBGvsgoAADAc8goAADAjcgoAADAjcgoAADAjcgoAADAjXyRUUqezhMIBOpeCAAAKJcvMko+n7c3ljwPGQAAuIQvMop953v7ScgAAMBVfJFR7GM9JXd1AwAA7iF/Rsnn85OTk5bGWCzmRC0AAKBc8meUdDptb4zH4/WvBAAAlE/+jKIoiqWloaGBCbMAALjcnIzS39/f39+/YsWK/v5+pwqqLlVVc7mcpZFOFAAA3O/L5js9PT1O1VEL+Xw+mUza20s2AgAAV5F5rCeRSBQKBUtjNBploAcAAPereUYxBo/qP36kKMro6GjJ9nqWAQAAlubLiz9lGXp6ehyZ2qKqam9vr729o6ODVccAAHhCrTLKzMzM7t27x8fHa3T9BSSTyf3799vbGxoaUqlU/esBAABLUJOxnp6envXr19c/oOi6HovFSgYUIUQ6neYcQQAAvKKa/SgzMzMjIyNOLQ5KpVKKotgnyRqGhoYY5QEAwEOq2Y/S09NjDiiNjY1Hjx6t4vXno6pqKBTq6uqaL6B0dHQkEok6VAIAAKqlmhmlvb29eLu7u/uTTz5pbW2t4vUt8vm8kU46OzvtG7UV7dmzR1XV2pUBAABqYd6xnsHBwenp6cHBwWJLd3d3c3OzOYhYtLe3NzY2dnd379q1q7GxscqVmqS/MF/HSdHQ0BA9KAAAeFHpjFJyTomxiri1tfXQoUPzRZBPPvmkisWZ6bquaZqmaeVEEyFEMBhMp9Ns1wYAgEdVPGd2fHx88+bNx44dq2lPiRAin89nMplMJqNpWiaTWWA0x27Pnj2KorCKBwAA75p3Pkpzc/PAwMClLwwMDDQ3NxsPGXuf1K6mdDodCoUaGxtbWlq6urpGR0fLDyjRaPT48eOpVIqAAgCAt10yKTbu2rXrUinmObBHjx4t+RyL4vP7+vrKef6pU6eW9kGi0ejExEQ5b1EVS/4DBwBUpG7/sDtrvo9fh6+2iYkJB//w9+7dW/Kto9Fo6X6Upqamku0DAwPF2+bptFVU6RqchoaGjo6O48ePa5rGDigAAEijsrXHTU1NxXU9juxzbxcKhWKxWCgUcroQZ/zOlSudLmGJqLz+vFu58HLxVA4sWcX7oxRnpczOzk5PT1e7HlFpX0g2m+3s7AyFQoqi5PP5qtfjcv/+2UWnS1giKq8/71YuvFw8lQNLVvG6HvMw0OzsbFWLEUKIWCy2b9++rq6uil5VKBR6e3tTqVQymUwmk45MmP3f7t/5v359Xf3fFwCk8f/+6tT/89IBp6uAW1ScUWq95FgIkUwmE4lEcdVx+QuPi0lFVdV4PF7rOi1uu/PPbrp5S53fFABk8s7bU2QUFFWcUWrRd2IXCARisVhx3Cefzxu7t2matmheKRQKd999d1tbm6qqrEAGAMCjKp6PMjMzU7xdhz4VQyAQiMfjqqrqun78+PF9+/YFg8GFXzI6OhqJRDKZTH0qBAAA1VVxRiku52lsbCzOn62nSCSSTCaNsNLR0bHAM3O5XCwW40BBAAC8qLKMMj09XcwoCxwuWB+RSERV1dnZ2b179zY0NJR8TqFQ6OzsJKYAAOA5FWSU6enpe++9t3i3u7u7BvVULBAIKIqSyWQW6FPp7OxMp9P1rAoAACxT6Yxi2Z9tenq6p6dn8+bNxcko3d3d8+1F64hQKKSq6sTExHzzVIyFQnWuCgAALNm8GWWFyebNm/v7+4uP7tq1q6+vr+QLd+/evWKu4kM9PT3m9lpspR+LxTKZTDQatT9UKBQSiUTV3xEAANRIxXNmBwYGzKf2uE0gENA0reS4TzabVRSl7hUBAIClmLM/yieffGJ0b4yMjFj2uW9vb29ubnbJHJRFGZNkh4eHLe29vb2JRMK3h/sAAOAhczJKY2OjkUKWnEXc08uSSqUymUw2m7W0K4rCMh8AANyv4rEerwgEAul02r4meXh4WNd1JyoCAAAVkDajCCFCoVAymbS3048CAID7yZxRhBDJZNLelUJGAQDA/STPKIFAwN6Vksvl2CsFAACXkzyjCCFKbouiaVq96wAAAJWQP6OEQqFwOGxpJKMAAOBy8mcUIUQsFrO0sLQHAACX80VGiUQilhb7vikAAMBVfJFRSm4sS1cKAABu5ouMYu9Hw+xO3QAAIABJREFUEWQUAADczRcZJRAIOF0CAACozJcXfwoAjzv34emPP/pV8e7V1359zdeuc7AeACgHGQWQ08z7J37x+k/f+eepE8feKPmEjZtvu+n3t9zRdj95BYA7kVEA2byWfvm19EvzRZOiE8feOHHsjZdefGbj5tvuf+ixm27eUp/yAKBMZBRAHjPvn/hR3+OLphOLE8feeLwzvnHzbd/tearp+o01qg0AKuWLObP5fN7eyERaSObI3w0k72mpNKAUnTj2RvKeliN/N1DdqgBgyXzRj1LyBMGSC5IBj0o9/vDroy+XeGD9bWJtWKzZINaaToQ4kxXnPhBnsuKkNdD8qP+vZ94/kXzq+VoWCwBl8UVGKdmPAkijREC5YqXYtF3ceKdYfU2JF6wNi7Vh8Xvbxfmz4t1XxVsHzQ8alyKmAHCcLzKKvR8lGo06UglQdSUCytpvim2PlU4nFquvEbfuEDfeKcaeFmf+tdj8+ujLK69a/UDPU9UuFgAq4Iv5KPYtZZmMAjm89dpPrQFl05+L9h+UFVCKVl8j2n8gbrjT3PY//37wrdd+Wo0aAWCJfJFR7P0oTEaBBC5+Wkg9/vCcpuh/E7EHl3i5bY9ZYkrq8YcvflpYanUAsFy+yCj2U47JKJDAD/v++rML5y/fv+FO8Xvbl3XFuTHlswvnf/zC08u6IAAsg/wZRdM0e2PJk5ABDzn34ek5ozxfXb/0HhSz2INi9dXFe//z7wfPfXi6CpcFgMrJn1FYeAwpjf7d/z3nfuxBccWqKlz3ilVi22PmhtdGX6rCZQGgcvJnFHs/Cot6IIHX0qZOlLXfnLP9yTKtDYu13yz9RgBQR37MKLFYzIE6gOqZef/EnJkoy5yGYnfDtuLNcx+dnnn/RJWvDwBlkHx/lEwmUyhYFyYw0AOv+8XrplXBV6wU66t9HOCGLeLVZ4r3Du578hvh5iq/BVDKx6XmPymKUvdC4AqSZ5SSE2bpR4HXzenY+Or66r/BFavE2m8Wd3X7l6nX/2Xq9eq/C1Ce3t5ep0uAMyQf67FnlHA4zAZu8LqL5029g2tr0y/41Q01uSwAlE3yjDI6OmppoRMFEqjH1mpVWSUEAMsgc0ZJp9P2xng8Xv9KgOo69ct3L99ZU4OxHgBwAd9lFPpRIIF137jx8p1zJ50rBABqSOaMYp+M0tbW5kQhQJWtvKrB6RIA1EMwGPTzr9bSZpRMJpPL5SyNfv6bhkxWrjZllF9/UJP3OFNig2YA9dTQ0FByQMA/pF17zGQUSKzp+o2/eP1nv71zxnpkZnX8+vIQ0pprr1tz7XU1eRdgroufFuZMtxJC+HVz8EgkkkwmfX66nI8ySjgc9vlfNqSx8eYtQnyxx9pvLooz2WruhS+EODklfnOxeG/PU8/fdHO1t4kDSnnn7anHO62/TJbc6Qp+IOdYj67r2az1l0sGeiCNm27ecuWq1ZfvvztW5TcwXfDKVasJKAAcIWdGKTnQk0gk6l4IUCu33PGty3fee1WcP1u1S5/JipNvlH4jAKgjv2SUYDDIMT2QyV1/sXvO/bGnq3bpN4fN97794GNVuzIAVELCjJLP5ycnJy2NDPRAMk3Xb9y4+bbL98/8q/iXw1W47psHi8f0CCFub7tvzdeYLQvAGRJmFFb0wCeST/1fc+5P/o/lTkx5d0y8dbB478pVq+lEAeAgX2SUhoYGMgrks+Zr193/4PfmNL36zNJjyrtj4tVnzA3ffugxOlEAOEi2jJLP5+3nCBJQIKv7H3zsD27/kzlNrz4jtBfFby5UcJXfXBBjT1sCyu1t91mnvABAfcmWUUouoyejQGLJp56fc3yPEOL4P4i/311uh8q7Y+Lvd4v3XjW3rfvGjQ/0/G31agSApZBtDzfOEYTfrLyq4fvq6F8l2ubsznn+Y/HqM+Ktg2L9FrFhS4kd3s5kxQdT4uSUOP+x5ZF137jx++ooRwIBcJz8GaWtrS0QCDhSDFAfK69q2H9YSz3+8OujL8954PzH4vg/iOP/IIQQq68Wq68WQohfnzTvIWvxZ9/Z9UDPUzWtFgDKJFVG0TStUChYGhnogU8kn3r+ltv/JPX4w59dOF/i4fMf27tMzNZce913u/+WHdsAuIdU81FYdQyfu+WObx04+i/3P/i9OTvlL+bKVavvf/B7+w9PEFAAuIps/SiWlnA4zEAPfGXlVQ33P/jY/Q8+9lr65bde/+k7/zxVulvFOIjn97fccvu37ojfV+ciAaAc8mSUkucIckYPfOuO+H1G+Jh5/8TFTwun3j9x8dOCEGLlVQ3rrt949bVfZ+8TAC4nT0ZhRQ9QUtP1G4UQnF0MwHPkmY9iH+jhHEEAALxL5oxCJwoAAN4lSUbJZDKsOgYAQCaSZBQmowAAIBlJMop9oCcajbLqGAAA75Iko2QyGUsLnSgAAHiaDBml5GQUMgoAAJ4mQ0axD/QIMgoAAB4nQ0axD/REo1FHKgEAANUiQ0bRdd3SwtZtAAB4nQwZZXJy0tJCRgEAwOs8n1HsAz2CjAIAgPd5PqPk83l7IxkFAACv8/y5x/ZFPeFw2IlC6u219MvnPvqVcXvjzVs8dKrtO29PnXh7yri95tqv3xG/z9l6ynfuw9Ovjb5UvHv/g485WExFvFu5EOKlF58u3r6j7f41X7vOwWIqwg8psEyezyh2Ptle9rX0SyeOvWHcvv9B4aF//k68PfXSi88Ytzduvs1D//x9/NGvipULT33Te7dyIYS58o03b/FURuGHFFgWz4/1cNwxAABS8nxGAQAAUiKjAAAAN/J8RrFvjsJYDwAAEvB8RgEAAFIiowAAADciowAAADeSMKOU3B0fAAB4i+czSjQatbSU3B0fAAB4i+czih0ZBQAACXg+o4RCIUsLYz0AAEiAjAIAANzI8xnFvmNboVAgpgAA4HWezyiRSMTeaD9oEAAAeIvnM0ogEAiHw5ZGVVWdqAUAAFSN5zOKKDXck81mGe4BAMDTZMgoiUTC3phKpepeCAAAqBoZMkokErEP9wwPD9OVAgCAd8mQUYQQyWTS3liyfwUAAHiCJBklkUgEg0FLYzabVRTFiXIAAMBySZJRhBAl40hvb286na57LQAAYLnkySiJRMI+K8VoZ2IKAACeI09GEfNsi1IoFGKxGDEFAABvkSqjRCKRffv22duNmMLGbgAAeIhUGUUIkUwmOzo67O2FQqGzszOZTObz+fpXBQAAKiVbRhFCpFKpkhNThBD79++PxWKc5gMAgPtJmFECgYCmafPFlGw229LSkkgkdF2vb10AAKACEmYU8UVMiUaj8z1heHh43bp1JBUAAFxLzowivogpJeemFBWTCqM/AAC4jbQZxaCq6tDQUENDwwLPGR4ebmlpCYVCqVSKbhUAAFxC8owivtjDbYFxH0Mul+vq6lq3bl0kElEUhf1UAABwlvwZRQgRCoU0TVu0Q8WQzWZ7e3s3bdoUCATi8XgqlSKvAABQf77IKAZjhuzevXvLSSpCiEKhMDo62tXVtWnTphUrVrAFHAAA9bTi0qVLTtdQb/l8PpVKpVKpQqFQ/qsmJiZisVjx7ooVKyxPWPeNG1deVVb6qYpTvzxx8dPzxu0111635trr6vbWy3Tuo9PnPjpt3F551ep139jobD3lu/hp4dQv3y3e3bj5NgeLqYh3KxdCnDj2RvF2nX/Klokf0iWw/L9q8OH3VJ1pmtbS0lLyoTr84SuK0tvba2+PRqPiko8NDQ3Nt42K3ezsrPm1Vf0LAgDMy6nvCP+YmJhw8A9/7969Jd86Go36aKzHzphOe+rUqT179gSDwQWeGQwGA4FA3Qor38qrVjtdwhJRef15t3Lh5eKpHFgyX2cUQ3HV8fHjx/fu3VuyZyUSidS/sHIUe5I9h8rrz7uVCy8XT+XAkn3Z6QJcJBKJGAuP8/m89oVsNivKyygdHR2hUKjmVQKAvHRdHx4edroKuAUZpQRj1XE8HhdC5PP5TCZTTkZJJBLmSbUAgEppmkZGQREZZRGBQIDkAQBA/TEfBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQAAuBEZBQD+//buN7apO8/3+C93kRgRiM0DoCrlxoSRioZk7JYwZeBKcaCdakZ3mjPTG0R3GWLUHVh1p8Ld1ZbcYe/EXBUEVHPHKbvcCbsVDt0uCKbTYx5MRYc/zoO0dIDheBIqKm2CsymIBmliB4IGafdyH7h1HB/H2Inj8zu/83498vn5+PhbSuDD7y8AGZFRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICMyCiFGIYRDocDgUAsFrO6FgAAnGWO1QVIJ5FI6Loei8VisVgqlUo3ejwev99f+IPBYNDtds96fQCgrmQyaXUJkAgZ5UuGYUQiEV3Xh4aGzO8W048Sj8fLXxYAAE7l9IySSCTC4fBU0STDMIyKlQQAAISTM4qu6+FwuKenp5ibU6lUIpHweDyzXBQAAPiSEzNKJBIJhUKFO07MDMMonFE2tmxevHTZjCoDAGcbuTl8LnrC6iogC2dlFF3Xg8FgqenE6/X6fL5HzofdoG1uWLN+BtUBgNP1XeoloyDDKRklkUgEAoEiR3aEELW1tZqm+f1+v9/Pah0AACrPERklHA6HQqHMQuICvF5vIBDQNI2pJwAAWEvxjJJMJjVNe2T3SW1tbSAQCAQCRBMAACShckYxDEPTtMKzT5qamoLBoKZpFasKAAAUQ9mMYhiG3+8vML7T1NQUCoUeuXssAACwhJoZpXBAqa2tjUQipBMAAGSm4JmChQNKR0dHIpEgoAAAIDnV+lHSk2TzBhSXy6XrOukEAABbUC2jBAKBvJNkvV5vLBZjpxMAAOxCqbGecDgcjUbN7QQUAABsR52MkkwmQ6GQuZ2AAgCAHamTUYLBoHkaisvlIqAAAGBHimSURCLR3d1tbtd1nYACAIAdKZJRwuGwuXHnzp2s4gEAwKYUySiRSCSnxeVy5Z2eAgAAbEGFjKLrunkmSjAYZJQHAAD7UiSjmBuDwWDlKwEAAOWiZkZpaWmhEwUAAFuzfUZJJBLmgR5N0ywpBgAAlIvtM0osFjM3klEAALA725/Xk0gkclpqa2sZ6AGEEH2Xevsv9fb9rnfk1vDIreFM++LHly1+fFnDt9bXr1nfsGa9hRUCQAG2zyiGYeS0+Hw+SyoBJDFyc/hc9Hj0WNf9e2P5b7g1PHJruP/yR0K8ufjxZRu1zS/8aEf1AleF6wSAwmyfUZLJZE4LGQWONX43dfqdruOH3yz+IyO3ho8ffjN6rKtl6w6SCgCp2H4+ijmjAM40eL1/54vNJQWUjPv3xo4ffnPni82D1/vLXhgATI/t+1Hi8XhOC/0ocKBz+onOv381zxtzq8UTXrHo62KZd6JxOC7u/Jv4PC4ejGffO3JrOPg/mne+cWijtnmW6wWAR7N9RjFjwiycJn9AeeKb4hvPi1XP5/nAE1/llWtnxKdnxOd/yH4z/ShiCgDLKZhRAEfJE1DmVovnXxcriliws+p5sep5ce2M6Dmc3adCTAEgA9vPRwGcbPB6f25AWbRCvPxuUQElY9Xz4uV3xaIV2W3/tH83c1MAWMv2GaW2tjanhVm0cI7O3T+ZdP2N74gtXWLu/JIfNHe+aP15dky5f28s9+EAUFm2zygejyenxbxjCqCk44cP3vjs2sT1ohXC/8r0H2eKKTc+u3b6na4ZFAgAM2L7jAI40/jdVPRYVoCYWy1e2DOdHpRsc+eLF/aIudWZhn/9x4Pjd3PPwwKAyrB9RjGv4jHvjg+o55x+YtI2smu3iprHyvDcmsfE2q2Zq/v3xi6e+6AMjwWA0tk+o5h3QyGjwAkmjcLULBFPv1i2Rz/9oqhZkvVFvyzbkwGgFLbPKOZ+FOajQHkjNyedEZjd81EeT/0w8/LGZ9dGbg4XuBcAZont90cx96OkUqlkMslOblDYxfO/mXT99XKfXfz19aLn/2auPjgZefq/bSjzVwD53Mi34j0Wi1W8EGeR9t/2CmYUIYRhGH6/v+K1ABUyaeeSJ74506myZjWPiUUrxJ2B9NV7b7/13ttvlfkrgKI1NzdbXQKsocJYj8uVe1KrtJEQKIuRm/8+cbHo67PyHZO3dAOAyrN9RhH5ulLIKHCQsneipJVllRAAzIAKGcU8rMPgJdTWf/mjiYusNTgAoBIVMoq5H2VoaIgVyFDYvPk1ExcP7llXCADMIjUziqArBUqrW1k/cZF1XjEAlFFLS4u1BaiQUTwej/lkQTIKnGLs9qw89s6/zcpjAdiEy+UKhULW1qBCRhFMSYHDNHwra0OUz+Oz8h1fLTwG4DQul6ulpcUwjLzDFJVk+/1R0vx+f3d3d3ZLekqK+VRkQAHLn8wa6xn7QozdLvMynDsDYuyLzNVPO7vXbvxeOZ8PTKHvUu/ubVpO48OHDy0pBpZTth9F0JUCdU3qRxFC/P7XZf6C379X6OsAoCIUySh5p6Toum5JMcBsq17gembDdyeuPz1TztU9Y7fFQG/m6pkN361ekLtNIgBUgCIZRQihabndg/SjQGEbWzZPXDwYFx8fK9ujPz6WvVbohR/tKNuTAaAU6mQU83BPKpWiKwWqWrvxe4sfXzZxffXX5Zk8O9ArPv0wc1XfuK5hDQM9AKyhckYRdKVAaTv3Hpp0ffpnM12Mc2dAnDmY3fDSX78+owcCwAyok1Hcbrd5txn6UaCwhjXrJ81KeTAuTv3N9GPKnQFx6m+yR3m+v2U7nSgALKRORhH5ulKGhoY4XxAKC+49tPzJVRPX6ZiSNeO1WNfO5ASU5U+u+nM6UQBYSqmMYp42K+hKgdKqF7h27v2Hycf3jIvTHeL0z4rdf3bstjj9M/Hhm9kBZd78mt1vvcNyHgDWUiqjeDwer9eb00hGgdrqVtbvi0QnxRQhxMBH4u0t4szBQn0qA73izEHx9hYx8FF287z5Nfsi0cVLl031OQCoDEX2mc3w+/3x+KTVDfF4nA1nobZ0TOnc/ZMbn12b9ManH365SOeJb4qax77ci3bsthi7LT7/Q95HLX9y1e633iGgAJCBUv0oQohAIGBupCsFykvHlO9v2Z7/7c//ID79UFw8Ji4eE59+OFVA+f6W7fSgAJCHahnF5/OZN5yNRCJW1AJUVPUC14/b9+49qtc3riv1s/WN68K/uvDj9r3MQQEgD9Uyisi3uicejyeTSStqASqtYc36fZFo+FcXNrRszp2kYjJvfs2Gls3hX13YF4nWrawvfDMAVJhq81GEEJqm5ZyBLITQdT3vMBCgpLqV9cG9h8TeQ4PX+/sv9Y7fTfX97svJs9U1rrqV9dULXPVr1pNLAMhMzYzicrlSqVR2IxkFzlS3sj4dRF56xepSAKBECo71iHwbpUSjUYZ7AACwEadkFMHZPQAA2IqaGSXv+YKsQAYAwEbUzCicLwgAgN2pmVFEvuGeVCrF+YIAANiFgzKKYDM3AADsQ9mM4na7zecLMm0WAAC7UDajiHxdKWw4CwCAXTgrowhmzgIAYBMqZ5S85wsy3AMAgC2onFFEvo1SyCgAANiC4zLK0NBQIpGwoBQAAFAKx2UUQVcKAAB2oHhG8Xg8rEAGAMCOFM8oQgifz5fTwm6zAADIb47VBcw6v9/f3d2d3RKPx60qpowGr/eP302lXy95/L8uXrrM2nqKN3Jz+Itb/55+Xb3AVbey3tp6ijd+NzV4vT9z2bBmvYXFlMS+lQsh+i71Zl7XrayvXuCysJiS8EMKzJAjMoq5MRaL5W23kX/ev7v/8kfp1y+98ncvvfK6tfUU71z0+PHDb6Zf1zeu2xeJWltP8Qav9+/eNrHpzun+OxYWUxL7Vi6EyK5871HdRgGLH1JghtQf6/F4PC5X7j+8GO4BAEBy6mcUkW9KCsuPAQCQnEMzCv0oAABIzhEZxePx5LRwsiAAAJJzREYx96OosbQHAACFOSKjAAAA23FERmFHfAAAbMcRGQUAANgOGQUAAMiIjAIAAGRERgEAADIiowAAABk5IqOw8z0AALbj3Ixi93OPAQBQmyMyCqfzAABgOw7NKE1NTZZUAgAAiuSIjKLrek6L+QQfAAAgFfUzSiwWS6VSOY1kFAAAJKd+RolEIuZGTdMqXggAACjBpIxy4MCBAwcOVFVVHThwwKqCyiuRSHR3d+c0trS0uN1uS+oBAABFmpN90d7eblUdsyQYDJob6UQBAEB+Ko/1RCKRaDSa0+hyuQKBgBXlAACAEpQ/owwODh44cKCxsbEqy6ZNmyo8fmQYRt5OlLyNAABANuXMKIODg5s2bVqxYkV7e/uVK1ey3zp16lR7e3tVVdWpU6fK+I1TMQzD7/ebl/PU1taGQqEKFAAAAGaobBnl7NmzK1aseGQE2bRp02zHlKkCiphijQ8AAJBQ2TJKXV3dwoUL06937dp18uTJh185efLk6tWrM3fO6sxcXdenCig7d+7kjB4AAOyinBmlq6vr2WefHRgY2L9/f2tra+at1tbWy5cvZ2LK4ODgbHSlJJPJYDD4gx/8IG9A8Xq94XC47F8KAABmSTnno7S2tv72t7+tq6vL+25XV1fmdc5slZmLRCIej6ezszPvu16vNxaLlfcbAQDArKrc2uPVq1dnBoNGR0fL8sxkMplOJ9u2bcvbfSK+Cihs2gYAgL1MmVGOHDmyY8eO7PXD7e3tlVmVU4z00uJ0OhkaGprqNgIKAAA2NSdva95prekNTp599tmTJ09mekSKNzo6muk+mWo86JEMw4hEIrquF8glGW1tbeFwmIACAIAd5c8oBZw9e7axsfHy5culxpQjR45kXmfPqH2kWCxmGEYsFst7gnFeLpcrEomw5z0AAPY15VjP6tWru7q6MuuHu7q6shfm7Nixo6SvSW8+m369ffv2wv0oyWQyHA4HAgGfz1dVVdXc3Pzaa69Fo9EiA0pbW1sikSCgAABga/n7UbZv3569DCfdsn379ueee+7s2bNCiFOnTp09e/bZZ58t5jtGR0c3bdqUHuhZuHDhrl27Ct/v9/vj8XhR5U/W1NSUnkI7jc/O3Hn9RP+l3op93cit4czrvku94vDBin31DPVl/SqN3Bo+bp/KR24OZ19SeeVV+KdshvghnYac36twuodZMo379+9/mM/AwEDmntbW1rz3mGVHmey93fI6evToNP4r2trabty4UWQ9ZTGTX3MAQPEq+Wc7Kq+joyPv//empqbS1h7X1dVlppKkO1QeKdP1IoTI2dstr0QiUVJJXq93dHTUwu4Ta31tXrXVJUwTlVeefSsXdi6eyoFpK3l/lMyslNHR0UduxZYdUHbt2vXIUR4hRKnLcOLxuMfjCQaDpYYbNfzp/rjVJUwTlVeefSsXdi6eyoFpK3ldT/Z018JbsWUHlO3bt+/fv7+Y5wcCgUgkUtJ8lFQq1dnZ2dnZ2dbWFgqFrOpQ+dq8eX/2ZyX/egIAMv7zP//jT/fvW10FZFHy36lFLjnOCSg5M3ALcLvdsVgsvQlKIpEoZh+UjO7u7u7u7o6OjmAwWPltUf7XP/5rw5r1Ff5SAFBJ36Xe3dtYlYkvlTzWU8w29tMOKGlutzsYDMZisUQiMTo6+v7773d0dDQ1NRX58T179vh8Pg7oAQDA1krOKIODg5nXeftU2tvbZxJQcrjdbk3TQqFQLBZL55W2tjaXy1X4U0NDQ83NzcFgcCZfDQAALFRyRsnkj4ULF2bmz2a/m9mrrbW1dYYBJUc6r0QikWQymQ4rhe/v7Oz0+/3JZLKMNQAAgMooLaNcuXIlk1HyriLO7D9bV1dX3oCSIx1WRkdHOzo6CnSr9PT0EFMAALCjEjLKlStXNm3alLk0LyQ+cuRIZiSoq6trGucOlsrtdodCoUQiUSCpxONxYgoAALaTP6Pk7M925cqV9vb2xsbGTATZtWuX+cydzKdWr15d5Db5ZZFOKoZhtLS05L0hHo9zfA8AAPYyZUapytLY2JiZZSKm3uwkk1GuXLlS9SjPPfdcef9LPB6Pruu/+MUv8r7b09PDFFoAAGyk5DmzXV1deSeaDA4OFrMsebYFg8GrV6/mHffp7OxkQTIAAHYxaQ+3P/7xj0eOHBFCnDp1Kmef+9bW1tWrVxezmb3l0puj+P3+VCqV81YgEHDmlvkAANjOpIyycOHCdAqZRhapq6t7KM1pwOmY8tRTT+W0Dw0NRSKRQCBgRVEAAKAEJY/12IXP58s7NyUUClW8FgAAUDJlM4oQIhgMmnfQT3elWFEOAAAogcoZRQiRN47oul7xQgAAQGkUzygej8e8aUo0GmVLNwAAJKd4RhFC5J0hyyJkAAAkp35G0TTNvF0KGQUAAMmpn1GEEH6/P6fFMAwrCgEAAMVyaEbp6emxohAAAFAsR2QUn89ndQkAAKA0jsgoHo/H3MiUFAAAZObcjAIAAGTmiIwCAABsZ86jbwFgT+N3U32/673xWX/f73pz3mr41vrlT9Y3fGt99YLclfkAIAkyCqCgc/qJi+d/88n5D6a6of/yR+kXz2z47toN39uoba5UaQBQLDIKoJRz+onjhw+O3Bou8v5Pzn/wyfkPjh8++Je73li78XuzWhs9jtoMAAAM/UlEQVQAlISMAihi/G5q76tbMx0kJRm5NbxvZ9szG74b3HuI0R8AknBERsm7zNi8sRtgX4PX+38aaLl/byzPezVLxBNeUfPYRMvYbfF5XIx9kXPjJ+c/ePm5p/dFonUr62ezWAAoiiMyCqC2c/qJf9q/OzegzK0WT70oVn1nUjrJNnZb/P7X4tMz4sF4pu3+vbGfBlqIKQBk4Ii1x+bTeWpray2pBCi7wev9eQLK2q3i5XfFt7dOGVCEEDWPCf8r4uV3xdqt2c3pmDJ4vX926gWAYjkioyQSiZwWdnWDGsbvpnKHeGqWiC1d4ttbxdz5RT1i7nzx7a1iS5eYW51pS8eU8bupctcLACVwREYx96Nwgg/UsPfVrZMCyqIVYkuXWLSi5ActWiFefjf7g/fvjYV3v1qOGgFgmhyaUehHgQLO6ScmreKpWSJaf15s94nZ3Pmi9efZvSmfnP/g4rnfzKxGAJg+9TNKIpFIpXK7rOlHgQKOHz446fqF/z39gJI2d75o/T/ZDf984O9n9EAAmAH1MwoLj6Gkc/qJSRu1rd06nSEes0UrsqfQjtwaPqefKMNjAaB06mcU80CP1+u1pBKgjE6/88uJi7nV4ukflu3RT/8we8Tn4nmGewBYQ/2MYu5HYaAHdjdyc/jGZ9cmrp96caajPNnmzhffeD5z9cn5D1jgA8ASimeUZDIZj8dzGhnogd31XZp8jvGq75T5Cyb3ypiPTQaAClB8n1kmo0BJg9f7Ji4WrSi0Udv01DwmapZkNsvft7OtzM8HSlFVVWV1CbCG4v0ouq7ntNTW1rLwGHZ3I3sT2LJMlTV7gmlbACymeEYx96PQiQLVlL0TZVYfCwBFUzmjGIYxNDSU00hGgQImHaZTs8S6QgBgFqmcUZiMAgCAfamcUcyTUbxeL5NRoIC6lfUTF1/NbAUAlWiapmxGSSaTPT09OY10okBBD+7NymPHbs/KYwGgCC6XKxAIKJtRzJ0oQghN0ypfCVB2y7P7UT7P3QGoPGbpsQDwKE1NTYZhuN1uZfdHMWcUl8tFPwrUULeyYeLizoAYu13mZThjt7OHkP7i1f/5jaefKefzgSncuN5vPsnywoULlhQDS2T/Ta1sRjFPmKUTBcpoWLN+0vW1D8W3t05x77Rc+zD76r//+cvVC1zlfD5QCv556VhqjvXoup5K5Z4wwu9yKGPx0mXLn1w1cf3pmXI+/cE9cfW9zFV94zoCCgBLKJtRzI30o0AlL/zoryYuxr4QHx8r26N//2vxYDxztVF7qWxPBoBSOCWjtLS0uN1uS4oBZsNGbfPix5dNXF88Ju4MlOG5dwbExYm4s/jxZRu1zWV4LACUTsGMEovFGOiBE7z0yuuTrs8cnOk65Af3xOmfFfoKAKggBTMKAz1wiI3a5vrGdRPXdwbEqb+dfkx5cE+c+tvs5Tz1jevoRAFgIUdkFLaXhaqCe/9h3vyaiet0TJnGoM+dAfEvO7I/OG9+ze5D5ZvjAgClUy2j5D1HMBAIWFELMOsWL12WmyTSaePjY8V2qDy4Jz4+Jv5lR3YPyrz5NfsiUZbzALCWahmFgR44TcOa9TvfOJTbevHYl0mlwJb2Y7fFx8fE23+RPUlWCDFvfs2P2/dOOhIIAKyg2h5u5oxSW1vLQA/UtlHbvHjpsr2vbr1/b2yidewLcfGYuHhMLFohnvCKufNFzZIv28duizsDeYeE0j0oBBQAMlAqoyQSiXg895AROlHgBA1r1r/1Xiy8+yf9lz/KfW+KOGJW37hu96FjDPEAkIRSYz15B3qYjAKHWLx02b5IdOcbhybtm1LkZx9ftvONQ8xBASAVpfpRzGf01NbW+nw+K2oBrLFR27xR23xOP3H6nV/e+OzaI+9f/uSqF370V6wxBiAhpTJKNBrNaWHrNjhTOqmM3Bzuu9Q7eL3vxvV+IcTg9X4hRHquyfKV9XUrGxrWrF+8tOROFwCoDHUyCit6gByLly7buHTzRkEfCQBbUmc+inmgR5BRAACwLZUzSktLixWFAACAMlAko+RddcxkFAAA7EuRjMJADwAAilE2o7C9LAAAtqZsRmGgBwAAW1MhoySTSfNZx2QUAABsTYWMkncyChkFAABbUyGjGIaR08JkFAAA7E6FjGLuR+GMHgAA7E6FjGLuRyGjAABgd7bPKMlkMpVK5TQyGQUAALuzfUYxd6II+lEAALA/22eURCKR0+JyudxutxW1AACAspljdQEzZc4oDulE+Wmgpf/yR+nXL73ydy+98rq19RTv+OGDxw+/mX5d37huXyRqbT3F67vUu3vbxAELp/vvWFhMSexbuRDihfpFmdd7j+oNa9ZbWExJ+CEFZkjBfhRWHQMAoAAyCgAAkJHtMwoAAFCS7TOKY+ejAACgNttnFPNpgizqAQBAAbbPKAAAQElkFAAAICMFM0oymbS6BAAAMFO2zyherzenJe/u+AAAwF5sn1GYIQsAgJJsn1HM6EcBAEABts8ofr8/p8W8YwoAALAd22cU88738XicabMAANid7TNK3l1lY7FYxQsBAADlpEJGcblcOY26rltSDAAAKBfbZxQhhKZpOS26rjPcAwCAramQUczTZlOpVDgctqIWAABQHipklEAgYB7uCYfDdKUAAGBfKmQUkW+4h64UAABsTZGMEgqFzI179uxhPzcAAGxKkYzi8Xja2trM7ZqmMeIDAIAdKZJRhBChUMg8K2VoaMg8oxYAAMhPnYzi8XjyjvjE4/FAIFDpagAAwMyok1GEEMFgsKmpydze3d3t8/kY9AEAwEaUyihCCF3XzSM+Qoh4PO73+5lCCwCAXaiWUdxudywWKxBTWJAMAIAtqJZRhBA+ny8SieR9K5VKvfbaa36/n0MHAQCQnIIZRQihadr777+ftzdFCNHT09Pc3BwIBBKJRGXrAgAAxVIzowghNE2batAnrbu7e/ny5YFAgD4VAAAkpGxGEUL4fL5EIuH1egvc093d3dzcnB4eYuEPAADyUDmjCCHcbrdhGB0dHYVvi8fj27ZtW7hwoaZphBUAAGSgeEZJC4VCV69eLdyhkhaNRtNhxe/3h0IhhoEAALCKIzKKEMLn8xmGcfTo0dra2mLu7+np2bNnT3Nzc1VVVTqvsLcKAACVNMfqAioqEAhomhYOhyORyNDQUJGf6unp6enp8Xg8Pp+vwG3n9RP9l3rLUWZRRm4NZ173XeoVhw9W7KtnqC/rV2nk1vBx+1Q+cnM4+5LKK6/CP2UzxA/pNOT8XoXDVT18+NDqGqwRiUTC4XA8Hi/y/qtXr2ZnlKqqqtmpCwAwiWP/noJzM0qaYRjhcFjX9VQqVfjOnF8oSTLK1+ZV/+n+uNVVTAeVV559Kxd2Lp7KZ87hf085mdMzSob+lbxhpampKWf+rCQZBQCUx99TjuWs+SgFaJqmaZoQwjAMXddjsVhPT0/m3cIzUdK8Xq/b7Z7FEgFAdclksvgheCiPfpRCYrFYLBYzDCM92Tb7LXM/yoULF/x+f+WKAwDlxGKx5ubmnEb+nnIs+lEK8fv9xA4AACzhlP1RAACAvZBRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICMyCgAAEBGZBQAACAjMgoAAJARGQUAAMiIjAIAAGRERgEAADIiowAAABmRUQAAgIzIKAAAQEZkFAAAICMyCgAAkBEZBQAAyIiMAgAAZERGAQAAMiKjAAAAGZFRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICMyCgAAEBGZBQAACAjMgoAAJARGQUAAMiIjAIAAGRERgEAADIiowAAABmRUQAAgIzIKAAAQEZkFAAAICMyCgAAkBEZBQAAyIiMAgAAZERGAQAAMiKjAAAAGZFRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICMyCgAAEBGZBQAACAjMgoAAJARGQUAAMiIjAIAAGRERgEAADIiowAAABmRUQAAgIzIKAAAQEZkFAAAICMyCgAAkBEZBQAAyIiMAgAAZERGAQAAMiKjAAAAGZFRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICMyCgAAEBGZBQAACAjMgoAAJARGQUAAMiIjAIAAGRERgEAADIiowAAABmRUQAAgIzIKAAAQEZkFAAAICMyCgAAkBEZBQAAyIiMAgAAZERGAQAAMiKjAAAAGZFRAACAjMgoAABARmQUAAAgIzIKAACQERkFAADIiIwCAABkREYBAAAyIqMAAAAZkVEAAICM5lhdgF1duHAh/eI//t/DOf+lSgjh8/ksrQgAbM/n86X/dM380Qon+//joUvpqiz/OwAAAABJRU5ErkJggg==">
<h6><span class="label">Figure 1-8. </span><code>Ref</code> borrows referring to a <code>RefCell</code> container</h6>
</div></figure>

<p>The runtime nature of these checks means that the <code>RefCell</code> user has to choose between two options, neither pleasant:</p>

<ul>
<li>
<p>Accept that borrowing is an<a data-primary="Result type" data-secondary="values from try_borrow" data-type="indexterm" id="OEBPS/ch01.html.id618"></a><a data-primary="try_borrow method" data-type="indexterm" id="OEBPS/ch01.html.id619"></a> operation that might fail, and cope with <code>Result</code> values from <code>try_borrow[_mut]</code></p>
</li>
<li>
<p>Use the allegedly infallible borrowing methods <code>borrow[_mut]</code>, and accept the risk of a <code>panic!</code> at runtime (<a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>)
if the borrow rules have not been complied with<a data-primary="borrow method" data-type="indexterm" id="OEBPS/ch01.html.id620"></a><a data-primary="panics" data-type="indexterm" id="OEBPS/ch01.html.id621"></a></p>
</li>
</ul>

<p>In either case, this runtime checking means that <code>RefCell</code> itself implements none of the standard pointer traits;
instead, its access operations return a  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> or
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.RefMut.html"><code>RefMut&lt;T&gt;</code></a> smart pointer type that does implement those
traits.</p>

<p>If the <a data-primary="Copy trait" data-type="indexterm" id="OEBPS/ch01.html.id622"></a><a data-primary="Cell type" data-type="indexterm" id="OEBPS/ch01.html.id623"></a>underlying type <code>T</code> implements the <code>Copy</code> trait (indicating that a fast bit-for-bit copy
produces a valid item; see <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>), then the  <code>Cell&lt;T&gt;</code> type allows interior mutation
with less overhead—the <code>get(&amp;self)</code> method copies out the current value, and the <code>set(&amp;self, val)</code> method copies in a new value.  The <code>Cell</code> type is used internally by both the <code>Rc</code> and
<code>RefCell</code> implementations, for shared tracking of counters that can be mutated without a <code>&amp;mut self</code>.</p>

<p>The smart<a data-primary="threading" data-type="indexterm" id="OEBPS/ch01.html.id624"></a> pointer types described so far are suitable only for single-threaded use; their implementations assume that
there is no concurrent access to their internals.  If this is not the case, then smart pointers that include additional synchronization overhead are needed.</p>

<p>The thread-safe equivalent of <code>Rc&lt;T&gt;</code> is  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>,
which uses atomic counters to ensure that the reference counts remain accurate. Like <code>Rc</code>, <code>Arc</code> implements all of the
various pointer-related traits.<a data-primary="Arc type" data-type="indexterm" id="OEBPS/ch01.html.id625"></a><a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch01.html.id626"></a></p>

<p>However, <code>Arc</code> on its own does not allow any kind of mutable access to the underlying item. This is covered by the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> type, which ensures that only one thread has
<span class="keep-together">access—</span>whether mutably or immutably—to the underlying item.  As with <code>RefCell</code>, <code>Mutex</code> itself does not<a data-primary="MutexGuard type" data-type="indexterm" id="OEBPS/ch01.html.id627"></a>
implement any pointer traits, but its <code>lock()</code> operation returns a value of a type that does:
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a>, which implements <code>Deref[Mut]</code>.</p>

<p>If there are likely to be more readers than writers, the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> type is preferable, as it allows multiple
readers access to the underlying item in parallel, provided that there isn’t currently a (single) writer.<a data-primary="shared-state parallelism" data-type="indexterm" id="OEBPS/ch01.html.id628"></a></p>

<p>In either case, Rust’s borrowing and threading rules force the use of one of these synchronization containers in
multithreaded code (but this guards against only <em>some</em> of the problems of  shared-state concurrency; see <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>).</p>

<p>The same strategy—see what the compiler rejects and what it suggests instead—can sometimes be
applied with the other smart pointer types.  However, it’s faster and less frustrating to understand what the behavior
of the different smart pointers implies. To borrow (pun intended) an example from <a href="https://oreil.ly/DOOKi">the first edition of the Rust book</a>:</p>

<ul>
<li>
<p><code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> holds a vector (<code>Vec</code>) with shared ownership (<code>Rc</code>), where the vector can be mutated—but
only as a whole vector.<a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch01.html.id629"></a><a data-primary="Vec type" data-type="indexterm" id="OEBPS/ch01.html.id630"></a></p>
</li>
<li>
<p><code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code> also holds a vector with shared ownership, but here each individual entry in the vector can be
mutated independently of the others.</p>
</li>
</ul>

<p>The types involved precisely describe these behaviors.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 9: Consider using iterator transforms 
instead of explicit loops" data-type="sect1"><div class="sect1" id="OEBPS/ch01.html.file_iterators_md">
<h1>Item 9: Consider using iterator transforms 
<span class="keep-together">instead of explicit loops</span></h1>

<p>The humble loop has had a long journey of increasing convenience and increasing abstraction.<a data-primary="iterators" data-type="indexterm" id="OEBPS/ch01.html.ix_iter"></a>  The
 <a href="https://oreil.ly/Oeial">B language (the precursor to  C)</a> had only <code>while (condition) { ... }</code>, but with the arrival of C, the common scenario of iterating
through indexes of an array became more<a data-primary="loops" data-secondary="increasing convenience and abstraction of" data-type="indexterm" id="OEBPS/ch01.html.id631"></a><a data-primary="C" data-secondary="for loop" data-type="indexterm" id="OEBPS/ch01.html.id632"></a><a data-primary="for loops" data-type="indexterm" id="OEBPS/ch01.html.id633"></a><a data-primary="B language" data-type="indexterm" id="OEBPS/ch01.html.id634"></a> convenient with the addition of the  <code>for</code> loop:</p>

<pre data-code-language="c" data-type="programlisting"><code class="c1">// C code</code>
<code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">len</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="n">Item</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">collection</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"></code>
<code class="w">  </code><code class="c1">// body</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The early versions of  C++ further improved convenience and scoping by allowing the loop variable declaration to be<a data-primary="C++" data-secondary="for statement, loop declaration in" data-type="indexterm" id="OEBPS/ch01.html.id635"></a>
embedded in the <code>for</code> statement (this was also adopted by C in  C99):</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++98 code</code>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">len</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="n">Item</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">collection</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Most modern languages abstract the idea of the loop further: the core function of a loop is often to move to the next
item of some container. Tracking the logistics that are required to reach that item (<code>index++</code> or <code>++it</code>) is mostly an
irrelevant detail.  This realization produced two core concepts:</p>
<dl>
<dt>Iterators</dt>
<dd>
<p>A <a data-primary="iterators" data-secondary="defined" data-type="indexterm" id="OEBPS/ch01.html.id636"></a>type whose purpose is to repeatedly emit the next item of a container, until exhausted<sup><a data-type="noteref" href="#OEBPS/ch01.html.id637" id="OEBPS/ch01.html.id637-marker">23</a></sup></p>
</dd>
<dt>For-each loops</dt>
<dd>
<p>A compact loop expression <a data-primary="for-each loops" data-type="indexterm" id="OEBPS/ch01.html.id638"></a>for iterating over all of the items in a container, binding
a loop variable to the <em>item</em> rather than to the details of reaching that item</p>
</dd>
</dl>

<p>These concepts allow for loop code that’s shorter and (more importantly) clearer about what’s intended:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++11 code</code>
<code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">Item</code><code class="o">&amp;</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">collection</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Once these concepts were available, they were so obviously powerful that they were quickly retrofitted to those
languages that didn’t already have them (e.g., for-each loops were added to  <a class="orm:hideurl" href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html">Java 1.5</a> and  C++11).</p>

<p>Rust includes iterators and for-each–style loops, but it also includes the next step in abstraction: allowing the whole
loop to be expressed as an  <em>iterator transform</em> (sometimes also referred to as an  <em>iterator adaptor</em>).  <a data-primary="iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id639"></a><a data-primary="iterator adaptors" data-see="iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id640"></a><a data-primary="transformations" data-seealso="iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id641"></a>As
with <a href="#OEBPS/ch01.html.file_transform_md">Item 3</a>’s discussion of <code>Option</code> and <code>Result</code>, this Item will attempt to show how these iterator transforms can be
used instead of explicit loops, and will give guidance as to when it’s a good idea. <a data-primary="loops" data-secondary="using iterator transforms instead of" data-type="indexterm" id="OEBPS/ch01.html.id642"></a>In particular, iterator transforms can
be more efficient than an explicit loop, because the compiler can skip the bounds checks it might otherwise need to
perform.</p>

<p>By the end of this Item, a C-like explicit loop to sum the squares of the first five even items of a vector:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">values</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="cm">/* ... */</code><code class="p">];</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="o">..</code><code class="n">values</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">continue</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"></code>
<code class="w">    </code><code class="n">even_count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>should start to feel more natural expressed as a functional-style expression:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">even_sum_squares</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">values</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">x</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">sum</code><code class="p">();</code><code class="w"></code></pre>

<p>Iterator transformation expressions like this<a data-primary="iterator transforms" data-secondary="transformation expressions" data-type="indexterm" id="OEBPS/ch01.html.id643"></a> can roughly be broken down into three parts:</p>

<ul>
<li>
<p>An initial source iterator, from an instance of a type that implements one of Rust’s iterator traits</p>
</li>
<li>
<p>A sequence of iterator transforms</p>
</li>
<li>
<p>A final consumer method to combine the results of the iteration into a final value</p>
</li>
</ul>

<p>The first two of these parts effectively move functionality out of the loop body and into the <code>for</code> expression; the last
removes the need for the <code>for</code> statement altogether.</p>








<section data-pdf-bookmark="Iterator Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id41">
<h2>Iterator Traits</h2>

<p>The core  <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a very simple interface:
a single method <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a> that yields  <code>Some</code>
items until it doesn’t  (<code>None</code>).  <a data-primary="traits" data-secondary="iterator" data-type="indexterm" id="OEBPS/ch01.html.id644"></a>The type of the emitted items is given by the trait’s associated <code>Item</code>
type.<a data-primary="Item type" data-type="indexterm" id="OEBPS/ch01.html.id645"></a></p>

<p>Collections that <a data-primary="iterables" data-type="indexterm" id="OEBPS/ch01.html.id646"></a><a data-primary="collections" data-secondary="allowing iteration over contents" data-type="indexterm" id="OEBPS/ch01.html.id647"></a>allow iteration over their contents—what would be called  <em>iterables</em> in other
languages—implement the  <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> trait;
the <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a> method of this trait
consumes  <code>Self</code> and emits an <code>Iterator</code> in its stead.<a data-primary="IntoIterator trait" data-type="indexterm" id="OEBPS/ch01.html.id648"></a><a data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch01.html.id649"></a><a data-primary="Self type" data-type="indexterm" id="OEBPS/ch01.html.id650"></a>  The compiler will automatically use this trait for
expressions of the form:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// body</code>
<code class="p">}</code><code class="w"></code></pre>

<p>effectively converting them to code roughly like:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">collection</code><code class="p">.</code><code class="n">into_iter</code><code class="p">();</code><code class="w"></code>
<code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">item</code>: <code class="nc">Thing</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">item</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">break</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="c1">// body</code>
<code class="p">}</code><code class="w"></code></pre>

<p>or more succinctly and more idiomatically:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">collection</code><code class="p">.</code><code class="n">into_iter</code><code class="p">();</code><code class="w"></code>
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// body</code>
<code class="p">}</code><code class="w"></code></pre>

<p>To keep things running smoothly, there’s also an implementation of <code>IntoIterator</code> for any <code>Iterator</code>, which just
returns <code>self</code>; after all, it’s easy to convert an <code>Iterator</code> into an <code>Iterator</code>!</p>

<p>This initial form is a <a data-primary="consuming iterators" data-type="indexterm" id="OEBPS/ch01.html.id651"></a>consuming iterator, using up the collection as it’s created:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="n">Thing</code><code class="p">(</code><code class="mi">0</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">3</code><code class="p">)];</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Consumed item {item:?}"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Any attempt to use the collection after it’s been iterated over fails:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">println!</code><code class="p">(</code><code class="s">"Collection = {collection:?}"</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">error[E0382]: borrow of moved value: `collection`
   --&gt; src/main.rs:171:28
    |
163 |   let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    |       ---------- move occurs because `collection` has type `Vec&lt;Thing&gt;`,
    |                  which does not implement the `Copy` trait
164 |   for item in collection {
    |               ---------- `collection` moved due to this implicit call to
    |                           `.into_iter()`
...
171 |   println!("Collection = {collection:?}");
    |                          ^^^^^^^^^^^^^^ value borrowed here after move
    |
note: `into_iter` takes ownership of the receiver `self`, which moves
      `collection`</pre>

<p>While simple to understand, this all-consuming behavior is often undesired; some kind of <em>borrow</em> of the iterated items
is needed.<a data-primary="borrow" data-type="indexterm" id="OEBPS/ch01.html.id652"></a><a data-primary="Copy trait" data-type="indexterm" id="OEBPS/ch01.html.id653"></a></p>

<p>To ensure that behavior is clear, the examples here use a <code>Thing</code> type that does <em>not</em> implement <code>Copy</code> (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>), as
that would hide questions of ownership (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>)—the compiler would silently make copies everywhere:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Deliberately not `Copy`</code>
<code class="cp">#[derive(Clone, Debug, Eq, PartialEq)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">Thing</code><code class="p">(</code><code class="kt">u64</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">collection</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="n">Thing</code><code class="p">(</code><code class="mi">0</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code><code class="w"> </code><code class="n">Thing</code><code class="p">(</code><code class="mi">3</code><code class="p">)];</code><code class="w"></code></pre>

<p>If the<a data-primary="collections" data-secondary="preceded by &amp;" data-type="indexterm" id="OEBPS/ch01.html.id654"></a> collection being iterated over is prefixed with <code>&amp;</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="o">&amp;</code><code class="n">collection</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="p">.</code><code class="mi">0</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"collection still around {collection:?}"</code><code class="p">);</code><code class="w"></code></pre>

<p>then the Rust compiler will look for an implementation of
<a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> for the type <code>&amp;Collection</code>. Properly
designed collection types will provide such an implementation; this implementation will still consume <code>Self</code>, but now
 <code>Self</code> is <code>&amp;Collection</code> rather than <code>Collection</code>, and the associated <code>Item</code> type will be a reference <code>&amp;Thing</code>.</p>

<p>This leaves the collection intact after iteration, and the equivalent expanded code is as follows:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">iter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="o">&amp;</code><code class="n">collection</code><code class="p">).</code><code class="n">into_iter</code><code class="p">();</code><code class="w"></code>
<code class="k">while</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">item</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iter</code><code class="p">.</code><code class="n">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"{}"</code><code class="p">,</code><code class="w"> </code><code class="n">item</code><code class="p">.</code><code class="mi">0</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If it makes sense to provide iteration over mutable references,<sup><a data-type="noteref" href="#OEBPS/ch01.html.id655" id="OEBPS/ch01.html.id655-marker">24</a></sup> then a similar pattern applies for <code>for item in &amp;mut collection</code>: the compiler
looks for and uses an implementation of <code>IntoIterator</code> for <code>&amp;mut Collection</code>, with each <code>Item</code> being of type <code>&amp;mut Thing</code>.</p>

<p>By convention, standard containers also provide an <code>iter()</code> method that returns<a data-primary="iter method" data-type="indexterm" id="OEBPS/ch01.html.id656"></a><a data-primary="iter_mut method" data-type="indexterm" id="OEBPS/ch01.html.id657"></a> an iterator over references to the
underlying item, and an equivalent <code>iter_mut()</code> method, if appropriate, with the same behavior as just described. <a data-primary="for loops" data-type="indexterm" id="OEBPS/ch01.html.id658"></a><a data-primary="iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.ix_itertrns"></a>These
methods can be used in <code>for</code> loops but have a more obvious benefit when used as the start of an iterator
transformation:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="o">&amp;</code><code class="n">collection</code><code class="p">).</code><code class="n">into_iter</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">thing</code><code class="o">|</code><code class="w"> </code><code class="n">thing</code><code class="p">.</code><code class="mi">0</code><code class="p">).</code><code class="n">sum</code><code class="p">();</code><code class="w"></code></pre>

<p>becomes:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">collection</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">thing</code><code class="o">|</code><code class="w"> </code><code class="n">thing</code><code class="p">.</code><code class="mi">0</code><code class="p">).</code><code class="n">sum</code><code class="p">();</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Iterator Transforms" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id42">
<h2>Iterator Transforms</h2>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a single required method
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a>) but also provides default
implementations (<a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>) of a large number of other methods that perform transformations on an iterator.</p>

<p>Some of these transformations affect the overall<a data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch01.html.id659"></a> iteration process:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take"><code>take(n)</code></a></dt>
<dd>
<p>Restricts an iterator to
emitting at most <code>n</code> items.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip"><code>skip(n)</code></a></dt>
<dd>
<p>Skips over the first <code>n</code>
elements of the iterator.<a data-primary="skip method" data-type="indexterm" id="OEBPS/ch01.html.id660"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by"><code>step_by(n)</code></a></dt>
<dd>
<p>Converts an
iterator so it emits only every nth item.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>chain(other)</code></a></dt>
<dd>
<p>Glues together two
iterators, to build a combined iterator that moves through one then the other.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cycle"><code>cycle()</code></a></dt>
<dd>
<p>Converts <a data-primary="Clone trait" data-type="indexterm" id="OEBPS/ch01.html.id661"></a>an iterator
that terminates into one that repeats forever, starting at the beginning again whenever it reaches the end.  (The
iterator must support <code>Clone</code> to allow this.)</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev"><code>rev()</code></a></dt>
<dd>
<p>Reverses the direction of an
iterator. (The iterator must implement the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>Double​En⁠ded​Iterator</code></a> trait, which has an
additional <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a>
required method.)</p>
</dd>
</dl>

<p>Other transformations affect the nature of the <code>Item</code> that’s <a data-primary="Item type" data-type="indexterm" id="OEBPS/ch01.html.id662"></a>the subject of the <code>Iterator</code>:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map(|item| {...})</code></a></dt>
<dd>
<p>Repeatedly applies a closure to transform each item in turn. This is the most general version; several of the following entries in this list are convenience variants that could be equivalently implemented as a <code>map</code>.<a data-primary="closures" data-secondary="in iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id663"></a><a data-primary="map method" data-type="indexterm" id="OEBPS/ch01.html.id664"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>cloned()</code></a></dt>
<dd>
<p>Produces a clone of
all of the items in the original iterator; this <a data-primary="cloned method" data-type="indexterm" id="OEBPS/ch01.html.id665"></a>is particularly useful with iterators over <code>&amp;Item</code> references. (This
obviously requires the underlying <code>Item</code> type to implement <code>Clone</code>.)</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied"><code>copied()</code></a></dt>
<dd>
<p>Produces a copy of
all of the items in the original iterator; this is<a data-primary="copied method" data-type="indexterm" id="OEBPS/ch01.html.id666"></a><a data-primary="Copy trait" data-type="indexterm" id="OEBPS/ch01.html.id667"></a> particularly useful with iterators over <code>&amp;Item</code> references. (This
obviously requires the underlying <code>Item</code> type to implement <code>Copy</code>, but it is likely to be faster than <code>cloned()</code>, if
that’s the case.)</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate"><code>enumerate()</code></a></dt>
<dd>
<p>Converts an
iterator over items to be an iterator over <code>(usize, Item)</code> pairs, providing an index to the items in the iterator.<a data-primary="enumerate method" data-type="indexterm" id="OEBPS/ch01.html.id668"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>zip(it)</code></a></dt>
<dd>
<p>Joins an iterator with a second
iterator, to produce a combined iterator that emits pairs of items, one from each of the original iterators, until the
shorter of the two iterators is finished.<a data-primary="zip method" data-type="indexterm" id="OEBPS/ch01.html.id669"></a></p>
</dd>
</dl>

<p>Yet other transformations perform filtering on the <code>Item</code>s being emitted by the 
<span class="keep-together"><code>Iterator</code></span>:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter(|item| {...})</code></a></dt>
<dd>
<p>Applies a <code>bool</code>-returning closure to each item reference to determine whether it should be passed through.<a data-primary="filter method" data-type="indexterm" id="OEBPS/ch01.html.id670"></a><a data-primary="bool type" data-type="indexterm" id="OEBPS/ch01.html.id671"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while"><code>take_while()</code></a></dt>
<dd>
<p>Emits an initial subrange of the iterator, based on a predicate. Mirror image of <code>skip_while</code>.<a data-primary="take_while method" data-type="indexterm" id="OEBPS/ch01.html.id672"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip_while"><code>skip_while()</code></a></dt>
<dd>
<p>Emits a final subrange of the iterator, based on a predicate. Mirror image of <code>take_while</code>.<a data-primary="skip_while method" data-type="indexterm" id="OEBPS/ch01.html.id673"></a></p>
</dd>
</dl>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten"><code>flatten()</code></a> method deals
with an iterator <a data-primary="flatten method" data-type="indexterm" id="OEBPS/ch01.html.id674"></a>whose items are themselves iterators, flattening the result.  On its own, this doesn’t seem that
helpful, but it becomes much more useful when combined with the observation that both
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.iter"><code>Option</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.iter"><code>Result</code></a> act as iterators: they produce
either zero (for <code>None</code>, <code>Err(e)</code>) or one (for <code>Some(v)</code>, <code>Ok(v)</code>) items.  This means that <code>flatten</code>ing a stream of
<code>Option</code>/<code>Result</code> values is a simple way to extract just the valid values, ignoring the rest.<a data-primary="Err variant of Result" data-type="indexterm" id="OEBPS/ch01.html.id675"></a><a data-primary="Option type" data-type="indexterm" id="OEBPS/ch01.html.id676"></a><a data-primary="None variant of Option" data-type="indexterm" id="OEBPS/ch01.html.id677"></a><a data-primary="Result type" data-type="indexterm" id="OEBPS/ch01.html.id678"></a><a data-primary="Ok variant of Result" data-type="indexterm" id="OEBPS/ch01.html.id679"></a><a data-primary="Some variant of Option" data-type="indexterm" id="OEBPS/ch01.html.id680"></a><a data-primary="flattening stream of Option / Result values" data-type="indexterm" id="OEBPS/ch01.html.id681"></a></p>

<p>Taken as a whole, these methods allow iterators to be transformed so that they produce exactly the sequence of elements
that are needed for most situations.<a data-primary="iterator transforms" data-startref="ix_itertrns" data-type="indexterm" id="OEBPS/ch01.html.id682"></a></p>
</div></section>








<section data-pdf-bookmark="Iterator Consumers" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id43">
<h2>Iterator Consumers</h2>

<p>The previous two sections described how to obtain an iterator and how to transform it into exactly the right shape for
precise iteration.<a data-primary="iterators" data-secondary="iterator consumers" data-type="indexterm" id="OEBPS/ch01.html.ix_itercons"></a><a data-primary="for-each loops" data-type="indexterm" id="OEBPS/ch01.html.id683"></a>  This precisely targeted iteration could happen as an explicit for-each loop:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">values</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">).</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, the large collection of <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> methods</a> includes
many that allow an iteration to be consumed in a single method call, removing the need for an explicit <code>for</code> loop.<a data-primary="for loops" data-type="indexterm" id="OEBPS/ch01.html.id684"></a></p>

<p>The most general of these methods is  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each"><code>for_each(|item| {...})</code></a>, which runs a closure for each item
produced by the <code>Iterator</code>. <a data-primary="for_each method" data-type="indexterm" id="OEBPS/ch01.html.id685"></a>This can do <em>most</em> of the things that an explicit <code>for</code> loop can do (the exceptions are
described in a later section), but its generality also makes it a little awkward to use—the closure needs to use mutable
references to external state in order to emit anything:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="n">values</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">for_each</code><code class="p">(</code><code class="o">|</code><code class="n">value</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// closure needs a mutable reference to state elsewhere</code>
<code class="w">        </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">});</code><code class="w"></code></pre>

<p>However, if the body of the  <code>for</code> loop matches one of a number of common patterns, there are more specific
iterator-consuming methods that are clearer, shorter, and more idiomatic.</p>

<p>These patterns include shortcuts for building a single value out of the collection:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>sum()</code></a></dt>
<dd>
<p>Sums a collection of
numeric values (integers or floats).<a data-primary="sum method" data-type="indexterm" id="OEBPS/ch01.html.id686"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.product"><code>product()</code></a></dt>
<dd>
<p>Multiplies a collection of numeric values.<a data-primary="product method" data-type="indexterm" id="OEBPS/ch01.html.id687"></a><a data-primary="min method" data-type="indexterm" id="OEBPS/ch01.html.id688"></a><a data-primary="max method" data-type="indexterm" id="OEBPS/ch01.html.id689"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min"><code>min()</code></a></dt>
<dd>
<p>Finds the minimum value of a collection, relative to the Item’s <code>Ord</code> implementation (see <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>).</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max"><code>max()</code></a></dt>
<dd>
<p>Finds the maximum value of a collection, relative to the Item’s <code>Ord</code> implementation (see <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>).<a data-primary="Ord trait" data-type="indexterm" id="OEBPS/ch01.html.id690"></a><a data-primary="Item type" data-secondary="Ord implementation" data-type="indexterm" id="OEBPS/ch01.html.id691"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by"><code>min_by(f)</code></a></dt>
<dd>
<p>Finds the minimum value of a collection, relative to a user-specified comparison function <code>f</code>.<a data-primary="min_by method" data-type="indexterm" id="OEBPS/ch01.html.id692"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by"><code>max_by(f)</code></a></dt>
<dd>
<p>Finds the maximum value of a collection, relative to a user-specified comparison function <code>f</code>.<a data-primary="max_by method" data-type="indexterm" id="OEBPS/ch01.html.id693"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce"><code>reduce(f)</code></a></dt>
<dd>
<p>Builds an accumulated value of the <code>Item</code> type by running a closure at each step that takes the value accumulated so far and the current item.  This is a more general operation that encompasses the previous methods.<a data-primary="reduce method" data-type="indexterm" id="OEBPS/ch01.html.id694"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold"><code>fold(f)</code></a></dt>
<dd>
<p>Builds an accumulated value of an arbitrary type (not just the <code>Iterator::Item</code> type) by running a closure at each step that takes the value accumulated so far and the current item.  This is a generalization of <code>reduce</code>.<a data-primary="fold method" data-type="indexterm" id="OEBPS/ch01.html.id695"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code>scan(init, f)</code></a></dt>
<dd>
<p>Builds an accumulated value of an arbitrary type by running a closure at each step that takes a mutable reference to some internal state and the current item.  This is a slightly different generalization of <code>reduce</code>.<a data-primary="scan method" data-type="indexterm" id="OEBPS/ch01.html.id696"></a><a data-primary="Iterator trait" data-secondary="methods to select single value from collection" data-type="indexterm" id="OEBPS/ch01.html.id697"></a></p>
</dd>
</dl>

<p>There are also methods for <em>selecting</em> a single value out of the collection:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>find(p)</code></a></dt>
<dd>
<p>Finds the first item that
satisfies a predicate.<a data-primary="find method" data-type="indexterm" id="OEBPS/ch01.html.id698"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>position(p)</code></a></dt>
<dd>
<p>Also finds
the first item satisfying a predicate, but this time it returns the index of the item.<a data-primary="position method" data-type="indexterm" id="OEBPS/ch01.html.id699"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth"><code>nth(n)</code></a></dt>
<dd>
<p>Returns the <code>n</code>th element
of the iterator, if available.<a data-primary="nth element of iterator" data-type="indexterm" id="OEBPS/ch01.html.id700"></a></p>
</dd>
</dl>

<p>There are methods for testing against every item in the collection:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>any(p)</code></a></dt>
<dd>
<p>Indicates whether a
predicate is <code>true</code> for <em>any</em> item in the collection.<a data-primary="any method (on Iterator)" data-type="indexterm" id="OEBPS/ch01.html.id701"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all"><code>all(p)</code></a></dt>
<dd>
<p>Indicates whether a
predicate is <code>true</code> for <em>all</em> items in the collection.<a data-primary="all method (on Iterator)" data-type="indexterm" id="OEBPS/ch01.html.id702"></a></p>
</dd>
</dl>

<p>In either case, iteration will terminate early if the relevant counterexample is found.</p>

<p>There are methods that allow for the possibility of failure in the closures used with each item.<a data-primary="closures" data-secondary="in iterator transforms" data-tertiary="failures of" data-type="indexterm" id="OEBPS/ch01.html.id703"></a>  In each case, if a
closure returns a failure for an item, the iteration is terminated and the operation as a whole returns the first
failure:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each"><code>try_for_each(f)</code></a></dt>
<dd>
<p>Behaves like <code>for_each</code>, but the closure can fail<a data-primary="try_for_each method" data-type="indexterm" id="OEBPS/ch01.html.id704"></a><a data-primary="for_each method" data-type="indexterm" id="OEBPS/ch01.html.id705"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold"><code>try_fold(f)</code></a></dt>
<dd>
<p>Behaves like
<code>fold</code>, but the closure can fail<a data-primary="try_fold method" data-type="indexterm" id="OEBPS/ch01.html.id706"></a><a data-primary="fold method" data-type="indexterm" id="OEBPS/ch01.html.id707"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_find"><code>try_find(f)</code></a></dt>
<dd>
<p>Behaves like
<code>find</code>, but the closure can fail<a data-primary="try_find method" data-type="indexterm" id="OEBPS/ch01.html.id708"></a></p>
</dd>
</dl>

<p>Finally, there are methods that accumulate all of the iterated items into a new collection.<a data-primary="collect method" data-type="indexterm" id="OEBPS/ch01.html.id709"></a>  The most important of these
is  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect()</code></a>, which can be
used to build a new instance of any collection type that implements the
<a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a> trait.</p>

<p>The <code>FromIterator</code> trait is implemented<a data-primary="FromIterator trait" data-type="indexterm" id="OEBPS/ch01.html.id710"></a> for all of the standard library collection types
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-FromIterator%3CT%3E"><code>Vec</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-FromIterator%3C(K%2C%20V)%3E"><code>HashMap</code></a>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E"><code>BTreeSet</code></a>, etc.), but
this ubiquity also means <a data-primary="Vec type" data-type="indexterm" id="OEBPS/ch01.html.id711"></a><a data-primary="HashSet type" data-type="indexterm" id="OEBPS/ch01.html.id712"></a>that you often have to use explicit types, because otherwise the
compiler can’t figure out whether you’re trying to assemble (say) a <code>Vec&lt;i32&gt;</code> or <code>HashSet&lt;i32&gt;</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">collections</code>::<code class="n">HashSet</code><code class="p">;</code><code class="w"></code>

<code class="c1">// Build collections of even numbers.  Type must be specified, because</code>
<code class="c1">// the expression is the same for either type.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">myvec</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="o">..</code><code class="mi">10</code><code class="p">).</code><code class="n">into_iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">h</code>: <code class="nc">HashSet</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="mi">0</code><code class="o">..</code><code class="mi">10</code><code class="p">).</code><code class="n">into_iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">).</code><code class="n">collect</code><code class="p">();</code><code class="w"></code></pre>

<p>This example also illustrates the use of  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expressions</a> to generate the initial data to be
iterated over.</p>

<p>Other (more obscure) collection-producing methods include the following:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip"><code>unzip()</code></a></dt>
<dd>
<p>Divides an
iterator of pairs into two collections<a data-primary="unzip method" data-type="indexterm" id="OEBPS/ch01.html.id713"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"><code>partition(p)</code></a></dt>
<dd>
<p>Splits an iterator into two collections based on a predicate that is applied <a data-primary="partition method" data-type="indexterm" id="OEBPS/ch01.html.id714"></a>to each item</p>
</dd>
</dl>

<p>This Item has touched on a wide selection of <code>Iterator</code> methods, but this is only a subset of the methods available;
for more information, consult the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator documentation</a> or
read <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/programming-rust-2nd/9781492052586/ch15.html">Chapter 15 of  <em>Programming Rust</em>, 2nd edition (O’Reilly)</a>, which has extensive coverage of the possibilities.<a data-primary="Programming Rust (Blandy et al.)" data-type="indexterm" id="OEBPS/ch01.html.id715"></a></p>

<p>This rich collection of iterator transformations is there to be used. It produces code that is more idiomatic, more
compact, and has clearer intent.</p>

<p>Expressing loops as iterator transformations can also produce code that is more efficient.<a data-primary="bounds checking" data-type="indexterm" id="OEBPS/ch01.html.id716"></a>  In the interests of safety,
Rust performs  <em>bounds checking</em> on access to contiguous containers such as vectors and slices; an attempt to
access a value beyond the bounds of the collection triggers a panic rather than an access to invalid data.<a data-primary="slices" data-secondary="bounds checking" data-type="indexterm" id="OEBPS/ch01.html.id717"></a><a data-primary="vectors" data-secondary="bounds checking" data-type="indexterm" id="OEBPS/ch01.html.id718"></a><a data-primary="loops" data-secondary="old-style, bounds checking and" data-type="indexterm" id="OEBPS/ch01.html.id719"></a>  An old-style
loop that accesses container values (e.g., <code>values[i]</code>) <em>might</em> be subject to these runtime checks, whereas an iterator
that produces one value after another is already known to be within range.</p>

<p>However, it’s also the case that an old-style loop might <em>not</em> be subject to additional bounds checks compared to the
equivalent iterator transformation.  The Rust compiler and optimizer is very good at analyzing the code surrounding a
slice access to determine whether it’s safe to skip the bounds checks;  Sergey
“Shnatsel” Davidoff’s <a href="https://oreil.ly/impAX">2023 article</a> explores the
subtleties involved.</p>
</div></section>








<section data-pdf-bookmark="Building Collections from Result Values" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id44">
<h2>Building Collections from <code>Result</code> Values</h2>

<p>The previous section described the use of <code>collect()</code> to build collections from iterators, but <code>collect()</code> also has  a
particularly helpful feature when dealing with  <code>Result</code> values.<a data-primary="iterators" data-secondary="iterator consumers" data-startref="ix_itercons" data-type="indexterm" id="OEBPS/ch01.html.id720"></a><a data-primary="iterators" data-secondary="building collections from Result values" data-type="indexterm" id="OEBPS/ch01.html.id721"></a><a data-primary="Result type" data-secondary="building collections from values" data-type="indexterm" id="OEBPS/ch01.html.id722"></a></p>

<p>Consider an attempt to convert a vector of <code>i64</code> values into bytes (<code>u8</code>), with the optimistic expectation <a data-primary="i64 type" data-type="indexterm" id="OEBPS/ch01.html.id723"></a><a data-primary="u8 type" data-type="indexterm" id="OEBPS/ch01.html.id724"></a><a data-primary="vectors" data-secondary="converting vector of i64 values to bytes (u8)" data-type="indexterm" id="OEBPS/ch01.html.id725"></a>that they
will all fit:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch01.html.id726">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="c1">// In the 2021 edition of Rust, `TryFrom` is in the prelude, so this</code>
<code class="c1">// `use` statement is no longer needed.</code>
<code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">convert</code>::<code class="n">TryFrom</code><code class="p">;</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">inputs</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">];</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">result</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">inputs</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">into_iter</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code>::<code class="n">try_from</code><code class="p">(</code><code class="n">v</code><code class="p">).</code><code class="n">unwrap</code><code class="p">())</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code><code class="p">();</code><code class="w"></code></pre>
</div></aside>

<p>This works until some unexpected input comes along:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">inputs</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">i64</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">512</code><code class="p">];</code><code class="w"></code></pre>

<p>and causes a runtime failure:</p>

<pre data-code-language="text" data-type="programlisting">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:
TryFromIntError(())', iterators/src/main.rs:266:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</pre>

<p>Following the advice given in <a href="#OEBPS/ch01.html.file_transform_md">Item 3</a>, we want to keep the <code>Result</code> type in play and use the <code>?</code> operator to make any
failure the problem of the calling code.<a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id727"></a>  The obvious modification to emit the <code>Result</code> doesn’t really help:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="nb">Result</code><code class="o">&lt;</code><code class="kt">u8</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"></code>
<code class="w">    </code><code class="n">inputs</code><code class="p">.</code><code class="n">into_iter</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code>::<code class="n">try_from</code><code class="p">(</code><code class="n">v</code><code class="p">)).</code><code class="n">collect</code><code class="p">();</code><code class="w"></code>
<code class="c1">// Now what?  Still need to iterate to extract results and detect errors.</code></pre>

<p>However, there’s an alternative version of <code>collect()</code>, which <a data-primary="Vec type" data-secondary="Result holding a Vec" data-type="indexterm" id="OEBPS/ch01.html.id728"></a>can assemble a <code>Result</code> holding a <code>Vec</code>, instead of a
<code>Vec</code> holding <code>Result</code>s.</p>

<p>Forcing use of this version <a data-primary="turbofish" data-type="indexterm" id="OEBPS/ch01.html.id729"></a>requires the turbofish (<code>::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;</code>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">inputs</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">into_iter</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">v</code><code class="o">|</code><code class="w"> </code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code>::<code class="n">try_from</code><code class="p">(</code><code class="n">v</code><code class="p">))</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">collect</code>::<code class="o">&lt;</code><code class="nb">Result</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">_</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="o">&gt;&gt;</code><code class="p">()</code><code class="o">?</code><code class="p">;</code><code class="w"></code></pre>

<p>Combining<a data-primary="? (question mark) operator" data-secondary="applied to Result iterators" data-type="indexterm" id="OEBPS/ch01.html.id730"></a> this with the question mark operator gives useful behavior:</p>

<ul>
<li>
<p>If the iteration encounters an error value, that error value is emitted to the caller and iteration stops.</p>
</li>
<li>
<p>If no errors are encountered, the remainder of the code can deal with a sensible collection of values of the right type.</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Loop Transformation" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id45">
<h2>Loop Transformation</h2>

<p>The aim of this Item is to convince you that many explicit loops can be regarded as something to be converted to
iterator transformations.<a data-primary="iterator transforms" data-secondary="converting loops to" data-type="indexterm" id="OEBPS/ch01.html.id731"></a><a data-primary="loops" data-secondary="converting to iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id732"></a>  This can feel somewhat unnatural for programmers who aren’t used to it, so let’s walk through
a transformation step by step.</p>

<p>Starting with a very C-like explicit loop to sum the squares of the first five even items of a vector:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="mi">0</code><code class="o">..</code><code class="n">values</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">continue</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">]</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">values</code><code class="p">[</code><code class="n">i</code><code class="p">];</code><code class="w"></code>
<code class="w">    </code><code class="n">even_count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The first step is to <a data-primary="for-each loops" data-type="indexterm" id="OEBPS/ch01.html.id733"></a>replace vector indexing with direct use of an iterator in a for-each loop:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">values</code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">continue</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">even_count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>An initial arm of the loop that uses <code>continue</code> to skip<a data-primary="filter method" data-type="indexterm" id="OEBPS/ch01.html.id734"></a> over some items is naturally expressed as a <code>filter()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">values</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">even_count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">even_count</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Next, the early exit from the loop <a data-primary="take method" data-type="indexterm" id="OEBPS/ch01.html.id735"></a>once five even items have been spotted maps to a <code>take(5)</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">values</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">).</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Every iteration of the loop uses only the item squared, in the <code>value * value</code> combination, which makes it <a data-primary="map method" data-type="indexterm" id="OEBPS/ch01.html.id736"></a>an ideal target
for a <code>map()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">val_sqr</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">values</code><code class="p">.</code><code class="n">iter</code><code class="p">().</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">).</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">).</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">x</code><code class="p">)</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">even_sum_squares</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">val_sqr</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>These refactorings of the original loop result in a loop body that’s the perfect nail to fit under the <a data-primary="sum method" data-type="indexterm" id="OEBPS/ch01.html.id737"></a>hammer of
the <code>sum()</code> method:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">even_sum_squares</code>: <code class="kt">u64</code> <code class="o">=</code><code class="w"> </code><code class="n">values</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">iter</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">take</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">x</code><code class="o">|</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">x</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">.</code><code class="n">sum</code><code class="p">();</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="When Explicit Is Better" data-type="sect2"><div class="sect2" id="OEBPS/ch01.html.id46">
<h2>When Explicit Is Better</h2>

<p>This Item has highlighted the advantages of iterator transformations, particularly with respect to concision and
clarity.<a data-primary="loops" data-secondary="using explicit loops instead of iterator transforms" data-type="indexterm" id="OEBPS/ch01.html.id738"></a><a data-primary="iterator transforms" data-secondary="when explicit loops are better than" data-type="indexterm" id="OEBPS/ch01.html.id739"></a>  So when are iterator transformations <em>not</em> appropriate or idiomatic?</p>

<ul>
<li>
<p>If the loop body is large and/or multifunctional, it makes sense to keep it as an explicit body rather than squeezing
it into a closure.</p>
</li>
<li>
<p>If the loop body involves error conditions that result in early termination of the surrounding function, these<a data-primary="try_.. methods" data-type="indexterm" id="OEBPS/ch01.html.id740"></a> are
often best kept explicit—the <code>try_..()</code> methods help only a little.  However, <code>collect()</code>’s ability to convert
a collection of <code>Result</code> values into a <code>Result</code> holding a collection of values often allows error conditions to still
be handled with the <code>?</code> operator.<a data-primary="Result type" data-type="indexterm" id="OEBPS/ch01.html.id741"></a><a data-primary="collect method" data-type="indexterm" id="OEBPS/ch01.html.id742"></a><a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch01.html.id743"></a></p>
</li>
<li>
<p>If performance is vital, an iterator transform that involves a closure <em>should</em> get optimized so that it is <a class="orm:hideurl" href="https://doc.rust-lang.org/book/ch13-04-performance.html">just as fast</a> as the equivalent explicit code.  But if performance
of a core loop is that important, <em>measure</em> different variants and tune appropriately:<a data-primary="Godbolt compiler explorer" data-type="indexterm" id="OEBPS/ch01.html.id744"></a></p>

<ul>
<li>
<p>Be careful to ensure that your measurements reflect real-world performance—the compiler’s optimizer can
give overoptimistic results on test data (as described in <a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>).</p>
</li>
<li>
<p>The  <a href="https://rust.godbolt.org">Godbolt compiler explorer</a> is an amazing tool for exploring what the compiler
spits out.</p>
</li>
</ul>
</li>
</ul>

<p>Most importantly, don’t convert a loop into an iteration transformation if the conversion is forced or awkward.  This is
a matter of  taste to be sure—but be aware that your taste is likely to change as you become more familiar
with the  functional style.<a data-primary="iterators" data-startref="ix_iter" data-type="indexterm" id="OEBPS/ch01.html.id745"></a></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch01.html.id279"><sup><a href="#OEBPS/ch01.html.id279-marker">1</a></sup> The situation gets muddier still if the filesystem is involved, since filenames on popular platforms are somewhere in between arbitrary bytes and UTF-8 sequences: see the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a> documentation.</p><p data-type="footnote" id="OEBPS/ch01.html.id281"><sup><a href="#OEBPS/ch01.html.id281-marker">2</a></sup> Technically, a <a class="orm:hideurl" href="https://www.unicode.org/glossary/#unicode_scalar_value"><em>Unicode scalar value</em></a> rather than a code point.</p><p data-type="footnote" id="OEBPS/ch01.html.id292"><sup><a href="#OEBPS/ch01.html.id292-marker">3</a></sup> The need to consider all possibilities also means that adding a new variant to an existing <code>enum</code> in a library is a <em>breaking change</em> (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>): library clients will need to change their code to cope with the new variant.<a data-primary="C++" data-secondary="switch arms for enums, warning about missing" data-type="indexterm" id="OEBPS/ch01.html.id746"></a>  If an <code>enum</code> is really just a C-like list of related numerical values, this behavior can be avoided by marking it as a  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> <code>enum</code>; see <a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>.</p><p data-type="footnote" id="OEBPS/ch01.html.id343"><sup><a href="#OEBPS/ch01.html.id343-marker">4</a></sup> At least not in stable Rust at the time of writing. The <a class="orm:hideurl" href="https://doc.rust-lang.org/nightly/unstable-book/language-features/unboxed-closures.html"><code>unboxed_closures</code></a> and <a class="orm:hideurl" href="https://doc.rust-lang.org/nightly/unstable-book/library-features/fn-traits.html"><code>fn_traits</code></a> experimental features may change this in the future.</p><p data-type="footnote" id="OEBPS/ch01.html.id352"><sup><a href="#OEBPS/ch01.html.id352-marker">5</a></sup> For example, Joshua Bloch’s  <a class="orm:hideurl" href="https://www.oreilly.com/library/view/effective-java/9780134686097/"><em>Effective Java</em></a> (3rd edition, Addison-Wesley) includes Item 64: Refer to objects by their interfaces.</p><p data-type="footnote" id="OEBPS/ch01.html.id363"><sup><a href="#OEBPS/ch01.html.id363-marker">6</a></sup> The addition of <a href="https://oreil.ly/ueIhM"><em>concepts</em></a> in  C++20 allows explicit specification of constraints on template types, but the checks are still performed only when the template is instantiated, not when it is declared.</p><p data-type="footnote" id="OEBPS/ch01.html.id392"><sup><a href="#OEBPS/ch01.html.id392-marker">7</a></sup> The <a href="https://oreil.ly/effective_rust_transforms">online version of this diagram</a> is clickable; each box links to the relevant documentation.</p><p data-type="footnote" id="OEBPS/ch01.html.id395"><sup><a href="#OEBPS/ch01.html.id395-marker">8</a></sup> Note that this method is separate from the  <code>AsRef</code> trait, even though the method name <a data-primary="as_Ref method" data-type="indexterm" id="OEBPS/ch01.html.id747"></a><a data-primary="AsRef trait" data-type="indexterm" id="OEBPS/ch01.html.id748"></a>is the same.</p><p data-type="footnote" id="OEBPS/ch01.html.id405"><sup><a href="#OEBPS/ch01.html.id405-marker">9</a></sup> Or at least the only nondeprecated, stable method.</p><p data-type="footnote" id="OEBPS/ch01.html.id409"><sup><a href="#OEBPS/ch01.html.id409-marker">10</a></sup> At the time of writing, <code>Error</code> has been <a href="https://oreil.ly/Il0vv">moved to <code>core</code></a> but is not yet available in stable Rust.</p><p data-type="footnote" id="OEBPS/ch01.html.id432"><sup><a href="#OEBPS/ch01.html.id432-marker">11</a></sup> This section is inspired by  <a href="https://oreil.ly/2K3PH">Nick Groenen’s “Rust: Structuring and Handling Errors in 2020” article</a>.</p><p data-type="footnote" id="OEBPS/ch01.html.id453"><sup><a href="#OEBPS/ch01.html.id453-marker">12</a></sup> More properly known as the  <em>trait coherence rules</em>.</p><p data-type="footnote" id="OEBPS/ch01.html.id465"><sup><a href="#OEBPS/ch01.html.id465-marker">13</a></sup> For now—this is likely to be replaced with the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code> “never” type</a> in a future version of Rust.</p><p data-type="footnote" id="OEBPS/ch01.html.id480"><sup><a href="#OEBPS/ch01.html.id480-marker">14</a></sup> Allowing lossy conversions in Rust was probably a mistake, and there have been <a href="https://oreil.ly/TpFKB">discussions</a> around trying to remove this behavior.</p><p data-type="footnote" id="OEBPS/ch01.html.id491"><sup><a href="#OEBPS/ch01.html.id491-marker">15</a></sup> Rust refers to these conversions as <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/subtyping.html">“subtyping,”</a> but it’s quite different from the definition of “subtyping” used in object-oriented languages.</p><p data-type="footnote" id="OEBPS/ch01.html.id501"><sup><a href="#OEBPS/ch01.html.id501-marker">16</a></sup> Specifically, the <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>.</p><p data-type="footnote" id="OEBPS/ch01.html.id502"><sup><a href="#OEBPS/ch01.html.id502-marker">17</a></sup> See <a href="https://oreil.ly/AiraF">“Mars Climate Orbiter” on Wikipedia</a> for more on the cause of failure.</p><p data-type="footnote" id="OEBPS/ch01.html.id516"><sup><a href="#OEBPS/ch01.html.id516-marker">18</a></sup> This is a sufficiently common problem for  <code>serde</code> that it includes a <a href="https://oreil.ly/6_6MC">mechanism to help</a>.</p><p data-type="footnote" id="OEBPS/ch01.html.id551"><sup><a href="#OEBPS/ch01.html.id551-marker">19</a></sup> Albeit with a warning from modern compilers.</p><p data-type="footnote" id="OEBPS/ch01.html.id584"><sup><a href="#OEBPS/ch01.html.id584-marker">20</a></sup> The equivalent trait for mutable expressions<a data-primary="IndexMut trait" data-type="indexterm" id="OEBPS/ch01.html.id749"></a> is  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a>.</p><p data-type="footnote" id="OEBPS/ch01.html.id589"><sup><a href="#OEBPS/ch01.html.id589-marker">21</a></sup> This is somewhat simplified; a full vtable also includes information about the size and  alignment of the type, together with a  <code>drop()</code> function pointer so that the underlying object can be safely dropped.</p><p data-type="footnote" id="OEBPS/ch01.html.id610"><sup><a href="#OEBPS/ch01.html.id610-marker">22</a></sup> Note that this doesn’t affect Rust’s memory safety guarantees: the items are still safe, just inaccessible.</p><p data-type="footnote" id="OEBPS/ch01.html.id637"><sup><a href="#OEBPS/ch01.html.id637-marker">23</a></sup> In fact, the iterator can be more general—the idea of emitting next items until completion need not be associated with a container.</p><p data-type="footnote" id="OEBPS/ch01.html.id655"><sup><a href="#OEBPS/ch01.html.id655-marker">24</a></sup> This method can’t be provided if a mutation to the item might invalidate the container’s internal guarantees.<a data-primary="Hash trait" data-type="indexterm" id="OEBPS/ch01.html.id750"></a><a data-primary="HashMap type" data-type="indexterm" id="OEBPS/ch01.html.id751"></a> For example, changing the item’s contents in a way that alters its  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> value would invalidate the internal data structures of a  <code>HashMap</code>.</p></div></div></section></div></div>
<div id="OEBPS/ch02.html"><div data-type="book">
<section data-pdf-bookmark="Chapter 2. Traits" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch02.html.file_traits_md">
<h1><span class="label">Chapter 2. </span>Traits</h1>


<p>The second core pillar of Rust’s type system is the use of  traits, which allow the encoding of behavior that is
common across distinct types.<a data-primary="traits" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id752"></a><a data-primary="generics" data-type="indexterm" id="OEBPS/ch02.html.id753"></a>  A <code>trait</code> is roughly equivalent to an interface type in other languages, but they are
also tied to Rust’s  <em>generics</em> (<a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>), to allow interface reuse without runtime overhead.</p>

<p>The Items in this chapter describe the standard traits that the Rust compiler and the Rust toolchain make available, and
provide advice on how to design and use trait-encoded behavior.</p>






<section data-pdf-bookmark="Item 10: Familiarize yourself with standard traits" data-type="sect1"><div class="sect1" id="OEBPS/ch02.html.file_std-traits_md">
<h1>Item 10: Familiarize yourself with standard traits</h1>

<p>Rust encodes key behavioral <a data-primary="traits" data-secondary="standard traits" data-type="indexterm" id="OEBPS/ch02.html.id754"></a>aspects of its  type system in the type system itself, through a collection of
fine-grained standard  traits that describe those behaviors (see <a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>).</p>

<p>Many of these traits will seem familiar to programmers <a data-primary="C++" data-type="indexterm" id="OEBPS/ch02.html.id755"></a>coming from  C++, corresponding to concepts such as
copy-constructors, destructors, equality and assignment operators, etc.</p>

<p>As in C++, it’s often a good idea to implement many of these traits for your own types; the Rust compiler will give
you helpful error messages if some operation needs one of these traits for your type and it isn’t present.</p>

<p>Implementing such a large collection of traits may seem daunting, but most of the common ones can be automatically
applied to user-defined types, using <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><code>derive</code> macros</a>. <a data-primary="macros" data-secondary="derive" data-type="indexterm" id="OEBPS/ch02.html.id756"></a><a data-primary="derive macros" data-type="indexterm" id="OEBPS/ch02.html.id757"></a><a data-primary="Eq trait" data-type="indexterm" id="OEBPS/ch02.html.id758"></a><a data-primary="struct types" data-secondary="field-by-field comparison for Eq" data-type="indexterm" id="OEBPS/ch02.html.id759"></a>These <code>derive</code> macros generate code
with the “obvious” implementation of the trait for that type (e.g., field-by-field comparison for <code>Eq</code> on a <code>struct</code>);
this normally requires that all constituent parts also implement the trait.  The auto-generated 
<span class="keep-together">implementation</span> is
<em>usually</em> what you want, but there are occasional exceptions discussed in each trait’s section that follows.<a data-primary="traits" data-secondary="auto-generated implementations from derive macros" data-type="indexterm" id="OEBPS/ch02.html.id760"></a></p>

<p>The use of the <code>derive</code> macros does lead to type definitions like:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]</code><code class="w"></code>
<code class="k">enum</code> <code class="nc">MyBooleanOption</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Off</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">On</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>where auto-generated implementations are triggered for eight different traits.</p>

<p>This fine-grained specification of behavior can be disconcerting at first, but it’s important to be familiar with the
most common of these standard traits so that the available behaviors of a type definition can be immediately
understood.</p>








<section data-pdf-bookmark="Common Standard Traits" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id49">
<h2>Common Standard Traits</h2>

<p>This section discusses the most commonly encountered standard traits. Here are rough one-sentence <a data-primary="traits" data-secondary="common standard traits" data-type="indexterm" id="OEBPS/ch02.html.ix_traitCS"></a>summaries of each:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></dt>
<dd>
<p> Items of this type can make a copy of themselves
when asked, by running user-defined code.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></dt>
<dd>
<p> If the compiler makes a bit-for-bit copy of this
item’s memory representation (without running any user-defined code), the result is a valid new item.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></dt>
<dd>
<p> It’s possible to make new instances of
this type with sensible default values.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></dt>
<dd>
<p> There’s a <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence relation</a> for items of this type—any two items
can be definitively compared, but it may not always be true that <code>x==x</code>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a></dt>
<dd>
<p> There’s an <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a> for items of this type—any two items can be
definitively compared, and it <em>is</em> always true that <code>x==x</code>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></dt>
<dd>
<p>  <em>Some</em> items of this type can be
compared and ordered.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a></dt>
<dd>
<p>  <em>All</em> items of this type can be
compared and ordered.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></dt>
<dd>
<p> Items of this type can produce a stable hash of their
contents when asked.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></dt>
<dd>
<p>Items of this type can be displayed to programmers.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></dt>
<dd>
<p>Items of this type can be displayed to users.</p>
</dd>
</dl>

<p>These traits can all be <code>derive</code>d for user-defined types, with the exception of <code>Display</code> (included here because of its
overlap with <code>Debug</code>).  <a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch02.html.id761"></a>However, there are occasions when a manual implementation—or no implementation—is
preferable.</p>

<p>The following sections discuss each of these common traits in more detail.</p>










<section data-pdf-bookmark="Clone" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id50">
<h3><code>Clone</code></h3>

<p>The  <code>Clone</code> trait indicates that <a data-primary="Clone trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id762"></a>it’s possible to make a new copy of an item, by calling the
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone()</code></a> method.  This is roughly equivalent to
C++’s copy-constructor but is more explicit: the compiler will never silently invoke this method on its own (read on to
the next section for that).</p>

<p><code>Clone</code> can be  <code>derive</code>d for a type if all of the item’s fields implement <code>Clone</code> themselves. The <code>derive</code>d
implementation clones an aggregate type by cloning each of its members in turn; again, this is roughly equivalent to a
default copy-constructor in C++.  This makes the trait opt-in (by adding <code>#[derive(Clone)]</code>), in contrast to the opt-out
behavior in C++ (<code>MyType(const MyType&amp;) = delete;</code>).</p>

<p>This is such a common and useful operation that it’s more interesting to investigate the situations where you shouldn’t
or can’t implement <code>Clone</code>, or where the default <code>derive</code> implementation isn’t appropriate.<a data-primary="Clone trait" data-secondary="where it can't or shouldn't be implemented" data-type="indexterm" id="OEBPS/ch02.html.id763"></a></p>

<ul>
<li>
<p>You <em>shouldn’t</em> implement <code>Clone</code> if the item embodies unique access to some resource (such as an  RAII type;
<a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>), or when there’s another reason to restrict copies (e.g., if the item holds cryptographic key material).</p>
</li>
<li>
<p>You <em>can’t</em> implement <code>Clone</code> if some component of your type is un-<code>Clone</code>able in turn.  Examples include the following:</p>

<ul>
<li>
<p>Fields that are mutable references (<code>&amp;mut T</code>), because the  borrow checker (<a href="#OEBPS/ch03.html.file_borrows_md">Item&nbsp;15</a>) allows only a single
mutable reference at a time.<a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch02.html.id764"></a><a data-primary="MutexGuard type" data-type="indexterm" id="OEBPS/ch02.html.id765"></a></p>
</li>
<li>
<p>Standard library types that fall into the previous category, such as
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> (embodies unique access) or
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> (restricts copies for thread safety).</p>
</li>
</ul>
</li>
<li>
<p>You should <em>manually implement</em> <code>Clone</code> if there is anything about your item that won’t be captured by a (recursive)
field-by-field copy or if there is additional bookkeeping associated with item lifetimes. For example, consider a
type that tracks the number of extant items at runtime for metrics purposes; a manual <code>Clone</code> implementation can
ensure the counter is kept accurate.</p>
</li>
</ul>
</div></section>










<section data-pdf-bookmark="Copy" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id51">
<h3><code>Copy</code></h3>

<p>The  <code>Copy</code> trait has a <a data-primary="Copy trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id766"></a>trivial declaration:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="nb">Copy</code>: <code class="nb">Clone</code> <code class="p">{</code><code class="w"> </code><code class="p">}</code><code class="w"></code></pre>

<p>There are no methods in this trait, meaning that it is a  <em>marker trait</em> (as described in <a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>): it’s
used to indicate some constraint on the type that’s not directly expressed in the type system.<a data-primary="marker traits" data-type="indexterm" id="OEBPS/ch02.html.id767"></a></p>

<p>In the case of <code>Copy</code>, the meaning of this marker is that a bit-for-bit copy of the memory holding an item gives a
correct new item.  Effectively, this trait is a marker that says that a type is a <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Passive_data_structure">“plain old data” (POD) type</a>.</p>

<p>This also means that the <code>Clone</code> trait bound can be slightly confusing: although a <code>Copy</code> type has to implement <code>Clone</code>,
when an instance of the type is copied, the <code>clone()</code> method is <em>not</em> invoked—the compiler builds the new item
without any involvement of user-defined code.<a data-primary="Clone trait" data-secondary="Copy trait implementation of" data-type="indexterm" id="OEBPS/ch02.html.id768"></a><a data-primary="marker traits" data-secondary="standard, affecting copy semantics" data-type="indexterm" id="OEBPS/ch02.html.id769"></a></p>

<p>In contrast to user-defined marker traits (<a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>), <code>Copy</code> has a special significance to the compiler (as do several of the other marker traits in <code>std::marker</code>) over and above being available for trait bounds—it shifts
the compiler from <em>move semantics</em> to <em>copy semantics</em>.<a data-primary="copy semantics" data-type="indexterm" id="OEBPS/ch02.html.id770"></a></p>

<p>With move semantics for the assignment operator, what the right hand giveth, the left hand taketh away:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id771">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Clone)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">KeyId</code><code class="p">(</code><code class="kt">u32</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">k</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">KeyId</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">k2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">k</code><code class="p">;</code><code class="w"> </code><code class="c1">// value moves out of k into k2</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"k = {k:?}"</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0382]: borrow of moved value: `k`
  --&gt; src/main.rs:60:23
   |
58 |         let k = KeyId(42);
   |             - move occurs because `k` has type `main::KeyId`, which does
   |               not implement the `Copy` trait
59 |         let k2 = k; // value moves out of k into k2
   |                  - value moved here
60 |         println!("k = {k:?}");
   |                       ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl`
help: consider cloning the value if the performance cost is acceptable
   |
59 |         let k2 = k.clone(); // value moves out of k into k2
   |                   ++++++++</pre>

<p>With copy semantics, the original item lives on:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Clone, Copy)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">KeyId</code><code class="p">(</code><code class="kt">u32</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">k</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">KeyId</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">k2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">k</code><code class="p">;</code><code class="w"> </code><code class="c1">// value bitwise copied from k to k2</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"k = {k:?}"</code><code class="p">);</code><code class="w"></code></pre>

<p>This makes <code>Copy</code> one of the most important traits to watch out for: it fundamentally changes the behavior of
assignments—including parameters for method invocations.</p>

<p>In this respect, there<a data-primary="C++" data-secondary="copy-constructors" data-type="indexterm" id="OEBPS/ch02.html.id772"></a> are again overlaps with C++’s copy-constructors, but it’s worth emphasizing a key distinction: in
Rust there is no way to get the compiler to silently invoke user-defined code—it’s either explicit (a call to
<code>.clone()</code>) or it’s not user-defined (a bitwise copy).</p>

<p>Because <code>Copy</code> has a <code>Clone</code> trait bound, it’s possible to <code>.clone()</code> any <code>Copy</code>-able item.  <a data-primary="Clippy" data-type="indexterm" id="OEBPS/ch02.html.id773"></a>However, it’s not a good
idea: a bitwise copy will always be faster than invoking a trait method.   Clippy (<a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a>) will warn you about
this:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id774">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">k3</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">k</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">warning: using `clone` on type `KeyId` which implements the `Copy` trait
  --&gt; src/main.rs:79:14
   |
79 |     let k3 = k.clone();
   |              ^^^^^^^^^ help: try removing the `clone` call: `k`
   |</pre>

<p>As with <code>Clone</code>, it’s worth exploring <a data-primary="Copy trait" data-secondary="deciding whether to implement it" data-type="indexterm" id="OEBPS/ch02.html.id775"></a>when you should or should not implement <code>Copy</code>:</p>

<ul>
<li>
<p>The obvious: <em>don’t implement <code>Copy</code> if a bitwise copy doesn’t produce a valid item</em>.  That’s likely to be
the case if <code>Clone</code> needed a manual implementation rather than an automatically <code>derive</code>d implementation.</p>
</li>
<li>
<p>It may be a bad idea to implement <code>Copy</code> if your type is large.  The basic promise of <code>Copy</code> is that a bitwise copy is
valid; however, this often goes hand in hand with an assumption that making the copy is fast.  If that’s not the case,
skipping <code>Copy</code> prevents accidental slow copies.</p>
</li>
<li>
<p>You <em>can’t</em> implement <code>Copy</code> if some component of your type is un-<code>Copy</code>able in turn.</p>
</li>
<li>
<p>If all of the components of your type are <code>Copy</code>able, then it’s usually worth deriving <code>Copy</code>.  <a data-primary="missing copy implementations compiler lint" data-type="indexterm" id="OEBPS/ch02.html.id776"></a>The compiler has an
off-by-default lint
<a class="orm:hideurl" href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-copy-implementations"><code>missing_copy_implementations</code></a>
that points out opportunities for this.</p>
</li>
</ul>
</div></section>










<section data-pdf-bookmark="Default" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id52">
<h3><code>Default</code></h3>

<p>The  <code>Default</code> trait defines a <em>default constructor</em>, via a
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default()</code></a> method. This trait can be
 <code>derive</code>d for user-defined types, provided<a data-primary="Default trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id777"></a><a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch02.html.id778"></a> that all of the subtypes involved have a <code>Default</code> implementation of
their own; if they don’t, you’ll have to implement the trait manually. Continuing the comparison with C++, notice that a
default constructor has to be explicitly triggered—the compiler does not create one automatically.</p>

<p>The <code>Default</code> trait can also be <code>derive</code>d for <code>enum</code> types, as long as there’s a <code>#[default]</code> attribute to give<a data-primary="enums" data-secondary="Default trait derived for" data-type="indexterm" id="OEBPS/ch02.html.id779"></a> the
compiler a hint as to which variant is, well, default:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Default)]</code><code class="w"></code>
<code class="k">enum</code> <code class="nc">IceCreamFlavor</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Chocolate</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">Strawberry</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="cp">#[default]</code><code class="w"></code>
<code class="w">    </code><code class="n">Vanilla</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The most useful aspect of the <code>Default</code> trait is its combination with  <a href="https://oreil.ly/DJW-U"><em>struct update syntax</em></a>.  <a data-primary="Default trait" data-secondary="combination with struct update syntax" data-type="indexterm" id="OEBPS/ch02.html.id780"></a><a data-primary="struct update syntax" data-type="indexterm" id="OEBPS/ch02.html.id781"></a>This syntax allows
<code>struct</code> fields to be initialized by copying or moving their contents from an existing instance of the same <code>struct</code>,
for any fields that aren’t explicitly initialized.  The template to copy from is given at the end of the initialization,
after <code>..</code>, and the <code>Default</code> trait provides an ideal template to use:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Default)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">Color</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">red</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">green</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">blue</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">alpha</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Color</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">red</code>: <code class="mi">128</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="o">..</code><code class="nb">Default</code>::<code class="n">default</code><code class="p">()</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>This makes it much easier to initialize structures with lots of fields, only some of which have nondefault values.<a data-primary="builder pattern" data-type="indexterm" id="OEBPS/ch02.html.id782"></a>
(The  builder pattern, <a href="#OEBPS/ch01.html.file_builders_md">Item 7</a>, may also be appropriate for these situations.)</p>
</div></section>










<section data-pdf-bookmark="PartialEq and Eq" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id53">
<h3><code>PartialEq</code> and <code>Eq</code></h3>

<p>The <code>PartialEq</code> and <code>Eq</code> traits allow you to define equality for user-defined types.<a data-primary="Eq trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id783"></a><a data-primary="equality (==) checks" data-type="indexterm" id="OEBPS/ch02.html.id784"></a> These traits have
special significance because if they’re present, the compiler will automatically use them for equality (<code>==</code>) checks,
similarly to <code>operator==</code> in C++.  The default  <code>derive</code> implementation does this with a recursive field-by-field
comparison.<a data-primary="C++" data-secondary="== operator" data-type="indexterm" id="OEBPS/ch02.html.id785"></a><a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch02.html.id786"></a></p>

<p>The <code>Eq</code> version is just a  marker<a data-primary="marker traits" data-secondary="Eq" data-type="indexterm" id="OEBPS/ch02.html.id787"></a><a data-primary="PartialEq trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id788"></a> trait extension of <code>PartialEq</code> that adds the assumption of
 <em>reflexivity</em>: any type <code>T</code> that claims to support <code>Eq</code> should ensure that <code>x == x</code> is true for any <code>x: T</code>.<a data-primary="reflexivity" data-type="indexterm" id="OEBPS/ch02.html.id789"></a></p>

<p>This is sufficiently odd to immediately raise the question, When wouldn’t <code>x == x</code>?  The primary rationale behind this
split relates to  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">floating point numbers</a>,<sup><a data-type="noteref" href="#OEBPS/ch02.html.id790" id="OEBPS/ch02.html.id790-marker">1</a></sup> and specifically to the special “not a
number” value  NaN (<code>f32::NAN</code> /  <code>f64::NAN</code> in Rust). The floating point specifications require
that nothing compares equal to NaN, <em>including NaN itself</em>; the <code>PartialEq</code> trait is the knock-on effect of this.<a data-primary="NaN (not a number) values" data-type="indexterm" id="OEBPS/ch02.html.id791"></a><a data-primary="floating point types" data-secondary="single-precision format" data-type="indexterm" id="OEBPS/ch02.html.id792"></a><a data-primary="f32 type" data-type="indexterm" id="OEBPS/ch02.html.id793"></a><a data-primary="HashMap type" data-type="indexterm" id="OEBPS/ch02.html.id794"></a><a data-primary="Hash trait" data-type="indexterm" id="OEBPS/ch02.html.id795"></a></p>

<p>For user-defined types that don’t have any float-related peculiarities, you should <em>implement <code>Eq</code> whenever you
implement <code>PartialEq</code></em>.  The full <code>Eq</code> trait is also required if you want to use the type as the key in a
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> (as well as the <code>Hash</code> trait).</p>

<p>You should implement <code>PartialEq</code> manually if your type contains any fields that do not affect the item’s identity,
such as internal caches and other performance optimizations.  (Any manual implementation will also be used for <code>Eq</code> if
it is defined, because <code>Eq</code> is just a marker trait that has no methods of its own.)</p>
</div></section>










<section data-pdf-bookmark="PartialOrd and Ord" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id54">
<h3><code>PartialOrd</code> and <code>Ord</code></h3>

<p>The ordering traits <code>PartialOrd</code> and <code>Ord</code> allow comparisons between two items of a type, returning <code>Less</code>,
<code>Greater</code>, or <code>Equal</code>.  <a data-primary="comparison traits" data-type="indexterm" id="OEBPS/ch02.html.id796"></a><a data-primary="PartialOrd trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id797"></a><a data-primary="Ord trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id798"></a><a data-primary="PartialEq trait" data-secondary="required by PartialOrd" data-type="indexterm" id="OEBPS/ch02.html.id799"></a><a data-primary="Eq trait" data-secondary="required by Ord" data-type="indexterm" id="OEBPS/ch02.html.id800"></a>The traits require equivalent equality traits to be implemented (<code>PartialOrd</code> requires
<code>PartialEq</code>; <code>Ord</code> requires <code>Eq</code>), and the two have to agree with each other (watch out for this with manual
implementations in particular).</p>

<p>As with the equality traits, the comparison traits have special significance because the compiler will automatically use
them for comparison operations (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).</p>

<p>The default implementation produced by  <code>derive</code> compares fields (or <code>enum</code> variants) lexicographically in the order
they’re defined, so if this isn’t correct, you’ll need to implement the traits manually (or reorder the fields).<a data-primary="enums" data-secondary="field comparisons with Ord and PartialOrd" data-type="indexterm" id="OEBPS/ch02.html.id801"></a></p>

<p>Unlike <code>PartialEq</code>, the <code>PartialOrd</code> trait does correspond to a variety of real situations. For example, it could be
used to express a subset relationship among collections:<sup><a data-type="noteref" href="#OEBPS/ch02.html.id802" id="OEBPS/ch02.html.id802-marker">2</a></sup> <code>{1, 2}</code> is a
subset of <code>{1, 2, 4}</code>, but <code>{1, 3}</code> is not a subset of <code>{2, 4}</code>, nor vice versa.<a data-primary="lattice" data-type="indexterm" id="OEBPS/ch02.html.id803"></a></p>

<p>However, even if a partial order does accurately model<a data-primary="PartialOrd trait" data-secondary="unexpected results from" data-type="indexterm" id="OEBPS/ch02.html.id804"></a> the behavior of your type, <em>be wary of implementing just
<code>PartialOrd</code> and not <code>Ord</code></em> (a rare occasion that contradicts the advice in <a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a> to encode behavior in the type
system)—it can lead to surprising results:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id805">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Inherit the `PartialOrd` behavior from `f32`.</code>
<code class="cp">#[derive(PartialOrd, PartialEq)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">Oddity</code><code class="p">(</code><code class="kt">f32</code><code class="p">);</code><code class="w"></code>

<code class="c1">// Input data with NaN values is likely to give unexpected results.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Oddity</code><code class="p">(</code><code class="kt">f32</code>::<code class="n">NAN</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Oddity</code><code class="p">(</code><code class="kt">f32</code>::<code class="n">NAN</code><code class="p">);</code><code class="w"></code>

<code class="c1">// A self-comparison looks like it should always be true, but it may not be.</code>
<code class="k">if</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"This line doesn't get executed!"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="c1">// Programmers are also unlikely to write code that covers all possible</code>
<code class="c1">// comparison arms; if the types involved implemented `Ord`, then the</code>
<code class="c1">// second two arms could be combined.</code>
<code class="k">if</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"y is bigger"</code><code class="p">);</code><code class="w"> </code><code class="c1">// Not hit.</code>
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"x is bigger"</code><code class="p">);</code><code class="w"> </code><code class="c1">// Not hit.</code>
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Neither is bigger"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>
</div></section>










<section data-pdf-bookmark="Hash" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id55">
<h3><code>Hash</code></h3>

<p>The  <code>Hash</code> trait is used to produce a single value that has a high probability of being different for different
items.<a data-primary="Hash trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id806"></a><a data-primary="HashMap type" data-type="indexterm" id="OEBPS/ch02.html.id807"></a><a data-primary="HashSet type" data-type="indexterm" id="OEBPS/ch02.html.id808"></a>  This hash value is used as the basis for hash-bucket–based data structures like
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>HashSet</code></a>; as such, the type of the keys in these
data structures must implement <code>Hash</code> (and <code>Eq</code>).<a data-primary="Eq trait" data-type="indexterm" id="OEBPS/ch02.html.id809"></a></p>

<p>Flipping this around, it’s essential that the “same” items (as per <code>Eq</code>) always produce the same hash: if <code>x == y</code> (via
<code>Eq</code>), then it must always be true that <code>hash(x) == hash(y)</code>.  <em>If you have a manual <code>Eq</code> implementation, check
whether you also need a manual implementation of <code>Hash</code></em> to comply with this requirement.</p>
</div></section>










<section data-pdf-bookmark="Debug and Display" data-type="sect3"><div class="sect3" id="OEBPS/ch02.html.id56">
<h3><code>Debug</code> and <code>Display</code></h3>

<p>The <code>Debug</code> and <code>Display</code> traits allow a type to specify how it should be included in output, for either
normal (<code>{}</code> format argument) or debugging purposes (<code>{:?}</code> format argument), roughly analogous to an <code>operator&lt;&lt;</code>
overload for <code>iostream</code> in C++.<a data-primary="Display trait" data-type="indexterm" id="OEBPS/ch02.html.id810"></a><a data-primary="C++" data-secondary="iostream, operator<< overload" data-type="indexterm" id="OEBPS/ch02.html.id811"></a></p>

<p>The differences <a data-primary="Debug trait" data-secondary="defined" data-type="indexterm" id="OEBPS/ch02.html.id812"></a>between the intents of the two traits go beyond which format specifier is needed, though:</p>

<ul>
<li>
<p><code>Debug</code> can be automatically  derived, <code>Display</code> can only be manually implemented.</p>
</li>
<li>
<p>The layout of <code>Debug</code> output may change between different Rust versions.  If the output will ever be parsed by
other code, use <code>Display</code>.</p>
</li>
<li>
<p><code>Debug</code> is programmer-oriented; <code>Display</code> is user-oriented. A thought experiment that helps with this is to
consider what would happen if the program was
<a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Internationalization_and_localization">localized</a> to a language that the authors don’t
speak—<code>Display</code> is appropriate if the content should be translated, <code>Debug</code> if not.<a data-primary="localization" data-type="indexterm" id="OEBPS/ch02.html.id813"></a><a data-primary="internationalization" data-type="indexterm" id="OEBPS/ch02.html.id814"></a></p>
</li>
</ul>

<p>As a general rule, <em>add an automatically generated <code>Debug</code> implementation for your types</em> unless they contain
sensitive information (personal details, cryptographic material, etc.).  To make this advice easier to comply with, the
Rust compiler includes a
<a class="orm:hideurl" href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#missing-debug-implementations"><code>missing_debug_implementations</code></a>
lint that points out types without <code>Debug</code>.  <a data-primary="missing Debug implementations compiler lint" data-type="indexterm" id="OEBPS/ch02.html.id815"></a>This lint is disabled by default but can be enabled for your code with either of the following:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#![warn(missing_debug_implementations)]</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#![deny(missing_debug_implementations)]</code><code class="w"></code></pre>

<p>If the automatically generated implementation of <code>Debug</code> would emit voluminous amounts of detail, then it may be more
appropriate to include a manual implementation of <code>Debug</code> that summarizes the type’s contents.</p>

<p>Implement <code>Display</code> if your types are designed to be shown to end users in textual output.<a data-primary="traits" data-secondary="common standard traits" data-startref="ix_traitCS" data-type="indexterm" id="OEBPS/ch02.html.id816"></a></p>
</div></section>
</div></section>








<section data-pdf-bookmark="Standard Traits Covered Elsewhere" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id57">
<h2>Standard Traits Covered Elsewhere</h2>

<p>In addition to the common traits described in the previous section, the standard library also includes other standard
traits that are less ubiquitous.<a data-primary="traits" data-secondary="less common standard traits" data-type="indexterm" id="OEBPS/ch02.html.id817"></a>  Of these additional standard traits, the following are the most important, but they are
covered in other Items and so are not covered here in depth:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,   <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>, and   <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></dt>
<dd>
<p>Items implementing<a data-primary="Fn trait" data-type="indexterm" id="OEBPS/ch02.html.id818"></a><a data-primary="FnMut trait" data-type="indexterm" id="OEBPS/ch02.html.id819"></a><a data-primary="FnOnce trait" data-type="indexterm" id="OEBPS/ch02.html.id820"></a><a data-primary="closures" data-secondary="traits representing" data-type="indexterm" id="OEBPS/ch02.html.id821"></a> these traits represent closures
that can be invoked. See <a href="#OEBPS/ch01.html.file_use-types-2_md"><span class="keep-together">Item 2</span></a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a></dt>
<dd>
<p>Items implementing this<a data-primary="Error trait" data-type="indexterm" id="OEBPS/ch02.html.id822"></a> trait represent error
information that can be displayed to users or programmers, and that <em>may</em> hold nested suberror information.  See
<a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a></dt>
<dd>
<p>Items implementing this<a data-primary="Drop trait" data-type="indexterm" id="OEBPS/ch02.html.id823"></a> trait perform processing
when they are destroyed, which is essential for  RAII patterns. See <a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and   <a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a></dt>
<dd>
<p>Items<a data-primary="From trait" data-type="indexterm" id="OEBPS/ch02.html.id824"></a><a data-primary="TryFrom trait" data-type="indexterm" id="OEBPS/ch02.html.id825"></a> implementing these traits can be automatically
created from items of some other type but with a possibility of failure in the latter case. See <a href="#OEBPS/ch01.html.file_casts_md">Item 5</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> and   <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></dt>
<dd>
<p>Items implementing these<a data-primary="Deref trait" data-type="indexterm" id="OEBPS/ch02.html.id826"></a><a data-primary="DerefMut trait" data-type="indexterm" id="OEBPS/ch02.html.id827"></a> traits are
pointer-like objects that can be dereferenced to get access to an inner item. See <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> and friends</dt>
<dd>
<p>Items implementing <a data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch02.html.id828"></a>these traits
represent collections that can be iterated over.  See <a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a></dt>
<dd>
<p>Items implementing this <a data-primary="threading" data-type="indexterm" id="OEBPS/ch02.html.id829"></a><a data-primary="Send trait" data-type="indexterm" id="OEBPS/ch02.html.id830"></a>trait are safe to
transfer between multiple threads. See <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>.</p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a></dt>
<dd>
<p>Items implementing this trait <a data-primary="Sync trait" data-type="indexterm" id="OEBPS/ch02.html.id831"></a>are safe to be
referenced by multiple threads. See <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>.</p>
</dd>
</dl>

<p>None of these traits are <code>derive</code>able.<a data-primary="derive attribute" data-type="indexterm" id="OEBPS/ch02.html.id832"></a></p>
</div></section>








<section data-pdf-bookmark="Operator Overloads" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id58">
<h2>Operator Overloads</h2>

<p>The final category of standard traits relates to operator overloads, where Rust allows various built-in unary and binary
operators<a data-primary="user-defined types" data-secondary="operator overloads for" data-type="indexterm" id="OEBPS/ch02.html.id833"></a> to be overloaded for user-defined types, by implementing various standard traits from the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code> module</a>.  <a data-primary="traits" data-secondary="relating to operator overloads" data-type="indexterm" id="OEBPS/ch02.html.id834"></a><a data-primary="operator overloads" data-type="indexterm" id="OEBPS/ch02.html.id835"></a>These traits are not derivable and are typically needed only
for types that represent “algebraic” objects, where there is a natural interpretation of these operators.</p>

<p>However, experience from C++ has shown that it’s best to <em>avoid overloading operators for unrelated types</em> as
it often leads to code that is hard to maintain and has unexpected performance properties (e.g., <code>x + y</code> silently invokes
an expensive O(N) method).<a data-primary="C++" data-secondary="operator overloads, avoiding for unrelated types" data-type="indexterm" id="OEBPS/ch02.html.id836"></a><a data-primary="Add trait" data-type="indexterm" id="OEBPS/ch02.html.id837"></a><a data-primary="Neg trait" data-type="indexterm" id="OEBPS/ch02.html.id838"></a><a data-primary="Sub trait" data-type="indexterm" id="OEBPS/ch02.html.id839"></a></p>

<p>To comply with the  principle of least astonishment, if you implement any operator overloads, you should <em>implement a coherent set of operator overloads</em>. For example, if <code>x&nbsp;+&nbsp;y</code> has an overload
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>), and <code>-y</code>
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a>) does too, then you should also implement <code>x&nbsp;-&nbsp;y</code>
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a>) and make sure it gives the same answer as <code>x + (-y)</code>.</p>

<p>The items passed to the operator overload traits are moved, which means that non-<code>Copy</code> types will be consumed by
default.  Adding implementations for <code>&amp;'a MyType</code> can help with this but requires more boilerplate to cover all of the
possibilities (e.g., there are 4 = 2 × 2 possibilities for combining reference/non-reference arguments to a binary
operator).</p>
</div></section>








<section data-pdf-bookmark="Summary" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id59">
<h2>Summary</h2>

<p>This item has covered a lot of ground, so some tables that summarize the standard traits that have been touched on are
in order.<a data-primary="traits" data-secondary="common standard traits" data-type="indexterm" id="OEBPS/ch02.html.id840"></a> First, <a data-type="xref" href="#OEBPS/ch02.html.table_2_1">Table&nbsp;2-1</a> covers the traits that this Item covers in depth, all of which can be automatically
 <code>derive</code>d <em>except</em>  <code>Display</code>.</p>
<table id="OEBPS/ch02.html.table_2_1">
	<caption><span class="label">Table 2-1. </span>Common standard traits</caption>
	<thead>
    <tr>
	  <th>Trait</th>
      <th>Compiler use</th>
      <th>Bound</th>
      <th>Methods</th>
    </tr>
	</thead>
	<tbody>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></td>
    <td><code>let y = x;</code></td>
    <td><code>Clone</code></td>
    <td>Marker trait</td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td>
    <td><code>x == y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq"><code>eq</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a></td>
    <td><code>x == y</code></td>
    <td><code>PartialEq</code></td>
    <td>Marker trait</td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td>
    <td><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td>
    <td><code>PartialEq</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><code>partial_cmp</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>Ord</code></a></td>
    <td><code>x &lt; y</code>, <code>x &lt;= y</code>, …</td>
    <td><code>Eq + PartialOrd</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html#tymethod.cmp"><code>cmp</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/hash/trait.Hash.html#tymethod.hash"><code>hash</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></td>
    <td><code>format!("{:?}", x)</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt"><code>fmt</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></td>
    <td><code>format!("{}", x)</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Display.html#tymethod.fmt"><code>fmt</code></a></td>
  </tr>
</tbody>
</table>

<p>The operator <a data-primary="traits" data-secondary="operator overload traits summary" data-type="indexterm" id="OEBPS/ch02.html.id841"></a>overloads are summarized in <a data-type="xref" href="#OEBPS/ch02.html.table_2_2">Table&nbsp;2-2</a>. None of these can be  <code>derive</code>d.<a data-primary="Rem trait" data-type="indexterm" id="OEBPS/ch02.html.id842"></a><a data-primary="AddAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id843"></a><a data-primary="Shl trait" data-type="indexterm" id="OEBPS/ch02.html.id844"></a></p>
<table id="OEBPS/ch02.html.table_2_2">
	<caption><span class="label">Table 2-2. </span>Operator overload traits<sup><a data-type="noteref" href="#OEBPS/ch02.html.id845" id="OEBPS/ch02.html.id845-marker">a</a></sup></caption>
	<thead>
    <tr>
	  <th>Trait</th>
      <th>Compiler use</th>
      <th>Bound</th>
      <th>Methods</th>
    </tr>
	</thead>
	<tbody>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td>
    <td><code>x + y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Add.html#tymethod.add"><code>add</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a></td>
    <td><code>x += y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html#tymethod.add_assign"><code>add_assign</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td>
    <td><code>x &amp; y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html#tymethod.bitand"><code>bitand</code></a><a contenteditable="false" data-primary="BitAnd trait" data-type="indexterm" id="OEBPS/ch02.html.id846"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html"><code>BitAndAssign</code></a></td>
    <td><code>x &amp;= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html#tymethod.bitand_assign"><code>bitand_assign</code></a><a contenteditable="false" data-primary="BitAndAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id847"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td>
    <td><code>x | y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitOr.html#tymethod.bitor"><code>bitor</code></a><a contenteditable="false" data-primary="BitOr trait" data-type="indexterm" id="OEBPS/ch02.html.id848"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html"><code>BitOrAssign</code></a></td>
    <td><code>x |= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html#tymethod.bitor_assign"><code>bitor_assign</code></a><a contenteditable="false" data-primary="BitOrAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id849"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td>
    <td><code>x ^ y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitXor.html#tymethod.bitxor"><code>bitxor</code></a><a contenteditable="false" data-primary="BitXor trait" data-type="indexterm" id="OEBPS/ch02.html.id850"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html"><code>BitXorAssign</code></a></td>
    <td><code>x ^= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html#tymethod.bitxor_assign"><code>bitxor_assign</code></a><a contenteditable="false" data-primary="BitXorAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id851"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td>
    <td><code>x / y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Div.html#tymethod.div"><code>div</code></a><a contenteditable="false" data-primary="Div trait" data-type="indexterm" id="OEBPS/ch02.html.id852"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html"><code>DivAssign</code></a></td>
    <td><code>x /= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html#tymethod.div_assign"><code>div_assign</code></a><a contenteditable="false" data-primary="DivAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id853"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td>
    <td><code>x * y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Mul.html#tymethod.mul"><code>mul</code></a><a contenteditable="false" data-primary="Mul trait" data-type="indexterm" id="OEBPS/ch02.html.id854"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a></td>
    <td><code>x *= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html#tymethod.mul_assign"><code>mul_assign</code></a><a contenteditable="false" data-primary="MulAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id855"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td>
    <td><code>-x</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Neg.html#tymethod.neg"><code>neg</code></a><a contenteditable="false" data-primary="Neg trait" data-type="indexterm" id="OEBPS/ch02.html.id856"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td>
    <td><code>!x</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Not.html#tymethod.not"><code>not</code></a><a contenteditable="false" data-primary="Not trait" data-type="indexterm" id="OEBPS/ch02.html.id857"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td>
    <td><code>x % y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Rem.html#tymethod.rem"><code>rem</code></a><a contenteditable="false" data-primary="Rem trait" data-type="indexterm" id="OEBPS/ch02.html.id858"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html"><code>RemAssign</code></a></td>
    <td><code>x %= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html#tymethod.rem_assign"><code>rem_assign</code></a><a contenteditable="false" data-primary="RemAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id859"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td>
    <td><code>x &lt;&lt; y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Shl.html#tymethod.shl"><code>shl</code></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html"><code>ShlAssign</code></a></td>
    <td><code>x &lt;&lt;= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html#tymethod.shl_assign"><code>shl_assign</code></a><a contenteditable="false" data-primary="ShlAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id860"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td>
    <td><code>x &gt;&gt; y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Shr.html#tymethod.shr"><code>shr</code></a><a contenteditable="false" data-primary="Shr trait" data-type="indexterm" id="OEBPS/ch02.html.id861"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html"><code>ShrAssign</code></a></td>
    <td><code>x &gt;&gt;= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html#tymethod.shr_assign"><code>shr_assign</code></a><a contenteditable="false" data-primary="ShrAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id862"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td>
    <td><code>x - y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Sub.html#tymethod.sub"><code>sub</code></a><a contenteditable="false" data-primary="Sub trait" data-type="indexterm" id="OEBPS/ch02.html.id863"></a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html"><code>SubAssign</code></a></td>
    <td><code>x -= y</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html#tymethod.sub_assign"><code>sub_assign</code></a><a contenteditable="false" data-primary="SubAssign trait" data-type="indexterm" id="OEBPS/ch02.html.id864"></a></td>
  </tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="4"><p data-type="footnote" id="OEBPS/ch02.html.id845"><sup><a href="#OEBPS/ch02.html.id845-marker">a</a></sup> Some of the names here are a little cryptic—e.g., <code>Rem</code> for remainder and <code>Shl</code> for shift left—but the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> documentation makes the intended use clear.</p></td></tr></tbody></table>

<p>For completeness, the standard traits that are covered in other items are included in <a data-type="xref" href="#OEBPS/ch02.html.table_2_3">Table&nbsp;2-3</a>; none of these
traits are  <code>derive</code>able (but <code>Send</code> and <code>Sync</code> may be <a data-primary="Sync trait" data-type="indexterm" id="OEBPS/ch02.html.id865"></a><a data-primary="traits" data-secondary="less common standard traits" data-type="indexterm" id="OEBPS/ch02.html.id866"></a>automatically implemented by the compiler).</p>
<table id="OEBPS/ch02.html.table_2_3">
	<caption><span class="label">Table 2-3. </span>Standard traits described in other Items</caption>
	<thead>
    <tr>
	  <th>Trait</th>
      <th>Compiler use</th>
      <th>Bound</th>
      <th>Methods</th>
      <th>Item</th>
    </tr>
	</thead>
	<tbody>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></td>
    <td><code>x(a)</code></td>
    <td><code>FnMut</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call"><code>call</code></a><a contenteditable="false" data-primary="Fn trait" data-type="indexterm" id="OEBPS/ch02.html.id867"></a></td>
    <td><a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></td>
    <td><code>x(a)</code></td>
    <td><code>FnOnce</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut"><code>call_mut</code></a><a contenteditable="false" data-primary="FnMut trait" data-type="indexterm" id="OEBPS/ch02.html.id868"></a></td>
    <td><a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></td>
    <td><code>x(a)</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once"><code>call_once</code></a><a contenteditable="false" data-primary="FnOnce trait" data-type="indexterm" id="OEBPS/ch02.html.id869"></a></td>
    <td><a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a></td>
    <td></td>
    <td><code>Display + Debug</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>[source]</code></a><a contenteditable="false" data-primary="Error trait" data-type="indexterm" id="OEBPS/ch02.html.id870"></a></td>
    <td><a href="#OEBPS/ch01.html.file_errors_md">Item 4</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.From.html#tymethod.from"><code>from</code></a><a contenteditable="false" data-primary="From trait" data-type="indexterm" id="OEBPS/ch02.html.id871"></a></td>
    <td><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#tymethod.try_from"><code>try_from</code></a><a contenteditable="false" data-primary="TryFrom trait" data-type="indexterm" id="OEBPS/ch02.html.id872"></a></td>
    <td><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.Into.html#tymethod.into"><code>into</code></a><a contenteditable="false" data-primary="Into trait" data-type="indexterm" id="OEBPS/ch02.html.id873"></a></td>
    <td><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#tymethod.try_into"><code>try_into</code></a><a contenteditable="false" data-primary="TryInto trait" data-type="indexterm" id="OEBPS/ch02.html.id874"></a></td>
    <td><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref</code></a><a contenteditable="false" data-primary="AsRef trait" data-type="indexterm" id="OEBPS/ch02.html.id875"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut</code></a><a contenteditable="false" data-primary="AsMut trait" data-type="indexterm" id="OEBPS/ch02.html.id876"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a><a contenteditable="false" data-primary="Borrow trait" data-type="indexterm" id="OEBPS/ch02.html.id877"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a></td>
    <td></td>
    <td><code>Borrow</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a><a contenteditable="false" data-primary="BorrowMut trait" data-type="indexterm" id="OEBPS/ch02.html.id878"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned</code></a><a contenteditable="false" data-primary="ToOwned trait" data-type="indexterm" id="OEBPS/ch02.html.id879"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a></td>
    <td><code>*x</code>, <code>&amp;x</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref</code></a><a contenteditable="false" data-primary="Deref trait" data-type="indexterm" id="OEBPS/ch02.html.id880"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></td>
    <td><code>*x</code>, <code>&amp;mut x</code></td>
    <td><code>Deref</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut"><code>deref_mut</code></a><a contenteditable="false" data-primary="DerefMut trait" data-type="indexterm" id="OEBPS/ch02.html.id881"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a></td>
    <td><code>x[idx]</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a><a contenteditable="false" data-primary="Index trait" data-type="indexterm" id="OEBPS/ch02.html.id882"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></td>
    <td><code>x[idx] = ...</code></td>
    <td><code>Index</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html#tymethod.index_mut"><code>index_mut</code></a><a contenteditable="false" data-primary="IndexMut trait" data-type="indexterm" id="OEBPS/ch02.html.id883"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a></td>
    <td><code>format("{:p}", x)</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html#tymethod.fmt"><code>fmt</code></a><a contenteditable="false" data-primary="Pointer trait" data-type="indexterm" id="OEBPS/ch02.html.id884"></a></td>
    <td><a href="#OEBPS/ch01.html.file_references_md">Item 8</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a><a contenteditable="false" data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch02.html.id885"></a></td>
    <td><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a></td>
    <td><code>for y in x</code></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a><a contenteditable="false" data-primary="IntoIterator trait" data-type="indexterm" id="OEBPS/ch02.html.id886"></a></td>
    <td><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a></td>
    <td></td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html#tymethod.from_iter"><code>from_iter</code></a></td>
    <td><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a></td>
    <td></td>
    <td><code>Iterator</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.size_hint"><code>(size_hint)</code></a><a contenteditable="false" data-primary="ExactSizeIterator" data-type="indexterm" id="OEBPS/ch02.html.id887"></a></td>
    <td><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a></td>
    <td></td>
    <td><code>Iterator</code></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a><a contenteditable="false" data-primary="DoubleEndedIterator" data-type="indexterm" id="OEBPS/ch02.html.id888"></a></td>
    <td><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a></td>
    <td><code>}</code> (end of scope)</td>
    <td></td>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><a contenteditable="false" data-primary="Drop trait" data-type="indexterm" id="OEBPS/ch02.html.id889"></a><a contenteditable="false" data-primary="Sized trait" data-type="indexterm" id="OEBPS/ch02.html.id890"></a></td>
    <td><a href="#OEBPS/ch02.html.file_raii_md">Item 11</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a></td>
    <td></td>
    <td></td>
    <td>Marker trait</td>
    <td><a href="#OEBPS/ch02.html.file_generics_md">Item 12</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a></td>
    <td>cross-thread transfer</td>
    <td></td>
    <td>Marker trait<a contenteditable="false" data-primary="Send trait" data-type="indexterm" id="OEBPS/ch02.html.id891"></a><a contenteditable="false" data-primary="Sync trait" data-type="indexterm" id="OEBPS/ch02.html.id892"></a></td>
    <td><a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a></td>
  </tr>
  <tr>
    <td><a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a></td>
    <td>cross-thread use</td>
    <td></td>
    <td>Marker trait</td>
    <td><a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a></td>
  </tr>
</tbody>
</table>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 11: Implement the Drop trait for RAII patterns" data-type="sect1"><div class="sect1" id="OEBPS/ch02.html.file_raii_md">
<h1>Item 11: Implement the <code>Drop</code> trait for RAII patterns</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>Never send a human to do a machine’s job.</p>
<p data-type="attribution">Agent Smith</p>
</blockquote>

<p>RAII stands<a data-primary="RAII (Resource Acquisition Is Initialization) pattern" data-type="indexterm" id="OEBPS/ch02.html.ix_RAII"></a> for “Resource Acquisition Is Initialization,” which is a programming pattern where the lifetime of a
value is exactly tied to the lifecycle of some additional resource.  The RAII pattern was popularized by the  C++
programming language and is one of C++’s biggest contributions to programming.<a data-primary="C++" data-secondary="RAII patterns in" data-type="indexterm" id="OEBPS/ch02.html.id893"></a><a data-primary="Resource Acquisition Is Initialization" data-see="RAII pattern" data-type="indexterm" id="OEBPS/ch02.html.id894"></a></p>

<p>The correlation between the <a data-primary="lifetime of a value, correlation with lifecycle of a resource" data-type="indexterm" id="OEBPS/ch02.html.id895"></a><a data-primary="constructors" data-type="indexterm" id="OEBPS/ch02.html.id896"></a><a data-primary="destructors" data-type="indexterm" id="OEBPS/ch02.html.id897"></a>lifetime of a value and the lifecycle of a resource is encoded in an RAII type:</p>

<ul>
<li>
<p>The type’s <em>constructor</em> acquires access to some resource</p>
</li>
<li>
<p>The type’s <em>destructor</em> releases access to that resource</p>
</li>
</ul>

<p>The result of this is that the RAII type has an <em>invariant</em>: access to the underlying resource is available if and only
if the item exists.<a data-primary="invariants" data-secondary="RAII types" data-type="indexterm" id="OEBPS/ch02.html.id898"></a> Because the compiler ensures that local variables are destroyed at scope exit, this in turn
means that the underlying resources are also released at scope exit.<sup><a data-type="noteref" href="#OEBPS/ch02.html.id899" id="OEBPS/ch02.html.id899-marker">3</a></sup></p>

<p>This is particularly helpful for <em>maintainability</em>: if a subsequent change to the code alters the control flow, item and
resource lifetimes are still correct.<a data-primary="C++" data-secondary="code that manually locks and unlocks a mutex" data-type="indexterm" id="OEBPS/ch02.html.id900"></a><a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch02.html.id901"></a> To see this, consider some code that manually locks and unlocks a mutex, without
using the RAII pattern; this code is in C++, because Rust’s  <code>Mutex</code> doesn’t allow this kind of error-prone usage!</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code</code>
<code class="k">class</code><code class="w"> </code><code class="nc">ThreadSafeInt</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="n">ThreadSafeInt</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">v</code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">value_</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="n">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">delta</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">mu_</code><code class="p">.</code><code class="n">lock</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ... more code here</code>
<code class="w">    </code><code class="n">value_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ... more code here</code>
<code class="w">    </code><code class="n">mu_</code><code class="p">.</code><code class="n">unlock</code><code class="p">();</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code></pre>

<p>A modification to catch an error condition with an early exit leaves the mutex locked:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id902">
<h1></h1>
<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">add_with_modification</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">delta</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="n">mu_</code><code class="p">.</code><code class="n">lock</code><code class="p">();</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ... more code here</code>
<code class="w">  </code><code class="n">value_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="c1">// Check for overflow.</code>
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">value_</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">MAX_INT</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Oops, forgot to unlock() before exit</code>
<code class="w">    </code><code class="k">return</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ... more code here</code>
<code class="w">  </code><code class="n">mu_</code><code class="p">.</code><code class="n">unlock</code><code class="p">();</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>However, encapsulating the locking behavior into an RAII class:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code (real code should use std::lock_guard or similar)</code>
<code class="k">class</code><code class="w"> </code><code class="nc">MutexLock</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="n">MutexLock</code><code class="p">(</code><code class="n">Mutex</code><code class="o">*</code><code class="w"> </code><code class="n">mu</code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">mu_</code><code class="p">(</code><code class="n">mu</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">mu_</code><code class="o">-&gt;</code><code class="n">lock</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="o">~</code><code class="n">MutexLock</code><code class="p">()</code><code class="w">                   </code><code class="p">{</code><code class="w"> </code><code class="n">mu_</code><code class="o">-&gt;</code><code class="n">unlock</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="n">Mutex</code><code class="o">*</code><code class="w"> </code><code class="n">mu_</code><code class="p">;</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>means the equivalent code is safe for this kind of modification:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">add_with_modification</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">delta</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="n">MutexLock</code><code class="w"> </code><code class="n">with_lock</code><code class="p">(</code><code class="o">&amp;</code><code class="n">mu_</code><code class="p">);</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ... more code here</code>
<code class="w">  </code><code class="n">value_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="c1">// Check for overflow.</code>
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">value_</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">MAX_INT</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">return</code><code class="p">;</code><code class="w"> </code><code class="c1">// Safe, with_lock unlocks on the way out</code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ... more code here</code>
<code class="p">}</code><code class="w"></code></pre>

<p>In C++, RAII patterns were often originally used for memory management, to ensure that manual allocation (<code>new</code>,
<code>malloc()</code>) and deallocation (<code>delete</code>, <code>free()</code>) operations were kept in sync.<a data-primary="memory management, RAII patterns used for" data-type="indexterm" id="OEBPS/ch02.html.id903"></a><a data-primary="C++" data-secondary="RAII patterns used for memory management" data-type="indexterm" id="OEBPS/ch02.html.id904"></a><a data-primary="unique_ptr (C++)" data-type="indexterm" id="OEBPS/ch02.html.id905"></a>  A general version of this memory
management was added to the 
<span class="keep-together">C++</span> standard library in  C++11: the <code>std::unique_ptr&lt;T&gt;</code> type ensures that a single
place has “ownership” of memory but allows a pointer to the memory to be “borrowed” for ephemeral use
(<code>ptr.get()</code>).<a data-primary="memory pointers" data-type="indexterm" id="OEBPS/ch02.html.id906"></a></p>

<p>In Rust, this behavior for memory pointers is built into the language (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>), but the general principle of RAII is
still useful for other kinds of resources.<sup><a data-type="noteref" href="#OEBPS/ch02.html.id907" id="OEBPS/ch02.html.id907-marker">4</a></sup>  <em>Implement  <code>Drop</code> for any
types that hold resources that must be released</em>, such<a data-primary="Drop trait" data-secondary="implementing for types holding resources that must be released" data-type="indexterm" id="OEBPS/ch02.html.id908"></a> as the following:</p>

<ul>
<li>
<p>Access to operating system resources.<a data-primary="operating systems" data-secondary="resources" data-type="indexterm" id="OEBPS/ch02.html.id909"></a>  For Unix-derived systems, this usually means something that holds a <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/File_descriptor"><em>file descriptor</em></a>; failing to release these correctly will hold onto system
resources (and will also eventually lead to the program hitting the per-process file descriptor limit).<a data-primary="file descriptors" data-type="indexterm" id="OEBPS/ch02.html.id910"></a></p>
</li>
<li>
<p>Access to synchronization resources.<a data-primary="Drop trait" data-secondary="implementing for synchronization resources" data-type="indexterm" id="OEBPS/ch02.html.id911"></a>  The standard library already includes memory synchronization primitives, but
other resources (e.g., file locks, database locks, etc.) may need similar encapsulation.<a data-primary="memory synchronization" data-type="indexterm" id="OEBPS/ch02.html.id912"></a></p>
</li>
<li>
<p>Access to raw memory, for <code>unsafe</code> types that deal with low-level memory management (e.g., for foreign function interface [FFI] functionality).<a data-primary="raw memory" data-type="indexterm" id="OEBPS/ch02.html.id913"></a></p>
</li>
</ul>

<p>The most obvious instance of RAII in the Rust standard library is the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> item returned by
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>Mutex::lock()</code></a> operations, which tend to be widely
used for programs that use the  shared-state parallelism discussed in <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>.  <a data-primary="lock method" data-type="indexterm" id="OEBPS/ch02.html.id914"></a><a data-primary="shared-state parallelism" data-type="indexterm" id="OEBPS/ch02.html.id915"></a><a data-primary="MutexGuard type" data-type="indexterm" id="OEBPS/ch02.html.id916"></a><a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch02.html.id917"></a>This is roughly analogous to the
final C++ example shown earlier, but in Rust the <code>MutexGuard</code> item acts as a proxy to the mutex-protected data in addition to
being an RAII item for the held lock:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">sync</code>::<code class="n">Mutex</code><code class="p">;</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">ThreadSafeInt</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">value</code>: <code class="nc">Mutex</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">ThreadSafeInt</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">val</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">value</code>: <code class="nc">Mutex</code>::<code class="n">new</code><code class="p">(</code><code class="n">val</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">delta</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">value</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="n">v</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p><a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a> advises against holding locks for large sections of code; to ensure this, <em>use blocks to restrict the
scope of RAII items</em>.<a data-primary="locks" data-secondary="correct use of" data-type="indexterm" id="OEBPS/ch02.html.id918"></a>  This leads to slightly odd indentation, but it’s worth it for the added safety and lifetime
precision:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">ThreadSafeInt</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_with_extras</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">delta</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// ... more code here that doesn't need the lock</code>
<code class="w">        </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">value</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">            </code><code class="o">*</code><code class="n">v</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">delta</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="c1">// ... more code here that doesn't need the lock</code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Having proselytized the uses of the RAII pattern, an explanation of how to implement it is in order. The
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait allows you to add user-defined behavior to the
destruction of an item.<a data-primary="Drop trait" data-secondary="implementing RAII pattern" data-type="indexterm" id="OEBPS/ch02.html.id919"></a><a data-primary="drop method" data-type="indexterm" id="OEBPS/ch02.html.id920"></a>  This trait has a single method,
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, which the compiler runs just before the
memory holding the item is released:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">MyStruct</code><code class="p">(</code><code class="kt">i32</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">MyStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Dropping {self:?}"</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Code to release resources owned by the item would go here.</code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The <code>drop</code> method is specially reserved for the compiler and can’t be manually invoked:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id921">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="n">x</code><code class="p">.</code><code class="nb">drop</code><code class="p">();</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:70:7
   |
70 |     x.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(x)`</pre>

<p>It’s worth understanding a little bit about the technical details here.  Notice that the <code>Drop::drop</code> method has a
signature of <code>drop(&amp;mut self)</code> rather than <code>drop(self)</code>: it takes a mutable reference to the item rather than having the
item moved into the method.  If <code>Drop::drop</code> acted like a normal method, that would mean the item would still be
available for use afterward—even though all of its internal state has been tidied up and resources released!</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id922">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// If calling `drop` were allowed...</code>
<code class="w">    </code><code class="n">x</code><code class="p">.</code><code class="nb">drop</code><code class="p">();</code><code class="w"> </code><code class="c1">// (does not compile)</code>

<code class="w">    </code><code class="c1">// `x` would still be available afterwards.</code>
<code class="w">    </code><code class="n">x</code><code class="p">.</code><code class="mi">0</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="c1">// Also, what would happen when `x` goes out of scope?</code></pre>
</div></aside>

<p>The compiler suggested a straightforward alternative, which is to call the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>drop()</code></a> function to manually drop an item.  This
function <em>does</em> take a moved argument, and the implementation of <code>drop(_item: T)</code> is just an empty body <code>{ }</code>—so
the moved item is dropped when that scope’s closing brace is reached.</p>

<p>Notice also that the signature of the <code>drop(&amp;mut self)</code> method has no return type, which means that it has no way to
signal failure.<a data-primary="release method" data-type="indexterm" id="OEBPS/ch02.html.id923"></a><a data-primary="Result type" data-secondary="returned by release method" data-type="indexterm" id="OEBPS/ch02.html.id924"></a> If an attempt to release resources can fail, then you should probably have a separate <code>release</code> method
that returns a <code>Result</code>, so it’s possible for users to detect this failure.</p>

<p>Regardless of the technical details, the <code>drop</code> method is nevertheless the key place for implementing RAII patterns; its
implementation is the ideal place to release resources <a data-primary="RAII (Resource Acquisition Is Initialization) pattern" data-startref="ix_RAII" data-type="indexterm" id="OEBPS/ch02.html.id925"></a>associated with an item.</p>
</div></section>






<section data-pdf-bookmark="Item 12: Understand the trade-offs between 
generics and trait objects" data-type="sect1"><div class="sect1" id="OEBPS/ch02.html.file_generics_md">
<h1>Item 12: Understand the trade-offs between 
<span class="keep-together">generics and trait objects</span></h1>

<p><a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a> described the use<a data-primary="generics" data-type="indexterm" id="OEBPS/ch02.html.ix_genrc"></a> of traits to encapsulate behavior in the type system, as a collection of related methods,
and observed that there are two ways to make use of traits: as  <em>trait bounds</em> for  <em>generics</em> or in
 <em>trait objects</em>.  <a data-primary="trait bounds" data-type="indexterm" id="OEBPS/ch02.html.id926"></a><a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch02.html.id927"></a>This Item explores the trade-offs between these two possibilities.</p>

<p>As a running example, consider a trait <a data-primary="traits" data-secondary="example for displaying graphical objects" data-type="indexterm" id="OEBPS/ch02.html.id928"></a>that covers functionality for displaying graphical objects:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Copy, Clone)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">x</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">y</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="cp">#[derive(Debug, Copy, Clone)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Bounds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">bottom_right</code>: <code class="nc">Point</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Calculate the overlap between two rectangles, or `None` if there is no</code>
<code class="sd">/// overlap.</code>
<code class="k">fn</code> <code class="nf">overlap</code><code class="p">(</code><code class="n">a</code>: <code class="nc">Bounds</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="nc">Bounds</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Bounds</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Trait for objects that can be drawn graphically.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Return the bounding rectangle that encompasses the object.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">bounds</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Bounds</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>








<section data-pdf-bookmark="Generics" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id62">
<h2>Generics</h2>

<p>Rust’s generics are<a data-primary="C++" data-secondary="templates" data-type="indexterm" id="OEBPS/ch02.html.id929"></a><a data-primary="templates (C++)" data-type="indexterm" id="OEBPS/ch02.html.id930"></a> roughly equivalent to  C++’s  templates: they allow the programmer to write
code that works for some arbitrary type <code>T</code>, and specific uses of the generic code are generated at compile time—a
process known as  <em>monomorphization</em> in Rust, and <em>template instantiation</em> in C++.  Unlike C++, Rust explicitly
encodes the expectations for the type <code>T</code> in the type system, in the form of trait bounds for the generic.<a data-primary="monomorphization (generics)" data-type="indexterm" id="OEBPS/ch02.html.id931"></a></p>

<p>For <a data-primary="generics" data-secondary="generic functions" data-type="indexterm" id="OEBPS/ch02.html.id932"></a><a data-primary="bounds method" data-type="indexterm" id="OEBPS/ch02.html.id933"></a><a data-primary="Draw trait" data-type="indexterm" id="OEBPS/ch02.html.id934"></a>the example, a generic function that uses the trait’s <code>bounds()</code> method has an explicit <code>Draw</code> trait bound:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Indicate whether an object is on-screen.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">on_screen</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code>
<code class="nc">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="nc">Draw</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">()).</code><code class="n">is_some</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This can also be<a data-primary="trait bounds" data-type="indexterm" id="OEBPS/ch02.html.id935"></a> written more compactly by putting the trait bound after the generic parameter:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">on_screen</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">Draw</code><code class="o">&gt;</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">()).</code><code class="n">is_some</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>or by<a data-primary="impl Trait" data-type="indexterm" id="OEBPS/ch02.html.id936"></a> using <code>impl Trait</code> as the type of the argument:<sup><a data-type="noteref" href="#OEBPS/ch02.html.id937" id="OEBPS/ch02.html.id937-marker">5</a></sup></p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">on_screen</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">impl</code><code class="w"> </code><code class="n">Draw</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">()).</code><code class="n">is_some</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If a type implements the trait:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Clone)]</code><code class="w"> </code><code class="c1">// no `Debug`</code>
<code class="k">struct</code> <code class="nc">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">bounds</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Bounds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">Bounds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">top_left</code>: <code class="nc">self</code><code class="p">.</code><code class="n">top_left</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">bottom_right</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="n">x</code>: <code class="nc">self</code><code class="p">.</code><code class="n">top_left</code><code class="p">.</code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">size</code><code class="p">,</code><code class="w"></code>
<code class="w">                </code><code class="n">y</code>: <code class="nc">self</code><code class="p">.</code><code class="n">top_left</code><code class="p">.</code><code class="n">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">size</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="p">},</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>then instances of that type can be passed to the generic function, monomorphizing it to produce code that’s specific to
one particular type:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="mi">2</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="c1">// Calls `on_screen::&lt;Square&gt;(&amp;Square) -&gt; bool`</code>
<code class="kd">let</code><code class="w"> </code><code class="n">visible</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">on_screen</code><code class="p">(</code><code class="o">&amp;</code><code class="n">square</code><code class="p">);</code><code class="w"></code></pre>

<p>If the same generic function is used with a different type that implements the relevant trait bound:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">center</code>: <code class="nc">Point</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">radius</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">bounds</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Bounds</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// ...</code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>then different monomorphized code is used:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">circle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">center</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">4</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">radius</code>: <code class="mi">1</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="c1">// Calls `on_screen::&lt;Circle&gt;(&amp;Circle) -&gt; bool`</code>
<code class="kd">let</code><code class="w"> </code><code class="n">visible</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">on_screen</code><code class="p">(</code><code class="o">&amp;</code><code class="n">circle</code><code class="p">);</code><code class="w"></code></pre>

<p>In other words, the programmer writes a single generic function, but the compiler outputs a different monomorphized
version of that function for every different type that the function is invoked with.<a data-primary="monomorphization (generics)" data-secondary="different monomorphized function for each type called with" data-type="indexterm" id="OEBPS/ch02.html.id938"></a></p>
</div></section>








<section data-pdf-bookmark="Trait Objects" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id63">
<h2>Trait Objects</h2>

<p>In <a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch02.html.id939"></a><a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch02.html.id940"></a>comparison, trait objects are  fat pointers (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>) that combine a pointer to the underlying concrete item
with a pointer <a data-primary="vtable" data-type="indexterm" id="OEBPS/ch02.html.id941"></a><a data-primary="function pointers" data-secondary="for all trait implementation's methods" data-secondary-sortas="all" data-type="indexterm" id="OEBPS/ch02.html.id942"></a>to a  vtable that in turn holds  function pointers for all of the trait implementation’s
methods, as depicted in <a data-type="xref" href="#OEBPS/ch02.html.fig_2_1">Figure&nbsp;2-1</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="mi">2</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch02.html.fig_2_1">
<img alt="The diagram shows a stack layout on the left, with three entries grouped together and labelled square at the top. The entries inside this group are three boxes representing integers, two for the x and y components of top_left (with values 1 and 2 respectively), and one for the size (value 2). Below this in the stack is a group of two boxes labelled draw; the top box has an arrow that links to the square item on the stack, the bottom box has an arrow that links to the right hand side of the diagram.  On the right is a rectangle showing the vtable of Draw for a Square item, with a single entry labelled bounds which points to a box representing the code of Square::bounds()." src="data:image/png;base64,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5s2DLawQtbe3f+UrX3E4HI2NjaywAAAAAABkh7ihuPh8vnA4XFNTk/ppXV1dTU1NVVVVLpfL7/fnpzYAAAAAgGmU6F0A8s3hcIRCoUAg0NjY2NXVlfrJkUjE7/f7fL4Uzzn91jHhpec0rTGV028dkx5f+aD71Ty+9TBdeb9bfmigyhXeCO4+I/stFLgrH/T/2PN8rQ6TcS9141Zumj9SAACAQjDi1q1betcAfcRiMb/f7/f74/F4iqfV19cHAgHp0O12t7e357w4ACh6R48edbvd+tYwYsSIpON5qC0UCtXW1ib9Ev90AQDAEFhMUbxsNpvYoGHDhg0pGjp4PJ58VpWmkXeM0ruELBm3csHIxVN5/lE5AABAkSNuKHZi6BCLxXbt2uV0OhVftVqthRk3XP/4mt4lZMm4lQtGLp7K84/KAQAAihy9G/BnXq/X6/WGw+FAIBAMBsW2DunMlbXb7Q6HI9flAYC5sU4NAACYDHEDBhC3ovD7/WLukE7c4PV6Gxsbc14ZAJjaYF0SAAAADIq4AcmxBSYAAAAAIGv0bgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbgAAAAAAABojbsCgYrFYNBrVuwoAAAAAgPGU6F0ACkssFgsGg+FwOBQKRSKRmpqaUCikd1EAAAAAAIMhboAgCEI4HA4EAmLEoBjXqyQAAAAAgHERNxQ1MWUIBoNdXV1JnxCPx6PRqMPhyG9dAAAAAABjo3dDMYrFYoFAwOVy3XfffVu2bBksaxCxmAIAAAAAkClmNxSXaDTq9/sDgUA8Hk/zJaynAAAAAABk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">
<h6><span class="label">Figure 2-1. </span>Trait object layout, with pointers to concrete item and vtable</h6>
</div></figure>

<p>This means that a function that accepts a trait object doesn’t need to be generic and doesn’t need monomorphization:
the programmer writes a function using trait<a data-primary="functions" data-secondary="using trait objects" data-type="indexterm" id="OEBPS/ch02.html.id943"></a> objects, and the compiler outputs only a single version of that function,
which can accept trait objects that come from multiple input types:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Indicate whether an object is on-screen.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">on_screen</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Draw</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">()).</code><code class="n">is_some</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Calls `on_screen(&amp;dyn Draw) -&gt; bool`.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">visible</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">on_screen</code><code class="p">(</code><code class="o">&amp;</code><code class="n">square</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Also calls `on_screen(&amp;dyn Draw) -&gt; bool`.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">visible</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">on_screen</code><code class="p">(</code><code class="o">&amp;</code><code class="n">circle</code><code class="p">);</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Basic Comparisons" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id64">
<h2>Basic Comparisons</h2>

<p>These basic facts already allow some <a data-primary="generics" data-secondary="versus trait objects" data-secondary-sortas="trait" data-type="indexterm" id="OEBPS/ch02.html.id944"></a><a data-primary="trait objects" data-secondary="generics versus" data-type="indexterm" id="OEBPS/ch02.html.id945"></a>immediate comparisons between the two 
<span class="keep-together">possibilities</span>:</p>

<ul>
<li>
<p>Generics are likely to lead to bigger code sizes, because the compiler generates a fresh copy (<code>on_screen::&lt;T&gt;(&amp;T)</code>)
of the code for every type <code>T</code> that uses the generic version of the <code>on_screen</code> function. In contrast, the trait
object version (<code>on_screen(&amp;dyn T)</code>) of the function needs only a single instance.</p>
</li>
<li>
<p>Invoking a trait method from a generic will generally be ever-so-slightly faster than invoking it
from code that uses a trait
object, because the latter needs to perform two dereferences to find the location of the code (trait object to vtable,
vtable to implementation location).</p>
</li>
<li>
<p>Compile times for generics are likely to be longer, as the compiler is building more code and the  linker has
more work to do to fold duplicates.<a data-primary="linker" data-type="indexterm" id="OEBPS/ch02.html.id946"></a></p>
</li>
</ul>

<p>In most situations, these aren’t significant differences—you should use optimization-related concerns as a
primary decision driver only if you’ve measured the impact and found that it has a genuine effect (a speed bottleneck or a
problematic occupancy increase).</p>

<p>A more significant difference is that generic<a data-primary="generics" data-secondary="trait bounds type parameter implementing multiple traits" data-type="indexterm" id="OEBPS/ch02.html.id947"></a> trait bounds can be used to conditionally make different functionality
available, depending on whether the type parameter implements <em>multiple</em> traits:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// The `area` function is available for all containers holding things</code>
<code class="c1">// that implement `Draw`.</code>
<code class="k">fn</code> <code class="nf">area</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code>
<code class="nc">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="nc">Draw</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bounds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="n">bottom_right</code><code class="p">.</code><code class="n">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="n">top_left</code><code class="p">.</code><code class="n">x</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="w"> </code><code class="p">(</code><code class="n">bounds</code><code class="p">.</code><code class="n">bottom_right</code><code class="p">.</code><code class="n">y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">bounds</code><code class="p">.</code><code class="n">top_left</code><code class="p">.</code><code class="n">y</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="c1">// The `show` method is available only if `Debug` is also implemented.</code>
<code class="k">fn</code> <code class="nf">show</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"></code>
<code class="k">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="nc">Debug</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">Draw</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"{:?} has bounds {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">,</code><code class="w"> </code><code class="n">draw</code><code class="p">.</code><code class="n">bounds</code><code class="p">());</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="mi">2</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">circle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Circle</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">center</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">4</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">radius</code>: <code class="mi">1</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>

<code class="c1">// Both `Square` and `Circle` implement `Draw`.</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"area(square) = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">area</code><code class="p">(</code><code class="o">&amp;</code><code class="n">square</code><code class="p">));</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"area(circle) = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">area</code><code class="p">(</code><code class="o">&amp;</code><code class="n">circle</code><code class="p">));</code><code class="w"></code>

<code class="c1">// `Circle` implements `Debug`.</code>
<code class="n">show</code><code class="p">(</code><code class="o">&amp;</code><code class="n">circle</code><code class="p">);</code><code class="w"></code>

<code class="c1">// `Square` does not implement `Debug`, so this wouldn't compile:</code>
<code class="c1">// show(&amp;square);</code></pre>

<p>A trait object <a data-primary="trait objects" data-secondary="encoding implementation vtable for only single trait" data-type="indexterm" id="OEBPS/ch02.html.id948"></a>encodes the implementation vtable only for a single trait, so doing something equivalent is much more
awkward.<a data-primary="DebugDraw trait" data-type="indexterm" id="OEBPS/ch02.html.id949"></a><a data-primary="blanket trait implementations" data-type="indexterm" id="OEBPS/ch02.html.id950"></a> For example, a combination <code>DebugDraw</code> trait could be defined for the <code>show()</code> case, together with a
blanket implementation to make life easier:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">trait</code><code class="w"> </code><code class="n">DebugDraw</code>: <code class="nc">Debug</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="sd">/// Blanket implementation applies whenever the individual traits</code>
<code class="sd">/// are implemented.</code>
<code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="nc">Debug</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">Draw</code><code class="o">&gt;</code><code class="w"> </code><code class="n">DebugDraw</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{}</code><code class="w"></code></pre>

<p>However, if there are multiple combinations of distinct traits, it’s clear that the combinatorics of this
approach rapidly become unwieldy.</p>
</div></section>








<section class="pagebreak-before less_space" data-pdf-bookmark="More Trait Bounds" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id65">
<h2>More Trait Bounds</h2>

<p>In addition to <a data-primary="trait bounds" data-secondary="more uses for" data-type="indexterm" id="OEBPS/ch02.html.id951"></a>using  trait bounds to restrict what type parameters are acceptable for a generic function, you
can also apply<a data-primary="Shape trait" data-secondary="requirement for Draw implementation" data-type="indexterm" id="OEBPS/ch02.html.id952"></a> them to trait definitions themselves:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Anything that implements `Shape` must also implement `Draw`.</code>
<code class="k">trait</code><code class="w"> </code><code class="n">Shape</code>: <code class="nc">Draw</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Render that portion of the shape that falls within `bounds`.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">render_in</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code>: <code class="nc">Bounds</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="sd">/// Render the shape.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">render</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Default implementation renders that portion of the shape</code>
<code class="w">        </code><code class="c1">// that falls within the screen area.</code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">visible</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">bounds</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">render_in</code><code class="p">(</code><code class="n">visible</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>In this example, the <code>render()</code> method’s  <a data-primary="render method" data-type="indexterm" id="OEBPS/ch02.html.id953"></a><a data-primary="Draw trait" data-type="indexterm" id="OEBPS/ch02.html.id954"></a>default implementation (<a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>) makes use of the trait bound, relying
on the availability of the <code>bounds()</code> method from <code>Draw</code>.</p>

<p>Programmers<a data-primary="inheritance, trait bounds versus" data-type="indexterm" id="OEBPS/ch02.html.id955"></a> coming from object-oriented languages often confuse trait bounds with inheritance, under the mistaken
impression that a trait bound like this means that a <code>Shape</code> <em>is-a</em> <code>Draw</code>.  That’s not the case: the relationship
between the two types is better expressed as <code>Shape</code> <em>also-implements</em> <code>Draw</code>.<a data-primary="also-implements" data-type="indexterm" id="OEBPS/ch02.html.id956"></a></p>

<p>Under the covers, trait objects<a data-primary="trait objects" data-secondary="for traits having trait bounds" data-secondary-sortas="traits" data-type="indexterm" id="OEBPS/ch02.html.id957"></a> for traits that have trait bounds:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="mi">2</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">shape</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code></pre>

<p>have a single combined  vtable that includes the methods of the top-level trait, plus the methods of all of the
trait bounds.<a data-primary="Shape trait" data-secondary="vtable for" data-type="indexterm" id="OEBPS/ch02.html.id958"></a><a data-primary="Draw trait" data-secondary="vtable for" data-type="indexterm" id="OEBPS/ch02.html.id959"></a><a data-primary="vtable" data-secondary="trait objects for trait bounds" data-type="indexterm" id="OEBPS/ch02.html.id960"></a>  This is shown in <a data-type="xref" href="#OEBPS/ch02.html.fig_2_2">Figure&nbsp;2-2</a>: the vtable for <code>Shape</code> includes the <code>bounds</code> method from the <code>Draw</code> trait,
as well as the two methods from the <code>Shape</code> trait itself.</p>

<p>At the time of writing (and as of Rust 1.70), this <a data-primary="trait objects" data-secondary="no conversions between related trait objects" data-type="indexterm" id="OEBPS/ch02.html.id961"></a>means that there is no way to “upcast” from <code>Shape</code> to
<code>Draw</code>, because the (pure) <code>Draw</code> vtable can’t be recovered at runtime; there is no way to convert between related
trait objects, which in turn means there is no  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution</a>.  <a data-primary="Liskov substitution" data-type="indexterm" id="OEBPS/ch02.html.id962"></a>However, this is likely to change in
later versions of Rust—see <a href="#OEBPS/ch03.html.file_reflection_md">Item 19</a> for more on this.</p>

<figure><div class="figure" id="OEBPS/ch02.html.fig_2_2">
<img alt="The diagram shows a stack layout on the left, and on the right are rectangles representing vtables and code methods. The stack layout includes three items; at the top is a composite item labeled square, with contents being a top_left.x value of 1, a top_left.y value of 2 and a size value of 2. The middle stack item is a trait object, containing an item pointer that links to the square item on the stack, and a vtable pointer that links to a Draw for Square vtable on the right hand side of the diagram.  This vtable has a single content marked bounds, pointing to a rectangle representing the code of Square::bounds().  The bottom stack item is also a trait object, containing an item pointer that also links to the square item on the stack, but whose vtable pointer links to a Shape for Square vtable on the right hand side of the diagram.  This vtable has three contents, labelled render_in, render and bounds.  Each of these vtable contents has a link to a different rectangle, representing the code for Square::render_in(), Shape::render() and Square::bounds() respectively.  The rectangle representing Square::bounds() therefore has two arrows leading to it, one from each of the vtables." src="data:image/png;base64,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">
<h6><span class="label">Figure 2-2. </span>Trait objects for trait bounds, with distinct vtables for <code>Draw</code> and <code>Shape</code></h6>
</div></figure>

<p>Repeating the same point in different words, a <a data-primary="Shape trait" data-secondary="methods accepting, Draw and" data-type="indexterm" id="OEBPS/ch02.html.id963"></a><a data-primary="Draw trait" data-secondary="methods accepting Shape and" data-type="indexterm" id="OEBPS/ch02.html.id964"></a>method that accepts a <code>Shape</code> trait object has the following characteristics:</p>

<ul>
<li>
<p>It <em>can</em> make use of methods from <code>Draw</code> (because <code>Shape</code> also-implements <code>Draw</code>, and because the relevant
function pointers are present in the <code>Shape</code> vtable).</p>
</li>
<li>
<p>It <em>cannot</em> (yet) pass the trait object onto another method that expects a <code>Draw</code> trait object (because <code>Shape</code> is-not
<code>Draw</code>, and because the <code>Draw</code> vtable isn’t available).</p>
</li>
</ul>

<p>In contrast, a<a data-primary="generics" data-secondary="generic method accepting items implementing Shape" data-type="indexterm" id="OEBPS/ch02.html.id965"></a> generic method that accepts items that implement <code>Shape</code> has these 
<span class="keep-together">characteristics</span>:</p>

<ul>
<li>
<p>It <em>can</em> use methods from <code>Draw</code>.</p>
</li>
<li>
<p>It <em>can</em> pass the item on to another generic method that has a <code>Draw</code> trait bound, because the trait bound is
monomorphized at compile time to use the <code>Draw</code> methods of the concrete type.</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Trait Object Safety" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id66">
<h2>Trait Object Safety</h2>

<p>Another restriction on trait objects is the requirement for  <a href="https://oreil.ly/gaq4l"><em>object safety</em></a>: only traits that comply with the
following two <a data-primary="trait objects" data-secondary="safety" data-type="indexterm" id="OEBPS/ch02.html.id966"></a><a data-primary="object safety" data-type="indexterm" id="OEBPS/ch02.html.id967"></a>rules can be used as trait objects:</p>

<ul>
<li>
<p>The trait’s methods must not be generic.</p>
</li>
<li>
<p>The trait’s methods must not involve a type that includes  <code>Self</code>, except for the  receiver (the object on
which the method is invoked).<a data-primary="Self type" data-secondary="trait object safety and" data-type="indexterm" id="OEBPS/ch02.html.id968"></a><a data-primary="generics" data-secondary="generic methods" data-type="indexterm" id="OEBPS/ch02.html.id969"></a></p>
</li>
</ul>

<p>The first restriction is easy to understand: a generic method <code>f</code> is really an infinite set of methods, potentially
encompassing <code>f::&lt;i16&gt;</code>, <code>f::&lt;i32&gt;</code>, <code>f::&lt;i64&gt;</code>, <code>f::&lt;u8&gt;</code>, etc. The trait object’s vtable, on the other hand, is
very much a finite collection of function pointers, and so it’s not possible to fit the infinite set of monomorphized
implementations into it.<a data-primary="vtable" data-secondary="trait object" data-type="indexterm" id="OEBPS/ch02.html.id970"></a></p>

<p>The second restriction is a little bit more subtle but tends to be the restriction <a data-primary="Clone trait" data-secondary="traits that impose Clone trait bounds" data-type="indexterm" id="OEBPS/ch02.html.id971"></a>that’s hit more often in
practice—traits that impose <code>Copy</code> or <code>Clone</code>  trait bounds (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>) immediately fall under
this rule, because they return <code>Self</code>. To see why it’s disallowed, consider code that has a trait object in its hands;
what happens if that code calls (say) <code>let y = x.clone()</code>? The calling code needs to reserve enough space for <code>y</code> on the
stack, but it has no idea of the size of <code>y</code> because <code>Self</code> is an arbitrary type.<a data-primary="Box type" data-type="indexterm" id="OEBPS/ch02.html.id972"></a>  As a result, return types that mention <code>Self</code> lead to a trait that is not object safe.<sup><a data-type="noteref" href="#OEBPS/ch02.html.id973" id="OEBPS/ch02.html.id973-marker">6</a></sup></p>

<p>There is an exception to this second restriction.  A method returning some <code>Self</code>-related type does not affect object
safety if <code>Self</code> comes with an explicit restriction to types whose  size is known at compile time,
indicated by the <code>Sized</code>  marker trait <a data-primary="Sized trait" data-type="indexterm" id="OEBPS/ch02.html.id974"></a><a data-primary="Self type" data-secondary="object safety of types with sizes known at compile time" data-type="indexterm" id="OEBPS/ch02.html.id975"></a>as a trait bound:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// A `Stamp` can be copied and drawn multiple times.</code>
<code class="k">trait</code><code class="w"> </code><code class="n">Stamp</code>: <code class="nc">Draw</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">make_copy</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"></code>
<code class="w">    </code><code class="k">where</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code>: <code class="nb">Sized</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">top_left</code>: <code class="nc">Point</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code>: <code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="mi">2</code><code class="w"> </code><code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="n">size</code>: <code class="mi">2</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>

<code class="c1">// `Square` implements `Stamp`, so it can call `make_copy()`.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">square</code><code class="p">.</code><code class="n">make_copy</code><code class="p">();</code><code class="w"></code>

<code class="c1">// Because the `Self`-returning method has a `Sized` trait bound,</code>
<code class="c1">// creating a `Stamp` trait object is possible.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">stamp</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Stamp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code></pre>

<p>This trait bound means that the method can’t be used with trait objects anyway, because trait objects refer to something
that’s of unknown size (<code>dyn Trait</code>), and so the method is irrelevant for object safety:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch02.html.id976">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="c1">// However, the method can't be invoked via a trait object.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">copy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">stamp</code><code class="p">.</code><code class="n">make_copy</code><code class="p">();</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">error: the `make_copy` method cannot be invoked on a trait object
   --&gt; src/main.rs:397:22
    |
353 |         Self: Sized;
    |               ----- this has a `Sized` requirement
...
397 |     let copy = stamp.make_copy();
    |                      ^^^^^^^^^</pre>
</div></aside>
</div></section>








<section data-pdf-bookmark="Trade-Offs" data-type="sect2"><div class="sect2" id="OEBPS/ch02.html.id67">
<h2>Trade-Offs</h2>

<p>The balance of factors so far suggests that you should <em>prefer generics to trait objects</em>, but there are
situations where trait objects are the right tool for the job.<a data-primary="trait objects" data-secondary="trade-offs between generics and" data-type="indexterm" id="OEBPS/ch02.html.id977"></a><a data-primary="generics" data-secondary="trade-offs with trait objects" data-type="indexterm" id="OEBPS/ch02.html.id978"></a></p>

<p>The first is a practical consideration: if generated code size or compilation time is a concern, then trait objects will
perform better (as described earlier in this Item).</p>

<p>A more <a data-primary="type erasure" data-type="indexterm" id="OEBPS/ch02.html.id979"></a>theoretical aspect that leads toward trait objects is that they fundamentally involve  <em>type erasure</em>:
information about the concrete type is lost in the conversion to a trait object.  This can be a downside (see <a href="#OEBPS/ch03.html.file_reflection_md">Item 19</a>),
but it can also be useful because it allows for collections of heterogeneous objects—because the code <em>just</em>
relies on the methods of the trait, it can invoke and combine the methods of items that have different concrete types.<a data-primary="object-oriented programming" data-secondary="rendering a list of shapes" data-type="indexterm" id="OEBPS/ch02.html.id980"></a><a data-primary="loops" data-secondary="rendering a list of shapes, OO example" data-type="indexterm" id="OEBPS/ch02.html.id981"></a><a data-primary="shapes, rendering in OO example" data-type="indexterm" id="OEBPS/ch02.html.id982"></a></p>

<p>The traditional  OO example of rendering a list of shapes is one example of this: the same
<code>render()</code> method could be used for squares, circles, ellipses, and stars in the same loop:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">shapes</code>: <code class="nb">Vec</code><code class="o">&lt;&amp;</code><code class="k">dyn</code><code class="w"> </code><code class="n">Shape</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="o">&amp;</code><code class="n">square</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">circle</code><code class="p">];</code><code class="w"></code>
<code class="k">for</code><code class="w"> </code><code class="n">shape</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">shape</code><code class="p">.</code><code class="n">render</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p class="pagebreak_before less_space">A much more obscure potential advantage for trait objects is when the available types are not known at compile time.  If
new code is dynamically loaded at runtime (e.g., via <a class="orm:hideurl" href="https://man7.org/linux/man-pages/man3/dlopen.3.html"><code>dlopen(3)</code></a>),
then items that implement traits in the new code can be invoked only via a trait object, because there’s no source code
to monomorphize over.<a data-primary="generics" data-startref="ix_genrc" data-type="indexterm" id="OEBPS/ch02.html.id983"></a></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 13: Use default implementations 
to minimize required trait methods" data-type="sect1"><div class="sect1" id="OEBPS/ch02.html.file_default-impl_md">
<h1>Item 13: Use default implementations 
<span class="keep-together">to minimize required trait methods</span></h1>

<p>The designer of a trait has two different audiences to consider: the programmers who will be <em>implementing</em> the trait and
those who will be <em>using</em> the trait.<a data-primary="traits" data-secondary="using default implementations to minimize required trait methods" data-type="indexterm" id="OEBPS/ch02.html.id984"></a><a data-primary="default implementations" data-type="indexterm" id="OEBPS/ch02.html.id985"></a>  These two audiences lead to a degree of tension in the trait design:</p>

<ul>
<li>
<p>To make the implementor’s life easier, it’s better for a trait to have the absolute minimum number of methods to
achieve its purpose.</p>
</li>
<li>
<p>To make the user’s life more convenient, it’s helpful to provide a range of variant methods that cover all of the
common ways that the trait might be used.</p>
</li>
</ul>

<p>This tension can be balanced by including the wider range of methods that makes the user’s life easier, but with
 <em>default implementations</em> provided for any methods that can be built from other, more
primitive, operations on the interface.<a data-primary="ExactSizeIterator" data-type="indexterm" id="OEBPS/ch02.html.id986"></a><a data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch02.html.id987"></a></p>

<p>A simple example of this is the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.is_empty"><code>is_empty()</code></a> method for an
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a>, which is an <code>Iterator</code>
that knows how many things it is iterating over.<sup><a data-type="noteref" href="#OEBPS/ch02.html.id988" id="OEBPS/ch02.html.id988-marker">7</a></sup>  This method has a default implementation that relies on the
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len"><code>len()</code></a> trait method:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">is_empty</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The existence of a default implementation is just that: a default.  If an implementation of the trait has a different
way of determining whether the iterator is empty, it can replace the default <code>is_empty()</code> with its own.<a data-primary="is_empty method" data-type="indexterm" id="OEBPS/ch02.html.id989"></a></p>

<p>This approach leads to trait definitions that have a small number of  <em>required methods</em>, plus a
much larger number of default-implemented methods.<a data-primary="trait methods with default implementations" data-type="indexterm" id="OEBPS/ch02.html.id990"></a>  An implementor for the trait has to implement only the former and
gets all of the latter for free.<a data-primary="next method" data-type="indexterm" id="OEBPS/ch02.html.id991"></a><a data-primary="Iterator trait" data-secondary="single required method and default method implementations" data-type="indexterm" id="OEBPS/ch02.html.id992"></a></p>

<p>It’s also an approach that is widely followed by the Rust standard library; perhaps the best example there is the
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait, which has a single required method
(<a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next()</code></a>) but includes a panoply of
pre-provided methods (<a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a>), over 50 at the time of 
<span class="keep-together">writing</span>.</p>

<p>Trait methods can impose  <em>trait bounds</em>, indicating <a data-primary="trait bounds" data-secondary="trait methods imposing" data-type="indexterm" id="OEBPS/ch02.html.id993"></a>that a method is only available if the types involved
implement particular traits.  The  <code>Iterator</code> trait also shows that this is useful in combination with default
method implementations.<a data-primary="cloned method" data-type="indexterm" id="OEBPS/ch02.html.id994"></a>  For example, the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>cloned()</code></a> iterator method has a
trait bound and a default implementation:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">cloned</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Cloned</code><code class="o">&lt;</code><code class="bp">Self</code><code class="o">&gt;</code><code class="w"></code>
<code class="k">where</code><code class="w"></code>
<code class="w">    </code><code class="n">T</code>: <code class="o">'</code><code class="na">a</code> <code class="o">+</code><code class="w"> </code><code class="nb">Clone</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="bp">Self</code>: <code class="nb">Sized</code> <code class="o">+</code><code class="w"> </code><code class="nb">Iterator</code><code class="o">&lt;</code><code class="n">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;'</code><code class="na">a</code><code class="w"> </code><code class="n">T</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Cloned</code>::<code class="n">new</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>In other words, the <code>cloned()</code> method is available only if the underlying <code>Item</code> type implements
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>; when it does, the implementation is automatically
available.<a data-primary="Clone trait" data-type="indexterm" id="OEBPS/ch02.html.id995"></a></p>

<p>The final observation about trait methods with default implementations is that new ones can <em>usually</em> be safely added to
a trait even after an initial version of the trait is released.<a data-primary="backward compatibility" data-type="indexterm" id="OEBPS/ch02.html.id996"></a>  An addition like this preserves
backward compatibility (see <a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) for users and implementors of the trait, as long as the
new method name does not clash with the name of a method<a data-primary="concrete methods" data-type="indexterm" id="OEBPS/ch02.html.id997"></a> from some other trait that the type implements.<sup><a data-type="noteref" href="#OEBPS/ch02.html.id998" id="OEBPS/ch02.html.id998-marker">8</a></sup></p>

<p>So follow the example of the standard library and provide a minimal API surface for implementors but a convenient and
comprehensive API for users, by adding methods with default implementations (and trait bounds as appropriate).</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch02.html.id790"><sup><a href="#OEBPS/ch02.html.id790-marker">1</a></sup> Of course, comparing floats for equality is always a dangerous game, as there is typically no guarantee that rounded calculations will produce a result that is bit-for-bit identical to the number you first thought of.</p><p data-type="footnote" id="OEBPS/ch02.html.id802"><sup><a href="#OEBPS/ch02.html.id802-marker">2</a></sup> More generally, any  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> also has a partial order.</p><p data-type="footnote" id="OEBPS/ch02.html.id899"><sup><a href="#OEBPS/ch02.html.id899-marker">3</a></sup> This also means that RAII as a technique is mostly available<a data-primary="defer statement (Go)" data-type="indexterm" id="OEBPS/ch02.html.id999"></a><a data-primary="Go" data-type="indexterm" id="OEBPS/ch02.html.id1000"></a> only in languages that have a predictable time of destruction, which rules out most garbage-collected languages (although Go’s  <a href="https://oreil.ly/2jrtX"><code>defer</code> statement</a> achieves some of the same ends).</p><p data-type="footnote" id="OEBPS/ch02.html.id907"><sup><a href="#OEBPS/ch02.html.id907-marker">4</a></sup> RAII is also still useful for memory management in<a data-primary="unsafe code" data-type="indexterm" id="OEBPS/ch02.html.id1001"></a> low-level  <code>unsafe</code> code, but that is (mostly) beyond the scope of this book.</p><p data-type="footnote" id="OEBPS/ch02.html.id937"><sup><a href="#OEBPS/ch02.html.id937-marker">5</a></sup> Using <a href="https://oreil.ly/k_zrF">“<code>impl Trait</code> in argument position”</a> isn’t exactly equivalent to the previous two versions, because it removes the ability for a caller to explicitly specify the type parameter with something like <code>on_screen::&lt;Circle&gt;(&amp;c)</code>.</p><p data-type="footnote" id="OEBPS/ch02.html.id973"><sup><a href="#OEBPS/ch02.html.id973-marker">6</a></sup> At the time of writing, the restriction on methods that return <code>Self</code> includes types like <code>Box&lt;Self&gt;</code> that <em>could</em> be safely stored on the stack; this restriction <a href="https://oreil.ly/JZH3V">might be relaxed in the future</a>.</p><p data-type="footnote" id="OEBPS/ch02.html.id988"><sup><a href="#OEBPS/ch02.html.id988-marker">7</a></sup> The <code>is_empty()</code> method is currently a <a href="https://oreil.ly/0wZOL">nightly-only experimental function</a>.</p><p data-type="footnote" id="OEBPS/ch02.html.id998"><sup><a href="#OEBPS/ch02.html.id998-marker">8</a></sup> If the new method happens to match a method of the same name in the <em>concrete</em> type, then the concrete method—known as an <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations"><em>inherent implementation</em></a>—will be used ahead of the trait method.  <a data-primary="inherent implementation" data-type="indexterm" id="OEBPS/ch02.html.id1002"></a>The trait method can be explicitly selected instead by casting: <code>&lt;Concrete as Trait&gt;::method()</code>.</p></div></div></section></div></div>
<div id="OEBPS/ch03.html"><div data-type="book">
<section data-pdf-bookmark="Chapter 3. Concepts" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch03.html.file_concepts_md">
<h1><span class="label">Chapter 3. </span>Concepts</h1>


<p>The first two chapters of this book covered Rust’s types and traits, which helps provide the vocabulary needed to work
with some of the <em>concepts</em> involved in writing Rust code—the subject of this chapter.<a data-primary="concepts in writing Rust code" data-type="indexterm" id="OEBPS/ch03.html.id1003"></a></p>

<p>The  borrow checker and  lifetime checks are central to what makes Rust unique; they are also a common
stumbling block for newcomers to Rust and so are the focus of the first two Items in this chapter.<a data-primary="borrow checker" data-type="indexterm" id="OEBPS/ch03.html.id1004"></a><a data-primary="lifetime checks" data-type="indexterm" id="OEBPS/ch03.html.id1005"></a></p>

<p>The other Items in this chapter cover concepts that are easier to grasp but are nevertheless a bit different from
writing code in other languages.<a data-primary="unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1006"></a>  This includes the 
<span class="keep-together">following</span>:</p>

<ul>
<li>
<p>Advice on Rust’s <code>unsafe</code> mode and how to avoid it (<a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>)</p>
</li>
<li>
<p>Good news and bad news about writing multithreaded code in Rust (<a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>)</p>
</li>
<li>
<p>Advice on avoiding runtime aborts (<a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>)</p>
</li>
<li>
<p>Information about Rust’s approach to reflection (<a href="#OEBPS/ch03.html.file_reflection_md">Item 19</a>)</p>
</li>
<li>
<p>Advice on balancing optimization against maintainability (<a href="#OEBPS/ch03.html.file_optimize_md">Item 20</a>)</p>
</li>
</ul>

<p>It’s a good idea to try to align your code with the consequences of these concepts.  It’s <em>possible</em> to re-create (some
of) the behavior of   C/C++ in Rust, but why bother to use Rust if you do?</p>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 14: Understand lifetimes" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_lifetimes_md">
<h1>Item 14: Understand lifetimes</h1>

<p>This Item describes Rust’s  <em>lifetimes</em>, which are a more precise formulation of a concept that existed in
previous compiled languages like C and C++—in practice if not in theory.<a data-primary="lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1007"></a>  Lifetimes are a required input for the
<em>borrow checker</em> described in <a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>; taken together, these features form the heart of Rust’s memory safety
guarantees.</p>








<section data-pdf-bookmark="Introduction to the Stack" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id71">
<h2>Introduction to the Stack</h2>

<p>Lifetimes are fundamentally related to the <em>stack</em>, so a quick introduction/reminder is in order.<a data-primary="stack" data-secondary="introduction to" data-type="indexterm" id="OEBPS/ch03.html.id1008"></a></p>

<p>While a program is running, the memory that it uses is divided up into different chunks, sometimes called
 <em>segments</em>.  <a data-primary="segments (stack)" data-type="indexterm" id="OEBPS/ch03.html.id1009"></a>Some of these chunks are a fixed size, such as the ones that hold the program code or the program’s
global data, but two of the <span class="keep-together">chunks—</span>the <em>heap</em> and the <em>stack</em>—change size as the program
runs.  <a data-primary="memory" data-secondary="program memory layout" data-type="indexterm" id="OEBPS/ch03.html.id1010"></a>To allow for this, they are typically arranged at opposite ends of the program’s virtual memory space, so one
can grow downward and the other can grow upward (at least until your program runs out of memory and crashes), as
summarized in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_1">Figure&nbsp;3-1</a>.</p>

<figure><div class="figure" id="OEBPS/ch03.html.fig_3_1">
<img alt="Representation of program memory layout, shown as a vertical rectangle divided into chunks.  From bottom to top the chunks are marked: Code, Global Data, Stack, but there is also an unlabelled chunk between Heap and Stack. In this empty chunk are two arrows each labelled Grows: the bottom arrow points up to indicate that the heap grows up into the empty space, the top arrow points down to indicate that the stack grows down into the empty space." src="data:image/png;base64,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">
<h6><span class="label">Figure 3-1. </span>Program memory layout, including heap growing up and stack growing down</h6>
</div></figure>

<p>Of these two dynamically sized chunks, the stack is used to hold state related to the currently executing function.
This state <a data-primary="functions" data-secondary="currently executing function, state of" data-type="indexterm" id="OEBPS/ch03.html.id1011"></a>can include these elements:</p>

<ul>
<li>
<p>The parameters passed to the function</p>
</li>
<li>
<p>The local variables used in the function</p>
</li>
<li>
<p>Temporary values calculated within the function</p>
</li>
<li>
<p>The return address within the code of the function’s caller</p>
</li>
</ul>

<p>When a function <code>f()</code> is called, a new stack frame is added to the stack, beyond where the stack frame for the calling
function ends, and the CPU normally updates a register—the  <em>stack pointer</em>—to point to the new
stack frame.<a data-primary="stack pointers" data-type="indexterm" id="OEBPS/ch03.html.id1012"></a></p>

<p>When the inner function <code>f()</code> returns, the stack pointer is reset to where it was before the call, which will be the
caller’s stack frame, intact and unmodified.</p>

<p>If the caller subsequently invokes a different function <code>g()</code>, the process happens again, which means that the stack
frame for <code>g()</code> will reuse the same area of memory that <code>f()</code> previously used (as depicted in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_2">Figure&nbsp;3-2</a>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">caller</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">42</code><code class="k">u64</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">19</code><code class="k">u64</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">f</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">g</code><code class="p">(</code><code class="n">y</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">f_param</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">two</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="k">u64</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">f_param</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">two</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">g</code><code class="p">(</code><code class="n">g_param</code>: <code class="kt">u64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">arr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">2</code><code class="k">u64</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="k">u64</code><code class="p">];</code><code class="w"></code>
<code class="w">    </code><code class="n">g_param</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">arr</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch03.html.fig_3_2">
<img alt="The diagram shows four pictures of a stack, evolving from left to right as different functions are called. The first stack is for the caller function itself, and just has two entries: an x value of 42 and a y value of 19. These two entries are repeated at the top of all four stack diagrams.  The second stack shows caller invoking f, and has two added stack entries at the bottom: an f_param value of 42 and a two value of 2.  The third stack is back to just being for the caller function itself, and is a repeat of the first stack, holding just x and y.  The final stack shows caller invoking g, and has new stack entries below x and y in the space space that was used in the second stack.  These extra stack entries are a g_param value of 19, then a pair of values jointly labelled arr holding values 3 and 2." src="data:image/png;base64,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AAAAQUAAAAAABAEBAAAAEAQEAAAAQBAQAAAAAEFAAAAAAAQBAQAAABAEBAAAAEAQEAAAAABBQAAAAAAEAQEAAAAQBAQAAABAEBAAAAAAQUAAAAAABAEBAAAAEAQEQH9//+Tk5OXLlzvdESBdJicnFQegkuIAPUxAAISjR4/u37//+PHjne4IkC5Hjx7ds2eP4gCUURygVwkIgBBCuHjx4kc+8pH+/v6lpaVO9wVIkStXrigOQKVScdi/f7/iAL1EQAC85vTp0/fcc8/IyIh5g0BcVBwuXLjQ6b4AKbK8vKw4QC8READlTpw4sWfPnsnJyU53BEiXEydO7N+/39pjoIziAD1DQAAkuHLlSml54cmTJzvdFyBFSsVh//79igMQFxUHGxNAVxMQAFd18eLFD37wg/39/efOnet0X4AUURyARNGWRooDdCkBAXANp0+ffte73nX48GHzBoG4UnGwawlQRnGA7iUgAGry+c9/fs+ePdPT053uCJAupV1LFAegjC2NoBsJCIBaXbly5eGHH96zZ48LGgFxigOQyJZG0HUEBMDGXLx48Z577unv73dBIyBOcQASRbuWKA6QfgICoB6nT5++7bbbXNAIKFMqDnYtAcooDtAVtna6A0CTXbhwYUNXGGokzj969Oj09PT09PTIyEjdLwK0x0aLQyPrBT7/+c8fP35ccYCu0P7iMDk5efjw4bpfBGgdAQH0mgsXLhw9erRtzV25cuUjH/lIKSbo7+9vW7vARikOQKL2F4eHH364lCEqDpA2lhgATbC8vHzPPfccOnTI8kIgTnEAEikOkE5b1tfXW/G6/f39p0+fjt9z48233njzra1o66cvXPn3/+5Poy/vPPDeVrRS8tyPfvjcj35Yuv2m62+47e13tq6t75/9dnT7trf/7Tddv71FDTmoBrXnoOJHVNLX15c4x29paemee+5pRR9qsX379sOHDx8+fHjHjh2JD2hncQjeco1xUA1SHMocOXKkSnGYnJws+xum4rBRDqoRvXdQPVwcWvoL8pZrhINqUCqKw3pr9PX1teJggEhfX1/i6Fv45rc63bWw69afO/PHBcUBOqJLi8ORI0c63TvocWkuDjfcsP1fLXxTcYCOiBeH3lli8Kbrb9BWVzTUzrZ68qCuaesbtnS2A7t3737kd46+58AvdrYbcd5yXdFQO9vqyYO6po4X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">
<h6><span class="label">Figure 3-2. </span>Evolution of stack usage as functions are called and returned from</h6>
</div></figure>

<p class="pagebreak-before less_space">Of course, this is a dramatically simplified version of what really goes on—putting things on and off the stack
takes time, and so real processors will have many optimizations.  However, the simplified conceptual picture is enough
for understanding the subject of this Item.</p>
</div></section>








<section data-pdf-bookmark="Evolution of Lifetimes" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id72">
<h2>Evolution of Lifetimes</h2>

<p>The previous section explained how parameters and local variables are stored on the stack and pointed out that those
values are stored only ephemerally.<a data-primary="lifetimes" data-secondary="evolution of" data-type="indexterm" id="OEBPS/ch03.html.ix_lftevol"></a></p>

<p>Historically, this allowed for some dangerous footguns: what happens if you hold onto a pointer to one of these
ephemeral stack values?</p>

<p>Starting back with  C, it was perfectly OK to return a pointer to a local variable (although modern compilers will
emit a warning for it):</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1013">
<h1></h1>
<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C code. */</code><code class="w"></code>
<code class="k">struct</code><code class="w"> </code><code class="nc">File</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">fd</code><code class="p">;</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>

<code class="k">struct</code><code class="w"> </code><code class="nc">File</code><code class="o">*</code><code class="w"> </code><code class="n">open_bugged</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">File</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">open</code><code class="p">(</code><code class="s">"README.md"</code><code class="p">,</code><code class="w"> </code><code class="n">O_RDONLY</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="n">f</code><code class="p">;</code><code class="w">  </code><code class="cm">/* return address of stack object! */</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>You <em>might</em> get away with this, if you’re unlucky and the calling code uses the returned value immediately:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1014">
<h1></h1>
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">File</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open_bugged</code><code class="p">();</code><code class="w"></code>
<code class="n">printf</code><code class="p">(</code><code class="s">"in caller: file at %p has fd=%d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="o">-&gt;</code><code class="n">fd</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">in caller: file at 0x7ff7bc019408 has fd=3</pre>

<p>This is unlucky because it only <em>appears</em> to work.  As soon as any other function calls happen, the stack area will
be reused and the memory that used to hold the object will be overwritten:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1015">
<h1></h1>
<pre data-code-language="c" data-type="programlisting"><code class="n">investigate_file</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C code. */</code><code class="w"></code>
<code class="kt">void</code><code class="w"> </code><code class="nf">investigate_file</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">File</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="kt">long</code><code class="w"> </code><code class="n">array</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">};</code><code class="w"> </code><code class="c1">// put things on the stack</code>
<code class="w">  </code><code class="n">printf</code><code class="p">(</code><code class="s">"in function: file at %p has fd=%d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="o">-&gt;</code><code class="n">fd</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">in function: file at 0x7ff7bc019408 has fd=1592262883</pre>

<p>Trashing the contents of the object has an additional bad effect for this example: the file descriptor corresponding to
the open file is lost, and so the program leaks the resource that was held in the data structure.</p>

<p>Moving forward in time to  C++, this latter problem of losing access to resources was solved by the inclusion of
<em>destructors</em>, enabling  RAII (see <a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>).  Now, the things on the stack have the ability to tidy themselves up:
if the object holds some kind of resource, the destructor can tidy it up, and the C++ compiler guarantees that the
destructor of an object on the stack gets called as part of tidying up the stack frame:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code.</code>
<code class="n">File</code><code class="o">::~</code><code class="n">File</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="n">std</code><code class="o">::</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"~File(): close fd "</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">fd</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="n">close</code><code class="p">(</code><code class="n">fd</code><code class="p">);</code><code class="w"></code>
<code class="w">  </code><code class="n">fd</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">-1</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The caller now gets an (invalid) pointer to an object that’s been destroyed and its resources reclaimed:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1016">
<h1></h1>
<pre data-code-language="c++" data-type="programlisting"><code class="n">File</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">open_bugged</code><code class="p">();</code><code class="w"></code>
<code class="n">printf</code><code class="p">(</code><code class="s">"in caller: file at %p has fd=%d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="p">,</code><code class="w"> </code><code class="n">f</code><code class="o">-&gt;</code><code class="n">fd</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">~File(): close fd 3
in caller: file at 0x7ff7b6a7c438 has fd=-1</pre>

<p>However, C++ did nothing to help with the problem of dangling pointers: it’s still possible to hold onto a pointer to an
object that’s gone (with a destructor that has been called):</p>

<pre data-code-language="c" data-type="programlisting"><code class="c1">// C++ code.</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">investigate_file</code><code class="p">(</code><code class="n">File</code><code class="o">*</code><code class="w"> </code><code class="n">f</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="kt">long</code><code class="w"> </code><code class="n">array</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">};</code><code class="w"> </code><code class="c1">// put things on the stack</code>
<code class="w">  </code><code class="n">std</code><code class="o">::</code><code class="n">cout</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"in function: file at "</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">" has fd="</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">f</code><code class="o">-&gt;</code><code class="n">fd</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">in function: file at 0x7ff7b6a7c438 has fd=-183042004</pre>

<p>As a C/C++ programmer, it’s up to you to notice this and make sure that you don’t dereference a pointer that points to
something that’s gone.  Alternatively, if you’re an  attacker and you find one of these dangling pointers, you’re
more likely to  cackle maniacally and gleefully dereference the pointer on your way to an exploit.<a data-primary="cackle maniacally" data-type="indexterm" id="OEBPS/ch03.html.id1017"></a></p>

<p>Enter Rust.  One of Rust’s core attractions is that it fundamentally solves the problem of dangling pointers,
immediately solving a large fraction of security problems.<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1018" id="OEBPS/ch03.html.id1018-marker">1</a></sup></p>

<p>Doing so requires moving the concept of lifetimes from the background (where 
<span class="keep-together">C/C++</span> programmers just have to know to
watch out for them, without any language support) to the foreground: every type that includes an ampersand <code>&amp;</code> has
an associated lifetime (<code>'a</code>), even if the compiler lets you omit mention of it much of the time.<a data-primary="lifetimes" data-secondary="evolution of" data-startref="ix_lftevol" data-type="indexterm" id="OEBPS/ch03.html.id1019"></a></p>
</div></section>








<section data-pdf-bookmark="Scope of a Lifetime" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id73">
<h2>Scope of a Lifetime</h2>

<p>The lifetime of an item on the stack <a data-primary="lifetimes" data-secondary="scope of" data-type="indexterm" id="OEBPS/ch03.html.ix_lftscp"></a>is the period where that item is guaranteed to stay in the same place; in other
words, this is exactly the period where a  <em>reference</em> (pointer) to the item is guaranteed not to become invalid.<a data-primary="scope" data-type="indexterm" id="OEBPS/ch03.html.ix_scp"></a><a data-primary="references" data-secondary="lifetime scope and" data-type="indexterm" id="OEBPS/ch03.html.id1020"></a></p>

<p>This starts at the point where the item is created, and extends to where it is either <em>dropped</em> (Rust’s equivalent to object destruction in C++) or <em>moved</em>.<a data-primary="moving an item" data-secondary="items moved to or from the stack" data-type="indexterm" id="OEBPS/ch03.html.id1021"></a><a data-primary="dropping items" data-type="indexterm" id="OEBPS/ch03.html.id1022"></a><a data-primary="C" data-type="indexterm" id="OEBPS/ch03.html.id1023"></a><a data-primary="C++" data-secondary="object destruction" data-type="indexterm" id="OEBPS/ch03.html.id1024"></a></p>

<p>The ubiquity of the latter is sometimes surprising for programmers coming from 
<span class="keep-together">C/C++</span>: Rust moves items from one place on
the stack to another, or from the stack to the heap, or from the heap to the stack, in lots of situations.</p>

<p>Precisely where an item gets automatically dropped depends on whether an item has a name or not.</p>

<p>Local variables and function parameters have names, and the corresponding item’s lifetime starts when the item is
created and the name is populated:</p>

<ul>
<li>
<p>For a local variable: at the <code>let var = ...</code> declaration</p>
</li>
<li>
<p>For a function parameter: as part of setting up the execution frame for the function invocation</p>
</li>
</ul>

<p>The lifetime for a named item ends when the item is either moved somewhere else or when the name goes out of
 scope:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Debug, Clone)]</code><code class="w"></code>
<code class="sd">/// Definition of an item of some kind.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">contents</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">item1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">1</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// `item1` created here</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">item2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">2</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// `item2` created here</code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"item1 = {item1:?}, item2 = {item2:?}"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="n">consuming_fn</code><code class="p">(</code><code class="n">item2</code><code class="p">);</code><code class="w"> </code><code class="c1">// `item2` moved here</code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `item1` dropped here</code></pre>

<p>It’s also possible to build an item “on the fly,” as part of an expression that’s then fed into something else.  These
unnamed temporary items are then dropped when they’re no longer needed.  One oversimplified but helpful way to think
about this is to imagine that each part of the expression gets expanded to its own block, with temporary variables being
inserted by the compiler.  For example, an expression like:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">f</code><code class="p">((</code><code class="n">a</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"></code></pre>

<p>would be roughly equivalent to:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">temp1</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">temp2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">temp1</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="n">f</code><code class="p">(</code><code class="n">temp2</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="c1">// `temp2` dropped here</code>
<code class="p">};</code><code class="w"> </code><code class="c1">// `temp1` dropped here</code></pre>

<p>By the time execution reaches the semicolon at the end of the original line, the temporaries have all been dropped.</p>

<p>One way to see what the compiler calculates as an item’s lifetime is to insert a deliberate error for the borrow checker
(<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>) to detect.  <a data-primary="borrow checker" data-secondary="deliberate error inserted for" data-type="indexterm" id="OEBPS/ch03.html.id1025"></a>For example, hold onto a reference to an item beyond the scope of the item’s lifetime:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1026">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">;</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"r.contents = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">contents</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<p>The error message indicates the exact endpoint of <code>item</code>’s lifetime:</p>

<pre data-code-language="text" data-type="programlisting">error[E0597]: `item` does not live long enough
   --&gt; src/main.rs:190:13
    |
189 |         let item = Item { contents: 42 };
    |             ---- binding `item` declared here
190 |         r = &amp;item;
    |             ^^^^^ borrowed value does not live long enough
191 |     }
    |     - `item` dropped here while still borrowed
192 |     println!("r.contents = {}", r.contents);
    |                                 ---------- borrow later used here</pre>

<p>Similarly, for an unnamed temporary:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1027">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fn_returning_ref</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">});</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"r.contents = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">contents</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<p>the error message shows the endpoint at the end of the expression:</p>

<pre data-code-language="text" data-type="programlisting">error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:209:46
    |
209 | let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
    |                                      ^^^^^^^^^^^^^^^^^^^^^ - temporary
    |                                      |           value is freed at the
    |                                      |           end of this statement
    |                                      |
    |                                      creates a temporary value which is
    |                                      freed while still in use
210 | println!("r.contents = {}", r.contents);
    |                             ---------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value</pre>

<p>One final point about the <a data-primary="references" data-secondary="lifetimes of" data-type="indexterm" id="OEBPS/ch03.html.id1028"></a>lifetimes of <em>references</em>: if the compiler can prove to itself that there is no use of a
reference beyond a certain point in the code, then it treats the endpoint of the reference’s lifetime as the last place
it’s used, rather than at the end of the enclosing scope.<a data-primary="non-lexical lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1029"></a>  This feature, known as  <a href="https://oreil.ly/4uJ73">non-lexical lifetimes</a>, allows the borrow checker to be a little bit more
generous:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// `s` owns the `String`.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code>: <code class="nb">String</code> <code class="o">=</code><code class="w"> </code><code class="s">"Hello, world"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Create a mutable reference to the `String`.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">greeting</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="p">[</code><code class="o">..</code><code class="mi">5</code><code class="p">];</code><code class="w"></code>
<code class="w">    </code><code class="n">greeting</code><code class="p">.</code><code class="n">make_ascii_uppercase</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="c1">// .. no use of `greeting` after this point</code>

<code class="w">    </code><code class="c1">// Creating an immutable reference to the `String` is allowed,</code>
<code class="w">    </code><code class="c1">// even though there's a mutable reference still in scope.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="kt">str</code> <code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">s</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"s = '{}'"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"> </code><code class="c1">// s = 'HELLO, world'</code>
<code class="p">}</code><code class="w"> </code><code class="c1">// The mutable reference `greeting` would naively be dropped here.</code></pre>
</div></section>








<section data-pdf-bookmark="Algebra of Lifetimes" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.algebra_lifetimes_sect">
<h2>Algebra of Lifetimes</h2>

<p>Although lifetimes are<a data-primary="scope" data-startref="ix_scp" data-type="indexterm" id="OEBPS/ch03.html.id1030"></a><a data-primary="lifetimes" data-secondary="scope of" data-startref="ix_lftscp" data-type="indexterm" id="OEBPS/ch03.html.id1031"></a><a data-primary="lifetimes" data-secondary="algebra of" data-type="indexterm" id="OEBPS/ch03.html.ix_lftalg"></a> ubiquitous when dealing with references in Rust, you don’t get to specify them in any
detail—there’s no way to say, “I’m dealing with a lifetime that extends from line 17 to line 32 of
<code>ref.rs</code>.”  Instead, your code refers to lifetimes with arbitrary names, conventionally <code>'a</code>, <code>'b</code>, <code>'c</code>,
…, and the compiler has its own internal, inaccessible representation of what that equates to in the source code.<a data-primary="static lifetime" data-type="indexterm" id="OEBPS/ch03.html.id1032"></a>
(The one exception to this is the <code>'static</code> lifetime, which is a special case that’s covered in a subsequent section.)</p>

<p>You don’t get to do much with these lifetime names; the main thing that’s possible is to compare one name with
another, repeating a name to indicate that two lifetimes are the “same.”</p>

<p>This algebra of lifetimes is easiest to illustrate with function signatures: if the inputs and outputs of a function
deal with references, what’s the relationship between their lifetimes?<a data-primary="function signatures, lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1033"></a></p>

<p>The most common case is a function that receives a single reference as input and emits a reference as output.  The
output reference must have a lifetime, but what can it be?  There’s only one possibility (other than <code>'static</code>) to
choose from: the lifetime of the input, which means that they both share the same name, say, <code>'a</code>.  Adding that name as a
 lifetime annotation to both types gives:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">first</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="p">[</code><code class="n">Item</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;'</code><code class="na">a</code><code class="w"> </code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Because this variant is so common, and because there’s (almost) no choice about what the output lifetime can be, Rust
has  <em>lifetime elision</em> rules that mean you don’t have to explicitly write the lifetime names for this case.<a data-primary="lifetime elision rules" data-type="indexterm" id="OEBPS/ch03.html.id1034"></a>  A
more idiomatic version of the same function signature would be the following:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">first</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Item</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The references involved still have lifetimes—the elision rule just means that you don’t have to make up an
arbitrary lifetime name and use it in both places.</p>

<p>What if there’s more than one choice of input lifetimes to map to an output lifetime?  In this case, the compiler can’t
figure out what to do:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1035">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find</code><code class="p">(</code><code class="n">haystack</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"> </code><code class="n">needle</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:56:55
   |
56 | pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
   |                       -----          -----            ^ expected named
   |                                                     lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
           signature does not say whether it is borrowed from `haystack` or
           `needle`
help: consider introducing a named lifetime parameter
   |
56 | pub fn find&lt;'a&gt;(haystack: &amp;'a [u8], needle: &amp;'a [u8]) -&gt; Option&lt;&amp;'a [u8]&gt; {
   |            ++++            ++                ++                  ++</pre>

<p>A shrewd guess based on the function and parameter names is that the intended lifetime for the output here is expected
to match the <code>haystack</code> input:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="o">&gt;</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="n">haystack</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"></code>
<code class="w">    </code><code class="n">needle</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"></code>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;'</code><code class="na">a</code><code class="w"> </code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Interestingly, the compiler suggested a different alternative: having both inputs to the function use the <em>same</em>
lifetime <code>'a</code>.  For example, the following is a function where this combination of lifetimes might make sense:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">smaller</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">left</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>This <em>appears</em> to imply that the two input lifetimes are the “same,” but the scare quotes (here and previously) are included
to signify that that’s not quite what’s going on.</p>

<p>The raison d’être of lifetimes is to ensure that references to items don’t outlive the items themselves; with this in
mind, an output lifetime <code>'a</code> that’s the “same” as an input lifetime <code>'a</code> just means that the input has to live longer
than the output.</p>

<p>When there are two input lifetimes <code>'a</code> that are the “same,” that just means that the output lifetime has to be
contained within the lifetimes of <em>both</em> of the inputs:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">outer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">7</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">inner</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">8</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">        </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">min</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">smaller</code><code class="p">(</code><code class="o">&amp;</code><code class="n">inner</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">outer</code><code class="p">);</code><code class="w"></code>
<code class="w">            </code><code class="fm">println!</code><code class="p">(</code><code class="s">"smaller of {inner:?} and {outer:?} is {min:?}"</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="c1">// `min` dropped</code>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="c1">// `inner` dropped</code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `outer` dropped</code></pre>

<p>To put it another way, the output lifetime has to be subsumed within the <em>smaller</em> of the lifetimes of the two inputs.</p>

<p>In contrast, if the output lifetime is unrelated to the lifetime of one of the inputs, then there’s no requirement for
those lifetimes to nest:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">haystack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"123456789"</code><code class="p">;</code><code class="w"> </code><code class="c1">// start of  lifetime 'a</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">needle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">b"234"</code><code class="p">;</code><code class="w"> </code><code class="c1">// start of lifetime 'b</code>
<code class="w">        </code><code class="n">find</code><code class="p">(</code><code class="n">haystack</code><code class="p">,</code><code class="w"> </code><code class="n">needle</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"> </code><code class="c1">// end of lifetime 'b</code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"found={:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">found</code><code class="p">);</code><code class="w"> </code><code class="c1">// `found` used within 'a, outside of 'b</code>
<code class="p">}</code><code class="w"> </code><code class="c1">// end of lifetime 'a</code></pre>
</div></section>








<section data-pdf-bookmark="Lifetime Elision Rules" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id75">
<h2>Lifetime Elision Rules</h2>

<p>In addition to the “one in, one out” elision rule described in <a data-type="xref" href="#OEBPS/ch03.html.algebra_lifetimes_sect">“Algebra of Lifetimes”</a>, there are two other elision rules that mean that
lifetime names can be 
<span class="keep-together">omitted</span>.<a data-primary="lifetimes" data-secondary="algebra of" data-startref="ix_lftalg" data-type="indexterm" id="OEBPS/ch03.html.id1036"></a><a data-primary="lifetime elision rules" data-secondary="defined" data-type="indexterm" id="OEBPS/ch03.html.id1037"></a></p>

<p>The first occurs when there are no references in the outputs from a function; in this case, each of the input references
automatically gets its own lifetime, different from any of the other input parameters.<a data-primary="elision rules" data-see="lifetime elision rules" data-type="indexterm" id="OEBPS/ch03.html.id1038"></a></p>

<p>The second occurs for  methods that use a reference to <code>self</code> (either <code>&amp;self</code> or <code>&amp;mut self</code>); in this case, the
compiler assumes that any output references take the lifetime of <code>self</code>, as this turns out to be (by far) the most
common situation.<a data-primary="self keyword" data-type="indexterm" id="OEBPS/ch03.html.id1039"></a></p>

<p>Here’s a summary of the  elision rules for <a data-primary="functions" data-secondary="lifetime elision rules for" data-type="indexterm" id="OEBPS/ch03.html.id1040"></a>functions:</p>

<ul>
<li>
<p>One input, one or more outputs: assume outputs have the “same” lifetime as the input:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="o">&amp;</code><code class="n">Item</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">Item</code><code class="p">)</code><code class="w"></code>
<code class="c1">// ... is equivalent to ...</code>
<code class="k">fn</code> <code class="nf">f</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="p">(</code><code class="o">&amp;'</code><code class="na">a</code><code class="w"> </code><code class="n">Item</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;'</code><code class="na">a</code><code class="w"> </code><code class="n">Item</code><code class="p">)</code><code class="w"></code></pre>
</li>
<li>
<p>Multiple inputs, no output: assume all the inputs have different lifetimes:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">z</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code>
<code class="c1">// ... is equivalent to ...</code>
<code class="k">fn</code> <code class="nf">f</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">c</code><code class="o">&gt;</code><code class="p">(</code><code class="n">x</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">z</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">c</code> <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code></pre>
</li>
<li>
<p>Multiple inputs including <code>&amp;self</code>, one or more outputs: assume output lifetime(s) are the “same” as <code>&amp;self</code>’s lifetime:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">z</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">Thing</code><code class="w"></code>
<code class="c1">// ... is equivalent to ...</code>
<code class="k">fn</code> <code class="nf">f</code><code class="p">(</code><code class="o">&amp;'</code><code class="na">a</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">z</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">c</code> <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Thing</code><code class="w"></code></pre>
</li>
</ul>

<p>Of course, if the elided lifetime names don’t match what you want, you can always explicitly write lifetime names that
specify which lifetimes are related to each other.  In practice, this is likely to be triggered by a compiler error that
indicates that the elided lifetimes don’t match how the function or its caller are using the references involved.</p>
</div></section>








<section data-pdf-bookmark="The 'static Lifetime" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id76">
<h2>The <code>'static</code> Lifetime</h2>

<p>The previous section described various possible mappings between the input and output reference lifetimes for
a function, but it neglected to cover one special case.<a data-primary="lifetimes" data-secondary="static lifetime" data-type="indexterm" id="OEBPS/ch03.html.id1041"></a><a data-primary="static lifetime" data-type="indexterm" id="OEBPS/ch03.html.id1042"></a>  What happens if there are <em>no</em> input lifetimes, but the output
return value includes a reference anyway?</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1043">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">the_answer</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:471:28
    |
471 |     pub fn the_answer() -&gt; &amp;Item {
    |                            ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but there
            is no value for it to be borrowed from
help: consider using the `'static` lifetime
    |
471 |     pub fn the_answer() -&gt; &amp;'static Item {
    |                             +++++++</pre>

<p>The only allowed possibility is for the returned reference to have a lifetime that’s guaranteed to never go out of
scope.  This is indicated by the special lifetime  <code>'static</code>, which is also the only lifetime that
has a specific name rather than an arbitrary placeholder name:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">the_answer</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>

<p>The simplest way to get something with the <code>'static</code> lifetime is to take a reference to a  global variable that’s
been marked as  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/keyword.static.html"><code>static</code></a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="n">ANSWER</code>: <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">the_answer</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;</code><code class="n">ANSWER</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The Rust compiler guarantees that a <code>static</code> item always has the same address for the entire duration of the program
and never moves.  This means that a reference to a <code>static</code> item has a <code>'static</code> lifetime, logically enough.<a data-primary="const" data-type="indexterm" id="OEBPS/ch03.html.id1044"></a></p>

<p>In many cases, a reference to a <code>const</code> item will also be
<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/destructors.html#constant-promotion">promoted</a> to have a <code>'static</code> lifetime, but
there are a couple of minor complications to be aware of.<a data-primary="interior mutability" data-type="indexterm" id="OEBPS/ch03.html.id1045"></a><a data-primary="destructors" data-type="indexterm" id="OEBPS/ch03.html.id1046"></a> The first is that this promotion doesn’t happen if the type
involved has a destructor or interior 
<span class="keep-together">mutability</span>:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1047">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Wrapper</code><code class="p">(</code><code class="k">pub</code><code class="w"> </code><code class="kt">i32</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Wrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">const</code><code class="w"> </code><code class="n">ANSWER</code>: <code class="nc">Wrapper</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Wrapper</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">the_answer</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="nc">Wrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// `Wrapper` has a destructor, so the promotion to the `'static`</code>
<code class="w">    </code><code class="c1">// lifetime for a reference to a constant does not apply.</code>
<code class="w">    </code><code class="o">&amp;</code><code class="n">ANSWER</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:520:9
    |
520 |         &amp;ANSWER
    |         ^------
    |         ||
    |         |temporary value created here
    |         returns a reference to data owned by the current function</pre>

<p>The second potential complication is that only the <em>value</em> of a <code>const</code> is guaranteed to be the same everywhere; the
compiler is allowed to make as many copies as it likes, wherever the variable is used. If you’re doing nefarious things
that rely on the underlying pointer value behind the <code>'static</code> reference, be aware that multiple memory
locations may be involved.</p>

<p>There’s one more possible way to get something with a <code>'static</code> lifetime.  The key promise of <code>'static</code> is that the
lifetime should outlive any other lifetime in the program; a value that’s allocated on the  heap but <em>never freed</em>
also satisfies this constraint.<a data-primary="heap" data-secondary="value allocated on and never freed" data-type="indexterm" id="OEBPS/ch03.html.id1048"></a></p>

<p>A normal<a data-primary="Box type" data-type="indexterm" id="OEBPS/ch03.html.id1049"></a> heap-allocated <code>Box&lt;T&gt;</code> doesn’t work for this, because there’s no guarantee (as described in the next section)
that the item won’t get dropped along the way:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1050">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">boxed</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">12</code><code class="w"> </code><code class="p">});</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">boxed</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"'static item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0597]: `boxed` does not live long enough
   --&gt; src/main.rs:344:32
    |
343 |     let boxed = Box::new(Item { contents: 12 });
    |         ----- binding `boxed` declared here
344 |     let r: &amp;'static Item = &amp;boxed;
    |            -------------   ^^^^^^ borrowed value does not live long enough
    |            |
    |            type annotation requires that `boxed` is borrowed for `'static`
345 |     println!("'static item is {:?}", r);
346 | }
    | - `boxed` dropped here while still borrowed</pre>

<p>However, the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> function
converts an owned <code>Box&lt;T&gt;</code> to a mutable reference to <code>T</code>.  There’s no longer an owner for the value, so it can never be
dropped—which satisfies the requirements for the <code>'static</code> lifetime:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">boxed</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">12</code><code class="w"> </code><code class="p">});</code><code class="w"></code>

<code class="w">    </code><code class="c1">// `leak()` consumes the `Box&lt;T&gt;` and returns `&amp;mut T`.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">leak</code><code class="p">(</code><code class="n">boxed</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"'static item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `boxed` not dropped here, as it was already moved into `Box::leak()`</code>

<code class="c1">// Because `r` is now out of scope, the `Item` is leaked forever.</code></pre>

<p>The inability to drop the item also means that the memory that holds the item can never be reclaimed using safe Rust,
possibly leading to a permanent<a data-primary="memory leaks" data-type="indexterm" id="OEBPS/ch03.html.id1051"></a> memory leak. (Note that leaking memory doesn’t violate Rust’s memory safety
guarantees—an item in memory that you can no longer access is still safe.)</p>
</div></section>








<section data-pdf-bookmark="Lifetimes and the Heap" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id77">
<h2>Lifetimes and the Heap</h2>

<p>The discussion so far has concentrated on the lifetimes of items on the stack, whether function parameters, local
variables, or temporaries. But what about items on the  heap?<a data-primary="heap" data-secondary="lifetimes and" data-type="indexterm" id="OEBPS/ch03.html.id1052"></a><a data-primary="lifetimes" data-secondary="of items on the heap" data-secondary-sortas="items" data-type="indexterm" id="OEBPS/ch03.html.id1053"></a></p>

<p>The key thing to realize about heap values is that every item has an owner (excepting special cases like the deliberate
leaks described in the previous section).<a data-primary="ownership" data-secondary="of items on the heap" data-secondary-sortas="items" data-type="indexterm" id="OEBPS/ch03.html.id1054"></a><a data-primary="Box type" data-secondary="ownership of values on the heap" data-type="indexterm" id="OEBPS/ch03.html.id1055"></a>  For example, a simple <code>Box&lt;T&gt;</code> puts the <code>T</code> value on the heap, with the owner
being the variable holding the <code>Box&lt;T&gt;</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">b</code>: <code class="nb">Box</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">});</code><code class="w"></code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `b` dropped here, so `Item` dropped too.</code></pre>

<p>The owning <code>Box&lt;Item&gt;</code> drops its contents when it goes out of scope, so the lifetime of the <code>Item</code> on the heap is the
same as the lifetime of the <code>Box&lt;Item&gt;</code> variable on the stack.</p>

<p>The owner of a value on the heap may itself be on the heap rather than the stack, but then who <a data-primary="Box type" data-secondary="Box::new method" data-type="indexterm" id="OEBPS/ch03.html.id1056"></a>owns the owner?</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">b</code>: <code class="nb">Box</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">});</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bb</code>: <code class="nb">Box</code><code class="o">&lt;</code><code class="nb">Box</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">b</code><code class="p">);</code><code class="w"> </code><code class="c1">// `b` moved onto heap here</code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `bb` dropped here, so `Box&lt;Item&gt;` dropped too, so `Item` dropped too.</code></pre>

<p>The chain of ownership has to end somewhere, and there are only two possibilities:</p>

<ul>
<li>
<p>The chain ends at a local variable or function parameter—in which case the lifetime of everything in the chain
is just the lifetime <code>'a</code> of that stack variable.  When the stack variable goes out of scope, everything in the chain
is dropped too.</p>
</li>
<li>
<p>The chain ends at a global variable marked as <code>static</code>—in which case the lifetime of everything in the chain
is <code>'static</code>.  The <code>static</code> variable never goes out of scope, so nothing in the chain ever gets automatically dropped.<a data-primary="static, global variable marked as" data-type="indexterm" id="OEBPS/ch03.html.id1057"></a></p>
</li>
</ul>

<p>As a result, the lifetimes of items on the heap are fundamentally tied to stack 
<span class="keep-together">lifetimes</span>.</p>
</div></section>








<section data-pdf-bookmark="Lifetimes in Data Structures" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id78">
<h2>Lifetimes in Data Structures</h2>

<p>The earlier section on the algebra of lifetimes concentrated on inputs and outputs for functions, but there are similar
concerns when references are stored in data 
<span class="keep-together">structures</span>.<a data-primary="references" data-secondary="stored in data structures, lifetimes of" data-type="indexterm" id="OEBPS/ch03.html.id1058"></a><a data-primary="data structures" data-secondary="lifetimes in" data-type="indexterm" id="OEBPS/ch03.html.id1059"></a><a data-primary="lifetimes" data-secondary="in data structures" data-secondary-sortas="data" data-type="indexterm" id="OEBPS/ch03.html.id1060"></a></p>

<p>If we try to sneak a reference into a data structure without mentioning an associated lifetime, the compiler brings us
up sharply:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1061">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">ReferenceHolder</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">item</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0106]: missing lifetime specifier
   --&gt; src/main.rs:548:19
    |
548 |         pub item: &amp;Item,
    |                   ^ expected named lifetime parameter
    |
help: consider introducing a named lifetime parameter
    |
546 ~     pub struct ReferenceHolder&lt;'a&gt; {
547 |         pub index: usize,
548 ~         pub item: &amp;'a Item,
    |</pre>

<p>As usual, the compiler error message tells us what to do. The first part is simple enough: give the reference type an
explicit lifetime name <code>'a</code>, because there are no lifetime elision rules when using references in data structures.<a data-primary="lifetime elision rules" data-type="indexterm" id="OEBPS/ch03.html.id1062"></a></p>

<p>The second part is less obvious and has deeper consequences: the data structure itself<a data-primary="lifetime parameter" data-type="indexterm" id="OEBPS/ch03.html.id1063"></a> has to have a
 lifetime parameter <code>&lt;'a&gt;</code> that matches the lifetime of the reference contained within it:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Lifetime parameter required due to field with reference.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">ReferenceHolder</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">index</code>: <code class="kt">usize</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">item</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="nc">Item</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The lifetime parameter for the data structure is infectious: any containing data structure that uses the type also has
to acquire a lifetime parameter:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Lifetime parameter required due to field that is of a</code>
<code class="c1">// type that has a lifetime parameter.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">RefHolderHolder</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">inner</code>: <code class="nc">ReferenceHolder</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The need for a lifetime parameter also applies if the data structure contains slice types, as these are again references
to borrowed data.<a data-primary="slices" data-secondary="slice types in structures, lifetime parameter for" data-type="indexterm" id="OEBPS/ch03.html.id1064"></a></p>

<p>If a data structure contains multiple fields that have associated lifetimes, then you have to choose what combination of
lifetimes is appropriate.<a data-primary="strings" data-type="indexterm" id="OEBPS/ch03.html.id1065"></a><a data-primary="lifetimes" data-secondary="lifetimes of multiple arguments" data-type="indexterm" id="OEBPS/ch03.html.id1066"></a>  An example that finds common substrings within a pair of strings is a good candidate to have
independent lifetimes:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Locations of a substring that is present in</code>
<code class="sd">/// both of a pair of strings.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">LargestCommonSubstring</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">left</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Find the largest substring present in both `left`</code>
<code class="sd">/// and `right`.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_common</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="o">&gt;</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="n">left</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">LargestCommonSubstring</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>whereas a data structure that references multiple places within the same string would have a common lifetime:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// First two instances of a substring that is repeated</code>
<code class="sd">/// within a string.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">RepeatedSubstring</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">first</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">second</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Find the first repeated substring present in `s`.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_repeat</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">s</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">RepeatedSubstring</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The propagation of lifetime parameters makes sense: anything that contains a reference, no matter how deeply nested, is
valid only for the lifetime of the item referred to. If that item is moved or dropped, then the whole chain of data
structures is no longer valid.</p>

<p>However, this also means that data structures involving references are harder to use—the owner of the data
structure has to ensure that the lifetimes all line up.<a data-primary="smart pointer types" data-type="indexterm" id="OEBPS/ch03.html.id1067"></a>  As a result, <em>prefer data structures that own their
contents</em> where possible, particularly if the code doesn’t need to be highly optimized (<a href="#OEBPS/ch03.html.file_optimize_md">Item 20</a>).  Where that’s not
possible, the various smart pointer types (e.g., <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>)
described in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a> can help untangle the lifetime 
<span class="keep-together">constraints</span>.</p>
</div></section>








<section data-pdf-bookmark="Anonymous Lifetimes" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id79">
<h2>Anonymous Lifetimes</h2>

<p>When it’s not possible to stick to data structures that own their contents, the data structure will necessarily end up
with a lifetime parameter, as described in the previous section.<a data-primary="lifetimes" data-secondary="anonymous" data-type="indexterm" id="OEBPS/ch03.html.id1068"></a><a data-primary="anonymous lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1069"></a><a data-primary="lifetime elision rules" data-secondary="anonymous lifetimes and" data-type="indexterm" id="OEBPS/ch03.html.id1070"></a>  This can create a slightly unfortunate interaction with
the lifetime elision rules described earlier in the Item.</p>

<p>For example, consider a function that returns a data structure with a lifetime parameter.  The fully explicit signature
for this function makes the lifetimes involved clear:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_one_item</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="p">(</code><code class="n">items</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="p">[</code><code class="n">Item</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">ReferenceHolder</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, the same signature with lifetimes elided can be a little misleading:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_one_item</code><code class="p">(</code><code class="n">items</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Item</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">ReferenceHolder</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Because the <a data-primary="lifetime parameter" data-secondary="elided" data-type="indexterm" id="OEBPS/ch03.html.id1071"></a>lifetime parameter for the return type is elided, a human reading the code doesn’t get much of a hint that
lifetimes are involved.</p>

<p>The  anonymous lifetime <code>'_</code> allows you to mark an elided lifetime as being present, without having to fully
restore <em>all</em> of the lifetime names:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find_one_item</code><code class="p">(</code><code class="n">items</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="n">Item</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nc">ReferenceHolder</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Roughly speaking, the <code>'_</code> marker asks the compiler to invent a unique lifetime name for us, which we can use in
situations where we never need to use the name elsewhere.</p>

<p>That means it’s also useful for other lifetime elision scenarios.<a data-primary="Debug trait" data-secondary="fmt method" data-type="indexterm" id="OEBPS/ch03.html.id1072"></a><a data-primary="fmt method" data-type="indexterm" id="OEBPS/ch03.html.id1073"></a>  For example, the declaration for the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt"><code>fmt</code></a> method of the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait uses the anonymous lifetime to indicate that
the <code>Formatter</code> instance has a different lifetime than <code>&amp;self</code>, but it’s not important what that lifetime’s name is:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">Debug</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">fmt</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">f</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Formatter</code><code class="o">&lt;'</code><code class="nb">_</code><code class="o">&gt;</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id80">
<h2>Things to Remember</h2>

<ul>
<li>
<p>All Rust references have an associated lifetime, indicated by a lifetime label (e.g., <code>'a</code>).<a data-primary="references" data-secondary="lifetimes of" data-type="indexterm" id="OEBPS/ch03.html.id1074"></a> The lifetime labels for function parameters and return values can be elided in some common cases (but are still
present under the covers).</p>
</li>
<li>
<p>Any data structure that (transitively) includes a reference has an associated lifetime parameter; as a result, it’s
often easier to work with data structures that own their contents.</p>
</li>
<li>
<p>The <code>'static</code> lifetime is used for references to items that are guaranteed never to go out of scope, such as global data
or items on the heap that have been explicitly leaked.<a data-primary="static lifetime" data-type="indexterm" id="OEBPS/ch03.html.id1075"></a></p>
</li>
<li>
<p>Lifetime labels can be used only to indicate that lifetimes are the “same,” which means that the output lifetime is
contained within the input lifetime(s).</p>
</li>
<li>
<p>The anonymous lifetime label <code>'_</code> can be used in places where a specific lifetime label is not needed.<a data-primary="anonymous lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1076"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 15: Understand the borrow checker" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_borrows_md">
<h1>Item 15: Understand the borrow checker</h1>

<p>Values in Rust have an owner, but that owner can lend the values out to other places in the code.<a data-primary="borrow checker" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchk"></a> This <em>borrowing</em>
mechanism involves the creation and use of  <em>references</em>, subject to rules policed by the  <em>borrow
checker</em>—the subject of this Item.<a data-primary="pointers" data-type="indexterm" id="OEBPS/ch03.html.id1077"></a><a data-primary="references" data-secondary="creation and use of" data-type="indexterm" id="OEBPS/ch03.html.id1078"></a></p>

<p>Under the covers, Rust’s references use the same kind of <em>pointer</em> values (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>) that are so prevalent in  C
or  C++ code but are girded with rules and restrictions to make sure that the sins of C/C++ are avoided.<a data-primary="C" data-secondary="pointers and references, comparison with Rust" data-type="indexterm" id="OEBPS/ch03.html.id1079"></a><a data-primary="C++" data-secondary="pointers and references, comparison with Rust" data-type="indexterm" id="OEBPS/ch03.html.id1080"></a> As a quick
comparison:</p>

<ul>
<li>
<p>Like a C/C++ pointer, a Rust reference is created with an ampersand: <code>&amp;value</code>.</p>
</li>
<li>
<p>Like a C++ reference, a Rust reference can never be  <code>nullptr</code>.</p>
</li>
<li>
<p>Like a C/C++ pointer or reference, a Rust reference can be modified after creation to refer to something different.</p>
</li>
<li>
<p>Unlike C++, producing a reference from a value always involves an explicit (<code>&amp;</code>) conversion—if you see
code like <code>f(value)</code>, you know that <code>f</code> is receiving ownership of the value.  (However, it may be ownership of a
<em>copy</em> of the item, if the <code>value</code>’s type implements
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>—see <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>.)</p>
</li>
<li>
<p>Unlike C/C++, the mutability of a newly created reference is always explicit (<code>&amp;mut</code>).  <a data-primary="mutable references" data-type="indexterm" id="OEBPS/ch03.html.id1081"></a>If you see code like
<code>f(&amp;value)</code>, you know that <code>value</code> won’t be modified (i.e., is <code>const</code> in C/C++ terminology).  Only
expressions like <code>f(&amp;mut value)</code> have the potential to change the contents
of <code>value</code>.<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1082" id="OEBPS/ch03.html.id1082-marker">2</a></sup></p>
</li>
</ul>

<p>The most important difference between a C/C++ pointer and a Rust reference is <a data-primary="borrow" data-type="indexterm" id="OEBPS/ch03.html.id1083"></a>indicated by the term  <em>borrow</em>: you
can take a reference (pointer) to an item, <em>but you can’t keep that reference forever</em>.  In particular, you can’t keep
it longer than the lifetime of the underlying item, as tracked by the compiler and explored in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>.<a data-primary="lifetimes" data-secondary="references" data-type="indexterm" id="OEBPS/ch03.html.id1084"></a><a data-primary="references" data-secondary="lifetimes of" data-type="indexterm" id="OEBPS/ch03.html.id1085"></a></p>

<p>These restrictions on the use of references enable Rust to make its memory safety guarantees, but they also mean that you have
to accept the cognitive costs of the borrow rules, and accept that it will change how you design your
software—particularly its data structures.</p>

<p>This Item starts by describing what Rust references can do, and the borrow checker’s rules for using them.  The rest of
the Item focuses on dealing with the consequences of those rules: how to refactor, rework, and redesign your code so
that you can win fights against the borrow checker.</p>








<section data-pdf-bookmark="Access Control" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id82">
<h2>Access Control</h2>

<p>There are three<a data-primary="access control" data-type="indexterm" id="OEBPS/ch03.html.ix_accctl"></a> ways to access the contents of a Rust item: via the item’s <em>owner</em> (<code>item</code>), a <em>reference</em>
(<code>&amp;item</code>), or a <em>mutable reference</em> (<code>&amp;mut item</code>).<a data-primary="owner of Rust items" data-secondary="accessing item contents through" data-type="indexterm" id="OEBPS/ch03.html.id1086"></a><a data-primary="mutable references" data-secondary="accessing contents of Rust items with" data-type="indexterm" id="OEBPS/ch03.html.id1087"></a> Each of these ways of accessing the item comes with different powers over the item.  Putting things roughly in
terms of the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> (create/read/update/delete)
model for storage (using Rust’s <em>drop</em> terminology in place of <em>delete</em>):</p>

<ul>
<li>
<p>The owner of an item gets to <em>create</em> it, <em>read</em> from it, <em>update</em> it, and <em>drop</em> it.<a data-primary="CRUD" data-type="indexterm" id="OEBPS/ch03.html.id1088"></a></p>
</li>
<li>
<p>A mutable reference can be used to <em>read</em> from the underlying item and <em>update</em> it.</p>
</li>
<li>
<p>A (normal) reference can be used only to <em>read</em> from the underlying item.</p>
</li>
</ul>

<p>There’s an important Rust-specific aspect to these data access rules: only the item’s owner can  <em>move</em> the item.<a data-primary="moving an item" data-type="indexterm" id="OEBPS/ch03.html.id1089"></a>  This makes sense if you think of a move as being some combination of <em>creating</em> (in the
new location) and <em>dropping</em> the item’s memory (at the old location).<a data-primary="dropping items" data-type="indexterm" id="OEBPS/ch03.html.id1090"></a></p>

<p>This can lead to some oddities for code that has a mutable reference to an item.  <a data-primary="mutable references" data-secondary="replacing item content and returning previous value" data-type="indexterm" id="OEBPS/ch03.html.id1091"></a><a data-primary="Option type" data-secondary="modifying, move restriction and" data-type="indexterm" id="OEBPS/ch03.html.id1092"></a>For example, it’s OK to overwrite an
<code>Option</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Some data structure used by the code.</code>
<code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">contents</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Replace the content of `item` with `val`.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">replace</code><code class="p">(</code><code class="n">item</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">val</code>: <code class="nc">Item</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="o">*</code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">val</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>but a modification to also return the previous value falls foul of the move restriction:<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1093" id="OEBPS/ch03.html.id1093-marker">3</a></sup></p>
<aside class="does_not_compile pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1094">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Replace the content of `item` with `val`, returning the previous</code>
<code class="sd">/// contents.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">replace</code><code class="p">(</code><code class="n">item</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">val</code>: <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">previous</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">item</code><code class="p">;</code><code class="w"> </code><code class="c1">// move out</code>
<code class="w">    </code><code class="o">*</code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">val</code><code class="p">);</code><code class="w"> </code><code class="c1">// replace</code>
<code class="w">    </code><code class="n">previous</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0507]: cannot move out of `*item` which is behind a mutable reference
  --&gt; src/main.rs:34:24
   |
34 |         let previous = *item; // move out
   |                        ^^^^^ move occurs because `*item` has type
   |                              `Option&lt;inner::Item&gt;`, which does not
   |                              implement the `Copy` trait
   |
help: consider removing the dereference here
   |
34 -         let previous = *item; // move out
34 +         let previous = item; // move out
   |</pre>

<p>Although it’s valid to <em>read</em> from a mutable reference, this code is attempting to <em>move</em> the value out, just prior to
replacing the moved value with a new value—in an attempt to avoid making a copy of the original value.<a data-primary="borrow checker" data-secondary="mutable references, moving value out and replacing it" data-type="indexterm" id="OEBPS/ch03.html.id1095"></a>  The
borrow checker has to be conservative and notices that there’s a moment between the two lines when the mutable
reference isn’t referring to a valid value.</p>

<p>As humans, we can <a data-primary="replace function" data-type="indexterm" id="OEBPS/ch03.html.id1096"></a>see that this combined operation—extracting the old value and replacing it with a new
value—is both safe and useful, so the standard library provides the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a> function to perform it.  <a data-primary="unsafe code" data-secondary="use by replace" data-type="indexterm" id="OEBPS/ch03.html.id1097"></a>Under
the covers, <code>replace</code> uses  <code>unsafe</code> (as per <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>) to perform the swap in one go:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Replace the content of `item` with `val`, returning the previous</code>
<code class="sd">/// contents.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">replace</code><code class="p">(</code><code class="n">item</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">val</code>: <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">std</code>::<code class="n">mem</code>::<code class="n">replace</code><code class="p">(</code><code class="n">item</code><code class="p">,</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">val</code><code class="p">))</code><code class="w"> </code><code class="c1">// returns previous value</code>
<code class="p">}</code><code class="w"></code></pre>

<p>For  <code>Option</code> types in particular, this<a data-primary="Option type" data-secondary="replace method" data-type="indexterm" id="OEBPS/ch03.html.id1098"></a> is a sufficiently common pattern that there is also a
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>replace</code></a> method on <code>Option</code> itself:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Replace the content of `item` with `val`, returning the previous</code>
<code class="sd">/// contents.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">replace</code><code class="p">(</code><code class="n">item</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">val</code>: <code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">item</code><code class="p">.</code><code class="n">replace</code><code class="p">(</code><code class="n">val</code><code class="p">)</code><code class="w"> </code><code class="c1">// returns previous value</code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Borrow Rules" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id83">
<h2>Borrow Rules</h2>

<p>There are two key rules to remember when borrowing references in Rust.<a data-primary="references" data-secondary="borrowing, rules for" data-type="indexterm" id="OEBPS/ch03.html.id1099"></a><a data-primary="access control" data-startref="ix_accctl" data-type="indexterm" id="OEBPS/ch03.html.id1100"></a><a data-primary="borrow checker" data-secondary="borrowing rules" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchkrule"></a></p>

<p>The first rule is that the scope of any reference must be smaller than the lifetime of the item that it refers
to.<a data-primary="lifetimes" data-secondary="references" data-type="indexterm" id="OEBPS/ch03.html.id1101"></a><a data-primary="scope" data-secondary="reference scope smaller than lifetime of item referred to" data-type="indexterm" id="OEBPS/ch03.html.id1102"></a> Lifetimes are explored in detail in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>, but it’s worth noting that the compiler has special behavior for
reference lifetimes; the  <em>non-lexical lifetimes</em> feature allows reference lifetimes to be shrunk so they end
at the point of last use, rather than the enclosing block.<a data-primary="non-lexical lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1103"></a></p>

<p>The second rule for borrowing references is that, in addition to the owner of an item, there<a data-primary="immutable references" data-type="indexterm" id="OEBPS/ch03.html.id1104"></a> can be either of the following:</p>

<ul>
<li>
<p>Any number of immutable references to the item</p>
</li>
<li>
<p>A single mutable reference to the item<a data-primary="mutable references" data-secondary="rule for" data-type="indexterm" id="OEBPS/ch03.html.id1105"></a></p>
</li>
</ul>

<p>However, there can’t be both (at the same point in the code).</p>

<p>So a function that takes multiple immutable references can be fed references to the same item:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Indicate whether both arguments are zero.</code>
<code class="k">fn</code> <code class="nf">both_zero</code><code class="p">(</code><code class="n">left</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">left</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">right</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">0</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="fm">assert!</code><code class="p">(</code><code class="n">both_zero</code><code class="p">(</code><code class="o">&amp;</code><code class="n">item</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">));</code><code class="w"></code></pre>

<p>but one that takes <em>mutable</em> references cannot:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1106">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Zero out the contents of both arguments.</code>
<code class="k">fn</code> <code class="nf">zero_both</code><code class="p">(</code><code class="n">left</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Item</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Item</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">left</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">right</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="n">zero_both</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0499]: cannot borrow `item` as mutable more than once at a time
   --&gt; src/main.rs:131:26
    |
131 |     zero_both(&amp;mut item, &amp;mut item);
    |     --------- ---------  ^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call</pre>

<p>The same restriction is true for a function that uses a mixture of mutable and immutable references:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1107">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Set the contents of `left` to the contents of `right`.</code>
<code class="k">fn</code> <code class="nf">copy_contents</code><code class="p">(</code><code class="n">left</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">Item</code><code class="p">,</code><code class="w"> </code><code class="n">right</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">left</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">right</code><code class="p">.</code><code class="n">contents</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="n">copy_contents</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0502]: cannot borrow `item` as immutable because it is also borrowed
              as mutable
   --&gt; src/main.rs:159:30
    |
159 |     copy_contents(&amp;mut item, &amp;item);
    |     ------------- ---------  ^^^^^ immutable borrow occurs here
    |     |             |
    |     |             mutable borrow occurs here
    |     mutable borrow later used by call</pre>

<p>The borrowing rules allow the compiler to make better decisions around
 <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Aliasing_(computing)"><em>aliasing</em></a>: tracking when two different pointers
may or may not refer to the same underlying item in memory.<a data-primary="aliasing" data-type="indexterm" id="OEBPS/ch03.html.id1108"></a>  If the compiler can be sure (as in Rust) that the memory
location pointed to by a collection of <a data-primary="mutable references" data-secondary="aliased" data-type="indexterm" id="OEBPS/ch03.html.id1109"></a>immutable references cannot be altered via an aliased <em>mutable</em> reference, then
it can generate code that has the following advantages:</p>
<dl>
<dt>It’s better optimized</dt>
<dd>
<p>Values can be, for example, cached in registers, secure in the knowledge that the underlying memory
contents will not change in the meantime.<a data-primary="optimization" data-type="indexterm" id="OEBPS/ch03.html.id1110"></a><a data-primary="data races" data-type="indexterm" id="OEBPS/ch03.html.id1111"></a></p>
</dd>
<dt>It’s safer</dt>
<dd>
<p>Data races arising from unsynchronized access to memory between threads (<a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>) are not possible.<a data-primary="borrow checker" data-secondary="borrowing rules" data-startref="ix_brwchkrule" data-type="indexterm" id="OEBPS/ch03.html.id1112"></a></p>
</dd>
</dl>
</div></section>








<section data-pdf-bookmark="Owner Operations" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id84">
<h2>Owner Operations</h2>

<p>One important consequence of the rules around the existence of references is that they also affect what operations can
be performed by the owner of the item.<a data-primary="borrow checker" data-secondary="owner operations and" data-type="indexterm" id="OEBPS/ch03.html.id1113"></a><a data-primary="owner of Rust items" data-secondary="operations performed by" data-type="indexterm" id="OEBPS/ch03.html.id1114"></a>  One way to help understand this is to imagine that operations involving the
owner are performed by creating and using references under the covers.</p>

<p>For example, an attempt to update the item via its owner is equivalent to making an ephemeral mutable reference and then
updating the item via that reference.  If another reference already exists, this notional second mutable reference can’t
be 
<span class="keep-together">created</span>:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1115">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="n">item</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code>
<code class="c1">// ^^^ Changing the item is roughly equivalent to:</code>
<code class="c1">//   (&amp;mut item).contents = 0;</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"reference to item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0506]: cannot assign to `item.contents` because it is borrowed
   --&gt; src/main.rs:200:5
    |
199 |     let r = &amp;item;
    |             ----- `item.contents` is borrowed here
200 |     item.contents = 0;
    |     ^^^^^^^^^^^^^^^^^ `item.contents` is assigned to here but it was
    |                       already borrowed
...
203 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here</pre>

<p>On the other<a data-primary="immutable references" data-secondary="owner operations and" data-type="indexterm" id="OEBPS/ch03.html.id1116"></a> hand, because multiple <em>immutable</em> references are allowed, it’s OK for the owner to read from the item
while there are immutable references in existence:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">item</code><code class="p">.</code><code class="n">contents</code><code class="p">;</code><code class="w"></code>
<code class="c1">// ^^^ Reading from the item is roughly equivalent to:</code>
<code class="c1">//   let contents = (&amp;item).contents;</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"reference to item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code></pre>

<p>but not<a data-primary="mutable references" data-secondary="owner operations and" data-type="indexterm" id="OEBPS/ch03.html.id1117"></a> if there is a <em>mutable</em> reference:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1118">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">item</code><code class="p">.</code><code class="n">contents</code><code class="p">;</code><code class="w"> </code><code class="c1">// i64 implements `Copy`</code>
<code class="n">r</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0503]: cannot use `item.contents` because it was mutably borrowed
   --&gt; src/main.rs:231:20
    |
230 |     let r = &amp;mut item;
    |             --------- `item` is borrowed here
231 |     let contents = item.contents; // i64 implements `Copy`
    |                    ^^^^^^^^^^^^^ use of borrowed `item`
232 |     r.contents = 0;
    |     -------------- borrow later used here</pre>

<p>Finally, the existence of any sort of <a data-primary="moving an item" data-type="indexterm" id="OEBPS/ch03.html.id1119"></a><a data-primary="dropping items" data-type="indexterm" id="OEBPS/ch03.html.id1120"></a>active reference prevents the owner of the item from moving or
 dropping the item, exactly because this would mean that the reference now refers to an invalid item:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1121">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">new_item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">item</code><code class="p">;</code><code class="w"> </code><code class="c1">// move</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"reference to item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0505]: cannot move out of `item` because it is borrowed
   --&gt; src/main.rs:170:20
    |
168 |     let item = Item { contents: 42 };
    |         ---- binding `item` declared here
169 |     let r = &amp;item;
    |             ----- borrow of `item` occurs here
170 |     let new_item = item; // move
    |                    ^^^^ move out of `item` occurs here
171 |     println!("reference to item is {:?}", r);
    |                                           - borrow later used here</pre>

<p>This is a scenario where the non-lexical lifetime feature described in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a> is particularly helpful, because
(roughly speaking) it terminates the lifetime of a reference at the point where the reference is last used, rather than
at the end of the enclosing scope.<a data-primary="non-lexical lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1122"></a>  Moving the final use of the reference up before the move happens means that the
compilation error evaporates:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">item</code><code class="p">;</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"reference to item is {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">r</code><code class="p">);</code><code class="w"></code>

<code class="c1">// Reference `r` is still in scope but has no further use, so it's</code>
<code class="c1">// as if the reference has already been dropped.</code>
<code class="kd">let</code><code class="w"> </code><code class="n">new_item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">item</code><code class="p">;</code><code class="w"> </code><code class="c1">// move works OK</code></pre>
</div></section>








<section data-pdf-bookmark="Winning Fights Against the Borrow Checker" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id173">
<h2>Winning Fights Against the Borrow Checker</h2>

<p>Newcomers to Rust (and even more experienced folk!) can often feel that they are spending time fighting against the
borrow checker. What kinds of things can help you win these battles?<a data-primary="borrow checker" data-secondary="winning fights against" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchkwin"></a></p>










<section data-pdf-bookmark="Local code refactoring" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id85">
<h3>Local code refactoring</h3>

<p>The first tactic is to pay attention to the compiler’s error messages, because the Rust developers have put a lot of
effort into making them as <a data-primary="borrow checker" data-secondary="winning fights against" data-tertiary="using local code refactoring" data-type="indexterm" id="OEBPS/ch03.html.id1123"></a><a data-primary="local code refactoring" data-type="indexterm" id="OEBPS/ch03.html.id1124"></a>helpful as possible:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1125">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// If `needle` is present in `haystack`, return a slice containing it.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">find</code><code class="o">&lt;'</code><code class="na">a</code><code class="p">,</code><code class="w"> </code><code class="o">'</code><code class="na">b</code><code class="o">&gt;</code><code class="p">(</code><code class="n">haystack</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">needle</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">b</code> <code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;'</code><code class="na">a</code><code class="w"> </code><code class="kt">str</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">haystack</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="n">needle</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">i</code><code class="o">|</code><code class="w"> </code><code class="o">&amp;</code><code class="n">haystack</code><code class="p">[</code><code class="n">i</code><code class="o">..</code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">needle</code><code class="p">.</code><code class="n">len</code><code class="p">()])</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="c1">// ...</code>

<code class="kd">let</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">find</code><code class="p">(</code><code class="o">&amp;</code><code class="fm">format!</code><code class="p">(</code><code class="s">"{} to search"</code><code class="p">,</code><code class="w"> </code><code class="s">"Text"</code><code class="p">),</code><code class="w"> </code><code class="s">"ex"</code><code class="p">);</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">text</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Found '{text}'!"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:353:23
    |
353 | let found = find(&amp;format!("{} to search", "Text"), "ex");
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       - temporary value
    |                   |                 is freed at the end of this statement
    |                   |
    |                   creates a temporary value which is freed while still in
    |                   use
354 | if let Some(text) = found {
    |                     ----- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value</pre>

<p>The first<a data-primary="error messages" data-secondary="borrowing rule broken" data-type="indexterm" id="OEBPS/ch03.html.id1126"></a> part of the error message is the important part, because it describes what borrowing rule the compiler thinks
you have broken and why.  As you encounter enough of these errors—which you will—you can build up an
intuition about the borrow checker that matches the more theoretical version encapsulated in the previously stated rules.</p>

<p>The second part of the error message includes the compiler’s suggestions for how to <a data-primary="error messages" data-secondary="fixing problem with borrow checker" data-type="indexterm" id="OEBPS/ch03.html.id1127"></a>fix the problem, which in this
case is simple:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">haystack</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"{} to search"</code><code class="p">,</code><code class="w"> </code><code class="s">"Text"</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">find</code><code class="p">(</code><code class="o">&amp;</code><code class="n">haystack</code><code class="p">,</code><code class="w"> </code><code class="s">"ex"</code><code class="p">);</code><code class="w"></code>
<code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">text</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">found</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Found '{text}'!"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="c1">// `found` now references `haystack`, which outlives it</code></pre>

<p>This is an instance of one of the two simple code tweaks that can help mollify the borrow checker:</p>
<dl>
<dt><em>Lifetime extension</em></dt>
<dd>
<p>Convert a temporary (whose lifetime extends only to the end of the expression) into a new named<a data-primary="lifetimes" data-secondary="lifetime extension" data-type="indexterm" id="OEBPS/ch03.html.id1128"></a>
local variable (whose lifetime extends to the end of the block) with a  <code>let</code> binding.</p>
</dd>
<dt><em>Lifetime reduction</em></dt>
<dd>
<p>Add an additional block <code>{ ... }</code> around the use of a reference so that its lifetime ends at the
end of the new block.<a data-primary="lifetimes" data-secondary="lifetime reduction" data-type="indexterm" id="OEBPS/ch03.html.id1129"></a></p>
</dd>
</dl>

<p>The latter is less common, because of the existence of  non-lexical lifetimes: the compiler can often figure out
that a reference is no longer used, ahead of its official drop point at the end of the block.<a data-primary="non-lexical lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1130"></a> However, if you do find
yourself repeatedly introducing an artificial block around similar small chunks of code, consider whether that code
should be encapsulated into a method of its own.</p>

<p>The compiler’s suggested fixes are helpful for simpler problems, but as you write more sophisticated code, you’re likely
to find that the suggestions are no <a data-primary="error messages" data-secondary="more complex problems with borrow checker" data-type="indexterm" id="OEBPS/ch03.html.id1131"></a>longer useful and that the explanation of the broken borrowing rule is harder to
follow:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1132">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">})));</code><code class="w"></code>

<code class="c1">// Call function with signature: `check_item(item: Option&lt;&amp;Item&gt;)`</code>
<code class="n">check_item</code><code class="p">(</code><code class="n">x</code><code class="p">.</code><code class="n">as_ref</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">borrow</code><code class="p">().</code><code class="n">deref</code><code class="p">()));</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0515]: cannot return reference to temporary value
   --&gt; src/main.rs:293:35
    |
293 |     check_item(x.as_ref().map(|r| r.borrow().deref()));
    |                                   ----------^^^^^^^^
    |                                   |
    |                                   returns a reference to data owned by the
    |                                       current function
    |                                   temporary value created here</pre>

<p>In this situation, it can be helpful to temporarily introduce a sequence of local variables, one for each step of a
complicated transformation, and each with an explicit type annotation:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1133">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"></code>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">})));</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">x1</code>: <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">as_ref</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">x2</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">cell</code>::<code class="n">Ref</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x1</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">borrow</code><code class="p">());</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">x3</code>: <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Item</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x2</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">deref</code><code class="p">());</code><code class="w"></code>
<code class="n">check_item</code><code class="p">(</code><code class="n">x3</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0515]: cannot return reference to function parameter `r`
   --&gt; src/main.rs:305:40
    |
305 |     let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    |                                        ^^^^^^^^^ returns a reference to
    |                                      data owned by the current function</pre>

<p>This narrows down the precise conversion that the compiler is complaining about, which in turn allows the code to be
restructured:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"></code>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">})));</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">x1</code>: <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">as_ref</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">x2</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">cell</code>::<code class="n">Ref</code><code class="o">&lt;</code><code class="n">Item</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x1</code><code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">borrow</code><code class="p">());</code><code class="w"></code>
<code class="k">match</code><code class="w"> </code><code class="n">x2</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">check_item</code><code class="p">(</code><code class="nb">None</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">x3</code>: <code class="kp">&amp;</code><code class="nc">Item</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">deref</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">check_item</code><code class="p">(</code><code class="nb">Some</code><code class="p">(</code><code class="n">x3</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Once the underlying problem is clear and has been fixed, you’re then free to recoalesce the local variables back
together so that you can pretend you got it right all along:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">})));</code><code class="w"></code>

<code class="k">match</code><code class="w"> </code><code class="n">x</code><code class="p">.</code><code class="n">as_ref</code><code class="p">().</code><code class="n">map</code><code class="p">(</code><code class="o">|</code><code class="n">r</code><code class="o">|</code><code class="w"> </code><code class="n">r</code><code class="p">.</code><code class="n">borrow</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">check_item</code><code class="p">(</code><code class="nb">None</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">check_item</code><code class="p">(</code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">deref</code><code class="p">())),</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>
</div></section>










<section data-pdf-bookmark="Data structure design" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id86">
<h3>Data structure design</h3>

<p>The next tactic that helps for battles against the borrow checker is to design your data structures with the borrow
checker in mind.<a data-primary="borrow checker" data-secondary="winning fights against" data-tertiary="using data structure design" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchkwinDSD"></a><a data-primary="data structures" data-secondary="designing with borrow checker in mind" data-type="indexterm" id="OEBPS/ch03.html.ix_dastrctdes"></a><a data-primary="ownership" data-secondary="data structures owning all data they use" data-type="indexterm" id="OEBPS/ch03.html.id1134"></a>  The panacea is your data structures owning all of the data that they use, avoiding any use of
references and the consequent propagation of  lifetime annotations described in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>.</p>

<p>However, that’s not always possible for real-world data structures; any time the internal connections of the data
structure form a graph that’s more interconnected than a tree pattern (a <code>Root</code> that owns multiple <code>Branch</code>es, each of
which owns multiple <code>Leaf</code>s, etc.), then simple single-ownership isn’t possible.<a data-primary="tree data structures" data-type="indexterm" id="OEBPS/ch03.html.id1135"></a></p>

<p>To take a simple example, imagine a simple register of guest details recorded in the order in which they arrive:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Guest</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">address</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ... many other fields</code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Local error type, used later.</code>
<code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Error</code><code class="p">(</code><code class="nb">String</code><code class="p">);</code><code class="w"></code>

<code class="sd">/// Register of guests recorded in order of arrival.</code>
<code class="cp">#[derive(Default, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GuestRegister</code><code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="p">);</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">register</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">guest</code>: <code class="nc">Guest</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">push</code><code class="p">(</code><code class="n">guest</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">nth</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="mf">0.</code><code class="n">get</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If this code <em>also</em> needs to be able to efficiently look up guests by arrival and alphabetically by name, then there are
fundamentally two distinct data structures involved, and only one of them can own the data.<a data-primary="cloning data in data structures" data-type="indexterm" id="OEBPS/ch03.html.id1136"></a></p>

<p>If the data involved is both small and immutable, then just cloning the data can be a quick solution:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">mod</code> <code class="nn">cloned</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="n">Guest</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="cp">#[derive(Default, Debug)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">by_arrival</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">by_name</code>: <code class="nc">std</code>::<code class="n">collections</code>::<code class="n">BTreeMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">Guest</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="n">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">register</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">guest</code>: <code class="nc">Guest</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="c1">// Requires `Guest` to be `Clone`</code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">guest</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"></code>
<code class="w">            </code><code class="c1">// Not checking for duplicate names to keep this</code>
<code class="w">            </code><code class="c1">// example shorter.</code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">guest</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">clone</code><code class="p">(),</code><code class="w"> </code><code class="n">guest</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">named</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">nth</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, this approach of cloning copes poorly if the data can be modified. For example, if the address for a <code>Guest</code>
needs to be updated, you have to find both versions and ensure they stay in sync.</p>

<p>Another possible approach is to add another layer of indirection, treating the <code>Vec&lt;Guest&gt;</code> as the owner and using an
index into that vector for the name lookups:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">mod</code> <code class="nn">indexed</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="n">Guest</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="cp">#[derive(Default)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">by_arrival</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Map from guest name to index into `by_arrival`.</code>
<code class="w">        </code><code class="n">by_name</code>: <code class="nc">std</code>::<code class="n">collections</code>::<code class="n">BTreeMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="kt">usize</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="n">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">register</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">guest</code>: <code class="nc">Guest</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="c1">// Not checking for duplicate names to keep this</code>
<code class="w">            </code><code class="c1">// example shorter.</code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="w"></code>
<code class="w">                </code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">guest</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">clone</code><code class="p">(),</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">len</code><code class="p">());</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">guest</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">named</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">idx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">nth</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">named_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">name</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">idx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">nth_mut</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">nth</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">get</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">nth_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">Guest</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">get_mut</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>In this approach, each guest is represented by a single <code>Guest</code> item, which allows the <code>named_mut()</code> method to return a
mutable reference to that item.<a data-primary="named_mut method" data-type="indexterm" id="OEBPS/ch03.html.id1137"></a>  That in turn means that changing a guest’s address works fine—the (single)
<code>Guest</code> is owned by the <code>Vec</code> and will always be reached that way under the covers:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">new_address</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"123 Bigger House St"</code><code class="p">;</code><code class="w"></code>
<code class="c1">// Real code wouldn't assume that "Bob" exists...</code>
<code class="n">ledger</code><code class="p">.</code><code class="n">named_mut</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">().</code><code class="n">address</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">new_address</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"></code>

<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">ledger</code><code class="p">.</code><code class="n">named</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">().</code><code class="n">address</code><code class="p">,</code><code class="w"> </code><code class="n">new_address</code><code class="p">);</code><code class="w"></code></pre>

<p>However, if guests can deregister, it’s easy to inadvertently introduce a bug:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1138">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Deregister the `Guest` at position `idx`, moving up all</code>
<code class="c1">// subsequent guests.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">deregister</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="k">super</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">idx</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="k">super</code>::<code class="n">Error</code>::<code class="n">new</code><code class="p">(</code><code class="s">"out of bounds"</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">idx</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Oops, forgot to update `by_name`.</code>

<code class="w">    </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>Now that the <code>Vec</code> can be shuffled, the <code>by_name</code> indexes into it are effectively acting like pointers, and we’ve
reintroduced a world where a bug can lead those “pointers” to point to nothing (beyond the <code>Vec</code> bounds) or to point to
incorrect data:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1139">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="n">ledger</code><code class="p">.</code><code class="n">register</code><code class="p">(</code><code class="n">alice</code><code class="p">);</code><code class="w"></code>
<code class="n">ledger</code><code class="p">.</code><code class="n">register</code><code class="p">(</code><code class="n">bob</code><code class="p">);</code><code class="w"></code>
<code class="n">ledger</code><code class="p">.</code><code class="n">register</code><code class="p">(</code><code class="n">charlie</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"Register starts as: {ledger:?}"</code><code class="p">);</code><code class="w"></code>

<code class="n">ledger</code><code class="p">.</code><code class="n">deregister</code><code class="p">(</code><code class="mi">0</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"Register after deregister(0): {ledger:?}"</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">also_alice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ledger</code><code class="p">.</code><code class="n">named</code><code class="p">(</code><code class="s">"Alice"</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Alice still has index 0, which is now Bob</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"Alice is {also_alice:?}"</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">also_bob</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ledger</code><code class="p">.</code><code class="n">named</code><code class="p">(</code><code class="s">"Bob"</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Bob still has index 1, which is now Charlie</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"Bob is {also_bob:?}"</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">also_charlie</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ledger</code><code class="p">.</code><code class="n">named</code><code class="p">(</code><code class="s">"Charlie"</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Charlie still has index 2, which is now beyond the Vec</code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"Charlie is {also_charlie:?}"</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<p>The code here uses a custom <code>Debug</code> implementation (not shown), in order to reduce the size of the output; this
truncated output is as follows:</p>

<pre data-code-language="text" data-type="programlisting">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {"Alice": 0, "Bob": 1, "Charlie": 2}
}
Alice is Some(Guest { name: "Bob", address: "234 Bobton" })
Bob is Some(Guest { name: "Charlie", address: "345 Charlieland" })
Charlie is None</pre>

<p>The preceding example showed a bug in the <code>deregister</code> code, but even after that bug is fixed, there’s nothing to prevent a
caller from hanging onto an index value and using it with <code>nth()</code>—getting unexpected or invalid results.</p>

<p>The core problem is that the two data structures need to be kept in sync.  A better approach for handling this is to use
Rust’s smart pointers instead (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>).  Shifting to a combination of
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> and
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> avoids the invalidation problems of using indices as
 pseudo-pointers.<a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch03.html.id1140"></a><a data-primary="RefCell type" data-type="indexterm" id="OEBPS/ch03.html.id1141"></a>  Updating the example—but keeping the bug in it—gives the 
<span class="keep-together">following</span>:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1142">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">mod</code> <code class="nn">rc</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="p">{</code><code class="n">Error</code><code class="p">,</code><code class="w"> </code><code class="n">Guest</code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="p">{</code><code class="n">cell</code>::<code class="n">RefCell</code><code class="p">,</code><code class="w"> </code><code class="n">rc</code>::<code class="n">Rc</code><code class="p">};</code><code class="w"></code>

<code class="w">    </code><code class="cp">#[derive(Default)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">by_arrival</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">by_name</code>: <code class="nc">std</code>::<code class="n">collections</code>::<code class="n">BTreeMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="n">GuestRegister</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">register</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">guest</code>: <code class="nc">Guest</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">guest</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">guest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">guest</code><code class="p">));</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">guest</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">guest</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">deregister</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="n">idx</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">Error</code>::<code class="n">new</code><code class="p">(</code><code class="s">"out of bounds"</code><code class="p">));</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">idx</code><code class="p">);</code><code class="w"></code>

<code class="w">            </code><code class="c1">// Oops, still forgot to update `by_name`.</code>

<code class="w">            </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="c1">// ...</code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Alice", {n: 'Alice', ...}), ("Bob", {n: 'Bob', ...}),
            ("Charlie", {n: 'Charlie', ...})]
}
Alice is Some(RefCell { value: Guest { name: "Alice",
                                       address: "123 Aliceville" } })
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })</pre>

<p>The output no longer has mismatched names, but a lingering entry for Alice remains until we fix the bug by
ensuring that the two collections stay in sync:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">deregister</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">idx</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">idx</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">Error</code>::<code class="n">new</code><code class="p">(</code><code class="s">"out of bounds"</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">guest</code>: <code class="nc">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Guest</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">by_arrival</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">idx</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="bp">self</code><code class="p">.</code><code class="n">by_name</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="o">&amp;</code><code class="n">guest</code><code class="p">.</code><code class="n">borrow</code><code class="p">().</code><code class="n">name</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [("Bob", {n: 'Bob', ...}), ("Charlie", {n: 'Charlie', ...})]
}
Alice is None
Bob is Some(RefCell { value: Guest { name: "Bob",
                                     address: "234 Bobton" } })
Charlie is Some(RefCell { value: Guest { name: "Charlie",
                                         address: "345 Charlieland" } })</pre>
</div></section>










<section data-pdf-bookmark="Smart pointers" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id87">
<h3>Smart pointers</h3>

<p>The final variation of the previous section is an example of a more general approach: <em>use Rust’s smart
pointers for interconnected data structures</em>.<a data-primary="data structures" data-secondary="designing with borrow checker in mind" data-startref="ix_dastrctdes" data-type="indexterm" id="OEBPS/ch03.html.id1143"></a><a data-primary="borrow checker" data-secondary="winning fights against" data-startref="ix_brwchkwinDSD" data-tertiary="using data structure design" data-type="indexterm" id="OEBPS/ch03.html.id1144"></a><a data-primary="smart pointer types" data-type="indexterm" id="OEBPS/ch03.html.ix_smptr"></a><a data-primary="borrow checker" data-secondary="winning fights against" data-tertiary="using smart pointers" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchkwinsmptr"></a></p>

<p><a href="#OEBPS/ch01.html.file_references_md">Item 8</a> described the most common smart pointer types provided by Rust’s standard library:</p>

<ul>
<li>
<p><code>Rc</code> allows shared ownership, with multiple things referring to the same item. <code>Rc</code> is often combined with <code>RefCell</code>.<a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch03.html.id1145"></a></p>
</li>
<li>
<p><code>RefCell</code> allows interior mutability so that internal state can be modified without needing a mutable
reference.  <a data-primary="RefCell type" data-type="indexterm" id="OEBPS/ch03.html.id1146"></a>This comes at the cost of moving borrow checks from compile time to runtime.<a data-primary="Arc type" data-type="indexterm" id="OEBPS/ch03.html.id1147"></a><a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch03.html.id1148"></a><a data-primary="RwLock type" data-type="indexterm" id="OEBPS/ch03.html.id1149"></a></p>
</li>
<li>
<p><code>Arc</code> is the multithreading equivalent to <code>Rc</code>.</p>
</li>
<li>
<p><code>Mutex</code> (and  <code>RwLock</code>) allows interior mutability in a multithreading environment, roughly equivalent to
<code>RefCell</code>.</p>
</li>
<li>
<p><code>Cell</code> allows interior mutability for <code>Copy</code> types.<a data-primary="Cell type" data-type="indexterm" id="OEBPS/ch03.html.id1150"></a></p>
</li>
</ul>

<p>For programmers who are adapting from C++ to Rust, the most common tool to reach for is <code>Rc&lt;T&gt;</code> (and its
thread-safe cousin <code>Arc&lt;T&gt;</code>), often combined with <code>RefCell</code> (or the thread-safe alternative <code>Mutex</code>).  A naive
translation of shared pointers (or even  <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>s) to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> instances will
generally give something that works in Rust without too much complaint from the borrow checker.</p>

<p>However, this approach means that you miss out on some of the protections that Rust gives you.<a data-primary="panics" data-type="indexterm" id="OEBPS/ch03.html.id1151"></a>  In particular,
situations where the same item is mutably borrowed (via
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut"><code>borrow_mut()</code></a>) while another reference
exists result in a runtime  <code>panic!</code> rather than a compile-time error.</p>

<p>For example, one pattern that breaks the one-way flow of ownership in tree-like data structures is when there’s an
“owner” pointer back from an item to the thing that owns it, as shown in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_3">Figure&nbsp;3-3</a>.  <a data-primary="tree data structures" data-type="indexterm" id="OEBPS/ch03.html.id1152"></a><a data-primary="owner links in tree-like data structures" data-type="indexterm" id="OEBPS/ch03.html.id1153"></a>These <code>owner</code> links are useful
for moving around the data structure; for example, adding a new sibling to a <code>Leaf</code> needs to involve the owning
<code>Branch</code>.</p>

<figure><div class="figure" id="OEBPS/ch03.html.fig_3_3">
<img alt="Representation of a tree data structure. At the top left is a rectangle representing a Tree struct. It has boxes for the id and branches fields, an arrow leads from the branches field to a stack of rectangles representing the Branch struct. The Branch struct has 3 boxes for fields: id, leaves and owner.  The owner field has an arrow that points back to the Tree struct in the top left.  The leaves field has an arrow that leads to a stack of rectangles representing the Leaf struct in the bottom right.  The Leaf struct has id and owner fields, and the owner field has an arrow pointing back to the Branch struct." src="data:image/png;base64,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">
<h6><span class="label">Figure 3-3. </span>Tree data structure layout</h6>
</div></figure>

<p>Implementing this<a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch03.html.id1154"></a> pattern in Rust can make use of <code>Rc&lt;T&gt;</code>’s more tentative partner,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">cell</code>::<code class="n">RefCell</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">rc</code>::<code class="p">{</code><code class="n">Rc</code><code class="p">,</code><code class="w"> </code><code class="n">Weak</code><code class="p">},</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>

<code class="c1">// Use a newtype for each identifier type.</code>
<code class="k">struct</code> <code class="nc">TreeId</code><code class="p">(</code><code class="nb">String</code><code class="p">);</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">BranchId</code><code class="p">(</code><code class="nb">String</code><code class="p">);</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">LeafId</code><code class="p">(</code><code class="nb">String</code><code class="p">);</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">Tree</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">id</code>: <code class="nc">TreeId</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">branches</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Branch</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">Branch</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">id</code>: <code class="nc">BranchId</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">leaves</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="n">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Leaf</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">owner</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Weak</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Tree</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">Leaf</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">id</code>: <code class="nc">LeafId</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">owner</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Weak</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Branch</code><code class="o">&gt;&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The <code>Weak</code> reference <a data-primary="Weak type" data-type="indexterm" id="OEBPS/ch03.html.id1155"></a>doesn’t increment the main refcount and so has to explicitly check whether the underlying item has
gone away:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">Branch</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_leaf</code><code class="p">(</code><code class="n">branch</code>: <code class="nc">Rc</code><code class="o">&lt;</code><code class="n">RefCell</code><code class="o">&lt;</code><code class="n">Branch</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">leaf</code>: <code class="nc">Leaf</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">leaf</code><code class="p">.</code><code class="n">owner</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">downgrade</code><code class="p">(</code><code class="o">&amp;</code><code class="n">branch</code><code class="p">));</code><code class="w"></code>
<code class="w">        </code><code class="n">branch</code><code class="p">.</code><code class="n">borrow_mut</code><code class="p">().</code><code class="n">leaves</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">Rc</code>::<code class="n">new</code><code class="p">(</code><code class="n">RefCell</code>::<code class="n">new</code><code class="p">(</code><code class="n">leaf</code><code class="p">)));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="k">fn</code> <code class="nf">location</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="o">&amp;</code><code class="bp">self</code><code class="p">.</code><code class="n">owner</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"&lt;unowned&gt;.{}"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="mi">0</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="nb">Some</code><code class="p">(</code><code class="n">owner</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="c1">// Upgrade weak owner pointer.</code>
<code class="w">                </code><code class="kd">let</code><code class="w"> </code><code class="n">tree</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">owner</code><code class="p">.</code><code class="n">upgrade</code><code class="p">().</code><code class="n">expect</code><code class="p">(</code><code class="s">"owner gone!"</code><code class="p">);</code><code class="w"></code>
<code class="w">                </code><code class="fm">format!</code><code class="p">(</code><code class="s">"{}.{}"</code><code class="p">,</code><code class="w"> </code><code class="n">tree</code><code class="p">.</code><code class="n">borrow</code><code class="p">().</code><code class="n">id</code><code class="p">.</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="mi">0</code><code class="p">)</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If Rust’s smart pointers don’t seem to cover what’s needed for your data structures, there’s always the final fallback of
writing  <code>unsafe</code> code that uses raw (and decidedly un-smart) pointers.  However, as per <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>, this should very
much be a last resort—someone else might have already implemented the semantics you want, inside a safe
interface, and if you search the standard library and  <code>crates.io</code>, you might find just the tool for the job.<a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch03.html.id1156"></a><a data-primary="unsafe code" data-secondary="using raw and un-smart pointers" data-type="indexterm" id="OEBPS/ch03.html.id1157"></a></p>

<p>For example, imagine that you have a function that sometimes returns a reference to one of its inputs but sometimes
needs to return some freshly allocated data.<a data-primary="enums" data-type="indexterm" id="OEBPS/ch03.html.id1158"></a> In line with <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a>, an  <code>enum</code> that encodes these two possibilities
is the natural way to express this in the type system, and you could then implement various pointer traits
described in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>.  <a data-primary="pointer traits" data-type="indexterm" id="OEBPS/ch03.html.id1159"></a><a data-primary="Cow enum" data-type="indexterm" id="OEBPS/ch03.html.id1160"></a><a data-primary="clone-on-write" data-type="indexterm" id="OEBPS/ch03.html.id1161"></a>But you don’t have to: the standard library already includes the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> type that covers
exactly this scenario once you know it exists.<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1162" id="OEBPS/ch03.html.id1162-marker">4</a></sup></p>
</div></section>










<section data-pdf-bookmark="Self-referential data structures" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id88">
<h3>Self-referential data structures</h3>

<p>One particular battle with the <a data-primary="borrow checker" data-secondary="winning fights against" data-startref="ix_brwchkwinsmptr" data-tertiary="using smart pointers" data-type="indexterm" id="OEBPS/ch03.html.id1163"></a><a data-primary="data structures" data-secondary="self-referential" data-type="indexterm" id="OEBPS/ch03.html.ix_dastrctself"></a><a data-primary="self-referential data structures" data-type="indexterm" id="OEBPS/ch03.html.ix_selfDS"></a><a data-primary="borrow checker" data-secondary="winning fights against" data-tertiary="creating self-referential data structures" data-type="indexterm" id="OEBPS/ch03.html.ix_brwchkwinselfDS"></a>borrow checker always stymies programmers arriving at Rust from other languages:
attempting to create self-referential data structures, which contain a mixture of owned data together with references to
within that owned data:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1164">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">SelfRef</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">text</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// The slice of `text` that holds the title text.</code>
<code class="w">    </code><code class="n">title</code>: <code class="nb">Option</code><code class="o">&lt;&amp;</code><code class="kt">str</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>At a syntactic level, this code won’t compile because it doesn’t comply with the lifetime rules described in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>:
the reference needs a lifetime annotation, and that means the containing data structure would also need a lifetime
parameter.  But a lifetime would be for something external to this <code>SelfRef</code> struct, which is not the intent: the data
being referenced is internal to the struct.</p>

<p>It’s worth thinking about the reason for this restriction at a more semantic level.  Data structures in Rust can <em>move</em>:
from the stack to the heap, from the heap to the stack, and from one place to another.  <a data-primary="moving an item" data-secondary="data structures" data-type="indexterm" id="OEBPS/ch03.html.id1165"></a>If that happens, the “interior”
<code>title</code> pointer would no longer be valid, and there’s no way to keep it in sync.</p>

<p>A simple alternative for this case is to use the indexing approach explored earlier: a range of offsets into the <code>text</code>
is not invalidated by a move and is invisible to the borrow checker because it doesn’t involve references:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">SelfRefIdx</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">text</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Indices into `text` where the title text is.</code>
<code class="w">    </code><code class="n">title</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">std</code>::<code class="n">ops</code>::<code class="n">Range</code><code class="o">&lt;</code><code class="kt">usize</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, this indexing approach works only for simple examples and has the same drawbacks as noted previously: the
index itself becomes a pseudo-pointer that can become out of sync or even refer to ranges of the <code>text</code> that no longer
exist.</p>

<p>A more general version of the self-reference problem turns up when the compiler<a data-primary="async" data-type="indexterm" id="OEBPS/ch03.html.id1166"></a> deals with  <code>async</code>
code.<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1167" id="OEBPS/ch03.html.id1167-marker">5</a></sup>  <a data-primary="Rust for Rustaceans (Gjengset)" data-type="indexterm" id="OEBPS/ch03.html.id1168"></a><a data-primary="Gjengset, Jon" data-type="indexterm" id="OEBPS/ch03.html.id1169"></a>Roughly speaking, the compiler bundles up a pending chunk of
<code>async</code> code into a closure, which holds both the code and any captured parts of the environment that the code works
with (as described in <a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>).  This captured environment can include both values and references to those values.
That’s inherently a self-referential data structure, and so <code>async</code> support was a prime motivation for the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> type in the standard library.  This pointer type “pins”
its value in place, forcing the value to remain at the same location in memory, thus ensuring that internal
self-references remain valid.<a data-primary="Pin type" data-type="indexterm" id="OEBPS/ch03.html.id1170"></a></p>

<p>So <code>Pin</code> is available as a possibility for self-referential types, but it’s tricky to use correctly—be sure to
read the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/pin/index.html">official docs</a>.</p>

<p>Where possible, <em>avoid self-referential data structures</em>, or try to find library<a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch03.html.id1171"></a> crates that encapsulate the
difficulties for you (e.g.,  <a class="orm:hideurl" href="https://crates.io/crates/ouroboros"><code>ouroborous</code></a>).</p>
</div></section>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id89">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Rust’s references are <em>borrowed</em>, indicating that they cannot be held forever.<a data-primary="borrow checker" data-secondary="winning fights against" data-startref="ix_brwchkwinselfDS" data-tertiary="creating self-referential data structures" data-type="indexterm" id="OEBPS/ch03.html.id1172"></a><a data-primary="data structures" data-secondary="self-referential" data-startref="ix_dastrctself" data-type="indexterm" id="OEBPS/ch03.html.id1173"></a><a data-primary="self-referential data structures" data-startref="ix_selfDS" data-type="indexterm" id="OEBPS/ch03.html.id1174"></a><a data-primary="smart pointer types" data-startref="ix_smptr" data-type="indexterm" id="OEBPS/ch03.html.id1175"></a><a data-primary="borrow checker" data-secondary="winning fights against" data-startref="ix_brwchkwin" data-type="indexterm" id="OEBPS/ch03.html.id1176"></a></p>
</li>
<li>
<p>The borrow checker allows multiple immutable references or a single mutable reference to an item but not both.<a data-primary="borrow checker" data-secondary="points to remember" data-type="indexterm" id="OEBPS/ch03.html.id1177"></a> The lifetime of a reference stops at the point of last use, rather than at the end of the enclosing scope, due to
non-lexical lifetimes.<a data-primary="non-lexical lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1178"></a><a data-primary="lifetimes" data-secondary="references" data-type="indexterm" id="OEBPS/ch03.html.id1179"></a></p>
</li>
<li>
<p>Errors from the borrow checker can be dealt with in various ways:</p>

<ul>
<li>
<p>Adding an additional <code>{ ... }</code> scope can reduce the extent of a value’s lifetime.<a data-primary="errors" data-secondary="from borrow checker" data-secondary-sortas="borrow" data-type="indexterm" id="OEBPS/ch03.html.id1180"></a></p>
</li>
<li>
<p>Adding a named local variable for a value extends the value’s lifetime to the end of the scope.</p>
</li>
<li>
<p>Temporarily adding multiple local variables can help narrow down what the borrow checker is complaining about.</p>
</li>
</ul>
</li>
<li>
<p>Rust’s smart pointer types provide ways around the borrow checker’s rules and so are useful for interconnected data
structures.</p>
</li>
<li>
<p>However, self-referential data structures remain awkward to deal with in Rust.<a data-primary="borrow checker" data-startref="ix_brwchk" data-type="indexterm" id="OEBPS/ch03.html.id1181"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 16: Avoid writing unsafe code" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_unsafe_md">
<h1>Item 16: Avoid writing <code>unsafe</code> code</h1>

<p>The memory safety guarantees—without runtime overhead—of Rust are its unique selling point; it is the
Rust language feature that is not found in any other mainstream language.<a data-primary="unsafe code" data-secondary="avoiding writing" data-type="indexterm" id="OEBPS/ch03.html.ix_unsf"></a><a data-primary="memory" data-secondary="safety guarantees without runtime overhead" data-type="indexterm" id="OEBPS/ch03.html.id1182"></a>  These guarantees come at a cost:
writing Rust requires you to reorganize your code to mollify the  borrow checker (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>) and to precisely
specify the reference types that you use (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>).</p>

<p>Unsafe Rust is a superset of the Rust language that weakens some of these <span class="keep-together">restrictions—</span>and the corresponding
guarantees.  <a data-primary="unsafe keyword" data-type="indexterm" id="OEBPS/ch03.html.id1183"></a>Prefixing a block with the  <code>unsafe</code> keyword switches that block into unsafe mode, which allows things
that are not supported in normal Rust.  In particular, it allows the use of  <em>raw pointers</em> that work
more like old-style C pointers. <a data-primary="raw pointers" data-type="indexterm" id="OEBPS/ch03.html.id1184"></a><a data-primary="C" data-secondary="old-style pointers" data-type="indexterm" id="OEBPS/ch03.html.id1185"></a>These pointers are not subject to the borrowing rules, and the programmer is responsible
for ensuring that they still point to valid memory whenever they’re dereferenced.</p>

<p>So at a superficial level, the advice of this Item is trivial: why move to Rust if you’re just going to write C code in
Rust?<a data-primary="unsafe code" data-secondary="occasions requiring" data-type="indexterm" id="OEBPS/ch03.html.id1186"></a>  However, there are occasions where <code>unsafe</code> code is absolutely required: for low-level library code or for when
your Rust code has to interface with code in other languages (<a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>).</p>

<p>The wording of this Item is quite precise, though: <em>avoid</em> writing <em><code>unsafe</code> code</em>.  The emphasis is on the
“writing,” because much of the time, the <code>unsafe</code> code you’re likely to need has already been written for you.</p>

<p>The Rust standard libraries contain a lot of <code>unsafe</code> code; a quick search finds around 1,000 uses of <code>unsafe</code> in the
<code>alloc</code> library, 1,500 in <code>core</code>, and a further 2,000 in <code>std</code>. This code has been written by experts and is
battle-hardened by use in many thousands of Rust codebases.<a data-primary="alloc library" data-type="indexterm" id="OEBPS/ch03.html.id1187"></a><a data-primary="core library" data-type="indexterm" id="OEBPS/ch03.html.id1188"></a><a data-primary="std library" data-type="indexterm" id="OEBPS/ch03.html.id1189"></a><a data-primary="libraries" data-secondary="unsafe code in Rust standard libraries" data-type="indexterm" id="OEBPS/ch03.html.id1190"></a></p>

<p>Some of this <code>unsafe</code> code happens under the covers in standard library features that we’ve already covered:</p>

<ul>
<li>
<p>The  smart pointer  types—<code>Rc</code>, <code>RefCell</code>, <code>Arc</code>, and friends—described in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a> use <code>unsafe</code> code (often raw pointers) internally to be able to present their particular semantics to
their users.<a data-primary="smart pointer types" data-secondary="use of unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1191"></a></p>
</li>
<li>
<p>The synchronization  primitives—<code>Mutex</code>,  <code>RwLock</code>, and associated guards—from <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>
use <code>unsafe</code> OS-specific code internally. <a class="orm:hideurl" href="https://marabos.nl/atomics/"><em>Rust Atomics and Locks</em></a> by  Mara Bos (O’Reilly) is recommended if you want to understand the subtle details involved in these primitives.<a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch03.html.id1192"></a><a data-primary="RwLock type" data-type="indexterm" id="OEBPS/ch03.html.id1193"></a><a data-primary="synchronization primitives" data-secondary="use of unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1194"></a><a data-primary="Bos, Mara" data-type="indexterm" id="OEBPS/ch03.html.id1195"></a><a data-primary="Rust Atomics and Locks (Bos)" data-type="indexterm" id="OEBPS/ch03.html.id1196"></a></p>
</li>
</ul>

<p>The<a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch03.html.id1197"></a> standard library also has other functionality covering more advanced
features, implemented with <code>unsafe</code> internally:<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1198" id="OEBPS/ch03.html.id1198-marker">6</a></sup></p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>std::pin::Pin</code></a> forces an <a data-primary="Pin type" data-type="indexterm" id="OEBPS/ch03.html.id1199"></a><a data-primary="self-referential data structures" data-type="indexterm" id="OEBPS/ch03.html.id1200"></a>item to not move in memory
(<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>).  This allows self-referential data structures, often a <a href="https://oreil.ly/JBnWU">bête noire</a> for new arrivals to Rust.</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> provides a  clone-on-write
smart<a data-primary="Cow enum" data-type="indexterm" id="OEBPS/ch03.html.id1201"></a><a data-primary="clone-on-write" data-type="indexterm" id="OEBPS/ch03.html.id1202"></a> pointer: the same pointer can be used for both reading and writing, and a clone of the underlying data
happens only if and when a write occurs.<a data-primary="functions" data-secondary="using unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1203"></a><a data-primary="take function" data-type="indexterm" id="OEBPS/ch03.html.id1204"></a><a data-primary="swap function" data-type="indexterm" id="OEBPS/ch03.html.id1205"></a><a data-primary="replace function" data-type="indexterm" id="OEBPS/ch03.html.id1206"></a></p>
</li>
<li>
<p>Various functions (<a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>take</code></a>, <a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>swap</code></a>, <a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>replace</code></a>) in <a class="orm:hideurl" href="https://doc.rust-lang.org/std/mem/index.html"><code>std::mem</code></a> allow items in memory to be manipulated without
falling foul of the  borrow checker.<a data-primary="std::mem functions" data-type="indexterm" id="OEBPS/ch03.html.id1207"></a></p>
</li>
</ul>

<p>These features may still need a little caution to be used correctly, but the <code>unsafe</code> code has been encapsulated in a
way that removes whole classes of problems.</p>

<p>Moving beyond the standard library, the  <a class="orm:hideurl" href="https://crates.io"><code>crates.io</code></a> ecosystem also includes many crates that
encapsulate <code>unsafe</code> code to provide a frequently<a data-primary="crates.io" data-secondary="encapsulating unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1208"></a> used feature:</p>
<dl>
<dt><a class="orm:hideurl" href="https://docs.rs/once_cell"><code>once_cell</code></a></dt>
<dd>
<p>Provides a way to have something like global variables, initialized
exactly once.<a data-primary="once_cell crate" data-type="indexterm" id="OEBPS/ch03.html.id1209"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://docs.rs/rand"><code>rand</code></a></dt>
<dd>
<p>Provides random number generation, making use of the lower-level underlying features
provided by the operating system and CPU.<a data-primary="rand crate" data-type="indexterm" id="OEBPS/ch03.html.id1210"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://docs.rs/byteorder"><code>byteorder</code></a></dt>
<dd>
<p>Allows raw bytes of data to be converted to and from numbers.<a data-primary="byteorder crate" data-type="indexterm" id="OEBPS/ch03.html.id1211"></a><a data-primary="cxx crate" data-type="indexterm" id="OEBPS/ch03.html.id1212"></a><a data-primary="C++" data-secondary="interoperating with Rust code" data-type="indexterm" id="OEBPS/ch03.html.id1213"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://docs.rs/cxx"><code>cxx</code></a></dt>
<dd>
<p>Allows  C++ code and Rust code to interoperate (also mentioned in <a href="#OEBPS/ch06.html.file_bindgen_md">Item 35</a>).</p>
</dd>
</dl>

<p>There are many other examples, but hopefully the general idea is clear.  If you want to do something that doesn’t
obviously fit within the constraints of Rust (especially Items <a href="#OEBPS/ch03.html.file_lifetimes_md">14</a> and <a href="#OEBPS/ch03.html.file_borrows_md">15</a>), hunt through the standard library to see
if there’s existing functionality that does what you need.  If you don’t find what you need, try also hunting through
<code>crates.io</code>. After all, it’s unusual to encounter a unique problem that no one else has ever faced before.</p>

<p>Of course, there will always be places where <code>unsafe</code> is forced, for example, when <a data-primary="FFI (foreign-function interface)" data-type="indexterm" id="OEBPS/ch03.html.id1214"></a>you need to interact with code written
in other languages via a  foreign function interface (FFI), as discussed in <a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>.  But when it’s necessary,
<em>consider writing a wrapper layer that holds all the <code>unsafe</code> code</em> that’s required so that other programmers
can then follow the advice given in  this Item.  This also helps to localize problems: when something goes wrong, the <code>unsafe</code>
wrapper can be the first suspect.<a data-primary="gratuitous use of Latin" data-type="indexterm" id="OEBPS/ch03.html.id1215"></a><a data-primary="wrapper layer holding unsafe code" data-type="indexterm" id="OEBPS/ch03.html.id1216"></a><a data-primary="Here Be Dragons" data-type="indexterm" id="OEBPS/ch03.html.id1217"></a></p>

<p>Also, if you’re forced to write <code>unsafe</code> code, pay attention to the warning implied by the keyword  itself: <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Here_be_dragons"><em>Hic sunt dracones</em></a>.</p>

<ul>
<li>
<p>Add  <a href="https://oreil.ly/MHQvh">safety comments</a> that document the
preconditions and invariants that the <code>unsafe</code> code relies on.<a data-primary="Clippy" data-type="indexterm" id="OEBPS/ch03.html.id1218"></a>  Clippy (<a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a>) has a
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/master/index.html#/missing_safety_doc">warning</a> to remind you about this.</p>
</li>
<li>
<p>Minimize the amount of code contained in an <code>unsafe</code> block, to limit the potential blast radius of a mistake.<a data-primary="missing safety doc Clippy lint" data-type="indexterm" id="OEBPS/ch03.html.id1219"></a>
Consider enabling the   <a class="orm:hideurl" href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code> lint</a> so that explicit
<code>unsafe</code> blocks are required when performing <code>unsafe</code> operations, even when those operations are performed in a
function that is <code>unsafe</code> itself.<a data-primary="unsafe_op_in_unsafe_fn lint" data-type="indexterm" id="OEBPS/ch03.html.id1220"></a></p>
</li>
<li>
<p>Write even more tests (<a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>) than usual.</p>
</li>
<li>
<p>Run additional diagnostic tools (<a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a>) over the code. In particular, <em>consider running  Miri over your
<code>unsafe</code> code</em>—<a class="orm:hideurl" href="https://github.com/rust-lang/miri">Miri</a> interprets the intermediate level output from the
compiler, that allows it to detect classes of errors that are invisible to the Rust compiler.</p>
</li>
<li>
<p>Think carefully about multithreaded use, particularly if there’s  shared state (<a href="#OEBPS/ch03.html.file_deadlock_md">Item&nbsp;17</a>).</p>
</li>
</ul>

<p>Adding the <code>unsafe</code> marker doesn’t mean that no rules apply—it means that <em>you</em> (the programmer) are now
responsible for maintaining Rust’s safety guarantees, rather than the compiler.<a data-primary="unsafe code" data-secondary="avoiding writing" data-startref="ix_unsf" data-type="indexterm" id="OEBPS/ch03.html.id1221"></a></p>
</div></section>






<section data-pdf-bookmark="Item 17: Be wary of shared-state parallelism" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_deadlock_md">
<h1>Item 17: Be wary of shared-state parallelism</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>Even the most daring forms of sharing are guaranteed safe in Rust.</p>
<p data-type="attribution"><a href="https://oreil.ly/wKFxX">Aaron Turon</a></p>
</blockquote>

<p>The official documentation describes Rust as enabling <a href="https://oreil.ly/R7eq9">“fearless concurrency”</a>, but this Item will explore why (sadly) there are
still some  reasons to be afraid of concurrency, even in Rust.<a data-primary="shared-state parallelism" data-type="indexterm" id="OEBPS/ch03.html.ix_SSpar"></a><a data-primary="concurrency" data-seealso="shared-state parallelism" data-type="indexterm" id="OEBPS/ch03.html.id1222"></a><a data-primary="afraid, reasons to be" data-type="indexterm" id="OEBPS/ch03.html.id1223"></a></p>

<p>This Item is specific to  <em>shared-state</em> parallelism: where different threads of execution communicate with each
other by sharing memory.<a data-primary="deadlocks" data-type="indexterm" id="OEBPS/ch03.html.id1224"></a><a data-primary="threads" data-secondary="sharing state between" data-type="indexterm" id="OEBPS/ch03.html.id1225"></a> Sharing state between threads generally comes with <em>two</em> terrible problems, regardless of the
language involved:</p>
<dl>
<dt>Data races</dt>
<dd>
<p>These can lead to corrupted data.</p>
</dd>
<dt>Deadlocks</dt>
<dd>
<p>These can lead to your program grinding to a halt.</p>
</dd>
</dl>

<p>Both of these problems are terrible (“causing or likely to cause terror”) because they can be very hard to debug in
practice: the failures occur nondeterministically and are often more likely to happen under load—which means
that they don’t show up in unit tests, integration tests, or any other sort of
test (<a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>), but they do show up in production.</p>

<p>Rust is a giant step forward, because it completely solves one of these two problems. However, the other still remains,
as we shall see.</p>








<section data-pdf-bookmark="Data Races" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id92">
<h2>Data Races</h2>

<p>Let’s start with the good news, by exploring  <em>data races</em> and Rust.<a data-primary="data races" data-type="indexterm" id="OEBPS/ch03.html.ix_darace"></a><a data-primary="shared-state parallelism" data-secondary="data races" data-type="indexterm" id="OEBPS/ch03.html.ix_SSpardarc"></a> The precise technical definition of
a data race varies from language to language, but we can summarize the key components as follows:</p>
<blockquote>
<p>A data race is defined to occur when two distinct threads access the same memory location, under the following conditions:</p>

<ul>
<li>
<p>At least one of them is a write.</p>
</li>
<li>
<p>There is no synchronization mechanism that enforces an ordering on the accesses.</p>
</li>
</ul></blockquote>










<section data-pdf-bookmark="Data races in C++" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id93">
<h3>Data races in C++</h3>

<p>The basics of this are best illustrated with an example.<a data-primary="data races" data-secondary="in C++" data-secondary-sortas="Cplus" data-type="indexterm" id="OEBPS/ch03.html.ix_daraceC"></a><a data-primary="C++" data-secondary="data races in" data-type="indexterm" id="OEBPS/ch03.html.ix_Cpldarc"></a> Consider a data structure that tracks a bank account:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1226">
<h1></h1>
<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code.</code>
<code class="k">class</code><code class="w"> </code><code class="nc">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="n">BankAccount</code><code class="p">()</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">balance_</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="w">  </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">balance</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">cerr</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"** Oh no, gone overdrawn: "</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"! **</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"></code>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">abort</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">balance_</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="n">deposit</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">balance_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="kt">bool</code><code class="w"> </code><code class="n">withdraw</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="c1">// What if another thread changes `balance_` at this point?</code>
<code class="w">    </code><code class="n">std</code><code class="o">::</code><code class="n">this_thread</code><code class="o">::</code><code class="n">sleep_for</code><code class="p">(</code><code class="n">std</code><code class="o">::</code><code class="n">chrono</code><code class="o">::</code><code class="n">milliseconds</code><code class="p">(</code><code class="mi">500</code><code class="p">));</code><code class="w"></code>

<code class="w">    </code><code class="n">balance_</code><code class="w"> </code><code class="o">-=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">balance_</code><code class="p">;</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>
</div></aside>

<p>This example is in  C++, not Rust, for reasons that will become clear shortly.  However, the same general concepts
apply in many other (non-Rust)  languages—Java, or Go, or Python, etc.</p>

<p>This class works fine in a single-threaded setting, but consider a multithreaded <a data-primary="multithreading" data-type="indexterm" id="OEBPS/ch03.html.id1227"></a>
<span class="keep-together">setting</span>:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="n">BankAccount</code><code class="w"> </code><code class="n">account</code><code class="p">;</code><code class="w"></code>
<code class="n">account</code><code class="p">.</code><code class="n">deposit</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code><code class="w"></code>

<code class="c1">// Start a thread that watches for a low balance and tops up the account.</code>
<code class="n">std</code><code class="o">::</code><code class="kr">thread</code><code class="w"> </code><code class="nf">payer</code><code class="p">(</code><code class="n">pay_in</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w"></code>

<code class="c1">// Start 3 threads that each try to repeatedly withdraw money.</code>
<code class="n">std</code><code class="o">::</code><code class="kr">thread</code><code class="w"> </code><code class="nf">taker</code><code class="p">(</code><code class="n">take_out</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w"></code>
<code class="n">std</code><code class="o">::</code><code class="kr">thread</code><code class="w"> </code><code class="nf">taker2</code><code class="p">(</code><code class="n">take_out</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w"></code>
<code class="n">std</code><code class="o">::</code><code class="kr">thread</code><code class="w"> </code><code class="nf">taker3</code><code class="p">(</code><code class="n">take_out</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">account</code><code class="p">);</code><code class="w"></code></pre>

<p>Here several threads are repeatedly trying to withdraw from the account, and there’s an additional thread that tops up
the account when it runs low:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// Constantly monitor the `account` balance and top it up if low.</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">pay_in</code><code class="p">(</code><code class="n">BankAccount</code><code class="o">*</code><code class="w"> </code><code class="n">account</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nb">true</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">account</code><code class="o">-&gt;</code><code class="n">balance</code><code class="p">()</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">200</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="n">log</code><code class="p">(</code><code class="s">"[A] Balance running low, deposit 400"</code><code class="p">);</code><code class="w"></code>
<code class="w">      </code><code class="n">account</code><code class="o">-&gt;</code><code class="n">deposit</code><code class="p">(</code><code class="mi">400</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="c1">// (The infinite loop with sleeps is just for demonstration/simulation</code>
<code class="w">    </code><code class="c1">// purposes.)</code>
<code class="w">    </code><code class="n">std</code><code class="o">::</code><code class="n">this_thread</code><code class="o">::</code><code class="n">sleep_for</code><code class="p">(</code><code class="n">std</code><code class="o">::</code><code class="n">chrono</code><code class="o">::</code><code class="n">milliseconds</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="c1">// Repeatedly try to perform withdrawals from the `account`.</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">take_out</code><code class="p">(</code><code class="n">BankAccount</code><code class="o">*</code><code class="w"> </code><code class="n">account</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nb">true</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">account</code><code class="o">-&gt;</code><code class="n">withdraw</code><code class="p">(</code><code class="mi">100</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="n">log</code><code class="p">(</code><code class="s">"[B] Withdrew 100, balance now "</code><code class="w"> </code><code class="o">+</code><code class="w"></code>
<code class="w">          </code><code class="n">std</code><code class="o">::</code><code class="n">to_string</code><code class="p">(</code><code class="n">account</code><code class="o">-&gt;</code><code class="n">balance</code><code class="p">()));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="n">log</code><code class="p">(</code><code class="s">"[B] Failed to withdraw 100"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">std</code><code class="o">::</code><code class="n">this_thread</code><code class="o">::</code><code class="n">sleep_for</code><code class="p">(</code><code class="n">std</code><code class="o">::</code><code class="n">chrono</code><code class="o">::</code><code class="n">milliseconds</code><code class="p">(</code><code class="mi">20</code><code class="p">));</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Eventually, things will go wrong:</p>

<pre data-code-language="text" data-type="programlisting">** Oh no, gone overdrawn: -100! **</pre>

<p>The problem isn’t hard to spot, particularly with the helpful comment in the <code>withdraw()</code> method: when multiple threads
are involved, the value of the balance can change between the check and the modification. However, real-world  bugs
of this sort are much harder to spot—particularly if the compiler is allowed to perform all kinds of tricks and
reorderings of code under the covers (as is the case for C++).</p>

<p>The various  <code>sleep</code> calls are included in order to artificially raise the chances of this bug being hit and thus
detected early; when these problems are encountered in the wild, they’re likely to occur rarely and
intermittently—making them very hard to debug.<a data-primary="sleep" data-type="indexterm" id="OEBPS/ch03.html.id1228"></a></p>

<p>The <code>BankAccount</code> class is  <em>thread-compatible</em>, which means that it can be used in a multithreaded environment as
long as the users of the class ensure that access to it is governed by some kind of external synchronization mechanism.<a data-primary="thread-compatible" data-type="indexterm" id="OEBPS/ch03.html.id1229"></a></p>

<p>The class can be converted to a  <em>thread-safe</em> class—meaning<a data-primary="thread-safe" data-type="indexterm" id="OEBPS/ch03.html.id1230"></a> that it is safe to use from multiple threads—by adding internal synchronization
operations:<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1231" id="OEBPS/ch03.html.id1231-marker">7</a></sup></p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code.</code>
<code class="k">class</code><code class="w"> </code><code class="nc">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w"> </code><code class="k">public</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="n">BankAccount</code><code class="p">()</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="n">balance_</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>

<code class="w">  </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">balance</code><code class="p">()</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Lock mu_ for all of this scope.</code>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">lock_guard</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">mutex</code><code class="o">&gt;</code><code class="w"> </code><code class="n">with_lock</code><code class="p">(</code><code class="n">mu_</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">cerr</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">"** Oh no, gone overdrawn: "</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="s">" **!</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code><code class="w"></code>
<code class="w">      </code><code class="n">std</code><code class="o">::</code><code class="n">abort</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">balance_</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="n">deposit</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">lock_guard</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">mutex</code><code class="o">&gt;</code><code class="w"> </code><code class="n">with_lock</code><code class="p">(</code><code class="n">mu_</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="n">balance_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>
<code class="w">  </code><code class="kt">bool</code><code class="w"> </code><code class="n">withdraw</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">lock_guard</code><code class="o">&lt;</code><code class="n">std</code><code class="o">::</code><code class="n">mutex</code><code class="o">&gt;</code><code class="w"> </code><code class="n">with_lock</code><code class="p">(</code><code class="n">mu_</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">balance_</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">amount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nb">false</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">balance_</code><code class="w"> </code><code class="o">-=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">true</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="p">}</code><code class="w"></code>

<code class="w"> </code><code class="k">private</code><code class="o">:</code><code class="w"></code>
<code class="w">  </code><code class="k">mutable</code><code class="w"> </code><code class="n">std</code><code class="o">::</code><code class="n">mutex</code><code class="w"> </code><code class="n">mu_</code><code class="p">;</code><code class="w"> </code><code class="c1">// protects balance_</code>
<code class="w">  </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">balance_</code><code class="p">;</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>The internal <code>balance_</code> field is now protected by a <em>mutex</em> <code>mu_</code>: a synchronization object that ensures that only one
thread can successfully hold the mutex at a time.<a data-primary="locks" data-secondary="in C++" data-secondary-sortas="Cplus" data-type="indexterm" id="OEBPS/ch03.html.id1232"></a><a data-primary="mutex (in C++)" data-type="indexterm" id="OEBPS/ch03.html.id1233"></a> A caller can acquire the mutex with a call to <code>std::mutex::lock()</code>;
the second and subsequent callers of <code>std::mutex::lock()</code> will block until the original caller invokes
<code>std::mutex::unlock()</code>, and then <em>one</em> of the blocked threads will unblock and proceed through <code>std::mutex::lock()</code>.</p>

<p>All access to the balance now takes place with the mutex held, ensuring that its value is consistent between check and
modification.<a data-primary="lock_guard (C++)" data-type="indexterm" id="OEBPS/ch03.html.id1234"></a> The  <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> is
also worth highlighting: it’s an  RAII class (see <a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>) that calls <code>lock()</code> on creation and <code>unlock()</code> on
destruction.  This ensures that the mutex is unlocked when the scope exits, reducing the chances of making a mistake
around balancing manual <code>lock()</code> and <code>unlock()</code> calls.</p>

<p>However, the thread safety here is still fragile; all it takes is one erroneous modification to the class:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// Add a new C++ method...</code>
<code class="kt">void</code><code class="w"> </code><code class="nf">pay_interest</code><code class="p">(</code><code class="kt">int32_t</code><code class="w"> </code><code class="n">percent</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="c1">// ...but forgot about mu_</code>
<code class="w">  </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">interest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">balance_</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">percent</code><code class="p">)</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="mi">100</code><code class="p">;</code><code class="w"></code>
<code class="w">  </code><code class="n">balance_</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">interest</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>and the thread safety<a data-primary="Clang" data-type="indexterm" id="OEBPS/ch03.html.id1235"></a> has been destroyed.<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1236" id="OEBPS/ch03.html.id1236-marker">8</a></sup><a data-primary="data races" data-secondary="in C++" data-secondary-sortas="Cplus" data-startref="ix_daraceC" data-type="indexterm" id="OEBPS/ch03.html.id1237"></a><a data-primary="C++" data-secondary="data races in" data-startref="ix_Cpldarc" data-type="indexterm" id="OEBPS/ch03.html.id1238"></a></p>
</div></section>










<section data-pdf-bookmark="Data races in Rust" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id94">
<h3>Data races in Rust</h3>

<p>For a book about Rust, this Item <a data-primary="data races" data-secondary="in Rust" data-secondary-sortas="Rust" data-type="indexterm" id="OEBPS/ch03.html.ix_daraceRst"></a>has covered a lot of C++, so consider a straightforward translation of this class into
Rust:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">balance</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">balance</code>: <code class="mi">0</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">balance</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">panic!</code><code class="p">(</code><code class="s">"** Oh no, gone overdrawn: {}"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">deposit</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">amount</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">amount</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">withdraw</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">amount</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">amount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="w"> </code><code class="o">-=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="kc">true</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>along with the functions that try to pay into or withdraw from an account forever:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pay_in</code><code class="p">(</code><code class="n">account</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">BankAccount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">account</code><code class="p">.</code><code class="n">balance</code><code class="p">()</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">200</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">println!</code><code class="p">(</code><code class="s">"[A] Running low, deposit 400"</code><code class="p">);</code><code class="w"></code>
<code class="w">            </code><code class="n">account</code><code class="p">.</code><code class="n">deposit</code><code class="p">(</code><code class="mi">400</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">sleep</code><code class="p">(</code><code class="n">std</code>::<code class="n">time</code>::<code class="n">Duration</code>::<code class="n">from_millis</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">take_out</code><code class="p">(</code><code class="n">account</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">BankAccount</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">loop</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">account</code><code class="p">.</code><code class="n">withdraw</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">println!</code><code class="p">(</code><code class="s">"[B] Withdrew 100, balance now {}"</code><code class="p">,</code><code class="w"> </code><code class="n">account</code><code class="p">.</code><code class="n">balance</code><code class="p">());</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">println!</code><code class="p">(</code><code class="s">"[B] Failed to withdraw 100"</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">sleep</code><code class="p">(</code><code class="n">std</code>::<code class="n">time</code>::<code class="n">Duration</code>::<code class="n">from_millis</code><code class="p">(</code><code class="mi">20</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This works fine in a single-threaded context—even if that thread is not the main thread:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BankAccount</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">_payer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">pay_in</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">account</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="c1">// At the end of the scope, the `_payer` thread is detached</code>
<code class="w">    </code><code class="c1">// and is the sole owner of the `BankAccount`.</code>
<code class="p">}</code><code class="w"></code></pre>

<p>but a naive attempt to use the <code>BankAccount</code> across <a data-primary="multithreading" data-type="indexterm" id="OEBPS/ch03.html.id1239"></a>multiple threads:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1240">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BankAccount</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">_taker</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">take_out</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">account</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">_payer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">pay_in</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">account</code><code class="p">));</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>immediately falls foul of the compiler:</p>

<pre data-code-language="text" data-type="programlisting">error[E0382]: use of moved value: `account`
   --&gt; src/main.rs:102:41
    |
100 | let mut account = BankAccount::new();
    |     ----------- move occurs because `account` has type
    |                 `broken::BankAccount`, which does not implement the
    |                 `Copy` trait
101 | let _taker = std::thread::spawn(move || take_out(&amp;mut account));
    |                                 -------               ------- variable
    |                                 |                         moved due to
    |                                 |                         use in closure
    |                                 |
    |                                 value moved into closure here
102 | let _payer = std::thread::spawn(move || pay_in(&amp;mut account));
    |                                 ^^^^^^^             ------- use occurs due
    |                                 |                        to use in closure
    |                                 |
    |                                 value used here after move</pre>

<p>The rules of the borrow checker (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>) make the problem clear: there are two mutable references
to the same item, one more than is allowed.<a data-primary="mutable references" data-secondary="borrow checker rule for" data-type="indexterm" id="OEBPS/ch03.html.id1241"></a><a data-primary="borrow checker" data-secondary="borrowing rules" data-type="indexterm" id="OEBPS/ch03.html.id1242"></a>  The rules of the borrow checker are that you can have a single mutable
reference to an item, or multiple (immutable) references, but not both at the same time.</p>

<p>This has a curious <a data-primary="thread safety in Rust" data-type="indexterm" id="OEBPS/ch03.html.id1243"></a>resonance with the definition of a data race at the start of this Item: enforcing that there is a
single writer, or multiple readers (but never both), means that there can be no data races.  By enforcing memory safety,
<a href="https://oreil.ly/wKFxX">Rust gets thread safety “for free”</a>.</p>

<p>As with C++, some kind of  synchronization is needed to make this <code>struct</code>  thread-safe.<a data-primary="synchronization primitives" data-type="indexterm" id="OEBPS/ch03.html.id1244"></a><a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch03.html.id1245"></a> The most common
mechanism is also called  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, but the Rust version
“wraps” the protected data rather than being a standalone object (as in C++):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">balance</code>: <code class="nc">std</code>::<code class="n">sync</code>::<code class="n">Mutex</code><code class="o">&lt;</code><code class="kt">i64</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock()</code></a> method on this <code>Mutex</code> generic returns
a  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> object with RAII behavior, like C++’s
<code>std::lock_guard</code>: the mutex is automatically released at the end of the scope when the guard is <code>drop</code>ped.  (In
contrast to C++, Rust’s <code>Mutex</code> has <a data-primary="RAII (Resource Acquisition Is Initialization) pattern" data-type="indexterm" id="OEBPS/ch03.html.id1246"></a><a data-primary="MutexGuard type" data-type="indexterm" id="OEBPS/ch03.html.id1247"></a><a data-primary="locks" data-secondary="in Rust" data-secondary-sortas="Rust" data-type="indexterm" id="OEBPS/ch03.html.id1248"></a>no methods that manually acquire or release the mutex, as they would expose
developers to the danger of forgetting to keep these calls exactly in sync.)</p>

<p>To be more precise, <code>lock()</code> actually returns a <code>Result</code> that holds the <code>MutexGuard</code>, to cope with the possibility that
the <code>Mutex</code> has been <em>poisoned</em>.  <a data-primary="Result type" data-secondary="holding MutexGuard" data-type="indexterm" id="OEBPS/ch03.html.id1249"></a><a data-primary="poisoning (locks)" data-type="indexterm" id="OEBPS/ch03.html.id1250"></a>Poisoning happens if a thread fails while holding the lock, because this might mean
that any mutex-protected invariants can no longer be relied on.  In practice, lock poisoning is sufficiently rare (and
it’s sufficiently desirable that the program terminates when it happens) that it’s common to just <code>.unwrap()</code> the
<code>Result</code> (despite the advice in <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>).</p>

<p>The <code>MutexGuard</code> object also acts as a proxy for <a data-primary="DerefMut trait" data-type="indexterm" id="OEBPS/ch03.html.id1251"></a>the data that is enclosed by the <code>Mutex</code>, by implementing the <code>Deref</code> and <code>DerefMut</code> traits (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>), allowing it to be used both for read operations:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">balance</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">balance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">balance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">panic!</code><code class="p">(</code><code class="s">"** Oh no, gone overdrawn: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">balance</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="n">balance</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>and for write operations:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">BankAccount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Note: no longer needs `&amp;mut self`.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">deposit</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">amount</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">()</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">amount</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">withdraw</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">amount</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">balance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">balance</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="o">*</code><code class="n">balance</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">amount</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="o">*</code><code class="n">balance</code><code class="w"> </code><code class="o">-=</code><code class="w"> </code><code class="n">amount</code><code class="p">;</code><code class="w"></code>
<code class="w">        </code><code class="kc">true</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>There’s an interesting detail lurking in the signatures of these methods: although they are modifying the balance of the
<code>BankAccount</code>, the methods now take <code>&amp;self</code> rather than <code>&amp;mut self</code>.  <a data-primary="self keyword" data-type="indexterm" id="OEBPS/ch03.html.id1252"></a>This is inevitable: if multiple threads are going
to hold references to the same <code>BankAccount</code>, by the rules of the borrow checker, those references had better not be
mutable.<a data-primary="interior mutability" data-type="indexterm" id="OEBPS/ch03.html.id1253"></a>  It’s also another instance of the  <em>interior mutability</em> pattern described in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>: borrow checks are
effectively moved from compile time to runtime but now with cross-thread synchronization behavior.<a data-primary="borrow checker" data-secondary="checks moved from compile time to runtime" data-type="indexterm" id="OEBPS/ch03.html.id1254"></a>  If a mutable
reference already exists, an attempt to get a second blocks until the first reference is dropped.<a data-primary="lifetimes" data-secondary="issue with in multithreaded environment" data-type="indexterm" id="OEBPS/ch03.html.id1255"></a></p>

<p>Wrapping up shared state in a <code>Mutex</code> mollifies the borrow checker, but there are still lifetime issues (<a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>) to fix:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1256">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BankAccount</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">taker</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="n">take_out</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">payer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="n">pay_in</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="c1">// At the end of the scope, `account` is dropped but</code>
<code class="w">    </code><code class="c1">// the `_taker` and `_payer` threads are detached and</code>
<code class="w">    </code><code class="c1">// still hold (immutable) references to `account`.</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:206:40
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                                    ^^           ------- `account` is
    |                                    |                     borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:206:21
    |
206 |     let taker = std::thread::spawn(|| take_out(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
206 |     let taker = std::thread::spawn(move || take_out(&amp;account));
    |                                    ++++
error[E0373]: closure may outlive the current function, but it borrows `account`
              which is owned by the current function
   --&gt; src/main.rs:207:40
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                                    ^^         ------- `account` is
    |                                    |                  borrowed here
    |                                    |
    |                                    may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; src/main.rs:207:21
    |
207 |     let payer = std::thread::spawn(|| pay_in(&amp;account));
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other
      referenced variables), use the `move` keyword
    |
207 |     let payer = std::thread::spawn(move || pay_in(&amp;account));
    |                                    ++++</pre>

<p>The error message makes the problem clear: the <code>BankAccount</code> is going to be  <code>drop</code>ped at the end of the<a data-primary="dropping items" data-secondary="in multithreaded environment" data-type="indexterm" id="OEBPS/ch03.html.id1257"></a>
block, but there are two new threads that have a reference to it and that may carry on running afterward. (The
compiler’s suggestion for how to fix the problem is less helpful—if the <code>BankAccount</code> item is moved into
the first closure, it will no longer be available for the second closure to receive a reference to it!)</p>

<p>The standard tool <a data-primary="reference-counted pointers" data-type="indexterm" id="OEBPS/ch03.html.id1258"></a><a data-primary="Arc type" data-type="indexterm" id="OEBPS/ch03.html.id1259"></a>for ensuring that an object remains active until all references to it are gone is a reference-counted
pointer, and Rust’s variant of this for multithreaded use is
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">sync</code>::<code class="n">Arc</code>::<code class="n">new</code><code class="p">(</code><code class="n">BankAccount</code>::<code class="n">new</code><code class="p">());</code><code class="w"></code>
<code class="n">account</code><code class="p">.</code><code class="n">deposit</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">account2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">account</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">_taker</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">take_out</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account2</code><code class="p">));</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">account3</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">account</code><code class="p">.</code><code class="n">clone</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">_payer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">thread</code>::<code class="n">spawn</code><code class="p">(</code><code class="k">move</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="n">pay_in</code><code class="p">(</code><code class="o">&amp;</code><code class="n">account3</code><code class="p">));</code><code class="w"></code></pre>

<p>Each thread gets its own copy of the reference-counting pointer, moved into the closure, and the underlying
<code>BankAccount</code> will be <code>drop</code>ped only when the refcount drops to zero. This combination of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> is common in
Rust programs that use  shared-state parallelism.</p>

<p>Stepping back from the technical details, observe that Rust has entirely avoided the problem of data races that plagues
multithreaded programming in other languages.  Of course, this good news is restricted to <em>safe</em> Rust—<code>unsafe</code>
code (<a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>) and FFI boundaries in particular (<a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>) may not be data-race free—but it’s
still a remarkable phenomenon.</p>
</div></section>










<section data-pdf-bookmark="Standard marker traits" data-type="sect3"><div class="sect3" id="OEBPS/ch03.html.id95">
<h3>Standard marker traits</h3>

<p>There are two standard traits that affect the use of Rust objects between threads.<a data-primary="marker traits" data-secondary="standard, affecting use of Rust objects between threads" data-type="indexterm" id="OEBPS/ch03.html.id1260"></a><a data-primary="data races" data-secondary="in Rust" data-secondary-sortas="Rust" data-startref="ix_daraceRst" data-type="indexterm" id="OEBPS/ch03.html.id1261"></a>  Both of these traits are  <em>marker traits</em> (<a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>) that have no associated methods but have special significance to the compiler in
multithreaded scenarios:</p>

<ul>
<li>
<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> trait indicates that items of a type are safe
to transfer between threads; ownership of an item of this type can be passed from one thread to another.<a data-primary="Send trait" data-type="indexterm" id="OEBPS/ch03.html.id1262"></a></p>
</li>
<li>
<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait indicates that items of a type can be
safely accessed by multiple threads, subject to the rules of the borrow checker.<a data-primary="Sync trait" data-type="indexterm" id="OEBPS/ch03.html.id1263"></a><a data-primary="threading" data-secondary="Send/Sync marker traits and" data-type="indexterm" id="OEBPS/ch03.html.id1264"></a></p>
</li>
</ul>

<p>Another way of saying this is to observe that <code>Send</code> means <code>T</code> can be transferred between threads,
and <code>Sync</code> means that <code>&amp;T</code> can be transferred between threads.<a data-primary="auto traits" data-type="indexterm" id="OEBPS/ch03.html.id1265"></a></p>

<p>Both of these traits are  <a href="https://oreil.ly/7eeE7"><em>auto traits</em></a>: the compiler automatically
derives them for new types, as long as the constituent parts of the type also implement <code>Send</code>/<code>Sync</code>.</p>

<p>The majority of safe types implement <code>Send</code> and <code>Sync</code>, so much so that it’s clearer to understand what types <em>don’t</em>
implement these traits (written in the form <code>impl !Sync for Type</code>).</p>

<p>A type that doesn’t implement <code>Send</code> is one that can be used only in a single thread. The canonical example of this is
the unsynchronized reference-counting pointer <a class="orm:hideurl" href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>).
The implementation of this type explicitly <a data-primary="Rc type" data-secondary="not implementing Send" data-type="indexterm" id="OEBPS/ch03.html.id1266"></a>assumes single-threaded use (for speed); there is no attempt at synchronizing
the internal refcount for multithreaded use. As such, transferring an <code>Rc&lt;T&gt;</code> between threads is not allowed; use
<code>Arc&lt;T&gt;</code> (with its additional synchronization overhead) for this case.</p>

<p>A type that doesn’t implement <code>Sync</code> is one that’s not safe to use from multiple threads via <em>non</em>-<code>mut</code> references (as
the borrow checker will ensure there are never multiple <code>mut</code> references).<a data-primary="interior mutability" data-type="indexterm" id="OEBPS/ch03.html.id1267"></a><a data-primary="Cell type" data-secondary="not implementing Sync" data-type="indexterm" id="OEBPS/ch03.html.id1268"></a><a data-primary="RefCell type" data-secondary="not implementing Sync" data-type="indexterm" id="OEBPS/ch03.html.id1269"></a>  The canonical examples of this are the types
that provide <em>interior mutability</em> in an unsynchronized way, such as
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>.  Use <code>Mutex&lt;T&gt;</code> or
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> to provide interior mutability in a multithreaded
environment.<a data-primary="RwLock type" data-type="indexterm" id="OEBPS/ch03.html.id1270"></a><a data-primary="Mutex type" data-secondary="providing interior mutability in multithreaded environment" data-type="indexterm" id="OEBPS/ch03.html.id1271"></a><a data-primary="raw pointers" data-type="indexterm" id="OEBPS/ch03.html.id1272"></a></p>

<p>Raw  pointer types like <code>*const T</code> and <code>*mut T</code> also implement neither <code>Send</code> nor <code>Sync</code>; see Items <a href="#OEBPS/ch03.html.file_unsafe_md">16</a>
and <a href="#OEBPS/ch06.html.file_ffi_md">34</a>.</p>
</div></section>
</div></section>








<section data-pdf-bookmark="Deadlocks" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id96">
<h2>Deadlocks</h2>

<p>Now for the bad news.<a data-primary="shared-state parallelism" data-secondary="data races" data-startref="ix_SSpardarc" data-type="indexterm" id="OEBPS/ch03.html.id1273"></a><a data-primary="data races" data-startref="ix_darace" data-type="indexterm" id="OEBPS/ch03.html.id1274"></a>  Although Rust has solved the problem of data races (as previously described), it is still susceptible
to the <em>second</em> terrible problem for multithreaded code with shared state:  <em>deadlocks</em>.<a data-primary="shared-state parallelism" data-secondary="deadlocks" data-type="indexterm" id="OEBPS/ch03.html.ix_SSpardead"></a><a data-primary="deadlocks" data-type="indexterm" id="OEBPS/ch03.html.ix_deadl"></a><a data-primary="locks" data-seealso="deadlocks" data-type="indexterm" id="OEBPS/ch03.html.id1275"></a></p>

<p>Consider a simplified multiple-player game server, implemented as a multithreaded application to service many
players in parallel.  Two core data structures might be a collection of players, indexed by username,
and a collection of games in progress, indexed by some unique identifier:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">GameServer</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Map player name to player info.</code>
<code class="w">    </code><code class="n">players</code>: <code class="nc">Mutex</code><code class="o">&lt;</code><code class="n">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">Player</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Current games, indexed by unique game ID.</code>
<code class="w">    </code><code class="n">games</code>: <code class="nc">Mutex</code><code class="o">&lt;</code><code class="n">HashMap</code><code class="o">&lt;</code><code class="n">GameId</code><code class="p">,</code><code class="w"> </code><code class="n">Game</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Both of these data structures are <code>Mutex</code>-protected and so are safe from data races.<a data-primary="Mutex type" data-secondary="data structures protected by" data-type="indexterm" id="OEBPS/ch03.html.id1276"></a>  However, code that manipulates <em>both</em>
data structures opens up potential problems.  A single interaction between the two might work fine:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">GameServer</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Add a new player and join them into a current game.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">add_and_join</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">info</code>: <code class="nc">Player</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">GameId</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Add the new player.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">players</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">players</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">players</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">username</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"> </code><code class="n">info</code><code class="p">);</code><code class="w"></code>

<code class="w">        </code><code class="c1">// Find a game with available space for them to join.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">games</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">games</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="n">game</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">games</code><code class="p">.</code><code class="n">iter_mut</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="n">game</code><code class="p">.</code><code class="n">add_player</code><code class="p">(</code><code class="n">username</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">id</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="nb">None</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, a second interaction between the two independently locked data structures is where problems start:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">GameServer</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Ban the player identified by `username`, removing them from</code>
<code class="w">    </code><code class="sd">/// any current games.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">ban_player</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Find all games that the user is in and remove them.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">games</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">games</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">games</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">iter_mut</code><code class="p">()</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="p">(</code><code class="n">_id</code><code class="p">,</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">g</code><code class="p">.</code><code class="n">has_player</code><code class="p">(</code><code class="n">username</code><code class="p">))</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">for_each</code><code class="p">(</code><code class="o">|</code><code class="p">(</code><code class="n">_id</code><code class="p">,</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">g</code><code class="p">.</code><code class="n">remove_player</code><code class="p">(</code><code class="n">username</code><code class="p">));</code><code class="w"></code>

<code class="w">        </code><code class="c1">// Wipe them from the user list.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">players</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">players</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">players</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">username</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>To<a data-primary="threads" data-secondary="deadlock sequence" data-type="indexterm" id="OEBPS/ch03.html.id1277"></a> understand the problem, imagine two separate threads using these two methods, where their execution happens in the
order shown in <a data-type="xref" href="#OEBPS/ch03.html.table_3_1">Table&nbsp;3-1</a>.</p>
<table id="OEBPS/ch03.html.table_3_1">
<caption><span class="label">Table 3-1. </span>Thread deadlock sequence</caption>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Enters <code>add_and_join()</code> and immediately<br><br> acquires the <code>players</code> lock.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td><p>Enters <code>ban_player()</code> and immediately<br><br> acquires the <code>games</code> lock.</p></td>
</tr>
<tr>
<td><p>Tries to acquire the <code>games</code> lock; this is held <br><br>by thread 2, so thread 1 blocks.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td><p>Tries to acquire the <code>players</code> lock; this is held <br><br>by thread 1, so thread 2 blocks.</p></td>
</tr>
</tbody>
</table>

<p>At this point, the program is  <em>deadlocked</em>: neither thread will ever progress, nor will any other
thread that does anything with either of the two <code>Mutex</code>-protected data structures.</p>

<p>The root <a data-primary="lock inversion" data-type="indexterm" id="OEBPS/ch03.html.id1278"></a>cause of this is a  <em>lock inversion</em>: one function acquires the locks in the order <code>players</code> then <code>games</code>,
whereas the other uses the opposite order (<code>games</code> then <code>players</code>).  This is a simple example of a more general problem;
the same situation can arise with longer chains of nested locks (thread 1 acquires lock A, then B, then it tries to acquire
C; thread 2 acquires C, then tries to acquire A) and across more threads (thread 1 locks A, then B; thread 2 locks B, then
C; thread 3 locks C, then A).</p>

<p>A simplistic attempt to <a data-primary="scope" data-secondary="reducing for locks" data-type="indexterm" id="OEBPS/ch03.html.id1279"></a><a data-primary="locks" data-secondary="reducing scope to prevent deadlocks" data-type="indexterm" id="OEBPS/ch03.html.id1280"></a>solve this problem involves reducing the scope of the locks, so there is no point where both
locks are held at the same time:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Add a new player and join them into a current game.</code>
<code class="k">fn</code> <code class="nf">add_and_join</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">,</code><code class="w"> </code><code class="n">info</code>: <code class="nc">Player</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">GameId</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Add the new player.</code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">players</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">players</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">players</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">username</code><code class="p">.</code><code class="n">to_owned</code><code class="p">(),</code><code class="w"> </code><code class="n">info</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Find a game with available space for them to join.</code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">games</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">games</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="n">game</code><code class="p">)</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">games</code><code class="p">.</code><code class="n">iter_mut</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="n">game</code><code class="p">.</code><code class="n">add_player</code><code class="p">(</code><code class="n">username</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">id</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="nb">None</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="sd">/// Ban the player identified by `username`, removing them from</code>
<code class="sd">/// any current games.</code>
<code class="k">fn</code> <code class="nf">ban_player</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">username</code>: <code class="kp">&amp;</code><code class="kt">str</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Find all games that the user is in and remove them.</code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">games</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">games</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">games</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">iter_mut</code><code class="p">()</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">filter</code><code class="p">(</code><code class="o">|</code><code class="p">(</code><code class="n">_id</code><code class="p">,</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">g</code><code class="p">.</code><code class="n">has_player</code><code class="p">(</code><code class="n">username</code><code class="p">))</code><code class="w"></code>
<code class="w">            </code><code class="p">.</code><code class="n">for_each</code><code class="p">(</code><code class="o">|</code><code class="p">(</code><code class="n">_id</code><code class="p">,</code><code class="w"> </code><code class="n">g</code><code class="p">)</code><code class="o">|</code><code class="w"> </code><code class="n">g</code><code class="p">.</code><code class="n">remove_player</code><code class="p">(</code><code class="n">username</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Wipe them from the user list.</code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">players</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">players</code><code class="p">.</code><code class="n">lock</code><code class="p">().</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">        </code><code class="n">players</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">username</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>(A better version of this would be to encapsulate the manipulation of the <code>players</code> data structure into <code>add_player()</code>
and <code>remove_player()</code> helper methods, to reduce the chances of forgetting to close out a scope.)</p>

<p>This solves the deadlock problem but<a data-primary="state inconsistency sequence" data-type="indexterm" id="OEBPS/ch03.html.id1281"></a> leaves behind a data consistency problem: the <code>players</code> and <code>games</code> data
structures can get out of sync with each other, given an execution sequence like the one shown in <a data-type="xref" href="#OEBPS/ch03.html.table_3_2">Table&nbsp;3-2</a>.</p>
<table id="OEBPS/ch03.html.table_3_2">
<caption><span class="label">Table 3-2. </span>State inconsistency sequence</caption>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Enters <code>add_and_join("Alice")</code> and adds Alice to the <br><br><code>players</code> data structure (then releases the <code>players</code> lock).</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td><p>Enters <code>ban_player("Alice")</code> and removes Alice from all <code>games</code> (then releases the <code>games</code> lock).</p></td>
</tr>
<tr>
<td></td>
<td><p>Removes Alice from the <code>players</code> data structure; thread 1 has already released the lock, so this does not block.</p></td>
</tr>
<tr>
<td><p>Carries on and acquires the <code>games</code> lock (already released by <br><br>thread 2). With the lock held,  adds “Alice” to a game in progress.</p></td>
<td></td>
</tr>
</tbody>
</table>

<p>At this point, there is a game that includes a player that doesn’t exist, according to the <code>players</code> data structure!</p>

<p>The heart of the problem is that there are two data structures that need to be kept in sync with each other.<a data-primary="synchronization primitives" data-secondary="keeping two data structures in sync" data-type="indexterm" id="OEBPS/ch03.html.id1282"></a>  The
best way to do this is to have a single synchronization primitive that covers both of them:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">struct</code> <code class="nc">GameState</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">players</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">Player</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">games</code>: <code class="nc">HashMap</code><code class="o">&lt;</code><code class="n">GameId</code><code class="p">,</code><code class="w"> </code><code class="n">Game</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">struct</code> <code class="nc">GameServer</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">state</code>: <code class="nc">Mutex</code><code class="o">&lt;</code><code class="n">GameState</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>








<section data-pdf-bookmark="Advice" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id97">
<h2>Advice</h2>

<p>The most obvious advice for avoiding the problems that arise with shared-state parallelism is simply to avoid
shared-state parallelism.<a data-primary="shared-state parallelism" data-secondary="deadlocks" data-startref="ix_SSpardead" data-type="indexterm" id="OEBPS/ch03.html.id1283"></a><a data-primary="deadlocks" data-startref="ix_deadl" data-type="indexterm" id="OEBPS/ch03.html.id1284"></a><a data-primary="shared-state parallelism" data-secondary="advice for avoiding problems with" data-type="indexterm" id="OEBPS/ch03.html.id1285"></a><a data-primary="Go" data-type="indexterm" id="OEBPS/ch03.html.id1286"></a>  The <a class="orm:hideurl" href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">Rust book</a> quotes from the
 <a href="https://oreil.ly/HiKmp">Go language documentation</a>: “Do not communicate by
sharing memory; instead, share memory by communicating.”</p>

<p>The Go language has  <em>channels</em> that are suitable for this <a href="https://oreil.ly/uBPhZ">built into the language</a>; for Rust, equivalent functionality is included in the standard library
in the  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code> module</a>: the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>channel()</code> function</a> returns a <code>(Sender, Receiver)</code> pair that allows
values of a particular type to be communicated between threads.<a data-primary="Sender/Receiver pair" data-type="indexterm" id="OEBPS/ch03.html.id1287"></a><a data-primary="Receiver" data-type="indexterm" id="OEBPS/ch03.html.id1288"></a><a data-primary="channels (Go)" data-type="indexterm" id="OEBPS/ch03.html.id1289"></a></p>

<p>If shared-state concurrency can’t be avoided, then there are some ways to reduce the chances of <a data-primary="deadlocks" data-secondary="reducing chance of in shared-state parallelism" data-type="indexterm" id="OEBPS/ch03.html.id1290"></a>writing deadlock-prone
code:</p>

<ul>
<li>
<p><em>Put data structures that must be kept consistent with each other under a single lock</em>.</p>
</li>
<li>
<p><em>Keep lock scopes small and obvious</em>; wherever possible, use helper methods that get and set things under the
relevant lock.<a data-primary="scope" data-secondary="locks, keeping small and obvious" data-type="indexterm" id="OEBPS/ch03.html.id1291"></a><a data-primary="locks" data-type="indexterm" id="OEBPS/ch03.html.id1292"></a></p>
</li>
<li>
<p><em>Avoid invoking closures with locks held</em>; this puts the code at the mercy of whatever closure gets added to
the codebase in the future.<a data-primary="closures" data-secondary="with locks held, avoiding invoking" data-secondary-sortas="locks" data-type="indexterm" id="OEBPS/ch03.html.id1293"></a></p>
</li>
<li>
<p>Similarly, <em>avoid returning a <code>MutexGuard</code> to a caller</em>: it’s like handing out a loaded gun, from a deadlock
perspective.<a data-primary="MutexGuard type" data-type="indexterm" id="OEBPS/ch03.html.id1294"></a></p>
</li>
<li>
<p><em>Include deadlock detection tools</em> in your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>), such as
<a class="orm:hideurl" href="https://docs.rs/no_deadlocks"><code>no_deadlocks</code></a>,
<a class="orm:hideurl" href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>, or
<a class="orm:hideurl" href="https://amanieu.github.io/parking_lot/parking_lot/deadlock/index.html"><code>parking_lot::deadlock</code></a>.</p>
</li>
<li>
<p>As a last resort: design, document, test, and police a  <em>locking hierarchy</em> that describes what lock orderings are
allowed/required. <a data-primary="locking hierarchy" data-type="indexterm" id="OEBPS/ch03.html.id1295"></a><a data-primary="no_deadlocks crate" data-type="indexterm" id="OEBPS/ch03.html.id1296"></a><a data-primary="parking_lot::deadlock" data-type="indexterm" id="OEBPS/ch03.html.id1297"></a><a data-primary="ThreadSanitizer" data-type="indexterm" id="OEBPS/ch03.html.id1298"></a>This should be a last resort because any strategy that relies on engineers never making a mistake is
likely to be doomed to failure in the long term.</p>
</li>
</ul>

<p>More <a data-primary="multithreading" data-secondary="general advice on multithreaded code" data-type="indexterm" id="OEBPS/ch03.html.id1299"></a>abstractly, multithreaded code is an ideal place to apply the following general advice: prefer code that’s so simple that
it is obviously not wrong, rather than code that’s so complex that it’s not obviously wrong.<a data-primary="shared-state parallelism" data-startref="ix_SSpar" data-type="indexterm" id="OEBPS/ch03.html.id1300"></a></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 18: Don’t panic" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_panic_md">
<h1>Item 18: Don’t panic</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>It looked insanely complicated, and this was one of the reasons why the snug plastic cover it fitted into had
the words DON’T PANIC printed on it in large friendly letters.</p>
<p data-type="attribution">Douglas Adams</p>
</blockquote>

<p>The title of this Item would be more accurately described as <em>prefer returning a  <code>Result</code> to using
 <code>panic!</code></em> (but <em>don’t panic</em> is much catchier).<a data-primary="Adams, Douglas" data-type="indexterm" id="OEBPS/ch03.html.id1301"></a><a data-primary="panics" data-type="indexterm" id="OEBPS/ch03.html.ix_panic"></a></p>

<p>Rust’s panic mechanism is primarily designed for unrecoverable bugs in your program, and <em>by default</em> it terminates the
thread that issues the <code>panic!</code>.  However, there are alternatives to this default.<a data-primary="panics" data-secondary="default behavior and alternatives to" data-type="indexterm" id="OEBPS/ch03.html.id1302"></a></p>

<p>In particular, newcomers to Rust who have come from languages that have an  exception system (such as  Java or
 C++) sometimes pounce on
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind</code></a> as a way to
simulate exceptions, because it appears to provide a mechanism for catching panics at a point further up the call stack.<a data-primary="Java" data-type="indexterm" id="OEBPS/ch03.html.id1303"></a><a data-primary="C++" data-secondary="exception system" data-type="indexterm" id="OEBPS/ch03.html.id1304"></a><a data-primary="exceptions, panic! and" data-type="indexterm" id="OEBPS/ch03.html.id1305"></a></p>

<p>Consider a function that panics on an invalid input:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">divide</code><code class="p">(</code><code class="n">a</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">panic!</code><code class="p">(</code><code class="s">"Cowardly refusing to divide by zero!"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="n">a</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">b</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Trying to invoke this with an invalid input fails as expected:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Attempt to discover what 0/0 is...</code>
<code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">divide</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">thread 'main' panicked at 'Cowardly refusing to divide by zero!', main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</pre>

<p>A wrapper that uses  <code>catch_unwind</code> to <a data-primary="catch_unwind" data-type="indexterm" id="OEBPS/ch03.html.id1306"></a>catch the panic:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">divide_recover</code><code class="p">(</code><code class="n">a</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kt">i64</code><code class="p">,</code><code class="w"> </code><code class="n">default</code>: <code class="kt">i64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">panic</code>::<code class="n">catch_unwind</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="n">divide</code><code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="nb">Err</code><code class="p">(</code><code class="n">_</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">default</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p><em>appears</em> to work and to simulate  <code>catch</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">divide_recover</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"result = {result}"</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">result = 42</pre>

<p>Appearances can be deceptive, however.  The first problem with this approach is that panics don’t always unwind; there
is a <a class="orm:hideurl" href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic">compiler option</a> (which is also accessible via a
 <em>Cargo.toml</em> <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/profiles.html#panic">profile setting</a>) that shifts panic
behavior so that it immediately aborts the process:</p>

<pre data-code-language="text" data-type="programlisting">thread 'main' panicked at 'Cowardly refusing to divide by zero!', main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
/bin/sh: line 1: 29100 Abort trap: 6  cargo run --release</pre>

<p>This leaves any attempt to simulate exceptions entirely at the mercy of the wider project settings. It’s also the case
that some target platforms (for example, WebAssembly) <em>always</em> abort on panic, regardless of any compiler or
project settings.<a data-primary="aborting on panic" data-type="indexterm" id="OEBPS/ch03.html.id1307"></a></p>

<p>A more subtle problem that’s surfaced by panic handling is  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Exception_safety"><em>exception safety</em></a>: if a panic occurs midway through an operation on a data
structure, it removes any guarantees that the data structure has been left in a self-consistent state.  <a data-primary="exception safety" data-type="indexterm" id="OEBPS/ch03.html.id1308"></a><a data-primary="invariants" data-secondary="internal, preserving in presence of exceptions" data-type="indexterm" id="OEBPS/ch03.html.id1309"></a><a data-primary="Cargill, Tom" data-type="indexterm" id="OEBPS/ch03.html.id1310"></a><a data-primary="C++" data-secondary="exception safety for template code" data-type="indexterm" id="OEBPS/ch03.html.id1311"></a><a data-primary="templates (C++)" data-type="indexterm" id="OEBPS/ch03.html.id1312"></a>Preserving
internal invariants in the presence of exceptions has been known to be extremely difficult since the 1990s;<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1313" id="OEBPS/ch03.html.id1313-marker">9</a></sup> this is one of the main reasons why <a href="https://oreil.ly/Bc-_z">Google (famously) bans the use of exceptions in its C++ code</a>.</p>

<p>Finally, panic propagation also <a href="https://oreil.ly/flAtD">interacts poorly</a> with
 FFI (foreign function interface) boundaries (<a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>); <em>use <code>catch_unwind</code> to prevent panics in Rust
code from propagating to non-Rust calling code</em> across an FFI boundary.<a data-primary="FFI (foreign-function interface)" data-secondary="panic propagation interacting badly with FFI bounds" data-type="indexterm" id="OEBPS/ch03.html.id1314"></a></p>

<p>So <a data-primary="panics" data-secondary="alternative to for dealing with error conditions" data-type="indexterm" id="OEBPS/ch03.html.id1315"></a>what’s the alternative to <code>panic!</code> for dealing with error conditions?  For library code, the best alternative is to
make the error <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Somebody_else%27s_problem">someone else’s problem</a>, by returning a
 <code>Result</code> with an appropriate error type (<a href="#OEBPS/ch01.html.file_errors_md">Item 4</a>).  This allows the <a data-primary="Result type" data-secondary="returning with proper error type instead of panic!" data-type="indexterm" id="OEBPS/ch03.html.id1316"></a>library user to make their own decisions
about what to do next—which may involve passing the problem on to the next caller in line, via the <code>?</code> operator.<a data-primary="? (question mark) operator" data-secondary="using to pass error on to next caller" data-type="indexterm" id="OEBPS/ch03.html.id1317"></a></p>

<p>The buck has to stop somewhere, and a useful rule of thumb is that it’s OK to <code>panic!</code> (or to <code>unwrap()</code>, <code>expect()</code>,
etc.) if you have control of  <code>main</code>; at that point, there’s no further caller that the buck could be passed to.<a data-primary="main function" data-type="indexterm" id="OEBPS/ch03.html.id1318"></a><a data-primary="expect method" data-type="indexterm" id="OEBPS/ch03.html.id1319"></a><a data-primary="unwrap method" data-type="indexterm" id="OEBPS/ch03.html.id1320"></a><a data-primary="panic! macro" data-secondary="sensible uses of" data-type="indexterm" id="OEBPS/ch03.html.id1321"></a></p>

<p>Another sensible use of <code>panic!</code>, even in library code, is in situations where it’s very rare to encounter errors, and
you don’t want users to have to litter their code with <code>.unwrap()</code> calls.</p>

<p>If an error situation <em>should</em> occur only because (say) internal data is corrupted, rather than as a result of invalid
inputs, then triggering a <code>panic!</code> is legitimate.</p>

<p>It can even be occasionally useful to allow panics that can be triggered by invalid input but where such invalid inputs
are out of the ordinary.<a data-primary="panic! macro" data-secondary="entrypoints triggering" data-type="indexterm" id="OEBPS/ch03.html.id1322"></a>  This works best when the relevant entrypoints come in pairs:</p>

<ul>
<li>
<p>An “infallible” version whose signature implies it always succeeds (and which panics if it can’t succeed)</p>
</li>
<li>
<p>A “fallible” version that returns a <code>Result</code></p>
</li>
</ul>

<p>For the former, Rust’s <a href="https://oreil.ly/vXxDV">API guidelines</a>
suggest that the <code>panic!</code> should be documented in a specific section of the inline documentation (<a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a>).<a data-primary="API guidelines" data-type="indexterm" id="OEBPS/ch03.html.id1323"></a></p>

<p>The
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_unchecked"><code>String::from_utf8_unchecked</code></a>
and  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a>
entrypoints in the standard library are an example of the latter (although in this case, the panics are actually
deferred to the point where a <code>String</code> constructed from invalid input gets used).<a data-primary="String::from_utf8" data-type="indexterm" id="OEBPS/ch03.html.id1324"></a><a data-primary="String::from_utf8_unchecked" data-type="indexterm" id="OEBPS/ch03.html.id1325"></a></p>

<p>Assuming that you are trying to comply with the advice in this Item, there are a few things to bear in mind.  <a data-primary="panics" data-secondary="avoiding" data-type="indexterm" id="OEBPS/ch03.html.id1326"></a>The first
is that panics can appear in different guises; avoiding <code>panic!</code> also involves avoiding the<a data-primary="unreachable! macro" data-type="indexterm" id="OEBPS/ch03.html.id1327"></a><a data-primary="expect_err method" data-type="indexterm" id="OEBPS/ch03.html.id1328"></a><a data-primary="unwrap_err method" data-type="indexterm" id="OEBPS/ch03.html.id1329"></a> following:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap()</code></a> and
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err()</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect()</code></a> and
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err"><code>expect_err()</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!()</code></a></p>
</li>
</ul>

<p class="pagebreak-before less_space">Harder to spot are things <a data-primary="slices" data-type="indexterm" id="OEBPS/ch03.html.id1330"></a>like these:</p>

<ul>
<li>
<p><code>slice[index]</code> when the index is out of range</p>
</li>
<li>
<p><code>x / y</code> when <code>y</code> is zero<a data-primary="dividing by zero" data-type="indexterm" id="OEBPS/ch03.html.id1331"></a></p>
</li>
</ul>

<p>The second observation around avoiding panics is that a plan that involves  constant
vigilance of humans is never a good idea.</p>

<p>However, constant vigilance of machines is another matter: adding a check to your continuous integration (see <a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>)
system that spots new, potentially panicking code is much more reliable.<a data-primary="no_panic crate" data-type="indexterm" id="OEBPS/ch03.html.id1332"></a><a data-primary="continuous integration" data-secondary="check spotting new potentially panicking code" data-type="indexterm" id="OEBPS/ch03.html.id1333"></a>  A simple version could be a simple grep for the
most common panicking entrypoints (as shown previously); a more thorough check could involve additional tooling from the Rust
ecosystem (<a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a>), such as setting up a build variant that pulls in the  <a class="orm:hideurl" href="https://docs.rs/no-panic"><code>no_panic</code></a>
crate.<a data-primary="panics" data-startref="ix_panic" data-type="indexterm" id="OEBPS/ch03.html.id1334"></a></p>
</div></section>






<section data-pdf-bookmark="Item 19: Avoid reflection" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_reflection_md">
<h1>Item 19: Avoid reflection</h1>

<p>Programmers coming to Rust from other languages are often used to reaching for  reflection as a tool in their toolbox.<a data-primary="reflection" data-type="indexterm" id="OEBPS/ch03.html.ix_reflct"></a>
They can waste a lot of time trying to implement reflection-based designs in Rust, only to discover that what they’re
attempting can only be done poorly, if at all.  This Item hopes to save that time wasted exploring dead ends, by
describing what Rust does and doesn’t have in the way of reflection, and what can be used instead.</p>

<p><em>Reflection</em> is the ability of a program to examine itself at runtime.  Given an item at runtime, it covers these questions:</p>

<ul>
<li>
<p>What information can be determined about the item’s type?</p>
</li>
<li>
<p>What can be done with that information?</p>
</li>
</ul>

<p>Programming languages with full reflection support have extensive answers to these questions.<a data-primary="reflection" data-secondary="languages with full reflection support" data-type="indexterm" id="OEBPS/ch03.html.id1335"></a>  Languages with reflection
typically support some or all of the following at runtime, based on the reflection information:</p>

<ul>
<li>
<p>Determining an item’s type</p>
</li>
<li>
<p>Exploring its contents</p>
</li>
<li>
<p>Modifying its fields</p>
</li>
<li>
<p>Invoking its methods</p>
</li>
</ul>

<p>Languages<a data-primary="dynamically typed languages" data-type="indexterm" id="OEBPS/ch03.html.id1336"></a><a data-primary="Python" data-type="indexterm" id="OEBPS/ch03.html.id1337"></a><a data-primary="Java" data-type="indexterm" id="OEBPS/ch03.html.id1338"></a><a data-primary="Go" data-type="indexterm" id="OEBPS/ch03.html.id1339"></a> that have this level of reflection support also <em>tend</em> to
be dynamically typed languages (e.g., <a class="orm:hideurl" href="https://docs.python.org/3/library/types.html#module-types">Python</a>,
Ruby), but there are also some notable <a data-primary="statically typed languages" data-secondary="supporting reflection" data-type="indexterm" id="OEBPS/ch03.html.id1340"></a>statically typed languages that also support reflection, particularly
 <a class="orm:hideurl" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html">Java</a> and
 <a class="orm:hideurl" href="https://golang.org/pkg/reflect/">Go</a>.</p>

<p>Rust does not support this type of reflection, which makes the advice to <em>avoid reflection</em> easy to follow at this
level—it’s just not possible.  For programmers coming from languages with support for full reflection, this
absence may seem like a significant gap at first, but Rust’s other features provide alternative ways of solving many of
the same problems.<a data-primary="RTTI (run-time type identification)" data-type="indexterm" id="OEBPS/ch03.html.id1341"></a><a data-primary="C++" data-secondary="run-time type identification (RTTI)" data-type="indexterm" id="OEBPS/ch03.html.id1342"></a></p>

<p>C++ has a more limited form of reflection, known as  <em>run-time type identification</em> (RTTI).  The <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a> operator returns a unique identifier
for every type, for <a data-primary="polymorphic type" data-type="indexterm" id="OEBPS/ch03.html.id1343"></a>objects of <em>polymorphic type</em> (roughly: classes with virtual functions):</p>
<dl>
<dt><code>typeid</code></dt>
<dd>
<p>Can recover the concrete class of an object referred to via a base class reference<a data-primary="typeid (C++)" data-type="indexterm" id="OEBPS/ch03.html.id1344"></a></p>
</dd>
<dt><a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/language/dynamic_cast"><code>dynamic_cast&lt;T&gt;</code></a></dt>
<dd>
<p>Allows base
class references to be converted to derived classes, when it is safe and correct to do so<a data-primary="dynamic_cast (C++)" data-type="indexterm" id="OEBPS/ch03.html.id1345"></a></p>
</dd>
</dl>

<p>Rust does not support this RTTI style of reflection either, continuing the theme that the advice of this Item is easy to
follow.</p>

<p>Rust does support some features that provide <em>similar</em> functionality in the
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/index.html"><code>std::any</code></a> module, but they’re limited (in ways we will explore) and so
best avoided unless no other alternatives are possible.<a data-primary="reflection" data-secondary="reflection-like features in Rust" data-type="indexterm" id="OEBPS/ch03.html.id1346"></a><a data-primary="std::any:tname" data-type="indexterm" id="OEBPS/ch03.html.id1347"></a></p>

<p>The first reflection-like feature from <code>std::any</code> <em>looks</em> like magic at first—a way of determining the name of an
item’s type.  The following example uses a user-defined <code>tname()</code> function:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">42</code><code class="k">u32</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">];</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"x: {} = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">tname</code><code class="p">(</code><code class="o">&amp;</code><code class="n">x</code><code class="p">),</code><code class="w"> </code><code class="n">x</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"y: {} = {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">tname</code><code class="p">(</code><code class="o">&amp;</code><code class="n">y</code><code class="p">),</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"></code></pre>

<p>to show types alongside values:</p>

<pre data-code-language="text" data-type="programlisting">x: u32 = 42
y: alloc::vec::Vec&lt;i32&gt; = [3, 4, 2]</pre>

<p>The implementation of <code>tname()</code> reveals what’s up the compiler’s sleeve: the function is generic
(as per <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>), and so each invocation of it is actually a  different function (<code>tname::&lt;u32&gt;</code>
or <code>tname::&lt;Square&gt;</code>):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">tname</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="p">(</code><code class="n">_v</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="kt">str</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">std</code>::<code class="n">any</code>::<code class="n">type_name</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p class="pagebreak-before less_space">The implementation is provided by the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/fn.type_name.html"><code>std::any::type_name&lt;T&gt;</code></a> library
function, which is also generic.  <a data-primary="trait objects" data-type="indexterm" id="OEBPS/ch03.html.id1348"></a><a data-primary="std::any::type_name" data-type="indexterm" id="OEBPS/ch03.html.id1349"></a>This function has access only to <em>compile-time</em> information; there is no code run that
determines the type at runtime.  Returning to the trait object types used in <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a> demonstrates this:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code>::<code class="n">new</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">shape</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code>

<code class="fm">println!</code><code class="p">(</code><code class="s">"square: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">tname</code><code class="p">(</code><code class="o">&amp;</code><code class="n">square</code><code class="p">));</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"shape: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">tname</code><code class="p">(</code><code class="o">&amp;</code><code class="n">shape</code><code class="p">));</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"draw: {}"</code><code class="p">,</code><code class="w"> </code><code class="n">tname</code><code class="p">(</code><code class="o">&amp;</code><code class="n">draw</code><code class="p">));</code><code class="w"></code></pre>

<p>Only the types of the trait objects are available, not the type (<code>Square</code>) of the concrete underlying item:</p>

<pre data-code-language="text" data-type="programlisting">square: reflection::Square
shape: &amp;dyn reflection::Shape
draw: &amp;dyn reflection::Draw</pre>

<p>The string returned by <code>type_name</code> is suitable only for diagnostics—it’s explicitly a “best-effort” helper whose
contents may change and may not be unique—so <em>don’t attempt to parse <code>type_name</code> results</em>.<a data-primary="TypeId" data-type="indexterm" id="OEBPS/ch03.html.id1350"></a> If you
need a globally unique type identifier, use  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a>
instead:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">any</code>::<code class="n">TypeId</code><code class="p">;</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">type_id</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">'</code><code class="nb">static</code> <code class="o">+</code><code class="w"> </code><code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="p">(</code><code class="n">_v</code>: <code class="kp">&amp;</code><code class="nc">T</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">TypeId</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">TypeId</code>::<code class="n">of</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">println!</code><code class="p">(</code><code class="s">"x has {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">type_id</code><code class="p">(</code><code class="o">&amp;</code><code class="n">x</code><code class="p">));</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"y has {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">type_id</code><code class="p">(</code><code class="o">&amp;</code><code class="n">y</code><code class="p">));</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">x has TypeId { t: 18349839772473174998 }
y has TypeId { t: 2366424454607613595 }</pre>

<p>The output is less helpful for humans, but the guarantee of uniqueness means that the result can be used in code.
However, it’s usually best not to use <code>TypeId</code> directly but to use the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>std::any::Any</code></a> trait instead, because the standard
library has additional functionality for working with <code>Any</code> instances (described below).<a data-primary="Any trait" data-type="indexterm" id="OEBPS/ch03.html.id1351"></a></p>

<p>The <code>Any</code> trait has a single method <a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id"><code>type_id()</code></a>,
which returns the <code>TypeId</code> value for the type that implements the trait. You can’t implement this trait yourself, though,
because <code>Any</code> already comes with a  blanket implementation for most arbitrary types <code>T</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="o">&lt;</code><code class="n">T</code>: <code class="o">'</code><code class="nb">static</code> <code class="o">+</code><code class="w"> </code><code class="o">?</code><code class="nb">Sized</code><code class="o">&gt;</code><code class="w"> </code><code class="n">Any</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">type_id</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">TypeId</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">TypeId</code>::<code class="n">of</code>::<code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The blanket implementation doesn’t cover <em>every</em> type <code>T</code>: the <code>T: 'static</code>  <em>lifetime bound</em> means<a data-primary="lifetime bound" data-type="indexterm" id="OEBPS/ch03.html.id1352"></a> that if <code>T</code>
includes any references that have a non-<code>'static</code> lifetime, then <code>TypeId</code> is not implemented for <code>T</code>.  This is a
<a href="https://oreil.ly/BjglR">deliberate restriction</a> that’s imposed because lifetimes aren’t fully
part of the type: <code>TypeId::of::&lt;&amp;'a T&gt;</code> would be the same as <code>TypeId::of::&lt;&amp;'b T&gt;</code>, despite the differing lifetimes,
increasing the likelihood of confusion and unsound code.</p>

<p>Recall from <a href="#OEBPS/ch01.html.file_references_md">Item 8</a> that a trait object is a fat pointer that holds a pointer to the underlying item,
together <a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch03.html.id1353"></a><a data-primary="vtable" data-secondary="entry for Any" data-type="indexterm" id="OEBPS/ch03.html.id1354"></a>with a pointer to the trait implementation’s  vtable.  For <code>Any</code>, the vtable has a single entry, for a
<code>type_id()</code> method that returns the item’s type, as shown in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_4">Figure&nbsp;3-4</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x_any</code>: <code class="nb">Box</code><code class="o">&lt;</code><code class="k">dyn</code><code class="w"> </code><code class="n">Any</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="mi">42</code><code class="k">u64</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y_any</code>: <code class="nb">Box</code><code class="o">&lt;</code><code class="k">dyn</code><code class="w"> </code><code class="n">Any</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">Square</code>::<code class="n">new</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">));</code><code class="w"></code></pre>

<figure><div class="figure" id="OEBPS/ch03.html.fig_3_4">
<img alt="The diagram shows a stack on the left, some concrete items in the middle, and some vtables and code objects on the right hand side.  The stack part has two trait objects labelled x_any and y_any. The x_any trait object has an arrow to a concrete item with value 42 in the middle; it also has an arrow to an Any for u64 vtable on the right hand side. This vtable has a single type_id entry, which in turn points to a code object labelled return TypeId::of::<u64>. The y_any trait object has an arrow to a concrete item that is composite, with components top_left.x=3, top_left.y=4 and size=3; it also has an arrow to an Any for Square vtable on the right hand side. This vtable has a single type_id entry, which in turn points to a code object labelled return TypeId::of::<Square>." src="data:image/png;base64,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">
<h6><span class="label">Figure 3-4. </span><code>Any</code> trait objects, each with pointers to concrete items and vtables</h6>
</div></figure>

<p class="pagebreak-before less_space">Aside from a couple of indirections, a <code>dyn Any</code> trait object is effectively a combination of a raw pointer and a type
identifier.  This means that the standard library can offer some additional  generic methods that are defined for a
<code>dyn Any</code> trait object; these methods are generic over some additional type <code>T</code>:</p>
<dl>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is::&lt;T&gt;()</code></a></dt>
<dd>
<p>Indicates whether the trait<a data-primary="is method" data-type="indexterm" id="OEBPS/ch03.html.id1355"></a>
object’s type is equal to some specific other type <code>T</code></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref::&lt;T&gt;()</code></a></dt>
<dd>
<p>Returns a reference to the concrete type <code>T</code>, provided that <a data-primary="downcast_ref method" data-type="indexterm" id="OEBPS/ch03.html.id1356"></a>the trait object’s type matches <code>T</code></p>
</dd>
<dt><a class="orm:hideurl" href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut"><code>downcast_mut::&lt;T&gt;()</code></a></dt>
<dd>
<p>Returns a mutable reference to the concrete type T, provided that the trait object’s type matches T<a data-primary="downcast_mut method" data-type="indexterm" id="OEBPS/ch03.html.id1357"></a></p>
</dd>
</dl>

<p>Observe that the <code>Any</code> trait is only approximating reflection functionality: the programmer chooses (at compile time) to
explicitly build something (<code>&amp;dyn Any</code>) that keeps track of an item’s compile-time type as well as its location. The
ability to (say) downcast back to the original type is possible only if the overhead of building an <code>Any</code> trait object
has already happened.</p>

<p>There are comparatively few scenarios where Rust has different compile-time and runtime types associated with an item.<a data-primary="trait objects" data-secondary="different compile time and runtime types" data-type="indexterm" id="OEBPS/ch03.html.id1358"></a><a data-primary="Square object" data-type="indexterm" id="OEBPS/ch03.html.id1359"></a>
Chief among these is  <em>trait objects</em>: an item of a concrete type <code>Square</code> can be coerced into a trait
object <code>dyn Shape</code> for a trait that the type implements.<a data-primary="type coercion" data-type="indexterm" id="OEBPS/ch03.html.id1360"></a><a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch03.html.id1361"></a>  This coercion builds a fat pointer (object + vtable) from a
simple pointer (object/item).<a data-primary="Shape trait" data-type="indexterm" id="OEBPS/ch03.html.id1362"></a></p>

<p>Recall also from <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a> that Rust’s trait objects are not really  object-oriented.  It’s not the case that a
<code>Square</code> <em>is-a</em> <code>Shape</code>; it’s just that a <code>Square</code> implements <code>Shape</code>’s interface.  <a data-primary="trait bounds" data-type="indexterm" id="OEBPS/ch03.html.id1363"></a>The same is true for  trait
bounds: a trait bound <code>Shape: Draw</code> does <em>not</em> mean  <em>is-a</em>; it just means
 <em>also-implements</em> because the vtable for <code>Shape</code> includes the entries for the methods of <code>Draw</code>.<a data-primary="Draw trait" data-type="indexterm" id="OEBPS/ch03.html.id1364"></a></p>

<p>For some simple trait bounds:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">trait</code><code class="w"> </code><code class="n">Draw</code>: <code class="nc">Debug</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">bounds</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Bounds</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">trait</code><code class="w"> </code><code class="n">Shape</code>: <code class="nc">Draw</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">render_in</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">bounds</code>: <code class="nc">Bounds</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">render</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">render_in</code><code class="p">(</code><code class="n">overlap</code><code class="p">(</code><code class="n">SCREEN_BOUNDS</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">bounds</code><code class="p">()));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p class="pagebreak-before less_space">the equivalent trait objects:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Square</code>::<code class="n">new</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">draw</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Draw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">shape</code>: <code class="kp">&amp;</code><code class="nc">dyn</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">square</code><code class="p">;</code><code class="w"></code></pre>

<p>have a layout with arrows (shown in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_5">Figure&nbsp;3-5</a>; repeated from <a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>) that make the problem clear: given a <code>dyn Shape</code>
object, there’s no immediate way to build a <code>dyn Draw</code> trait object, because there’s no way to get back to the
 vtable for <code>impl Draw for Square</code>—even though the relevant part of its contents (the address of the
<code>Square::bounds()</code> method) <em>is</em> theoretically recoverable.  (This is likely to change in later versions of Rust; see the
final section of this Item.)</p>

<figure><div class="figure" id="OEBPS/ch03.html.fig_3_5">
<img alt="The diagram shows a stack layout on the left, and on the right are rectangles representing vtables and code methods. The stack layout includes three items; at the top is a composite item labeled square, with contents being a top_left.x value of 1, a top_left.y value of 2 and a size value of 2. The middle stack item is a trait object, containing an item pointer that links to the square item on the stack, and a vtable pointer that links to a Draw for Square vtable on the right hand side of the diagram.  This vtable has a single content marked bounds, pointing to a rectangle representing the code of Square::bounds().  The bottom stack item is also a trait object, containing an item pointer that also links to the square item on the stack, but whose vtable pointer links to a Shape for Square vtable on the right hand side of the diagram.  This vtable has three contents, labelled render_in, render and bounds.  Each of these vtable contents has a link to a different rectangle, representing the code for Square::render_in(), Shape::render() and Square::bounds() respectively.  The rectangle representing Square::bounds() therefore has two arrows leading to it, one from each of the vtables." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABZ8AAASWCAIAAADKbkUuAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzdf3Bb533n+6M2vbkbqyThuY41XXlJg+okozgDpqC3UdgJqQYM3f1DklcGJu3citTSBjrx2qasmQCTrCww2nQA78iC5FXuBWyOSfVumyGsmtIfjRkgEZgpI6chGmAj6yZTESZrpaPEcwmQoXPj9qa6fzz20aMD4OA3Dg7wfk0mQx6ec/AAOKJ5Pvg+32fH7du3FQAAAAAAANP6DaMHAAAAAAAAUBPSDQAAAAAAYG6kGwAAAAAAwNxINwAAAAAAgLmRbgCAkUZHR3dIjB4OAAAAYEqkGwAAAAAAwNw+ZPQAAKAa0Wg0mUwmk8lMJpPJZBRFsVgsdrtd/L/T6bRarUaPEQAAAECT7Lh9+7bRYwCACkSjUZ/PJxINHW63OxwON2dItRgdHY3H4+q3/E4GAAAAqkDtBgAziUQiHo+nnD3z449IJJLNZtVvvV5vPUcGAAAAwDikGwBMIxqNlhltFDtcrpIg3QAAAADaBukGANPw+XzytxaLxev1OhwOu90utsTj8Ww2G4/H5RQDAAAAQNsj3QBgDtFoVJ5sYrVaV1ZWLBaLvI/D4VAUxel0KopCwAEAAAB0DlaEBWAOmj4agUBAE21oiKQDAAAAQCcg3QBgDslkUv6W8AIAAACAinQDgDnIy50oiqJfuCELBoM7duzYsWOHZq7KDkkwGNQcJdadHR0d7e/vV3fr7+/3eDzRaLTkg2YymWAwqDl8dHTU5/NpYpqS4vG4PNTR0dGKDgcAAAA6AX03AJhSNpstP+CoSDKZHB0d1YQpQiaTiUQikUjE4XDMz88XG0AwGNQ0QBVEu9NgMBgIBMpfsUWzTAxLvQAAAAD5qN0AYA5Wq1X+tpwCiupks9mC0YYsHo8XrKHIZrODg4MFo43qBINBueGI2+1mSg4AAACQj9oNAOagSTd8Pp/dblfXgtVhsVhEIpBMJuXYQo4JqigDSSaTkUjE7XZrRpU/8UR9oEqXcclms/KUGYvFEggEKh0nAAAA0Amo3QBgDmKdV5VaJaFZSyWf2+2OxWKxWEwThcQkckhhsVi8Xu/8/Pzq6urtD2xsbITDYU0Iokkr4vF4JBKRt3i93o2NDfVRbt++vbKyoglEdPh8PjmO8Xq9DZqMAwAAAJjdjtu3bxs9BgAoy+joaMHyB+cHKjq8it9+mgkpFotlY2ND/dblcsnzZcpsrlFsVMlkcnBwUN1ut9tXVlYqHTAAAADQIajdAGAagUCgYPFCNBp1uVz9/f35S5/Ul8PhkCfIyIUV2WxWjjasVmuN7T81zTuYkwIAAADoIN0AYBp2u71YwKEoSiaT8fl8/f39lba3qIim/YdK86DlTz8pKBqNyiekmSgAAACgj3QDgJmIJho6zUQzmczo6Kim/0UTaNp/lNPuVIdcuEEzUQAAAKAk0g0AJiM6UITD4WJlFIqieDyeRgQcOovFarbXkm5oVoGlmSgAAABQEl1FAZhYPB6PRqMFgwyLxbK6uirnAlV0FY3H48lkMpPJZDIZzYKympNU3bJUc+Dq6urg4KD6QFardXV1tcxTAQAAAB2L2g0AJuZwOMLh8Orqan6fi2w2W3X5RjabDQaD99577+joqM/ni0Qi8Xi8WNVGfUUiEfmBaLcBAAAAlIN0A4DpWa3WcDgci8U0MziSyWQVZ0smkyLUaE6coaGJaSKRSHXPAgAAAOgopBsA2oTD4dAswlpdLuDxePIPtNvt4vw6zT7qIn8pWc3SsAAAAADykW4AaB9Op1P+VrOOSTk0tRIWiyUcDt++fXtlZSUWiwUCgUanG0peG9F4PN7QNW4BAACANkC6AaB91B49RKNR+dv5+fn8jh4FaSbF1DKrxWKxaMo3PB5P1WcDAAAAOgHpBgDcIVdJWK3W8pt6apaArbFZhmYKTCaTacQCtwAAAFXbITH2JIDwIaMHgA7l9/vVr//l17d/6zff/3U2MTHR19dnyJDQBjSZQo0LjlRUCZLf0LTGR/d6vXLJhs/nczqdmkdBe1hbW5udnRVfy78Plbt/VQIAAEAH6QaMMT09XXD7yMgI6QaqpulP0YQeGSpNlhGJRDSzSyrldrvlJiBigdsaz4nWtLa2VuxXIukGAABAmZiZAsAcgsGgfpfQZDIZDAblLZrZIvknzN8oH1JRL0+r1Sofm8lkCp5fKLMrRyAQkL8t+QoAAAAAHYt0A4A5xOPx/v7+wcHBYDAYjUblooZ4PO7xeAYHB+XUwGq1ahqCasorfD7f4ODg6AfERk0gokkoMpmMTr6geTifzxcMBjVBRjKZ9Hg8ZTbRcDgc8piz2axOYgIAAAB0sh23b982egzoRMX6Bl25cmVkZKS5Y4E5jI6OVlRMMT8/n79AbH9/f8GdHQ5HLBZTFCUej6tJh/ojETEkk0nNiiqKomh+hQ4ODub3E7Xb7aJfRjKZFGFHIBBQ55honpfmhMlkcnBwUN4Si8Vq7OiBVpNIJPbv31/wR/w3GtCRTCbj8XgkEpFzZ7vdLn75M5UPnUz+S7tx/ympy6M0Z6joEPTdANCGwuGwJtpQFMVqtYbDYf3VVUWWIccN8Xi8/FQlHA6Pjo7m12uUeXg+u90uGnCoW4LBIOkGAIj6uPztyWRS/Nb1+XwbGxs0YwaAzsHMFADm4HA4yukSarVaY7GYZpKIyu12x2Ixp9OpnkrEB/JHfPPz88Uadtjt9pWVFZ1HFzuUTB8q+mtb8/FjPB7PLyEBgI7i8XhKztRT6+YAAB2CmSkwBjNTUJ14PC5KkRWp66f4E1aUXeh3Ei1fJBKJRqPqQzidTofDUSw0KThOeajKB21HRcl0MxdzQetjZgpQkWg06nK51G+9Xq/X61WDjEwmE41GM5mMxWLR9GYGOgczU9CZSDdgDNINABBIN9qDCDQzmUx+22C32221Wkk260XucJTfYqkDiSRd7retKIrFYhGlf263mxqWDkS6gc5EugFjkG4AgEC60R6CwaDP59Pfx263e71e7sZrIfdaVhtCd6xsNuvxeEpOV3Q4HIFAoF61jTCFiiIDEZDF4/FsNqtmZBaLxW63OxwOnWQ2/1FEyiai3kwmY7VaRe2qCHlrHKro7y7On81mxcn1R4iOcxswQrEL8sqVK0YPDQCa6sqVK/w3ug2UPwnC6XQaPVgTk1/nQCBg9HCMtLq6Wv4d3crKitHjRWnyBFiHw6G/8+rqqrqz1WoVG8u5GGKxmHyScq4ir9dbcAzyPuFwWP9Uxf7ByvsUe7IbGxv6uXCH/zaAiq6iAAAA9STfPGxsbAQCAbnZcDQa1aw8jep0eDGCy+WSl8INBAKrq6vqhTc/P682pRZdnwwaJiog/6IouV6bvEPVFWGiwqLkbsFgUH/JOUVRPB6P/ql8Pl/JAreCstns6Oiofo1S1SdHm2FFWAAAgEYR7Q+8Xm80GvV4PGLF6Hg87vP56HlZBfn2qZNr0eUuG2KxMM2r4XQ6nU5nIBDw+Xz03TALp9NpsVjUdeWj0ahObCGnGzUuFS8mocjLDKmzS9R9IpGI6LCufx7R312kaeIkciohVrWvdLQej0fuKeN2ux0Oh8ViSSaTkUhEHWR1J0ebId0AAABoODEzfHR0VNy68Ic4aiHf7Hm9Xp2ghxDNXBwOhxoHJJPJctINkSmIr9VONHKBmKY9jVzIY7VaV1ZWipX2aNoJRaNRnV9Z4XBYpDPycxHjdLlcamQjfvUVO0k+0TFXfG2xWGKxmDpasZidy+VSX4pKT472Q7oBAADQDHa7PRAIqAXe/CGOqsnpBldRO5HTDZ3JKaIDqPhaTkAKXgw6V4h+AZSY3KQGHPJVl09uGqJ59Pn5eTVticfjotuozqlkwWBQ/TocDmuCGIvFMj8/39/fr5bFVXRytB/6bgAAADSJvHCA+ENcZ+dMJhMMBoPBoMvl2lGIx+MJBoPqTY5GJBIpdqw4sNiDqrsV26fgY6lHFRtPdeTx7NixQ15wt7+/v+DLUrKtSTKZDAaD9957r3pIf39/MBjUv3nLH1gt705LyWazwWBwdHRU8xTEy6LzLNS3oL+/X+f85bw11V2uBdXlrRGvieYMLperopFUQY4qNHNDZPK12tCmKnIyUtE/EM1J5EGWbCmiymQy6s5iXe38fSwWi7y9/JOjPRnRyhRgzRQAeB9rprQHuf5f7iqqv2fBPv8bGxtqP8iSLBZLwUfZ2Ngo59j5+fn8Y9Ud3G53pU+/2HiqJi8MUSadxSZKrrzgdDo3NjZ0xlOXd6d28j1nOByu+jwbGxvFPnLXKHgxqFGdumZHQSXfmlouV/kk9Xpr9M9TciQ1koOAYm+uvE/BK1YecI3j0TlV+Y8i/97TXEs6JwmHw+qPdFZFkXcrtrwLOgS1GwAAAM1T8rNQ8aFxmWcr9rGtxWIp2Usym826XC65GkJQb1mrqDto5QaWyWRycHBQf+WFaDQ6ODio8xl1Xd6d2slXUdUVIplMZnBwMP8CaL5aLld5h9rfGvGa6J9HjKRxRRya8o2CA1C3i/6aDRpJHckveDmrtOTvqfOvSZ6KUnWBCdoD6QYAAEDzVFShbbVaA4FAIBDI/3g2HA57vV79v/jFsZoDA4GAfJTP59PcG1eRbqg3IXWf8a4pCpALDeQFUGWaHoqCuCNVx2m32+VPxQOBgDryTCYjN0HUH1vV706N5PaN4oa80ps6scqmzpqyt+/+SLzRqr5c9c9W0VsjXhP5lZTPEIvF5NzB5/M1aBKEZgHp/B3quFpK08i/Gcr/xSK/FzohjvwimGIuGBqo4H8VgEYrdkEyMwVAp2FmSnsof2bKbamev+C7LM/FKH9uSKXkuzvNLaV6C6c/3UCm3l00bsBCOelGQZrOiwX3kV+TYk+kOe9OOfKjB6fTubKyUubh8itptVqLvZj6T7ZeM1NK0rlcVbW/NZrXpOCLKf9Lr/rplCT/isgfhjzOYu+4fGHUOBidU1X0KMV21jmJ/L5XPUh0FGo3YIBUKlXsR319fU0cCAAABpBvXcov0q4v+d5Y87G/XMWgOUrtxKk5RP28tDVXK0gmk/KikvPz8wV3i8Vi6ufDkUjEqLemTG63W/NExLSa0dHRkpNNksmkuo9YZbM13ziVzuVaL5lMRn7d5ufnC9Z3yHUf8Xi8QYPRb5MpN9qse31QMpmMx+NiLdjR0VH9frGNxjQTVIp0AwbI5XLFfkS6AQBAE9jtdnlqg/yjYjXk0WhU/VZzx6WeoTVbAMjl/V6vt9ggLRaL3E6yFRpS6HM6naurq5o+qfF43OPx3HvvvTqNITQvSItHG4ru5Vov8tutP6tILp1o0OQUnflrmUxGfQX0W+SWL5vNRiIRsWiOCMh8Pl8wGCy5rlMzFVz+RmX06NAqSDcAAAA6kXq7WKzvhnL3naT8Oap8x5XNZtUzNHRxyqqV36dA/qkplpa0Wq3z8/MrKyuapU+y2azP57v33nvbpnFDscu1XuR0Qz81qMsiqfrkvirxeFwTMqpf1+Wfmyj58Xg8prjgAX2kGwAAAG1LVJhrPucUH+wXu0sslm7It3/yHZe8TwtWAcgLTFgsFv0bQrlGwERV8WqTVLk9qlJkdY+KXpAmq+JyrQs5oSv5mjRnhY5iQZv83tVeuxGNRuVuu/rDAFrfh4weAAAAQGeR7yUaN5VD1JYX/JH4YL/YgVar1WKxiJs9dajJZFJzexmNRkW9gLxgSgvOTJGHXU74oj53RVEymUwL5jU6vF6v1+uNRqMej0d9Fj6fz2q1qnfClb4gzVH15VoX8j/JbDbbCjMdHA6HWqaRTCbVt0/dWHvukM1mPR6PvMVutzudTvEPWT1/K7waiqIUXAsJ0CDdAAAAaCq5S0WD4oAqlgiVWa1Wcbg6VPWeyu12iyKOeDyuSTdaqgqgoHJebavV2jq9BqrjdDodDoe8uKnP5yv4OX+LpFE1Xq61q7owpHGXitPpVKOHaDQq1mqp75SiSCQiP/FAICD3nWmc6q46qkhQDmamAAAANI98F9egv9c9Ho/8KE6nc35+XrNsXiAQ0LnHUHMK9eZNJBoWi0U9UG0yKtduNOLp1FE5N7FmjzYEsTSM3ImzZSfa1H651q5FUh6ZPEFG7SQqpxu1T0uRzyaqfmo8oQ75n1X5Mai8Z3v8w0SjkW4AAAA0j3xH0YhiB7H8gfptOByen5/PvxHSWTpEyVsUVu2y4Xa75dn+oqBDvTVtzXRDfprl3CC15sSNKlit1oKre1T6gpSj6tqHulyutZPfaLvdfrsSjRtV/rqw6psoN4ipWn2zEn3VTcdrxLWK9ka6AQAA0DzyvVwjajc0teuapTTKpEk31DGLWyB12CLdaPGZKfJn4HJDzYLk9iKt+XQqUjCdsVgs8vtbS7dO9TxyV86K1OVyrZ08R6zG16SONIuzyFdv3cOIRl/t8r+76mo3Wrb4CC2FdAMAAKBJIpGImgU4HI4G1W6oX1ddeqC5rRIpht1uFwNWl6uMx+OmiAPKX+fVjEul6ih2ly4/NTluq1Sx5XXK1zqVMmqwks1mCy6j23x2u119TcS/NfVHprs4q1vIVr4kWuRNQYsj3QAAAGiGTCYjL/3QoFnumgVBqzuJ/FG2upKF/HGxeiuoPqOWjTYUabSKouisLZrNZuVlO4yqI6gjOayRLwz5rdS0lqxI7Tefdblc60LOCxq9AG351Hcqk8mo76bVaq3LP7emzfuQoxl5NZaS5As1mUzqR5OAQroBAADQBPF4fHR0VL1l8nq9Dfr0Vb7tiUajVZdza6afKHff7at3Her9Rit/mCx3oMhmsy6Xq+Bu8hvkdrtbuemGz+fz+Xz6d+CRSETutSG/QQ6HQ/02k8lolgVVlbx45JvPYDBYxcVWr8u1dg6HQ44SRkdHW6HRg/z6qNFbOf/W5OSiWPAkn7xxwYFmQd+KUl25y4+iKPI6x8UeiwksHY50AwAAoIGCwaDL5ZJvlhwOh1jfsREsFoscQwwODha87SzZXEBzb6/ORhHUWSry41Y/6MYLBAJykf/g4KA8IyMYDPb398vtURv3BtVFJBIJBoP33nuvx+OR602EYDA4OjoqZxb5XTnlJxiNRjUvSDQa9Xg8g4OD+sPQNC4VF5vmusofnqxel2tdhMNh9SJJJpP9/f0ejyd/5k48Hg8Gg4ODg00YkubfnVBOuiHvIy6SeDwuRq6GHfI+Pp+vYJpTY+ohwkS5cKPSkih5f5E6FRySKLzq7++nvqPTVdQTGKiLK1eucEECgMCvxPZQ/s2w0+nUP9Xq6qq6s9vtrmIwGxsbFdUdWK3W/JPMz8/L+8RiMc0O4XBY3mFlZaWKoVZKvtVZXV2t6NiVlZVyXhar1apz5trfndpp3pqSio0zFovVfpKKLjaHw1HjGZQil+vtOr01q6ur5U/6aM41n99AtJyjdN7cQCAg9pFfMUVRLBaL1+uNfSAQCOTHKJpHkX9kt9sDgUAgEBCHh8NhscSSvE/+Wr+akxR8LvnlHlar1ev1iofzer3yW6Y+O3Qm/nKCAfhTHgBU/EpsD+WkG3a7veAf9xp1uUnb2Ngof1WFgreLGxsb8sgL7qDeulgslurGWala0o3bZbwsTqdzY2ND5wytkG5sbGyUn6aFw2GdU8VisTKTBZ0nu7GxUea8pILpxu16XK636/rWlPny6r+29aKJEUvGo6piVRLy/X85z1S+QjQPUc6rVPLlkvep9LnoPzt0oA9VdFECAAAgn/jcMpPJ5Nexiw4OTqezmX0cLBbL/Px8JpMRvQzyJ96Lz2nF1wVvTcVCqqKkvOCthSgyF/MOWrnphky8LKI9oTyHQsywaNAqNnUn3juv1xuNRjOZTP77q765JXscOByO1dXVSCSSTCblS9ftdtvtdofD0d/fX854YrGY6Bwpd1gQ1Nkr4oTFzlDj5Vpf4uUV13b+MxL/onWeTn05nU55klH5DxoOh51Op1inKZlMin/RmmV3vV5vwd9agsViCYfDmnbIMqvVWk53EofDUWOnITFpSL/bq8ViCQQCbdAMGLXYcbvC1A2oXSKR2L9/f8EfcUEC6DT8SgTQmjKZjJpuuN1uTREB2kY8Ho9Go/F4XEQVoget3W7Pn1qSL5lMimWhRcMLta+n1Wq1Wq2if229QkOxWK8Yp9rLw+FwiLCJXAMK6QYMwZ/yAKDiVyKA1kS6AcBcWDMFAAAAAACYG+kGAAAAAAAwN9INAAAAAABgbqQbAAAAAADA3Eg3AAAAAACAuZFuAAAAAAAAc/uQ0QMAAAAA0HKsVivrUgMwEWo3AAAAAACAuZFuAAAAAAAAcyPdAAAAAAAA5ka6AQAAAAAAzI10AwAAAAAAmBvpBgAAAAAAMDfSDQAAAAAAYG6kGwAAAAAAwNxINwAAAAAAgLl9yOgBwDCJRGJ2dnZiYmJkZMTosQAA0LlSqVQulzN6FADQEvr6+vr6+oweBUyJdKMTzc7O+v3+9fV18W1LpRs7duwweggAABSQSqUSicTU1FQdz5nL5UZGRtLpdB3PCQBmNzw8nEgkjB4FzIeZKZ1ldna2r6/v6NGjarQxNzfH50UAAJSUy+WOHTvW19dXx7+5Z2dniTYAQGNpaWlhYcHoUcB8SDc6RSKRGBgYkHMNFb87AAAo0/r6+v79+0dGRtbW1mo/Gx8wAEBBqVTK6CHAfEg32l8ul5uamtq/f3+xT4dCoVCThwQAgKktLS09+OCDfr+feAIAgBZB3402l0qlDh06lF+vIUun06lUamBgoGmj0vG1VygkAdBZ3vrxtZeD/8XoUaAa09PToVAoFApNTEzUfraHBj/z57OXaj8PAJjUlycOXlv5ntGjgImRbrSz2dnZo0eP6u8zPDw8MTHRItGGoiiffHjI6CEAAFCuzc3No0ePioyjpbp0AwDQaZiZ0rYmJib0o43h4eErV64kEom6fOIEAEDHSqfT+/fvn5iYqEszDgAAUAXSjfY0MTExNzdX7KdqrsGnTAAA1Mvc3NzAwADNOAAAMATpRhvSiTa6u7vPnDlDrgEAQCNsbm5OT08PDAzMzs4aPRYAADoL6Ua70Yk2hoeHU6nU1NRUk4cEAEBHWV9fP3r06MjICCsaAgDQNKQbbWVqaqpYtPHMM88kEom+vr7mjggAgA61tLT0qU99amJigokqAAA0AelG+5idnT179mzBH73yyiuhUKjJ4wEAAHNzc319fX6/3+iBAADQ5kg32kSxKSfd3d2vvfYaq6IAAGAU0Yyjr69vYWHB6LEAANC2SDfaxMTExObmZv722dnZQ4cONX88AIDOkUqlRkZGdrS7/fv31/Iqra+vP/rooyMjI6waCwBAI5ButAO/359Op/O3v/LKK0QbAICGyuVyIyMjS0tLRg/EHJaWlh588MGpqSmacQAAUF+kG6a3trY2PT2dv/2ZZ55hQgoAoNH8fn/B4kHoOHv2bF9fHy2xAACoow8ZPQDUqmC7jeHhYf5mAgA0AYueVmdzc/PYsWP333+/0QMBAKBNULthbolE4tKlS5qN3d3ds7OzRgwHAAAAAAADkG6YW8EV5vx+f19fX7OHAgAAytbd3X3mzJk/+7M/M3ogAAC0CdINE0ulUvld3Hp7ewvOVQEAAC3imWeeWVtb47/XAADUEX03TKxgZ42C1RwAAKAVDA8Pz87OUmIJAEDdUbthVrlcbm5uTrOxt7eXdVIAAK3g5MmTt9vLlStXanlBent7X3vttUQiQbQBAEAjkG6YVcG+oRRuAADQarq7u0+ePLm2tnbo0CGjxwIAQNtiZopZ5acb3d3dFG4AANBSxsfHQ6FQT0+P0QMBAKDNkW6Y0traWjqd1mwk2gAAoHUMDw+HQqGBgQGjBwIAQEcg3TClhYWF/I2kG2gb6atLJ554TGeH8WMnDk8+3bTxlGN7K7cYvZB647vpq3dWMtrZ1XN48ilFUVpttOgoqVRqYWGBqYvN1Nvb6/f7+e8yAADNRLphSvnpRm9vr4k+HVpbWyu4/SM7u5o7EKA+Ls6cmztzKn/79lZObJ87c2rX7t7I6ytNHxo6Wi6X8/v9Z8+eHR4eNnosnaK7u3tqampqaoqpKAAANBnphiktLS1ptpirUVmxdMP68YeaOxCgDs5PH1+MXii5284ubnXQVKFQyO/3b25uGj2QDjI+Pu73+1kSBQAAQ5BumE8ikcjfaK50A2gbi9EL5UQbiqLc/0BvowcDCIlEYmJiYn193eiBdBCbzRYKhUZGRoweCAAAnYt0w3wKphv8RYV2Yts3fPnaO5qNZZZINNnFmXPyt2POI2POI3v22tQty4uXb91cu3E9LW9EvSxGL5yfPi6+zr9mOtDa2trU1NSlS5eMHkgH6e7uDoVCtNiAGb37i80f/d3yWz+59qO/W5a339PVbf34Qw9+7KFP/vuhe36726jhAUClSDfMJz/dYEK1SYkb41s31xejFyKvr+zazWf7JrO8ePnWzTsfjxfsdTo0dqCcU3ExVKFYu5POlMvlQqHQ9PS00QPpLCdPnqTFBszo2wvfeOM7f/P973yz2A7qj37/D//owJ96PvnwULOGBgDVI90wn1QqpdlC4YZJcWNmdqk37nTA2bPXVsvCKFwMlWrNWh6jzM7OTk1N0WKjmYaHh2dnZ2mxAdP59sI3/urrz//8n94uc//vf+eb3//ONx/82Cce932NjANAiyPdMJlcLpf/96uJVksB2snqm2n16zJrNFC79NWl89PH5aqZTpZIJKamptLpdOldUSe9vb2zs7N8rgDTefcXm1976si1le9VcexbP3nzK0cP/f4f/tHU115krgqAlkW6YTL5hRuKovDZEWCI7a2c+jVtNZrgxvX0xZlzy4uXjR5IS1hbW/P7/XNzc0YPpIP09PScOXNmamrK6IEAFcv8+NqXJw7+cnurwM+67lfu61fu23Nnyzs3lHdWla2faXb8/ne++eWJg8987b+zyB2A1kS6YTIF04Zlk5UAACAASURBVA1qNwBDyOUD93Qz8b6Blhcv/+23LpFrCKLFRigUYipKkw0MDPAfXJjRtxe+8VLgK9po48P3KHvHlN/7j0rXrsKHvbOq/P1FZXVZee9dddtbP3nzyxMH/3z2EgEHgBb0G0YPAJXJ5XKaLTabAZ8Yh0Ihv9/f/McFWtbOLtKNRtneyp2fPq6JNobGDpx66VWjhmSg2dnZgYGB6elpog0A5cj8+NrZ//KUNtr49BFl8n8oI18sGm0oinJfvzL2JWXyfyh7Py9v/uX21pcnDmZ+fK0x4wUqEwwGg8Hgjh07gsGg0WNpLfF4PBgMjo6O7tixw+ixNA/phsnk124Y0qo9l8tNT0/39fUtLCw0/9EBdJSdXT1yWxORa3hPz9z/QJ9xgzJAKpUaGRk5evTo+jo9RwCU5ec/ffvLEwfv2tR1v/K/h5V9R5QP7yzrFB/eqYx9SXGeVj58j7rtl9tbZ7/yn9/9BRkrjOfz+Xw+n9GjaEXJZNLn88XjcaMH0lTMTDGZ/NoNA6tk19fXH330UfrGl8/9yGCxVojuRwaLHbVrd2/k9RX9M6evLt24nr4486LaCWJnV8/hyaf27LXZ9pW1YPBi9ML2Vm57a1MsTSqz7Rse+PRnh8YOtscypbduri8vXkq98d301btWPBkaO2DbN6zfPqO6d7DgSrGNuxiqs72Ve+7xx25cf7855Z69thfmS/zn8FmXQ91/zHnkyZOnGzEw4fDk08uLlw9PPtU212FFcrnc1NQULTYAVCr0lf98V9XGff2K83S5uYZst01xvqBEn1Vnqbz1kzdDX3nqK+dYuwpACyHdMJn8dMOQ2g3Z0tLSgw8++Mwzz/j9fsMH04FuXE9/3X9cvclUbW/lxCKje/bavug/rXPTfnHmnP5ypOmrS+mrS3NnTtn2DT958rR57y0LTnAQblxP37ieVs6cGho78OTJ0x04zWRnV8+XXph51uUQAdmN6+m5M6fGj50otv/cmVNyFNLQaENRlF27e//ye//Q0IdoWX6/v/YWG0tLSxUVpo6Pj4dCIX6lA6b27YVv3LVCStf9VUYbwn39moDj+9/55o9+sMwysQBaBzNTTKZll/07e/ZsX19fKBQyeiCdZTF6Qf78vKAb19PPuhyL0Tp8upK+uuR+ZNCknR3TV5fcjzxccvDLi5efdTk6c7XRXbt75ZBCZ3WS5cXLao2PiEWaMb6O1NfXZ0iLjbm5OVY8Bczur77+/F3fH/hq9dGGcF+/cuCrdz3E+eeL7QsAzUfthum1zh+gm5ubx44dC4VCs7OzrTOqNrYYvXB++niZO4s9x5xHan/c4PFJrzIj90FofemrSyeeeKzMnW/dXH/u8cMNmgDS4obGDhy+/rSaXJyfPt7/CZumWufWzXX5witYznPiicfkiT8Vse0b7sx2oQUZ2GIjnU7Pzs5OTEwYNQAAtfj2wjd+/k9v3/n+00eU+/rrcN7dNmXv55Xr3xLfXVv5HuUbAFoH6QbqbH19ff/+/QcPHgyFQjTj0NDcMB946D75RxXN+NDcYSqKMjR24A8+f1ANHZYXL7/+6gX5DvP89HHbvmH9RxGf3sutOra3covRC4vRC3I5Q8Gb3pZ16+Z68Pjj8hbRSUTthSGeo9y15NbN9Ysz5/KbZdTxHazjqepr/NgJ0cZFUZTtrdzzz05qGnA8/+yk+kIdnnzaXDkXKrK2tmb0EABU6fJf/J93vum6X9lXh4833jfyRXmZ2Mt/ESbdANAimJmChrh06dKDDz7o9/vzG4WgLjS9P588edp7eiZ/XQlN34T8jqEa9z/Qp+lCurOr5/Dk05HXV+STb2/lSp6qdVycOafejSuKMn7sxKmXXpWTiw+e4w/k7iQXZ15s6ihbyZdemFE7j4gGHOqPNO02dBpzAACM8vOfvv3WT9688/2n/mM9z/7hnUr/nTjj+9/5Zj1PDgA1IN0wk/zlYFucWDV2dnbW6IG0m1s31+U+Gocnny425eTw5NPybbymBKMimvSkllM1k+a1Krh8iaDpH7G9ldNvaNLGijXgoN0GAJjCG9/5m7u+/8RYnR/g9w7L3/3oB8t1Pj8AVIWZKWZSsA6ixXvab25uHj16NBQKhUIhmnHUy/LiJfVrsfKrzs6HJ58Sq72qxxa7vS9p/NhzcpvJWk7VNPJrZds3rD/gXbt7h8YOqM8xfXVJf4HYNpbfgGNnV3fJdhsqGmfUS29vr4GtN9pAIpEIhUKtXEUoT/956yfXvjxx0LixoH3cXLtx55vf+jfK5eeU+/YoI1+s2wPc1698+B51cso1Wm8AaA2kG6Y3MDBg9BBKS6fT+/fvHx8f9/v9NOOonVxTYNv3Wf3lS3d29dj2fVa9Y6+lHkFz82+K0obUG99Vvx749GdL7r9rd5/6tSmKUxpH04BDbstKu42mSaVSIh1u/rIpbWBhYeHRRx81ehQVePcXW3et3wnUxb/8v8rN/1n/097Xr5428+Nr9T8/ULlIJJJMJiORiLrF6/Xa7Xan06l/YCaTiUajkUgkk8mILeIot9ttsViKHdLf/36n3lgs5nA48vcJBoM+n098ffv27YIPKr6Qx6woisVi8Xq9DofDbrfrj1xRlGg0mkwmg8GgusXpdBYcT7HDM5lMMBjMZrPydofDIU7i9XrLPFUrIN1A88zNzS0sLExNTf3qV78yeizmtvrmnVihnOKCPXttaiQhH1uFOp6qOeRBzp05JbeQKEnu1tGZvvTCzLMuh+Z1oN1GM/X09Pj9/omJCb/fPzc3V/V5bDabzordU1NTLbvceC1Y8AVooN0Darrx7hbxK4yn5ggycc/vcDjm5+eL5RRyBqFKJpPJZNLn8wUCgQbd3qvhSL5sNiuG5Ha7w+Gwzm4ulysej2u2R6NRkZvoy2QyLpcrmUwW/Gk8HhdnLjNkaRGkG9DK5XIlG3xU3Uh/c3Nzenq6u7u7usMhyDUFZaYbBY+tgulKG2pJKLY7/s810YAjeHxS3UK7DUOIBkYTExNVxxA9PT06cwNbfIZjdRKJBAUvAABFUeLx+ODg4MrKSn7AMTo6mp8OyHw+Xzwej8VijRxgUZFIJJvNzs/P5/8om80ODg6qxSaVymazo6OjJQ+3WCwmijYUuopCw+/3WyyW/aXU8hGioij8xWleO7tIpjpL/yds8tSn7a0cJS1GGRkZSaVSr7zyCgExAAD57HZ7OBy+/YFwOKzemWcyGY/Ho9lfJBfia6vVKh8bCASsVqv4UTweL1gYUi8Oh2NjY+O2JBAIqD+NRqMF8xeXyyXPo9EMvmQkIU/DcbvdsVjs9t0CgUA552k11G7gDr/fPz09bfQogEY59dKrmvVuoW97K/f8s5OaOOP5Zye/+vJFnZaiaKiJiYlDhw6FQiF+XQMAoMqfxOF2u91ut1qdIWICtSFFPB5Xe1XY7fZYLCZXdni9XnGsmLgRDAbdbread9SXw+HQFJV4vV6r1epyucS3kUhE00dDnTYiDteUlni9Xq/X6/F4NO08ZOrUFafTWXDyi5iPY66mGwq1G+ZSsIFoHZeJ1ZmVjZYi31iW09pT3qfGm9I6nqo55LoDU7RBbSnnp4+rL5o6v+nWzfXnn50sfpCiKMqJJx478NB91f1Pbl+KgkQzjrfeeuvgQdbXAGCQd+4sy3IPdZ1oAcWiB/nWXb7blztTFOzKYbFY5CkhctvOJpA7g+bXbshPpFhjDv0sRu0hWqwdiUmRbphJwanR9VroLpVKGT5h5Fe/fNfYAZhF/yfu9NGoNN2Qj62C3Iri/gf6ajlVc1T6WkE1d+aU2kF2z17bV19+VV1P98b1tLw6LAzR19e3sLBw5cqV3l4T5IwA2s07q+qX1o8/ZOBAAH1Wq1VdM0WOCeTihWJBgHxsOX0660tNN7LZrGZBE/WJ6AxenzrlJBKJNHTeTZMxMwXvq1dKUovf+vCHjR5CU+3s6lFr/n/29lr5pRDywiXpq9/d3srpLAq7vZVLX72zKmo5XUh1LEYv1OtUlZKfY/kNTQc+/dn01SXx9fLi5RuT6SYPu0xVXwwNsrx4+eLMOfG16CS6s6tHXiN2MXph1+5eNe+AUUZGRtbW1kKhkN/vNzyhNouTJ08aPYQ7EonE0tL7v6M++jsPfO7QF4wdD9rAP7/3nvoLXFEUZe/nla5dStf99XyMd1aVrZ+p3z34MdINtDS73S6yiWw2m0wm7XZ7MplU8wL91hL5xzZhwIJcVZHNZtVvyx+8Dq/Xq+Y1wWBQTL1xOBwlV89tcaQbaCG/+ZuddUHu7OpWb2hvXE+X3xJiaOygurLp9lbu4syLOit0Xpx5Ue6bMDRWfSn7xZlzd5/qQNWnqoLc0LT8xWjl10pRlK/7j3/15Vd1wiCjVH0xFHNx5pz6xMePnagohrh1c10uzfCefllNW+Q1YufOnLLtG27NtKjTTE1NiVVjz549a/RYTMDv9xs9hDv8fr+cbvzxF79k7HjQBn70g+W70o2xBlxUby7K333y3w/V/yGA+pGrG0QuIJdC6AcE+cc2TbGijPIHr0O0GnG5XOrZIpGImPBi6piDmSmAYeRJE4vRC+UvRbFrd++Y84j67cWZc3JJhezizDn5T5wx5xH9ooCfvb1WbBjLi5flmKD5t7XyYrQ3rqfVioxSR/XKKcyN6+nnHn+sBaeoVH0xFDR35pT8Zmm+1be9lXvu8cPqAMaPnZCjFrFGrPrt889OFqyjOfXSq5evvVPd/0699Go1z7nj9fT0hEKht956a3iY1rkAGum9beX6nXTj9//wj+75bfpuoKXlt5YofyHVFmxLUfUqsBoOh2N1ddXtdmu2RyIRl8vV39/f/Mk4tSPdMJn8hQDX1taMGAjqQE4Hbt1cf+7xx9T5JurGizPnnnU58g5VDk8+LRcgnJ8+Hjw+KR++vHj5xBOPyfe0O7t6Sn6Af+vm+p985nfnzpySs4P01SVxfnnPx/7TUyWeXr3Z9n1W/vb89HH5+d64nr44c65gQ8rxY89peos+63Kcnz5+10dbiqK8Xwhz7uLMOc2TbYJaLgYN8Sw0GzV1NzrOTx9XA4uhsQP518zQ2AE1MNJUecBwfX19iUTitddeoxkHgEb5+79W3rvTKO1zB5lOhVaXX3NRfq+Kcuo1WqSmowoWi0UsJRsIBDTFGplMxuVy5S+j2+I6ayJAGxgYGFBLWIUmpBu3b9/WbKlx7VibzZZOt9yH582nmTRx43o6eHxSKXSreOvmuqbmQnyELt+ELy9eXl68XPBw4cmTp8vs5qCp+Mh3ePLp5i+turOrx7ZvWI1dbt1cL/hyFXytvKdf1gQfotqlWEVD89te1HIxaMidXzXbS07Jef8qUhRFUXZ29chlGrInT54WDV8URUlfXbo4c64JDThOPPGYfsHOgYfuk7/dtbs38vpKgwfVog4dOnTo0CG/3x8KhWjGAXQabSXFzbSyu361lu+sKm/cKRf96O888OnP/Ye6nRxoDLnYQdRiyBUZyWRSs96q/rH5mpxulD/48qkrvwaDQXm52UgkYrFYAoFA7Q/RHNRuoKmGh4evXLly6NAhowfSEspvyliwzcTQ2IFiN5/5njx5ul5tMobGDui0+Wioch634Gtl2zd86qUK2m2U37W0Xmq8GGQ7i6zMV2y7SlOI8eTJ08VeMdFhVP127sypFpzsA7/fv7a2Nj4+bvRAADSVdgWT97brdur3tpXos/KGx73/tW4nBxpGvVe3WCyiUYXdbpebdOocq/5UPVb9Vv26XlNFyiQPPn+x2Bp5vd5YLBaLxdSHCAaDTY5vakG6YXqtsNZJOXp7e1955ZVEIjEyMmL0WFpIpe0eNcacR16Yj+v3v9iz1/bCfFzu06GjZM3CkydPe0/PVDDEutqz11Z1UwbbvuHI6z8o/9WusfNFFWq8GFQFpyBppjIVNHfmq+qzHnMe0Y/DxpxH5Avv637mp7Sinp6e2dnZK1eu8IsX6Cgf/Z0H7nxzY7k+J31vW4kel+ek/P4f/hGFG2h9yWRSXj9V3S4v9VosnshkMvLCsfKPLBaLOkOk7hFDSfIat/rpTHUcDodazaGUCoBaCumGyQwMDGi2pFIpQ0ZSkZMnT6ZSqYmJCaMH0orGj52IvL6i6d0ojDmPjB87cfnaOzr3mSK8OPXSq+PHTsi3r+LT9VMvvVoy/pDd/0Df5Wvv5A9G1GtcvvZOmSlJ49j2Df/l9/5h/NgJzZMq57USr4l4ggXLQMTTFB0xDVlXpcaLQT6P/ASLPV+ZZk5KOWUy8j6i70nJQ2CIkZGRllolBECjPfSwtIjJ9W9pljipxjuryv/lUd5ZVTd8ZGfX1NderPW0QIMlk0mXy6V+K9+xy1/LS4eostlssWMFdUpIMplscgNOzeCrKB7xeDzBYLDMnVuwtWox9N0wmZ6ellvJUt/BgwdDoVBfX5/RA2lpYlZCLZ/b2/YN2/YN16v3QY2DaTRRm1DLCMWxtT/Hy9feqfEM+Wq/GIRKTzI0duDyWGVPx7ZvuBGvQDGspQIAZTrwp57vXPrGne+/9d+U97aV3ztczbne21b+/q/lXhuKonxkZ9efz15iqRS0lHg8rik3iEaj8g281+uV+3FarVav1yt2SCaTg4ODXq9XXUAkGAxGIhE1NdAcKzidTrGEqqIoLpfL6/V6vV45CGhcTYc8+Ewm09/fHwgE3G63piWHzhmSyWQkEvH5fIFAwGq1ypUpmpdOMyWnxZFumF7Lrplis9lCoRDl0AAAAM1k/fhDf3jwC3cFHEv/h/LDv1b6h5Q9Q+U2Gd26pbz5LeWHF+XZKMoH0Ya2uwdgtHg8vmPHjmI/dbvd+a0xA4GAOm8lk8l4PJ6CS4Q4HI6CbTXF9A01BQgGg+VXQ9ROHryiKD6fz+fzlXlsNptVs4+SR+UXrbQy0g2TGRkZ0SxWsr7e7PaHJXV3d4dCIeahAAAAGOIJ339968c/eusnb97ZtPUz5Yd/rfzwrxVFUe7rVz58j7L7g/nOXfcr3bve//rttPLetnIzLc9DURFtwIzC4bBalKERi8WCwaDOHX4gENC5vRepRzNDDVnJweuw2+3ldNPQeelaE+kG6uyZZ57x+/2mm0EDAADQNu757e4/n730taeOXFv5XoEfi+Ti5v+s6JwPDX7mKy9eYEIKWsrGxoaYHhKNRjW3606n0263lyw98Hq9TqczGo3KU1HsdrvT6dTM9SgoEAg4nc54PJ6/tojD4RC9OTQdSetITIfRLOMqiKegKEp+PGGxWFZWVkTpR8GmISK1MVfVhkC6YTIFG1i0yEIkw8PDs7OztNgAAAAwnAg4vr3wjb/6+vM//6e3aznVR3/ngT/+4pc+d+gL9RobUC8Wi0XchNdyKy7aWFR9BrvdXk6MonH79m39HRwOR8l9hOoGL4Zd6VEtjnTDZFozO+jt7Z2dnW2FhAWGOD99fDF6ofR+pYw5jzx58nTt5wEAAMLnDn3hc4e+8O2Fb7zxnb/50d8t/3J7q6LDH/zYJw786Z+RawAwBdIN8+nu7t7c3JS3GFi70d3dPTU1xVqDAAAALUtkHIqiZH587ec//ce3fnLtZz99++c//Ufx08yPr6mpx4Mf+8Q9v9390X/77z758NAnHx766L99wLBBA0CFSDfMZ2BgYGlpyehRKIqijI+Ph0IhWmwAAACYgvXjD1k//tCnP/cfjB4IANQf6Yb55KcJqVSqyWMYGRk5dOjQwMBA6V3R8g5PPn148mmjRwEAAAAA1SPdMJ+BgYFLly7JW3K5XJPHQIsNyJ48eZp+GQAAAAAM9BtGDwAVy6/daJGJKgAAAAAAGIJ0w3wKzgdpfvkGAAAAAAAtgnTDfAouCtv81hsAAAAAALQI0g3zKZhuULsBAAAAAOhYpBumZLPZNFuo3QAAAAAAdCzSDVNqhUVhAQAAAABoEaQbppS/ICszUwAAAAAAHYt0w5RYFBYAAAAAABXphikVXBR2bW2t6QMBAAAAAMB4pBumRLoBAAAAAIDqQ0YPANXIn5miKEoqlcrvxwEd3174xs//6R/F1w89PPTJh4eMHY8+Rts45hrtj36wfO0Hy+Lrj/7Ov/vcoS8YOx59jBZoZZkfX3s58BX12z+fvWTgYEpitI3DaBvqyxMH1a8f933N+vGHDBxMSeYaLaBBumFWw8PDml4b1G5U6tsLf3Vt5Xvi6z/+otLi97SMtnHMNdprP1j+q6//N/H1Q4OfafE7cEYLtLJ3f7Gp/vZrfYy2cRhtQ8mjffcXmwaOpBzmGi2gwcwUs+rr69NsYVFYAAAAAEBnIt0wK9INAAAAAAAE0g2zym+xsbm5mcvljBgLAAAAAABGIt0wq2KNRZs/EgAAAAAAjEW6YVYFF4Ul3QAAAAAAdCDSDROz2WyaLWZZNqXYOO/p6m7uQAAAAAAA7YB0w8TM21i0WLrBktoAAAAAgCqQbphY/uQUs6QbAAAAAADUEemGieWnGyybAgAAAADoQKQbJpY/M0WhfAMAAAAA0HlIN0ys4LIpZmksCgAAAABAvZBumFv+sinUbgAAAAAAOg3phrmZd9kUAAAAAADqhXTD3Fg2BQAAAAAA0g1zY9kUAAAAAABIN8yNZVMAAAAAACDdMLeCy6aQbgAAAAAAOgrphunlL5vCzBQAAAAAQEch3TC9/MkpiUTCgHEAAAAAAGAQ0g3Ty5+csra2ZsRAAAAAAAAwBumG6eWnG+vr64aMBAAAAAAAQ5BumF7BZVOYnAIAAAAA6BykG6ZXcNkUJqcAAAAAADoH6UY7yF82hXQDAAAAANA5SDfaQU9Pj2ZLKpUyZCQAAAAAADQf6UY7GBkZ0WzJ5XJGDAQAAAAAAAOQbrSD/MaiS0tLRgwEAAAAAAADkG60g4LLptB6AwAAAADQIUg32gHLpgAAAAAAOhnpRjvI7yqq0FgUAAAAANAxSDfaxPDwsGYLjUUBAAAAAB2CdKNNsCgsAAAAAKBjkW60ifzWG9RuAAAAAAA6xIeMHgDqI792w4yLwr768rnLfxFu2sP96pfvGvXQVWC0jWOu0f7ze++pX//fP/z+H+/rN3AwJTHacvz61/9fcx4ILe7ayvcOPHSfgQMw9tErxWgbh9E2zleOHjJ6CBUw12gBhXSjbRRcNsV0/uWf3/uXf36v9H7t9dBVYLSNY67R/vrXv373F1tGj6JcjBYAAACNw8yUNlFw2ZREItH0gQAAgHIV/M93k/2vH7nH6CFUgNE2DqNtKHMNuBVG29fXZ/QQYD6kG22iPWo3AADoKBMTE729vcaOQZ6d1/oYbeMw2oYy14ANH+3w8PDExISxY4AZMTOlfXR3d29ubspbUqnUyMiIQcOpxkMPf+aTDw8ZPQoAaKqf//Ttb1/6htGjgDF6enrW1tZSqRS9wAFA6Onp4YNbVId0o30MDAxoOoma7k+lTz489Mdf/JLRowCApvrRD5ZJNzocf8cDAFA7Zqa0M9OlGwAAAAAAVIF0o33kT0JJpVJGDAQAAAAAgKYi3QAAAAAAAOZGutE+8leVW1tbM2IgAAAAAAA0FelG+8jvSba+vm7ISAAAAAAAaCbSDQAAAAAAYG6kG22OZVMAAAAAAG2PdKN95K+ZorBsCgAAAACgA5BuAAAAAAAAcyPdAAAAAAAA5ka6AQAAAAAAzI10AwAAAAAAmBvpRlux2WyaLXQVBQAAAAC0PdKNttLT06PZwoqwAAAAAIC2R7oBAAAAAADMjXQDAAAAAACYG+kGAAAAAAAwN9KNtpLfQzS/EwcAAAAAAG2GdKOtbG5uarYMDAwYMhIAAAAAAJrmQ0YPAAC00leXTjzxmM4O48dOHJ58umnjKcf2Vm4xeiH1xnfTV5fUjTu7eg5PPqUoSquNFgAAAGgzpBsAUKuLM+fmzpzK3769lRPb586c2rW7N/L6StOHBgAAAHQE0o32kcvljB4C0InOTx9fjF4oudvOLprgAAAAAI1C3432kd9SVKHvBtBgi9EL5UQbiqLc/0BvowcDAAAAdCxqN9oca6bAjGz7hi9fe0ezscwSiSa7OHNO/nbMeWTMeWTPXpu6ZXnx8q2bazeup+WNqFr66tKN6+mLMy9ub92pVrPtGx749Gdt+4Z5kQEAADoW6Ub7yK/d6O7uNmQkKJO4Mb51c30xeiHy+squ3Xy2bzLLi5dv3VxXvy3Y63Ro7EA5p+JiKGl58fLFmXM3rqfzf5S+upS+uqScOTU0dmD82HO8egAAAB2IdKN95PfdYFpKiyvYhxImknrjzvIoe/baalkYhYtBX/D45PLi5ZK7LS9eXn0z/dWXLxJwAAAAdBr6brSPRCKh2cK0FKChVt+8U0dQZo0GqnDiicfKiTaEWzfXn392sqHjAQAAQAuidqN9rK2taba0bO0Gy7ugPcitH+j40Djvbt71G+Pw5NOiy4b4dnnx8t9+65Icf9y4nl5evEzeBAAA0FGo3WgTuVxufX1ds7Fl0410usDMeUVRHnp4qMkjAWohN924p5tSqUb50gsz4ouhsQN/+b1/GD92Qo02xEbv6ZnxYyfkQ/72W5eaOkQAAAAYjdqNNpE/LUVp4XQDaD87u0g3GmXX7l4RXuh0Njk8+XTqje+mr77fCUWeNAQAAIBOQLrRJvLTje7u7r6+PgOGAgD1Vk7H1kceO6KmG3JZDQAAADoB6UabyE83RkZGDBgHdLkfGSx20+V+ZLDYUbt290ZeX9E/c/rq0o3r6YszL6qdIHZ29RyefGrPXptcw69jMXpheyu3vbUpliaV2fYND3z6s0NjB9tjHYpbN9eXFy/Jn/MrirJnr21o7IBt37B++4zq3sGCK8U27mKo2sWZc+rSLTu7ev7ye/9Q3/0bbWcXa2ADAAB0LtKNdrC2tpbfyYJ0o0PcuJ7+uv/4jevaC2B7KyfuPPfstX3Rf1rnpl2+Ry0ofXUpfXVp7swp277hJ0+eNm/GgSfeNAAAIABJREFUsb2VOz99vODqGzeup29cTytnTg2NHXjy5OnOnGZi2zesfHAlbG/lblxP62c98lVn2/fZxg6uQua9SgEAAFAduoq2g4WFhfyNpBudYDF64VmXIz/akN24nn7W5ViMXqj94dJXl9yPDJa/NmdLSV9dcj/ycMnBLy9eftbl6Mx5DXv22uRQQK5tKSh99bvq1wOfLqtEqKHuTluMHw8AAACaidqNdjA7O6vZ0tvbS0vRtrcYvXB++niZO4s9x5xHan/c4PFJrzJjruU201eXTjzxWJk737q5/tzjhxs3AaSVDY0dVKcmpd74rk63ixvX0/KCuJrr4cQTj5UMR4qx7Rs+9dKrVRwoR3h/8HkzXZ8AAACoHemG6aVSqfxpKYcOHTJkMNCnuWE+8NB98o8qqqW/dXNdE20MjR34g88fVG8ylxcvv/7qBfkO8/z0cdu+Yf1H2bW798mTp+XPvbe3covRC4vRC3I5w/np4/2fsJml+P/WzfXg8cflLaKTiHrrLp6j3LXk1s31izPn8u/t6/gO1vFUdTTw6c+q6Ub66tL2Vq7YJB1N1xLD5/LIl6ht3zC1GwAAAJ2GmSmmFwqF8jdOTEw0fSBoKk3vzydPnvaevqueYmjswKmXXhXraBY7Kt/9D/Rpbgt3dvUcnnw68vqKfPLtrVzJU7WOizPn5CqD8WMnTr30qpxcfPAcfyC3mbg482JTR9kabPuG5ZxCZyJPS00DuXVzXe5v+uTJ08aOBwAAAM1HumFua2trc3Nzmo02m41pKe3t1s11uQj/8OTTxaacHJ58Wr6N15RgVESTntRyqmbSvFYFly8Rdnb1fOmFGfVb0Vaz4eNrPfK1lHqj6OwSuemGfvPRRhMzidQAy9SNbwEAAFA1ZqaYm9/vz984NTXV9IGgqZYXL6lfi5VfdXY+PPmUWO1VPVanmYK+8WPPyR/m13KqppFfK9u+Yf0B79rdOzR2QH2O6atLxt63G2Jo7IBamLO8eHn7ZIHJKXLTjZ1dPflNWKprnFGFWzfXn392Ug3aDk8+ba6OMAAAAKgXajdMLJFI5BdudHd303Sj7WlW4tRvebCzq0derbOWegRx81+XUzVN6g15XY/Sq5bu2t2nfm2K4pS627PXJmc6BSenyE03DFwLVlRtqNfhmPOIZioWAAAAOge1GyZWsEZjamqqp8fg9n5otNU378QK5RQX7NlrU+9R5WOrUMdTNYc8yLkzp9TuDOWQu3V0lKGxA2pk8Lffupw/70kOtoxaC1ZEG2oCNTR2gHYbAAAAnYzaDbOamprKXyqlu7ubaSmdQK4pKDPdKHhsFUxX2lBLQrG9tVnHkZiIHGekry5p3ujtrZzcdMOQmSCaaMO2b9h7ekb/EAAAALQ30g1Tmp2dPXv2bP72UChE4QYaamdXt9FDQMPt7OqRAw65d4miKOmr31UzI80aK82hiTbGnEea1uYDAAAALYuZKeaTSqWOHj2av314eJiFYAEdp1561fC1S83iDz5/QF1rZjF6Qe7Geve0lGY33ciPNpiQAgAAAIV0w3RSqdTIyEj+9u7u7tnZ2WaPBgbZtbtXvbu7cT1d8o5dvh2tcbHMOp6qOXZ29aiFBuW8VhBs+4b37LWJt/vWzfXlxcvqDBR5hd1iSxGfeOIxufNopQ9drBZjeytHtAEAAICCmJliJrOzs5/61Kc2Nwv0AgiFQn19fU0fEYzR/4k7fTTKWbhE3kc+tgpyK4r7H+ir5VTNUelrBZWcXLz+6vuJhrwWbPOnpZyfPi732iDaAAAAgKpwuhGNRoPB4L333rvjbqOjo8FgMBgM6p80GAy6XK7yj81kMupu8Xi82DnVfQrukMlkxPl35PH5fNFoVH/MmpOMjo7mn6e/vz8YDCaTyYqeu8fjKfPR9U1NTRWckKIoyvj4OHNSzEi+M/zZ22vlHyh3CZWbIBSk6QFZThdSHfLn9jWeqlLyy1V+Q1N56sTy4uWWDTiqvhgaZ8x5RC3PUXuLygvE/sHnm9pP9OLMOfXR9+y1eU+/3MxHBwAAQIvTphuZTGZwcNDlcvl8vmw2q/lpPB73+Xw+n6/YHb4IFwqmCeqxxeKJGkWjUXH+gqNyuVyDg4OZTKbY4fF4XOQX4iQFQ5ZMJlPw/EIkEin43CORSMlH15dIJAYGBgq2EVUUZXx8nDkpJiV36Kzornto7KD69fZW7uLMizo7X5x5UY4/5GMrdXHm3N2naurNrfxylb8Yreb5ft1/vDXXea36Yijm4sy5Aw/dJ/53ceZcdSeRyzfESdQOozu7epp5AcjX+c6uni+9MNP8bqYAAABoZXf13chms6OjoyVvwi0Wi91uz98+OjparPKiCaxWq/4OyWRydHR0ZWXFYrEU/GktD+TxeCKRSMlHj8ViJccpW1tb8/v9c3NzxXaw2WyhUKj8E6Kl9H/CptYgLEYvjDmPlHnDtmt375jziFpGcXHmnNiSv+fFmXPyna38aXxBP3t7bXsrV3AYy4uX586cUr8VfRnKGW29yIvR3rieTl9dKqeJxq7dvUNjB9TP/G9cTz/3+GNf9J9u8uBLqvpiKGjuzCn5fZ87c2p7a3P82IlKzzPmPKKmY4vRC3v23hnk0NgBnRHWfRGTxegFNZY6PPmUKXq+AAAAoJnuqt2IRCJqtOF2u2Ox2O27BQKBQCBQMNrQ1Dt4vd7V1VX5WLfb3dBnYrVaHQ5HIBDQPG4gEFADBTHxpOSpxNPUPPfV1dVAIOB0OvPDEZ/PJ0cbgUBgY2NDHBWLxRwOh/roHo+nzKeztrY2MTHx4IMP6kQb4+PjiUSCJWDNS77BvnVz/bnHH5PL/sXGizPnnnU58o89PPm0fG95fvp48PikfPjy4uUTTzwm5xE7u3rklS8KunVz/U8+87tzZ07JLSHTV5fE+eU9H/tPT5V4evVm23fX8hznp4/Lz/fG9fTFmXMnnngs/8DxY8/Jr9WN6+lnXY7z08fzKxq2t3IiD9I82Sao5WLQEM9Cs1FTd1OmnV09hyfvvNHnp4+rXzd9WsqdAqVirUwBAADQye6q3VCnVDidznA4nL+31+tV/18mpwYWiyUWi+UnIAUzkTqy2+2xWCx/u9frdbvd6sSQSCQSCAT0T5X/BBVFsVqtBbfLz91qtWqqMxwOh8PhUCs74vF4PB5X8458uVxuYWEhFAql0yVK05mQ0gaGxg7K6cON6+ng8UnleIE9b91c13xYvWt375MnT8s34cuLl5cXLxc8XHjy5OkyP/HWVHzkOzz5dPMXH9nZ1WPbN6zGLrdurhd8uQq+Vt7TL2uCD1H5Ir/+mkPqNewy1XIxaMidXzXbq6gHkcs3VLt29zbzAlhevCwP4E8+87tlHsgawAAAAJ3jrtoNtdFGwbkbOuSCiPn5+UYHGZWyWCxq5Ug2m83vJ1ILzXMvOPEkEAioL6nO5B2/32+xWI4ePaofbXR3d7/yyitEG21g1+7eksUUQsE2E0NjB8pfM+LJk6fr1SVhaOxAFXMc6qKcxy34WolFRsu/ty+/a2m91HgxyOQWHuVsL3W2u8o3hCZXT9y6udbMhwMAAIAZ3ZVuqKlEJBLRaZ+ZTy36EKUK9RpcHcmBS33TDbngpVisY7FY1JelWLqRSCSmp6dLPtzw8HAqlWKFlLYxfuxEmfe0BY05j7wwH9dvIbFnr+2F+XiZt6MlaxaePHnae3qmgiHW1Z69tqobOtj2DUde/0H5r3bzm4/WeDGoCk5B0kxlqkh+ExDmhgAAAKDV3DUzxev1qvfqYmFUt9vtcDicTqfOKZLJpJoXGB5tiEoKTTRjt9sbVE5S/nO32+3itS3WtDWRSOg/Vnd3dygUItdoP+PHTow5jywvXkq98V2524XyQRNQ/TteEV6kry7duJ6WZxCIj9z37LVVVJl//wN9kddXLs6c0wxmaOzAnr22utx718i2b/gvv/cPi9ELmuVdy3mtdnb1jB87MX7shJh3kz8tRTzNSl+0OqrxYpDPs7OrW32CNeYm4lpSz1Zjx1MAAACgEe5KN0TrCpfLpd6xRyIR0TBCJ+aQSyEMnJMSjUY9Hk/BuoxkMln+kigVkaMKj8dTTtNQMTWm0rk/iqJsbm6mUqlcLkcb0fYj7lpruf+07Ru27RuuV/pQ42AaTdQm1DJCcWztz/HytXdqPEO+2i8GoXFvYpP7iSotf0ECAACgFfyG5nuHw7G6upq/vkkkEnG5XP39/Wpxh6rkCrJNIIZX3ykn5ajuEQseNTIyUvLAs2fPDgwMlKzyAIA6unVzXV2yRORoxo4HAAAAyKdNNxRFsVgs4XBYrKWqKdbIZDIul0tToVCwj2bVqsgLstmsPBXF6XTOz89r1nNt0Hq0VZRgFDMyMvLaa6/19pboerC+vr5///6pqal6PS4A6Lh1c/25xw+rM56avxIwAAAAUI4C6YbK6/WKmCAQCMhNJTQ9R+U7/NongFSRbkQiEfWoQCAwPz+fP4NGv3VI1eRkJxaL3S5PsTzo0KFDa2trP/zhD8fHx7u79VY3OHv27MjISC7X7K6HANqY6N6ifnvjevrizDn3I4PqCjJjziMUbgAAAKA16aUbKq/XG4vFYrGYGmQEg0E1ULDb7er26tINOR+pYp6LHIg0qEajmNqfe76BgYHZ2dm1tbUzZ87olHIsLS0RcACoo9dfvfCsy3HgofvE/551OeTGq7t29xq1EjAAAABQ0odK7/IBh8Ph9XrVqo1kMqkWdDgcDtGPIxqNZjKZSueqWCwWq9Uqco1iC6a2LKfTKRqviiVm6jVXpaenZ2pqampqyu/3h0Khzc3N/H3S6fTIyEgikaDPKIx1fvr4YvRC7ecZcx558uTp2s+D6qSvfrfYj3bt7v3qyxdZKgUAAAAt667aDY/HI1ZULYd8Gy9XTLhcroL76085UYOSZDKZ37i0/JFUemzt1OeezWZHR0fr3mPV7/evra0dPHiw4E9FwEEFB4AabW/l1OYaGrZ9w199+eKu3SW6AgEAAAAGuivdSCaTPp9vx44dwWBQExOIH6mFGxaLRV78VV4sNplMDg4OinIGIRqNulwuuVVHPrkvhthZk4bo1HTIx3o8Hp/Plz9JpHHLqdjtdq/XK75OJpP9/f0+ny8/ZAkGgxWFR7Kenp6FhYVXXnmlYDOOdDo9MTFRxWkBQDZ+7ISmrcb4sROnXnr11EuvEm0AAACgxd2ZmZLNZtVQQD+JUBRFvZ9XhcPhZDIpKheSyaTH49EsraJPTHtRb/6DwWD5QYDVag0EAuqYKzq2LgKBQDabVQMdnUfPf93KNzExMTAwMDIykj9L5dKlS36/3+/3V31ydLLDk08fnnza6FHAYDu7ergSAAAAYF539d2w2+3ltMYMh8P5zTstFsvKyorL5aq6cUYgEFB0owEdXq/XYrFUlKfUVzgcdjgcHo9Hv0ikxnkrAwMDiUSiYMAxPT09MjIyMjJSy/mB6jx58jT9MgAAAAAY6E66IeKJZDIZj8cLNr8Q6YNO9YHFYonFYvF4PB6PyyGF2+12OByZTKZkSUggEHA6neJwTUzgcDhEb45ia7u63W632y0OzI9IrFarmsjUq/GnhtPpFB1Gs9ms5plaLBbxutVSuyHoBBwTExNra2s1nh8AAAAAANPRrplit9vlhhpVEDGEiEJkZRZliAFUnQKIA/MfvZwDa48elA+ajNblVMWIgONTn/qUZvv6+jrzUwAAMKlUKrWwsJBKpWgWDgA1GhgYEJP6+/r6jB4LmqeCFWHROgYGBs6cOXPs2DHN9lAoNDU1xQKxAACYRS6XC4VCs7Oz6+vrRo8FANrE0tKS+GJ4eHhiYoJFGDrEb5TeBS1pampqeHhYs3FzczMUChkyHgAAUCm/39/X1zc9PU20AQCNsLS0dPTo0b6+vkQiYfRY0HCkGyY2OzubvzEUClHRCgBAi0ulUgMDA9PT0/mNtAAA9bW+vr5///6pqSlulNobM1NMrK+v7+TJk9PT0/JGUb5B9w0AAFrWwsLCxMREwVxj4CP3DPybe5o/JABoG9v/+q+pX27feO9Xmu1nz55NJBKJRIKJ/O2KdMPcpqamQqGQ5s+j2dlZ0g0AAFrTwsLCo48+qtk48JF7Humy/FF3Q5Z1A4AOdOtf/vmbm9lo9v95919/rW5Mp9MjIyMEHO2KmSnm1tPTk98jZ319fWFhwYjhAAAAPalUSvMf7nt+4zd9u3affcBKtAEAdbTrt/6Xo//b/fP9H3vk7t+u6XT60KFDRo0KDdW8dMPr9d7+QNMetBNM/f/s3X1UW/ed7/udjjvxbShCWXVqt1AJYd+m2AkkkF4/nFtEI2xP7hpDx4ZxOtMATgxrpSuxUqeB0zRGuE0PpHEjJ5OcBaltkdM1ccE+xZm1UtuQGHprx00gFfFDkxuDYaCxa89EiOAe59St7x873f556wE9b+2t92v5D7Ql9v5qSxj2R7/f9+d0Bm4k3QAAIN1MT0+rJqQsvnH+buticg0ASJKsT/3Nf12Y27wwV9w4ODjIUHdDYuyG7lmt1srKStVG0g0AANKN2+0eGRlRbi6+cf7OL9kWfvpvNSwJADLB35nMqoCjtbV1fHxco3KQLPTdMIKqqqoDBw6IW/x+v9yMXauSdGHs3ZOXPvrkA7TPf+FLt3wxT9t6wqPa5NFXtRd+P/mHD/5d/vqmz5psty7Ttp7wqBZQjI+Pi43Ab/rU3zz5RUvWp/5Gw5IAIHP8nck8+5c//8uFc8qWuro6lok1GNINI6iqqqqvr1dt7O3tJd0I76dtj58cOiZ/fe+D3733wce0rSc8qk0efVX72oGXX37hx/LXy0pX/shzIPzjtUW1gMLtdos3H7plEaM2ACCVqs2f+/XsjPePl+Sbg4OD4+PjVqtV06KQSMxMMYKcnJyysjLVRpJIAADSh8fjUb4u/sxN9NoAgNT7r9fPT1HlztA70g2DsNvtqi2Dg4NaFAIAgO4lvNvcwMCA2Ex0g/lzid0/ACASCz/9t/8lK1u5SbNCgyHdMIjAdEOSJK/Xm/JCAADQvdbWVqvVmsC/esUBlTd96m/+b+FvawBAKokLxE5MTNBb1EhINwyCdAMAgASamJj4xje+YbfbE/LLVEw37vjMTfHvEAAQG9V/wlwxGQnphnEUFRWptpBEAgAQj8HBwTvuuMPpdE5PTydqn4tvnJ+oXQEAopX1qb/5/Kc/rdwk3TAS0g3jCOz3S2NRAADit3PnTqvVGk/zOfGvZ5ZKAQBtLeL/YYMi3TAO1n8FACBJ/H7/I488YrVaY/vkQGwpyl/VAAAkA+mGcQSO3WDZFAAAEmhiYqK8vLyqqoq5nwAApBvSDeMITDcAAEDCHThwID8/3+VyJbAZBwAAiBPphsHx4RIAAMkgrxrr8Xi0LgQAAEgS6YaRBF0UlnQDAIAk8fv99fX1xcXFtPEGAEBzpBsAAACxGxkZKS8vr6ur4xMFAAA0RLqBVGOWMgDAeLq6uoqLi2nGAQCAVkg3kGperzfUXbfdtSqVlQAAkEB+v7+1tbW4uJhmHAAApB7phqFYLBbVljBRAgAAGeiGCMSz/4mJifr6ervdzq9gAABSiXTDUAIXhWV8LAAAqTc4OHjHHXfU1dXxixgAgNQg3QAAAEiKrq4uq9Xqcrm0LgQAAOMj3QAAAEgWuRmH1lUAAGB8pBsAAACAMS2q2ZC3edNX3E9/7d13tK5FT+ZlZ+dt3pS3edNX+15dsn2bVmXMz8u9bXfn/LzchD8YMCTSDUMJnNwb2IkDAADDS6tff7W1tVqXgMz1ubWr87c6F6xdrXUhOjPPlJ2/1Zm/1alhWGBeufzO/XvNK5cXup+O5PGF7qflb8laWpjs2oD0RLphKCMjI6otafXnHQAAqWG1Wrds2aJ1FVJZWdmRI0dYIBZAtBasXX3b7s552dmSJGUtLczbvCn84/O3OuVQY152tpyJpKJKIM2QbgAAAANyu90aBhwmk2nPnj0DAwN2u12rGgDo1IK1q78ijNfwHTs++eLu8N9yrnvf5ckp5eZtuzsZwYEMNE/rAgAAAJLC7Xa7XC6v1xvtN5aXl8dz3JaWFqfTmZOTE89OopW1tNC8cvmCtavFS5orMzPyRdG5n++7MjOTynoAxCZraaEYbZzr3vf+tu1zftflyam312+8fc+1UOP2PZ1vr98oRh6A4ZFuAAAAw8rJyUnl6InKykq3253iaaHzsrOXbN8WtLHCvOzs/K1OSZLytzp9x46f3eGePXU6lbUBiMq87OzC6KMN2ZWZmXfqG+7cv1fuFTIvO/v23Z1vr99IsonMwcwUAACAeFksliNHjvT29qY42pifl3vn/r2R9IxkHj6Q/pZs36b0MfUdOx55tCG7MjPzzqYGZbzG/Lzc/EedCS4RSGOkG8YxMDAQuJHpvgAAJJXJZHrmmWfGx8c1+Z1b6H5aXNPh7A73mxX3/OrW2+V/v3M+qkzXnz11moEbQDpbVLNBSSovT079zvloDDu5PDl1WvjGRTUbSDaROUg3AAAAYrRly5bx8XGnU5tPR8UuG5cnp96suGfyxd3iNPuLBw+f3eH+1a23T764++LBw5oUCSBC4sIo77dsj3lGyeyp02d3uJWbS1q3xVsZoBOkGwAAAFErKys7e/as2+1OcfdQkdhAVJVrqJzd4Z5zzQUAGlpUs0EZh3Wue5/v2PF49jb54m5lrNb8vNxFNRvirQ/QA9IN4wicmWKxWLQoBAAAI7NYLL/4xS8GBgZS3GIjkJhu+N6I61oIgLbEgRsJySLF4Rufi6A1D2AArJliZJr/1QUAgJGYTCan0+lyubQuJFnmZWcv+scNOSuWqybqX56cOte9Twq9suxX+16VP3aWJ8iE2v/X3n1H/sJ37PiJTQ1BH7OoZsM8U3bW0sLAVqnnuvddnpyK/MJvfl6uvJOge1N2GH65XPmcqPZw8eDh2VOno7oEXVSzYcn2TyYIvL9tu3w+oxX/TvI2b1J9kn+ue9/sydOR70peezhv86Z52dnyFvnt4Tt2PHxjl0S9Scwrl8u5XuAbVV4C+fLkVOTzsBbVbMhaViieEPnFjWomlxxMyOsTBdYjSdKcJZlXLhcHbiRkGVffseO+Y8flUySfNDrvwPBIN4xjenpa6xIAADCs2tpabeehhGdesfzcZCwXzLJ52dn5jzpDDV+fn5errCwb1RKVMZShXL0HksvL27zp/W3bw1wrzsvOztu8SfwkPMwOlevPoPK3OoPuZ8Ha1QvWrp6zEkXe5k3ipe+S7dvmmbKj/Xw+/p2sfPPXSiShWFSzQaqR8jZver9le/jZEKHWHpbfHvlbpYsHD7+/LfZuEZG4bXdnmB6ZyhLIC48df79le/iMwLxy+ZLWbWJTXpn84gZGFUEtWLt6yfZtgWdVVc+ccYk4tuLcz2P/QVaZ+ulu5XQtWLuadAOGx8wU4/B6vaotxcXFmlQCAICRlJWV/fa3v/V4POkWbUwLs1HEz9KjJS8rmw4z86/MzMx5bTwvO/sr7qfDVDvPlB1JtCH76GTw6z35nITfj1xJJMcKTAQiWcQ34TsJ8w6Zn5d72+7OMGc1a2nhnGsPL1i7+s79e8UJU1oxr1x+++7OwORCsahmw21hHxCJRTUbvuJ+OpKfuzmbaCgnNrFrG/mOHVd+oFg5BZmAsRtGlm5/hAEAoC8Wi8XlctXV1WldSHAXDx5WQg35avy089FoL43mZWerrgPP7nBfPHhY/NxbnBCRbMoYftWohLzNm8Q1YvIfdV48eHjOKCTMnBqxiaNK0HOi7MG8cvlCYeXO/K3O2VOn4+wBmTIXDx6ePnZcmYeyYO3qhcKKoUu2b/so2NX1vOxsce3h2VOnz/18n7KTvM2blJM5Py+30P302+s3JnUEhyywV648Zkf5iVjSui3o3JaspYXi+9l37Pj57n3K2IpFNRs+t3b1nFmAPNxJuXmue99/HDysehssWLt6fl7unFNCspYWKhFJwt9I536+Tw7g5KOk4HUBNES6YRyDg4OqLbrru/G9+spUHu7seyeVr1/r3XviraOpPHq0qDZ59FXthd9PKl+ffe9kin9qokW1kbj0kT81B0JU5BYbTqcznT8quDw5dfZpt3KdJgccFw8eFpdLmFP+o07lqvXy5NQ7mxoCx/Of696XsnTj7fUbg26ffHH35Iu7laEBcjuMOedl+N44HuoxYTpNqM6JKjOS2xnMCvNEch/YFP6i9OLBw6oRDTEs0Bv/Tk5salDVefHg4YsHDy/Zvk0ZtZG/1RmYCCzZfm0GR2A7DNVLMz8vN/9RZ/KmL4nHDdxy8eDhO/fvlcOCUM0m/k/hzRw40+pc975z3fsWrF39FffTYY6+6B83KJFEqDWJInyBxCQl4ZNHxB2aVy5nZWgYG+mGkeku3Tj51jGtDn3hg8kLH0zO/bj0QLXJo69qL300o+FPTbSoFjpSW1vrcrl08Wv0XPe+KzMz4mWY3DXAd+z4fxw8PGeryKyl1/opXpmZCRptpJX/b9v2O/fvlb9O0gwIVdPNUMNhJl/crYwlmbNl4+SLu6/4Z+JsCBr/TkJFMO9v225e8UlXS/PK5eaVy8VHih1Vr8zM/M75aNCdvFPf8NX+V+UL/kU1G8IvUZw8ct9ZJXgyr1yuel2UpqTyg0OlMB9FkzLEGUmIc1uiOm4k/pfwKsQ5EwdIf/TdMIjAphsSM1MAAIiJx+PRRbQhu3jw8JsV96g+kjWvXL5k+7aVb/46fFcIsY2CVpejUZk9dVoZWv9/JOdSTYw2wo+CEbs/zjmR4Vz3vl/derv8L7YFUxK1k6DEoQeq1UNVb5JQUxtU/Vk1bOOiimZU9y68/vVNyBFzVsTV0kIMHRL+Myi+gUk3YHikGwYRdMEUuooCAJAJLk9O/c756NvrN6queOUlG1a++etQzSDFa3K9dI644v/k6jrmLqrhLfrH6xYc/PznAAAgAElEQVQHDfNI3xvhrqL1RXym5uuv1SN/k4j3atjDUryeD4zAxMLimaYhPtm8zZu+IvQliZa4tm7M9YShBFJJ+pEB0gczUwwicOyGyWTSpJJ4LCtdqXUJAJBqlz7yn33vlNZVwAhmT51+f9v297dtF7s8Sn9d2mN+QGuAednZyjX5lZmZtFotUu4NqRp4Io8OmGdK4hXavOxs5QpwznMiXot+VufphrxajdKPU2k/GdWbRB5ZI+9E27jn8uSU/P5XXc+Lr+/lyal4WmzOnjo9+eJu5S2qzAibDt3qRStX/J+8KKQbMDzSDYMIHLuhx4EbP/Ic0LoEAEi1E28dfby+SusqcJ26ujq3263fCZ5yl8cFa1cv2b5NuZ7J3+pUliORiTFB+sxJyd/qDDWbRh6KktSjix+/z8vO/tq77yT1cGnl8uSUEknMM/013YjyTaJcSEuSND8vN33eVzLx6fyvuGs7u8N9ZWZGfE/KXUvytzpVa9MASA1mphjEwMCAaot+/yYDAEBbXV1dVqvV5XJpXUhcLh48/KbjHvHD9jDRwJ/8abFO5J3794ZvFJJsn451YIgBOhrM+R6I5E0Sf2SgL5Mv7g6cESZJkpwtztn4RiWp45IkYYoKYFSkGwZhjLEbAACkCb/f39raarVaAz8/0JErMzOnnY8qlzTz83LTuT3Eku3bxPIuHjz8O+ejShNN+Z/8aXnyakiTlEcTcyY7kUQ/SWr1ms7kGWHym1PVl0QebXTn/r3hw69k98VQjk66AcNjZopBjIyMqLboqNk7AADpaWJiory8vKysTF+rqIguT06d+/k+5QNkcYHMK8KVfKIuSmP+8Hledra4ykao5U4nX9y9qGZD8toHiDMpZk+dfnv9xiQdKA2JV+DKe0N8k0QyPiWSmSzJHqEQhvh0PrsswUmfPCNMkqS8zZuU1YIlScpaWnj77s4wyy2L28MvLRyDpC7IAqQbxm4Ywfj4eOBGnf4RBgBAuhkcHMzPz3c6nUFXKEt/oS5prszMKHfJjSRjPoQyH0Hs2hgV1cIcWjUskJtryl/HeU70JWtpofJkxWV3xU6iYofRSHaiujf+N0n8VE8nSfOJ5Okqv7t+2FSYKSriT2jCB7+I/W5JN2B4pBtGEDTdYGYKAAAJtHPnTqvV6na7tS4kamE+KhfXNBVXQo3W5alrV02xXTGKl7vi3lLv3M8/CVbmZWeHWknXeMIs+xr5Oq/h146N/02SEGJhSX195alVkRzrIyEJSvjcMXGHeln1GYgZ6YYRBC4HK9FVFACARPP7/Y888khxcbG+mnHkrLh2zan68PY/hCVU4pnxIe42titG8dJX2xET00LiIy9Mm5DdLqrZ8LV335H/iXNwUr+TQKqRBaqBM+LNMCdEtYJv4Oib+N8kCSEuG5S3eVNScxYxTQjzRhIHy8QTMgalRE7iUQCjIt0wgsCxG2VlZVoUAgCA8Y2MjJSXl1dVVQUdO5lK+Vud+Vud4S+/F9VsUC5vrszMBH4sr2yZn5e7ZPu2oDuZ8/Nk1RVjDJ8/f3Ty2sfXYs+C1PMdO648nfl5ubfv6Yz/Ajhv8ybx3C7Zvi2GpWESspNA8/NyC91PK++ic937VBHY5ckpJaqYl539FffTQfdz+57OMDuREvEmSYjZU6eVSuZlZ9++O8bXV14VJfz3ioNZwnfTEEsKP0AmKllLC5XzzMANZALSDSMIHLtB0w0AAJLqwIED+fn5LpdLw2Yci/5xQ97mTSvf/HXQC928zZtu290pXg9Pvrg78MPbszuuzbVZsHb1nfv3ioMC5Eu4O/fvDV+JeAEs/XVhV1XsEv5S/MrMTOAeAi+A5+flpqAn5fvbtisX51lLC7/a9+qS7dsCx0qYVy7P27zpzv175xzfEThUIYbBC/HvRPUSZC0tzN/q/Grfq8p5vjw5dfbpIHOvzj7tVk6IeeVy1Zskb/OmSHYS/5skUcTXd35e7lf7Xg2sZM5zm7W0cFHNhq/2vRr0vZq1tFD+AVS2iOFOIHEU1cLEjcoRR4KELwAwBtZMMYLAz45INwAASIHW1la32+12u+vq6lJ86AVrVyvXY/KlZv5WZ5jHn+veJy/ooDJ76vSJTQ3KZVjW0sIl27eFGsQRxtmn3eYVy5WPsuVxJXHvIdoqEuPKzMw7mxoK3U8rl6yLajZINVKo0zI/Lzex61wkSfgX5fLk1DubGoJOXpCXFi50Py2/OmHeJGF2IiXiTZIQ8usrjtqIoRJlhIU8PiL8e3X21Gmln0tQvmPHL09OyfUsWLt6MhErp8zPy1VCqNlTp3XxFgXixNgNI5iYmFBtoaUoAACp4ff76+vr7XZ7iptx+I4dF4ddhPf+tu3vb9seZlcnQi9XGaErMzNvr98Yz+h3eQ9p8gnz5cmpt9dvjPAMfzaamTuhtswpITsJ5Vz3vrfXbwzzHpDXxw1/xIsHD4ffSfxvkkSRX994lub5KOKw4OLBw+/Uh0x8FGL4mJDQR9xJ+GwFMAzGbuhe0L+lGLsBAEAqDQ4OlpeX19bWulyu1PwWvjIzM/ni7skXdy9Yu3p+Xm7W0kLVWHr5AdL1V02h+I4df7PinkU1G7KWFYqTDs5175s9edr3xvGv9r0aSUknNjWYVy6Xpzyo7lUmJsyeOh3q+vbKzMzvnI+ezcuVW28Ezg5QnpSUkj4C8hmWp0sEPiO5u0SYpyPu54p/Rhns8P627TFcV8e2kxObGrKWFsoDDQLnX/iOHZ9+4/jFg4cjybbkV2dyaaE8JUfZlfzK+o4dj2R0QPxvkkS5MjPz/rbt8k9Qzorlqm4Xyjst1POSE0P5vbGoZkNgAw55IliE51aSpHPd+5Qup/IZjuQnN5QFa1crPz6qOUGAgd1w9epVrWtAXDweT319vWpjDC/rwMBAeXl50LsS+yYJc6BXTl5M4IEAQBdOvHX08fqqoHel5ne03W4fHBwM3N7S0uJyuZL97fEYHx9PUl/PUL+nImEymZxOp+q533DDDcrXO/NsxZ+5Keb9a0LuTSB/fa57X5hhIABitmDtarFp69vrN8Y2nWRedvad+/cqgcuJTQ3pMF4mrWyZHPP+8ZL8dQp+WyFlGLuhe4F/2FksFi0KAQAgRbxer9PpDJqqaM7v97e2tno8HrfbXVUVPLcCgEAXDx7+3MHDypiLQvfTb6/fGMMyruJCP/KwmkRWCaQx+m7oHgumAAAyyvj4eKgBI+ljYmLiG9/4ht1uD/w1DQChqNZzEdfZjdBXhG64odavAYyKdEP3Asdu2O12DeoAACAlXC6X3+/XuoqIDA4O3nHHHalfTgWATsnL0yg3s5YWRhVwfMX9tDL0Q95VDEM/AP0i3dC9kZER1RbGbgAADCxJvTaSp6urS+sSAOiGvEizcjPCgGNedvZtuzvFRry/cz7KKrDINKQb+hZ0vCvpBgAAAKBT8iLNys2spYXy4ixh5G3eJC77QidRZCbSDX0L+vkVM1MAAEgTJpOppaVF6yoA6IwccMjzSmZPnT67Y472GWd3uOWRGvKau0QbyEykG/oWOHaDBVMAAEgTlZWVXq+XtQYBxMB37Pjb6zf6jh0XO3GEcdr5qPItya4NSE+sCKtvLJgCAEAaKioqcrvdhhlNeXly6le33q51FUDGuTw5JU5RSeCDAUNi7Ia+sWAKAACylpaWqwkSTxkmk2nPnj1er5ffyAAApBLphr6xYAoM7FDPS99cuWTdsgXfXLnkUM9LWpcDAHNraWkZHx9nCVgAAFKPmSk6xoIpMLBDPS8937pV/np2Zvr51q1Z2Tmr1qzTtioACKWsrMzj8fBbGAAArZBu6BgLpsDAvMcHA7eQbgQ18sbgmdMj+3c9NzszrWwsWlFWvPxrRSvKFhcWaVgbkAksFovH4+H3LwAA2iLd0DEWTAEy3NFDr+zf9eyZ0+oZapIkjbwxOPLGoPTMD1atWVf7yLaFufznACSeyWRyuVxOp1PrQgAAAH039IwFU2BgxcvL5tyS4dq33t++9f6g0Ybo6KFXtj2w/vzURGqqAjJHbW3t+Ph4hNFGUdG1UVS//eNs0ooCACBzkW7oGAumwMDWVN/37ZYdWdk5kiRlZed8u2UH01JET2zecPTQKxE++PzUxFPfuT+p9QAZpays7Le//a3H48nJyYnwW8RHzv7lL8mpCwAQkfcvX1a+jvx/cqQ/ZqboGAumwNjWVN+3pvo+ratIU5f80+LN9fc/LHfZkG8ePfTKrw8fEOOPM6dHjh56hYQIiJPFYnG73VVVVdF+o9VqHRz8pJ2Ql7EbAKCdMx9fvvSXPys3i4uLNSwGicXYDb1iwRQgkz32k13yF6vWrPvXY+/XPvKEEm3IG5t27Kp95AnxW359+EBKSwSMxWQyyau9xhBtSNcPrjzz8eXzf/rfCasMABAN1fRABr8bCWM39IoFU4BMtjDXIocX6+9/ONRj1t//sPf4r0be+OTj4tFTc3ToABBKbW2ty+WK5yME1S/oX/p99Z/7fJxVAQBi0OP7D+XryspKDStBwjF2Q69YMAXIcOvvfzhMtCFbu+Ha1B4aiwIxKCsrO3LkiMfjiXN0pNVqLSu7NsCqx/efs8K4aABAavzS7/vDn/6k3IxtOB7SFmM39IoFU5Ce9u96VpKkrmd+oNqelZ2z/v6HJElaXFgkzqFQHOp56fnWrWH2XPvIE3NezIue2LxBGbYQoVdOXpzzMeenJo4eOiCOiZAkaXFh0ao164pWlC0uLArzvamXlW3SugRArywWi8vlqqurS9QO6+rqlNYbl/7y5/92burJL/KxBACkzuxf/vzchXPKTZPJRLphMKQbesWCKUg3+3c9GxhqKGZnppV7o80p0sTszPTzrVuDrlRy5vTImdMj0jM/WLVmnbLUS7pZmMt1FBCplpYWp9OZ2Eb6dXV1LpdrYuKTUVS/np35pd/3dyZzAg8BAAhjy7+Pif1EE/7/PDTHzBS9YsEUpJUnNm8IE22oLMy1JrOWpBh5Y7Bh7V1zLsJ69NAr36lxpM8ckDOnr/1HEXTIDICgXC5XMv7k9Xg84s2281O/9PsSfhQAgMrsX/78385Pnfn42kKw8gA97SpCUjB2Q5eCthQl3YBW9u96Nqo5IAVL02v6hizMgIuRNwaf2Lwhwv2cn5rY9sD6zoNDqu0xzJRRFK0o+8GL+2L4xkM9Lylf/5fVLAcLaMxut2/ZsmXnzp3KlrbzU+f/9L/pMAoAyXP+T//78d9PiNGGJEm9vb1a1YPkId3QpaDphl7Wah4YGAi6fVGeNaV1IHH273pO+Vrur7FqTaVqHoTcrkKSpEM9LwWdIrGm+r411fepNj7fulW8Po/KnHGAKm7Y/tPgjz8/NdG+9QFxS9GKsuLlX1Mm18zOTB/qeWn/rudmZ6aVb9m/61nNZ98c6nlJGUVStKKMsRtAOnC73V6vV2nAIUmS5z8v/Hp25qFbvlD8mZs0LAwAjGf2L3/u+fA/enz/een6Rs579uzRy6UTokK6oUuBAYHJZNL7tLH5/FWnT2dOjyhX9VnZOT/p7g8aXizMtchX+5pf88ueb90qRhtNO3aFagi6f9ezyhOUgjUNycrOWX//w2uq79v2wAZlJsj+Xc9p+0zPT00oc4WysnO+3bJDw2IAiHp7e+12uzjD9MzHl7dMji2+cf5ak/mOz2QtvnG+huUBgAF4/3jp/52d+aXfdylggao9e/YksGM00grphi5NT0+rtpA+QiuX/NfejVnZJl20rty/61lxSMi3W3asWhN81sb5qQnxkWH6oWZl5zz2k10Na0vlm7Mz02dOj2i1hIo8O0YJZb7dskMXrwuQIXJycgYGBpxOZ1dXl7j9zMeX/+Wvzfw//+lPL/r032pRHQDo2/uXLwcmGjKTyeR2u4k2DIx0Q5dYDhbp4ybTtUFD8niB2kee0LCeOR099IrYALX2kScCZ8QIDz6gfF20oiz8cIyFuZZVa9YpnUdH3hgU043YGmfE4PzUxFPfuV+Zk7L+/odDZTcAtJKTk+PxeIqLi10ul9/vD3zAH/70pz/86U+pLwwAjKqoqEj+j1frQpBErJmiS4F9N0g3oJXFhUXiuID9u5795sol+3c9mz7rhojOnB5p33q/cnPVmnXhAwvv8V8pXxcv/9qc+xeXg9HkDMijNpQJMmuq70vzsAnIZE6n0+v11tbWal0IABiZxWLZs2eP1+sl2jA8xm7o0sSE+qqJn1Vo6NstO8QlRWZnprue+UHXMz+QO4wWrSjTaoKGyuzM9FPfuRZtLC4satqxK/y3jJ66NjFeflJRHS7aCuMkRxtKqrJqzTrabQBpzmq1ejwet9vt8Xh6e3vFbqMAgHiYTKaqv9K6FqQI6Yb+BE5LkSRJ7y1FoWvyeqWBa6bKMYf0zA8W5lrWVN+neT/RbQ9sUK78F+ZaQi2SIoonoZidCTLaPHlU0UbRirI5sxsAaSInJ8fpdDqdTumvjcO9Xm9gjy0AwJysAq1rQaqRbuhP0D937HZ7ygsBrilaUdZ5cKjrme1K1wmR3I9j/67nwje5SKquZ36gzNeQJOmxn+zKyjZOJqiKNtZU38eoDUCn5F/o/FoHACBapBv6Ezh2w2QyaVIJIFqYa2nasev8IxNHDx0IOoNjdmb6+datvz78Ssr6ayqOHnpl/65nlZth1n8N4wcv7itaUZbQuhKDaAMAAAAg3dAfloNFOluYa1l//8Pr73/4zOmRkTcG9+96TjW5Y+SNwfat96dy0sT5qYnnW7cqN6NaQyQrO0ep/8zpkXjSjSc2bxh5I8YZ9fLcn6B3zc5ME20AAAAArJmiP4FjN2i6gTS0uLBo/f0P/+ux9zsPDqk6bhw99ErQCSxJ8tR37lcSisWFRVGtIVKw9NoQD3FiS/p4vnWr2GuDaAMAAACZiXRDfxi7AX1ZmGupfeSJn3T3i30uYkgKYltgVWy3kZWd89hPohszIq4Ce/TQK+kWcOzf9aySEy0uLGra8VNt6wEAAAC0QrqhP4zdgB4tLiwS+4lGGBMszLUoX4uLs0ZI1W7j2y07xB1GYtWaSvHmC66tqV/nNZTZmen9u56Tv5aDGyP1SQUAAACiQt8N/fH71ctMMnYD2vpOjWNN9X1zLoYiJhoRpgyq4R4jbwxG3vlCbmKq3FxTfV/k7TYUC3Mtq9asU8ZHnDk9su2BDQ+6dsTWlDTabwnvUM9LStSy/v6Hog1uAAAAACNh7IbOjI+Pa10CcJ0zp0fOnB55vnXrumULup75wf5dzwaObti/69nv1DjEnpoRXoqLbS8kSWrf+sChnpfEQ+/f9ewTmzcE/d6uZ36gVCLPjonkiIFqH9mmClm+U+N4vnWrOCpENjszvX/Xs/t3Pdu+9f7YjhUVZeCGJElarbMLAAAApAnGbuhM0HTDbrenug7gr8QJI/IFf9DlYEVZ2TkRXo0vLiwqWlGmxCLycAxxRIbs/NSEKi4ZeWNQzEHOT018c+WSOQ/37ZYdgYUtzLU07fipKkORdx7qmaZgGMXRQ6+IKVIkz06WtuvaAgAAAPFg7IbOBLYUBbQVQ7PPph0/jbxDRCRjLgJbcsTWgjQUeUHWyGtO7NFDHGI82YcAAAAAdIR0Q2cCW4oWFUU9/x9IIHl4RYQPLlpR9pPu/qjGDiwuLGraEd1CJ8lQtKKs8+BbqqVtw0if5qMAAABAJmBmiu6xYAq0tWrNulVr1s3OTMuTNfbvei7wwn79/Q9nZZuKVpTF0IxTPsS/rnj/UM9LqjVZ11TftzDXsqb6vtSsFZKVnVP7yBO1jzwRagLOqjXrFhcWRRX3AAAAAEgI0g2dYWYK0lNWdo48riHy0Q0x7D/ynUeyhkvMkvpMI69B2wIAAACAtMLMFJ0JnJlCS1EAAAAAQIYj3QAAAAAAAPpGugEAAAAAAPSNdENnBgcHVVuKi4s1qQQAAAAAgDRBuqF7rJkCAAAAAMhwpBsAAAAAAEDfSDcAAAAAAIC+kW4AAAAAAAB9I93Qk/Hx8cCNVqs11XUAAAAAAJBOSDf0hHQDAAAAAIBApBsAAAAAAEDfSDcAAAAAAIC+kW4AAAAAAAB9I90AAAAAAAD6RrqhewMDA1qXAAAAAACAlkg39CQnJ0frEgAAAAAASDukG3pSXFysdQkAAAAAAKQd0g0AAAAAAKBvpBsAAAAAAEDfSDd0j66iAAAAAIAMR7qhM2VlZVqXYBzfq6tct2yB/O/lF57Supw5UG3y6Kval194Sqn2e3WVWpczB6oFAABAapBu6N74+LjWJQAAAAAAoCXSDZ2xWq2qLaQbAAAAAIAMR7qhM6QbAAAAAACokG7oTGC6MTExoUUhAAAAAACkC9INnQlMNySWTQEAAAAAZDbSDZ2x2+2BG5mcAgAAAADIZKQb+mOxWFRbvF6vJpUAAAAAAJAOSDf0p7i4WLWFmSkAAAAAgExGuqE/genGyMjI9PS0JsUAAAAAAKA50g39Cdp6g+EbAAAAAICMRbqhP3a73WQyqTaSbgAAAAAAMhbphi4FDt/o7e3VohAAAAAAALRHuqFLVVVVqi0TExOsnAIAAAAAyEykG7oUtPWG2+1OeSEAAAAAAGiPdEOXrFZrZWWlamNvby8rpwAAAAAAMhDphl4FTk7x+/103wAAAAAAZCDSDb2qqqoKXDnF5XJpUQsAAAAAAFoi3dCrnJycuro61caJiQmPx6NBNQAAAAAAaId0Q8ecTmfQjXTfAAAAAABkFNINHbNarbW1taqNfr+f+SkAAAAAgIxCuqFvQYOMnTt3er3elNcSqYGBgaDbF33JltpCAAAAAAAGQbqhb1ardcuWLYHbq6qqdDc/Zf5nbtK6BAAAAACALpFu6J7L5QpcPGViYiKw5ygAAAAAAIZEuqF7OTk5brc7cPuBAwdowAEAAAAAyASkG0ZQV1dXWVkZuL21tZUFYgEAAAAAhke6YRAejydwfookSfX19QQcAAAAAABjI90wiJycnFBrkdTX1zudztSWAwAAAABA6pBuGEdxcfGePXuC3rVz5049rqICAAAAAEAkSDcMpa6uLugCsZIkHThwoLi4ONT4DgAAAAAA9It0w2jcbndtbW3QuyYmJsrLy51OJ4M4AAAAAABGQrphQB6PJ9QIDkmSdu7cabVaaTUKAAAAADAM0g1jcrvdoXpwSJLk9/vr6+vJOAAAAAAAxkC6YVh1dXVHjhwJukysbGJior6+Picnx+VyMVcFAAAAAKBf87QuAElkt9vHx8erqqoGBwdDPcbv97e2ttbV1aWwruDOvnvy5ReeSuURL3wwqXx94q2jUmqPHi2qTR59VXviraPK1xc+mEzxT020qDYSF34/OfeDAAAAEBbphsHl5OQMDAy43W6Xy+X3+4M+prKy0mq1jo+Pp7Y0tbPvnTz73kmtjn7yrWMn3zqm1dGjRbXJo69qL3ww+fILP9a6ikhRLQAAAJKHmSkZwel0er3eUGupVFVVpbietDL/MzdpXUIUqDZ5qDZ5qBYAAADJRrqRKeQeokeOHCkrKxO3m0ymdJiWoqHLf7ykdQlRoNrkodrkoVoAAAAkGzNTMovdbh8YGBgYGPB4PF1dXVI6DdywWCxWq1XrKgAg1aanp0dGRrSuAgAAQN9INzKR3W632+0ul8vj8aRPulFXV+dyubSuAgBSbWBgoLy8XOsqAAAA9I10I3NZrVbSBAAAAACAAdB3AwAAAAAA6BvpBgAAAAAA0DfSDQAAAAAAoG+kGwAAAAAAQN9INwAAAAAAgL6RbgAAAAAAAH0j3QAAAAAAAPpGugEAAAAAAPSNdAMAAAAAAOgb6QYAAAAAANA30g0AAAAAAKBvpBsAAAAAAEDfSDcAAAAAAIC+kW4AAAAAAAB9I90AAAAAAAD6RroBAAAAAAD0jXQDAAAAAADoG+kGAAAAAADQN9INAAAAAACgb6QbAAAAAABA30g3AAAAAACAvpFuAAAAAAAAfSPdAAAAAAAA+ka6AQAAAAAA9I10AwAAAAAA6BvpBgAAAAAA0DfSDQAAAAAAoG+kGwAAAAAAQN9INwAAAAAAgL6RbgAAAAAAAH0j3QAAAAAAAPpGugEAAAAAAPSNdAMAAAAAAOgb6QYAAAAAANA30g0AAAAAAKBvpBsAAAAAAEDfSDcy3fj4uNYlAAAAANDeDQJtdwLEgHQjE42Pj7vd7qqqqhtuuMHlcmldDgAAAAAAcZmndQFInenp6d7eXo/HMzg4qGwcGBjQriIAAAAAABKAdCMjjI+Pu1yu3t5ev9+vumtiYsLr9RYXF2tSGAAAAAAA8WNmisGNj4/X1dXl5+d3dXUFRhsyhm8AAAAAAHSNdMOwpqenlVwj/CNTnG54vd6g261WayrLAAAAaWV4eLi9vb2goEBsSVhaWtre3t7e3q51dYDGaNUJzImZKcbkdrtdLleowRoqKU43QlVFugEAQMZqbm4OGmEMDw8PDw/LD/jwww/NZnPKSwMA6APphtFMT09XVVWJfUNDsVgsVVVVdru9qqoqBYUBAAAE1djY2NnZGf4xJSUlRBsAgDBINwzF6/Xa7fbwQzZMJlNVVVVdXZ3dbk9VXREpLy/XugQAAJBqPT09YrTR1NTU1NSkBBljY2M9PT1jY2NEGwCA8Eg3jMPj8TidzjDRhsVicTqddXV1OTk5qSwMAAAofD5fQUGBz+dTtgwNDZWUlGhYkrbECSnd3d3V1dXivTabrampKeVFaWl4eLi/v7+np0eekiMzm83yeWhoaCDoAYCgSDcMwuPx1NfXh7rXZDK5XC6n05nKkgAAQKCenh4x2pC3ZGy6obTVkCTJ4XCooo1M4/P5Ghsbe3p6gt7V3NwsSVJzc7PD4Whra8vY9wzmJAdk/f39Pp9P+fkym80lJSXyT5nNZot8b3LQNjw8PDY2NjY2ZrPZbDZbSUlJQ0NDVPsJWqeyc5/PJ+85hgqBa65C/7I9B68AACAASURBVPbs2RPmJd6yZYvP55tzJ0eOHEnNmyQJ72IAMKbE/vcbSllZWdCjt7S0pODbU1+w5hwOh6pys9msdVGaaWtrU85DW1ub1uVoaXR0NPIruqGhIa3rxdwaGhqUl8zhcIR/8OjoqPJgm82mbI/k/dDX16fsJJJ3UVNTU6gyxId1dHSE31uon1nxMUEf8OGHH4aPMjP8fwPEjLEbuuf1ekON2rBYLB6PJ936a4Ty/9x7/8rVf691FQCQamffPfnT9u9rXQVSZGxsrL+/X/66pKRE/ljV5/P19PRk+LAFSZIyfDBCTU3N2NiYcrOtrU38BFv+iFuexVNSUpLh50ovHA6H0lNG+cEPRXxAzP8byMMr5nxYe3u7z+fr6OgI/7DGxsbwD2hubvb5fGJGGQmfz1dRUSFOvErUngHSDX2bnp4OFV6UlZX19vbqqMXGoi/l33bXKq2rAAAgiZRJB2azuaOjo7S0VNmememGeCWWyWPRxS4bNputr69PdTaqq6urq6vb2tqam5vpu6EX1dXVZrNZmYkW/sdcTDcCR3hFRZ6EIi4zpEwtUR7T2dlZXV0954HMZrPD4VACNXk/4uSp9vZ2h8MRVcGNjY1itNHQ0OBwOMxm8/DwcGdnp1JkDHsGSDf0raqqKmgb0draWo/Hk/JyAABAOMoHufIFg8PhkC9p5BnyXLVmLPFir6mpKUzQw6fZ+uJwOJQsYHh4OJJ0Qw4UlO19fX3yFxUVFYEbZcpYHpvNFqZLcXt7u9y9RdbT0xM+O+jo6JADGvHpyKXW1NQoqY0cQ4TZj0jumCt/bTab+/r6lGodDkdDQ0NNTY1yKqLaMyCRbuiax+MZHBwM3E60AQBAGhI/O5UvcpR0w+fz9ff3Z+bwDUjXpxtczhmJmG6EmZwi55vy16r/B4K+H0K9ScIPgJKX3VECjvBzQyRJEvuGqI7e3d2tpC39/f1yt9Hwe5OJayR1dHSoghiz2dzd3a2sKhXVngFJkj6ldQGI0fT0dNA1UMrKyog2AABIQ+InlvIFjHjxEHSlDFF/f397e3t7e3tFRcUN17v55pvb29vD7KGmpkZ5sHh1EdTNN9+sPFi1vEv8xsbGxMqVwSySJBUUFNwQjPiRdVByQwqx7IKCgvb29jkv3lSFyadXPFeixsZGuVtBjM88tXw+X9C3inxmwjwR5VUoKCgIs/9IXp3Ozs5Q51M+mZE/nYS8OvI5Ue2hpqYmqkqiJUYVqrkhIvG9mtSmKmIsEtUPSOB+xDrn7CoiExsP2Wy2oHmu8t9jVHsGZIzd0Cu32x04J8VisfT29mpSDwAACE9JH5S/3eUh6JFMTqmoqAjzV76yXKjD4Qi6zEFJSYk4PD5MkfLSjMp3pflkmVBLqI6NjcknpLq6uqOjI8yzkK94I7m+7ezsNJvN8qffSdXf3x/qM/NIyG8GMTYSKWemubm5oaFhzr6S8ZQRpielXF57e7s89yHMThL16jQ3NwfdT09PT09Pz5yVxExugaH80IV6ccX3cFLHcCUwOqmurlaeV4RBififWJg3uVhkJE1SAQVjN3Rpenra7XYHbvd4PDpqIwoAQOYQP7YVPz5VvpYnp8R5lP7+/oqKisDrAfFCQhwDH3QPgbWlp+Hh4dLS0vBjXnp6ekpLS8NcesnXzxEeMXkfqounOp4RImNjY6WlpaGijVQym81zRmM+n6+mpiZMtQl5deRzEn4/ciVJGsShGr4R9OjKdrm/ZjLKSLgYMgjxYWF+msR8Np4BJshApBu65PF4Agdu1NbW6mXxVwAAMk3gtBSZKneIZFdtbW1Xr9fW1qZcEY2NjQV+Zi5/gCx/HT5GSfYIeZvNJlYuPv3R0dGrwagaKMrky1HlYqmkpKSjo0M8IcoF0tjYmNgBMXxtbW1tbW1tH374oaqGjo6Opqam5KUbYu9G+Wo8hos6eaFN1bKyqrOavMEagZTzGfh2Fc+kvPZn5HuL6tUJXHxU3ENfX5/4w9jc3JyMeRBidBU0jNNRpCgSM4gI8zjxhQgT4ognQS9zwZAmSDd0KXDghslkcrlcWtQCAADmplzAqK5exNxhztYbssDh901NTUNDQ8rVQn9/f+C18ZwfIKvqVC3ckG4aGxvFsTBDQ0NiUNLU1DQ6OqqcWGU6RngOh6OpqampqSnwuquhoUG+tE5Q+WrypbtyUw44ampqoso4mpublXNis9lGR0cDl1+JZ85LtIaGhuTzqdouv13FuC2SwSaxvTqqcyKXpOxB7o4pfmMyhm+UlJQor4I4TENhgHQjwjeqGFVEmBUydgNRId3QH6/XOzExodpYVVVltVq1KAcAAMxheHhY+Rs9cFK9siXolU+EbDabeBkZ+BH0nB8gS9c33UjnEfLDw8PiWJju7u6gD+vr61OeQmdnZ5pP4G9oaFA9EXlaTUVFRSQX/8PDw8rD5IU203ylCXEUSZKuYMfGxsRT193dHfSKWhz3ETQZjF/4Nplio82Ejw8aHh6WGxI3NzdXVFSEbxabbEQVSDbSDf0JuiQKAzcAAEhb4T+bjSR3iET41RBKSkrEsQxBLzPEOpO6cEOcxLMU9MN8marNZDp0owivurp6dHRUlX/19/c3NjbKy+KE+V7VOUnzaEO6vmdtkoIn8RUPP7EohgliUQmzvMjY2Jhqoej4ycNh5BVz5IBMbqoqL7CakEPEL+jaNwqtq4NekW7oz8DAgGpLUVERAzcAAEhb4mopgZfi4mVePFdWczb5E6+dgsYoYuSRziPkIx/JL96ri6UlbTZbd3e3aqKN9NeVUG6++eZQ+ZceZzcob/sk9VYQ043wwUGi1kkNRfzBV7X1FV/QhESK8pCfxsZGXbzhgcQi3dCZ6enpkZER1ca6ujotagEAAHMT55uEunpRLr3EuSExEKf3B94rXjCH724oDvRIN+L5FLuWBCUmRzoaFa80SRXbo0qhl/aI6pykmDwnQvXJvDwUJakNI30+n7L/Oc9JChbpCBW0iS9c/GM3enp6xG674csAjGee1gUgOoEDNyRJYqkUAADSlvgBcqhLC4fDoTyss7MzsBFjQsiNQuUrq7Gxsf7+ftVH1mLTjWQUkBDiJXEk8y/MZrPyLWNjY+k/ZUMk99Hs6elpbGxUnkVzc7PNZhOvhKM9J6khz4YIepc8FCWpRxev8H0+n+aTHRwOhxIpDg8PKy+fsjH+Hzqfz6daL6mkpKS6utpms4lNgjU/FbKgayEBcSLd0Bmv16vaYjKZiouLNSkGAADMSRy4EeoD5GQPjFc0NDQonxur0g1dT20Iw2azpU+vgdhUV1c7HA5xZdPm5uZQn/OnSS/Y2Ba1TaCYB4Yk6d1SXV2tRA89PT3yQi2J/aHr7OwUn3VbW1uSctJAMbzr9PKfDPSFmSk6E5huEG0AAJC2fD6fcgEzPDwcqoXezTffrHxLUmfLi/P/VV029bIWrCiSK1i9RxsyeWkYsQ1nOk+0aWxsFMurrq7u7u6+er22trakBjFpkvIoxNkxSidR8Yc9/mkp4t6CrsWbWOJPVoSToebsDQTEiXRDZ6anp1VbmJYCAEDaUnUQjEQ868JGQrnmkRdWUL5WLo0StXBDkohXrZFcIKXnrI0Y2Gy2UEt7RHtOIhHz2AfxfSVJUkdHR3d3d+CbKsxiNwkhvtYlJSVXo5GkkgLXhRU73cR/NhKblcxJfKdFWHwy3qiAiHRDZwYHB1VbcnJyNKkEAADMKbacIp51YecUdOUU8YhpPnBD/Ax8ziRIbCaSVr02YxMqnTGbzcpdY2NjiWpMG9t+VLMtVIu/pIzZbBaHuiS1g2mEAtvcKO/ehIcRKXi3iz96MYzdSOfBR9Av0g3dY2YKEINLH/lf693rfvyh79VVblxesG7ZAvnfxuUF36urfLHt8dd69176yK91mQB0T/xsds5PjBOyLuycxCEA/f398jWGOC0lzcduSNGs86rHZiJhhLlEF5+das5RVMQAJbZP19NnsIzyPvf5fElNDCNUUlKinBDlR0+mxzdnDGvZiu+HdHhFYDykGwAyy4m3jj758H33rli88/sPvX5g78mhY3+cnVHu/ePszMmhY//2s86d33/o3hWLn3z4vhNvHdWwWgC6JjZHiOTqRfnTP851Yeck5hdyJ0IlBdDqk/aoiEWGWVjU5/OJa3bo4qmFJ4Y1quAg8DWN7RDxX3+qlrCNrYyEEH/okr0AbYSUl0letEj+2mazJWSoRSrnfYjpTOSdesR36fDwcFJjXGQm0g09CWwpKjEzBYjYibeOfq+u8vH6qt+8/ssIv+U3r//y8fqq79VVjr17Mqm1ATCkaD/bjHxIQpwcDodyrM7OTvFiWBefIYvDT3w+X01NTdCHVVRUKM+roaEhnZtuNDc3Nzc3h7/87uzsDNP5VXxNx8bGVCuDKuacDiBef7a3t8cwfUB8q/f09Gg4AcHhcIhpQkVFhea9HsSTo0RvEf7QieFF0OBJ3HlS/wNRLegbeftS1dAwcZ3jUAdiAguiQrqhJ4EtRSVmpgCRebHt8cfrq04OHYvhe08OHXNuKH/5hacSXhUAY4t25HkqJ6WLFyTKhYrNZtNFuiFJUltbmzjIv7S0VJyO0d7eXlBQoJxDm80mL8CZtjo7O9vb22+++ebGxkZxvImsvb29oqJCDCyCtuQUn2NPT4/qnPT09DQ2NpaWloavRNW7tLS0NHDUQ2CFIrPZHLiHwPdzanphdHR0iEOiCgoKGhsbA2fu9Pf3t7e3l5aWJrskcdEiRYQ/dOLD5PdJf3+/XLkcdogPaG5uDhrlxJ96yHmiOHAjqlFR4oPlyCloSfLAq4KCAsZ3ICrztC4AAJLr0kf+79VVnn3vVJD7FhRIuUVS9uelWxZ/suXCGeniqDQ1Is38QfXYl1/48di7J51PPnfTZ01JLhmAQUS7IIKqdUJSL8gdDkdJSYnqmlNHczfkFVJramrkS7jh4eHGxsagAxZsNltfX1+6rQ8q6unpUS6q5Qtv8YPxQA0NDUE/LS8pKenr66uoqJBvhjkn4bW1tfX39yvXxvK4kjj3EG0NiWI2m/v6+sSrcfkMhzotY2Njye7H6XA4VCMvIux009DQoHyjavSE/H9FdXW1stHn85WWljY0NCj/q8gzQaIKC0pLS+Xa5HMiT7UT366SJHV0dET1w+VwOJqampSAbHh4uKKiwmazKbmPPFGOIRuIDekGACMLHm3ceJNUuEa68x+k7IXqb8gt+uSLi6PS2/ul04fFO3/z+i+/V1f5I88BAg4AcxJ7Z0Q+8lxJHOQh2Um90GpoaFBd4+ko3ZAkqaSkZGhoqLGxMUx7iOrq6mivvlLP4XC0tbVFGAF0dHSEeZkcDkdfX19jY2M8UzDMZvPQ0FBNTU3MH5vLewj/0qSMzWYbGhpqb2+P5Awn+4dOCkg3Im/iKy9AE6ZlrDxGSQw42tvbAwfa2Gy2CN8ew8PD4VOGjo6OGJoQt7W1qZYNHhsbCz8gCIgQM1P0JGiLjaDTVQBIoaKNgpXSP3dI9geDRBuiBQXSmsek+38m5d4ubj773qknH7ovCcUCMBrxyjDyq+uUtd6QAlpRNDQ0pHkKEEgewTE0NNTW1iYWL1/mDQ0NdXd3p/+TMpvNTU1NV69e7e7ubmtrC7xcNJvNbW1tbW1tV69enTOBcjgco6OjgSFIQ0NDR0fH6OhohCX19fX19fUFHUAkn962tjb5MaH20N3dPTo6GvQZiU+qra2tu7s7kqriIZ9h+XCB9zY0NMhPJwUBn+psRDUXrKOjo6+vr7q6Wo5g5PYrbW1tStlNTU1hnoL8ooR/jhG2p5FztJhPV0dHh+pnNpDZbO7o6Ii8qQcgSdINV69e1boGROGGG25QbTly5Ijdbo9/zwMDA+Xl5UHvSuybJPApyB5o+uG6b0U9eBII48mH71M3EF39XWnpmqh39PZ+afC/ixv+/p8bNjc/GV91wCdOvHX08fqqoHel5ne03W4fHBwM3N7S0uJyuZL97TFI/RENrLOzUxm+0dfXp5emG4jZ2NhYQUGB/LWcd2hbD5Khv7+/p6dHmRwkhyAlJSURJpjykA1lKSWltafNZpNb88h7i79OeaVeuU5xeSl5ERl9DSVDmmBmCgBjOv7aq9dFGzfeJK3bfm3iSVTuXC/dmCUd/rGy4d9+1rn87ntuu2tV3GUCgJaUEfIlJSVEG4AxiAvoxKCkpEQOL5I9bkLuSEqKgQRiZgoAA7r0kd/9+EPXbSp7MMZoQ7Z0jbT6u+KGnar9A4DeyJ+ayl9zgQEA0DvSDZ2xWCyqLePj41oUAqS1V/5Hxx9nZ67dXn5fLBNSVJaukQpXK7cufDD5Wu/eePcJABqRF9SQv5a7FWpbDwAAcSLd0Bmr1araQroBBDrwkjCROPvz0ooE9QG1PyjdeJNy6+UXnkrMbgEgycTlCeSVFEpLS+UlXeTWfdqVBgBAYpBu6B5rpgAqr/XuVQ/cSJQbs6Q71iu3LnwweeKtownbOQAkTXNz8w1/dfPNN4tLY3Z3d0e4SgIAAOmMdENnApdH8Xq9WhQCpK/jr7967Ub25xMwJ0V05z+IwzeOv/ZqmMcCQDqQlz8I3G6z2VgnBQBgGKyZonvMTAFUTrwpjKcoSPSyJjdmSQWrpNOH5VtDg4eX331Pgg+BDHP23ZOh7hoYGEhBAYwBzARNTU3t7e3Kzerq6pKSkmQviAAAQCqRbuiM3W5vbW0Vt0xMTGhVDJCGLvx+8rppKYuTsGhrbpGSbpybHH+8virxhwAkSZKk8vJyrUuAEcjrO7a1tWldCLRns9muXr2qdRUAkBTMTNGZwK6iUqo+3AN04Q8f/Pt1t+NZBTaUvCTsEwAAAEAcSDd0Jmi6weQUQHHh95NJP0b2wqQfAgAAAEA0SDf0p6hI/bkx6QaguCCO3ci9XbtCAAAAAKQO6Yb+FBcXq7YwMwUI7uNLWlcAAAAAIBVIN/QncHIKi8ICivwvL7t24+KodoUAuhcYpgMAAKQt0g39sdvtqi1+v5/JKYDspmzTdbc/nk38MQhNkAEqKyurqlgPCAAA6Abphv4E/TCNySmAzHbrsutuT40k/hiTjJaCkVkslpaWlt7eXq0LAQAAiMI8rQtA1HJyciwWy8TEhLiRySmA7KbPmm75Qt6FD/66csqZo1LBqgQfQ0hMlpWu/JHnQIL3jwxz4q2jj9cHHyVx9erVFBcDAACgU4zd0KXA4RukG4Bi2V1CnDF6NMGTU2bOS6PHlFu3fTXR0QkAAACA6DF2Q5fsdvuBA9d9XDw4OKhVMUC6ubtq4+sH9n5y4+NL0tv/U1pxX8L2/sZL1x2r8t6E7RmAcU1PT7tcLj6KAACF1Wp1Op10sEYCkW7oUqjWG4ENR4EMdNtdq66bnPLb/dKd/yDdmJWAXV8clU4fVm4tK115yxfzErBbAEbndDq7urq0rgIA0sjg4KDX6yX2RQIxM0WXgqYYNBYFFPc++Ni1Gx9fkl7Zlpj9HnrquqN8+7FQDwQAEdEGAAQaGUlC93dkMNINvSorK1NtIfgEFHdXbcz/8tJrt6feUQUTsTj0lLgW7LLSlbfdRdMNAAAAIC0wM0WviouLVb02GLsBiLY8+S/ODeXXbp8+LGUvjL0Bx6GnxDkpn8nKdj75L/EVCCBDfb1y4+eZ1AYgU/3h95PX+qMBCUW6oVd2u33nzp3iFr/f7/V6acwDyGy3Lnug6Yc/bf/+tU3HX5Jmzkv2B6PrwfHxrHToKXGdFEmSNjc/SccNALG5u2ojI78AZKwTbx0l3UCSMDNFr2i9Acxp3bcav1658bpNpw9LP2uUTh2KdBenDkm7/kkVbfz9PzfcXbUx1HcAAAAASD3SDb3KyckpKipSbSTdAFScTz6nDjhm/iAd/rG065+kU4ekmfPBv23mvPT2fmnXP0mHfyx9fEm85+uVGzc3P5m0egEAAADEgpkpOlZcXKzqM0y6AQRyPvncTZ/N/refdV63Vc44JElaUCBlf15asPiT7RfPSBdHpZk/BN3VA00/XPetxqRWCwAAACAGjN3QscDJKXLrDS1qAdLa5uYnv7ez6zNZ2UHuuzgqjR6Tjr/0yb/RY0GjjVu+kPfknl6iDQAAACA9kW7oWNDWG6QbQFDL775nV9/b9z743eAZR2ifycq+98Hv7tx/hC6AQIYYHx/XugQAABA10g0ds1qtFotFtTHNJ6eECV9yPndLKitBBrrps6Z7H3xsV9/bDzT9MP/LS+d8fP6Xl2754XO7+t6+98HHbvqsKQUVAkgHdXV1drudjAMAAH2h74a+2e32rq4ucUuapxvT09Oh7jKTbiAlbvqsad23Gtd9q/HC7yfH3j1x9r2TY++evDTj/+TebJPt1mX5X15221dXkWgAGWtwcDA/P7+lpcXpdObk5GhdDgAAmBvphr4FphsTExPj4+NWq1WjigDduOWLebd8MW/53fdoXQiANNXa2up2u91ud11dnda1AACAOTAzRd+Ctt5I8+EbAADohd/vr6+vLy4u5ncrAABpjnRD3/TYegMAAH0ZGRkpLy+vqqqiGQcAAGmLdEP3AodvsGwKACADud3uMN2d4nfgwIHi4mKXy5XUowAAgNiQbuhecXGxasvIyAh/eAEAMo3f7w86YTOxh2htbS0uLvZ4PEk9EAAAiBbphu7RegMAkFGqqqpC3TUyMpKCDqATExP19fV2u53ftgAApA/SDd0rLi42mdTrVjI5BQBgVGHSDUmSurq6UjOwYnBwsLy8vK6ujvGSAACkA9INIwicnMKnSQAAo7JarS0tLWEe4HQ6U9b+s6ury2q1ulyu1BwOAACEQrphBIGTUwYHB7UoBACAVHC5XJWVlaHu9fv9qYwb5GYcVqu1t7c3ZQcFAAAqpBtGELT1BpNTAAAG5vF4ioqKQt3b1dWV4tVbJyYmvvGNb9jtdn7/AgCgiXlaF4AECJyZIkmS1+sNuh0AgHTg8XjiDCCWL1/+7rvvfvzxx0Hvrauri20JlXiqGhwcvOOOO7Zs2eJyuXJycmLeDwAAiBbphhHk5OQUFRWNjIyIG/nsCACQnqanp+12u+rXVsINDg5qNU9z586dHo/H5XI5nU5NCgAAIAORbhhEcXEx6QYAQBecTmeyow3N+f3+Rx55xO12ezye2IaQAAk09u7Js++evPDBv4sbb/nCl275Yt5td63SqioASCzSDYMoLi7u6uoSt9BYFACQnlS/sAxsYmKivLw8TANUIKlOvHX0td69x1979Y+zM2Ee9n99/e+Wf/2eu6s2pqwwAEgG0g2DCNpiY3x83Gq1prwWAABwzYEDB7QuARnn+Guv/rT9+xc+mIzkwb95/Ze/ef2XL7/w1L0PPkbGAUC/WDPFIIKOek1xu3gAABCorKxM6xKQQS78fvJ7dZU/2lIbYbRx7Rs/mNz5/Ye2rLePvXsySbUBQFKRbhiHxWJRbRkYGNCiEAAAIEmSZLFYfvGLX/DrGClz/LVXH15vPzl0LPjdCwqk3Nuv/Qvm7HunnBvKX+vdm8QqASA5mJliHFardWJiQtwyPT2tVTEAAGQyk8nkdDpdLpfWhSCDvNa7d+f3H1JvvfEmqWCVtHiVVBCse+jFUenUIen0IenjS+Lmnd9/6MRbR51PPpe0YgEg8Ug3jMNut6s6ibJsCgBAR4qKinJyciJ//Pnz5997771Q9xYUFOTm5sZQxsjISJwfD9TW1rpcLlpfIZWCRxvL75Pu/AfpxqyQ37agQLI/KNkflN7eLx1/Scw4Xj+wV5IkAg4AOkK6YWT03QAA6Ijb7Y588VSv13vHHXeEutdkMg0NDUWVlSgCPy2IXFlZmcvlYglYpNjYuyfV0caCAmnNY9KCgkh3ced6aeka6ZVt0tQ7yrbXD+y97a5V9BkFoBekG8Zht9tbW1vFLaqJKlB5rXevsvD7srtWpfl671SbPPqq9sRbR0++dVT++pYvfCnN/+ikWiTJ+Ph4+ATB6XTGFm3EzGKxuFyuurq6VB4UkCTp0kf+Hz1833WbFhRI1TvCDdkI6sYsqfon0qGnpNOHlW07v/9Q/q3LbLcuS0SlAJBcpBsGNz09neI/73Tktd6XlbZb9z4opfk1LdUmj76qPfnW0Zdf+LH89bLSlWl+BU61SJKqqiq/3x/qXovF4nQ6U1lPS0tL6vMUQPavzz913fIosUUbijWPSZIkBhw/bXv8Rx5WNQagA6yZYhxBP8Wi9QYAwGAGBgZGRkZC3WsymXp7e1MWNFRWVp49e9blchFtQBMXfj/5bz/rvHY7+/NxRRuy66e0nBw6xhIqAHSBdAMAAOiJx+MJc6/b7S4uLk5BGUVFRUeOHOnt7aV7KDT0ry88dd3tNY/FG23I1rVKN96k3HpZdRQASEukGwAAQE/C9MxuaWlJQecLk8m0Z88er9dL91Bo69JHfnllk0/k3i7lFiVm19kLpTvWK7cufDB54q9tiQAgbZFuGIrFYlFtiXNNOwAA9KKystLlciX7KFu2bBkfH6d7KNLB8dd+ed3tFbWJ3Pud/yAO32ByCoD0R7phKIGDY+m7AQDIEMmekFJWVnb27Fm3202LDaSJ46+/eu3GgoKEDdyQ3ZglFVxrs32SsRsA0h5rpgAAAIRjsVg8Hg/zUJBuTrwpJA4FSVjwa/EqZfGUCx9Mfvebaz/9tzcm/iiYy7pvNS6/+x6tqwB0gHQDAAAgOJPJ5HQ6UzDhBYjWpY/8f5yduXY7L6EDN2TXDwZ5753hxB8CETg5dOzv/7lhc/OTWhcCpDtmphjK4OCgaguN3AEAiE1tbe34+DjRBtLT2Lsnr7strOGaMDdmia03oKF/+1mn+hWHUfT397e3t1dUVNxwww1a16J7jN0wONINAACiVVZWlrKVZYHESMhCsIEWFEhT7yRlz4jSb15/1XbrMq2rQOINDw83NzdrXYVBMHYDAADgGo/HMzAwQLQBd+SOnQAAIABJREFUAED8xsbG5JEpN9xwQ2dnZ1KPRbphHAMDA4Eb6esOAEBUGPYIXPPxJa0rAKBvjY2N/f39gV8nA+mGcUxPTwdu5KMnAAAA47nps6brbl8cTcphkrRbABljbGxMvDk8nMT+xKQbxhE4dsNisWhRCAAAAJJL3YLhwpnEH4NoA0DcbDabeLOkpCR5x6KrqHEEphsM3AAAADCq/C8vPfveqU9uTI1IS9ck+ACTXvHWvQ9+N8H7RzCv9e698MGk1lUACdPR0aFMSOno6HA4HMk7FumGQUxPT4+MjKg22u12LWoBAABA0i27a9W1dGP0qPTxbIJXTjl9+NqxSlfe++Bjidw5Qjjx5lHSDRiJzWbr6+tLzbF0MzOFdYDD6+3tDdxIugEAAGBUy+++59qNjy9JZ44mcu9TI+LMlOuOBQBpSTdjN1gHODy3263aYrFYmJkCAABgVLfdteqWL+Rd+5z/+EvS4lUJG77xRpd46+6qjYnZLQAkjW7GbiCMgYEBpqUAAABkmutmi8z8QXrjpcTs9+390tQ7yq2vV25UL9ECaGFsbKy9vV0Z0a9SUFDQ3t4efkmO9vb2mpoa8bsaGxt7enoiOWhjY6PqiDfffPOcR1T09PQ0NzeL315TU9PZ2Rn504+heNVTiPm8RSvogWQRPuXYTrtuxm4gDKfTGeFGAAAAGMbdVRtffuGpa8M3fvs/pQUF8bYXvTgqHb8uJfkmHTegtf7+/oqKivCPGRsba25uHhoaCnpvZ2dnY2Nj0O2dnZ0lJSXd3d2q1T1kBQUFoY7o8/nk6QUNDQ0dHR1hHlZTUyO31RT19PREkk3EU3z8500rsZ12xm7ontvtDhy4UVZWxrQUAAAAw3ug6YfX3T7847hWcr04KvV8R/r4krLh3ge/e8sX82LfIZAIkY8sCHqR39jYGDQdEPdfUVExNjYWS3GS1NnZWVNTE/Qun89XWloaGG1ELp7i4zxvaS7wtJNu6JvX633kkUcCt7tcrpTXAgAAgFRbfvc9X6+8vinGzxqlU4di2VdAtJH/5aUslYJ009bW1tbWdvV6o6OjbW1t1dXVZrNZ9fjm5mZxNkRbW9uHH34of1dfX5+yQOnY2Fj4EMHhcCjfKGtra1Pu7enpCRph1NTUKLlDSUlJR0eH+O0lJSXhn2yiipeiP2/x6OvrUx0l5l1FddpJN3TM6/UGba5RVlZG0w0AAIAMsbn5h/lfXnrdpsM/ll7ZJn08G8Ve3nhJ+lmjGG18Jiv78Wf/R4JqBBKmqampqalJtdFmszU1NXV3d6u2y+0blMeMjo42NTUpV/IOh6Ovr6+hoUG+2d/fH2aQhcPhUEUAqiMGdpQQd+hwOIaGhpRjyd+u2pK84qUoz1v6iOq0k27oldfrraqq8vv9/z979x/b1J3n//7D3UpcNZDESKS9FCYhqVS0hMatww4tf8QFZ9BUmsadriOYaYvRTOPv0u2QmdFgq1RL2Fsqm2qnYXqXnWSpMLQ7IPLtjNORWtEEaqQbyixxmwyhX5AmxpkAKqkutgOpvuz3O+L+cTonJ8c/4tjHPj7286Fq5PPxOZ/zjgew/crnR+JTifunAAAAoFRVLK16w9+vDjjGz4l3fig+PTZPxnH3jrh0SrzzQ9VaG/cvqXzD38+cFBidnA4IIVItTuH1euXvzwudQuJwOOQBFInXKr94p1qYI82UkHwXb1ypXnbSDUMKBoNWq3ViYiLxqb1797LiBgAAQFlJHnDcnRHnj4lDdvHBP4lPj4lro+LaqLh755sHn70vPvgn8c4PxcdviumbyutqVqx6w99fv6axoD8DkAfysp0OhyPVNBCTyZQmoZiXfG00Go1Go8qn5N4cDkcWC1sUoHjjSvqys2eK8XR1de3bty/pUy0tLay4AQAAUIYqllYdfD/47949v38vYcPF8XNi/Jw4n1E/jc1P7nn7GFvAogSEQiH5e6/8ZTgpi8UiRQlZLCyqnDcRjUblQ+Xd511fI1FhijeupC970Y3dyHEf4Kz38pUvTLzK4/Ek3apncHBQPifD1WgXer5KMBisq6tLFW00NTUFAoEsugUAAEBpeMmzf/+RQM2KbGaU3L+kctfrb7/h7yfaQGlQftt3uVyJX/SU3/ik0xLHX8wr1aAMZT9ZpBuFKd64kr7sRTR2I8d9gHPcy1dKVZJeJc13StxGWBUXzVuh8g/oQtekDQQC3d3dZ8+eTXVCU1NTMBisrq5eULcAAAAoMevWbzz88WenAyc+ePfXV69cyuSSmhWrnnnBtdm+lVwDpSS7r/rK8Re5yHEkhb7FG1SxpBvSPsC5/AnIcS/feedBSdsIDw8Py39clJdkUrnyD2iG064ikYjf7/f7/UmX2JARbQAAAEBps33rZvvWqeuT5898eP70h+HLY1/fmVaecP+Syvo1jev+buO3Nz3NEhsoSfp+z89ioQ2lcg4pslYs6YZqH+COjg55bxufz9fX17egqRzSFriqDW/C4bDUT9I/KPX19TabzWazqVZ88fl8vb29Um3S7BV5f12TyWQymaTMYkFjN+b9gx4MBgOBQDAYHB0dnbfbtrY2v99PtAEAAACVmodWPfOC65kXXNLhzO14+PLYAyu+xWYoKAfKr10DAwPpV6/QnPJbZygUWujd9S3eoIpi3Y0c9wFOlMVevhaLZWBgwO12q6IH6e5yo2oFELldlW5Iq340NzcrG+dNN4LBoNlsXrRo0VNPPXXw4MF5o42qqqq33norEAgQbQAAAGBeFUur1q3fSLSBMmGxWJRrfOp49yx2M9G3eIMqinQjx32A881kMsnZimqlFrkq5cyUaDQq/fENhULKP4jpl8yNRCJ2uz2TwRqSlpaWkZGRzs7OBfwkAAAAAFA2HA6H9MDn8xV+xU357oODg1kkFPoWryHld/m8/iBFkW7kuA9wASjziHnTDeUaqMqUTj4n6dQYv98fj8czKaalpeWTTz6R9k/J5HwAAAAAKEPK31K3trYWeM9U5XwC5VIMGdK3eG3JX5yzGMaSOf3TjRz3AdZW0k1hm5ubU23aIucUyj9qyv/DkqYbuSQ4VVVVTqfTarVm3QMAAAAAlAOLxSJHDKFQqKGhwePxJH658/l8LpdL2itTQ9LaCNLjcDjc0NCQOAojzZgOfYvXlrxuyODgoMvlkl+EwcFBj8ejVfH6ryqa4z7AWunr61O+ykqqCSZKcsHRaDQcDtfX10ejUdXYDaldKNKNpD9mhgMx4vH4jh07urq6uru77XZ7JpcYxf/98g//5m/+ppB3/J9fz8iP//vhX33wbvJZUUWCavPHWNX+19278uP/8fkftj3RoGMx86LaTPzlL/+7MDcCAKAMeb3eaDQqL4aQ5ot04tKNmtw9FArJv/P2eDwej2dBl+tYvIbcbrf8U/T29qqWs5Tn4ORI/3SjGAbY9Pb2ulyuLC5U5hRSiiFHGx0dHdL/Z319fW63W16ww2QyJR274XQ6g8Hg0aNHM7nvxMTEs88+29LS4vf7S2Z+ivIbZuH9r/+6+7/+6+785xUHqs0fY1X7l7/8Zeb29PznFQeqBQAAuujp6bHZbKl+mS3L0zfTgYEBn8+3oFBDSd/itVJfX9/T05PqS7dWxes/M0X3hTai0ajyj5rD4Th58uS9uVLt2CJtCis9lv4vkdKN+vp6r9crPSW1yKM/0vy8fr//888/f+utt9ra2qqqquat/OzZs2azORAIZPiTAgAAAEAZcjgct27d6unp8Xq9qqdMJpPX6/V6vam218yd2+2+d++e1+tN3NjVYrFId79161aqy/UtXisdHR3Dw8OqMSYOh8Pr9Q4MDGhyC/3HbuS4D3Duent75RjM6/UmHdLjcDhUg2dkFotFGmgUDofD4bD02OFwmEwm6arQX0nnp/8BzWaz2WyWdkIZGRnx+/2BQGBiYiLV+fF4/Nlnn927d29XV1cmPywAAAAAGIvb7dZk5oX0S+sFdXXv3r30J9hstnnPkeT4U2RRvFavm1YsFouU5sx7ZnYvu/7phrSRr5QvDA4OFv7VV47wSTVGIw1luiFPS5EmDsmZiHIljqQbpiRlNpu7u7u7u7uDwWB3d3d/f3+qM/ft2xeJRPx+/0KLL7xIJJLqqU1tWx9g93UA5Wfq+uTp/hN6VwEAAGBs+qcbQpECSPsA675zyoIoN4WVBmhIiZQQwmaz1dfXh8Ph3t5e+YfKYnCK1Wq1Wq2RSKSzszNVxiEt2FH8AUeadGOzfeu69RsLWAsAFIWLF4ZINwAAAHKk/7obIud9gHOkHEyRaufXNOTYIhQKSZUrB4BIj6PRqLxMbtbrjNTV1QUCgU8++aS2tjbpCUePHu3u7s6ucwAAAAAAjKso0o0c9wHOkXL7GZfL5fF4Eu+VZn1aaWaNfCgttyEfqqa6qE7OgtVqHRkZ2b59e9Jnf/rTnwaDwVz6BwAAAACUJ5fLtShb2e1DqqGiSDeEEKr1Yz0ez7Jly5SvVBajKjIk7W8iH/p8vubmZtX/T+3t7Wl6UE6lkdYTlQ9NJpMy4NBkzdTq6mq/33/kyJGkzzqdzlgslvtdAAAAAAAwimJJN4QQAwMDmayemg9ut7unpyfry5XpRuKqqMqhHBpuf+t0OpMGHBMTE8xPAQAAAACUlSJKN0TO+wDnoqOjQ7p10k1bpPEdksSpJcoVQxPzC5vNJv842i6Y6nQ69+7dm9gubaGi4Y0AAAAAACWvp6fnXrZyGTGgiaLYM0Ulu115NdnLV+phoUNIHA5H+v14BwYGciorta6urmAwePbs2cT24t8/BQAAAAAATRRjuoEF8fv9ZrM5Ho8rG6X9U6qrq/WqCgAAFInw5bGZ2998TnhgxbdqHlqlbz3pGavaqeuTN2/8WXpcsbSqfk2jvvWkR7X5Y6xqZ27Hw5fHpMfFXy2QOdINw6urq+vs7Ny3b5+q3e/3d3Z26lISAAAoHoe9e8aGz0mPt+38xbadu/WtJz1jVXu6//jxQ29Kjxubn3zD369vPelRbf4Yq9rw5bE9O+zS4+KvFshcca27gex0dnZWVVWpGpmZAgAAAAAoE6QbpaC6utrpdKoaR0dHWVsUAAAAAFAOSDdKRGK6IYQIBoOFrgMAAAAAgIIj3SgRZrO5trZW1Ui6AQAAAAAoB6QbpcNqtapamJkCAAAAACgHpBulw2w2q1rOnj2rSyUAAAAAABQS6UbpSEw3hBCxWKzwlQAAAAAAUEikG6UjaboxMjJS+EoAAAAAACgk0o3SUV1drXcJAAAAAADogHQDAAAAAAAYG+lGSWlqalK1sCksAAAAAKDkkW6UFCanAAAAAADKEOkGAAAAAAAwtvv0LgBaStz/ldEcQCrhy2NjF4ZuXv/z1ctjyvbVaxrr16xbvaaxfk2jXrUBAAAAWBDSjZIyOjqqakm6TSxQzqauT/a/++s/nPlo6sZk0hPGhs9JD2pWrNps3/rMC66KpVUFLBAAAADAgjEzBUC5mLkd797zyo+3PP7793pTRRtKUzcmjx96c9sTDx8/dGDmdrwAFQIAAADIDukGgLJwOnDiR62Pn+k/kcW1xw+9+aPWx8+f/lDzqgAAAABogpkppWNkZCSxsa6uruCFAEWne88rKXONlY+K5Q+LxUu+Obx7R3z1J3Htj6qzvr4z/cau7d97vuMlz/58VgoAAAAgG6QbpSNxSVFBugEIsf8nL/7hzEfq1pWPir/dIh7eOJtrKN29I/40JD7/rfhqXNn8+/d6Z25Pd+5/O2/FAgAAAMgG6UbpiEQiepcAFJ3uPa+oo43lDcK6U6xsSnfZ4iVi7RaxdosYHxLBQ2L6pvyMNAaEgAMAAAAoKqy7UToS042WlhY9CgGKxb9796gnpDz2ffF8zzzRhlLDRvF8j/jb7yjbzvSf+ODdHo1qBAAAAKAB0o3SkbjuRnV1tS6VAMXg4oWh37/XO6fpO78Q1p0L7mjxErFltyrgOOx7LXx5LLcCAQAAAGiGdKN0JI7dMJvNehQCFIWDe16Zc9zyD2Ltluy7Sww4vHuy7w0AAACApkg3Ssfo6KiqhSVFUbZOB05M3ZicPW54Ujz+XK6dbtktVj4qH40NnzsdyGZ/WQAAAACaI90oEWwHCygdP3Rg9mBxhdiyW5t+t+wWiyvko9OB49p0CwAAACA3pBslImm6YbVaC14IoL/zpz+cM3DjseeSb/uahcoHxWOzY0DGhs+x+gYAAABQDEg3SkRiutHUlPGuEEBpOa/cAnZxhXj8+1r2Prc3hm8AAAAAxYB0o0QkphtMS0HZGrswNHvQsFGzgRuSxUtEw5PJ7wUAAABAJ/fpXQC0cfbsWVULG6agPE1dn5wzLeXhjdrfo2GjGD8nPbx65dIzjcu1vwUghBBi0aJFepcAAABgDIzdKAUsugHIbt7485zjlXmYolXzsPZ9AgAAAMgB6UYpSJpuMHYD5WlmOj7nWNtpKZLlDdr3CQAAACAHpBulIBgMqlqampqqq6v1qAXQ2dUrik1MVj6qXyEAAAAACod0oxQkphsM3AAAAAAAlA9WFTW8WCw2MTGhamTRDZStmhXfmj249kf9CgHKnd1u17uEInXY+1pFZWUh76gc1HY6cOJicW/2ZKxqp67PrmN99crYqzvadCxmXlSbPxpWO2cUqoKGfx1mpqeVtyvwa6u8O6At0g3DSxy4IRi7gTJW89CqOcd372i/9MZX4xp3CJSctrY23olSSfXVpTCmbszdWKq4GavamdvTYxfO6V1Fpqg2f/JUbZ7+OhjrtQXSY2aK4SWmG1VVVXymRNl6QDl2Q+QniZj6k/Z9AiVk165dfr9f7yqKC5v7AgCQb4zdMLzEdINpKShnNQ+tun9J5dd3/jro8U9D2m8Ke21Ufvh/rar7x3/u1rh/lJmrl8cO+15L+tQnn3xS4GJyx3tQUvfu3dO7BAAAShzphrHFYrHR0VFVIwM3UOY2bH76TP+Jbw6+OCWsO7Xs/e4d8cXH8lFzy3fWrd+oZf+AAklBSVr9yNqKpVV6VwGgSF29MjZzO8nKFDUrVtWsWJXYbjgzt+NXr1zSuwqUJtINY0u66AafhlHmNmz67my6cXdGXDol1m7RrPfPfqs82mzfplnPAMrDjz37SUUBpPKqs21sOMlCGJvtW7ft3F34ejR38cLQnh0sO428YN0NYxsZGUlsJN1Amduw+en7lyj2Izh/TNy9o03Xd++Iz9+Xj2pWrKpf06hNzwAAAAByQLphbIljN1paWvQoBCgubS+6Zg+mb4pPj2nT76kD4u6MfFQav0IBAAAASgDphrGdPXtW1cLADUAI8cwLrjlzUz//rbh0KtdOP3tfjM+OFF39yNrN9q259gkAAABAC6QbBsaiG0AqFUurfux+fU7Tx2/mFHBcOiXO/puy4cee/dn3BgAAAEBTpBsGRroBpLFh89Ob2uaOrfj4TfHZ+ylOTyt4SHz8prJh285fsCggAAAAUDxINwyMRTeA9Dr3v736kbVzms7+m+j7mZj+MtMuvhoX77nE53P2SdnUViKLlgMAAAAlg3TDwFh0A5jXG/5+dcBx7Y/inefFqQPiq/F0V44PiVMHxHsu1WmNzU++5Hk91UUAAAAAdHGf3gUgS0xLATJRsbTqDX9/955X/nDmozlPfPGx+OJjUfmAWN4glj8sKh8QVQ+K+Jdi+qb46k/i2qhybxTZpratnfvfLlDpAAAAADJGumFUIyMjiY1ms7nwlQBFrmJp1Z5fHTt+6MDxQ2+qn5u+KaZvKndCSeX+JZU/eHn3My+45j0TAAAAQOExM8WoEsduNDU1VVdX61ELYADbdu4+fOqzxuYns7h2U9vWX70fJNoAAAAAihZjN4wqMd1gWgqQXs1Dq97w91+8MHQ6cOL86Q+/vjOd/vz7l1Ru2Pz0D3burnloVWEqBAAAAJAd0g1DikQi8Xhc1Ui6AWRi3fqN69ZvFPvfPn/6w6tXxi7+55AQYmz4m8kp0uCOdX+3sVE6DQAAAIARkG4YUtIlRQ2x6EYkEtG7BOAbGzY/vWHz09t26l0HAAAAgJyx7oYhJS4pWltbW1dXp0ctC0O6AQAAAADQHOmGISWmG0xLAQAAAACULdINQzp79qyqxRDTUgAAAAAAyAfSDeNJHLghSDcAAAAAAGWMdMN4kqYbzEwBAAAAAJQt0g3jSUw3mpqadKkEAAAAAIBiwI6wxpOYbjAtBQAAAGmEL4/N3I5PXZ+cuvHniqVVq9c0CiHWrd+od10AoBnSDeMh3QAAAMC8Zm7HTwdOXLww9IczH6U6Z/Ujazfbt23Y9HTNQ6sKWRsAaI50w2BisVg8Hlc1km4AAABANnV98jeHDpzpPzHvmVevXDrse+2w77XG5ie3vbyb0RwAjIt1NwyGDVMAAACQxvFDB3685fFMog2lseFze3bYu/e8MnNb/Ys0ADAE0g2DiUQiiY3V1dUFLwQAAADFJXx5bNdz1uOH3kx30spHxeKKVE+e6T/xo9bHL14Y0r44AMgzZqYYTGK60dLSokchAAAAKCLhy2OvOtu+vjOtfmJ5g/jb74iah8XKubvsfTUuJkfE+JC49kdl89d3pvfssO96/e3N9q15LhkAtES6YTCJ6QYDNwAAAMpc8mhj5aPiie3qUEO2vEEsbxCPPyemvxSfHhNffKx88uBrrwghCDgAGAjphsEkphssugEAAFDOpq5PqqONxRViy27RkNkSoZUPii27xdot4tQBMX1Tbj742is1D61inVEARkG6YTCxWEzvEkqHtPG79PiBFd8q8o3QqDZ/jFXt1PXJmzf+LD2uWFpVv6ZR33rSo1oAKID9P3lhTrRR+YB45p/F8oaF9bKySTzfI/p+Lr4an+35lRffGfisYmmVRpUCQB6RbhjM6OioqsVqtepRSCk47N0zNnxOerxt5y+27dytbz3pUW3+GKva0/3H5eXiGpuffMPfr2896VEtAOTb8UMHrl65NHtc+YB4vkcsXpJNX4uXCMe/KAOOr+9Md+95Zc+vjmlRKQDkF3umAAAAAIY0czvef6xn9nhxhXjmn7OMNr7pYYlw/IuofEBu+MOZj9hCBYAhkG4AAAAAhvSbfz0wZ07KhhcXPCEl0eIlYsucYYzH//VArn0CQP6RbhhJ4pKiQoi6urpC1wEAAAC9zdyOnw6cmD1e+ah4/Dltul7ZJP72O/LR2PC5qeuT2vQMAHlDumEkpBsAAACQnD/90ZyBG1pFG5InXlQe9b/7ay07B4A8IN0AAAAAjGfOchiVD2S6/2uGKh8UDU/KR2MsvQGg6LFnCgAAKDt+vz8YDCYdFJlvh7172F8Tmrjyx9DsgbbRhtzn+Dd7il29cmnmdpw/ugCKGemG4cViserqar2rAADAMKxW69mzZ/W6+5zNOwGtrGrKd5/hy2Pr1uchQwEAjTAzxUisVmti48jISMELAQDAqLq6unSMNoB8yX2rlESVDyqPWFgUQJEj3QAAAGXE7/frXQKQB3OTCM2sfFR+OHXjz3m5BVDeBgcHfT5fa2vrokWL9K7F8JiZYnixWEzvEgAAMIyJiQm9SwAA4BuhUMjj8ehdRYlg7IbBNDWpJ1UyMwUAAAAAUOZINwwmcQFRXdZ7BwAAQBGZ/jIv3V77o/ywZsW38nILANAI6YbBmM1mVQtjNwAAAMrdV+Pa9zk3Mal5aJX2twAA7bDuhsEkphujo6NsCgsAQI62b99eV1eXp8737dsnP97UtvUBviVCCx+82zNze/qbg8lR0aD1dq2To8qj+jWNGvcPAJoi3TCYxHRDCBEMBu12e+GLAQCgZDidzqQ7r2tCmW5stm9dt17rb6EoSzevT57pP/HNwfiQsO7U+AbjQ/LD1Y+srVhapXH/AKApZqYYjNlsrqpSv7UEAgFdigEAAIBeNmz67uzB9E1x6ZSWvU9/KcbPyUeNRHIAih7phvEk/mYpEAiwLywAAEBZ2bD56fuXVM4enz+mZe+fzumt7YX/pmXnAJAHpBvGkzgJJR6PM3wDAACg3LS96Jo9mL4pPntfm36vjYovPpaPGpufZElRAMWPdMN47HZ74uSUrq4uPWoBAACAbp55wTVn+MbZf9Ng85S7d8QH/6Rs2Pby7lz7BLQQDod9Pp/P52ttbV2UoKGhwefzhUKhND34fL729nblVS6Xq6+vL5Obulwu1R2XLVs27x1lfX19Ho9HeXl7e3tvb2/mP34Wxat+hKxfN6NgVVHjqa6uttvtR48eVTZOTEz4/X6n06lTUQAAACi0iqVVP3h592Hfa7NNfT8Tjl+K5Q1Z9nj3juj7ubg7IzdsamMdXOhvcHCwtbU1/TnhcNjj8QwPDyd9tre31+VyJW3v7e21WCwnT56sr69PPKGhIeXfpmg06vF4hBAdHR09PT1pTmtvbx8cHFS19/X1ZZJN5FJ87q+bsTB2w5A6OzuTNrL6BgAAQFl55gVXY/OTs8d3Z0Tfz7IcwSFFG4pr719S+ZLn9ZxrBHKV+ciCpF/yXS5X0nRA2X9ra2s4HM6mOCF6e3vb29uTPhWNRpubmxOjjczlUnyOr5vhkG4YktlsbmlpUTXG43HGbgAAAJSbPW8fmzM/RQo4FroGx/iQeOeHqljkDX8/G8Gi2Hi9Xq/Xe2+u8fFxr9frcDhMJpPqfI/Ho5wA4vV6b926JV01MDBgs9mk9nA4nD5EsNls8oUSr9crP9vX15c0wmhvb5dzB4vF0tPTo7zcYrGk/2G1Kl4s/HUzItINo0q60EZ/f7/f7y90KQAAANBPxdKqN/z96oDj7L+J91zi2uj81381Lvp+Jj7Yq5yQIoTY9frb9WsatS4WyJXb7Xa73arG+vp6t9t98uRJVbu05IR8zvj4uNvtlr/J22y2gYGBjo4O6XBwcDDNIAubzaaKAFR3TFxEQ9mhzWYbHh6W7yVdrmrJX/Figa+bQZFuGJXVat2+fXti+44dO9iB/dB1AAAgAElEQVQ/BQAAoKzUr2lUBxxCii1+Lt75oQgeEtdGxd07c569Nio+e1+85xLvucS1PyqfuX9J5a7X395s35r/woH8ktMBIUSqxSm8Xq8cGSx0ConD4ZAHUCReq8w7Ui3MkWZKSL6LLz2kGwbW3d2duHmKEMLpdAaDwYKXAwAAAN3Ur2l8Z+Cz1Y+sVT8xfVN8/lvR93NxyC7ess3+1/fzpHus1KxY9Ya/n2gDpUFettPhcKSaBmIymdIkFPOSr41Go9FoVPmU3JvD4chiYYsCFF9iSDcMrLq6Ouk8lHg8/tRTTzFFBQAAoKxULK06+H5w285fqAdxZOx7z3ccfP8TJqSgNIRCITlukCOApOTsIIuFRZXTVZTphvLu866vkagwxZcY0g1js9vte/fuTfrUjh07km6tAgAAgBK2befuX70f/N7zHQvKODa1bT186rOXPPtZRhQlQ/lt3+VyLUpN2thVJBt/Ma9UgzKU/WSRbhSm+BJDumF4XV1dSRfgEEIcPHjQbDaPjIwUuCQAAADoqOahVS959r8z8Nmu19/+9qbvpok5vr3puz92v3780z917n+75qFVhSwSyLfsvuprFRDkOJJC3+IN6j69C4AGpEkoR48eTXxqdHT0scce27VrV1dXV3V1daErAwAAgE4qllZttm+VVtCYuR0PXx5TPvvAim8RZ6C06bvLaRYLbSiVxhatBcbYjRLh9/tTjeAQQhw8eLCurq6rqysWixWyKgAAABSDiqVV69ZvVP5HtIGSp8wXBgYG7mUmx1RCpownQqGQsYo3KNKN0pE+4IjH4/v27TOZTE6nk7kqAAAAAEqbxWKRI4Ys8gUN757Fbib6Fm9QpBslxe/3HzlyJOk2sbKjR48+9thjdXV1nZ2dxBwAAAAASpXD4ZAe+Hy+wq9JId99cHAwi4RC3+KNiHSj1EhDM1paWtKfNjExcfDgQSnmcDqdBSkNAAAAAAqno6NDehCNRltbWwu8Z6rb7ZYft7e3L/Tu+hZvRKwqWoLq6uqCwWB3d3dXV1c8Hk9/8sTERJGM4DgdODF2YaiQd5y6MSk/vnhhSBw6UMi7LxTV5o+xqr2o+GsydWPyONVqR69qp65Pzn8SAABYOIvF4na7fT6fECIUCjU0NLjdbovFIg+LkPh8vnA4XF9fr8wjcid1KN09HA43NDR4vd6Ojo4Ml+TQt3gjIt0oWZ2dnU6ns7u7u7u7O33GYbfbC1ZVGmf6T+h497EL58YunNOxgAWh2vwxVrVTNyaPH3pT7yoyRbUAAKDwvF5vNBrt7e2VDqWwIKl8pANerzcUCsnrbng8Ho/Hs6DLdSzecJiZUsqqq6u7uroikcjevXvTLMZhtVoLWFTR+T/vr9C7hAWg2vyh2vyhWgAAoKOenp6TJ0/Ou8dqnqZ+DAwMeL3erC/Xt3hjId0ofXLGceTIkaampsQTyjzd+J9fz+hdwgJQbf5Qbf5QLQAA0JfD4bh161ZPT09i0GAymbxer9frPXnyZJ7u7na779275/V6bTab6imLxSLd/datW6ku17d4A2FmSrmorq52Op1OpzMSiQQCAb/fPzo6KoSYd/3Rwqitra2rq9O7CgDQQSwWk/5BBgAASbndbk1mXkjrdC6oq3v37qU/wWazzXuOJMefIovitXrdjIJ0o+xIe8F2dnZGIpFgMFgkmYLT6ezq6tK7CgDQQTAYfOqpp/SuAgAAwNhIN8oXe8ECAAAAAEoD624AAAAAAABjI90AAAAAAADGRroBAAAAAACMjXQDAAAAAAAYG+kGCioWi+ldAgAAAACg1JBuoKBGR0eTtlut1sIWAgAAAAAoHaQbAAAApexVZ9szjcul/44fOqB3OfMwVrXHDx2Qq33V2aZ3OfOg2vwxVrUXLwwZqFogc6QbAAAAAADA2Eg3AAAAAACAsZFuAAAAAAAAYyPdAAAAAAAAxka6AQAAAAAAjI10AwAAAAAAGBvpBgAAAAAAMDbSDQAAAAAAYGykGwAAAAAAwNhINwAAAAAAgLGRbgAAAAAAAGMj3QAAAAAAAMZGugEAAAAAAIyNdAMAAAAAABgb6QYAAAAAADA20g0AAAAAAGBspBsAAAAAAMDYSDcAAAAAAICxkW4AAAAAAABjI90AAAAAAADGRroBAAAAAACMjXQDAAAAAAAYG+kGAAAAAAAwNtINAAAAAABgbKQbAAAAAADA2Eg3AAAAAACAsZFuAAAAAAAAYyPdAAAAAAAAxka6AQAAAAAAjI10AwAAAAAAGBvpRlkLBALBYFDvKgAAAAAAyAnpRtmJxWJ+v99uty9atOjZZ5/t7u7WuyIAAAAAAHJyn94FoHACgYDf7+/v71c2MnYDAAAAAGB0pBulLxaLBQKBrq6uiYmJxGfj8XgwGLRarQWvCwCAcnTY+1pFZWUh73j1ypj8+HTgxMULQ4W8+0IZq9qp65Py46tXxl7d0aZjMfOi2vzRsFrlXwElDf86zExPK29X4NdWeXdAW6QbJa67u7urqysej6c5h3QDAICCSfXVpTCmbkxO3Zic/7ziYKxqZ25Pj104p3cVmaLa/MlTtXn662Cs1xZIj3SjZAUCgc7OzqTjNVSYnAIAAAAAMDTSjRIUi8WcTqdqfY00qqur81oPAAAAAAB5RbpRaoLBoN1uTz8VRQhRVVVl/6vCFJbeyMiI3iUAgD74B7DcrH5kbcXSKr2rAFCkrl4Zm7mdZGWKmhWralasKnw9mpu5Hb965ZLeVaA0kW6UlO7u7p/+9Kfpz2lpaXE6nU6nsyAVZWresgEAKA0/9uxft36j3lUAKFKvOtvGhpMshLHZvnXbzt2Fr0dzFy8M7dlRFL9eRekh3SgdTqfz6NGjaU7Yvn17V1dXXV1doSoCAAAAAKAQSDdKRPpoo62trbu7m1wDAAAAAFCSSDdKQZpoo7a21u/3s+ErAAAAAKCEkW4YXnd3d6poo62tze/3G2VLlP1HAsxDBlCGmIEMAACQu/9D7wKQk5GRkVTrcb711luBQMAo0QYAAAAAAFlj7IaBxWKxVPu5HjlypNh2RQEAAAAAIE8Yu2FgXV1dExMTie1EGwAAAACAskK6YVSRSOTgwYOJ7Xv37iXaAAAAAACUFdINo+rq6kpsbGlpSdoOAAAAAEAJI90wpEgkkrhPSlVVld/v16McAAAAAAD0RLphSEkHaHR2dtbV1RW6FAAAAAAA9Ea6YUiBQEDVUltby5wUAAAAAEB5It0wnkAgEI/HVY2dnZ26FAMAAAAAgO5IN4wnceCGEIJ9UgAAAAAAZYt0w3gS0422trbq6mpdigEAAAAAQHekGwYzMjKSOC3FbrfrUgwAAAAAAMWAdMNgRkZGEhtJNwAAAAAA5Yx0w2AikYiqpba2lmkpAAAAAIByRrphMMFgUNViNpv1KAQAAAAAgGJxn94FYGFisZiqxUDpRmLxAAAAKIyZ2/Hw5THpcf2axoqlVfrWAwDaIt0wmNHRUVWLgdKNpIuGALq7eGFIebhu/Ua9KgEAQFvhy2OnA8evXh4bGz6X+OzqR9Y2rt+4bv3GDZufLnxtAKAt0g3DY9ENYKFmbsfPn/7o4oWhsQtDUzcmE0+oWbGqcf3GDZu+y6c9AIBBnQ6cOH7oQNK3OdnVK5euXrn0+/d6719S2fai65kXXAzoAGBcpBsAysjU9cnfHDpw/vSHX9+ZTnfajckz/SfO9J/g0x4AwHDOn/7wsO+19LmGytd3po8ferP/WM8PXt79zAuu/NUGAPnDqqJGkrikqBCirq6u0HUAxnT80IGfPGc9038ifbShJH3a+1Hr4x+825PX2gAAyN3M7Xj3nlfe2LV9QdGG7Os704d9r73qbJu6ns3lAKAvxm4YHukGMK/w5bGDe/7x6pVL2V0ufdo7f/rDPW8fYxAHAKA4zdyOv+psS/5m1/CkWNkkah4WyxvE4iVCCHFtVMS/FNdGxfiQuDujPHds+NxPnrO+4e+vX9NYkMIBQBukGwBKXPjy2KvOtiTjNSofEA0bxaomsbxBVD74TeP0l+KrcTE5KsaHxPRN5eljw+d+1Po4n/YAAEUoebSxuEK07BQPb/wm0VBa2SRWNom1W4QQ4tIpcf6Y8l3v6zvTrzrbeMsDYCykGwBKWfJoY+Wj4ontYmVTkgsqHxSVD4qGjcK6k097AABDSB5tPPZ98cSLSXKNRGu3iLVbxGfvi/PH5HEcvOUBMBzW3TCSpJNQIpFIoesADCJJtLG4QrT8g3D8Mnm0obJ2i/jRf4iWf1C2SZ/2Zm7HtS4WAIAsde95ZU60sbhCPLNPWHdmFG3IHn9OOH4pFlfIDV/fmT645x95ywNgFKQbRkK6AWRu5nb84J5/nBNtLG8Qjl+Kx59bWEePPyee71F92tv/yosalQkAQE7On/7wD2c+mj1eXCEcvxQNG7Ppa3mD+NF/iMoH5IarVy6xrjYAoyDdAFCafvOvB+b8Imt5g3D8i1jekE1fUiyiCDjGhs8dP3Qg5xoBAMiJtEnKnKYtu7N8s5MsXiKe+WflW97xQ2+yhQoAQyDdAFCCpq5P/v693tnjxRViy+6FDdBVkQIOhf5jPQzWBQDo64N3e+aMUnzs+1mO2lBa3iC27FY2/IZAH4ARkG4YTFOTerGAkZERXSoBipn6c1iOv8iSLG9QrsHx9Z1pBusCpeTLL7/UuwRgwU4HTsweVD4gntBo4mTDRrHyUfnoTP8Jhm8AKH6kGwZTXV2taonFYrpUAhStqeuTZ/oVn/ZWPqrBL7Ikjz+nTEkYvgEYSDAYdDqdSVewkmzbtm3RokV2u93v9/PeCkM4f/rDqRuK0GFDZjukZOiJ7XPudeZDzXoGgPwg3TCYxHSDsRuAivoT2NzPZ7lS/Frs6zvT509/lOZcAMVgZGTEarU+9dRTR48enZiYSH9yf3//jh076urquru7C1MekLWLF4ZmDxZXiLVbtOx9ZZMy0D9/mnQDQLEj3TAYs9msauH3S4DKnE9gyxsy2vw1cw0blYvJz/lkCaD4+P3+xx577OzZswu6Kh6P//SnP3U6nfkpCtDGmPI9SKtRikp/+53Zew2f075/ANDUfXoXgIXRZexGV1eXJv2k37z2dODEGF8UoYU5n8AUn8w007BRfP7bb+7FH1qgiAWDwR07dmR9+dGjR+vq6rR6EwQ0N2drMG2jfMmqOb9Uu3hhaN36PGQoAKAR0g2DSRy7EY/HY7FYYuqhoX379uWvc9mchRIAraxS/5XRwMOz6cbUjcmZ2/GKpVXa3wVAbmKxWO6DL/bt22e32xPffAHdhS+PzTmueVj7e8xdkHtmmqWmABQ10g2DSfoBS5pRXPBaACPIfauU+foMXx7jd1lAMQgGg8pxFiMjI/OuspEJu92u7RQVxipCEzdVm5jk4/1O6varcenh1StjGzY/nZe7AGn5fD4hhMfj8Xq9brdb73KKy+DgYCgUGhwcHBwcvHfvnt7l6Ix0w2CSjtEg3QCSUyyQoSUNV6QHoJ2zZ88udH2NTExMTGg7hpGxijCSxRV6VwAIj8ejdwnFKxQK8frIWFXUeFpaWlQtbJsCJJendAMAAABAkSHdMJ7EySnpV+vMulvA8KZv6l0BAMN4+eWX9S4ByMHdO3np9q/TUoQQNSu+lZdbAIBGSDeMp66uTtWiyUDc6urqxFEhgLHlKd3I0ydIAPnX1JRyX4m///u/37t3byGLAbSkiCE0c/eOuDsjH9U8tEr7WwCAdkg3jCfVwqK59+z3+2tra3PvBygi+fi0N7fPB/hdFmAcfr8/zbNdXV1p4g+gqP0pD0vVXhtVHtWvadT+FgCgHVYVNZ6kC4gGg8Hcp5bU1dWNjIz4/f5AIJBjV0nFYrHR0dFUz65+ZC3bakITY8PnZg+m/qT9MvKTs3+M719Sye+ygAJzOp3ZDVrcu3fvvO+VgUDAbDbH4+x8CaMZHxLWnRr3qUhMalas4nMagCJHumFITU1NqphAq4VFq6urOzs7Ozs7NelNJRgMPvXUU6me/bFnP9tqQhO7nrNevXLpm4PxIbF2i8Y3GJ/9tLfu7/hDCxSa0+kMBoNHjx5d0FVNTU2ZvLvV1dV1d3fv2LEj2+oAnUzfFNdGxUrtBh/dvSO++Fg++vam72rWMwDkB+mGIZnNZlW6EQwGdaoFKDobNj+tSDfOiekvReWDmvV+bVQ5M2XDpqc16xlAxvx+v9VqDQQCsVgsk/OdTqfT6cywc6fTaTabu7u7NVm0W6IcbMJYRWjlL3/53//j8/+cPf70qHD8UrPeP/ut8mizfZtmPQNAfpBuGJLValX9zmpiYiIWi1VXV+tVElA8NrdtO37ozdnjT4+JLbs16/3TOX/1Nmzmd1mAPhYUWCyU2WxOv0LHQi1atEh+zFhFaKh7zytn+k98c3Dtj2J8SDRo8adr+ktx/ph8tPqRtSy6AaD4saqoISWdNszwDUBS89CqxuYnZ4+/+Fi1Llr2xofEtT/KR5vatvILWACAjn6wc258f+qANht7fTBn/6BtO7X7JQGQm97eXpfLtUjB4/H09fVlcm04HPb5fA0NDfK1zc3NPp8vGo2muUQ+eXBwMOk5Pp9PPifVTX0+n6rsRYsWLVu2zOfzhUKhTIrv6+vzeDzKy9vb23t7ezO81ufzLVu2TFVAa2urVFsmnRgCYzcMyWw2V1VVqdY8CwaDdrtdr5KAorLt5d17dij+Opw6IJ7vEYuX5NTp9Jfi1AFlg/ozJQAAhVXz0KrvPd/x+/f++g3n7ozo+7lw/EtOb3mnDijnYDY2P7lhM9MwURQ8Hk9io/Tl3GaznTx50mQypbrW5/MlXh4KhUKhkMfj8Xq9brdb22olDQ0pl7ePRqNSSR0dHT09PWlOa29vT8xW+vr65o11wuFwe3t7qgBlcHBQ6tZms1kslvRdGQJjN4wqcfiGVguLAiVg3fqNc9Y/m74p+n6e06+z7t4RH+wVd2fkhu8938FuKQAA3f3g5d01KxTvR1+N5/SWd+qAcjHR+5dUdu7/f3IrECiEwcHB5ubmVKMwWltbkyYjMo/H09ramp/S5tfb29ve3p70qWg02tzcnGrYSHrRaLS1tXXesSEmk6k0og1BumFcifvCZrc9HlCqOve/ff+SytnjXD7t3b0j+n6u/EVWzYpVP3iZgRsAAP1VLK169VfH1G9577kWPCtz+kvxnksZbQghXvLsJ8pHUbFYLD09Pff+qqenR/5mHg6HXS5X4iUej0dOB+rr65WXe73e+vp66anBwcH0CUiObDbbrVu37il4vV752b6+vqQRRnt7ezgclh6rfnav15s+lejt7ZWv7ejoGBgYuDeX1+udtxNjId0wqsR0Q7D0BqBQsbRqz9vH5jRl92nv2qh454fKaOP+JZWv/uoYK24AAIpE/ZrGlzz75zRJgxZPHRDTX85//d074tNj4j2X8s1OCLFt5y8227dqWimQk46OjuHh4Y6ODlWLzWaTDhMzgsHBQXldCYvForrc7XYPDw/LX+99Pp8cB2jOZrOpJs643e6TJ0/Kh4mLaMgzR6TLkxavbFGR5604HI6enh75VVL24Ha7BwYGFv7TFCnSDaMi3QDmtW79xl2vvz2naUGf9qa/FB/8k+j7uXJCihCic//bLB0PACgqm+1b1W95QogvPhbvPC9OHRDjQ8lHL44PiVMHxDs/FOePqd7stu38BYuJotjI4yxUlItWqDIC5coUSRfmMJlMyoihwEtsOhwOOXRIHLuh/FlSLcyR6jURQsjzdNIsR1JiWFXUwFpaWlSzUUg3ABXpl04HX3tlTusXH4svPhYNT4qGjWJVk6h8cM6z01+KyVHxxSnl9iiS+5dUvuTZz+JqAIAitNm+dfWaxledbV/fmZ7zhPSuJ4SofEBUPvBN490Z1UgNmfRmx6gNGEh9fb3D4ZCCDFVGoBy/kCoIUF7e19eXZoHPfLDZbFLN0Wg0Go0qkwj5Z0lTfBoWi0UaitLb22symZQTYUoVYzcMjKU3gExstm/dfyQwZ0KyZPyc+PhN8c7z4i2b6PuZ6PuZeM8l3rKJd54XH7+ZGG3UrFj1hr+fT3sAgKJVv6bxnYHP5qyrrTR9U1z74zf/pYg2Gpuf5M0ORiTPLolGo/I6mqFQSB6/kH51iaSXF4YyzlCuipp58akod4GRtq11uVwZ7p5rUKQbBpa4bYpg+AaQzLr1G9N92hMi/Uc9IcT3nu84+P4nTEgBABS5iqVVe351bP+RQGPzkwu6sGbFql2vv/2Gv583OxiRcmiDHAoow4L0AUHSywsj1aCMzItPxWKxDAwMKNMTaXOWEo45SDcMjKU3gMxl/Wnv25u+u/9I4CXPfpYRBQAYxbr1G9/w93f/90++93zHnP1iE9y/pHJT29ZXDx49/PFnDNmAcSVdWiLzJUKLcGUKTdY3tdls4+PjiSuPSjFHQ0NDiWUcrLthYNXV1U1NTaOjczaAGBkZ0aseoPitW79xnb9/6vpk/7u/HrswdPXKpVRnrn5k7Wb7tg2bnmYnPACAQdWvaaz37H/Js3/q+uTNG38euzCkfHb1I401D32LkRooDUkHXGS+VkUm4zWKZEzHQplMpp6enp6eHp/PFwqFlHFGOBxub2/v6Ogo8FIj+UO6YWxWq1WVbjB2A5hXzUOrpJ3zZm7Hw5fHpq5PTt34s/TU6kcaKyqr1q3fqGuBAABoqeahVTUPreLdDSVMOdJBHoihHJERCoUSt0RNf7lKgdONzIvPkLwMh8/nU+41W0prjjIzxdgSJ6fE43GGbwAZqlhatW79xs32rdt27pb+27D5aT78AQAAGIv8Xd1kMsmrVFgsFjkjSL9WqPys8nIxN2LQZKpI5pTFJ24Wmwu32z0wMKBcksPn8xU4u8kT0g1jY+kNAAAAAOUsFAopN09VPiUf9vX1pYonwuGwcuNY5VMmk0meIaJtxJAJuZjBwUHNd3Kx2WzKTVUKvFNMnpBuGJu09IaqkXQDAAAAQDkIhULt7e3yofIbu+qwvb09cYRCNBpNc7kQQp4Solq0ogBUxS908IjL5fL5fBmeXITrqmaBdMPwEodvkG4AAAAAKDGq0ROhUMjj8TQ3N8tf+91ut2oxzvr6ejkjCIVCzc3Nvb298rM+n6+5uVketpB4uZg7mqO9vd3j8agikvyN6VAWHw6HGxoaEqeQpBlzIb0+ixYt8vl8qlxGesrj8UiHqvk4xsWqooZntVoPHjyobInH45FIpK6uTqeKAAAAAEBjg4ODixYtSvVsR0dH0qUxvV6vPHUlHA67XC6Xy5V4ms1mS3q5NINDHgTh8/kyHxCRO2XxQghlJJFeNBqVg495L0kcsWJQjN0wPLPZnNjI8A0AAAAAZULa9DTVswMDA+n3BPF6vQMDA2me1fH7/7zFp5LhcIyenp6SSTcYu2F4dXV1tbW1ExMTyka2TQEAAABQAm7duiVNJ+nr61NNxHA4HBaLJZMv52632+Fw9PX19fb2yjNZLBaLw+Ho6OiYd9UJr9frcDgGBwcT54bYbDZpbQ7ViqQacrvd0vgR5U6uEulHEEJ0dHQo200m0/DwsDTuI+mKIVJiUjK5hoR0oxRYrdajR48qWxi7AQAAAKAEmEwm6Ut4jl/FpWUssu7EYrFkmKQo3bt3L/0JNptt3nMkWRQv1bygSwyNmSmlIHFyyujoqC6VAAAAAABQeKQbpSBx2xTB8A0AAAAAQNkg3SgFSRcWZekNAAAAAECZIN0oES0tLaoW0g0AAAAAQJkg3SgRicM3SDcAAAAAAGWCdKNEsLAoAAAAAKBskW6UCJbeAAAAAACULdKNEpE03YhEIgUvBAAAAACAQiPdKB1NTU2qFsZuAACAV51tzzQul/47fuiA3uXMw1jVHj90QK72VWeb3uXMg2rzx1jVXrwwZKBqgcyRbpSOuro6VQvpBgAAAACgHJBulI7EySmxWEyXSgAAAAAAKCTSjdLB2A0AAAAAQHm6T+8CoJnEdCMej+tRiGH8u3fP1ctj0uPN9m2b7Vv1rSc9qs0fY1V7OnDidOC49Hj1msaXPPv1rSc9qgUAAEBhkG6Ujurq6sTGSCSSmHpAcvXy2NjwOenxur/bqG8x86La/DFWtVM3/ixXW/yoFgAAAIXBzJTSUfybwgaDQb1LAAAAAACUININAAAAAABgbKQbAAAAAADA2Eg3SkpTU5OqpahmpgAAAAAAkA+kGyUlcWFR0g0AAAAAQMkj3QAAAAAAAMZGulFSYrGY3iUAAAAAAFBopBslZXR0VNWSdJtYAAAAAABKCelGiUtciQMAAAAAgBJDulE6mJYCAAAAAChPpBulY2RkJLGxrq6u4IUAAAAAAFBQpBulI+nmr6QbAAAAAICSR7pROoLBoKqlqalJj0IAAAAAACgo0o3SkZhusGEKAAAAAKAcFEu64fP5fD7fokWLfD6f3rUYUiQSmZiYUDVarVY9agEAAAAAoKDu07uAb3g8Hr1LMLbu7u7ERtINAAAAAEA5KJaxG8iR3+9XtTQ1NbGkKAAAAACgHJBulILu7u54PK5qdDqdetQCAAAAAEChkW4YXiwW6+rqSmy32+0FrwUAAAAAAB2Qbhie0+lMHLixfft2pqUAAAAAAMoE6Yax+f3+/v7+xPakozkAAAAAAChJpBsG5vf7d+zYkdjOwA0AAAAAQFkh3TCqVNFGVVVV0t1hAQAAAAAoVaQbhtTV1ZU02hBC+P3+6urqAtcDAAAAAICOtE83+vr6fD7fsmXLFs3V2trq8/l8Pl/6ywcHB30+n/LCZcuW+Xy+UCiU/sJwOCz1vyiBx+Pp6+tLc200GpWubW5uVl3b3t4+b81KPp+vvb1d2YPL5Up/9wUZGRkxm8379u1L+uyuXbvYKgUAAAAAUG7u07CvcDjc3t6eKoYYHBwcHBwUQthsNovFkqoT+TRZNBr1eDxCCLfb7fV6U13Y187i3vsAACAASURBVNcnnZZIiicsFsvJkyfr6+sTT1i2bFmabqWee3p6Ojo6Up0mhOjt7XW5XEnbe3t709w9Q7FYrLOz8+jRo6lO2L59O3NSAAAAAABlSLOxG9FotLW1dd4RFiaTKU20kZ7P50uVXwgh5g0OQqFQa2trNBrN7u4ulytpeJHJs/Ldw+FwFreORCJOp9NkMqWPNvx+fxadAwAAAABgdJqlG729vfJX946OjoGBgXtzeb1er9c7b7Rhs9l6enpUF8rP+nw+1cgOWX19vc1m83q94+Pjqsvl4EOavZL+7sprx8fHlXfv7e1NGq94PJ7e3l750Ov13rp1S+phYGDAZrPJd0+fgKhEIpHu7m6z2bx69eo0uYYg2gAAAAAAlDfNZqbIS0s4HI6enp7EE9xut/y/adhsNtUEELfbbbFYWltb5RvJeYGSxWIZGBhIet+Ojo7m5mYpfOnt7U0zvUXVc319vdvtttls7e3t0uU+n6+jo0M5TkSZmNTX1w8MDCiftdlsNpvN5XJJ8Yc07yZp/ZJYLBb8q9HR0VSnKR05csTpdGZyJgAA0N3Vy2MFvuPM7bj8+Ob1yYsXhgpcwIIYq9qb1yflxzO341SrobKtVvlXQHULrV4E5b9ChX9tC/9vIMqHZumGPOPDZDJp1adMWqpDmvYy7+SXRCaTqaOjQxp2EY1Go9Hogoq0WCw9PT1yvOLz+ZTxjXIwSKqVNbxeb19fn/QSpUk3urq6Ui0XmlRTU5Pf7zebzZlfAgAA9HXY95qOdz/Tf+JM/wkdC1gQY1V79cqlPTsMs7g71eZPnqrN018HY722QHqazUyRp5ykmr6RIzkRyCLdEIryhCKIWdDd5QJUG6AoB62kmndjMpnky1PNrAkGg5lHG1VVVW+99Za0f0qGlwAAAAAAUKo0SzeUU06kbVm13QlVNRkk1WlJN4Vtbm7OvRI5nohGo3LCEgqF5KwkzXwToYhXUhUfDAYzKaOqqmrv3r2RSKSzszOT8wEAgO7a2tr0LgEAik5tba3eJaCkaDl2Y2BgQDnjo7e3t729XauYY965JH19fcuWLfN4PIkjR0KhkHLVz+wo4xU50VBGFS6Xa1FqclXS1Jisy4jH48FgMBKJZN0DAAAosK6urqamJr2rAIAiUltb293drXcVKC33NHXr1i3VmqCy+vr6kydPprpQPs3r9SY9QbliqGpXlHv37iVdxzSVxMvnvbuqAHlHmAXdN00B9+7d++STTxbUyfbt26PRaKpqi9PevXuzeLkAoGzp/c92vqT6eT/55JOSvzsApNfS0pL036i9e/fqXRpQ7DQbuyExmUzSfq5er9fhcCifCofD7e3tC9oSNUPRaFQ5XsPhcCTGKKkylxxpuISq1Wr93e9+l/norKNHj9bV1QUCAa0KAAAAAADAoDRON2Rut1uKGLxer3JBinysOdrb2yvP9fB6vSdPnlQFK0KIxJaFUq5mKocayukq8oCOeSXdV0UIYbfbI5HI1atXjxw5sn379qqqqvQlxePxZ599lu1gAQAAAABlLl/phsztdg8MDCiX5PD5fLksPJFI2VuexmgIRbphMpnkJUItFov8c2W3mUuiuro6p9Pp9/tjsdjvfve7eWOOo0ePms3mWCymyd0BAAAAADCc+wpzG5vN5na75VEboVAo/Q4jxSYcDssLo6oqdzgc0pKlPp+vo6NDw7kqQgi73W6322OxWCAQ6OrqmpiYSHra6Oio1WoNBoPV1dUa3r3Afux+ffWaRr2rAIBCu3p57LDvNb2rAAAAMDbN0g2Xy1VfX6/cFzYNbSMAZW99fX35GL7R3t4uP1b139HRIaUb0Wi0tbX15MmTqSaeZK26utrpdEoDOjo7O+PxeOI5JRBwrF7TuG79Rr2rAAAAAAAYj2YzU0KhkMfjWbRokc/nU+3/Kj0lD9xQzuzQhHJNDZfL5fF4EieJZDgXxuPxtLe3K7eP7e3tbW5uljt0OByqsRsWi0XOdEKhUENDg8fjSdwB1+fzuVwun8+X2c+UnNPpjEQiu3btSvrs6OhoZ2dnLv0DAAAAAGBE2ozdiEaj8vf/eRcNzXB8R+bq6+u9Xq98X5/Pl0uI0NfX19fXl3Rvl/r6+qRbwHq93mg0Kmciae6e+89eXV3d3d1tNpuTDuKQ1uAg4wAAAAAAlBXNxm5kOByjp6dH83RDCOF2u5PmDhqy2WzDw8Op5tT09PScPHly3hk34XBYk2KcTmcwGEy62mhXV1ckEtHkLgAAAAAAGII2YzdMJtPw8HAoFBocHAyFQonzMrxer8jDqA2ljo6Ojo4OaUOWxNET9fX18noZaTIIr9drMpkGBweVP4Lb7bZYLPPuKetwOKQVRqPRqGoAi8lkkn52DV8Bs9kcDAatVqtqBEc8HpeyD61uBAAAAABAkdNyzxSLxZL1ghr37t1Lf4LNZpv3HPHX+EAKU7IjpSS5XC7ynOPIzGZzIBB46qmnVO1nz56Vgo8C1AAAAAAAgO40m5kCXVit1r179ya2d3V1FbwWAAAAAAD0QbpheF1dXbW1tarGs2fPsvoGAAAAAKBMkG6UgqQjNbq7uwteCAAAAAAAOiDdKAVOpzNx+EYgENClGAAAAAAACox0o0R0dnaqWiYmJkZGRnQpBgAAAACAQiLdKBF2uz2xkX1hAQAAAADlgHRDCCHu/VVhdnLNh7q6uqamJlUj6QYAAAAAoByQbpQOq9WqamHbFAAAAABAOSDdKB1ms1nVMjo6qkslAAAAAAAUEulG6airq0tsZPgGAAAAAKDkkW6UjsSZKYJ0AwAAAABQBkg3AAAAAACAsZFulLhYLKZ3CQAAAAAA5BfpRklpaWlRtYyMjOhSCQAAAAAABUO6AQAAAAAAjI10AwAAAAAAGNt9ehcALSXukJJ0m1gA4ctjYxeGLl4Yunp5bOrGpPKpmhWrVq9pXLd+44ZNT9c8tEqvCgEAAABkjnSjpExMTKhaiirdYBEQFIPTgRMfvPvrq1cupTph6sbk1I3JP5z56LDvtcbmJzfbt222by1khQAAAAAWinQDhcMGLtDX+dMfHva9phqpkd7Y8Lmx4XPHDx3Ytf/tdes35q82AAAAALlg3Q0ApW/mdnz/T158Y9f2BUUbsqkbk3t22P/du0fzwgAAAABogrEbpSMYDCY2ms3mghcCFJep65P7f/JC8qkoKx8VK81iVdNsy907YmpcXBsR1/6oOvf37/WOXRh6w99fsbQqn/UCAAAAWDDSjRJXXV2tdwmAnsKXx151tn19Z3pO6+IK8dhz4vHvi8VLklzTsFGIF8X0l+LSx+Lz98XdGfmZq1cuvepsI+AAAAAAig0zU0pH4pqdtbW1ulQCFImZ2/GDe/5RHW089n3xo/8QT7yYPNqQVT4onnhR/Og/RMOTymYp4Ji5Hc9DvQAAAACyRLpROhLX7CyqDVOAwtv/yotzJqQsrhDP7BPWnfPkGkqLl4hn/ll85xfKtqtXLv279zXtygQAAACQK9KN0pG47gbpBsrZB+/2jA2fmz1eXCEcvxQNWe17snaLeL5HLK6QG870nzh/+sOcawQAAACgDdKN0hGJRFQtpBsoWzO347/51wNzmhy/FMsbsu9xeYNo2alsOOx7jfkpAAAAQJEg3SgdExMTqhY2TEHZ+uDdnjnLbWx4MadoQ7J2i3js+/LR1I3JD97tybVPAAAAAFog3SgRSbeDZewGytPM7Xj/MUXusLxBPPGiNl0/8aKofEA+Oh04oU23AAAAAHJDulEiEjdMEYzdQLk6f/qjOQM3rDtTn7tAi5eIDbNBydSNSVbfAAAAAIoB6UaJSEw3WlpadKkE0N35M4rEofIBsbJJy97XblEuL3r+zEdadg4AAAAgK/fpXQC0kZhuMHADZevifw7NHmS3SUp6DRvFFx9LDz/7f89cvDCU/nQgvauXx1I9lXTWIQAAABKRbpSI0dFRVQuLbqA8hS+PzZmW8nAe0o2HZ9ON2P83tWeHXftbAEIIIZ566im9SwAAADAGZqaUgqS/3LNarYWuAygC6l1atZ2WIsl9+xUAAAAAmiLdKAVJ0w1mpqA8TV2fnD1QLJChpcoH89ItAAAAgGyRbpQClhQFZFM3/jx7wCALAAAAoDyQbpSCxLEbDNwAhBDi7ozeFQBYAN68AABA1kg3DC8SicTjcVUji26gbK1+pHH24Ktx/QoBsDAtLS3V1dV6VwEAAIyKdMPwWHQDUKqorJpzPP2l9ve4pt6iCECOqqqquru79a4CAAAYGOmG4SWmG7W1tWwHi7JVv6ZxzvFkHpKIqT9p3ydQrmpra7dv3z4yMkIuDwAAcnGf3gUgV4npBtNSUM4qllbVrFg1deOvO6dcGxVrt2h8jy8+lh82Nj/5hr9f4/5RZi5eGNqzw570qXv37hW4GAAAAINi7IaxRSKRiYkJVSPpBsrctzd9d/bgi4/F3Tta9j79pXI5jw2bn9aycwAAAABZId0wNhbdABJttm+bc/zZb7Xs/dNjyqMNm0g3AAAAAP2RbhhbYrpRVVVFuoEyV7+mcfUja2ePzx/TbG3Rr8aV01K+vem7NQ+t0qZnAAAAADkg3TC2kZERVQvTUgAhxDMv/Lc5xx/s1aDTu3fEqQNz7+LSoFsAAAAAOSPdMLBYLDY6qt4PgnQDEEJstm9tbH5y9vircVUwkY1TB5Qrbnz7/2/v/oPavvM7j39J5DVrsCS6IWu2aBGp6cYQ24rnNiVkN4jdDUcy0zMZs8Q3NzfI3OJ2bqZn5czMNTs3IJjd9o/DU/kyczeDt/zo3EwdFnflf1JKpmeRegnj7djgBJyWNIiVWpw4PSEFO/KarO+Pb/brjyUhhPT96quv9HyM/5C+iI/e368E5vPS58d3Xjz4zeeybRMAAACAGkg3DCzpohukG4DsB3/84z3l5gf3l6YzDzjkURv/NKsc2FNudv/49ewKBAAAAKAa0g0DY9ENIIUnnnyq549//NChpWnpp/91x1uoRG9KPz0tLrchSZL7x6+X7bVkXSMAAAAAdZBuGFhiusHADUD03fbj3zl6/KFDoevSn/8H6eqFtL7/7ob0zl9I/+cPxAkpkiSd+tHrbAQLAAAA5BWT3gUgQyy6AaRDnj/yfy+ef3Do7m1p5n9L1/5K+p3npIZ/K1X+TpJvu/VP0uLfSEt/I929HfeVUz96/bvtx5N8CwAAAAD9kG4YFYtuAGly//j1g9987ux//6OHjkY/kq79lXTtr6TdZV8EHNUOKTQvSZIUup60nT3l5p4//jHRBgAAyEAgEKitrc342wcGBgYGBlI/xmKxBAIBq9Wa8bMAhsbMFKNK3AtWkiQW3QCS+m77ce/kpdpvNCT52t3bUui6FLouzf3FFzeSqf1Gw5+MXSTaAAAAmbHb7adOndL0KTweD9EGihnphlEljt1obm7WoxDAGJ548qmzF/w/+G8/evxrth194+Nfs5360etnL/ifePIpjWoDAADFwOPxWCxarUpeU1Pjdrs1ahwwBNINo5qZmYk7wrQUYFv/7j/+wU+mr5760eu/950Xt33w733nxR+eHf/J9FWGbAAAgOxZrVav16tR42NjYxq1DBgF624YUtJpKaQbQJq+235cDize/cXPV95/7/ankY/+OfjxP/+y9smnys2Wsr2W2iefOvjN5/QuEwAAFBqXy+X1ehM3B8hSc3MzfQGAdMOQWFIUUMXBbz5HigEAAHLJ6/W2tLSo2yYDNwCJmSkGlTh24/Dhw7pUAgAAACB9Tqfz6NGjKjbY399vt9tVbBAwKNINQ0pMNxi4AQAAABiCiqtvWCwWFhMFZKQbxrO+vp44VY+9YAEAAABDsNvt/f39qjTl9XrZBRaQkW4YT9IlRUk3AAAAAKNwu901NTVZNnL48GGXy6VGOUAhIN0wHtINAAAAwNCsVqvH48myEe32lwWMiHTDeBLTjebmZl0qAQAAAJAZl8uVzZ/xXV1dLL0HiEg3jCcQCMQdYeAGAAAAYDgZD9+wWCzZD/0ACgzphvHMzMzEHSHdAAAAAAzH6XR2dXVl8I1ut5tdYIE4pBsGkzhwQ5IkfrUBAAAARuTxeCwWy46+paamhl1ggUSkGwaTNN1gxh0AAABgRHa7fadRhcfjYRdYIBHphsEkLim606wXAAAAQP7weDzp7w7b3NzMLrBAUqQbBrO+vh53hEU3AAAAAENLf29XdoEFtkK6YTB+vz/uCItuAAAAAIbW3t6ezu6wXV1dfLQJbIV0w/BINwAAAACj23ZQhsViYeAGkIJJ7wKwM4mrirKkUMb+1nf+43/5pXz7qW8+d/Cbz+lbT2pUqx1jVfvuL37+3i9+Lt9+/Gtf/277cX3rSY1qAQBIk8Ph6OrqGh8f3+oBbrebv/yBFEg3DGZ1dTXuCIPTMva3vr987+9n5dv//j9Led6npVrtGKva937x87/8X/9Dvv3Uv2nK8x441QIAkD6v1+vz+SKRSOKXampqPB5PzisCjISZKQAAAACgP6vVulWEwZwUYFukGwAAAACQF9xud+LusM3Nze3t7brUAxgI6YaRzM/PJx5kZgoAAABQMMbGxrY9AiAR6YaRrK+vJx5kbSEAAACgYDidTnF32FOnTrFJIpAOVhUFAADII36/X+8SAOjsD//wD2dmZiRJKisr+973vsevhR2xWq0Mby9OpBsAAAA68/l8Pp/P7/cnbo4GoJjdvn3793//9/WuwpAOHz7sdDpdLhdJR/FgZoqRJJ2EEggEcl4IAABQwfr6usfjsdvtL7/88vj4ONEGAKhlYWHh7NmzTz/9tNPpZPBLkSDdMJKkuaOB0o2kq6ICAFCc/H6/w+EYGBgg1AAA7czMzLS0tLS3tyddxBCFhHQDuROJRPQuAQCAvOB2u1taWsg1ACA3Ll68aLfb+bS1sLHuhuEZaOwGAACQJMnlco2Pj8cdLHvk0RctFY49ZXW7S/ft+pIuhQFAAfjgbmw59tnljejljah4PBKJPP3006Ojoy6XS6fSoC3SDYNpbm6W109WkG4AAGAgidFG2SOP/tHjVS9aKvQqCQAKyf7dpft3l75oqbh571ej//rxVCQsfvXEiRNWq7W9vV2v8qAdZqYYHsOrAAAwCq/XGxdtfKvcPPE73yDaAADV7dv1pdf2Vf+5ve6ru3aJx10uF58QFyTSDYNxOp1xR0g3AAAwhPn5+VdffVU84vrK4z/+7ZryRx7VqyQAKHj7d5eO2Ov27y5VjkQiESanFCTSDYNJ3DZldXWV6BEAgPzndrvFu22WihOPfVWvYgCgeJQ/8ujZrz8hBhwzMzNjY2P6VQRNkG4YTNJNYdnAGQCAPOf3+8WVsxx7yl7bV61jPQBQVMofefS1KluZMFbO4/HoVw40QbphMHa7vaamJu6gz+fTpRgAAJAmr9cr3iXaAIAc27+79PsVX1Hurq6uMnyjwJBuGE/iAr8XL15kcgoAAHlrfX394sWLyt02SwV7vgJA7n3/tx4Th2/wIXGBId0wnsSFRSVJIncEACBvxf0BfeIrj+tVCQAUs/JHHhX3qBJzZxQA0g3jaW9vT5yc4vV619fXdakHAACkJm5wtn93KQM3AEAvcTtws4JhISHdMKTEHYwikQjr4gAAkJ/EdMOxp1zHSgCgyIk7p0iSxAT/QkK6YUhxW8rJzp49K/7xBAAA8oQ4vrL8Ef76AgA9OfaUKbdJNwoJ/78aktVq7erqSjzucrmYnwIAQL5ZWFhQbu8v/bKOlQAAUKhIN4zK6/VaLJa4gwsLC0mHdQAAgDyxV1iuHwAAqIV0w6isVmvShTbGx8cTV+UAAAAAAKCAkW4YmNvtPnz4cOJxAg4AAAAAQFEh3TA2n8+XOD9F+k3AwRocAAAAAIBiQLphbHa7fWxsLOmXxsfHnU4nu6gAAAAAAAoe6Ybhtbe3j46OJv3SwsKC0+lMujwHAAAAAAAFg3SjELhcrq0CjkgkMjAwYLfbfT5fjqsCAAAAACA3SDcKRIqAQ5Kk1dXVl19+2eFwbDWNBQAAAAAA4yLdKBwul+tnP/tZ0kVGZQsLCydOnLDb7R6PJxAI5LA0AAAAAAA0RLpRUNrb2+fn55NuE6tYXV0dGBiora11OBxer5dlRwEAAAAARke6UWjsdvv8/Hx/f/+2j1xYWHj11Veffvpph8ORg8IAAAAAANBIyf379/WuAZoIBAIul2tmZmbbRx49ejQ3a46WlJSk+GrtNxrK9m45rUYLK//w3u1Po/Ltx79me/xrtlw++05RrXaMVe3H/xL8+F+C8u2yvebabzylbz2pUW06bn8aWfmHxaRf4v9oLWz1n9GlS5ecTmcOnvSs7QnHnjKNngiAyWyueqVDkqSqzo7wO3PLfYN6V4QvlNqq6wb6lvsHY8GQWo/MzKngh/N3bsu3+/v72WKyYJj0LgBasdvtfr/f7/d7PJ7UGYd2f8ztyFZ/3OeG2KvJf1SrHWNVe/vT6Ht/P6t3FemiWgBADpgs5trT7i/uvKNrKRBUNDUe8A6ZzOZ679DVY8dTP7jeO1TeUH/kwvnrJ05uLC7lpkIUAGamFDin0+n3+y9dunT06NEUj8lhRXmnbK9Z7xJ2gGq1Q7XaoVoAAHJATgSef/9605XLlW2tepfzQGVb68GRYZPZLElSeUO9rac7xYNrT7vLG+olSTKZzUcunK9oasxRlTA+0o2i4HQ6fT7fyspKf39/TU2N+CWLxVLk624oUxIMgWq1Q7XaoVoAALRmMpsPjQ4rucAB71Ce5AKVba0HvEPK3fDsXPDcSIrHr01MihNSDo58cVLAtpiZUkTkvWA9Hs/8/PzY2Jjf719YWMiHgRtdXV12u13vKgBAH4FAYHx8XO8qYHjlDfUVTY2Vba1iN2AzGpV7EWtvTG5GSe6AQlbR1CgPjlCUN9SHZ+f0qkepQYw21iYmt10JJRYMXT12XElqJEk6NDp89dhxjdbgQCEh3ShG8l6wkiQFAgG9a5EkSXK5XPkQsgCALvx+P+kGsmEym+sG+5KOQjeZv1iAoPa0Ozw7t3LGywx2ADkjr7Kh3E0n2pBtRqPXT5w8cuF8qa1abufQyPDVY8dJaZEaM1OKmt1uZ9AEAADGVWqrPnLhfDoT7PNkjDoAjYRn5+I6/7qnmXWDfXI8IUlSeHZn+9dsRqPXu08q4zVKbdW1ve7U3wKQbgAAABhVvXdI6TxIkrRyxnvlhZfefvKQ/O+Gu1eZ376xuKR7VweAduTxDvKP+WY0esPdq++0lKrODiV4jQVDN9y9O20hFgwtCd9V1dlBSovUmJkCAABgSOIqG7FgSPycU3ZravrW1PTKGW/taTcjuoGCt7G4tO1mqzkjboyy3D+Y2a+gjcUl+TeYfLduoO/KCy+pUx8KEWM3AAAADElcQDR4biTFknsrZ7ypNykAABVVdXYow8rWJiazGUUSPDeijDsrtVVXdXaoUB8KFOkGAACAIYnpRvgdnXdGAACFOHAj+2h15YxXuf1YGssMoWgxMwUAAACSJEkms7nqlQ7rs41xk9tjwdDaxKS09c6yz7z1pvw5bSwYSjFu/Pn3r8s3wrNz73afTPqYqs4Ok8Vc3lCfuFTq2sRkLBhKv6dUaquWG0namtJg6u1y5WsS18KtqemNxaUd9dmqOjvqBvvk28t9g/L13KksG9H9glQ0NcqRXOJ7TN69OBYM3ZqaTvN0qjo7yp+qFz/Jl8tIvwVJpddXlQubGVtPtzJrI9GO3iQqvjoVTY3iwI3sd3INz86FZ+fkquQ6WUUISZFuAAAAGF7Fs41rwUw6zDKT2Vzb695qyHeprVrZWTb9PR0zK0PpvSeSy7P1dC/3DaboZZnMZltPt/jRcYoG5W7bVg+oPe1O2k5lW2tlW+u2lSjiuqB1g30mi3mnH2hn3EieXJCDI8MploRUdi/eNzu33D+Yuj9c0dRYN9AnrqcrlpGitx8ny9dXxQurOxVfHenh4RVrb2T+e0kU+smIUmFlWyvpBpJiZgoAAIAhrQuzUWw93SazObN25G1l82E2+2Y0uu2H2yaz+YB3KEW1Jos5nQ6n7NP3kveR5GuSuh25knSeK/Hz/HQ28VWrkTy8IClUNDUeGhlOTC4UVZ0dB1M+IB2qnI4qF9ZYtn11ZMo7U8WtmsT9btk5BVth7AYAAIAh3ZqaVkINube25O7daV/CZDbHdVdWznhvTU2LH8+KEyK0pox+j/ug29bTLe4RU9vrvjU1vW0UkmJOjbjqYZyk10RpoaKpcZ+w1WXtaffG4pK+W2+mL08uSOIyt/IgCOXNXDfQl3TuUnlDvfhWDM/O3ZyYVIZXVHV2PNbWum3XV4vXN7MLm73guZG4K5n9T2vGr46svKFeSVrV/blYe2NSjpPkp2AfKCQi3QAAADCkWDC0MuRVejJywHFralrcYmBbtb1upeuVdFtZSZLWJiZzlm5stZ+l3Is7cuG8HHDIyyVsO9Q//M7cVo9JsR5B3DWJy4zkJQA2hHki1T/oTt2LuzU1LS4BKx9JXblGjeTJBUmsIXhu5NbU9JEL5+WO8VZrK/yu8D5MnCS1NjG5NjFZ2dZ6wDuU4tlVPx0p0wubnzJ+dWRiuqTu/BGxtYqmxgze/yh4zEwBAAAwqrWJyRvuXvFIZVvrkQvnD44MpzPTpLzhwaKMm9Fo0mgjr/yj0JuN6+qrJW7Lya2Gw4gRkrIc41aC50bEfvhy32AGSzCo0kgGtLggScUtGZs4BENsNhYMbbX+y6cpe9Q5O50Cs+2roxCnyKV+LXbqM+G3k3bDYWBopBsAAAAGdmtq+soLL8V9jFnR1Fg32Nd05XLqdQHEhRvkPRG0qlIlG4tLynD0L2vTvRG7vqlHwYjLJW47G2JtYvLtJw/J/zL+MF+VRnZKowuSlDhEIjFQ2PdwJRm0L+X2dApM6ldHIeYO6v5KEV8s0g0kRboBAABgbLFg6Ia7uQ5LzgAAIABJREFU9+qx43E9Xnmng6Yrl7daflLssxll5YjNyBfpRsarqKZW9cpDO4ymeGT4nbQ6e0aXywsidl8T0yvx7ZrxrARe34ylfnUUyg+mFmmpEm5q9OMPo2PdDQAAgEKwsbi03De43Ddo6+kWFzKUt34oTVgp0GQ2K322zWg0r3ZYlJcwjBt4Iu+pabJo2Ksxmc1Kr2nbayJ23vYWaO839xckFgzJb9247qtYSSwYymxFSV7fLG316uTMZiQqPzXpBpIi3QAAACgo8gKclW2tdYN9Sh+g9rRb2Y5EJsYE+TMnpfa0e6vZNPJQFE2fXRzubjKbn3//uqZPl//y54KIb9fPMn275s/pANACM1MAAAAK0K2p6Svfe0n8dDpFNHAvkhd7Kx65cD71QiFa25XpwJBCXQWgwC5IgZ1OntN0mBXbwSIpxm4AAAAUps1odMndq+zjWGqrTrGPo+7qBvvE1Q1uTU1/MjUdtzKCradbnrSiUQ15kvLkjwK7IAV2OvlJ06UxlJiJdANJkW4AAAAUrFgwtPbGpDIgoqKpUUk3NoWenlr7j2T8aa3JbBY3s1juG0y6J0jw3EhVZ4d26YY4Q2djcenqseMaPZFR5M8FEd+ue5/KfFEP5Tavr0bEi6xunKrdbiwoGMxMAQAAKGRbdQM2o1HlS6W26mwiA2UdBHHVxh2J270lZ9udxtmMRpXPhLO8JoUhfy6IuAioyWzObKpI/pxObmg6N2Qr4i8cdbdtFtd2Jd1AUqQbAAAAhSxFD0fc81LcKXOnYqEHPY3Mup1iP1NsLffW3vgiWDGZzVvtpFtU8ueCiJsWZ1xJ/pyORvT98ZEk6VNhsIa6O+mKrRllB2vkGOkGAABAIbM++2BYRNwHnp8Iq1pkM+NDbDazHqPYJdP3E/V1IfFRcY2Pqs6O59+/Lv8T5+DkvpGd0uiCZEBchMXW051ZjpY/p6ORzx6eGJL7AjYWl5QBMtlkpomUEV7iUwAi0g0AAABDqj3trj3tTt09q+rsULoEm9Fo3Aee4dk55UiprbpusC9pI9v2keK6nRn0qT5978HnvZVtrbr0ymTh2TnldEpt1YdGh7PfL8PW0y1e27rBvgy2hlGlkQxocUEys7G4pFRiMpsPjWRSSf6cjkZiwZDS869oatQlvhFfJnHSWTbKG+qVXwsM3MBWSDcAAAAMqeqVDltPd9OVy0k7urae7oMjw2J/OHhuJPEDz5UzXuV2ZVvrkQvnxUEBlW2tdYN9Ry6cT11JLBgSV8qQN3aN61al7opvRqOJLSRmHKW26hwsJbDcN6iMRilvqH/mrTfrBvsSx0pUNDXaerqVLWlSSBzPksEIF1UayYzqF0SVSkpt1c+89WbiO23by5I/p6ORhzKg0WHx58jW033AO6R1eigOCtun0iAjcRhI3FZKgII9UwAAAIynsq1V6XTJHbPa0+4Uj1+bmAyeG0k8vrG49G73yYMjw/Ld8ob6usG+rQZxpLAy5K14tlH5GFweV5J1CzutQh2b0ej17pP1QiewqrND6pS2uiyltuq83WdXFflzQeRKxFEbGbzT8ud0NCJvLSTfLm+oT0wnNxaXND2j8OxcLBiSX6PKttZg1junlNqqlTPSungYGmM3AAAAjCc8OycOu0htuW9wuW8wRVPvdp/Mcg+CzWj06rHj2YwYl1vIk09lY8HQ1WPH07zCe3cyc2erI9tSpZGMqXtBsq8ky1118ud0tBALhm64e1M8IAejUcQsdafxUyKxBWVdWCARYzcAAACMZzMaDZ4bCZ4bqWxrLbVVlzfUxw3Ilx8gPdzN2Ep4du7KCy9VdXaUP1UvDtFfm5jceG8p/M7cM2+9mU5J73afrGhqLG+oT+zPKLNXNhaXtgpBNqPRG+7eFVu1vPRG4hQD5aSknMy9l6+wPKcm8YzWJiZjwVCK0xHb2YxElaEBy32DGXTOVWkkS2pdkCxtRqPLfYPym9/6bGPcyg7KmyQ8O5f6Q/48OR0t3Jqa/vSFlyrbWuNm7siBTjq/E7K0NjGprPwqz/HJ+Ekr21qVXwVxk+CAOCX379/XuwYUi5KSkqTHL1265HQ6c1sLAOQLv9/f0tKS9Ev8H60FXf4zEp/0rO0Jx54yjZ5II/ICB/LttYnJFMNAAEBW2dZ6wDuk3L167HgGM0pMZvORC+eViUjvdp9UJWw6Ffxw/s5t+XZ/f7/H48m+TeQDZqYAAAAAANR0a2panDxV7x3KYEaMuKnN2sSkEcfRIJdINwAAAAAAKovb4+bQ6PCOAg5xe5dYMLQylO5KQyhapBvIkUAgsNWXrFZrDgsBAAAAoLnNaHRJWN+0vKE+/YDjgHdIWW5DbidxQ2sgDquKIkdSpBsOhyOHhQAAAAC6qRvsE9fuzYCBlr9J3HP60Ojw9RMnU0QVJrP5gHdIXCz2hruXXWCRDsZuAAAAAAA0Ie85rdwtb6iX96nZiq2nW4w21FpJFMWAdAMAAAAAoBU54JDHa2wsLskb025l5YxXHqkhbzJNtIH0MTMFAAAAAHJkuW/QKPNKVBSenbt67HjdQN9y//bnvuTulR+pLEoKpIN0AwAAAKnEgqG3nzykdxUAjC0WDIlTVFR5JCBiZgoAAAAAADA20g0AAAAAAGBspBsAAAAAAMDYSDcAAAAAAICxkW4AAAAAAABjI90AAADInbV7v9K7BAAAChDpBgAAgLaam5uV2zdJNwBAVxuff653CdAE6QYAAEDu3Ny8p3cJAFDUPrgbU247HA4dK4G6SDcAAAC05XQ6ldvX7mzoVwgAFLu/24iKd+12u06FQH2kGwAAANoSPxv86N69+Tu3dSwGAIrZZSHdsFgsjN0oJKQbAAAA2mpvb7dYLMrd0X/9SMdiAKBo3bz3q6lIWLnb3t6uYzFQHekGAACA5sS/oefv3Gb4BgDk3usfr4l3XS6XToVAE6QbAAAAmvN4POLdP7kZ3Pg1i/YDQO783UZUnJbS3NwsLoqEAkC6AQAAoDm73d7V1aXc/ejevVO//JCAAwBy44O7sT9dC4lH4kJnFADSDQAAgFzwer3i6hsf3I0RcABADnxwN/ZffvnhbeH37alTpxi4UXhK7t+/r3cNAAAAOVJSUpL0+KVLl3Lwl67f729paRGPfHXXrh/uszn2lGn91ABQnEY/+WjsXz8Wjxw+fNjv91utVr1KgkYYuwEAAJAjTqdzdHRUPPLRvXungh/+6c3QB3djelUFAAXpryPhzg/fj4s2LBaLz+cj2ihIJr0LAAAAKCLyEv0nTpwQD05FwlOR8Fd37fp2uWXfrl11u7+sT3EAYHzX7mx8cDd27c7t2wlT/2pqanw+n91u16MuaI50AwAAIKdcLpfdbm9vb49EIuLxj+7dmwx/oldVAFDYmpubGbVR2JiZAgAAkGtOpzMQCIi7qAAANGKxWP7sz/6MtTYKHukGAACADqxW69jY2LVr18g4AEAjNTU1/f39gUDA7XbrXQs0x54pAACgiOi7Z8pW1tfXfT6f3+8PBAIzMzN6lQEABaCmpsZutzt/Q+9ykDukGwAAoIjkZ7oBAACyxMwUAAAAAABgbKQbAAAAAADA2Eg3AAAAAACAsZFuAAAAAAAAYyPdAAAAAAAAxka6AQAAAAAAjI10AwAAAAAAGBvpBgAAAAAAMDbSDQAAAAAAYGykGwAAAAAAwNhINwAAAAAAgLGRbgAAAAAAAGMj3QAAAAAAAMZGugEAAAAAAIyNdAMAAAAAABgb6QYAAAAAADA20g0AAAAAAGBspBsAAAAAAMDYSDcAAAAAAICxkW4AAAAAAABjI90AAAAAAADGRroBAAAAAACMjXQDAAAAAAAYm0nvAgAAAIpdIBDw+Xx+v39+fn51dVXvcgDA2Jqbmx0Oh9PpbG9v17sW5E7J/fv39a4BAAAgR0pKSpIev3TpktPpzG0tkiRJfr/f4/HMzMzk/qkBoOBZLBaXy+V2u+12u961QHPMTAEAANBBIBBwOp0tLS1EGwCgkUgkcvbsWYfD4fF49K4FmiPdAAAAyDWfz+dwOMg1ACAHIpHIwMCAw+EIBAJ61wINse4GAABATo2NjZ04cSLx+P7dpd8qN+8v/fLeRx7NfVUAUBjW7v1q/rPb1+5sfHTvnnh8YWHB4XD4/X6Hw6FXbdAU6QYAAEDuJI022iwVJ77y+L5dX9KlJAAoJA6p7EVLhSRJf7cRnQx/Mn/ntvKlSCTidDoJOAoVq4oCAIAiou+qoj6f7+WXXxaP7N9d+lqVbf/uUq2fGgCK00/Dn4x+8vHtX3+uHKmpqZmfn7darTpWBS2w7gYAAEAurK+vu1wu8UibpeLs158g2gAA7Xy/4rH/+fUnyoQZf6urq3G/jVEYSDcAAABywe12RyIR5e63ys2v7asuZ4kNANDY/t2lcQHHxYsX/X6/fhVBE6QbAAAAmgsEAuPj48rdr+7a9VpVtY71AEBR2b+79E9+u0Y8wh6xhYd0AwAAQHNxf0b/cJ+NURsAkEuOPWVtlgrl7szMDMM3CgzpBgAAgLbW19d9Pp9yt81S4dhTpmM9AFCc/ujxKnF+ytjYmH61QH2kGwAAANry+/3iihsvmitSPBgAoJHyRx799l6zclfMnVEASDcAAAC0NT8/r9z+6q5dDNwAAL18q/xBuhGJRMTfzzA60g0AAABtiVO7n95Trl8hAFDsvi2kG5IkBQIBnQqB+kg3AAAAcmefaZfeJQBAUdu/u1S5zdiNQkK6AQAAoK2ZmRnl9r5dX9KxEgBA+aNsWVWYSDcAAAByp4p0AwAADZBuAAAAAAAAYyPdAAAAAAAAxka6AQAAAAAAjI10AwAAAAAAGBvpBgAAAAAAMDbSDQAAAAAAYGykGwAAAAAAwNhINwAAAAAAgLGRbgAAAAAAAGMj3QAAAAAAAMZGugEAAPCQ9fV1vUvInarODltP9wHv0PPvX9e7FhQ7k9ls6+m29XQ/89abdYN9epeTlVJb9cGR4VJbteoPBrAV0g0AAICH2O12r9erdxU58lhba+1pd2Vbq96FAJLJYq497a497TZ6P7+iqfHIhfMVTY313qF0Hl/vHZK/pbyhXuvagAJGugEAAPCQSCTy6quv2u12v9+vdy0ADKayrfXgyLDJbJYkqbyh3tbTnfrxtafdcqhhMpvlTCQXVQKFiHQDAAAgidXV1ZaWlvb29kAgoHctAIyhsq31gDBeIzw7Fzw3kvpb1iYmY8GQcvfgyDAjOIDMkG4AAABs6eLFi7W1tR6PJ88X45A/Ij5y4fzz719X/jVduSyvYiB/jAxAU+UN9WK0sTYx+W73yW2/KxYMXT12fGNxSTlyaJQ1OIBMkG4AAABsY2BgwG63j42N6V1IEiaz+YB36MiF88r4dvFL8ioGTVcu84EwoCmT2Vz/cLSx3DeY5vduRqPXT5xURnCYzOZDv5nbAiB9pBsAAADbi0QiJ06ccDqdebUYR6mt+siF8+msCcpkfkBTdYN9yoCL8Oxc+tGGbDMavd79IOAotVXX9rpVLhEodKQbAAAA6ZqZmWlpaXG5XHmyGEe9d0gcwb5yxnvlhZfefvKQ/O+Gu1eZ87+xuCQOfQegoqrODiVkjAVDN9y9GTQSC4aWhG+s6uwglAR2hHQDAABgZ8bHxx0Oh+6LcVS2tSqTTWLB0JUXXgqeGxGXJ7w1Nb1yxvv2k4eC50ZuTU3rVCZQ+MSNUZb7Bzej0cza2VhcWjnzYDvquoG+bCsDignpBgAAwI5FIpGBgQGHw+Hz+fSqQVxHIy7XiLNyxrvtxg0AMlPV2aEMoVqbmAzPzmXTWvDciDLMqtRWXdXZkW19QNEg3QAAAMjQ6urqyy+/7HQ65+fnc//sYroRfierDhWAjIkDN1SJEcXhG4+lsaoOAJlJ7wIAAACMbWZm5umnn+7q6vJ6vVarVe9yMifvHSt21SRJWjnjjQVD6UxsqersMFnM5Q31iaucrk1MxoKhbTt+5Q318kIDibvYhmfn1t+ZuzU1nWKIShyT2Vz1SkdcPbempjcWl3baBa3q7Kgb/GKOwHLf4NrE5I6+PfsWSm3V8lkkvbzSb67w2huTKeZEZHNBKpoa5TTN+mxj3GIQm9GoPHQo/dlPVZ0d5U/Vi6MS5DJ2NH9Kldc3+wtb0dQoDtxI//2ZQnh2Ljw7J19n+cqzaA6QjpL79+/rXQMAAECOlJSUJD1+6dIlp9OZ+jHbslgsbrfb4/GkeNKzticce8oyaz/OwZFhpZ+ZWZc7rpEUwrNzy/2DKXpuJrO56crl1I1sRqPLfYNb9WDTrGRtYnJlyLvtuga1p91xMU36lcSx9XTXnn5o94qdzvTJuAU5bEpxIqLNaHT2mW9t9dVsLohabxJJkiqaGusG+sSlcLeSekfVLF9fFS9s3WCfEtNcPXZcrRiioqnx4MiwfDt4bkQczYHsnQp+OH/ntny7v78/8Zc2DIqZKQAAANLY2JjnNzJuRF6Mw26352bX2HVhNkriYAd1VTQ1HhoZTvEUm9HotomDyWw+4B3Kch2Bqs6OIxfOp+gey7vkpu64ypWk2blN/Eg/nS14VWnBZIkfSpPCp+8l71erfkG2Ir9JUrw0VZ0dB1M+IB2qnI4qF1amvJTqbksUnp1TfqDYOQVIEzNTAAAApPHxcbWaWl1dbWlpaW5uHhsbs9vtajWb6NbUtBJqyF2+JXdvNv2rlTPezUhUHAMif76tPEVtrzvFx+nK3IS4UQm2nm5xe5faXvetqenUUUjc0AZ5+oAy/KHUVn1oZPjqseOJjZjM5rgO9soZrzKtoKKpcZ+wc2ftaffG4lKWa0DmTCwYkl+axFkS4qqWcVS/IImjTuLeJHUDfe92n0z8xvKGemVujiRJ4dm5mxOTyvCKqs6Ox9pat+3Ga/H6ZnZhlZNSIj/V30hrb0zKEYz8LBnvwwIUD8ZuAAAAqG9mZqa2ttbtdmu3a2wsGFoZejBeXQ44DniHxNVGdyR4biRuekvw3IgYIqTu7F09djx4biRxwoXciBK7yMslpK4kbk6BvGbHlRdeUmY9yFFL4jfW9rqVCmPBkFySUn94du6Gu1cc5F/9g+0/wE+c4LDT7XWzb0GSpPA7c/LlTezlrk1MrpzxJp28oPoF2er1FQcaJH0H/q4QbaxNTL7bfVK8CPKRG+7e1M+uxeub2YWViXGM6ktjiA0yfANIB+kGAACAVs6ePavp8I21icm4DmFlW+uRC+cPjgyrtZFk3GqgO52UofhHYdBHZvlLLBi63n0yRdQSt33mViNZxB03t+qKxz1eHLGy3De400VJs28hMxpdkERxb5LErrjYbCwY2moE0KcpA4KcnU76xLlaqYvPwGfCCiZZTucBigTpBgAAgIYikYim7d+amr7ywktxYwEqmhrrBvuarlzOciUFmTjkPuNe1sbikhJMfDnTRuJ60XEJjnhX7OImWnvjwRCVNJcyffvJQ/K/zFZvzb6FDGh3QRKJb5LEQGHfw5Vk0L6U29NJk/jjoMpuKSLxBEk3gHSQbgAAgCJSU1OjdwnqiwVDN9y9V48dj+s2m8zm2tPupiuXMx5wobSv3C6tzryXtRmJKoVl3IjYi47ruIoTXlJP/Qi/k6orXjByeUHErnhieiW+UhnMypHl4eurvJNVjzZkSiCo6ZrBQMEg3QAAAEXE5XLl8umOHj26srKSm+faWFxa7ht8+8lDK2e8Yl8r++0wxP1Qth12Ie9++vz718V/8igSk0WFHpo4BkRc09FkNiu3N6PR1IsgiNdnb4GmG7m/IEojcV1xsZJYMJTZ6pjF+fqqEggCxYM9UwAAQBFxu90+n29hYUHrJ6qpqRkbG3M6nVo/USJ5icTKtta6wT6lU1R72q3saZKBzUh02/5V7Wn3VhmKPIoks6dOFAuGlA/kTZYv9pIQh+6bzObn37+u1tMZVP5cEDHV+izTMQ75czoA8hbpBgAAKCJWq3V+fn5sbMzn8221m8nMzEw2T2GxWDwej9utWmc+M7empsOzc4dGhx9sxXranXG6sa0jF87nbIrHvUiSD/93ZTowpFBXNCiwC5Lnp6PKuKQU2A4WSAfpBgAAKDoulyvFFJWSkpKMWz516pTH47FarRm3oKLNaHTJ3Xvkwnl52EWprbq8oV71fSslSaob7BOjjVtT059MTcclKbaebltPtyoD7JN2dJNGHsWswC5Ifp6O1utiKNEM6QaQDtINAAAAFTQ3N3u9XofDoXchD4kFQ2tvTCoTRiqaGlVPN0xms7iZxXLfYNI9QYLnRqo6O1TpBIqNKAsTiEstbCwuXT12PPsnMrT8uSCbQjCx96lsF/WQ9D4dkViV6tGhphuyAAWJVUUBAACyUlNT87Of/czv9+dbtCHTul8kbocRnp3TertTk9ms9PrEJSrFpU9LbdWswpg/F0RcBFR8+XbaSJ6cjkj84cp4n+OtiOuhkm4A6SDdAAAAyJDFYunv7w8EAu3t7XrXsiWtVwQQ+5mxkOZ9MHF3W3HjT0mS1t6YVErKchPcwpA/F0TcxzfjSvLndBSfCoM1VF93RmxQvIAAtkK6AQAAkImurq5AIODxePQuZBvWZx+MrdDiE2Ax0cjBJ+ritiyfPLy0x7oQdqi1xoesqrND2d1WnIaTyxYyoN0F2SlxERZbT3dmwzfy53QU4v7EVa+o/LIqo6LEZwGQAukGAADAzjQ3N1+6dGlsbEzf1UNrT7trT7tT9/GqOjuUPtJmNKrFJ8Cfvvfg4+vKtlZVPsHeapB/3WCf0jEOz87FnU54dk7pRZfaqg+NDquyX4atp7tusE+sYauNb7VrITMaXZAMbCwuKZWYzOZDI5lUkj+nIxLPS5yllaXyhnrlR4mBG0CaSDcAAADSVVNTMzo66vf7nU6n3rVIVa902Hq6m65cTtpbtvV0HxwZFjvVwXMjWnwCvBmNimttHLlw3tbTnZhxlNqq058jc3Bk+IB3SJx9UNnWeuTCeXHUw8oZb+I3LvcNKuNTyhvqn3nrzbrBvsSxEhVNjbaebmU3mdQSJ0HsdFpE9i1kTIsLkn0lpbbqZ956M3H8xbaXJX9ORyEOINqn3qgccSSIdhs5AwWGPVMAAAC2Z7FY3G632+3Ok91eK9talZ6b3LurPe1O8fi1icnguRGNilkZ8lY826h8kF572l17Ots2K9taK9taD2zx1eW+waT7U2xGo9e7T9Z7h5R4paqzQ+qUxJRHVGqr1mKL3PyRPxdErkQctSEPPsqgkXw4HUV4di4WDMknVdnWGlRj55RSW7US2WwsLhX2WxRQEWM3AAAAtnH06NH5+XmPx5Mn0YYkSeHZuaSDF5Ja7htc7hvUrpjNaPTqseO5+YQ5Fgy9230yxc4ssWDo6rHjaV6cvWnMo0k8r52eafYtZEP1C5JlJVnuqpM/p6MQc8Od5jVJiY0oa6kC2BZjNwAAALZ0+PBhr9ebD/NQ4mxGo8FzI8FzI5VtraW26vKG+rhR/fIDpIe7XprWc8Pdu2KrlpfeSJxioNQjpbGOwJUXXkpsZ21icuO9pTT7xvLFkSfsJHY41yYmY8HQxuJSOisaBM+NbEaiyuiA5b7BnfbPs28heypekGxsRqPLfYPy+9b6bGPcQhXKmyQ8O5d6wEKenI7ydMpSqfKkmGx+6ORRS/LtWDCU+7cKYFwl9+/f17sGAACAPFJSUiJJksVi8Xq9LpdLrQZlZ21POPaUZd9m4Tk4Mqz0da+88JIW27sAGqlsaz3gHVLuXj12PLPpJCaz+ciF88rknXe7T7KkqBZOBT+cv3Nbvt3f35//W18hTcxMAQAAiHfq1KlAIKBKtAGg4N2amhZnG9V7hzJb0FTcCGZtYpJoA9gR0g0AAICHrKyseL3e/FliA0D+i9sU5tDo8E4DjgPCaqmxYGhlKN2FdQDISDcAAAAeYrfb9S4BgMFsRqNL7l7lbnlD/Y4CDnELZLkpLfZvBgob6QYAAAAAZGtjcend7pPK3TQDDpPZfHBkWFxA94a7l11ggQyQbgAAAACACsKzc3EBh7yxSwq2nm5x7xhWEgUyRroBAAAAAOqQAw55XsnG4tLKmW2Wz1g545VHamxGo0QbQDZINwAAAABANeHZuavHjodn58SVOFJYcvcq36J1bUABM+ldAAAAACCJ4/kBo4sFQ+m/pXf0YABbYewGAAAAAAAwNtINAAAAAABgbKQbAAAAAADA2Eg3AAAAAACAsZFuAAAAAAAAYyPdAAAAyJ1Pf/253iUAAFCASDcAAAC0dfjwYeX2B7HPdKwEAIBCRboBAACgLavVqty+uXlPx0oAAPN3biu37Xa7foVAZaQbAAAA2nI4HMrta3c2dKwEAIrcB3dj4l3SjUJCugEAAKAtMd346N69uL+tAQA589eRsHLbYrE4nU79aoHKSDcAAAC01d7eLt79afgTvSoBgGK28evPxXSDaKPAkG4AAABoy2q1Hj16VLk7FQkzfAMAcu+n/++T28LGVS6XS79aoL6S+/fv610DAABAgfP7/S0tLcrd/btL/9xep2M9AFBsPrgb+0+BZeVuTU1NIBDQrxyoj7EbAAAAmnM6nc3NzcrdD+7G/vRmSMd6AKCobPz68x/+c0A84vF49CkFmmHsBgAAQC4EAgGHwxGJRJQjbZaK1/ZV61gSABSDjV9/fuqXH4pTApubm/1+v34VQROM3QAAAMgFu93u9XrFI1OR8KnghxvCJHAAgLrm79zu/Kd/EKMNi8UyNjamX0XQCmM3AAAAcsflco2Pj4tHyh559PsVX/n+bz1W/sijelUFAIXn5r1fvf7x2uWNqHjQYrH4/X5xo24UDNINAACAnEoMOCRJKnvk0W/vNTu+XFa160uOPWW6FAYARnfz3q9u3rt37c7G5Y1o4u5URBuFjXQDAAAg17xe76uvvqp3FQBQRGpqanw+H9FGAWPdDQAAgFxzu93Xrl07fPiw3oUAQFFcELOdAAAAe0lEQVTo6uqan58n2ihspBsAAAA6cDgc8/Pzo6OjNTU1etcCAAXr6NGjly5dGhsbs1qtetcCbTEzBQAAQGfz8/NjY2N+v39hYUHvWgDA8CwWi8PhaG9vb29vt9vtepeDHCHdAAAAyCOBQCAQCOhdBQAYldPp1LsE6OP/A0yN4Ut4qNy2AAAAAElFTkSuQmCC">
<h6><span class="label">Figure 3-5. </span>Trait objects for trait bounds, with distinct vtables for <code>Draw</code> and <code>Shape</code></h6>
</div></figure>

<p>Comparing this with the previous diagram, it’s also clear that an explicitly constructed <code>&amp;dyn Any</code> trait object doesn’t help.
<code>Any</code> allows recovery of the original concrete type of the underlying item, but there is no runtime way to
see what traits it implements, or to get access to the relevant vtable that might allow creation of a trait object.</p>

<p>So what’s available instead?</p>

<p>The primary tool to reach for is <a data-primary="traits" data-type="indexterm" id="OEBPS/ch03.html.id1365"></a>trait definitions, and <a data-primary="Effective Java (Bloch)" data-type="indexterm" id="OEBPS/ch03.html.id1366"></a><a data-primary="Bloch, Joshua" data-type="indexterm" id="OEBPS/ch03.html.id1367"></a><a data-primary="Java" data-type="indexterm" id="OEBPS/ch03.html.id1368"></a>this is in line with advice for other languages—<em>Effective
Java</em>  Item 65 recommends, “Prefer interfaces to reflection.”  If code needs to rely on the availability of certain
behavior for an item, encode that behavior as a trait (<a href="#OEBPS/ch01.html.file_use-types-2_md">Item 2</a>). Even if the desired behavior
can’t be expressed as a set of method signatures, use marker traits to indicate compliance with the desired
behavior—it’s safer and more efficient than (say) introspecting the name of a class to check for a particular
prefix.</p>

<p>Code that expects trait objects can also be used with objects having backing code that was not <a data-primary="dlopen function" data-type="indexterm" id="OEBPS/ch03.html.id1369"></a>available at program link time,
because it has been dynamically loaded at runtime (via  <code>dlopen(3)</code> or equivalent)—which means that
monomorphization of a generic (<a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>) isn’t possible.</p>

<p>Relatedly, reflection is sometimes also used <a data-primary="libraries" data-secondary="multiple versions of same library" data-type="indexterm" id="OEBPS/ch03.html.id1370"></a>in other languages to allow multiple incompatible versions of the same
dependency library to be loaded into the program at once, bypassing linkage constraints that  There Can Be Only
One. This is not needed in Rust, where  Cargo already copes with multiple versions of the same library (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).</p>

<p>Finally,  macros—especially   <code>derive</code> macros—can be<a data-primary="macros" data-type="indexterm" id="OEBPS/ch03.html.id1371"></a><a data-primary="derive macros" data-type="indexterm" id="OEBPS/ch03.html.id1372"></a> used to auto-generate
ancillary code that understands an item’s type at compile time, as a more efficient and more type-safe equivalent to
code that parses an item’s contents at runtime.  <a href="#OEBPS/ch05.html.file_macros_md">Item 28</a> discusses Rust’s macro system.</p>








<section data-pdf-bookmark="Upcasting in Future Versions of Rust" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id100">
<h2>Upcasting in Future Versions of Rust</h2>

<p>The text of this Item was first written in 2021, and remained accurate all the way until the book was being prepared for
publication in 2024—at which point a new feature is due to be added to Rust that changes some of the details.<a data-primary="upcasting in future Rust versions" data-type="indexterm" id="OEBPS/ch03.html.id1373"></a><a data-primary="reflection" data-secondary="upcasting in future Rust versions" data-type="indexterm" id="OEBPS/ch03.html.id1374"></a><a data-primary="traits" data-secondary="new upcasting feature" data-type="indexterm" id="OEBPS/ch03.html.id1375"></a></p>

<p>This <a href="https://oreil.ly/gWJUW">new “trait upcasting” feature</a> enables  upcasts that
convert a trait object <code>dyn T</code> to a trait object <code>dyn U</code>, when <code>U</code> is one of <code>T</code>’s supertraits (<code>trait T: U {...}</code>).
The feature is gated on <code>#![feature(trait_upcasting)]</code> in advance of its official release, expected to be Rust version
1.76.<a data-primary="trait objects" data-secondary="upcasting in Rust version 1.76" data-type="indexterm" id="OEBPS/ch03.html.id1376"></a><a data-primary="Liskov substitution" data-type="indexterm" id="OEBPS/ch03.html.id1377"></a></p>

<p>For the preceding example, that means a <code>&amp;dyn Shape</code> trait object <em>can</em> now be converted to a <code>&amp;dyn Draw</code> trait object,
edging closer to the <em>is-a</em> relationship of  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution</a>.  Allowing this conversion has a knock-on
effect on the internal details of the vtable implementation, which are likely to become more complex than the versions
shown in <a data-type="xref" href="#OEBPS/ch03.html.fig_3_5">Figure&nbsp;3-5</a>.</p>

<p>However, the central<a data-primary="Any trait" data-type="indexterm" id="OEBPS/ch03.html.id1378"></a> points of this Item are not affected—the <code>Any</code> trait has no supertraits, so the ability to
upcast adds nothing to its functionality.<a data-primary="reflection" data-startref="ix_reflct" data-type="indexterm" id="OEBPS/ch03.html.id1379"></a></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 20: Avoid the temptation to over-optimize" data-type="sect1"><div class="sect1" id="OEBPS/ch03.html.file_optimize_md">
<h1>Item 20: Avoid the temptation to over-optimize</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>Just because Rust <em>allows</em> you to write super cool non-allocating zero-copy algorithms safely, doesn’t mean
<em>every</em> algorithm you write should be super cool, zero-copy and non-allocating.</p>
<p data-type="attribution"><a href="https://oreil.ly/fQMfu">trentj</a></p>
</blockquote>

<p>Most of the Items in this book are designed to help existing programmers become familiar with Rust and its idioms.<a data-primary="optimization" data-secondary="avoiding over-optimization" data-type="indexterm" id="OEBPS/ch03.html.ix_optiover"></a>  This
Item, however, is all about a problem that can arise when programmers stray too far in the other direction and become
obsessed with exploiting Rust’s potential for efficiency—at the expense of usability and maintainability.</p>








<section data-pdf-bookmark="Data Structures and Allocation" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id101">
<h2>Data Structures and Allocation</h2>

<p>Like pointers in other languages, Rust’s references allow you to reuse data without making copies.  <a data-primary="references" data-type="indexterm" id="OEBPS/ch03.html.id1380"></a>Unlike other
languages, Rust’s rules around reference lifetimes and borrows allow you to reuse data <em>safely</em>.<a data-primary="borrow checker" data-type="indexterm" id="OEBPS/ch03.html.id1381"></a>  However, complying
with the borrow checking rules (<a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>) that make this possible can lead to code that’s harder to use.</p>

<p>This is particularly relevant<a data-primary="data structures" data-secondary="and allocation" data-secondary-sortas="allocation" data-type="indexterm" id="OEBPS/ch03.html.ix_DSalloc"></a> for data structures, where you can choose between allocating a fresh copy of something
that’s stored in the data structure or including a reference to an existing copy of it.</p>

<p>As an example, consider some code that parses a data stream of bytes, extracting data encoded<a data-primary="TLV (type-length-value) structure" data-type="indexterm" id="OEBPS/ch03.html.ix_TLV"></a><a data-primary="type-length-value (TLV) structure" data-type="indexterm" id="OEBPS/ch03.html.ix_typeLV"></a> as  type-length-value
(TLV) structures where data is transferred in the following format:</p>

<ul>
<li>
<p>One byte describing the type of the value (stored in the <code>type_code</code> field here)<sup><a data-type="noteref" href="#OEBPS/ch03.html.id1382" id="OEBPS/ch03.html.id1382-marker">10</a></sup></p>
</li>
<li>
<p>One byte describing the length of the value in bytes (used here to create a slice of the specified length)</p>
</li>
<li>
<p>Followed by the specified number of bytes for the value (stored in the <code>value</code> field):</p>
</li>
</ul>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// A type-length-value (TLV) from a data stream.</code>
<code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Tlv</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">type_code</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">value</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="p">[</code><code class="kt">u8</code><code class="p">],</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">pub</code><code class="w"> </code><code class="k">type</code> <code class="nc">Error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;'</code><code class="nb">static</code><code class="w"> </code><code class="kt">str</code><code class="p">;</code><code class="w"> </code><code class="c1">// Some local error type.</code>

<code class="sd">/// Extract the next TLV from the `input`, also returning the remaining</code>
<code class="sd">/// unprocessed data.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">get_next_tlv</code><code class="p">(</code><code class="n">input</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(</code><code class="n">Tlv</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">]),</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">input</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="s">"too short for a TLV"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="c1">// The TL parts of the TLV are one byte each.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">type_code</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">input</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">input</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">usize</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">input</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="s">"TLV longer than remaining data"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">tlv</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Tlv</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">type_code</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Reference the relevant chunk of input data</code>
<code class="w">        </code><code class="n">value</code>: <code class="kp">&amp;</code><code class="nc">input</code><code class="p">[</code><code class="mi">2</code><code class="o">..</code><code class="mi">2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">len</code><code class="p">],</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="nb">Ok</code><code class="p">((</code><code class="n">tlv</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">input</code><code class="p">[</code><code class="mi">2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">len</code><code class="o">..</code><code class="p">]))</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This <code>Tlv</code> data structure is efficient because it holds a reference to the relevant chunk of the input data, without
copying any of the data, and Rust’s memory safety ensures that the reference is always valid.  That’s perfect for some
scenarios, but things become more awkward if something needs to hang onto an instance of the data structure (as
discussed in <a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>).</p>

<p>For example, consider a network server that is receiving messages in the form of TLVs.  The received data can be parsed
into <code>Tlv</code> instances, but the lifetime of those instances will match that of the incoming message—which might be
a transient <code>Vec&lt;u8&gt;</code> on the heap or might be a buffer somewhere that gets reused for multiple messages.</p>

<p>That induces a problem if the server code ever wants to store an incoming message so that it can be consulted later:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">NetworkServer</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="w">    </code><code class="sd">/// Most recent max-size message.</code>
<code class="w">    </code><code class="n">max_size</code>: <code class="nb">Option</code><code class="o">&lt;</code><code class="n">Tlv</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;&gt;</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Message type code for a set-maximum-size message.</code>
<code class="k">const</code><code class="w"> </code><code class="n">SET_MAX_SIZE</code>: <code class="kt">u8</code> <code class="o">=</code><code class="w"> </code><code class="mh">0x01</code><code class="p">;</code><code class="w"></code>

<code class="k">impl</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="n">NetworkServer</code><code class="o">&lt;'</code><code class="na">a</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">process</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">data</code>: <code class="kp">&amp;</code><code class="o">'</code><code class="na">a</code> <code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="p">(),</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">while</code><code class="w"> </code><code class="o">!</code><code class="n">data</code><code class="p">.</code><code class="n">is_empty</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="p">(</code><code class="n">tlv</code><code class="p">,</code><code class="w"> </code><code class="n">rest</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_next_tlv</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"></code>
<code class="w">            </code><code class="k">match</code><code class="w"> </code><code class="n">tlv</code><code class="p">.</code><code class="n">type_code</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="n">SET_MAX_SIZE</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                    </code><code class="c1">// Save off the most recent `SET_MAX_SIZE` message.</code>
<code class="w">                    </code><code class="bp">self</code><code class="p">.</code><code class="n">max_size</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Some</code><code class="p">(</code><code class="n">tlv</code><code class="p">);</code><code class="w"></code>
<code class="w">                </code><code class="p">}</code><code class="w"></code>
<code class="w">                </code><code class="c1">// (Deal with other message types)</code>
<code class="w">                </code><code class="c1">// ...</code>
<code class="w">                </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="s">"unknown message type"</code><code class="p">),</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rest</code><code class="p">;</code><code class="w"> </code><code class="c1">// Process remaining data on next iteration.</code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="nb">Ok</code><code class="p">(())</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This code compiles as is but is<a data-primary="lifetimes" data-type="indexterm" id="OEBPS/ch03.html.id1383"></a> effectively impossible to use: the lifetime of the <code>NetworkServer</code> has to be smaller
than the lifetime of any data that gets fed into its <code>process()</code> method. That means that a straightforward processing
loop:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1384">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">server</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NetworkServer</code>::<code class="n">default</code><code class="p">();</code><code class="w"></code>
<code class="k">while</code><code class="w"> </code><code class="o">!</code><code class="n">server</code><code class="p">.</code><code class="n">done</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Read data into a fresh vector.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">data</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">read_data_from_socket</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">server</code><code class="p">.</code><code class="n">process</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">log</code>::<code class="n">error</code><code class="o">!</code><code class="p">(</code><code class="s">"Failed to process data: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>fails to compile because the lifetime of the ephemeral data gets attached to the longer-lived server:</p>

<pre data-code-language="text" data-type="programlisting">error[E0597]: `data` does not live long enough
   --&gt; src/main.rs:375:40
    |
372 |     while !server.done() {
    |            ------------- borrow later used here
373 |         // Read data into a fresh vector.
374 |         let data: Vec&lt;u8&gt; = read_data_from_socket();
    |             ---- binding `data` declared here
375 |         if let Err(e) = server.process(&amp;data) {
    |                                        ^^^^^ borrowed value does not live
    |                                              long enough
...
378 |     }
    |     - `data` dropped here while still borrowed</pre>

<p>Switching the code so it reuses a longer-lived buffer doesn’t help either:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch03.html.id1385">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">perma_buffer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">0</code><code class="k">u8</code><code class="p">;</code><code class="w"> </code><code class="mi">256</code><code class="p">];</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">server</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NetworkServer</code>::<code class="n">default</code><code class="p">();</code><code class="w"> </code><code class="c1">// lifetime within `perma_buffer`</code>

<code class="k">while</code><code class="w"> </code><code class="o">!</code><code class="n">server</code><code class="p">.</code><code class="n">done</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Reuse the same buffer for the next load of data.</code>
<code class="w">    </code><code class="n">read_data_into_buffer</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">perma_buffer</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">server</code><code class="p">.</code><code class="n">process</code><code class="p">(</code><code class="o">&amp;</code><code class="n">perma_buffer</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">log</code>::<code class="n">error</code><code class="o">!</code><code class="p">(</code><code class="s">"Failed to process data: {:?}"</code><code class="p">,</code><code class="w"> </code><code class="n">e</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>This time, the compiler complains that the code is trying to hang on to a reference while also handing out a mutable
reference to the same buffer:</p>

<pre data-code-language="text" data-type="programlisting">error[E0502]: cannot borrow `perma_buffer` as mutable because it is also
              borrowed as immutable
   --&gt; src/main.rs:353:31
    |
353 |         read_data_into_buffer(&amp;mut perma_buffer);
    |                               ^^^^^^^^^^^^^^^^^ mutable borrow occurs here
354 |         if let Err(e) = server.process(&amp;perma_buffer) {
    |                         -----------------------------
    |                         |              |
    |                         |              immutable borrow occurs here
    |                         immutable borrow later used here</pre>

<p>The core problem is that the <code>Tlv</code> structure references transient data—which is fine for transient processing
but is fundamentally incompatible with storing state for later.  However, if the <code>Tlv</code> data structure is converted to
own its contents:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">Tlv</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">type_code</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">value</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="c1">// owned heap data</code>
<code class="p">}</code><code class="w"></code></pre>

<p>and the <code>get_next_tlv()</code> code is correspondingly tweaked to include an additional call to <code>.to_vec()</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// ...</code>
<code class="kd">let</code><code class="w"> </code><code class="n">tlv</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Tlv</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">type_code</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Copy the relevant chunk of data to the heap.</code>
<code class="w">    </code><code class="c1">// The length field in the TLV is a single `u8`,</code>
<code class="w">    </code><code class="c1">// so this copies at most 256 bytes.</code>
<code class="w">    </code><code class="n">value</code>: <code class="nc">input</code><code class="p">[</code><code class="mi">2</code><code class="o">..</code><code class="mi">2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">len</code><code class="p">].</code><code class="n">to_vec</code><code class="p">(),</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>then the server code has a much easier job.  The data-owning <code>Tlv</code> structure has no lifetime parameter, so the server
data structure doesn’t need one either, and both variants of the processing loop work fine.<a data-primary="type-length-value (TLV) structure" data-startref="ix_typeLV" data-type="indexterm" id="OEBPS/ch03.html.id1386"></a><a data-primary="TLV (type-length-value) structure" data-startref="ix_TLV" data-type="indexterm" id="OEBPS/ch03.html.id1387"></a><a data-primary="data structures" data-secondary="and allocation" data-secondary-sortas="allocation" data-startref="ix_DSalloc" data-type="indexterm" id="OEBPS/ch03.html.id1388"></a></p>
</div></section>








<section data-pdf-bookmark="Who’s Afraid of the Big Bad Copy?" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id102">
<h2>Who’s Afraid of the Big Bad Copy?</h2>

<p>One reason why programmers can become overly obsessed with reducing copies is that Rust generally makes copies and
allocations explicit.<a data-primary="copies, reducing" data-type="indexterm" id="OEBPS/ch03.html.id1389"></a>  A visible call to a method like <code>.to_vec()</code> or <code>.clone()</code>, or to a function like <code>Box::new()</code>,
makes it clear that copying and allocation are occurring.  This is in contrast to  C++, where it’s easy to
inadvertently write code that blithely performs allocation under the covers, particularly in a copy-constructor or
assignment operator.<a data-primary="C++" data-secondary="allocation, hidden" data-type="indexterm" id="OEBPS/ch03.html.id1390"></a></p>

<p>Making an allocation or copy operation visible rather than hidden isn’t a good reason to optimize it away, especially if
that happens at the expense of usability.<a data-primary="usability" data-type="indexterm" id="OEBPS/ch03.html.id1391"></a><a data-primary="efficiency (optimal), fine-tuning for" data-type="indexterm" id="OEBPS/ch03.html.id1392"></a>  In many situations, it makes more sense to focus on usability first, and
<em>fine-tune for optimal efficiency only if performance is genuinely a concern</em>—and if
 benchmarking (see <a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>) indicates that reducing copies will have a significant impact.</p>

<p>Also, the efficiency of your code is usually important only if it needs to scale up for extensive use.  If it turns out
that the trade-offs in the code are wrong, and it doesn’t cope well when millions of users start to use it—well,
that’s a nice problem to have.</p>

<p>However, there are a couple of specific points to remember.  The first was hidden behind the weasel word <em>generally</em>
when pointing out that copies are generally visible.  <a data-primary="copy semantics" data-type="indexterm" id="OEBPS/ch03.html.id1393"></a>The big exception to this is <code>Copy</code> types, where the compiler
silently makes copies willy-nilly, shifting from move semantics to copy semantics.<a data-primary="Copy trait" data-type="indexterm" id="OEBPS/ch03.html.id1394"></a>  As such, the advice in <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a> bears repeating here: don’t implement <code>Copy</code> unless a bitwise copy is valid and fast. But the converse is true
too: do <em>consider implementing <code>Copy</code> if a bitwise copy is valid and fast</em>. For example, <code>enum</code> types that
don’t carry additional data <a data-primary="enums" data-secondary="deriving Copy" data-type="indexterm" id="OEBPS/ch03.html.id1395"></a>are usually easier to use if they derive <code>Copy</code>.</p>

<p>The second point that might be relevant is the potential trade-off with  <code>no_std</code> use.<a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch03.html.id1396"></a>  <a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a> suggests that it’s
often possible to write code that’s <code>no_std</code>-compatible with only minor modifications, and code that avoids allocation
altogether makes this more straightforward.<a data-primary="alloc library" data-type="indexterm" id="OEBPS/ch03.html.id1397"></a>  However, targeting a <code>no_std</code> environment that supports heap allocation
(via the  <code>alloc</code> library, also described in <a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a>) may give the best balance of usability and <code>no_std</code> support.</p>
</div></section>








<section class="pagebreak-before less_space" data-pdf-bookmark="References and Smart Pointers" data-type="sect2"><div class="sect2" id="OEBPS/ch03.html.id103">
<h2>References and Smart Pointers</h2>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>So very recently, I’ve consciously tried the experiment of not worrying about the hypothetical perfect code. Instead,
I call .clone() when I need to, and use Arc to get local objects into threads and futures more smoothly.</p>
<p>And it feels glorious.</p>
<p data-type="attribution"><a href="https://oreil.ly/1ViCT">Josh Triplett</a></p>
</blockquote>

<p>Designing a <a data-primary="references" data-secondary="and smart pointers" data-secondary-sortas="smart" data-type="indexterm" id="OEBPS/ch03.html.id1398"></a>data structure so that it owns its contents can certainly make for better ergonomics, but there are still
potential problems if multiple data structures need to make use of the same information.  If the data is immutable, then
each place having its own copy works fine, but if the information might change (which is very commonly the case), then
multiple copies means multiple places that need to be updated, in sync with each other.<a data-primary="smart pointer types" data-type="indexterm" id="OEBPS/ch03.html.id1399"></a></p>

<p>Using Rust’s smart pointer types helps solve this problem, by allowing the design to shift from a single-owner model to
a shared-owner model.<a data-primary="ownership" data-secondary="shifting from single-owner to shared-owner model" data-type="indexterm" id="OEBPS/ch03.html.id1400"></a><a data-primary="Rc type" data-type="indexterm" id="OEBPS/ch03.html.id1401"></a><a data-primary="Arc type" data-type="indexterm" id="OEBPS/ch03.html.id1402"></a>  The  <code>Rc</code> (for single-threaded code) and  <code>Arc</code> (for multithreaded code) smart
pointers provide reference counting that supports this shared-ownership model.  Continuing with the assumption that
mutability is needed, they are typically paired with an inner type that allows  interior mutability, independently
of Rust’s borrow checking rules:</p>
<dl>
<dt><code>RefCell</code></dt>
<dd>
<p>For interior mutability in single-threaded code, giving the common <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> combination</p>
</dd>
<dt><code>Mutex</code></dt>
<dd>
<p>For interior mutability in multithreaded code (as per <a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>), giving the common <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
combination</p>
</dd>
</dl>

<p>This transition is covered in more detail in the <code>GuestRegister</code> example in <a href="#OEBPS/ch03.html.file_borrows_md">Item 15</a>, but the point here is that you
don’t have to treat Rust’s smart pointers as a last resort.  It’s not an admission of defeat if your design uses smart
pointers instead of a complex web of interconnected reference lifetimes—<em>smart pointers can lead to a
simpler, more maintainable, and more usable design</em>.<a data-primary="optimization" data-secondary="avoiding over-optimization" data-startref="ix_optiover" data-type="indexterm" id="OEBPS/ch03.html.id1403"></a></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch03.html.id1018"><sup><a href="#OEBPS/ch03.html.id1018-marker">1</a></sup> For example, the  Chromium project estimates that <a href="https://oreil.ly/GJkt0">70% of security bugs are due to memory safety</a>.</p><p data-type="footnote" id="OEBPS/ch03.html.id1082"><sup><a href="#OEBPS/ch03.html.id1082-marker">2</a></sup> Note that all bets are off with expressions like <code>m!(value)</code> that involve a  macro (<a href="#OEBPS/ch05.html.file_macros_md">Item 28</a>), because that can expand to arbitrary code.</p><p data-type="footnote" id="OEBPS/ch03.html.id1093"><sup><a href="#OEBPS/ch03.html.id1093-marker">3</a></sup> The compiler’s suggestion doesn’t help here, because <code>item</code> is needed on the subsequent line.</p><p data-type="footnote" id="OEBPS/ch03.html.id1162"><sup><a href="#OEBPS/ch03.html.id1162-marker">4</a></sup> <code>Cow</code> stands for  clone-on-write; a copy of the underlying data is made only if a change (write) needs to be made to it.</p><p data-type="footnote" id="OEBPS/ch03.html.id1167"><sup><a href="#OEBPS/ch03.html.id1167-marker">5</a></sup> Dealing with <code>async</code> code is beyond the scope of this book; to understand more about its need for self-referential data structures, see Chapter 8 of  <a class="orm:hideurl" href="https://rust-for-rustaceans.com/"><em>Rust for Rustaceans</em></a> by  Jon Gjengset (No Starch Press).</p><p data-type="footnote" id="OEBPS/ch03.html.id1198"><sup><a href="#OEBPS/ch03.html.id1198-marker">6</a></sup> In practice, most of this <code>std</code> functionality is actually provided by <code>core</code> and so is available to <code>no_std</code> code as described in <a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a>.</p><p data-type="footnote" id="OEBPS/ch03.html.id1231"><sup><a href="#OEBPS/ch03.html.id1231-marker">7</a></sup> The third category of behavior is  <em>thread-hostile</em>: code that’s dangerous in a multithreaded environment <em>even if</em> all access to it <a data-primary="thread-hostile" data-type="indexterm" id="OEBPS/ch03.html.id1404"></a>is externally synchronized.</p><p data-type="footnote" id="OEBPS/ch03.html.id1236"><sup><a href="#OEBPS/ch03.html.id1236-marker">8</a></sup> The  Clang C++ compiler includes a <a class="orm:hideurl" href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><code>-Wthread-safety</code></a> option, sometimes known as <em>annotalysis</em>, that allows data to be annotated with information about which mutexes protect which data, and functions to be annotated with information about the locks they acquire. This gives <em>compile-time</em> errors when these invariants are broken, like Rust; however, there is nothing to enforce the use of these annotations in the first place—for example, when a thread-compatible library is used in a multithreaded environment for the first time.</p><p data-type="footnote" id="OEBPS/ch03.html.id1313"><sup><a href="#OEBPS/ch03.html.id1313-marker">9</a></sup> Tom Cargill’s 1994 <a href="https://oreil.ly/J9hes">article in the <em>C++ Report</em></a> explores just how difficult exception safety is for C++ template code, as does  Herb Sutter’s <a href="https://oreil.ly/521d9">Guru of the Week #8 column</a>.</p><p data-type="footnote" id="OEBPS/ch03.html.id1382"><sup><a href="#OEBPS/ch03.html.id1382-marker">10</a></sup> The field can’t be named <code>type</code> because that’s a reserved keyword in Rust.<a data-primary="raw identifier prefix (r#)" data-type="indexterm" id="OEBPS/ch03.html.id1405"></a>  It’s possible to work around this restriction by using the  <a href="https://oreil.ly/oC8VO">raw identifier prefix</a> <code>r#</code> (giving a field <code>r#type: u8</code>), but it’s normally easier just to rename the field.</p></div></div></section></div></div>
<div id="OEBPS/ch04.html"><div data-type="book">
<section data-pdf-bookmark="Chapter 4. Dependencies" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch04.html.file_deps_md">
<h1><span class="label">Chapter 4. </span>Dependencies</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
<p>When the Gods wish to punish us, they answer our prayers.</p>
<p data-type="attribution">Oscar Wilde</p>
</blockquote>

<p>For decades, the idea of code reuse was merely a dream.<a data-primary="code reuse" data-type="indexterm" id="OEBPS/ch04.html.id1406"></a><a data-primary="dependencies" data-secondary="defined" data-type="indexterm" id="OEBPS/ch04.html.id1407"></a><a data-primary="Wilde, Oscar" data-type="indexterm" id="OEBPS/ch04.html.id1408"></a>  The idea that code could be written once, packaged into a
library, and reused across many different applications was an ideal, realized only for a few standard libraries and for
corporate in-house tools.</p>

<p>The growth of the internet and the rise of open source software finally changed that.<a data-primary="CPAN (Comprehensive Perl Archive Network)" data-type="indexterm" id="OEBPS/ch04.html.id1409"></a><a data-primary="open source" data-type="indexterm" id="OEBPS/ch04.html.id1410"></a> The first openly accessible
repository that held a wide collection of useful libraries, tools, and helpers, all packaged up for easy reuse, was
 <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/CPAN">CPAN</a>: the Comprehensive Perl Archive Network, online since 1995.<a data-primary="C" data-type="indexterm" id="OEBPS/ch04.html.id1411"></a><a data-primary="C++" data-type="indexterm" id="OEBPS/ch04.html.id1412"></a>  Today, almost every modern language has a comprehensive collection of open source libraries available, housed in a package
repository that makes the process of adding a new dependency easy and quick.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1413" id="OEBPS/ch04.html.id1413-marker">1</a></sup></p>

<p>However, new problems come along with that ease, convenience, and speed.  It’s <em>usually</em> still easier to reuse existing
code than to write it yourself, but there are potential pitfalls and risks that come along with dependencies on someone
else’s code.  This chapter of the book will help you be aware of these.<a data-primary="Cargo" data-type="indexterm" id="OEBPS/ch04.html.id1414"></a></p>

<p>The focus is specifically on Rust, and with it the use of the  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo"><code>cargo</code></a> tool,
but many of the concerns, topics, and issues covered apply equally well to other toolchains (and other languages).</p>






<section data-pdf-bookmark="Item 21: Understand what semantic versioning promises" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_semver_md">
<h1>Item 21: Understand what semantic versioning promises</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>If we acknowledge that SemVer is a lossy estimate and represents only a subset of the possible scope of
changes, we can begin to see it as a blunt instrument.</p>
<p data-type="attribution">Titus Winters, <em>Software Engineering at Google</em> (O’Reilly)</p>
</blockquote>

<p>Cargo, Rust’s package manager, allows automatic selection of dependencies (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) for Rust code according to
 <em>semantic versioning</em> (semver).<a data-primary="Cargo" data-secondary="automatic dependency selection by semver" data-type="indexterm" id="OEBPS/ch04.html.id1415"></a><a data-primary="package manager for Rust" data-see="Cargo" data-type="indexterm" id="OEBPS/ch04.html.id1416"></a><a data-primary="dependencies" data-secondary="selection by cargo by semantic versioning" data-type="indexterm" id="OEBPS/ch04.html.id1417"></a><a data-primary="semantic versioning" data-type="indexterm" id="OEBPS/ch04.html.ix_semver"></a>  A  <em>Cargo.toml</em> stanza like:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[dependencies]</code><code class="w"></code>
<code class="n">serde</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"1.4"</code><code class="w"></code></pre>

<p>indicates to <code>cargo</code> what ranges of semver versions are acceptable for this dependency.  The <a href="https://oreil.ly/fchXS">official documentation</a> provides the details on specifying precise
ranges of acceptable versions, but <a data-primary="semantic versioning" data-secondary="ranges of acceptable versions" data-type="indexterm" id="OEBPS/ch04.html.id1418"></a>the following are the most commonly used variants:</p>
<dl>
<dt><code>"1.2.3"</code></dt>
<dd>
<p>Specifies that any version that’s semver-compatible with 1.2.3 is acceptable</p>
</dd>
<dt><code>"^1.2.3"</code></dt>
<dd>
<p>Is another way of specifying the same thing more explicitly</p>
</dd>
<dt><code>"=1.2.3"</code></dt>
<dd>
<p>Pins to one particular version, with no substitutes accepted</p>
</dd>
<dt><code>"~1.2.3"</code></dt>
<dd>
<p>Allows versions that are semver-compatible with 1.2.3 but only where the last specified component changes
(so 1.2.4 is acceptable but 1.3.0 is not)</p>
</dd>
<dt><code>"1.2.*"</code></dt>
<dd>
<p>Accepts any version that matches the wildcard</p>
</dd>
</dl>

<p>Examples of what these specifications allow are shown in <a data-type="xref" href="#OEBPS/ch04.html.table_4_1">Table&nbsp;4-1</a>.</p>
<table id="OEBPS/ch04.html.table_4_1">
<caption><span class="label">Table 4-1. </span>Cargo dependency version specification</caption>
<thead>
<tr>
<th>Specification</th>
<th>1.2.2</th>
<th>1.2.3</th>
<th>1.2.4</th>
<th>1.3.0</th>
<th>2.0.0</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>"1.2.3"</code></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"^1.2.3"</code></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"=1.2.3"</code></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"~1.2.3"</code></p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"1.2.*"</code></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"1.*"</code></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr>
<td><p><code>"*"</code></p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>

<p>When choosing dependency versions, Cargo will generally pick the largest version
that’s within the combination of all of these semver ranges.</p>

<p>Because semantic versioning is at the heart of <code>cargo</code>’s dependency resolution process, this Item explores more
details about what semver means.<a data-primary="Cargo" data-secondary="dependency resolution process" data-type="indexterm" id="OEBPS/ch04.html.id1419"></a></p>








<section data-pdf-bookmark="Semver Essentials" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id106">
<h2>Semver Essentials</h2>

<p>The essentials of<a data-primary="semantic versioning" data-secondary="essentials of" data-type="indexterm" id="OEBPS/ch04.html.id1420"></a> semantic versioning are listed in the <a href="https://oreil.ly/sBrbZ">summary in the semver documentation</a>, reproduced here:</p>
<blockquote>
<p>Given a version number MAJOR.MINOR.PATCH, increment<a data-primary="backward compatibility" data-type="indexterm" id="OEBPS/ch04.html.id1421"></a> the:</p>

<ul>
<li>
<p>MAJOR version when you make incompatible API changes</p>
</li>
<li>
<p>MINOR version when you add functionality in a backward compatible manner</p>
</li>
<li>
<p>PATCH version when you make backward compatible bug fixes</p>
</li>
</ul></blockquote>

<p>An important point lurks in the <a class="orm:hideurl" href="https://semver.org/#spec-item-3">details</a>:</p>
<blockquote><ol start="3">
<li>
<p>Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications
MUST be released as a new version.</p>
</li>

</ol></blockquote>

<p>Putting this into different words:</p>

<ul>
<li>
<p>Changing <em>anything</em> requires a new patch version.<a data-primary="patch version" data-type="indexterm" id="OEBPS/ch04.html.id1422"></a></p>
</li>
<li>
<p><em>Adding</em> things to the API in a way that means existing users of the crate still compile and work requires a minor
version upgrade.<a data-primary="minor version" data-type="indexterm" id="OEBPS/ch04.html.id1423"></a><a data-primary="major version" data-type="indexterm" id="OEBPS/ch04.html.id1424"></a></p>
</li>
<li>
<p><em>Removing</em> or <em>changing</em> things in the API requires a major version upgrade.</p>
</li>
</ul>

<p>There is one more important <a class="orm:hideurl" href="https://semver.org/#spec-item-4">codicil</a> to the semver rules:</p>
<blockquote><ol start="4">
<li>
<p>Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT
be considered stable.</p>
</li>

</ol></blockquote>

<p>Cargo adapts this last rule slightly, “left-shifting” the earlier rules so that changes in the leftmost non-zero
component indicate incompatible changes.  This means that 0.2.3 to 0.3.0 can include an incompatible API change, as can
0.0.4 to 0.0.5.</p>
</div></section>








<section data-pdf-bookmark="Semver for Crate Authors" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id107">
<h2>Semver for Crate Authors</h2>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>In theory, theory is the same as practice. In practice, it’s not.</p>
</blockquote>

<p>As a crate <a data-primary="semantic versioning" data-secondary="for crate authors" data-secondary-sortas="crate" data-type="indexterm" id="OEBPS/ch04.html.id1425"></a><a data-primary="crates" data-secondary="semantic versioning for authors" data-type="indexterm" id="OEBPS/ch04.html.id1426"></a>author, the first of these rules is easy to comply with, in theory: if you touch anything, you need a new
release.<a data-primary="Git, tracking commits" data-type="indexterm" id="OEBPS/ch04.html.id1427"></a> Using  Git <a class="orm:hideurl" href="https://git-scm.com/docs/git-tag"><em>tags</em></a> to match releases can help with
<span class="keep-together">this—</span>by default, a tag is fixed to a particular commit and can be moved only with a manual <code>--force</code>
option. Crates published to  <a class="orm:hideurl" href="https://crates.io"><code>crates.io</code></a> also get automatic policing of this, as the registry
will reject a second attempt to publish the same crate version.<a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch04.html.id1428"></a> The main danger for noncompliance is when you notice a
mistake <em>just after</em> a release has gone out, and you have to resist the temptation to just nip in a fix.</p>

<p>The semver specification covers API compatibility, so if you make a minor change to behavior that doesn’t alter the API,
then a patch version update should be all that’s needed.<a data-primary="Hyrum's Law" data-type="indexterm" id="OEBPS/ch04.html.id1429"></a>  (However, if your crate is widely depended on, then in practice
you may need to be aware of  <a href="https://oreil.ly/7lQQ_">Hyrum’s Law</a>: regardless of how minor a change you make
to the code, someone out there is likely to <a class="orm:hideurl" href="https://xkcd.com/1172/">depend on the old behavior</a>—even if the API
is unchanged.)</p>

<p>The difficult part for crate authors is the latter rules, which require an accurate determination of whether a change is
back compatible or not.<a data-primary="backward compatibility" data-secondary="crate author determining for changes" data-type="indexterm" id="OEBPS/ch04.html.id1430"></a>  Some changes are obviously incompatible—removing public entrypoints or types, changing
method signatures—and some changes are obviously backward compatible (e.g., adding a new method to a <code>struct</code>,
or adding a new constant), but there’s a lot of gray area left in between.</p>

<p>To help with this, the <a href="https://oreil.ly/Y6ZLJ">Cargo book</a> goes into considerable detail as to what is and is not
 back compatible. Most of these details are unsurprising, but there are a few areas worth
highlighting:</p>

<ul>
<li>
<p>Adding new items is <em>usually</em> safe—but may cause clashes if code using the crate already makes use of something that
happens to have the same name as the new item.</p>

<ul>
<li>
<p>This is a particular danger if the user does a  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#minor-adding-new-public-items">wildcard import from the crate</a>, because all of the
crate’s items are then automatically in the user’s main namespace. <a href="#OEBPS/ch04.html.file_wildcard_md">Item 23</a> advises against doing this.</p>
</li>
<li>
<p>Even without a wildcard import, a <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-adding-a-defaulted-trait-item">new trait method</a> (with
a default implementation; <a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>) or a <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-change-adding-any-inherent-items">new inherent method</a>
has a chance of clashing with an existing name.</p>
</li>
</ul>
</li>
<li>
<p>Rust’s insistence on covering all possibilities means that changing the set of available possibilities can be a
breaking change.</p>

<ul>
<li>
<p>Performing a <code>match</code> on an <code>enum</code> must cover all possibilities, so if a <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-new-enum-variants-without-non_exhaustive">crate adds a new <code>enum</code> variant</a>,
that’s a breaking change (unless the <code>enum</code> is already marked as
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>—<em>adding</em>
<code>non_exhaustive</code> is also a breaking change).<a data-primary="enums" data-type="indexterm" id="OEBPS/ch04.html.id1431"></a><a data-primary="non_exhaustive attribute" data-type="indexterm" id="OEBPS/ch04.html.id1432"></a></p>
</li>
<li>
<p>Explicitly creating an instance of a  <code>struct</code> requires an initial value for all fields, so <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-a-public-field-when-no-private-field-exists">adding a field to a structure that can be publicly instantiated</a>
is 
<span class="keep-together">a breaking</span> change.  <a data-primary="structs" data-type="indexterm" id="OEBPS/ch04.html.id1433"></a>Structures that have private fields are OK, because crate users can’t explicitly construct
them anyway; a <code>struct</code> can also be marked 
<span class="keep-together">as <code>non_exhaustive</code></span> to prevent external users from performing explicit

<span class="keep-together">construction</span>.</p>
</li>
</ul>
</li>
<li>
<p>Changing a trait so it is  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/semver.html#trait-object-safety">no longer <em>object safe</em></a> (<a href="#OEBPS/ch02.html.file_generics_md">Item 12</a>) is a breaking change; any
users that build trait objects for the trait will stop being able to compile their code.<a data-primary="object safety" data-type="indexterm" id="OEBPS/ch04.html.id1434"></a><a data-primary="traits" data-secondary="breaking changes in" data-type="indexterm" id="OEBPS/ch04.html.id1435"></a></p>
</li>
<li>
<p>Adding a new  blanket implementation for a trait is a breaking change; any users that already implement the trait
will now have two conflicting implementations.</p>
</li>
<li>
<p>Changing the  <em>license</em> of an open source crate is an incompatible change: users of your crate who have strict<a data-primary="licenses" data-secondary="changing license for open source crate" data-type="indexterm" id="OEBPS/ch04.html.id1436"></a>
restrictions on what licenses are acceptable may be broken by the change. <em>Consider the license to be part of
your API</em>.</p>
</li>
<li>
<p>Changing the  default features (<a href="#OEBPS/ch04.html.file_features_md">Item 26</a>) of a crate is potentially a breaking change. <a data-primary="default features" data-type="indexterm" id="OEBPS/ch04.html.id1437"></a>Removing a default
 feature is almost certain to break things (unless the feature was already a no-op); adding a default feature may
break things depending on what it enables.  <em>Consider the default feature set to be part of your API</em>.</p>
</li>
<li>
<p>Changing library code so that it uses a new feature of Rust <em>might</em> be an incompatible change, because users of your
crate who have not yet upgraded their compiler to a version that includes the feature will be broken by the change.<a data-primary="minimum supported Rust version (MSRV)" data-type="indexterm" id="OEBPS/ch04.html.id1438"></a>
However, most Rust crates treat a minimum supported Rust version (MSRV) increase as a <a href="https://oreil.ly/Tadgz"><em>non</em>-breaking change</a>, so <em>consider whether the MSRV forms part of your API</em>.</p>
</li>
</ul>

<p>An obvious corollary of the rules is this: the fewer public items a crate has, the fewer things there are that can
induce an incompatible change (<a href="#OEBPS/ch04.html.file_visibility_md">Item 22</a>).</p>

<p>However, there’s no escaping the fact that comparing all public API items for compatibility from one release to the next
is a time-consuming process that is likely to yield only an <em>approximate</em> (major/minor/patch) assessment of the level of
change, at best.<a data-primary="cargo-semver-checks" data-type="indexterm" id="OEBPS/ch04.html.id1439"></a> Given that this comparison is a somewhat mechanical process, hopefully tooling (<a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a>) will arrive
to make the process easier.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1440" id="OEBPS/ch04.html.id1440-marker">2</a></sup></p>

<p>If you do need to make an incompatible major version change, it’s nice to make life easier for your users by ensuring
that the same overall functionality is available after the change, even if the API has radically changed.  If possible,
the most helpful sequence for your crate users is as follows:</p>
<ol>
<li>
<p>Release a minor version update that includes the new version of the API and that marks the older variant as
<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, including an
indication of how to migrate.<a data-primary="deprecated attribute" data-type="indexterm" id="OEBPS/ch04.html.id1441"></a></p>
</li>
<li>
<p>Release a major version update that removes the deprecated parts of the API.</p>
</li>

</ol>

<p>A more subtle point is <em>make breaking changes breaking</em>. If your crate is changing its behavior in a
way that’s actually incompatible for existing users but that <em>could</em> reuse the same API: don’t.  Force a change in
types (and a major version bump) to ensure that users can’t inadvertently use the new version incorrectly.</p>

<p>For the less tangible parts of your API—such as the
 <a href="https://oreil.ly/Gast-">MSRV</a> or the
license—consider setting up a CI check (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) that detects changes, using tooling
(e.g., <code>cargo-deny</code>; see <a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) as needed.<a data-primary="cargo-deny" data-type="indexterm" id="OEBPS/ch04.html.id1442"></a></p>

<p>Finally, don’t be afraid of version 1.0.0 because it’s a commitment that your API is now fixed. Lots of crates fall into
the trap of staying at version 0.x forever, but that reduces the already-limited expressivity of semver from three
categories (major/minor/patch) to two (effective-major/effective-minor).</p>
</div></section>








<section data-pdf-bookmark="Semver for Crate Users" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id108">
<h2>Semver for Crate Users</h2>

<p>For the <a data-primary="crates" data-secondary="semantic versioning for users" data-type="indexterm" id="OEBPS/ch04.html.id1443"></a><a data-primary="semantic versioning" data-secondary="for crate users" data-secondary-sortas="crate" data-type="indexterm" id="OEBPS/ch04.html.id1444"></a>user of a crate, the <em>theoretical</em> expectations for a new version of a dependency are as follows:</p>

<ul>
<li>
<p>A new patch version of a dependency crate Should Just Work.™</p>
</li>
<li>
<p>A new minor version of a dependency crate Should Just Work,™ but the new parts of the API might be worth
exploring to see if there are now cleaner or better ways of using the crate.  However, if you do use the new parts, you
won’t be able to revert the dependency back to the old version.</p>
</li>
<li>
<p>All bets are off for a new major version of a dependency; chances are that your code will no longer compile, and you’ll
need to rewrite parts of your code to comply with the new API.  Even if your code does still compile, you should
<em>check that your use of the API is still valid after a major version change</em>, because the constraints and
preconditions of the library may have changed.</p>
</li>
</ul>

<p>In practice, even the first two types of change <em>may</em> cause unexpected behavior changes, even in code that still
compiles fine, due to  Hyrum’s Law.<a data-primary="Hyrum's Law" data-type="indexterm" id="OEBPS/ch04.html.id1445"></a></p>

<p>As a consequence of these expectations, your dependency specifications will commonly take a form like <code>"1.4.3"</code> or
<code>"0.7"</code>, which includes subsequent compatible versions; <em>avoid specifying a completely  wildcard
dependency</em> like <code>"*"</code> or <code>"0.*"</code>. A completely wildcard dependency says that <em>any</em> version of the dependency, with
<em>any</em> API, can be used by your crate—which is unlikely to be what you really want.<a data-primary="wildcard dependency" data-type="indexterm" id="OEBPS/ch04.html.id1446"></a>
Avoiding wildcards is also a requirement for <a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch04.html.id1447"></a>publishing to <code>crates.io</code>; submissions with <code>"*"</code> wildcards will be
<a href="https://oreil.ly/i6ELc">rejected</a>.</p>

<p class="pagebreak-before less_space">However, in the longer term, it’s not safe to just ignore major version changes in dependencies.  Once a library has had
a major version change, the chances are that no further bug fixes—and more importantly, security
updates—will be made to the previous major version.  A version specification like <code>"1.4"</code> will then fall further
and further behind as new 2.x releases arrive, with any security problems left 
<span class="keep-together">unaddressed</span>.</p>

<p>As a result, you need to either accept the risks of being stuck on an old version or <em>eventually
follow major version upgrades to your dependencies</em>.<a data-primary="cargo update" data-type="indexterm" id="OEBPS/ch04.html.id1448"></a><a data-primary="Dependabot" data-type="indexterm" id="OEBPS/ch04.html.id1449"></a>  Tools such as <code>cargo update</code> or
 <a class="orm:hideurl" href="https://docs.github.com/en/code-security/dependabot">Dependabot</a> (<a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a>) can let you know when updates are
available; you can then schedule the upgrade for a time that’s convenient for you.</p>
</div></section>








<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id109">
<h2>Discussion</h2>

<p>Semantic versioning has a cost: every change to a crate has to be assessed against its criteria, to decide the
appropriate type of version bump.<a data-primary="semantic versioning" data-secondary="understanding its concepts and limitations" data-type="indexterm" id="OEBPS/ch04.html.id1450"></a>  Semantic versioning is also a blunt tool: at best, it reflects a crate owner’s guess
as to which of three categories the current release falls into.  Not everyone gets it right, not everything is
clear-cut about exactly what “right” means, and even if you get it right, there’s always a chance you may fall foul of
Hyrum’s Law.<a data-primary="Hyrum's Law" data-type="indexterm" id="OEBPS/ch04.html.id1451"></a></p>

<p>However, semver is the only game in town for anyone who doesn’t have the luxury of working in an environment like
<a href="https://oreil.ly/i-WpN">Google’s highly tested gigantic internal monorepo</a>.  As such, understanding
its concepts and limitations is necessary for managing dependencies.<a data-primary="semantic versioning" data-startref="ix_semver" data-type="indexterm" id="OEBPS/ch04.html.id1452"></a></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 22: Minimize visibility" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_visibility_md">
<h1>Item 22: Minimize visibility</h1>

<p>Rust allows elements of the code to either be hidden from or exposed to other parts of the codebase.<a data-primary="visibility" data-type="indexterm" id="OEBPS/ch04.html.ix_visi"></a>  This Item
explores the mechanisms provided for this and suggests advice for where and when they should be used.</p>








<section data-pdf-bookmark="Visibility Syntax" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id111">
<h2>Visibility Syntax</h2>

<p>Rust’s basic unit of visibility is the  module.<a data-primary="visibility" data-secondary="syntax for" data-type="indexterm" id="OEBPS/ch04.html.id1453"></a><a data-primary="modules" data-type="indexterm" id="OEBPS/ch04.html.id1454"></a><a data-primary="private" data-type="indexterm" id="OEBPS/ch04.html.id1455"></a><a data-primary="types" data-secondary="visibility" data-type="indexterm" id="OEBPS/ch04.html.id1456"></a><a data-primary="methods" data-secondary="visibility" data-type="indexterm" id="OEBPS/ch04.html.id1457"></a><a data-primary="constants" data-type="indexterm" id="OEBPS/ch04.html.id1458"></a>  By default, a module’s items (types, methods, constants) are
<em>private</em> and accessible only to code in the same module and its submodules.</p>

<p>Code that needs to be more widely available is marked with the  <code>pub</code> keyword, making it public to some other scope.<a data-primary="pub" data-type="indexterm" id="OEBPS/ch04.html.id1459"></a>  For most Rust syntactic features, making the feature <code>pub</code> does not automatically expose the
<span class="keep-together">contents—</span>the types and functions in a <code>pub mod</code> are not public, nor are the fields in a <code>pub struct</code>.  However,
there are a couple of exceptions where applying the visibility to the contents makes sense:</p>

<ul>
<li>
<p>Making an <code>enum</code> public automatically makes the type’s variants public too (together with any fields that might
be present in those variants).<a data-primary="enums" data-secondary="making public" data-type="indexterm" id="OEBPS/ch04.html.id1460"></a></p>
</li>
<li>
<p>Making a <code>trait</code> public <a data-primary="traits" data-secondary="making public" data-type="indexterm" id="OEBPS/ch04.html.id1461"></a>automatically makes the trait’s methods public too.</p>
</li>
</ul>

<p>So a collection of types in a module:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">mod</code> <code class="nn">somemodule</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Making a `struct` public does not make its fields public.</code>
<code class="w">    </code><code class="cp">#[derive(Debug, Default)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">AStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// By default fields are inaccessible.</code>
<code class="w">        </code><code class="n">count</code>: <code class="kt">i32</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Fields have to be explicitly marked `pub` to be visible.</code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Likewise, methods on the struct need individual `pub` markers.</code>
<code class="w">    </code><code class="k">impl</code><code class="w"> </code><code class="n">AStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// By default methods are inaccessible.</code>
<code class="w">        </code><code class="k">fn</code> <code class="nf">canonical_name</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="bp">self</code><code class="p">.</code><code class="n">name</code><code class="p">.</code><code class="n">to_lowercase</code><code class="p">()</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Methods have to be explicitly marked `pub` to be visible.</code>
<code class="w">        </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">id</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="fm">format!</code><code class="p">(</code><code class="s">"{}-{}"</code><code class="p">,</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">canonical_name</code><code class="p">(),</code><code class="w"> </code><code class="bp">self</code><code class="p">.</code><code class="n">count</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Making an `enum` public also makes all of its variants public.</code>
<code class="w">    </code><code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">AnEnum</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">VariantOne</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Fields in variants are also made public.</code>
<code class="w">        </code><code class="n">VariantTwo</code><code class="p">(</code><code class="kt">u32</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="n">VariantThree</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code>: <code class="nb">String</code><code class="p">,</code><code class="w"> </code><code class="n">value</code>: <code class="nb">String</code> <code class="p">},</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Making a `trait` public also makes all of its methods public.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">DoSomething</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">fn</code> <code class="nf">do_something</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">arg</code>: <code class="kt">i32</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>allows access to <code>pub</code> things and the exceptions previously mentioned:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">somemodule</code>::<code class="o">*</code><code class="p">;</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">AStruct</code>::<code class="n">default</code><code class="p">();</code><code class="w"></code>
<code class="n">s</code><code class="p">.</code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Miles"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"s = {:?}, name='{}', id={}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">id</code><code class="p">());</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">e</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">AnEnum</code>::<code class="n">VariantTwo</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"e = {e:?}"</code><code class="p">);</code><code class="w"></code>

<code class="cp">#[derive(Default)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">DoesSomething</code><code class="p">;</code><code class="w"></code>
<code class="k">impl</code><code class="w"> </code><code class="n">DoSomething</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">DoesSomething</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">do_something</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">_arg</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code><code class="p">{}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">DoesSomething</code>::<code class="n">default</code><code class="p">();</code><code class="w"></code>
<code class="n">d</code><code class="p">.</code><code class="n">do_something</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"></code></pre>

<p>but non-<code>pub</code> things are generally inaccessible:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">AStruct</code>::<code class="n">default</code><code class="p">();</code><code class="w"></code>
<code class="n">s</code><code class="p">.</code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Miles"</code><code class="p">.</code><code class="n">to_string</code><code class="p">();</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"(inaccessible) s.count={}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">count</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"(inaccessible) s.canonical_name()={}"</code><code class="p">,</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">canonical_name</code><code class="p">());</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">error[E0616]: field `count` of struct `somemodule::AStruct` is private
   --&gt; src/main.rs:230:45
    |
230 |     println!("(inaccessible) s.count={}", s.count);
    |                                             ^^^^^ private field
error[E0624]: method `canonical_name` is private
   --&gt; src/main.rs:231:56
    |
86  |         fn canonical_name(&amp;self) -&gt; String {
    |         ---------------------------------- private method defined here
...
231 |     println!("(inaccessible) s.canonical_name()={}", s.canonical_name());
    |                                         private method ^^^^^^^^^^^^^^
Some errors have detailed explanations: E0616, E0624.
For more information about an error, try `rustc --explain E0616`.</pre>

<p>The most common visibility marker is the bare <code>pub</code> keyword, which makes the item visible to anything that’s able to see
the module it’s in.  <a data-primary="pub" data-type="indexterm" id="OEBPS/ch04.html.id1462"></a><a data-primary="modules" data-secondary="pub contents" data-type="indexterm" id="OEBPS/ch04.html.id1463"></a>That last detail is important: if a <code>somecrate::somemodule</code> module isn’t visible to other code in
the first place, anything that’s <code>pub</code> inside it is still not visible.</p>

<p>However, there are also some more-specific variants of <code>pub</code> that allow the scope of the visibility to be constrained.
In descending order of usefulness, these are as follows:</p>
<dl>
<dt><code>pub(crate)</code></dt>
<dd>
<p>Accessible anywhere within the owning crate.<a data-primary="pub" data-secondary="pub(crate)" data-type="indexterm" id="OEBPS/ch04.html.id1464"></a><a data-primary="crates" data-secondary="pub(crate) visibility" data-type="indexterm" id="OEBPS/ch04.html.id1465"></a>  This is particularly useful for crate-wide
internal helper functions that should not be exposed to external crate users.</p>
</dd>
<dt><code>pub(super)</code></dt>
<dd>
<p>Accessible to the parent module of the current module and its submodules.  <a data-primary="pub" data-secondary="pub(super)" data-type="indexterm" id="OEBPS/ch04.html.id1466"></a>This is occasionally
useful for selectively increasing visibility in a crate that has a deep module structure. <a data-primary="modules" data-secondary="visibility" data-type="indexterm" id="OEBPS/ch04.html.id1467"></a>It’s also the effective
visibility level for modules: a plain <code>mod mymodule</code> is visible to its parent module or crate and the corresponding 
<span class="keep-together">submodules</span>.</p>
</dd>
<dt><code>pub(in &lt;path&gt;)</code></dt>
<dd>
<p>Accessible to code in <code>&lt;path&gt;</code>, which has to be a description of some ancestor module of the
current module.<a data-primary="pub" data-secondary="pub(in path)" data-type="indexterm" id="OEBPS/ch04.html.id1468"></a> This can occasionally be useful for organizing source code, because it allows subsets of functionality
to be moved into submodules that aren’t necessarily visible in the public API.
For example, the Rust standard library consolidates all of the iterator
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/iter/index.html#adapters">adapters</a> into <a class="orm:hideurl" href="https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html">an internal <code>std::iter::adapters</code> submodule</a> and has the following:</p>

<ul>
<li>
<p>A <code>pub(in crate::iter)</code> visibility marker<a data-primary="pub" data-secondary="pub(in crate)" data-type="indexterm" id="OEBPS/ch04.html.id1469"></a><a data-primary="adapters" data-type="indexterm" id="OEBPS/ch04.html.id1470"></a> on all of the required adapter methods in submodules, such as
<a href="https://oreil.ly/XbQGP"><code>std::iter::adapters::map::Map::new</code></a>.</p>
</li>
<li>
<p>A <code>pub use</code> of all of the <code>adapters::</code> types in <a href="https://oreil.ly/uLZ-d">the outer <code>std::iter</code> module</a>.</p>
</li>
</ul>
</dd>
<dt><code>pub(self)</code></dt>
<dd>
<p>Equivalent to <code>pub(in self)</code>, which is equivalent to not being <code>pub</code>.  Uses for this are<a data-primary="pub" data-secondary="pub(self)" data-type="indexterm" id="OEBPS/ch04.html.id1471"></a> very obscure,
such as reducing the number of special cases needed in code-generation  macros.</p>
</dd>
</dl>

<p>The Rust compiler will warn you if you have a code item that is private to the module but not used within that
module (and its submodules):</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">mod</code> <code class="nn">anothermodule</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Private function that is not used within its module.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">inaccessible_fn</code><code class="p">(</code><code class="n">x</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">i32</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">3</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Although the warning indicates that the code is “never used” in its owning module, in practice this warning often
indicates that code <em>can’t</em> be used from outside the module, because the visibility restrictions don’t allow it:</p>

<pre data-code-language="text" data-type="programlisting">warning: function `inaccessible_fn` is never used
  --&gt; src/main.rs:56:8
   |
56 |     fn inaccessible_fn(x: i32) -&gt; i32 {
   |        ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default</pre>
</div></section>








<section data-pdf-bookmark="Visibility Semantics" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id112">
<h2>Visibility Semantics</h2>

<p>Separate from the question of <em>how</em> to increase visibility is the question of <em>when</em> to do so.  <a data-primary="visibility" data-secondary="restricting" data-type="indexterm" id="OEBPS/ch04.html.id1472"></a>The generally
accepted answer to this is <em>as little as possible</em>, at least for any code that may possibly get used and reused in the
future.</p>

<p>The first reason for this advice is that visibility changes can be hard to undo.  Once a crate item is public, it can’t
be made private again without breaking any code that uses the crate, thus necessitating a  major
version bump (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>).  The converse is not true: moving a private item to be public generally needs only a minor
version bump and leaves crate users unaffected—read through <a href="https://oreil.ly/CkFWN">Rust’s API compatibility guidelines</a> and notice how many are
relevant only if there are  <code>pub</code> items in play.</p>

<p>A more important—but more subtle—reason to prefer privacy is that it keeps your options open.<a data-primary="private" data-secondary="preferring private code" data-type="indexterm" id="OEBPS/ch04.html.id1473"></a>  The more
things that are exposed, the more things there are that need to stay fixed for the future (absent an incompatible
change).  If you expose the internal implementation details of a data structure, a putative future change to use a more
efficient algorithm becomes a breaking change.  If you expose internal helper functions, it’s  inevitable that some external code will come to depend on the exact details of those functions.</p>

<p>Of course, this is a concern only for library code that potentially has multiple users and a long lifespan. But nothing
is as permanent as a temporary solution, and so it’s a good habit to fall into.</p>

<p>It’s also worth observing that this advice to restrict visibility is by no means unique to<a data-primary="API guidelines" data-type="indexterm" id="OEBPS/ch04.html.id1474"></a><a data-primary="struct types" data-secondary="private fields in" data-type="indexterm" id="OEBPS/ch04.html.id1475"></a> this Item or to Rust:</p>

<ul>
<li>
<p>The Rust <a href="https://oreil.ly/nSrkD">API guidelines</a> include this advice: <a class="orm:hideurl" href="https://rust-lang.github.io/api-guidelines/future-proofing.html#structs-have-private-fields-c-struct-private">structs should have private fields</a>.</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://www.oreilly.com/library/view/effective-java/9780134686097/"><em>Effective Java</em></a>, 3rd edition, (Addison-Wesley Professional)  has the following:</p>

<ul>
<li>
<p>Item 15: Minimize the accessibility of classes and members.<a data-primary="Effective Java (Bloch)" data-type="indexterm" id="OEBPS/ch04.html.id1476"></a><a data-primary="Bloch, Joshua" data-type="indexterm" id="OEBPS/ch04.html.id1477"></a><a data-primary="Java" data-secondary="visibility guidelines" data-type="indexterm" id="OEBPS/ch04.html.id1478"></a></p>
</li>
<li>
<p>Item 16: In public classes, use accessor methods, not public fields.</p>
</li>
</ul>
</li>
<li>
<p><em>Effective C++</em> by Scott Meyers (Addison-Wesley Professional)
has the following in its second edition:</p>

<ul>
<li>
<p>Item 18: Strive for class interfaces that are complete and <em>minimal</em> (my italics).<a data-primary="Effective C++ (Meyers)" data-type="indexterm" id="OEBPS/ch04.html.id1479"></a><a data-primary="Meyers, Scott" data-type="indexterm" id="OEBPS/ch04.html.id1480"></a><a data-primary="C++" data-secondary="visibility guidelines" data-type="indexterm" id="OEBPS/ch04.html.id1481"></a></p>
</li>
<li>
<p>Item 20: Avoid data members in the public interface.<a data-primary="visibility" data-startref="ix_visi" data-type="indexterm" id="OEBPS/ch04.html.id1482"></a></p>
</li>
</ul>
</li>
</ul>
</div></section>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 23: Avoid wildcard imports" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_wildcard_md">
<h1>Item 23: Avoid wildcard imports</h1>

<p>Rust’s <code>use</code> statement pulls in a named item from another crate or module and makes that name available for
use in the local module’s code without qualification.<a data-primary="wildcard imports" data-type="indexterm" id="OEBPS/ch04.html.ix_wldimp"></a>  A  <em>wildcard import</em> (or <em>glob import</em>) of the form <code>use somecrate::module::*</code> says that <em>every</em> public symbol from that module should be added to the local namespace.<a data-primary="glob imports" data-seealso="wildcard imports" data-type="indexterm" id="OEBPS/ch04.html.id1483"></a><a data-primary="use statements" data-type="indexterm" id="OEBPS/ch04.html.id1484"></a><a data-primary="modules" data-secondary="wildcard imports of" data-type="indexterm" id="OEBPS/ch04.html.id1485"></a></p>

<p>As described in <a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>, an external crate may add new items to its API as part of a minor version upgrade; this is
considered a  backward-compatible change.<a data-primary="backward compatibility" data-type="indexterm" id="OEBPS/ch04.html.id1486"></a></p>

<p>The combination of these two observations raises the worry that a nonbreaking change to a dependency might break your
code: what happens if the dependency adds a new symbol that clashes with a name you’re already using?<a data-primary="dependencies" data-secondary="nonbreaking change causing compilation failure" data-type="indexterm" id="OEBPS/ch04.html.id1487"></a></p>

<p>At the simplest level, this turns out not to be a problem: the names in a wildcard import are treated as being lower
priority, so any matching<a data-primary="name clashes" data-type="indexterm" id="OEBPS/ch04.html.id1488"></a> names that are in your code take precedence:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">bytes</code>::<code class="o">*</code><code class="p">;</code><code class="w"></code>

<code class="c1">// Local `Bytes` type does not clash with `bytes::Bytes`.</code>
<code class="k">struct</code> <code class="nc">Bytes</code><code class="p">(</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">);</code><code class="w"></code></pre>

<p>Unfortunately, there are still cases where clashes can occur.  For example, consider the case when the dependency adds a
new trait and implements it for some type:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">trait</code><code class="w"> </code><code class="n">BytesLeft</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Name clashes with the `remaining` method on the wildcard-imported</code>
<code class="w">    </code><code class="c1">// `bytes::Buf` trait.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">remaining</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">BytesLeft</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="o">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Implementation clashes with `impl bytes::Buf for &amp;[u8]`.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">remaining</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">self</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>If any method names from the new trait c<a data-primary="wildcard imports" data-secondary="name clashes from" data-type="indexterm" id="OEBPS/ch04.html.id1489"></a>lash with existing method names that apply to the type, then the compiler
can no longer unambiguously figure out which method is intended:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch04.html.id1490">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">arr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="mi">1</code><code class="k">u8</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="k">u8</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="k">u8</code><code class="p">];</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">arr</code><code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="p">];</code><code class="w"></code>

<code class="fm">assert_eq!</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">remaining</code><code class="p">(),</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<p>as indicated by the compile-time error:</p>

<pre data-code-language="text" data-type="programlisting">error[E0034]: multiple applicable items in scope
  --&gt; src/main.rs:40:18
   |
40 |     assert_eq!(v.remaining(), 2);
   |                  ^^^^^^^^^ multiple `remaining` found
   |
note: candidate #1 is defined in an impl of the trait `BytesLeft` for the
      type `&amp;[u8]`
  --&gt; src/main.rs:18:5
   |
18 |     fn remaining(&amp;self) -&gt; usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: candidate #2 is defined in an impl of the trait `bytes::Buf` for the
           type `&amp;[u8]`
help: disambiguate the method for candidate #1
   |
40 |     assert_eq!(BytesLeft::remaining(&amp;v), 2);
   |                ~~~~~~~~~~~~~~~~~~~~~~~~
help: disambiguate the method for candidate #2
   |
40 |     assert_eq!(bytes::Buf::remaining(&amp;v), 2);
   |                ~~~~~~~~~~~~~~~~~~~~~~~~~</pre>

<p>As a result, you should <em>avoid wildcard imports from crates that you don’t control</em>.</p>

<p>If you do control the source of the wildcard import, then the previously mentioned concerns disappear.<a data-primary="wildcard imports" data-secondary="avoiding from crates you don't control" data-type="indexterm" id="OEBPS/ch04.html.id1491"></a><a data-primary="test modules" data-type="indexterm" id="OEBPS/ch04.html.id1492"></a><a data-primary="use statements" data-type="indexterm" id="OEBPS/ch04.html.id1493"></a>  For example, it’s common
for a <code>test</code> module to do <code>use super::*;</code>. It’s also possible for crates that use modules primarily as a way of dividing
up code to have a wildcard import from an internal module:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">mod</code> <code class="nn">thing</code><code class="p">;</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">use</code><code class="w"> </code><code class="n">thing</code>::<code class="o">*</code><code class="p">;</code><code class="w"></code></pre>

<p>However, there’s another common exception where wildcard imports make sense.  Some crates have a convention that common
items for the crate <a data-primary="prelude" data-type="indexterm" id="OEBPS/ch04.html.id1494"></a>are  re-exported from a  <em>prelude</em> module, which is explicitly intended to be wildcard
imported:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">thing</code>::<code class="n">prelude</code>::<code class="o">*</code><code class="p">;</code><code class="w"></code></pre>

<p>Although in theory the same concerns apply in this case, in practice such a prelude module is likely to be carefully
curated, and higher convenience may outweigh a small risk of future problems.</p>

<p>Finally, if you don’t follow the advice in this Item, <em>consider pinning dependencies that you wildcard import
to a precise version</em> (see <a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) so that minor version upgrades of the dependency aren’t automatically allowed.<a data-primary="dependencies" data-secondary="wildcard-imported, pinning to precise version" data-type="indexterm" id="OEBPS/ch04.html.id1495"></a><a data-primary="wildcard imports" data-startref="ix_wldimp" data-type="indexterm" id="OEBPS/ch04.html.id1496"></a></p>
</div></section>






<section data-pdf-bookmark="Item 24: Re-export dependencies whose types 
appear in your API" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_re-export_md">
<h1>Item 24: Re-export dependencies whose types 
<span class="keep-together">appear in your API</span></h1>

<p>The title of this Item<a data-primary="re-export" data-type="indexterm" id="OEBPS/ch04.html.ix_reex"></a><a data-primary="dependencies" data-secondary="re-exporting dependencies whose types appear in your API" data-type="indexterm" id="OEBPS/ch04.html.ix_depreex"></a><a data-primary="RustCrypto crates" data-type="indexterm" id="OEBPS/ch04.html.id1497"></a> is a little convoluted, but working through an example will make things clearer.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1498" id="OEBPS/ch04.html.id1498-marker">3</a></sup></p>

<p><a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a> describes how  <code>cargo</code> supports different versions of the same library crate being linked into a
single binary, in a transparent manner.<a data-primary="Cargo" data-secondary="supporting different versions of library crate linked into single binary" data-type="indexterm" id="OEBPS/ch04.html.id1499"></a>  Consider a binary that uses the  <a class="orm:hideurl" href="https://docs.rs/rand"><code>rand</code></a> crate—more specifically, one that uses some 0.8 version of the crate:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="c1"># Cargo.toml file for a top-level binary crate.</code><code class="w"></code>
<code class="k">[dependencies]</code><code class="w"></code>
<code class="c1"># The binary depends on the `rand` crate from crates.io</code><code class="w"></code>
<code class="n">rand</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"=0.8.5"</code><code class="w"></code>

<code class="c1"># It also depends on some other crate (`dep-lib`).</code><code class="w"></code>
<code class="n">dep-lib</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1.0"</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Source code:</code>
<code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">rng</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rand</code>::<code class="n">thread_rng</code><code class="p">();</code><code class="w"> </code><code class="c1">// rand 0.8</code>
<code class="kd">let</code><code class="w"> </code><code class="n">max</code>: <code class="kt">usize</code> <code class="o">=</code><code class="w"> </code><code class="n">rng</code><code class="p">.</code><code class="n">gen_range</code><code class="p">(</code><code class="mi">5</code><code class="o">..</code><code class="mi">10</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">choice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dep_lib</code>::<code class="n">pick_number</code><code class="p">(</code><code class="n">max</code><code class="p">);</code><code class="w"></code></pre>

<p>The final line of code also uses a notional <code>dep-lib</code> crate as another dependency.  <a data-primary="rand crate" data-type="indexterm" id="OEBPS/ch04.html.id1500"></a>This crate might be another
crate from <code>crates.io</code>, or it could be a local crate that is located via Cargo’s <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> mechanism</a>.</p>

<p>This <code>dep-lib</code> crate internally uses a 0.7 version of the <code>rand</code> crate:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="c1"># Cargo.toml file for the `dep-lib` library crate.</code><code class="w"></code>
<code class="k">[dependencies]</code><code class="w"></code>
<code class="c1"># The library depends on the `rand` crate from crates.io</code><code class="w"></code>
<code class="n">rand</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"=0.7.3"</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Source code:</code>
<code class="sd">//! The `dep-lib` crate provides number picking functionality.</code>
<code class="k">use</code><code class="w"> </code><code class="n">rand</code>::<code class="n">Rng</code><code class="p">;</code><code class="w"></code>

<code class="sd">/// Pick a number between 0 and n (exclusive).</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pick_number</code><code class="p">(</code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">rand</code>::<code class="n">thread_rng</code><code class="p">().</code><code class="n">gen_range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">n</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>An eagle-eyed reader might notice a difference between the two code examples:</p>

<ul>
<li>
<p>In version 0.7.x of <code>rand</code> (as used by the <code>dep-lib</code> library crate), the
<a class="orm:hideurl" href="https://docs.rs/rand/0.7.3/rand/trait.Rng.html#method.gen_range"><code>rand::gen_range()</code></a> method takes two
parameters, <code>low</code> and <code>high</code>.</p>
</li>
<li>
<p>In version 0.8.x of <code>rand</code> (as used by the binary crate), the
<a class="orm:hideurl" href="https://docs.rs/rand/0.8.5/rand/trait.Rng.html#method.gen_range"><code>rand::gen_range()</code></a> method takes a single
parameter <code>range</code>.</p>
</li>
</ul>

<p>This is not a back-compatible change, and so <code>rand</code> has increased its leftmost version component
accordingly, as required by  semantic versioning (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>).  Nevertheless, the binary that combines the two
incompatible versions works just fine—<code>cargo</code> sorts everything out.</p>

<p>However, things get a lot more awkward if the <code>dep-lib</code> library crate’s API exposes a type from its dependency, making
that dependency a <a href="https://oreil.ly/yAm3Y"><em>public dependency</em></a>.</p>

<p>For example, suppose that the <code>dep-lib</code> entrypoint involves an <code>Rng</code> item—but specifically a version-0.7 <code>Rng</code>
item:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Pick a number between 0 and n (exclusive) using</code>
<code class="sd">/// the provided `Rng` instance.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pick_number_with</code><code class="o">&lt;</code><code class="n">R</code>: <code class="nc">Rng</code><code class="o">&gt;</code><code class="p">(</code><code class="n">rng</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">R</code><code class="p">,</code><code class="w"> </code><code class="n">n</code>: <code class="kt">usize</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">usize</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">rng</code><code class="p">.</code><code class="n">gen_range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">n</code><code class="p">)</code><code class="w"> </code><code class="c1">// Method from the 0.7.x version of Rng</code>
<code class="p">}</code><code class="w"></code></pre>

<p>As an aside, <em>think carefully before using another crate’s types in your API</em>: it intimately ties your crate
to that of the dependency.<a data-primary="crates" data-secondary="caution with use of another crate's types in your API" data-type="indexterm" id="OEBPS/ch04.html.id1501"></a>  For example, a major version bump for the dependency (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) will automatically require a
major version bump for your crate too.</p>

<p>In this case, <code>rand</code> is a semi-standard crate that is widely used and pulls in only a small number of
dependencies of its own (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>), so including its types in the crate API is probably fine on balance.</p>

<p>Returning to the example, an attempt to use this entrypoint from the top-level binary fails:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch04.html.id1502">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">rng</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">rand</code>::<code class="n">thread_rng</code><code class="p">();</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">max</code>: <code class="kt">usize</code> <code class="o">=</code><code class="w"> </code><code class="n">rng</code><code class="p">.</code><code class="n">gen_range</code><code class="p">(</code><code class="mi">5</code><code class="o">..</code><code class="mi">10</code><code class="p">);</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">choice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dep_lib</code>::<code class="n">pick_number_with</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">rng</code><code class="p">,</code><code class="w"> </code><code class="n">max</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<p>Unusually for Rust, the compiler error message isn’t <a class="orm:hideurl" href="https://github.com/rust-lang/rust/issues/22750">very helpful</a>:</p>

<pre data-code-language="text" data-type="programlisting">error[E0277]: the trait bound `ThreadRng: rand_core::RngCore` is not satisfied
  --&gt; src/main.rs:22:44
   |
22 |     let choice = dep_lib::pick_number_with(&amp;mut rng, max);
   |                  ------------------------- ^^^^^^^^ the trait
   |                  |                `rand_core::RngCore` is not
   |                  |                 implemented for `ThreadRng`
   |                  |
   |                  required by a bound introduced by this call
   |
   = help: the following other types implement trait `rand_core::RngCore`:
             &amp;'a mut R</pre>

<p>Investigating the types involved leads to confusion because the relevant traits do <em>appear</em> to be implemented—but
the caller actually implements a (notional) <code>RngCore_v0_8_5</code> and the library is expecting an implementation of
<code>RngCore_v0_7_3</code>.</p>

<p>Once you’ve finally deciphered the error message and realized that the version clash is the underlying cause, how can you fix it?<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1503" id="OEBPS/ch04.html.id1503-marker">4</a></sup> <a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch04.html.id1504"></a>The key
observation is to realize that while the binary can’t <em>directly</em> use two different versions of the same crate, it
can do so <em>indirectly</em> (as in the original example shown previously).</p>

<p>From the perspective of the binary author, the problem could be worked around by adding an intermediate wrapper crate
that hides the naked use of <code>rand</code> v0.7 types. A wrapper crate is distinct from the binary crate and so is allowed to
depend on <code>rand</code> v0.7 separately from the binary crate’s dependency on <code>rand</code> v0.8.</p>

<p>This is awkward, and a much better approach is available to the author of the library crate. It can make life easier for
its users by explicitly
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/items/use-declarations.html#use-visibility">re-exporting</a> either of the 
<span class="keep-together">following</span>:</p>

<ul>
<li>
<p>The types involved in the API</p>
</li>
<li>
<p>The entire dependency crate</p>
</li>
</ul>

<p>For this example, the latter approach works best: as well as making the version 0.7 <code>Rng</code> and <code>RngCore</code> types available,
it also makes available the methods (like <code>thread_rng()</code>) that construct instances of the type:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Re-export the version of `rand` used in this crate's API.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">use</code><code class="w"> </code><code class="n">rand</code><code class="p">;</code><code class="w"></code></pre>

<p>The calling code now has a different way to directly refer to version 0.7 of <code>rand</code>, as <code>dep_lib::rand</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">prev_rng</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dep_lib</code>::<code class="n">rand</code>::<code class="n">thread_rng</code><code class="p">();</code><code class="w"> </code><code class="c1">// v0.7 Rng instance</code>
<code class="kd">let</code><code class="w"> </code><code class="n">choice</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dep_lib</code>::<code class="n">pick_number_with</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">prev_rng</code><code class="p">,</code><code class="w"> </code><code class="n">max</code><code class="p">);</code><code class="w"></code></pre>

<p>With this example in mind, the advice given in the title of the Item should now be a little less obscure: <em>re-export dependencies
whose types appear in your API</em>.<a data-primary="re-export" data-startref="ix_reex" data-type="indexterm" id="OEBPS/ch04.html.id1505"></a><a data-primary="dependencies" data-secondary="re-exporting dependencies whose types appear in your" data-startref="ix_depreex" data-type="indexterm" id="OEBPS/ch04.html.id1506"></a></p>
</div></section>






<section data-pdf-bookmark="Item 25: Manage your dependency graph" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_dep-graph_md">
<h1>Item 25: Manage your dependency graph</h1>

<p>Like most modern programming languages, Rust makes it easy to pull in external libraries, in the form of <em>crates</em>. <a data-primary="dependency graph" data-type="indexterm" id="OEBPS/ch04.html.ix_depgrp"></a> Most
nontrivial Rust programs use external crates, and those crates may themselves have additional dependencies,
forming a  <em>dependency graph</em> for the program as a whole.<a data-primary="libraries" data-secondary="crates" data-type="indexterm" id="OEBPS/ch04.html.id1507"></a><a data-primary="crates" data-type="indexterm" id="OEBPS/ch04.html.id1508"></a></p>

<p>By default,  <a data-primary="Cargo.toml file" data-type="indexterm" id="OEBPS/ch04.html.id1509"></a>Cargo will download any crates named in the <code>[dependencies]</code> section of your  <em>Cargo.toml</em> file
from <a class="orm:hideurl" href="https://crates.io"><code>crates.io</code></a> and find versions of those crates that match the requirements configured in
<em>Cargo.toml</em>.</p>

<p>A few subtleties lurk underneath this simple statement.<a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch04.html.id1510"></a><a data-primary="features" data-type="indexterm" id="OEBPS/ch04.html.id1511"></a>  The first thing to notice is that crate names from
<code>crates.io</code> form a single flat namespace—and this global namespace also overlaps with the names of
 <em>features</em> in a crate (see <a href="#OEBPS/ch04.html.file_features_md">Item 26</a>).<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1512" id="OEBPS/ch04.html.id1512-marker">5</a></sup></p>

<p>If you’re planning on <em>publishing</em> a crate on <code>crates.io</code>, be aware that names are generally allocated on a first-come,
first-served basis; so you may find that your preferred name for a public crate is already taken.<a data-primary="crates.io" data-secondary="names for crates published on" data-type="indexterm" id="OEBPS/ch04.html.id1513"></a>  However,
name-squatting—reserving a crate name by preregistering an empty crate—is <a href="https://oreil.ly/ArljK">frowned upon</a>, unless you really are going to release code
in the near future.</p>

<p>As a minor wrinkle, there’s also a slight difference between what’s allowed as a crate name in the crates namespace and
what’s allowed as an identifier in code: a crate can be named <code>some-crate</code>, but it will appear in code as <code>some_crate</code>
(with an underscore).  To put it another way: if you see <code>some_crate</code> in code, the corresponding crate name may be
either <code>some-crate</code> or <code>some_crate</code>.</p>

<p>The second subtlety to understand is that Cargo allows multiple semver-incompatible versions of the same crate to be
present in the build.<a data-primary="semantic versioning" data-secondary="multiple semver-incompatible versions of a crate in the build" data-type="indexterm" id="OEBPS/ch04.html.id1514"></a><a data-primary="dependencies" data-secondary="indirect" data-type="indexterm" id="OEBPS/ch04.html.id1515"></a><a data-primary="Cargo" data-secondary="allowing multiple versions of a crate in a build" data-type="indexterm" id="OEBPS/ch04.html.id1516"></a>  This can seem surprising to begin with, because each <em>Cargo.toml</em> file can have only a single
version of any given dependency, but the situation frequently arises with indirect dependencies: your crate depends on
<code>some-crate</code> version 3.x but also depends on <code>older-crate</code>, which in turn depends on <code>some-crate</code> version 1.x.</p>

<p>This can lead to confusion if the dependency is exposed in some way rather than just being used internally (<a href="#OEBPS/ch04.html.file_re-export_md">Item 24</a>)—the compiler will treat the two versions as being distinct crates, but its error messages won’t necessarily
make that clear.</p>

<p>Allowing multiple versions of a crate can also go wrong if the crate includes  C/C++ code accessed via Rust’s
 FFI mechanisms (<a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>). <a data-primary="C++" data-secondary="one definition rule for C/C++ code accessed via Rust's  FFI" data-type="indexterm" id="OEBPS/ch04.html.id1517"></a><a data-primary="FFI (foreign-function interface)" data-type="indexterm" id="OEBPS/ch04.html.id1518"></a><a data-primary="foreign function interface" data-see="FFI" data-type="indexterm" id="OEBPS/ch04.html.id1519"></a>The Rust toolchain can internally disambiguate distinct versions of Rust code, but any
included C/C++ code is subject to the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/One_Definition_Rule"><em>one definition rule</em></a>: there can be only a single version of any function, constant,
or global variable.<a data-primary="one definition rule" data-type="indexterm" id="OEBPS/ch04.html.id1520"></a></p>

<p>There are restrictions on Cargo’s multiple-version support.<a data-primary="Cargo" data-secondary="restrictions in multiple-version support" data-type="indexterm" id="OEBPS/ch04.html.id1521"></a><a data-primary="semantic versioning" data-secondary="Cargo and" data-type="indexterm" id="OEBPS/ch04.html.id1522"></a>  Cargo does <em>not</em> allow multiple versions of the same
crate within a semver-compatible range (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>):</p>

<ul>
<li>
<p><code>some-crate</code> 1.2 and <code>some-crate</code> 3.1 can coexist</p>
</li>
<li>
<p><code>some-crate</code> 1.2 and <code>some-crate</code> 1.3 cannot</p>
</li>
</ul>

<p>Cargo also extends the semantic versioning rules for pre-1.0 crates so that the first
non-zero subversion counts like a major version, so a similar constraint applies:</p>

<ul>
<li>
<p><code>other-crate</code> 0.1.2 and <code>other-crate</code> 0.2.0 can coexist</p>
</li>
<li>
<p><code>other-crate</code> 0.1.2 and <code>other-crate</code> 0.1.4 cannot</p>
</li>
</ul>

<p>Cargo’s <a href="https://oreil.ly/qIxXh">version selection algorithm</a> does the job of figuring
out what versions to include.<a data-primary="version selection algorithm (Cargo)" data-type="indexterm" id="OEBPS/ch04.html.id1523"></a><a data-primary="Cargo" data-secondary="version selection algorithm" data-type="indexterm" id="OEBPS/ch04.html.id1524"></a>  Each <em>Cargo.toml</em> dependency line specifies an acceptable range of versions, according to
semantic versioning rules, and Cargo takes this into account when the same crate appears in multiple places in the
dependency graph.  If the acceptable ranges overlap and are  semver-compatible, then Cargo will
(by default) pick the most recent version of the crate within the overlap.  If there is no semver-compatible overlap,
then Cargo will build multiple copies of the dependency at different versions.</p>

<p>Once Cargo has picked acceptable versions for all dependencies, its choices are recorded in the  <em>Cargo.lock</em> file.<a data-primary="Cargo.lock file" data-type="indexterm" id="OEBPS/ch04.html.id1525"></a>
Subsequent builds will then reuse the choices encoded in <em>Cargo.lock</em> so that the build is stable and no new downloads
are needed.</p>

<p>This leaves you with a choice: should you commit your <em>Cargo.lock</em> files into version control or not?<a data-primary="version control, Cargo.lock file" data-type="indexterm" id="OEBPS/ch04.html.id1526"></a> The <a href="https://oreil.ly/pppkQ">advice from the Cargo developers</a>
is as <span class="keep-together">follows</span>:</p>

<ul>
<li>
<p>Things that produce a final product, namely applications and binaries, should commit <em>Cargo.lock</em> to ensure a
deterministic build.</p>
</li>
<li>
<p>Library crates should <em>not</em> commit a <em>Cargo.lock</em> file, because it’s irrelevant to any downstream consumers of the
library—they will have their own <em>Cargo.lock</em> file; <em>be aware that the Cargo.lock file for a
library crate is ignored by library users</em>.</p>
</li>
</ul>

<p>Even for a library crate, it can be helpful to have a checked-in <em>Cargo.lock</em> file to ensure that regular builds and
 CI (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) don’t have a moving target.  Although the promises of  semantic versioning
(<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) should prevent failures in theory, mistakes happen in practice, and it’s frustrating to have builds that fail
because someone somewhere recently changed a dependency of a dependency.</p>

<p>However, <em>if you version-control Cargo.lock, set up a process to handle upgrades</em> (such as GitHub’s
 <a class="orm:hideurl" href="https://docs.github.com/en/code-security/dependabot">Dependabot</a>). If you don’t, your dependencies will stay
pinned to versions that get older, outdated, and potentially insecure.<a data-primary="Dependabot" data-type="indexterm" id="OEBPS/ch04.html.id1527"></a><a data-primary="dependency upgrades" data-type="indexterm" id="OEBPS/ch04.html.id1528"></a></p>

<p>Pinning versions with a checked-in <em>Cargo.lock</em> file doesn’t avoid the pain of handling dependency upgrades, but it does
mean that you can handle them at a time of your own choosing, rather than immediately when the upstream crate
changes. There’s also some fraction of dependency-upgrade problems that go away on their own: a crate that’s released
with a problem often gets a second, fixed, version released in a short space of time, and a batched upgrade process
might see only the latter version.</p>

<p>The third subtlety of Cargo’s resolution<a data-primary="feature unification" data-type="indexterm" id="OEBPS/ch04.html.id1529"></a><a data-primary="union" data-type="indexterm" id="OEBPS/ch04.html.id1530"></a> process to be aware of is  <em>feature unification</em>: the features that get
activated for a dependent crate are the <em>union</em> of the features selected by different places in the dependency graph;
see <a href="#OEBPS/ch04.html.file_features_md">Item 26</a> for more details.</p>








<section data-pdf-bookmark="Version Specification" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id116">
<h2>Version Specification</h2>

<p>The version specification clause for a dependency defines a<a data-primary="version specification (dependencies)" data-type="indexterm" id="OEBPS/ch04.html.id1531"></a><a data-primary="semantic versioning" data-secondary="version specification for dependencies" data-type="indexterm" id="OEBPS/ch04.html.id1532"></a> range of allowed versions, according to the
<a href="https://oreil.ly/9YHm-">rules explained in the Cargo book</a>:</p>
<dl>
<dt><em>Avoid a too-specific version dependency</em></dt>
<dd>
<p>Pinning to a specific version (<code>"=1.2.3"</code>) is <em>usually</em> a bad
idea: you don’t see newer versions (potentially including security fixes), and you dramatically narrow the potential
overlap range with other crates in the graph that rely on the same dependency (recall that Cargo allows only a single
version of a crate to be used within a semver-compatible range). If you want to ensure that your builds use a consistent set of dependencies, the <em>Cargo.lock</em> file is the tool for
the job.</p>
</dd>
<dt><em>Avoid a too-general version dependency</em></dt>
<dd>
<p>It’s <em>possible</em> to specify a version dependency (<code>"*"</code>) that
allows <em>any</em> version of the dependency to be used, but it’s a bad idea.  If the dependency releases a new major
version of the crate that completely changes every aspect of its API, it’s unlikely that your code will
still work after a <code>cargo update</code> pulls in the new 
<span class="keep-together">version</span>.<a data-primary="cargo update" data-type="indexterm" id="OEBPS/ch04.html.id1533"></a></p>
</dd>
</dl>

<p>The most<a data-primary="Goldilocks version specification (dependencies)" data-type="indexterm" id="OEBPS/ch04.html.id1534"></a> common Goldilocks specification—not too precise, not too vague—is to allow semver-compatible
versions (<code>"1"</code>) of a crate, possibly with a specific minimum version that includes a feature or fix that you require
(<code>"1.4.23"</code>). Both of these version specifications make use of <a data-primary="Cargo" data-type="indexterm" id="OEBPS/ch04.html.id1535"></a>Cargo’s default behavior, which is to allow versions
that are semver-compatible with the specified version.  You can make this more explicit by adding a caret:</p>

<ul>
<li>
<p>A version of <code>"1"</code> is equivalent to <code>"^1"</code>, which allows all 1.x versions (and so is also equivalent to <code>"1.*"</code>).</p>
</li>
<li>
<p>A version of <code>"1.4.23"</code> is equivalent to <code>"^1.4.23"</code>, which allows any 1.x versions that are larger than
1.4.23.</p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Solving Problems with Tooling" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id117">
<h2>Solving Problems with Tooling</h2>

<p><a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a> recommends that you take advantage of the range of tools that are available within the Rust ecosystem.<a data-primary="dependency graph" data-secondary="solving problems with tooling" data-type="indexterm" id="OEBPS/ch04.html.id1536"></a>  This
section describes some dependency graph problems where tools can help.</p>

<p>The compiler will tell you pretty quickly if you use a dependency in your code but don’t include that dependency in
<em>Cargo.toml</em>.  <a data-primary="Cargo.toml file" data-type="indexterm" id="OEBPS/ch04.html.id1537"></a>But what about the other way around?  If there’s a dependency in <em>Cargo.toml</em> that you <em>don’t</em> use in
your code—or more likely, <em>no longer</em> use in your code—then Cargo will go on with its business.  The
 <a class="orm:hideurl" href="https://crates.io/crates/cargo-udeps"><code>cargo-udeps</code></a> tool is designed to solve exactly this problem: it warns you
when your <em>Cargo.toml</em> includes an unused dependency (“udep”).<a data-primary="cargo-udeps" data-type="indexterm" id="OEBPS/ch04.html.id1538"></a></p>

<p>A more versatile tool is  <a class="orm:hideurl" href="https://crates.io/crates/cargo-deny"><code>cargo-deny</code></a>, which analyzes your dependency graph
to detect a variety of<a data-primary="cargo-deny" data-type="indexterm" id="OEBPS/ch04.html.id1539"></a> potential problems across the full set of transitive dependencies:</p>

<ul>
<li>
<p>Dependencies that have known security problems in the included version</p>
</li>
<li>
<p>Dependencies that are covered by an unacceptable  license</p>
</li>
<li>
<p>Dependencies that are just unacceptable</p>
</li>
<li>
<p>Dependencies that are included in multiple different versions across the dependency tree</p>
</li>
</ul>

<p>Each of these features can be configured and can have exceptions specified.  The exception mechanism is usually needed
for larger projects, particularly the multiple-version warning: as the dependency graph grows, so does the chance of
transitively depending on different versions of the same crate.  It’s worth trying to reduce these duplicates where
possible—for binary-size and compilation-time reasons if nothing else—but sometimes there is no possible
combination of dependency versions that can avoid a duplicate.</p>

<p>These tools can be run as a one-off, but it’s better to ensure they’re executed regularly and reliably by including them
in your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>).  <a data-primary="continuous integration" data-type="indexterm" id="OEBPS/ch04.html.id1540"></a>This helps to catch newly introduced problems—including
problems that may have been introduced outside of your code, in an upstream dependency (for example, a newly reported
vulnerability).</p>

<p>If one of these tools does report a problem, it can be difficult to figure out exactly where in the dependency graph the
problem arises.<a data-primary="cargo tree" data-type="indexterm" id="OEBPS/ch04.html.id1541"></a>  The  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html"><code>cargo tree</code></a> command
that’s included with <code>cargo</code> helps here, as it shows the dependency graph as a tree structure:</p>

<pre data-code-language="text" data-type="programlisting">dep-graph v0.1.0
├── dep-lib v0.1.0
│   └── rand v0.7.3
│       ├── getrandom v0.1.16
│       │   ├── cfg-if v1.0.0
│       │   └── libc v0.2.94
│       ├── libc v0.2.94
│       ├── rand_chacha v0.2.2
│       │   ├── ppv-lite86 v0.2.10
│       │   └── rand_core v0.5.1
│       │       └── getrandom v0.1.16 (*)
│       └── rand_core v0.5.1 (*)
└── rand v0.8.3
    ├── libc v0.2.94
    ├── rand_chacha v0.3.0
    │   ├── ppv-lite86 v0.2.10
    │   └── rand_core v0.6.2
    │       └── getrandom v0.2.3
    │           ├── cfg-if v1.0.0
    │           └── libc v0.2.94
    └── rand_core v0.6.2 (*)</pre>

<p><code>cargo tree</code> includes a variety of options <a data-primary="cargo tree" data-type="indexterm" id="OEBPS/ch04.html.id1542"></a>that can help to solve specific problems, such as these:</p>
<dl>
<dt><code>--invert</code></dt>
<dd>
<p>Shows what depends <em>on</em> a specific package, helping you to focus on a particular problematic dependency</p>
</dd>
<dt><code>--edges features</code></dt>
<dd>
<p>Shows what crate features are activated by a dependency link, which helps you figure out what’s
going on with feature unification (<a href="#OEBPS/ch04.html.file_features_md">Item 26</a>)</p>
</dd>
<dt><code>--duplicates</code></dt>
<dd>
<p>Shows crates that have multiple versions present in the dependency graph</p>
</dd>
</dl>
</div></section>








<section data-pdf-bookmark="What to Depend On" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id118">
<h2>What to Depend On</h2>

<p>The previous sections have covered the more mechanical aspect of working with dependencies, but there’s a more
philosophical (and therefore harder-to-answer) question: when should you take on a dependency?<a data-primary="dependencies" data-secondary="deciding when to take on" data-type="indexterm" id="OEBPS/ch04.html.id1543"></a></p>

<p>Most of the time, there’s not much of a decision involved: if you need the functionality of a crate, you need that
function, and the only alternative would be to write it yourself.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1544" id="OEBPS/ch04.html.id1544-marker">6</a></sup></p>

<p>But every new dependency has a cost, partly in terms of longer builds and bigger binaries but mostly in terms of the
developer effort involved in fixing problems with dependencies when they arise.</p>

<p class="pagebreak-before less_space">The bigger your dependency graph, the more likely you are to be exposed to these kinds of problems.<a data-primary="crates" data-secondary="vulnerability to dependency problems" data-type="indexterm" id="OEBPS/ch04.html.id1545"></a>  The Rust crate
ecosystem is just as vulnerable to accidental dependency problems as other package ecosystems, where history has shown
that <a href="https://oreil.ly/8lTZ8">one developer removing a package</a>,
or a team <a href="https://oreil.ly/7HjSi">fixing the licensing for their package</a> can have
widespread knock-on effects.<a data-primary="licenses" data-type="indexterm" id="OEBPS/ch04.html.id1546"></a></p>

<p>More worrying still are  <a data-primary="supply chain attacks" data-type="indexterm" id="OEBPS/ch04.html.id1547"></a>supply chain attacks, where a malicious actor deliberately tries to subvert commonly used
dependencies, whether by <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Typosquatting">typo-squatting</a>, <a href="https://oreil.ly/b8D-f">hijacking a maintainer’s account</a>, or other more sophisticated attacks.</p>

<p>This kind of attack doesn’t <a data-primary="build scripts" data-secondary="dependency running arbitrary code during build" data-type="indexterm" id="OEBPS/ch04.html.id1548"></a>just affect your compiled code—be aware that a dependency can run arbitrary code at
<em>build</em> time, via  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> scripts or procedural
macros (<a href="#OEBPS/ch05.html.file_macros_md">Item 28</a>). That means that a compromised dependency could end up running a cryptocurrency miner as part of your
CI system!<a data-primary="continuous integration" data-type="indexterm" id="OEBPS/ch04.html.id1549"></a></p>

<p>So for dependencies that are more “cosmetic,” it’s sometimes worth considering whether adding the dependency is
worth the cost.</p>

<p>The answer is usually “yes,” though; in the end, the amount of time spent dealing with
dependency problems ends up being much less than the time it would take to write equivalent functionality from
scratch.</p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id119">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Crate names on <code>crates.io</code> form a single flat namespace (which is shared with feature names).<a data-primary="crates.io" data-secondary="names for crates published on" data-type="indexterm" id="OEBPS/ch04.html.id1550"></a></p>
</li>
<li>
<p>Crate names can include a hyphen, but it will appear as an underscore in code.</p>
</li>
<li>
<p>Cargo supports multiple versions<a data-primary="Cargo" data-type="indexterm" id="OEBPS/ch04.html.id1551"></a> of the same crate in the dependency graph, but only if they are of different
semver-incompatible versions. This can go wrong for crates that include FFI code.</p>
</li>
<li>
<p>Prefer to allow semver-compatible versions of dependencies (<code>"1"</code>, or <code>"1.4.23"</code> to include a minimum version).</p>
</li>
<li>
<p>Use <em>Cargo.lock</em> files to ensure your builds are repeatable, but remember that the <em>Cargo.lock</em> file does not ship
with a published crate.<a data-primary="Cargo.lock file" data-type="indexterm" id="OEBPS/ch04.html.id1552"></a></p>
</li>
<li>
<p>Use tooling (<code>cargo tree</code>, <code>cargo deny</code>, <code>cargo udep</code>, …) to help find and fix dependency problems.<a data-primary="cargo tree" data-type="indexterm" id="OEBPS/ch04.html.id1553"></a><a data-primary="cargo-deny" data-type="indexterm" id="OEBPS/ch04.html.id1554"></a><a data-primary="cargo-udeps" data-type="indexterm" id="OEBPS/ch04.html.id1555"></a></p>
</li>
<li>
<p>Understand that pulling in dependencies saves you writing code but doesn’t come for free.<a data-primary="dependency graph" data-startref="ix_depgrp" data-type="indexterm" id="OEBPS/ch04.html.id1556"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 26: Be wary of feature creep" data-type="sect1"><div class="sect1" id="OEBPS/ch04.html.file_features_md">
<h1>Item 26: Be wary of <code>feature</code> creep</h1>

<p>Rust allows the same codebase to support a variety of different configurations via Cargo’s  <em>feature</em> mechanism,
which is built on top of a lower-level mechanism for conditional compilation.  However, the feature mechanism has a few
subtleties to be aware of, which this Item explores.<a data-primary="features" data-type="indexterm" id="OEBPS/ch04.html.ix_featr"></a><a data-primary="conditional compilation" data-type="indexterm" id="OEBPS/ch04.html.id1557"></a></p>








<section data-pdf-bookmark="Conditional Compilation" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id121">
<h2>Conditional Compilation</h2>

<p>Rust includes support for  <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a>, which is controlled by
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> (and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>) attributes.<a data-primary="cfg attribute" data-type="indexterm" id="OEBPS/ch04.html.id1558"></a><a data-primary="cfg_attr attribute" data-type="indexterm" id="OEBPS/ch04.html.id1559"></a>
These attributes govern whether the thing—function, line, block, etc.—that they are attached to is
included in the compiled source code or not (which is in contrast to  C/C++’s line-based preprocessor).<a data-primary="C" data-secondary="line-based preprocessor" data-type="indexterm" id="OEBPS/ch04.html.id1560"></a><a data-primary="C++" data-secondary="line-based preprocessor" data-type="indexterm" id="OEBPS/ch04.html.id1561"></a>  The
conditional inclusion is controlled by configuration options that are either plain names (e.g., <code>test</code>) or pairs of names
and values (e.g., <code>panic = "abort"</code>).</p>

<p>Note that the name/value variants of config options <a data-primary="config options, name/value variants of" data-type="indexterm" id="OEBPS/ch04.html.id1562"></a>are multivalued—it’s possible to set more than one value
for the same name:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Build with `RUSTFLAGS` set to:</code>
<code class="c1">//   '--cfg myname="a" --cfg myname="b"'</code>
<code class="cp">#[cfg(myname = </code><code class="s">"a"</code><code class="cp">)]</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"cfg(myname = 'a') is set"</code><code class="p">);</code><code class="w"></code>
<code class="cp">#[cfg(myname = </code><code class="s">"b"</code><code class="cp">)]</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"cfg(myname = 'b') is set"</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">cfg(myname = 'a') is set
cfg(myname = 'b') is set</pre>

<p>Other than the <code>feature</code> values described in this section, the most commonly used config values are those that the toolchain
populates automatically, with values that describe the target environment for the build.<a data-primary="operating systems" data-secondary="target_os config value" data-type="indexterm" id="OEBPS/ch04.html.id1563"></a><a data-primary="target_arch config option" data-type="indexterm" id="OEBPS/ch04.html.id1564"></a><a data-primary="target_os config option" data-type="indexterm" id="OEBPS/ch04.html.id1565"></a>  These include the OS
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_os"><code>target_os</code></a>), CPU
architecture
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_arch"><code>target_arch</code></a>),
pointer width<a data-primary="target_pointer_width config option" data-type="indexterm" id="OEBPS/ch04.html.id1566"></a>
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_pointer_width"><code>target_pointer_width</code></a>),
and endianness
 (<a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_endian"><code>target_endian</code></a>).
This allows for code portability, where features that are specific to some particular target are compiled in only when
building for that target.<a data-primary="target_endian config option" data-type="indexterm" id="OEBPS/ch04.html.id1567"></a></p>

<p>The standard <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/conditional-compilation.html#target_has_atomic"><code>target_has_atomic</code></a>
option also provides an example of the multi-valued nature of config values: both <code>[cfg(target_has_atomic = "32")]</code> and
<code>[cfg(target_has_atomic = "64")]</code> will be set for targets that support both 32-bit and 64-bit atomic operations.<a data-primary="target_has_atomic config option" data-type="indexterm" id="OEBPS/ch04.html.id1568"></a><a data-primary="atomics" data-type="indexterm" id="OEBPS/ch04.html.id1569"></a><a data-primary="Bos, Mara" data-type="indexterm" id="OEBPS/ch04.html.id1570"></a><a data-primary="Rust Atomics and Locks (Bos)" data-type="indexterm" id="OEBPS/ch04.html.id1571"></a>  (For
more information on atomics, see Chapter 2 of  Mara Bos’s <a class="orm:hideurl" href="https://marabos.nl/atomics/"><em>Rust Atomics and Locks</em></a> [O’Reilly].)</p>
</div></section>








<section class="pagebreak-before less_space" data-pdf-bookmark="Features" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id122">
<h2>Features</h2>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/index.html">Cargo</a> package manager builds on this base <code>cfg</code> name/value
mechanism to provide the concept of
 <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/features.html"><em>features</em></a>: named selective aspects of the
functionality of a crate that can be enabled when building the crate.<a data-primary="features" data-secondary="defined" data-type="indexterm" id="OEBPS/ch04.html.id1572"></a><a data-primary="Cargo" data-secondary="feature activation" data-type="indexterm" id="OEBPS/ch04.html.id1573"></a>  Cargo ensures that the <code>feature</code> option is
populated with each of the configured values for each crate that it compiles, and the values are crate-specific.<a data-primary="feature option" data-type="indexterm" id="OEBPS/ch04.html.id1574"></a></p>

<p>This is Cargo-specific functionality: to the Rust compiler, <code>feature</code> is just another configuration option.</p>

<p>At the time of writing, the most reliable way to determine what features are available for a crate is to examine the
crate’s  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/manifest.html"><em>Cargo.toml</em></a> manifest file.  <a data-primary="Cargo.toml file" data-type="indexterm" id="OEBPS/ch04.html.id1575"></a>For
example, the following chunk of a manifest file includes <em>six</em> features:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[features]</code><code class="w"></code>
<code class="n">default</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"featureA"</code><code class="p">]</code><code class="w"></code>
<code class="n">featureA</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[]</code><code class="w"></code>
<code class="n">featureB</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[]</code><code class="w"></code>
<code class="c1"># Enabling `featureAB` also enables `featureA` and `featureB`.</code><code class="w"></code>
<code class="n">featureAB</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"featureA"</code><code class="p">,</code><code class="w"> </code><code class="s2">"featureB"</code><code class="p">]</code><code class="w"></code>
<code class="n">schema</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[]</code><code class="w"></code>

<code class="k">[dependencies]</code><code class="w"></code>
<code class="n">rand</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"^0.8"</code><code class="p">,</code><code class="w"> </code><code class="n">optional</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">true</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="n">hex</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"^0.4"</code><code class="w"></code></pre>

<p>Given that there are only five entries in the <code>[features]</code> stanza; there are clearly a couple of subtleties to watch out
for.</p>

<p>The first is that<a data-primary="default features" data-type="indexterm" id="OEBPS/ch04.html.id1576"></a> the  <code>default</code> line in the <code>[features]</code> stanza is a special feature name, used
to indicate to <code>cargo</code> which of the features should be enabled by default.  These features can still be disabled by
passing the <code>--no-default-features</code> flag to the <a data-primary="--no-default-features flag (build command)" data-primary-sortas="no-default" data-type="indexterm" id="OEBPS/ch04.html.id1577"></a>build command, and a consumer of the crate can encode this in their
<em>Cargo.toml</em> file like so:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[dependencies]</code><code class="w"></code>
<code class="n">somecrate</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"^0.3"</code><code class="p">,</code><code class="w"> </code><code class="n">default-features</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">false</code><code class="w"> </code><code class="p">}</code><code class="w"></code></pre>

<p>However, <code>default</code> still counts as a feature name, which can be tested in code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[cfg(feature = </code><code class="s">"default"</code><code class="cp">)]</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"This crate was built with the </code><code class="se">\"</code><code class="s">default</code><code class="se">\"</code><code class="s"> feature enabled."</code><code class="p">);</code><code class="w"></code>
<code class="cp">#[cfg(not(feature = </code><code class="s">"default"</code><code class="cp">))]</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"This crate was built with the </code><code class="se">\"</code><code class="s">default</code><code class="se">\"</code><code class="s"> feature disabled."</code><code class="p">);</code><code class="w"></code></pre>

<p>The second subtlety of feature <a data-primary="dependencies" data-secondary="dependencies section of Cargo.toml" data-type="indexterm" id="OEBPS/ch04.html.id1578"></a><a data-primary="Cargo.toml file" data-secondary="dependencies section" data-type="indexterm" id="OEBPS/ch04.html.id1579"></a>definitions is hidden in the <code>[dependencies]</code> section of the original <em>Cargo.toml</em>
example: the <code>rand</code> crate<a data-primary="rand crate" data-type="indexterm" id="OEBPS/ch04.html.id1580"></a> is a dependency that is marked as <code>optional = true</code>, and that effectively makes <code>"rand"</code> into
the name of a feature.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1581" id="OEBPS/ch04.html.id1581-marker">7</a></sup>  If the crate is compiled with <code>--features rand</code>, then that dependency is activated:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[cfg(feature = </code><code class="s">"rand"</code><code class="cp">)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pick_a_number</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kt">u8</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">rand</code>::<code class="n">random</code>::<code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="cp">#[cfg(not(feature = </code><code class="s">"rand"</code><code class="cp">))]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">pick_a_number</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="kt">u8</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="mi">4</code><code class="w"> </code><code class="c1">// chosen by fair dice roll.</code>
<code class="p">}</code><code class="w"></code></pre>

<p>This also means that <em>crate names and feature names share a namespace</em>, even though one <a data-primary="crates" data-secondary="crate names and feature names sharing namespace" data-type="indexterm" id="OEBPS/ch04.html.id1582"></a>is typically global (and usually
governed by <code>crates.io</code>), and one is local to the crate in question.  Consequently, <em>choose feature names
carefully</em> to avoid clashes with the names of any crates that might be relevant as potential dependencies.<a data-primary="crates.io" data-type="indexterm" id="OEBPS/ch04.html.id1583"></a><a data-primary="name clashes" data-secondary="crates and features" data-type="indexterm" id="OEBPS/ch04.html.id1584"></a> It is
possible to work around a clash, because Cargo includes a <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">mechanism that allows imported crates to be renamed</a> (the
<code>package</code> key), but it’s easier not to have to.</p>

<p>So you can <em>determine a crate’s features by examining <code>[features]</code></em> as well as <em><code>optional</code> <code>[dependencies]</code></em> in the crate’s
 <em>Cargo.toml</em> file.  <a data-primary="Cargo.toml file" data-secondary="determining crate's features in" data-type="indexterm" id="OEBPS/ch04.html.id1585"></a>To turn on a feature of a dependency, add the <code>features</code> option to the relevant line in the
<code>[dependencies]</code> stanza of your own manifest file:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[dependencies]</code><code class="w"></code>
<code class="n">somecrate</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"^0.3"</code><code class="p">,</code><code class="w"> </code><code class="n">features</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"featureA"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rand"</code><code class="w"> </code><code class="p">]</code><code class="w"> </code><code class="p">}</code><code class="w"></code></pre>

<p>This line ensures that <code>somecrate</code> will be built with both the <code>featureA</code> and the <code>rand</code> feature enabled.  However, that
might not be the only features that are enabled; other features may also be enabled due to a phenomenon known as
 <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/features.html#feature-unification"><em>feature unification</em></a>. This means that a crate will
get built with the <em>union</em> of all of the features that are requested by anything in the build graph.<a data-primary="union" data-type="indexterm" id="OEBPS/ch04.html.id1586"></a> In other words, if
some other dependency in the build graph also relies on <code>somecrate</code>, but with just <code>featureB</code> enabled, then the crate
will be built with all of <code>featureA</code>, <code>featureB</code>, and <code>rand</code> enabled, to satisfy everyone.<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1587" id="OEBPS/ch04.html.id1587-marker">8</a></sup>  The
same consideration applies to default features: if your crate sets <code>default-features = false</code> for a dependency but some
other place in the build graph leaves the default features enabled, then enabled they will be.<a data-primary="default features" data-type="indexterm" id="OEBPS/ch04.html.id1588"></a></p>

<p>Feature unification means that <em>features should be additive</em>; it’s a bad idea to have mutually incompatible features
because there’s nothing to prevent the incompatible features being simultaneously enabled by different users.<a data-primary="feature unification" data-type="indexterm" id="OEBPS/ch04.html.id1589"></a></p>

<p>For example, if a crate exposes a <code>struct</code> and its fields<a data-primary="struct types" data-secondary="contents made public, avoiding making fields feature-dependent" data-type="indexterm" id="OEBPS/ch04.html.id1590"></a> publicly, it’s a bad idea to make the fields
feature-dependent:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch04.html.id1591">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// A structure whose contents are public, so external users can construct</code>
<code class="sd">/// instances of it.</code>
<code class="cp">#[derive(Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">ExposedStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">data</code>: <code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"></code>

<code class="w">    </code><code class="sd">/// Additional data that is required only when the `schema` feature</code>
<code class="w">    </code><code class="sd">/// is enabled.</code>
<code class="w">    </code><code class="cp">#[cfg(feature = </code><code class="s">"schema"</code><code class="cp">)]</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">schema</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>A user of the crate that tries to build an instance of the <code>struct</code> has a quandary: should they fill in the <code>schema</code>
field or not?<a data-primary="Cargo.toml file" data-type="indexterm" id="OEBPS/ch04.html.id1592"></a>  One way to <em>try</em> to solve this is to add a corresponding feature in the user’s <em>Cargo.toml</em>:</p>

<pre data-code-language="toml" data-type="programlisting"><code class="k">[features]</code><code class="w"></code>
<code class="c1"># The `use-schema` feature here turns on the `schema` feature of `somecrate`.</code><code class="w"></code>
<code class="c1"># (This example uses different feature names for clarity; real code is more</code><code class="w"></code>
<code class="c1"># likely to reuse the feature names across both places.)</code><code class="w"></code>
<code class="n">use-schema</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"somecrate/schema"</code><code class="p">]</code><code class="w"></code></pre>

<p>and to make the <code>struct</code> construction depend on this feature:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch04.html.id1593">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">somecrate</code>::<code class="n">ExposedStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">data</code>: <code class="nc">vec</code><code class="o">!</code><code class="p">[</code><code class="mh">0x82</code><code class="p">,</code><code class="w"> </code><code class="mh">0x01</code><code class="p">,</code><code class="w"> </code><code class="mh">0x01</code><code class="p">],</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Only populate the field if we've requested</code>
<code class="w">    </code><code class="c1">// activation of `somecrate/schema`.</code>
<code class="w">    </code><code class="cp">#[cfg(feature = </code><code class="s">"use_schema"</code><code class="cp">)]</code><code class="w"></code>
<code class="w">    </code><code class="n">schema</code>: <code class="s">"[int int]"</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>
</div></aside>

<p>However, this doesn’t cover all eventualities: the code will fail to compile if this code doesn’t activate
<code>somecrate/schema</code> but some other transitive dependency does.  The core of the problem is that only the crate that has
the feature can check the feature; there’s no way for the user of the crate to determine whether Cargo has turned on
<code>somecrate/schema</code> or not. As a result, you should <em>avoid feature-gating public fields</em> in structures.<a data-primary="public fields in structures, avoiding feature-gating" data-type="indexterm" id="OEBPS/ch04.html.id1594"></a></p>

<p>A similar consideration applies to public traits, intended to be used outside the crate they’re defined in.<a data-primary="traits" data-secondary="public, with feature gate on a method" data-type="indexterm" id="OEBPS/ch04.html.id1595"></a>  Consider a
trait that includes a feature gate on one of its methods:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch04.html.id1596">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Trait for items that support CBOR serialization.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">trait</code><code class="w"> </code><code class="n">AsCbor</code>: <code class="nb">Sized</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="sd">/// Convert the item into CBOR-serialized data.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">serialize</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="sd">/// Create an instance of the item from CBOR-serialized data.</code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">deserialize</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="bp">Self</code><code class="p">,</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="sd">/// Return the schema corresponding to this item.</code>
<code class="w">    </code><code class="cp">#[cfg(feature = </code><code class="s">"schema"</code><code class="cp">)]</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">cddl</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">String</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>External trait implementors again have a quandary: should they implement the <code>cddl(&amp;self)</code> method or not?  The external
code that tries to implement the trait doesn’t know—and can’t tell—whether to implement the feature-gated
method or not.<a data-primary="methods" data-secondary="on public traits, avoiding feature-gating" data-secondary-sortas="public" data-type="indexterm" id="OEBPS/ch04.html.id1597"></a></p>

<p>So the net is that you should <em>avoid feature-gating methods on public traits</em>.  A trait method with a
default implementation (<a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>) might be a partial exception to this⁠—​but only if it never makes sense
for external code to override the default.</p>

<p>Feature unification also means that if your crate has <em>N</em> independent
features,<sup><a data-type="noteref" href="#OEBPS/ch04.html.id1598" id="OEBPS/ch04.html.id1598-marker">9</a></sup> then all of the 2<sup>N</sup> possible build combinations can occur in practice.  To avoid unpleasant
surprises, it’s a good idea to ensure that your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) covers all of these
2<sup>N</sup> combinations, in all of the available test variants (<a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>).</p>

<p>However, the use of optional features is very helpful in controlling exposure to an expanded dependency graph (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).  <a data-primary="dependency graph" data-secondary="expanded, controlling exposure to with optional features" data-type="indexterm" id="OEBPS/ch04.html.id1599"></a><a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch04.html.id1600"></a><a data-primary="std library" data-type="indexterm" id="OEBPS/ch04.html.id1601"></a><a data-primary="alloc library" data-type="indexterm" id="OEBPS/ch04.html.id1602"></a>This is particularly useful in low-level crates that are capable of being used in a  <code>no_std</code> environment
(<a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a>)—it’s common to have a <code>std</code> or <code>alloc</code> feature that turns on functionality that relies on those
libraries.</p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch04.html.id123">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Feature names overlap with dependency names.</p>
</li>
<li>
<p>Feature names should be carefully chosen so they don’t clash with potential dependency names.</p>
</li>
<li>
<p>Features should be additive.</p>
</li>
<li>
<p>Avoid feature gates on public <code>struct</code> fields or trait methods.</p>
</li>
<li>
<p>Having lots of independent features potentially leads to a combinatorial explosion of different build configurations.<a data-primary="features" data-startref="ix_featr" data-type="indexterm" id="OEBPS/ch04.html.id1603"></a></p>
</li>
</ul>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch04.html.id1413"><sup><a href="#OEBPS/ch04.html.id1413-marker">1</a></sup> With the notable exception of C and C++, where package management remains somewhat fragmented.</p><p data-type="footnote" id="OEBPS/ch04.html.id1440"><sup><a href="#OEBPS/ch04.html.id1440-marker">2</a></sup> For example,  <a class="orm:hideurl" href="https://github.com/obi1kenobi/cargo-semver-checks"><code>cargo-semver-checks</code></a> is a tool that attempts to do something along these lines.</p><p data-type="footnote" id="OEBPS/ch04.html.id1498"><sup><a href="#OEBPS/ch04.html.id1498-marker">3</a></sup> This example (and indeed Item) is inspired by the approach used in the  <a href="https://oreil.ly/7w1iF">RustCrypto crates</a>.</p><p data-type="footnote" id="OEBPS/ch04.html.id1503"><sup><a href="#OEBPS/ch04.html.id1503-marker">4</a></sup> This kind of error can even appear when<a data-primary="dependency graph" data-type="indexterm" id="OEBPS/ch04.html.id1604"></a> the dependency graph includes two alternatives for a crate with the <em>same version</em>, when something in the build graph uses the <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code></a> field to specify a local directory instead of a <code>crates.io</code> location.</p><p data-type="footnote" id="OEBPS/ch04.html.id1512"><sup><a href="#OEBPS/ch04.html.id1512-marker">5</a></sup> It’s also possible to configure an <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/registries.html">alternate registry</a> of crates (for example, an internal corporate registry).  <a data-primary="registry of crates" data-type="indexterm" id="OEBPS/ch04.html.id1605"></a>Each dependency entry in <em>Cargo.toml</em> can then use the <code>registry</code> key to indicate which registry a dependency should be sourced from.</p><p data-type="footnote" id="OEBPS/ch04.html.id1544"><sup><a href="#OEBPS/ch04.html.id1544-marker">6</a></sup> If you are <a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch04.html.id1606"></a><a data-primary="alloc library" data-type="indexterm" id="OEBPS/ch04.html.id1607"></a>targeting a <code>no_std</code> environment, this choice may be made for you: many crates are not compatible with <code>no_std</code>, particularly if <code>alloc</code> is also unavailable (<a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a>).</p><p data-type="footnote" id="OEBPS/ch04.html.id1581"><sup><a href="#OEBPS/ch04.html.id1581-marker">7</a></sup> This default behavior can be disabled by using a <code>"dep:&lt;crate&gt;"</code> reference elsewhere in the <code>features</code> stanza; see the <a href="https://oreil.ly/HnLOJ">docs</a> for details.</p><p data-type="footnote" id="OEBPS/ch04.html.id1587"><sup><a href="#OEBPS/ch04.html.id1587-marker">8</a></sup> The <code>cargo tree --edges features</code> command can help with determining which features are enabled for which crates, and why.</p><p data-type="footnote" id="OEBPS/ch04.html.id1598"><sup><a href="#OEBPS/ch04.html.id1598-marker">9</a></sup> Features can force other features to be enabled; in the original example, the <code>featureAB</code> feature forces both <code>featureA</code> and <code>featureB</code> to be enabled.</p></div></div></section></div></div>
<div id="OEBPS/ch05.html"><div data-type="book">
<section data-pdf-bookmark="Chapter 5. Tooling" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch05.html.file_tooling_md">
<h1><span class="label">Chapter 5. </span>Tooling</h1>


<p>Titus Winters (Google’s C++ library lead) describes  software engineering as programming
integrated over time, or sometimes as programming integrated over time and people.  Over longer timescales, and a wider
team, there’s more to a codebase than just the code held within it.<a data-primary="tooling" data-secondary="defined" data-type="indexterm" id="OEBPS/ch05.html.id1608"></a><a data-primary="Winters, Titus" data-type="indexterm" id="OEBPS/ch05.html.id1609"></a></p>

<p>Modern languages, including Rust, are aware of this and come with an ecosystem of tooling that goes way beyond just
converting the program into executable binary code (the compiler).</p>

<p>This chapter explores the Rust tooling ecosystem, with a general recommendation to make use of all of this
infrastructure.  Obviously, doing so needs to be proportionate—setting up CI, documentation builds, and six
types of test would be overkill for a throwaway program that is run only twice.  But for most of the things described
in this chapter, there’s lots of “bang for the buck”: a little bit of investment into tooling integration will yield
worthwhile benefits.</p>






<section data-pdf-bookmark="Item 27: Document public interfaces" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_documentation_md">
<h1>Item 27: Document public interfaces</h1>

<p>If your crate is going to be used by other programmers, then it’s a good idea to add documentation for its contents,
particularly its public API.<a data-primary="documentation" data-secondary="documenting public interfaces" data-type="indexterm" id="OEBPS/ch05.html.i_docu"></a>  If your crate is more than just ephemeral, throwaway code, then that “other programmer”
includes the you-of-the-future, when you have forgotten the details of your current code.<a data-primary="Effective Java (Bloch)" data-type="indexterm" id="OEBPS/ch05.html.id1610"></a><a data-primary="Bloch, Joshua" data-type="indexterm" id="OEBPS/ch05.html.id1611"></a><a data-primary="Java" data-type="indexterm" id="OEBPS/ch05.html.id1612"></a></p>

<p>This is not advice that’s specific to Rust, nor is it new advice—for example,  <a class="orm:hideurl" href="https://www.oreilly.com/library/view/effective-java-2nd/9780137150021/"><em>Effective Java</em></a> 2nd edition (from 2008) has Item 44:
“Write doc comments for all exposed API elements.”</p>

<p>The particulars of Rust’s documentation comment format—Markdown-based, delimited<a data-primary="comments, documentation" data-type="indexterm" id="OEBPS/ch05.html.id1613"></a><a data-primary="Markdown" data-type="indexterm" id="OEBPS/ch05.html.id1614"></a><a data-primary="documentation" data-secondary="documenting public interfaces" data-tertiary="Rust documentation comment format" data-type="indexterm" id="OEBPS/ch05.html.id1615"></a> with <code>///</code> or <code>//!</code>—are
covered in the <a href="https://oreil.ly/_WGEv">Rust book</a>, for
example:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Calculate the [`BoundingBox`] that exactly encompasses a pair</code>
<code class="sd">/// of [`BoundingBox`] objects.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">union</code><code class="p">(</code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">BoundingBox</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>However, there are some specific details about the format that are worth highlighting:</p>
<dl>
<dt><em>Use a code font for code</em></dt>
<dd>
<p>For anything that would be typed into source code as is, surround it with
back-quotes to ensure that the resulting documentation is in a fixed-width font, making the distinction between <code>code</code>
and text clear.<a data-primary="code, distinguishing from text" data-type="indexterm" id="OEBPS/ch05.html.id1616"></a></p>
</dd>
<dt><em>Add copious cross-references</em></dt>
<dd>
<p>Add a  Markdown link for anything that might provide context for
someone reading the documentation.<a data-primary="cross-references (in documentation)" data-type="indexterm" id="OEBPS/ch05.html.id1617"></a><a data-primary="cross-reference identifiers" data-type="indexterm" id="OEBPS/ch05.html.id1618"></a> In particular, <em>cross-reference identifiers</em> with the convenient
<code>[`SomeThing`]</code> syntax—if <code>SomeThing</code> is in scope, then the resulting documentation will hyperlink to the
right place.</p>
</dd>
<dt><em>Consider including example code</em></dt>
<dd>
<p>If it’s not trivially obvious how to use an entrypoint, adding an <code># Examples</code> section with  sample code can be helpful.<a data-primary="example code" data-type="indexterm" id="OEBPS/ch05.html.id1619"></a><a data-primary="cargo test" data-type="indexterm" id="OEBPS/ch05.html.id1620"></a>  Note that sample code in
<a class="orm:hideurl" href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">doc comments</a> gets compiled and
executed when you run <code>cargo test</code> (see <a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>), which helps it stay in sync with the code it’s demonstrating.</p>
</dd>
<dt><em>Document panics and <code>unsafe</code> constraints</em></dt>
<dd>
<p>If there are inputs that cause a function<a data-primary="panics" data-secondary="documenting" data-type="indexterm" id="OEBPS/ch05.html.id1621"></a> to panic, document (in
a <code># Panics</code> section) the preconditions that are required to avoid the  <code>panic!</code>.  <a data-primary="unsafe code" data-secondary="documenting" data-type="indexterm" id="OEBPS/ch05.html.id1622"></a>Similarly, document (in a <code># Safety</code> section) any requirements for  <code>unsafe</code> code.</p>
</dd>
</dl>

<p>The documentation for Rust’s <a class="orm:hideurl" href="https://doc.rust-lang.org/std/index.html">standard library</a> provides an excellent example
to emulate for all of these details.</p>








<section data-pdf-bookmark="Tooling" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id126">
<h2>Tooling</h2>

<p>The Markdown <a data-primary="documentation" data-secondary="documenting public interfaces" data-tertiary="tooling for" data-type="indexterm" id="OEBPS/ch05.html.id1623"></a>format that’s used for documentation comments results in elegant output, but this also means that there
is an explicit conversion step  (<code>cargo doc</code>).  <a data-primary="cargo doc" data-type="indexterm" id="OEBPS/ch05.html.id1624"></a>This in turn raises the possibility that something goes
wrong along the way.</p>

<p>The simplest advice for this is just to <em>read the rendered documentation</em> after writing it, by running
<code>cargo doc --open</code> (or <code>cargo doc --no-deps --open</code> to restrict the generated documentation to just the current crate).</p>

<p>You could<a data-primary="broken_intra_doc_links crate attribute" data-type="indexterm" id="OEBPS/ch05.html.id1625"></a> also check that all the generated hyperlinks are valid, but that’s a job more suited to a machine—via
the <code>broken_intra_doc_links</code> crate attribute:<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1626" id="OEBPS/ch05.html.id1626-marker">1</a></sup></p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1627">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#![deny(broken_intra_doc_links)]</code><code class="w"></code>

<code class="sd">/// The bounding box for a [`Polygone`].</code>
<code class="cp">#[derive(Clone, Debug)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">BoundingBox</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>With this attribute enabled, <code>cargo doc</code> will detect invalid links:</p>

<pre data-code-language="text" data-type="programlisting">error: unresolved link to `Polygone`
 --&gt; docs/src/main.rs:4:30
  |
4 | /// The bounding box for a [`Polygone`].
  |                              ^^^^^^^^ no item named `Polygone` in scope
  |</pre>

<p>You can also <em>require</em> documentation, by enabling the <code>#![warn(missing_docs)]</code> attribute for the crate.  <a data-primary="warn(missing_docs) attribute" data-type="indexterm" id="OEBPS/ch05.html.id1628"></a><a data-primary="documentation" data-secondary="requiring" data-type="indexterm" id="OEBPS/ch05.html.id1629"></a>When this is
enabled, the compiler will emit a warning for every undocumented public item.  However, there’s a risk that enabling
this option will lead to poor-quality documentation comments that are rushed out just to get the compiler to shut
up—more on this to come.<a data-primary="continuous integration" data-type="indexterm" id="OEBPS/ch05.html.id1630"></a></p>

<p>As ever, any tooling that detects potential problems should form a part of your CI system
(<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>), to catch any regressions that creep in.</p>
</div></section>








<section data-pdf-bookmark="Additional Documentation Locations" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id127">
<h2>Additional Documentation Locations</h2>

<p>The output from <code>cargo doc</code> is the primary place where your crate is documented, but it’s not the only place—other
parts of a Cargo project can help users figure out how to use your code.<a data-primary="documentation" data-secondary="documenting public interfaces" data-tertiary="additional documentation locations" data-type="indexterm" id="OEBPS/ch05.html.id1631"></a><a data-primary="cargo doc" data-type="indexterm" id="OEBPS/ch05.html.id1632"></a></p>

<p>The <em>examples/</em> subdirectory of a Cargo project can hold the code for standalone binaries that make use of your crate.
These programs are built and run very similarly to integration tests (<a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>) but are specifically intended to hold
example code that illustrates the correct use of your crate’s interface.<a data-primary="example code" data-type="indexterm" id="OEBPS/ch05.html.id1633"></a></p>

<p>On a related note, bear in mind that the integration tests under the <code>tests/</code> subdirectory can also serve as
examples for the confused user, even though their primary purpose is to test the crate’s external interface.<a data-primary="tests" data-type="indexterm" id="OEBPS/ch05.html.id1634"></a><a data-primary="integration tests" data-type="indexterm" id="OEBPS/ch05.html.id1635"></a></p>
</div></section>








<section data-pdf-bookmark="Published Crate Documentation" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id128">
<h2>Published Crate Documentation</h2>

<p>If you publish your crate to  <code>crates.io</code>, the documentation for your project will be visible at <a class="orm:hideurl" href="https://docs.rs"><code>docs.rs</code></a>, which is an official Rust project that builds and hosts documentation for
published crates.<a data-primary="crates.io" data-secondary="published crate documentation" data-type="indexterm" id="OEBPS/ch05.html.id1636"></a><a data-primary="documentation" data-secondary="documenting public interfaces" data-tertiary="published crate documentation" data-type="indexterm" id="OEBPS/ch05.html.id1637"></a></p>

<p>Note that <code>crates.io</code> and <code>docs.rs</code> are intended<a data-primary="docs.rs" data-type="indexterm" id="OEBPS/ch05.html.id1638"></a> for slightly different audiences: <code>crates.io</code> is aimed at people who
are choosing what crate to use, whereas <code>docs.rs</code> is intended for people figuring out how to use a crate they’ve already
included (although there’s obviously considerable overlap between the two).</p>

<p>As a result, the home page for a crate shows different content in each location:</p>
<dl>
<dt><code>docs.rs</code></dt>
<dd>
<p>Shows the top-level page from the output of <code>cargo doc</code>, as generated from <code>//!</code> comments in the top-level
<em>src/lib.rs</em> file.</p>
</dd>
<dt><code>crates.io</code></dt>
<dd>
<p>Shows the content of any top-level <em>README.md</em> file
that’s included in the project’s repo.<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1639" id="OEBPS/ch05.html.id1639-marker">2</a></sup></p>
</dd>
</dl>
</div></section>








<section data-pdf-bookmark="What Not to Document" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id129">
<h2>What <em>Not</em> to Document</h2>

<p>When a project <em>requires</em> that documentation be included for all public items (as mentioned in the first section), it’s
very easy to fall into the trap of having documentation that’s a pointless waste of valuable pixels.<a data-primary="documentation" data-secondary="documenting public interfaces" data-tertiary="what not to document" data-type="indexterm" id="OEBPS/ch05.html.id1640"></a>  Having the
compiler warn about missing doc comments is only a proxy for what you really want—useful documentation—and
is likely to incentivize programmers to do the minimum needed to silence the 
<span class="keep-together">warning</span>.</p>

<p>Good doc comments are a boon that helps users understand the code they’re using; bad doc comments impose a maintenance
burden and increase the chance of user confusion when they get out of sync with the code. So how to distinguish between
the two?</p>

<p>The primary advice is to <em>avoid repeating in text something that’s clear from the code</em>.  <a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> exhorted
you to encode as much semantics as possible into Rust’s type system; once you’ve done that, allow the type system to
document those semantics.<a data-primary="types" data-secondary="including as much semantics as possible Rust type system" data-type="indexterm" id="OEBPS/ch05.html.id1641"></a>  Assume that the reader is familiar with Rust—possibly because they’ve read a helpful
collection of Items describing effective use of the language—and don’t repeat things that are clear from the
signatures and types involved.</p>

<p>Returning to<a data-primary="comments, documentation" data-secondary="overly verbose" data-type="indexterm" id="OEBPS/ch05.html.id1642"></a> the previous example, an overly verbose documentation comment might be as follows:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1643">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Return a new [`BoundingBox`] object that exactly encompasses a pair</code>
<code class="sd">/// of [`BoundingBox`] objects.</code>
<code class="sd">///</code>
<code class="sd">/// Parameters:</code>
<code class="sd">///  - `a`: an immutable reference to a `BoundingBox`</code>
<code class="sd">///  - `b`: an immutable reference to a `BoundingBox`</code>
<code class="sd">/// Returns: new `BoundingBox` object.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">union</code><code class="p">(</code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">BoundingBox</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>
</div></aside>

<p>This comment repeats many details that are clear from the function signature, to no benefit.</p>

<p>Worse, consider what’s likely to happen if the code gets refactored to store the result in one of the original arguments
(which would be a  breaking change; see <a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>). <a data-primary="comments, documentation" data-secondary="out-of-sync comment" data-type="indexterm" id="OEBPS/ch05.html.id1644"></a>No compiler or tool complains that the
comment isn’t updated to match, so it’s easy to end up with an out-of-sync comment:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1645">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Return a new [`BoundingBox`] object that exactly encompasses a pair</code>
<code class="sd">/// of [`BoundingBox`] objects.</code>
<code class="sd">///</code>
<code class="sd">/// Parameters:</code>
<code class="sd">///  - `a`: an immutable reference to a `BoundingBox`</code>
<code class="sd">///  - `b`: an immutable reference to a `BoundingBox`</code>
<code class="sd">/// Returns: new `BoundingBox` object.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">union</code><code class="p">(</code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">BoundingBox</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>
</div></aside>

<p>In contrast, the original comment survives the refactoring unscathed, because its text describes behavior, not syntactic
details:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Calculate the [`BoundingBox`] that exactly encompasses a pair</code>
<code class="sd">/// of [`BoundingBox`] objects.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">union</code><code class="p">(</code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">BoundingBox</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>

<p>The mirror image of the preceding advice also helps improve documentation: <em>include in text anything that’s</em> not
<em>clear from the code</em>.  <a data-primary="preconditions" data-type="indexterm" id="OEBPS/ch05.html.id1646"></a><a data-primary="invariants" data-type="indexterm" id="OEBPS/ch05.html.id1647"></a><a data-primary="panics" data-type="indexterm" id="OEBPS/ch05.html.id1648"></a><a data-primary="error conditions" data-type="indexterm" id="OEBPS/ch05.html.id1649"></a><a data-primary="principle of least astonishment" data-type="indexterm" id="OEBPS/ch05.html.id1650"></a>This includes preconditions, invariants, panics, error conditions, and anything else that might
surprise a user; if your code can’t comply with the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a>, make sure that the surprises are
documented so you can at least say, “I told you so.”</p>

<p>Another <a data-primary="comments, documentation" data-secondary="describing how some other code uses the method" data-type="indexterm" id="OEBPS/ch05.html.id1651"></a>common failure mode is when doc comments describe how some other code uses a method, rather than what the method
does:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Return the intersection of two [`BoundingBox`] objects, returning `None`</code>
<code class="sd">/// if there is no intersection. The collision detection code in `hits.rs`</code>
<code class="sd">/// uses this to do an initial check to see whether two objects might overlap,</code>
<code class="sd">/// before performing the more expensive pixel-by-pixel check in</code>
<code class="sd">/// `objects_overlap`.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">intersection</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"></code>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">BoundingBox</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>

<p>Comments like this are almost guaranteed to get out of sync: when the using code (here, <code>hits.rs</code>) changes, the comment that
describes the behavior is nowhere nearby.</p>

<p>Rewording the comment <a data-primary="comments, documentation" data-secondary="focusing on the why" data-type="indexterm" id="OEBPS/ch05.html.id1652"></a>to focus more on the <em>why</em> makes it more robust to future changes:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Return the intersection of two [`BoundingBox`] objects, returning `None`</code>
<code class="sd">/// if there is no intersection.  Note that intersection of bounding boxes</code>
<code class="sd">/// is necessary but not sufficient for object collision -- pixel-by-pixel</code>
<code class="sd">/// checks are still required on overlap.</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">intersection</code><code class="p">(</code><code class="w"></code>
<code class="w">    </code><code class="n">a</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">BoundingBox</code><code class="p">,</code><code class="w"></code>
<code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Option</code><code class="o">&lt;</code><code class="n">BoundingBox</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code></pre>

<p>When<a data-primary="programming in the future tense" data-type="indexterm" id="OEBPS/ch05.html.id1653"></a> writing software, it’s good advice to “program in the future tense”:<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1654" id="OEBPS/ch05.html.id1654-marker">3</a></sup> structure the code to accommodate future changes.<a data-primary="More Effective C++ (Meyers)" data-type="indexterm" id="OEBPS/ch05.html.id1655"></a><a data-primary="Meyers, Scott" data-type="indexterm" id="OEBPS/ch05.html.id1656"></a><a data-primary="C++" data-type="indexterm" id="OEBPS/ch05.html.id1657"></a>  The same
principle is true for documentation: focusing on the semantics, the <em>whys</em> and the <em>why nots</em>, gives text that is more
likely to remain helpful in the long run.</p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id175">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Add doc comments for public API items.</p>
</li>
<li>
<p>Describe aspects of the code—such as panics and safety criteria—that aren’t obvious from the code
itself.</p>
</li>
<li>
<p><em>Don’t</em> describe things that are obvious from the code itself.</p>
</li>
<li>
<p>Make navigation clearer by providing cross-references and by making identifiers stand out.<a data-primary="documentation" data-secondary="documenting public interfaces" data-startref="i_docu" data-type="indexterm" id="OEBPS/ch05.html.id1658"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 28: Use macros judiciously" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_macros_md">
<h1>Item 28: Use macros judiciously</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>In some cases it’s easy to decide to write a macro instead of a function, because only a macro can do what’s
needed.</p>
<p data-type="attribution">Paul Graham, <em>On Lisp</em> (Prentice Hall)</p>
</blockquote>

<p>Rust’s macro systems allow you to perform <em>metaprogramming</em>: to write code that<a data-primary="Graham, Paul" data-type="indexterm" id="OEBPS/ch05.html.id1659"></a> emits code into your project.
This is most valuable when there are chunks of “boilerplate” code that are deterministic and repetitive and that would
otherwise need to be kept in sync manually.<a data-primary="macros" data-type="indexterm" id="OEBPS/ch05.html.ix_mcro"></a><a data-primary="metaprogramming" data-type="indexterm" id="OEBPS/ch05.html.id1660"></a></p>

<p>Programmers coming to Rust may have previously encountered the macros provided by     C/C++’s
 preprocessor, which perform textual substitution on the tokens of the input text.<a data-primary="C++" data-secondary="macros" data-type="indexterm" id="OEBPS/ch05.html.id1661"></a><a data-primary="abstract syntax tree" data-type="indexterm" id="OEBPS/ch05.html.id1662"></a> Rust’s macros
are a different beast, because they work on either the parsed tokens of the program or on the  <em>abstract
syntax tree</em> (AST) of the program, rather than just its textual content.</p>

<p>This means Rust macros can be aware of code structure and can consequently avoid entire classes of macro-related
footguns.<a data-primary="hygienic macros" data-type="indexterm" id="OEBPS/ch05.html.id1663"></a> In particular, we see in the following section that Rust’s declarative macros are  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Hygienic_macro"><em>hygienic</em></a>—they cannot accidentally refer to (“capture”)
local variables in the surrounding code.</p>

<p>One way to think about macros is to see them as a different level of abstraction in the code.<a data-primary="functions" data-type="indexterm" id="OEBPS/ch05.html.id1664"></a>  A simple form of abstraction
is a function: it abstracts away the differences between different values of the same <em>type</em>, with implementation code
that can use any of the features and methods of that type, regardless of the current value being operated on.<a data-primary="generics" data-type="indexterm" id="OEBPS/ch05.html.id1665"></a>  A
 generic is a different level of abstraction: it abstracts away the difference between different <em>types</em> that
satisfy a  trait bound, with implementation code that can use any of the methods provided by the trait bounds,
regardless of the current type being operated on.<a data-primary="trait bounds" data-type="indexterm" id="OEBPS/ch05.html.id1666"></a></p>

<p>A macro abstracts away the difference between different fragments of the program that play the same role (type,
identifier, expression, etc.); the implementation can then include any code that makes use of those fragments in the
same role.</p>

<p>Rust provides two ways to define macros:</p>

<ul>
<li>
<p>Declarative macros, also<a data-primary="macros" data-secondary="declarative" data-type="indexterm" id="OEBPS/ch05.html.id1667"></a><a data-primary="declarative macros" data-secondary="defined" data-type="indexterm" id="OEBPS/ch05.html.id1668"></a> known as “macros by example,” allow the insertion of arbitrary Rust code into the program,
based on the input parameters to the macro (which are categorized according to their role in the AST).</p>
</li>
<li>
<p>Procedural macros allow the insertion of arbitrary Rust code into the program, based on the parsed tokens of the
source code.<a data-primary="macros" data-secondary="procedural" data-seealso="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.id1669"></a>  This is most commonly used for  <code>derive</code> macros, which can generate code based on the
contents of data structure definitions.<a data-primary="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.id1670"></a><a data-primary="derive macros" data-type="indexterm" id="OEBPS/ch05.html.id1671"></a></p>
</li>
</ul>








<section data-pdf-bookmark="Declarative Macros" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.declarative-macros">
<h2>Declarative Macros</h2>

<p>Although this Item isn’t the place to reproduce the <a href="https://oreil.ly/Vm7AZ">documentation for declarative macros</a>, a few reminders of details to watch out for are in
order.<a data-primary="macros" data-secondary="declarative" data-type="indexterm" id="OEBPS/ch05.html.ix_macrdec"></a><a data-primary="declarative macros" data-type="indexterm" id="OEBPS/ch05.html.ix_decmac"></a></p>

<p>First, be aware that the scoping rules for using a declarative macro are different than for other Rust items.<a data-primary="scope" data-secondary="rules for declarative macro use" data-type="indexterm" id="OEBPS/ch05.html.id1672"></a>  If a
 declarative macro is defined in a source code file, only the code <em>after</em> the macro definition
can make use of it:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1673">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">before</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"[before] square {} is {}"</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="n">square</code><code class="o">!</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Macro that squares its argument.</code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">square</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="cp">$e</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">after</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"[after] square {} is {}"</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="n">square</code><code class="o">!</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error: cannot find macro `square` in this scope
 --&gt; src/main.rs:4:45
  |
4 |     println!("[before] square {} is {}", 2, square!(2));
  |                                             ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module/import?</pre>

<p>The  <code>#[macro_export]</code> attribute makes a macro more widely visible, but this also has an oddity: a
macro appears at the top level of a crate, even if it’s defined in a module:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">mod</code> <code class="nn">submod</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="cp">#[macro_export]</code><code class="w"></code>
<code class="w">    </code><code class="fm">macro_rules!</code><code class="w"> </code><code class="n">cube</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="cp">$e</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="cp">$e</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">mod</code> <code class="nn">user</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">use_macro</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Note: *not* `crate::submod::cube!`</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">cubed</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">crate</code>::<code class="n">cube</code><code class="o">!</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"cube {} is {}"</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="n">cubed</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Rust’s declarative macros are what’s known as  <em>hygienic</em>: the expanded code in the body of the
macro is not allowed to make use of local variable bindings.<a data-primary="declarative macros" data-secondary="hygienic macros" data-type="indexterm" id="OEBPS/ch05.html.id1674"></a><a data-primary="hygienic macros" data-type="indexterm" id="OEBPS/ch05.html.id1675"></a>  For example, a macro that assumes that some variable <code>x</code>
exists:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Create a macro that assumes the existence of a local `x`.</code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">increment_x</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>will trigger a compilation failure when it is used:</p>
<aside class="does_not_compile" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1676">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"></code>
<code class="n">increment_x</code><code class="o">!</code><code class="p">();</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"x = {}"</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">);</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="text" data-type="programlisting">error[E0425]: cannot find value `x` in this scope
   --&gt; src/main.rs:55:13
    |
55  |     {} =&gt; { x += 1; };
    |             ^ not found in this scope
...
314 |     increment_x!();
    |     -------------- in this macro invocation
    |
    = note: this error originates in the macro `increment_x`</pre>

<p>This hygienic property means that Rust’s macros are safer than C preprocessor macros.<a data-primary="C" data-secondary="preprocessor macros" data-type="indexterm" id="OEBPS/ch05.html.id1677"></a> However, there are still a couple
of minor gotchas to be aware of when using them.</p>

<p>The first is to realize that even if a macro invocation <em>looks</em> like a function invocation, it’s not.  A macro
generates code at the point of invocation, and that generated code can perform manipulations of its arguments:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">macro_rules!</code><code class="w"> </code><code class="n">inc_item</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$x</code>:<code class="nc">ident</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cp">$x</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This means that the normal intuition about whether parameters are moved or <code>&amp;</code>-referred-to doesn’t apply:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// type is not `Copy`</code>

<code class="c1">// Item is *not* moved, despite the (x) syntax,</code>
<code class="c1">// but the body of the macro *can* modify `x`.</code>
<code class="n">inc_item</code><code class="o">!</code><code class="p">(</code><code class="n">x</code><code class="p">);</code><code class="w"></code>

<code class="fm">println!</code><code class="p">(</code><code class="s">"x is {x:?}"</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">x is Item { contents: 43 }</pre>

<p>This<a data-primary="declarative macros" data-secondary="inserting code at point of invocation" data-type="indexterm" id="OEBPS/ch05.html.id1678"></a><a data-primary="macros" data-secondary="declarative" data-tertiary="inserting code at point of invocation" data-type="indexterm" id="OEBPS/ch05.html.id1679"></a> becomes clear if we remember that the macro inserts code at the point of invocation—in this case, adding a
line of code that increments <code>x.contents</code>.<a data-primary="cargo-expand" data-type="indexterm" id="OEBPS/ch05.html.id1680"></a>  The  <a class="orm:hideurl" href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> tool
shows the code that the compiler sees, after macro expansion:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Item</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">contents</code>: <code class="mi">42</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="n">x</code><code class="p">.</code><code class="n">contents</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="p">{</code><code class="w"></code>
<code class="w">    </code>::<code class="n">std</code>::<code class="n">io</code>::<code class="n">_print</code><code class="p">(</code><code class="fm">format_args!</code><code class="p">(</code><code class="s">"x is {0:?}</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">));</code><code class="w"></code>
<code class="p">};</code><code class="w"></code></pre>

<p>The expanded code includes the modification in place, via the owner of the item, not a reference.<a data-primary="println! macro" data-type="indexterm" id="OEBPS/ch05.html.id1681"></a><a data-primary="format_args! macro" data-type="indexterm" id="OEBPS/ch05.html.id1682"></a>  (It’s also interesting
to see the expanded version of <code>println!</code>, which relies on the <code>format_args!</code> macro, to be discussed shortly.)<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1683" id="OEBPS/ch05.html.id1683-marker">4</a></sup></p>

<p>So the  exclamation mark serves as a warning: the expanded code for the macro may do arbitrary things to or with
its arguments.<a data-primary="! (exclamation mark)" data-type="indexterm" id="OEBPS/ch05.html.id1684"></a></p>

<p>The expanded code can also include control flow operations that aren’t visible in the calling code, whether<a data-primary="control flow" data-type="indexterm" id="OEBPS/ch05.html.id1685"></a><a data-primary="loops" data-type="indexterm" id="OEBPS/ch05.html.id1686"></a><a data-primary="conditionals" data-type="indexterm" id="OEBPS/ch05.html.id1687"></a><a data-primary="return statements" data-type="indexterm" id="OEBPS/ch05.html.id1688"></a><a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch05.html.id1689"></a><a data-primary="principle of least astonishment" data-type="indexterm" id="OEBPS/ch05.html.id1690"></a> they be
loops, conditionals,  <code>return</code> statements, or use of the  <code>?</code> operator.  Obviously, this is likely to violate
the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a>, so <em>prefer macros whose behavior aligns with normal Rust</em> where possible and appropriate.  (On the other hand, if the
<em>purpose</em> of the macro is <a data-primary="declarative macros" data-secondary="preferring macros with behavior aligned with normal Rust" data-type="indexterm" id="OEBPS/ch05.html.id1691"></a><a data-primary="macros" data-secondary="declarative" data-tertiary="preferring macros with behavior aligned with normal Rust" data-type="indexterm" id="OEBPS/ch05.html.id1692"></a>to allow weird control flow, go for it! But help out your users by making sure the control
flow behavior is clearly documented.)</p>

<p>For example, consider a macro (for checking HTTP status codes) that silently includes a <code>return</code> in its body:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Check that an HTTP status is successful; exit function if not.</code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">check_successful</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="cp">$e</code><code class="p">.</code><code class="n">group</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="n">Group</code>::<code class="n">Successful</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">MyError</code><code class="p">(</code><code class="s">"HTTP operation failed"</code><code class="p">));</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Code that uses this macro to check the result of some kind of HTTP operation can end up with control flow that’s
somewhat obscure:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">rc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perform_http_operation</code><code class="p">();</code><code class="w"></code>
<code class="n">check_successful</code><code class="o">!</code><code class="p">(</code><code class="n">rc</code><code class="p">);</code><code class="w"> </code><code class="c1">// may silently exit the function</code>

<code class="c1">// ...</code></pre>

<p>An alternative version of the macro that<a data-primary="Result type" data-secondary="macro emitting" data-type="indexterm" id="OEBPS/ch05.html.id1693"></a> generates code that emits a <code>Result</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Convert an HTTP status into a `Result&lt;(), MyError&gt;` indicating success.</code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">check_success</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">match</code><code class="w"> </code><code class="cp">$e</code><code class="p">.</code><code class="n">group</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">Group</code>::<code class="n">Successful</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(()),</code><code class="w"></code>
<code class="w">            </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">MyError</code><code class="p">(</code><code class="s">"HTTP operation failed"</code><code class="p">)),</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>gives code that’s easier to follow:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">rc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perform_http_operation</code><code class="p">();</code><code class="w"></code>
<code class="n">check_success</code><code class="o">!</code><code class="p">(</code><code class="n">rc</code><code class="p">)</code><code class="o">?</code><code class="p">;</code><code class="w"> </code><code class="c1">// error flow is visible via `?`</code>

<code class="c1">// ...</code></pre>

<p>The second thing to watch out for with  declarative<a data-primary="macros" data-secondary="declarative" data-tertiary="expression with side effects as input" data-type="indexterm" id="OEBPS/ch05.html.id1694"></a><a data-primary="declarative macros" data-secondary="expression with side effects as input" data-type="indexterm" id="OEBPS/ch05.html.id1695"></a> macros is a problem shared with the
 C preprocessor: if the argument to a macro is an expression with side effects, beware of
repeated use of the argument in the macro.<a data-primary="C" data-secondary="macro argument with side effects" data-type="indexterm" id="OEBPS/ch05.html.id1696"></a><a data-primary="square! macro" data-type="indexterm" id="OEBPS/ch05.html.id1697"></a>  The <code>square!</code> macro defined earlier takes an arbitrary expression as an
argument and then uses that argument twice, which can lead to surprises:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1698">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">square</code><code class="o">!</code><code class="p">({</code><code class="w"></code>
<code class="w">    </code><code class="n">x</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">x</code><code class="w"></code>
<code class="p">});</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"x = {x}, y = {y}"</code><code class="p">);</code><code class="w"></code>
<code class="c1">// output: x = 3, y = 6</code></pre>
</div></aside>

<p>Assuming that this behavior isn’t intended, one way to fix it is simply to evaluate the expression once and assign the
result to a local<a data-primary="square_once! macro" data-type="indexterm" id="OEBPS/ch05.html.id1699"></a> variable:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">macro_rules!</code><code class="w"> </code><code class="n">square_once</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="cp">$e</code><code class="p">;</code><code class="w"></code>
<code class="w">            </code><code class="n">x</code><code class="o">*</code><code class="n">x</code><code class="w"> </code><code class="c1">// Note: there's a detail here to be explained later...</code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="c1">// output now: x = 2, y = 4</code></pre>

<p class="pagebreak-before less_space">The other alternative is not to allow an arbitrary expression as input to the macro.  If the <a href="https://oreil.ly/8u0NJ"><code>expr</code> syntax fragment specifier</a> is replaced with an <code>ident</code>
fragment specifier, then the macro will only accept identifiers as inputs, and the attempt to feed it an arbitrary
expression will no longer compile.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1700">
<h1>Formatting Values</h1>
<p>One common style of declarative macro involves assembling a message that includes various values from the current state
of the code.<a data-primary="declarative macros" data-secondary="formatting values" data-type="indexterm" id="OEBPS/ch05.html.id1701"></a><a data-primary="macros" data-secondary="declarative" data-tertiary="formatting values" data-type="indexterm" id="OEBPS/ch05.html.id1702"></a><a data-primary="format! macro" data-type="indexterm" id="OEBPS/ch05.html.id1703"></a><a data-primary="println! macro" data-type="indexterm" id="OEBPS/ch05.html.id1704"></a><a data-primary="eprintln! macro" data-type="indexterm" id="OEBPS/ch05.html.id1705"></a> For example, the standard library includes
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a> for assembling a <code>String</code>,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> for printing to standard output,
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.eprintln.html"><code>eprintln!</code></a> for printing to standard error, and so on.  The
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/index.html">documentation</a> describes the syntax of the formatting directives, which
are roughly equivalent to  C’s  <code>printf</code> statement.<a data-primary="printf (C)" data-type="indexterm" id="OEBPS/ch05.html.id1706"></a><a data-primary="C" data-secondary="printf statement" data-type="indexterm" id="OEBPS/ch05.html.id1707"></a><a data-primary="Display trait" data-type="indexterm" id="OEBPS/ch05.html.id1708"></a><a data-primary="Debug trait" data-type="indexterm" id="OEBPS/ch05.html.id1709"></a><a data-primary="std::fmt" data-type="indexterm" id="OEBPS/ch05.html.id1710"></a><a data-primary="LowerHex trait" data-type="indexterm" id="OEBPS/ch05.html.id1711"></a>  However, the format arguments are type safe
and checked at compile time, and the implementations of the macro use the <code>Display</code> and <code>Debug</code> traits described in <a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a>
to format individual values.<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1712" id="OEBPS/ch05.html.id1712-marker">5</a></sup></p>

<p>You can (and should) use the same formatting syntax for any macros of your own that perform a similar function.<a data-primary="log crate" data-type="indexterm" id="OEBPS/ch05.html.id1713"></a>  For
example, the logging macros provided by the  <a class="orm:hideurl" href="https://docs.rs/log"><code>log</code></a> crate use the same syntax as <code>format!</code>.
To do this, <em>use  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.format_args.html"><code>format_args!</code></a> for macros <a data-primary="format_args! macro" data-type="indexterm" id="OEBPS/ch05.html.id1714"></a>that
perform argument formatting</em> rather than attempting to reinvent the wheel:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Log an error including code location, with `format!`-like arguments.</code>
<code class="sd">/// Real code would probably use the `log` crate.</code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">my_log</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$($arg</code>:<code class="nc">tt</code><code class="p">)</code><code class="o">+</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">eprintln!</code><code class="p">(</code><code class="s">"{}:{}: {}"</code><code class="p">,</code><code class="w"> </code><code class="fm">file!</code><code class="p">(),</code><code class="w"> </code><code class="fm">line!</code><code class="p">(),</code><code class="w"> </code><code class="fm">format_args!</code><code class="p">(</code><code class="cp">$($arg</code><code class="p">)</code><code class="o">+</code><code class="p">));</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="k">u8</code><code class="p">;</code><code class="w"></code>
<code class="c1">// Format specifiers:</code>
<code class="c1">// - `x` says print as hex</code>
<code class="c1">// - `#` says prefix with '0x'</code>
<code class="c1">// - `04` says add leading zeroes so width is at least 4</code>
<code class="c1">//   (this includes the '0x' prefix).</code>
<code class="n">my_log</code><code class="o">!</code><code class="p">(</code><code class="s">"x = {:#04x}"</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">src/main.rs:331: x = 0x0a</pre>
</div></aside>
</div></section>








<section class="pagebreak-before less_space" data-pdf-bookmark="Procedural Macros" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id132">
<h2>Procedural Macros</h2>

<p>Rust also supports  <em>procedural macros</em>, often known as <em>proc macros</em>.  <a data-primary="macros" data-secondary="declarative" data-startref="ix_macrdec" data-type="indexterm" id="OEBPS/ch05.html.id1715"></a><a data-primary="declarative macros" data-startref="ix_decmac" data-type="indexterm" id="OEBPS/ch05.html.id1716"></a><a data-primary="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.ix_procmac"></a><a data-primary="macros" data-secondary="procedural" data-type="indexterm" id="OEBPS/ch05.html.ix_macrproc"></a>Like a declarative macro,
a <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macro</a> has the ability to insert arbitrary
Rust code into the program’s source code.  <a data-primary="proc macros" data-see="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.id1717"></a>However, the inputs to the macro are no longer just the specific arguments
passed to it; instead, a procedural macro has access to the parsed tokens corresponding to some chunk of the original
source code.  This gives a level of expressive power that approaches the flexibility of dynamic languages such as
Lisp—but still with compile-time guarantees.<a data-primary="Lisp" data-type="indexterm" id="OEBPS/ch05.html.id1718"></a><a data-primary="reflection" data-type="indexterm" id="OEBPS/ch05.html.id1719"></a>  It also helps mitigate the limitations of reflection in Rust, as
discussed in <a href="#OEBPS/ch03.html.file_reflection_md">Item 19</a>.</p>

<p>Procedural macros must be defined<a data-primary="crates" data-secondary="proc-macro crate type" data-type="indexterm" id="OEBPS/ch05.html.id1720"></a><a data-primary="proc-macro crate" data-type="indexterm" id="OEBPS/ch05.html.id1721"></a> in a separate crate (of crate type <code>proc-macro</code>) from where they are used, and that
crate will almost certainly need to depend on either <a class="orm:hideurl" href="https://doc.rust-lang.org/proc_macro/index.html"><code>proc-macro</code></a>
(provided by the standard toolchain) or <a class="orm:hideurl" href="https://docs.rs/proc-macro2"><code>proc-macro2</code></a> (provided by  David Tolnay) as a support library, to make it possible to work with the input tokens.<a data-primary="proc-macro2 crate" data-type="indexterm" id="OEBPS/ch05.html.id1722"></a><a data-primary="Tolnay, David" data-type="indexterm" id="OEBPS/ch05.html.id1723"></a></p>

<p>There are <a data-primary="procedural macros" data-secondary="types of" data-type="indexterm" id="OEBPS/ch05.html.id1724"></a>three distinct types of procedural macro:</p>
<dl>
<dt><em>Function-like macros</em></dt>
<dd>
<p>Invoked with an argument</p>
</dd>
<dt><em>Attribute macros</em></dt>
<dd>
<p>Attached to some chunk of syntax in the program</p>
</dd>
<dt><em>Derive macros</em></dt>
<dd>
<p>Attached to the definition of a data structure</p>
</dd>
</dl>










<section data-pdf-bookmark="Function-like macros" data-type="sect3"><div class="sect3" id="OEBPS/ch05.html.id133">
<h3>Function-like macros</h3>

<p>Function-like procedural macros <a data-primary="function-like macros" data-type="indexterm" id="OEBPS/ch05.html.id1725"></a><a data-primary="procedural macros" data-secondary="function-like macros" data-type="indexterm" id="OEBPS/ch05.html.id1726"></a>are invoked with an argument, and the macro definition has access to the parsed tokens
that make up the argument, and emits arbitrary tokens as a result.  Note that the previous sentence says “argument,”
singular—even if a function-like macro is invoked with what looks like multiple arguments:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="n">my_func_macro</code><code class="o">!</code><code class="p">(</code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="p">,</code><code class="w"> </code><code class="kt">f32</code>::<code class="n">consts</code>::<code class="n">PI</code><code class="p">);</code><code class="w"></code></pre>

<p>the macro itself receives a single argument, which is a stream of parsed tokens.  A macro implementation that just
prints (at compile time) the contents of the stream:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">proc_macro</code>::<code class="n">TokenStream</code><code class="p">;</code><code class="w"></code>

<code class="c1">// Function-like macro that just prints (at compile time) its input stream.</code>
<code class="cp">#[proc_macro]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">my_func_macro</code><code class="p">(</code><code class="n">args</code>: <code class="nc">TokenStream</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">TokenStream</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Input TokenStream is:"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="n">tt</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="n">args</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">println!</code><code class="p">(</code><code class="s">"  {tt:?}"</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Return an empty token stream to replace the macro invocation with.</code>
<code class="w">    </code><code class="n">TokenStream</code>::<code class="n">new</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>shows the stream corresponding to the input:</p>

<pre data-code-language="text" data-type="programlisting">Input TokenStream is:
  Literal { kind: Integer, symbol: "15", suffix: None,
            span: #0 bytes(10976..10978) }
  Punct { ch: ',', spacing: Alone, span: #0 bytes(10978..10979) }
  Ident { ident: "x", span: #0 bytes(10980..10981) }
  Punct { ch: '+', spacing: Alone, span: #0 bytes(10982..10983) }
  Ident { ident: "y", span: #0 bytes(10984..10985) }
  Punct { ch: ',', spacing: Alone, span: #0 bytes(10985..10986) }
  Ident { ident: "f32", span: #0 bytes(10987..10990) }
  Punct { ch: ':', spacing: Joint, span: #0 bytes(10990..10991) }
  Punct { ch: ':', spacing: Alone, span: #0 bytes(10991..10992) }
  Ident { ident: "consts", span: #0 bytes(10992..10998) }
  Punct { ch: ':', spacing: Joint, span: #0 bytes(10998..10999) }
  Punct { ch: ':', spacing: Alone, span: #0 bytes(10999..11000) }
  Ident { ident: "PI", span: #0 bytes(11000..11002) }</pre>

<p>The low-level nature of this input stream means that the macro implementation has to do its own parsing.<a data-primary="TokenTree::Punct tokens" data-type="indexterm" id="OEBPS/ch05.html.id1727"></a>  For example,
separating out what appear to be separate arguments to the macro involves looking for <code>TokenTree::Punct</code> tokens that
hold the commas dividing the arguments.  The  <a class="orm:hideurl" href="https://docs.rs/syn"><code>syn</code></a> crate (from  David
Tolnay) provides a parsing library that can help with this, as <a data-type="xref" href="#OEBPS/ch05.html.derive-macros-sect">“Derive macros”</a> describes.<a data-primary="syn crate" data-type="indexterm" id="OEBPS/ch05.html.id1728"></a><a data-primary="Tolnay, David" data-type="indexterm" id="OEBPS/ch05.html.id1729"></a></p>

<p>Because of this, it’s usually easier to use a declarative macro than a function-like procedural macro, because the
expected structure of the macro’s inputs can be expressed in the matching pattern.</p>

<p>The flip side of this need for manual processing is that function-like proc macros have the flexibility to accept inputs
that <em>don’t</em> parse as normal Rust code.  That’s not often needed (or sensible), so function-like macros are
comparatively rare as a result.</p>
</div></section>










<section data-pdf-bookmark="Attribute macros" data-type="sect3"><div class="sect3" id="OEBPS/ch05.html.id134">
<h3>Attribute macros</h3>

<p>Attribute macros are invoked by placing them before some item in the program, and the parsed tokens for that item are
the input to the macro.<a data-primary="attribute macros" data-type="indexterm" id="OEBPS/ch05.html.id1730"></a><a data-primary="procedural macros" data-secondary="attribute macros" data-type="indexterm" id="OEBPS/ch05.html.id1731"></a>  The macro can again emit arbitrary tokens as output, but the output is typically some
transformation of the input.</p>

<p>For example, an attribute macro can be used to  wrap the body of a function:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[log_invocation]</code><code class="w"></code>
<code class="k">fn</code> <code class="nf">add_three</code><code class="p">(</code><code class="n">x</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">3</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>so that invocations of the function are logged:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">add_three</code><code class="p">(</code><code class="n">x</code><code class="p">);</code><code class="w"></code>
<code class="fm">println!</code><code class="p">(</code><code class="s">"add_three({x}) = {y}"</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">log: calling function 'add_three'
log: called function 'add_three' =&gt; 5
add_three(2) = 5</pre>

<p>The implementation of this macro is too large to include here, because the code needs to check the structure of the
input tokens and to build up the new output tokens, but the <code>syn</code> crate can again help with this processing.</p>
</div></section>










<section data-pdf-bookmark="Derive macros" data-type="sect3"><div class="sect3" id="OEBPS/ch05.html.derive-macros-sect">
<h3>Derive macros</h3>

<p>The final type of procedural<a data-primary="procedural macros" data-secondary="derive macros" data-type="indexterm" id="OEBPS/ch05.html.ix_procmacder"></a><a data-primary="derive macros" data-type="indexterm" id="OEBPS/ch05.html.ix_dermac"></a> macro is the  derive macro, which allows generated code to be automatically attached
to a data structure definition (a <code>struct</code>, <code>enum</code>, or <code>union</code>).<a data-primary="enums" data-type="indexterm" id="OEBPS/ch05.html.id1732"></a><a data-primary="union" data-type="indexterm" id="OEBPS/ch05.html.id1733"></a><a data-primary="struct types" data-type="indexterm" id="OEBPS/ch05.html.id1734"></a> This is similar to an attribute macro
but there are a few <code>derive</code>-specific aspects to be aware of.</p>

<p>The first is that <code>derive</code> macros <em>add</em> to the input tokens, instead of replacing them altogether.  This means that the data
structure definition is left intact but the macro has the opportunity to append related code.</p>

<p>The second is that a <code>derive</code> macro can declare associated helper attributes, which can then be used to mark parts of the
data structure that need special processing.<a data-primary="derive macros" data-secondary="declaring associated helper attributes" data-type="indexterm" id="OEBPS/ch05.html.id1735"></a>  For example,  <a class="orm:hideurl" href="https://docs.rs/serde"><code>serde</code></a>’s
<a class="orm:hideurl" href="https://docs.rs/serde/latest/serde/derive.Deserialize.html"><code>Deserialize</code></a> derive macro has a <code>serde</code> helper attribute
that can provide metadata to guide<a data-primary="Deserialize macro" data-type="indexterm" id="OEBPS/ch05.html.id1736"></a><a data-primary="serde crate" data-type="indexterm" id="OEBPS/ch05.html.id1737"></a> the deserialization process:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">generate_value</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">String</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="s">"unknown"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="cp">#[derive(Debug, Deserialize)]</code><code class="w"></code>
<code class="k">struct</code> <code class="nc">MyData</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// If `value` is missing when deserializing, invoke</code>
<code class="w">    </code><code class="c1">// `generate_value()` to populate the field instead.</code>
<code class="w">    </code><code class="cp">#[serde(default = </code><code class="s">"generate_value"</code><code class="cp">)]</code><code class="w"></code>
<code class="w">    </code><code class="n">value</code>: <code class="nb">String</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The final aspect of <code>derive</code> macros to be aware of is that the  <a class="orm:hideurl" href="https://docs.rs/syn"><code>syn</code></a> crate can take care of
much of the heavy lifting involved in parsing the input tokens into the equivalent nodes in the AST.<a data-primary="syn crate" data-type="indexterm" id="OEBPS/ch05.html.id1738"></a><a data-primary="parse_macro_input! macro" data-type="indexterm" id="OEBPS/ch05.html.id1739"></a><a data-primary="tokens" data-type="indexterm" id="OEBPS/ch05.html.id1740"></a>  The
<a class="orm:hideurl" href="https://docs.rs/syn/latest/syn/macro.parse_macro_input.html"><code>syn::parse_macro_input!</code></a> macro converts the tokens into
a <a class="orm:hideurl" href="https://docs.rs/syn/latest/syn/struct.DeriveInput.html"><code>syn::DeriveInput</code></a> data structure that describes the content
of the item, and <code>Deri⁠ve​Input</code> is much easier to deal with than a raw stream of tokens.<a data-primary="DeriveInput data structure" data-type="indexterm" id="OEBPS/ch05.html.id1741"></a></p>

<p>In practice, <code>derive</code> macros <a data-primary="enums" data-secondary="derive macro use" data-type="indexterm" id="OEBPS/ch05.html.id1742"></a><a data-primary="struct types" data-secondary="derive macro use" data-type="indexterm" id="OEBPS/ch05.html.id1743"></a>are the most commonly encountered type of procedural macro—the ability to generate
field-by-field (for <code>struct</code>s) or variant-by-variant (for <code>enum</code>s) implementations allows for a lot of functionality to
be provided with little effort from the programmer—for example, by adding a single line like <code>#[derive(Debug, Clone, PartialEq, Eq)]</code>.</p>

<p>Because the <code>derive</code>d implementations are auto-generated, it also means that the implementations automatically stay in
sync with the data structure definition.<a data-primary="Debug trait" data-secondary="from derive macro" data-secondary-sortas="derive" data-type="indexterm" id="OEBPS/ch05.html.id1744"></a>  For example, if you were to add a new field to a <code>struct</code>, a manual
implementation of <code>Debug</code> would need to be manually updated, whereas an automatically <code>derive</code>d version would display
the new field with no additional effort (or would fail to compile if that wasn’t possible).<a data-primary="procedural macros" data-secondary="derive macros" data-startref="ix_procmacder" data-type="indexterm" id="OEBPS/ch05.html.id1745"></a><a data-primary="derive macros" data-startref="ix_dermac" data-type="indexterm" id="OEBPS/ch05.html.id1746"></a><a data-primary="macros" data-secondary="procedural" data-startref="ix_macrproc" data-type="indexterm" id="OEBPS/ch05.html.id1747"></a><a data-primary="procedural macros" data-startref="ix_procmac" data-type="indexterm" id="OEBPS/ch05.html.id1748"></a></p>
</div></section>
</div></section>








<section data-pdf-bookmark="When to Use Macros" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.when_macros_sect">
<h2>When to Use Macros</h2>

<p>The primary reason to use macros is to avoid repetitive code—especially repetitive code<a data-primary="macros" data-secondary="when to use" data-type="indexterm" id="OEBPS/ch05.html.id1749"></a> that would otherwise
have to be manually kept in sync with other parts of the code.  In this respect, writing a macro is just an extension of
the same kind of generalization process that normally forms part of programming:</p>

<ul>
<li>
<p>If you repeat exactly the same code for multiple values of a specific type, encapsulate that code into a common<a data-primary="functions" data-type="indexterm" id="OEBPS/ch05.html.id1750"></a>
function and call the function from all of the repeated places.</p>
</li>
<li>
<p>If you repeat exactly the same code for multiple types, encapsulate that code into a  generic<a data-primary="generics" data-type="indexterm" id="OEBPS/ch05.html.id1751"></a>
with a trait bound and use the generic from all of the repeated places.</p>
</li>
<li>
<p>If you repeat the same structure of code in multiple places, encapsulate that code into a  macro and
use the macro from all of the repeated places.</p>
</li>
</ul>

<p>For example, avoiding <a data-primary="enums" data-secondary="avoiding code repetition with macros" data-type="indexterm" id="OEBPS/ch05.html.id1752"></a>repetition for code that works on different  <code>enum</code> variants can be done only by a macro:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">enum</code> <code class="nc">Multi</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Byte</code><code class="p">(</code><code class="kt">u8</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">Int</code><code class="p">(</code><code class="kt">i32</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">Str</code><code class="p">(</code><code class="nb">String</code><code class="p">),</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="sd">/// Extract copies of all the values of a specific enum variant.</code>
<code class="cp">#[macro_export]</code><code class="w"></code>
<code class="fm">macro_rules!</code><code class="w"> </code><code class="n">values_of_type</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$values</code>:<code class="nc">expr</code><code class="p">,</code><code class="w"> </code><code class="cp">$variant</code>:<code class="nc">ident</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="n">val</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="cp">$values</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="n">Multi</code>::<code class="cp">$variant</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">val</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                    </code><code class="n">result</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="n">v</code><code class="p">.</code><code class="n">clone</code><code class="p">());</code><code class="w"></code>
<code class="w">                </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="n">result</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>

<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">values</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="fm">vec!</code><code class="p">[</code><code class="w"></code>
<code class="w">        </code><code class="n">Multi</code>::<code class="n">Byte</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="n">Multi</code>::<code class="n">Int</code><code class="p">(</code><code class="mi">1000</code><code class="p">),</code><code class="w"></code>
<code class="w">        </code><code class="n">Multi</code>::<code class="n">Str</code><code class="p">(</code><code class="s">"a string"</code><code class="p">.</code><code class="n">to_string</code><code class="p">()),</code><code class="w"></code>
<code class="w">        </code><code class="n">Multi</code>::<code class="n">Byte</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="p">];</code><code class="w"></code>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">ints</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">values_of_type</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">values</code><code class="p">,</code><code class="w"> </code><code class="n">Int</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Integer values: {ints:?}"</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">bytes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">values_of_type</code><code class="o">!</code><code class="p">(</code><code class="o">&amp;</code><code class="n">values</code><code class="p">,</code><code class="w"> </code><code class="n">Byte</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"Byte values: {bytes:?}"</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Output:</code>
<code class="w">    </code><code class="c1">//   Integer values: [1000]</code>
<code class="w">    </code><code class="c1">//   Byte values: [1, 2]</code>
<code class="p">}</code><code class="w"></code></pre>

<p>Another scenario where macros help avoid manual repetition is when information about a collection of data values would
otherwise be spread out across different areas of the code.</p>

<p>For example, consider a data structure that <a data-primary="data structures" data-secondary="using macros to avoid code repetition" data-type="indexterm" id="OEBPS/ch05.html.id1753"></a>encodes information about HTTP status codes; a macro can help keep all of
the related information together:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// http.rs module</code>

<code class="cp">#[derive(Debug, PartialEq, Eq, Clone, Copy)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">enum</code> <code class="nc">Group</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Informational</code><code class="p">,</code><code class="w"> </code><code class="c1">// 1xx</code>
<code class="w">    </code><code class="n">Successful</code><code class="p">,</code><code class="w">    </code><code class="c1">// 2xx</code>
<code class="w">    </code><code class="n">Redirection</code><code class="p">,</code><code class="w">   </code><code class="c1">// 3xx</code>
<code class="w">    </code><code class="n">ClientError</code><code class="p">,</code><code class="w">   </code><code class="c1">// 4xx</code>
<code class="w">    </code><code class="n">ServerError</code><code class="p">,</code><code class="w">   </code><code class="c1">// 5xx</code>
<code class="p">}</code><code class="w"></code>

<code class="c1">// Information about HTTP response codes.</code>
<code class="n">http_codes</code><code class="o">!</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">Continue</code><code class="w">           </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="n">Informational</code><code class="p">,</code><code class="w"> </code><code class="s">"Continue"</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">SwitchingProtocols</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="mi">101</code><code class="p">,</code><code class="w"> </code><code class="n">Informational</code><code class="p">,</code><code class="w"> </code><code class="s">"Switching Protocols"</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="w">    </code><code class="nb">Ok</code><code class="w">                 </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="mi">200</code><code class="p">,</code><code class="w"> </code><code class="n">Successful</code><code class="p">,</code><code class="w"> </code><code class="s">"Ok"</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="n">Created</code><code class="w">            </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="mi">201</code><code class="p">,</code><code class="w"> </code><code class="n">Successful</code><code class="p">,</code><code class="w"> </code><code class="s">"Created"</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>The macro invocation holds all the related information—numeric value, group, description—for each HTTP
status code, acting as a kind of  domain-specific language (DSL) holding the source of truth for the data.<a data-primary="domain-specific language (DSL)" data-type="indexterm" id="OEBPS/ch05.html.id1754"></a></p>

<p>The macro definition then describes the generated code; each line of the form <code><span class="keep-together">$( ... )+</span></code> expands to multiple lines in
the generated code, one per argument to the macro:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">macro_rules!</code><code class="w"> </code><code class="n">http_codes</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$(</code><code class="w"> </code><code class="cp">$name</code>:<code class="nc">ident</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="cp">$val</code>:<code class="nc">literal</code><code class="p">,</code><code class="w"> </code><code class="cp">$group</code>:<code class="nc">ident</code><code class="p">,</code><code class="w"> </code><code class="cp">$text</code>:<code class="nc">literal</code><code class="p">),</code><code class="w"> </code><code class="p">)</code><code class="o">+</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="cp">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</code><code class="w"></code>
<code class="w">        </code><code class="cp">#[repr(i32)]</code><code class="w"></code>
<code class="w">        </code><code class="k">enum</code> <code class="nc">Status</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="cp">$(</code><code class="w"> </code><code class="cp">$name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="cp">$val</code><code class="p">,</code><code class="w"> </code><code class="p">)</code><code class="o">+</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">impl</code><code class="w"> </code><code class="n">Status</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">fn</code> <code class="nf">group</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Group</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                    </code><code class="cp">$(</code><code class="w"> </code><code class="bp">Self</code>::<code class="cp">$name</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">Group</code>::<code class="cp">$group</code><code class="p">,</code><code class="w"> </code><code class="p">)</code><code class="o">+</code><code class="w"></code>
<code class="w">                </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="k">fn</code> <code class="nf">text</code><code class="p">(</code><code class="o">&amp;</code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="o">'</code><code class="nb">static</code> <code class="kt">str</code> <code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">match</code><code class="w"> </code><code class="bp">self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                    </code><code class="cp">$(</code><code class="w"> </code><code class="bp">Self</code>::<code class="cp">$name</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="cp">$text</code><code class="p">,</code><code class="w"> </code><code class="p">)</code><code class="o">+</code><code class="w"></code>
<code class="w">                </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="k">impl</code><code class="w"> </code><code class="n">core</code>::<code class="n">convert</code>::<code class="n">TryFrom</code><code class="o">&lt;</code><code class="kt">i32</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">Status</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="k">type</code> <code class="nc">Error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">();</code><code class="w"></code>
<code class="w">            </code><code class="k">fn</code> <code class="nf">try_from</code><code class="p">(</code><code class="n">v</code>: <code class="kt">i32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="bp">Self</code><code class="p">,</code><code class="w"> </code><code class="bp">Self</code>::<code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="k">match</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                    </code><code class="cp">$(</code><code class="w"> </code><code class="cp">$val</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Ok</code><code class="p">(</code><code class="bp">Self</code>::<code class="cp">$name</code><code class="p">),</code><code class="w"> </code><code class="p">)</code><code class="o">+</code><code class="w"></code>
<code class="w">                    </code><code class="n">_</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="nb">Err</code><code class="p">(())</code><code class="w"></code>
<code class="w">                </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>As a result, the overall output from the macro takes care of generating all of the code that derives from the
source-of-truth values:</p>

<ul>
<li>
<p>The <a data-primary="enums" data-secondary="avoiding code repetition with macros" data-type="indexterm" id="OEBPS/ch05.html.id1755"></a>definition of an <code>enum</code> holding all the variants</p>
</li>
<li>
<p>The definition of a <code>group()</code> method, which indicates which group an HTTP status belongs to</p>
</li>
<li>
<p>The definition of a <code>text()</code> method, which maps a status to a text description</p>
</li>
<li>
<p>An implementation of <code>TryFrom&lt;i32&gt;</code> to convert numbers to status <code>enum</code> values<a data-primary="TryFrom trait" data-type="indexterm" id="OEBPS/ch05.html.id1756"></a></p>
</li>
</ul>

<p>If an extra value needs to be added later, all that’s needed is a single additional line:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="n">ImATeapot</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="mi">418</code><code class="p">,</code><code class="w"> </code><code class="n">ClientError</code><code class="p">,</code><code class="w"> </code><code class="s">"I'm a teapot"</code><code class="p">),</code><code class="w"></code></pre>

<p>Without the macro, four different places would have to be manually updated.  The compiler would point out some of them
(because <code>match</code> expressions need to cover all cases) but not all—<code>TryFrom&lt;i32&gt;</code> could easily be forgotten.<a data-primary="match expressions" data-type="indexterm" id="OEBPS/ch05.html.id1757"></a></p>

<p>Because macros are expanded in place <a data-primary="diagnostic information from macros" data-type="indexterm" id="OEBPS/ch05.html.id1758"></a><a data-primary="file! MACRO" data-type="indexterm" id="OEBPS/ch05.html.id1759"></a><a data-primary="line! macro" data-type="indexterm" id="OEBPS/ch05.html.id1760"></a>in the invoking code, they can also be used to automatically emit additional
diagnostic information—in particular, by using the standard library’s
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.file.html"><code>file!()</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.line.html"><code>line!()</code></a> macros, which emit source code location information:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="fm">macro_rules!</code><code class="w"> </code><code class="n">log_failure</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="cp">$e</code>:<code class="nc">expr</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="cp">$e</code><code class="p">;</code><code class="w"></code>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nb">Err</code><code class="p">(</code><code class="n">err</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&amp;</code><code class="n">result</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">                </code><code class="fm">eprintln!</code><code class="p">(</code><code class="s">"{}:{}: operation '{}' failed: {:?}"</code><code class="p">,</code><code class="w"></code>
<code class="w">                          </code><code class="fm">file!</code><code class="p">(),</code><code class="w"></code>
<code class="w">                          </code><code class="fm">line!</code><code class="p">(),</code><code class="w"></code>
<code class="w">                          </code><code class="fm">stringify!</code><code class="p">(</code><code class="cp">$e</code><code class="p">),</code><code class="w"></code>
<code class="w">                          </code><code class="n">err</code><code class="p">);</code><code class="w"></code>
<code class="w">            </code><code class="p">}</code><code class="w"></code>
<code class="w">            </code><code class="n">result</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>When failures occur, the log file then automatically includes details of what failed and where:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">convert</code>::<code class="n">TryInto</code><code class="p">;</code><code class="w"></code>

<code class="kd">let</code><code class="w"> </code><code class="n">x</code>: <code class="nb">Result</code><code class="o">&lt;</code><code class="kt">u8</code><code class="p">,</code><code class="w"> </code><code class="n">_</code><code class="o">&gt;</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">log_failure</code><code class="o">!</code><code class="p">(</code><code class="mf">512.</code><code class="n">try_into</code><code class="p">());</code><code class="w"> </code><code class="c1">// too big for `u8`</code>
<code class="kd">let</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">log_failure</code><code class="o">!</code><code class="p">(</code><code class="n">std</code>::<code class="kt">str</code>::<code class="n">from_utf8</code><code class="p">(</code><code class="s">b"</code><code class="se">\xc3\x28</code><code class="s">"</code><code class="p">));</code><code class="w"> </code><code class="c1">// invalid UTF-8</code></pre>

<pre data-code-language="text" data-type="programlisting">src/main.rs:340: operation '512.try_into()' failed: TryFromIntError(())
src/main.rs:341: operation 'std::str::from_utf8(b"\xc3\x28")' failed:
                 Utf8Error { valid_up_to: 0, error_len: Some(1) }</pre>
</div></section>








<section data-pdf-bookmark="Disadvantages of Macros" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id137">
<h2>Disadvantages of Macros</h2>

<p>The primary disadvantage of using a macro is the impact that it has on code readability<a data-primary="macros" data-secondary="disadvantages of" data-type="indexterm" id="OEBPS/ch05.html.id1761"></a> and maintainability. <a data-type="xref" href="#OEBPS/ch05.html.declarative-macros">“Declarative Macros”</a> explains that macros allow you to create a DSL to
concisely express key features of your code and data. However, this means that anyone reading or maintaining the code
now has to understand this DSL—and its implementation in macro definitions—in addition to understanding
Rust.  For example, the <code>http_codes!</code> example in the previous section creates a Rust <code>enum</code> named <code>Status</code>, but it’s not
visible in the DSL used for the macro invocation.<a data-primary="enums" data-secondary="disadvantage of macros for" data-type="indexterm" id="OEBPS/ch05.html.id1762"></a></p>

<p>This potential impenetrability of macro-based code extends beyond other engineers: various tools that analyze and
interact with Rust code may treat the code as opaque, because it no longer follows the syntactical conventions of Rust
code.<a data-primary="square_once! macro" data-type="indexterm" id="OEBPS/ch05.html.id1763"></a><a data-primary="rustfmt, inapplicability to macro invocations" data-type="indexterm" id="OEBPS/ch05.html.id1764"></a>  The <code>square_once!</code> macro shown earlier provided one trivial example of this: the body of the macro has not been
formatted according to the normal  <code>rustfmt</code> rules:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="cp">$e</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// The `rustfmt` tool doesn't really cope with code in</code>
<code class="w">    </code><code class="c1">// macros, so this has not been reformatted to `x * x`.</code>
<code class="w">    </code><code class="n">x</code><code class="o">*</code><code class="n">x</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Another example is the earlier <code>http_codes!</code> macro, where the DSL uses <code>Group</code> enum variant names like <code>Informational</code>
with neither a <code>Group::</code> prefix nor a <code>use</code> statement, which may confuse some code navigation tools.<a data-primary="Group enum" data-type="indexterm" id="OEBPS/ch05.html.id1765"></a></p>

<p>Even the compiler itself is less helpful: its error messages don’t always follow the chain of macro use and definition.<a data-primary="tooling" data-type="indexterm" id="OEBPS/ch05.html.id1766"></a><a data-primary="cargo-expand" data-type="indexterm" id="OEBPS/ch05.html.id1767"></a>
(However, there are parts of the tooling ecosystem [see <a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a>] that can help with this, such as  David Tolnay’s  <a class="orm:hideurl" href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>, used earlier.)</p>

<p>Another possible<a data-primary="code bloat with macro use" data-type="indexterm" id="OEBPS/ch05.html.id1768"></a> downside for macro use is the possibility of code bloat—a single line of macro invocation can
result in hundreds of lines of generated code, which will be invisible to a cursory survey of the code.  This is less
likely to be a problem when the code is first written, because at that point the code is needed and saves the humans
involved from having to write it themselves.  However, if the code subsequently stops being necessary, it’s not so
obvious that there are large amounts of code that could be deleted.</p>
</div></section>








<section data-pdf-bookmark="Advice" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id138">
<h2>Advice</h2>

<p>Although the previous section listed some downsides of macros, they are still fundamentally the right tool for the<a data-primary="macros" data-secondary="general advice on use of" data-type="indexterm" id="OEBPS/ch05.html.id1769"></a> job
when there are different chunks of code that need to be kept consistent but that cannot be coalesced any other way:
<em>use a macro whenever it’s the only way to ensure that disparate code stays in sync</em>.</p>

<p>Macros are also the tool to reach for when there’s boilerplate code to be squashed: <em>use a macro for repeated
boilerplate code</em> that can’t be coalesced into a function or a generic.</p>

<p>To reduce the impact on readability, try to avoid syntax in your macros that clashes with Rust’s normal syntax rules;
either make the macro invocation look like normal code or make it look sufficiently <em>different</em> so that no one could
confuse the two.  In particular, follow these guidelines:</p>

<ul>
<li>
<p><em>Avoid macro expansions that insert references</em> where <a data-primary="references" data-secondary="macro expansions that insert, avoiding" data-type="indexterm" id="OEBPS/ch05.html.id1770"></a>possible—a macro invocation like <code>my_macro!(&amp;list)</code>
aligns better with normal Rust code than <code>my_macro!(list)</code> would.</p>
</li>
<li>
<p><em>Prefer to avoid nonlocal control flow operations in macros</em> so that anyone reading the code is able to<a data-primary="control flow" data-secondary="avoiding nonlocal operations in macros" data-type="indexterm" id="OEBPS/ch05.html.id1771"></a>
follow the flow without needing to know the details of the macro.</p>
</li>
</ul>

<p>This preference for Rust-like readability sometimes affects the choice between declarative macros and procedural macros.<a data-primary="declarative macros" data-type="indexterm" id="OEBPS/ch05.html.id1772"></a><a data-primary="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.id1773"></a><a data-primary="derive macros" data-secondary="preferring to procedural macro that emits a type" data-type="indexterm" id="OEBPS/ch05.html.id1774"></a>
If you need to emit code for each field of a structure, or each variant of an enum, <em>prefer a  derive macro to a procedural macro that emits a type</em> (despite the example shown in <a data-type="xref" href="#OEBPS/ch05.html.when_macros_sect">“When to Use Macros”</a>)—it’s more idiomatic and makes the code easier to read.</p>

<p>However, if you’re adding a derive macro with functionality that’s not specific to your project, check whether an
external crate already provides what you need (see <a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).  For <a data-primary="enums" data-type="indexterm" id="OEBPS/ch05.html.id1775"></a><a data-primary="crates" data-secondary="external, using instead of macros" data-type="indexterm" id="OEBPS/ch05.html.id1776"></a>example, the problem of converting integer values
into the appropriate variant of a C-like  <code>enum</code> is well-covered: all of
<a class="orm:hideurl" href="https://docs.rs/enumn/latest/enumn/derive.N.html"><code>enumn::N</code></a>,
<a class="orm:hideurl" href="https://docs.rs/num_enum/latest/num_enum/derive.TryFromPrimitive.html"><code>num_enum::TryFromPrimitive</code></a>,
<a class="orm:hideurl" href="https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html"><code>num_derive::FromPrimitive</code></a>, and
<a class="orm:hideurl" href="https://docs.rs/strum/latest/strum/derive.FromRepr.html"><code>strum::FromRepr</code></a> cover some aspect of this 
<span class="keep-together">problem</span>.<a data-primary="macros" data-startref="ix_mcro" data-type="indexterm" id="OEBPS/ch05.html.id1777"></a></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 29: Listen to Clippy" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_clippy_md">
<h1>Item 29: Listen to Clippy</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>It looks like you’re writing a letter. Would you like help?</p>
<p data-type="attribution">Microsoft Clippit</p>
</blockquote>

<p><a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a> describes the ecosystem <a data-primary="Clippy" data-type="indexterm" id="OEBPS/ch05.html.ix_Clpy"></a><a data-primary="Microsoft Clippit" data-type="indexterm" id="OEBPS/ch05.html.id1778"></a><a data-primary="Clippit" data-type="indexterm" id="OEBPS/ch05.html.id1779"></a>of helpful tools available in the Rust toolbox, but one tool is sufficiently helpful and
important to get promoted to an Item of its very own:  <a class="orm:hideurl" href="https://github.com/rust-lang/rust-clippy#clippy">Clippy</a>.</p>

<p>Clippy is an additional component for  Cargo (<code>cargo clippy</code>) that emits warnings about your <a data-primary="warnings about Rust usage (Clippy)" data-type="indexterm" id="OEBPS/ch05.html.id1780"></a><a data-primary="Clippy" data-secondary="warnings about Rust usage" data-type="indexterm" id="OEBPS/ch05.html.id1781"></a>Rust usage, across
a variety of categories:</p>
<dl>
<dt><em>Correctness</em></dt>
<dd>
<p>Warns about common programming errors</p>
</dd>
<dt><em>Idiom</em></dt>
<dd>
<p>Warns about code<a data-primary="idioms, warning about" data-type="indexterm" id="OEBPS/ch05.html.id1782"></a> constructs that aren’t quite in standard Rust style</p>
</dd>
<dt><em>Concision</em></dt>
<dd>
<p>Points out variations<a data-primary="concision" data-type="indexterm" id="OEBPS/ch05.html.id1783"></a> on the code that are more compact</p>
</dd>
<dt><em>Performance</em></dt>
<dd>
<p>Suggests alternatives<a data-primary="performance" data-type="indexterm" id="OEBPS/ch05.html.id1784"></a> that avoid unnecessary processing or allocation</p>
</dd>
<dt><em>Readability</em></dt>
<dd>
<p>Describes alterations to the code that would make it easier for humans to read and understand<a data-primary="readability" data-type="indexterm" id="OEBPS/ch05.html.id1785"></a></p>
</dd>
</dl>

<p>For example, the following code builds fine:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1786">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">circle_area</code><code class="p">(</code><code class="n">radius</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">pi</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.14</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="n">pi</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>but Clippy points out <a data-primary="π" data-type="indexterm" id="OEBPS/ch05.html.id1787"></a>that the local approximation to  π is unnecessary and inaccurate:</p>

<pre data-code-language="text" data-type="programlisting">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:5:18
  |
5 |         let pi = 3.14;
  |                  ^^^^
  |
  = help: consider using the constant directly
  = help: for further information visit
    https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
  = note: `#[deny(clippy::approx_constant)]` on by default</pre>

<p>The linked webpage explains the problem and points the way to a suitable modification of the code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">circle_area</code><code class="p">(</code><code class="n">radius</code>: <code class="kt">f64</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">f64</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">std</code>::<code class="kt">f64</code>::<code class="n">consts</code>::<code class="n">PI</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">radius</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>As shown previously, each Clippy warning comes with a link to a webpage describing the error, which explains <em>why</em> the code
is considered bad.<a data-primary="Clippy" data-secondary="links to webpage describing error" data-type="indexterm" id="OEBPS/ch05.html.id1788"></a>  This is vital, because it allows you to decide whether those reasons apply to your code or whether
there is some particular reason why the lint check isn’t relevant.<a data-primary="lint" data-seealso="Clippy" data-type="indexterm" id="OEBPS/ch05.html.id1789"></a>  In some cases, the text also describes known
problems with the lint, which might explain an otherwise confusing false positive.</p>

<p>If you decide that a lint warning isn’t relevant for your code, you <a data-primary="allow attribute" data-type="indexterm" id="OEBPS/ch05.html.id1790"></a>can disable it either for that particular item
 (<code>#[allow(clippy::some_lint)]</code>) or for the entire crate (<code>#![allow(clippy::some_lint)]</code>, with an extra
<code>!</code>, at the top level).  However, it’s usually better to take the cost of a minor refactoring of the code than to
waste time and energy arguing about whether the warning is a genuine false positive.</p>

<p>Whether you choose to fix or disable the warnings, you should <em>make your code Clippy-warning free</em>.</p>

<p>That way, when new warnings appear—whether because the code has been changed or because<a data-primary="continuous integration" data-type="indexterm" id="OEBPS/ch05.html.id1791"></a> Clippy has been
upgraded to include new checks—they will be obvious. Clippy should also be enabled in your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>).</p>

<p>Clippy’s warnings are particularly helpful when you’re learning Rust, because they reveal gotchas you might not have
noticed and help you become familiar with Rust idiom.</p>

<p>Many of the Items in this book also have corresponding Clippy warnings, when it’s possible to mechanically check the
relevant <a data-primary="Clippy" data-secondary="warnings corresponding to Items in this book" data-type="indexterm" id="OEBPS/ch05.html.id1792"></a><a data-primary="parameters (function), limiting" data-type="indexterm" id="OEBPS/ch05.html.id1793"></a>concern:</p>

<ul>
<li>
<p><a href="#OEBPS/ch01.html.file_use-types_md">Item 1</a> suggests using more<a data-primary="bool type" data-type="indexterm" id="OEBPS/ch05.html.id1794"></a> expressive types than plain <code>bool</code>s, and Clippy will also point out the use of multiple
 <code>bool</code>s in <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#fn_params_excessive_bools">function parameters</a> and
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#struct_excessive_bools">structures</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_transform_md">Item 3</a> covers manipulations of <code>Option</code> and <code>Result</code> types, and Clippy points out a few<a data-primary="Result type" data-secondary="manipulations of, Clippy pointing out redundancies" data-type="indexterm" id="OEBPS/ch05.html.id1795"></a> possible
redundancies, such as the following:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#ok_expect">Unnecessarily converting <code>Result</code> to <code>Option</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#unwrap_or_else_default">Opportunities to use <code>unwrap_or_default</code></a></p>
</li>
</ul>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_transform_md">Item 3</a> also suggests that errors <a data-primary="errors" data-type="indexterm" id="OEBPS/ch05.html.id1796"></a>should be returned to the caller where possible; Clippy <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#unwrap_in_result">points out some missing opportunities to do that</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a> suggests<a data-primary="Into trait" data-type="indexterm" id="OEBPS/ch05.html.id1797"></a> implementing <code>From</code> rather than <code>Into</code>, which <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#from_over_into">Clippy also suggests</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_casts_md">Item 5</a> also describes<a data-primary="casts" data-type="indexterm" id="OEBPS/ch05.html.id1798"></a> casts, and Clippy has (disabled by default) warnings for the following:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#cast_lossless"><code>as</code> casts that could be <code>from</code> instead</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#cast_possible_truncation"><code>as</code> casts that might truncate</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#cast_possible_wrap"><code>as</code> casts that might wrap</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#cast_precision_loss"><code>as</code> casts that lose precision</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#cast_sign_loss"><code>as</code> casts that might convert signed negative numbers to large positive numbers</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#as_conversions"><em>any</em> use of <code>as</code></a></p>
</li>
</ul>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_references_md">Item 8</a> describes  fat <a data-primary="fat pointers" data-type="indexterm" id="OEBPS/ch05.html.id1799"></a>pointer types, and various Clippy
lints point out scenarios where<a data-primary="pointers" data-secondary="unnecessary pointer indirections" data-type="indexterm" id="OEBPS/ch05.html.id1800"></a><a data-primary="Box type" data-type="indexterm" id="OEBPS/ch05.html.id1801"></a><a data-primary="heap" data-type="indexterm" id="OEBPS/ch05.html.id1802"></a> there are unnecessary extra pointer indirections:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#box_collection">Holding a heap-allocated collection in a <code>Box</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#vec_box">Holding a heap-allocated collection of <code>Box</code> items</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#borrowed_box">Taking a reference to a <code>Box</code></a></p>
</li>
</ul>
</li>
<li>
<p><a href="#OEBPS/ch01.html.file_iterators_md">Item 9</a> describes the myriad ways<a data-primary="Iterator trait" data-secondary="manipulation of, methods" data-type="indexterm" id="OEBPS/ch05.html.id1803"></a> to manipulate  <code>Iterator</code> instances; Clippy
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#explicit_counter_loop">includes</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#explicit_iter_loop">a</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#explicit_into_iter_loop">truly</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#filter_map_identity">astonishing</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#from_iter_instead_of_collect">number</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#into_iter_on_ref">of</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#iter_count">lints</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#iter_next_loop">that</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#iter_not_returning_iterator">point</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#manual_filter_map">out</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#manual_find_map">combinations</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#map_clone">of</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#needless_range_loop">iterator</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#search_is_some">methods</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#skip_while_next">that</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#suspicious_map">could</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#unnecessary_filter_map">be</a>
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#unnecessary_fold">simplified</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch02.html.file_std-traits_md">Item 10</a> describes Rust’s<a data-primary="traits" data-secondary="standard traits" data-tertiary="implementation checks by Clippy" data-type="indexterm" id="OEBPS/ch05.html.id1804"></a> standard traits and included some implementation requirements that Clippy checks:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#derive_ord_xor_partial_ord"><code>Ord</code> must agree with <code>PartialOrd</code></a>.</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#partialeq_ne_impl"><code>PartialEq::ne</code> should not need a nondefault implementation</a> (see <a href="#OEBPS/ch02.html.file_default-impl_md">Item 13</a>).</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#derived_hash_with_manual_eq"><code>Hash</code> and <code>Eq</code> must be consistent</a>.</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#expl_impl_clone_on_copy"><code>Clone</code> for <code>Copy</code> types should match</a>.</p>
</li>
</ul>
</li>
<li>
<p><a href="#OEBPS/ch03.html.file_panic_md">Item 18</a> suggests <a data-primary="panics" data-secondary="Clippy checks for use of" data-type="indexterm" id="OEBPS/ch05.html.id1805"></a>limiting the use of
 <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#panic"><code>panic!</code></a> or related methods like
 <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#expect_used"><code>expect</code></a>, which Clippy also
detects.<a data-primary="expect method" data-type="indexterm" id="OEBPS/ch05.html.id1806"></a></p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_semver_md">Item 21</a> observes <a data-primary="wildcard imports" data-secondary="Clippy checks on" data-type="indexterm" id="OEBPS/ch05.html.id1807"></a>that importing a  wildcard version of a crate isn’t sensible; Clippy
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#wildcard_dependencies">agrees</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_wildcard_md">Item 23</a> suggests avoiding  wildcard imports, as does
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#wildcard_imports">Clippy</a>.</p>
</li>
<li>
<p>Items <a href="#OEBPS/ch04.html.file_re-export_md">24</a> and <a href="#OEBPS/ch04.html.file_dep-graph_md">25</a> touch on the fact that multiple versions of the <a data-primary="crates" data-secondary="multiple versions in dependency graph" data-type="indexterm" id="OEBPS/ch05.html.id1808"></a><a data-primary="dependency graph" data-secondary="multiple versions of a crate in" data-type="indexterm" id="OEBPS/ch05.html.id1809"></a>same crate can appear in your dependency graph;
Clippy can be configured to <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#multiple_crate_versions">complain when this happens</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_features_md">Item 26</a> explains the additive nature of Cargo  features, and Clippy includes a warning about <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#negative_feature_names">“negative” feature names</a> (e.g., <code>"no_std"</code>) that
are likely to indicate a feature that falls foul of this.<a data-primary="features" data-type="indexterm" id="OEBPS/ch05.html.id1810"></a></p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_features_md">Item 26</a> also explains that a crate’s optional dependencies form part of its feature set, and Clippy warns if there
are <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#redundant_feature_names">explicit feature names (e.g., <code>"use-crate-x"</code>)</a> that
could just make use of this instead.</p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a> describes <a data-primary="documentation" data-secondary="conventions for documentation comments" data-type="indexterm" id="OEBPS/ch05.html.id1811"></a><a data-primary="unsafe code" data-secondary="documenting" data-type="indexterm" id="OEBPS/ch05.html.id1812"></a>conventions for documentation comments, and Clippy will also point out the following:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#missing_panics_doc">Missing descriptions of <code>panic!</code>s</a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#missing_safety_doc">Missing descriptions</a> of   <a class="orm:hideurl" href="https://rust-lang.github.io/rust-clippy/stable/index.html#undocumented_unsafe_blocks"><code>unsafe</code> concerns</a></p>
</li>
</ul>
</li>
</ul>

<p>As the size of this list should make clear, it can be a valuable learning experience to <em>read the <a href="https://oreil.ly/Nt5zE">list of Clippy lint warnings</a></em>—including the checks
that are disabled by default because they are overly pedantic or because they have a high rate of false positives. Even
though you’re unlikely to want to enable these warnings for your code, understanding the reasons why they were written
in the first place will improve your understanding of Rust and its idiom.<a data-primary="Clippy" data-startref="ix_Clpy" data-type="indexterm" id="OEBPS/ch05.html.id1813"></a></p>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 30: Write more than unit tests" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_testing_md">
<h1>Item 30: Write more than unit tests</h1>
<blockquote data-type="epigraph" epub:type="epigraph">
<p>All companies have test environments.</p>
<p>The lucky ones have production environments separate from the test environment.</p>
<p data-type="attribution"><a href="https://oreil.ly/UzBRq">@FearlessSon</a></p>
</blockquote>

<p>Like most other modern languages, Rust includes features that make it easy to  <a class="orm:hideurl" href="https://doc.rust-lang.org/book/ch11-00-testing.html">write tests</a> that live alongside your code
and that give you confidence that the code is working 
<span class="keep-together">correctly.</span><a data-primary="@FearlessSon" data-primary-sortas="Fearless" data-type="indexterm" id="OEBPS/ch05.html.id1814"></a><a data-primary="tests" data-type="indexterm" id="OEBPS/ch05.html.ix_test"></a></p>

<p>This isn’t the place to expound on the importance of tests; suffice it to say that if code isn’t tested, it probably
doesn’t work the way you think it does.  So this Item assumes that you’re already signed up to <em>write tests for
your code</em>.</p>

<p>Unit tests and integration tests, described in the next two sections, are the key forms of tests. However, the Rust
toolchain, and extensions to the toolchain, allow for various other types of tests.  This Item describes their distinct
logistics and rationales.</p>








<section data-pdf-bookmark="Unit Tests" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id141">
<h2>Unit Tests</h2>

<p>The most common form of test for<a data-primary="tests" data-secondary="unit tests" data-type="indexterm" id="OEBPS/ch05.html.ix_testunit"></a><a data-primary="unit tests" data-type="indexterm" id="OEBPS/ch05.html.ix_unit"></a> Rust code is a  unit test, which might look something like this:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// ... (code defining `nat_subtract*` functions for natural</code>
<code class="c1">//      number subtraction)</code>

<code class="cp">#[cfg(test)]</code><code class="w"></code>
<code class="k">mod</code> <code class="nn">tests</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">use</code><code class="w"> </code><code class="k">super</code>::<code class="o">*</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="cp">#[test]</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">test_nat_subtract</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">nat_subtract</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">).</code><code class="n">unwrap</code><code class="p">(),</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">nat_subtract</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">),</code><code class="w"> </code><code class="nb">None</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>

<code class="w">    </code><code class="cp">#[should_panic]</code><code class="w"></code>
<code class="w">    </code><code class="cp">#[test]</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">test_something_that_panics</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="n">nat_subtract_unchecked</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Some aspects of this example <a data-primary="unit tests" data-secondary="common elements" data-type="indexterm" id="OEBPS/ch05.html.id1815"></a>will appear in every unit test:</p>

<ul>
<li>
<p>A collection of unit test functions.<a data-primary="test attribute" data-type="indexterm" id="OEBPS/ch05.html.id1816"></a></p>
</li>
<li>
<p>Each test function is marked with the <code>#[test]</code> attribute.</p>
</li>
<li>
<p>The module holding the test functions is annotated with a <code>#[cfg(test)]</code> attribute, so the code gets built only in test configurations.<a data-primary="cfg(test) attribute" data-type="indexterm" id="OEBPS/ch05.html.id1817"></a></p>
</li>
</ul>

<p>Other aspects of this example illustrate things that are optional and may be relevant only<a data-primary="unit tests" data-secondary="optional elements" data-type="indexterm" id="OEBPS/ch05.html.id1818"></a> for particular tests:</p>

<ul>
<li>
<p>The test code here is held in a separate  module, conventionally called <code>tests</code> or <code>test</code>.  <a data-primary="modules" data-secondary="tests or test" data-type="indexterm" id="OEBPS/ch05.html.id1819"></a>This module may be
inline (as here) or held in a separate <em>tests.rs</em> file.<a data-primary="test modules" data-type="indexterm" id="OEBPS/ch05.html.id1820"></a>  Using a separate file for the test module has the advantage
that it’s easier to spot whether code that uses a function is test code or “real” code.</p>
</li>
<li>
<p>The test module might have a wildcard <code>use super::*</code> to pull in everything from the parent module under test.  This
makes it more convenient to add tests (and is an exception to the general advice in <a href="#OEBPS/ch04.html.file_wildcard_md">Item 23</a> to avoid wildcard
imports).</p>
</li>
<li>
<p>The normal visibility rules for modules mean that a unit test has the ability to use anything from the parent module,
whether it is  <code>pub</code> or not.<a data-primary="visibility" data-secondary="unit tests and" data-type="indexterm" id="OEBPS/ch05.html.id1821"></a>  This allows for  “open-box” testing of the code, where the unit
tests exercise internal features that aren’t visible to normal users.</p>
</li>
<li>
<p>The test code makes use of <code>expect()</code> or <code>unwrap()</code> for its expected results.<a data-primary="expect method" data-type="indexterm" id="OEBPS/ch05.html.id1822"></a><a data-primary="unwrap method" data-type="indexterm" id="OEBPS/ch05.html.id1823"></a>  The advice in <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a> isn’t really
relevant for test-only code, where <code>panic!</code> is used to signal a failing test.<a data-primary="panics" data-secondary="signaling failing test" data-type="indexterm" id="OEBPS/ch05.html.id1824"></a><a data-primary="assert_eq! macro" data-type="indexterm" id="OEBPS/ch05.html.id1825"></a>  Similarly, the test code also checks
expected results with <code>assert_eq!</code>, which will panic on failure.</p>
</li>
<li>
<p>The code under test includes a function that panics on some kinds of invalid input; to exercise that, there’s a unit test function that’s marked with the <code>#[should_panic]</code> attribute. <a data-primary="should_panic attribute" data-type="indexterm" id="OEBPS/ch05.html.id1826"></a><a data-primary="panics" data-secondary="function that panics on invalid input" data-type="indexterm" id="OEBPS/ch05.html.id1827"></a><a data-primary="invariants" data-type="indexterm" id="OEBPS/ch05.html.id1828"></a><a data-primary="preconditions" data-type="indexterm" id="OEBPS/ch05.html.id1829"></a>This might be needed when testing an internal function that normally expects the rest of the code to respect its invariants and preconditions, or it might be a public function that has some reason to ignore the advice in <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>. (Such a function should have a “Panics” section in its doc comment, as described in <a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a>.)</p>
</li>
</ul>

<p><a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a> suggests <em>not</em> documenting things that are already expressed by the type system.  <a data-primary="type system" data-secondary="not documenting things already expressed by" data-type="indexterm" id="OEBPS/ch05.html.id1830"></a><a data-primary="enums" data-secondary="holding values not in list of allowed variants" data-type="indexterm" id="OEBPS/ch05.html.id1831"></a>Similarly, there’s no need to
test things that are guaranteed by the type system. If your <code>enum</code> types start holding values that aren’t in the
list of allowed variants, you’ve got bigger problems than a failing unit test!</p>

<p>However, if your code relies on specific functionality from your dependencies, it can be helpful to include basic tests
of that functionality.<a data-primary="dependencies" data-secondary="testing functionality of" data-type="indexterm" id="OEBPS/ch05.html.id1832"></a>  The aim here is not to repeat testing that’s already done by the dependency itself but instead
to have an early warning system that indicates whether the behavior that you need from the dependency has
changed—separately from whether the public API signature has changed, as indicated by the  semantic version number (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>).<a data-primary="tests" data-secondary="unit tests" data-startref="ix_testunit" data-type="indexterm" id="OEBPS/ch05.html.id1833"></a><a data-primary="unit tests" data-startref="ix_unit" data-type="indexterm" id="OEBPS/ch05.html.id1834"></a></p>
</div></section>








<section data-pdf-bookmark="Integration Tests" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id142">
<h2>Integration Tests</h2>

<p>The other common form of test included <a data-primary="integration tests" data-type="indexterm" id="OEBPS/ch05.html.id1835"></a><a data-primary="tests" data-secondary="integration tests" data-type="indexterm" id="OEBPS/ch05.html.id1836"></a>with a Rust project is  <em>integration tests</em>, held under
<em>tests/</em>.  Each file in that directory is run as a separate test program that executes all of the functions marked with
<code>#[test]</code>.</p>

<p>Integration tests do <em>not</em> have access to crate internals and so act as  behavior tests that can exercise only
the public API of the crate.<a data-primary="behavior tests" data-type="indexterm" id="OEBPS/ch05.html.id1837"></a></p>
</div></section>








<section data-pdf-bookmark="Doc Tests" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id143">
<h2>Doc Tests</h2>

<p><a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a> described the inclusion of short code samples in documentation comments, to illustrate the use of a particular
public API item.<a data-primary="doc tests" data-type="indexterm" id="OEBPS/ch05.html.id1838"></a><a data-primary="tests" data-secondary="doc tests" data-type="indexterm" id="OEBPS/ch05.html.id1839"></a>  Each such chunk of code is enclosed in an implicit <code>fn main() { ... }</code> and run as part of
<code>cargo test</code>, effectively making it an additional test case for your code, known as a  <em>doc test</em>.  <a data-primary="cargo test" data-type="indexterm" id="OEBPS/ch05.html.id1840"></a>Individual
tests can also be executed selectively by running <code>cargo test --doc &lt;item-name&gt;</code>.</p>

<p>Regularly running tests as part of your CI environment (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) ensures that your code
samples don’t drift too far from the current reality of your API.<a data-primary="continuous integration" data-secondary="integration tests" data-type="indexterm" id="OEBPS/ch05.html.id1841"></a></p>
</div></section>








<section data-pdf-bookmark="Examples" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id144">
<h2>Examples</h2>

<p><a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a> also described the ability to provide example programs that exercise your public API.<a data-primary="tests" data-secondary="of examples" data-secondary-sortas="examples" data-type="indexterm" id="OEBPS/ch05.html.id1842"></a><a data-primary="example code" data-secondary="testing" data-type="indexterm" id="OEBPS/ch05.html.id1843"></a> Each Rust file under
<code>examples/</code> (or each subdirectory under <code>examples/</code> that includes a <code>main.rs</code>) can be run as a standalone binary
with <code>cargo run --example &lt;name&gt;</code> or <code>cargo test --example &lt;name&gt;</code>.</p>

<p>These programs have access to only the public API of your crate and are intended to illustrate the use of your API as a
whole.  Examples are not specifically designated as test code (no <code>#[test]</code>, no <code>#[cfg(test)]</code>), and they’re a poor
place to put code that exercises obscure nooks and crannies of your crate—particularly as examples are <em>not</em>
run by <code>cargo test</code> by default.</p>

<p>Nevertheless, it’s a good idea to ensure that your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) builds and runs all
the associated examples for a crate (with <code>cargo test --examples</code>), because it can act as a good early warning system
for regressions that are likely to affect lots of users.<a data-primary="continuous integration" data-secondary="testing example code" data-type="indexterm" id="OEBPS/ch05.html.id1844"></a>  As noted, if your examples demonstrate mainline use of
your API, then a failure in the examples implies that something significant is wrong:</p>

<ul>
<li>
<p>If it’s a genuine  bug, then it’s likely to affect lots of users—the
very nature of example code means that users are likely to have copied, pasted, and adapted the example.</p>
</li>
<li>
<p>If it’s an intended change to the API, then the examples need to be updated to match.  <a data-primary="backward compatibility" data-type="indexterm" id="OEBPS/ch05.html.id1845"></a><a data-primary="semantic versioning" data-secondary="updating" data-type="indexterm" id="OEBPS/ch05.html.id1846"></a>A change to the API also
implies a  backward incompatibility, so if the crate is published, then the semantic version
number needs a corresponding update to indicate this (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>).</p>
</li>
</ul>

<p>The likelihood of users copying and pasting example code means that it should have a different style than test code.<a data-primary="main function" data-type="indexterm" id="OEBPS/ch05.html.id1847"></a><a data-primary="? (question mark) operator" data-type="indexterm" id="OEBPS/ch05.html.id1848"></a><a data-primary="unwrap method" data-type="indexterm" id="OEBPS/ch05.html.id1849"></a><a data-primary="Result type" data-secondary="avoiding unwrap calls for" data-type="indexterm" id="OEBPS/ch05.html.id1850"></a> In
line with <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>, you should set a good example for your users by avoiding <code>unwrap()</code> calls for
 <code>Result</code>s. Instead, make each example’s  <code>main()</code> function return something like <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>, and then use the  question mark operator throughout (<a href="#OEBPS/ch01.html.file_transform_md">Item 3</a>).</p>
</div></section>








<section data-pdf-bookmark="Benchmarks" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id145">
<h2>Benchmarks</h2>

<p><a href="#OEBPS/ch03.html.file_optimize_md">Item 20</a> attempts to persuade you that fully optimizing the performance of your code isn’t always necessary.<a data-primary="benchmarks" data-type="indexterm" id="OEBPS/ch05.html.id1851"></a><a data-primary="tests" data-secondary="benchmarks" data-type="indexterm" id="OEBPS/ch05.html.id1852"></a>
Nevertheless, there are definitely times when performance is critical, and if that’s the case, then it’s a good
idea to measure and track that performance. Having  <em>benchmarks</em> that are run regularly (e.g., as part of CI; <a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) allows you to detect when changes to the code or the toolchains adversely affect that
performance.<a data-primary="performance" data-secondary="benchmarks of" data-type="indexterm" id="OEBPS/ch05.html.id1853"></a></p>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html"><code>cargo bench</code></a> command runs special
test cases that repeatedly perform an operation, and emits average timing information for the operation.<a data-primary="cargo bench" data-type="indexterm" id="OEBPS/ch05.html.id1854"></a><a data-primary="unstable features in Rust" data-type="indexterm" id="OEBPS/ch05.html.id1855"></a>  At the time of
writing, support for benchmarks is not stable, so the precise command may need to be <code>cargo +nightly bench</code>. (Rust’s
unstable features, including the <a class="orm:hideurl" href="https://doc.rust-lang.org/unstable-book/library-features/test.html"><code>test</code></a> feature
used here, are described in <a href="https://oreil.ly/tDaYl"><em>The Unstable Book</em></a>.)</p>

<p>However, there’s a danger that compiler optimizations may give misleading results, particularly if you restrict<a data-primary="optimization" data-secondary="compiler optimizations giving misleading results" data-type="indexterm" id="OEBPS/ch05.html.id1856"></a> the
operation that’s being performed to a small subset of the real code.  Consider a simple arithmetic function:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">factorial</code><code class="p">(</code><code class="n">n</code>: <code class="kt">u128</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u128</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">match</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="mi">0</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">n</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">factorial</code><code class="p">(</code><code class="n">n</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">),</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>A naive benchmark for this code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#![feature(test)]</code><code class="w"></code>
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">test</code><code class="p">;</code><code class="w"></code>

<code class="cp">#[bench]</code><code class="w"></code>
<code class="k">fn</code> <code class="nf">bench_factorial</code><code class="p">(</code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">test</code>::<code class="n">Bencher</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">b</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">factorial</code><code class="p">(</code><code class="mi">15</code><code class="p">);</code><code class="w"></code>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">result</code><code class="p">,</code><code class="w"> </code><code class="mi">1_307_674_368_000</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">});</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>gives incredibly positive results:</p>

<pre data-code-language="text" data-type="programlisting">test bench_factorial             ... bench:           0 ns/iter (+/- 0)</pre>

<p>With fixed inputs and a small amount of code under test, the compiler is able to optimize away the iteration and
directly emit the result, leading to an unrealistically optimistic result.</p>

<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/hint/fn.black_box.html"><code>std::hint::black_box</code></a>
function can <a data-primary="black_box function" data-type="indexterm" id="OEBPS/ch05.html.id1857"></a>help with this; it’s an identity function <a href="https://oreil.ly/UEpFk">whose implementation the compiler is “encouraged, <em>but not required</em>”</a> (their italics) to pessimize.</p>

<p>Moving the benchmark code to use this hint:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[bench]</code><code class="w"></code>
<code class="k">fn</code> <code class="nf">bench_factorial</code><code class="p">(</code><code class="n">b</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">test</code>::<code class="n">Bencher</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">b</code><code class="p">.</code><code class="n">iter</code><code class="p">(</code><code class="o">||</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">factorial</code><code class="p">(</code><code class="n">std</code>::<code class="n">hint</code>::<code class="n">black_box</code><code class="p">(</code><code class="mi">15</code><code class="p">));</code><code class="w"></code>
<code class="w">        </code><code class="fm">assert_eq!</code><code class="p">(</code><code class="n">result</code><code class="p">,</code><code class="w"> </code><code class="mi">1_307_674_368_000</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="p">});</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>gives more realistic results:</p>

<pre data-code-language="text" data-type="programlisting">test blackboxed::bench_factorial ... bench:          16 ns/iter (+/- 3)</pre>

<p>The  <a href="https://rust.godbolt.org">Godbolt compiler explorer</a> can also help by showing the actual machine code
emitted by the compiler, which may make it obvious when the compiler has performed optimizations that would be
unrealistic for code running a real scenario.<a data-primary="Godbolt compiler explorer" data-type="indexterm" id="OEBPS/ch05.html.id1858"></a></p>

<p>Finally, if you are including benchmarks for your Rust code, the  <a class="orm:hideurl" href="https://crates.io/crates/criterion"><code>criterion</code></a>
crate may provide an alternative to the standard
<a class="orm:hideurl" href="https://doc.rust-lang.org/test/bench/struct.Bencher.html"><code>test::bench::Bencher</code></a> functionality that is more convenient (it runs with stable Rust) and more fully featured (it has support for statistics and graphs).<a data-primary="criterion crate" data-type="indexterm" id="OEBPS/ch05.html.id1859"></a></p>
</div></section>








<section data-pdf-bookmark="Fuzz Testing" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id146">
<h2>Fuzz Testing</h2>

<p>Fuzz testing is the process of exposing <a data-primary="tests" data-secondary="fuzz tests" data-type="indexterm" id="OEBPS/ch05.html.id1860"></a>code to randomized inputs in the hope of finding  bugs, particularly
crashes that result from those inputs.<a data-primary="fuzz tests" data-type="indexterm" id="OEBPS/ch05.html.id1861"></a> Although this can be a useful technique in general, it becomes much more
important when your code is exposed to inputs that may be controlled by someone who is deliberately trying to attack the
code—so you should <em>run  fuzz tests if your code is exposed to potential attackers</em>.<a data-primary="attackers, code exposed to" data-type="indexterm" id="OEBPS/ch05.html.id1862"></a></p>

<p>Historically, the majority of defects in  C/C++ code that have been exposed by fuzzers have been<a data-primary="C++" data-secondary="code defects exposed by fuzzers" data-type="indexterm" id="OEBPS/ch05.html.id1863"></a><a data-primary="C" data-secondary="code defects exposed by fuzzers" data-type="indexterm" id="OEBPS/ch05.html.id1864"></a><a data-primary="memory" data-secondary="safety problems in C/C++" data-type="indexterm" id="OEBPS/ch05.html.id1865"></a> memory safety problems,
typically found by combining fuzz testing with runtime instrumentation (e.g.,
 <a class="orm:hideurl" href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> or
 <a class="orm:hideurl" href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>) of memory access patterns.<a data-primary="AddressSanitizer" data-type="indexterm" id="OEBPS/ch05.html.id1866"></a><a data-primary="ThreadSanitizer" data-type="indexterm" id="OEBPS/ch05.html.id1867"></a></p>

<p>Rust is <a data-primary="memory" data-secondary="safety problems in Rust" data-type="indexterm" id="OEBPS/ch05.html.id1868"></a>immune to some (but not all) of these memory safety problems, particularly when there is no  <code>unsafe</code> code
involved (<a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>).  <a data-primary="unsafe code" data-type="indexterm" id="OEBPS/ch05.html.id1869"></a>However, Rust does not prevent bugs in general, and a code path that triggers a  <code>panic!</code>
(see <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>) can still result in a  denial-of-service (DoS) attack on the codebase as a whole.<a data-primary="panic! macro" data-secondary="code path triggering, resulting in DoS attack" data-type="indexterm" id="OEBPS/ch05.html.id1870"></a><a data-primary="denial-of-service (DoS) attacks" data-type="indexterm" id="OEBPS/ch05.html.id1871"></a></p>

<p>The most effective forms of fuzz testing are <em>coverage-guided</em>: the test infrastructure monitors which parts of the code
are executed and favors random mutations of the inputs that explore new code paths.   <a class="orm:hideurl" href="https://lcamtuf.coredump.cx/afl/">“American fuzzy lop” (AFL)</a> was the original heavyweight champion of this technique, but in more recent
years equivalent functionality has been included in the LLVM toolchain as
 <a class="orm:hideurl" href="https://llvm.org/docs/LibFuzzer.html"><code>libFuzzer</code></a>.</p>

<p>The Rust compiler is built on LLVM, and so the <a class="orm:hideurl" href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a> subcommand
exposes <code>libFuzzer</code> functionality for Rust (albeit for only a limited number of platforms).<a data-primary="libFuzzer" data-type="indexterm" id="OEBPS/ch05.html.id1872"></a></p>

<p>The primary requirement for a fuzz test is to identify an entrypoint of your code that takes (or can be adapted to take)
arbitrary bytes of data as input:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch05.html.id1873">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Determine if the input starts with "FUZZ".</code>
<code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">is_fuzz</code><code class="p">(</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">])</code><code class="w"> </code>-&gt; <code class="kt">bool</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">data</code><code class="p">.</code><code class="n">len</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">3</code><code class="w"> </code><code class="cm">/* oops */</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">data</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'F'</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">data</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'U'</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">data</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'Z'</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">data</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">b'Z'</code><code class="w"></code>
<code class="w">    </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kc">true</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kc">false</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>With a target entrypoint identified, the <a href="https://oreil.ly/xF0Ex"><em>Rust Fuzz Book</em></a> gives instructions on how
to arrange the fuzzing subproject.<a data-primary="Rust Fuzz Book" data-type="indexterm" id="OEBPS/ch05.html.id1874"></a>  At its core is a small driver that connects the target entrypoint to the fuzzing
infrastructure:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// fuzz/fuzz_targets/target1.rs file</code>
<code class="cp">#![no_main]</code><code class="w"></code>
<code class="k">use</code><code class="w"> </code><code class="n">libfuzzer_sys</code>::<code class="n">fuzz_target</code><code class="p">;</code><code class="w"></code>

<code class="n">fuzz_target</code><code class="o">!</code><code class="p">(</code><code class="o">|</code><code class="n">data</code>: <code class="kp">&amp;</code><code class="p">[</code><code class="kt">u8</code><code class="p">]</code><code class="o">|</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">_</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">somecrate</code>::<code class="n">is_fuzz</code><code class="p">(</code><code class="n">data</code><code class="p">);</code><code class="w"></code>
<code class="p">});</code><code class="w"></code></pre>

<p>Running <code>cargo +nightly fuzz run target1</code> continuously executes the fuzz target with random data, stopping only if a
crash is found.  In this case, a failure is found almost immediately:</p>

<pre data-code-language="text" data-type="programlisting">INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1607525774
INFO: Loaded 1 modules: 1624 [0x108219fa0, 0x10821a5f8),
INFO: Loaded 1 PC tables (1624 PCs): 1624 [0x10821a5f8,0x108220b78),
INFO:        9 files found in fuzz/corpus/target1
INFO: seed corpus: files: 9 min: 1b max: 8b total: 46b rss: 38Mb
#10	INITED cov: 26 ft: 26 corp: 6/22b exec/s: 0 rss: 39Mb
thread panicked at 'index out of bounds: the len is 3 but the index is 3',
     testing/src/lib.rs:77:12
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f77bfb7336f2/library/std/src/panicking.rs:579:5
   1: core::panicking::panic_fmt
             at /rustc/f77bfb7336f2/library/core/src/panicking.rs:64:14
   2: core::panicking::panic_bounds_check
             at /rustc/f77bfb7336f2/library/core/src/panicking.rs:159:5
   3: somecrate::is_fuzz
   4: _rust_fuzzer_test_input
   5: ___rust_try
   6: _LLVMFuzzerTestOneInput
   7: __ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm
   8: __ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb
   9: __ZN6fuzzer6Fuzzer16MutateAndTestOneEv
  10: __ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_
      16fuzzer_allocatorIS3_EEEE
  11: __ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE
  12: _main</pre>

<p>and the input that triggered the failure is emitted.</p>

<p>Normally, fuzz testing does not find failures so quickly, and so it does <em>not</em> make sense to run fuzz tests as part of
your CI.  The open-ended nature of the testing, and the consequent compute costs, mean that
you need to consider how and when to run fuzz tests—perhaps only for new releases or major changes, or perhaps
for a limited period of time.<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1875" id="OEBPS/ch05.html.id1875-marker">6</a></sup></p>

<p>You can also make subsequent<a data-primary="OSS-Fuzz program" data-type="indexterm" id="OEBPS/ch05.html.id1876"></a><a data-primary="Google OSS-Fuzz program" data-type="indexterm" id="OEBPS/ch05.html.id1877"></a> runs of the fuzzing infrastructure more efficient, by <a data-primary="corpus for fuzzing" data-type="indexterm" id="OEBPS/ch05.html.id1878"></a>storing and reusing a  <em>corpus</em>
of previous inputs that the fuzzer found to explore new code paths; this helps subsequent runs of the fuzzer explore
new ground, rather than retesting code paths previously visited.</p>
</div></section>








<section class="pagebreak-before less_space" data-pdf-bookmark="Testing Advice" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id147">
<h2>Testing Advice</h2>

<p>An Item about testing wouldn’t be complete without <a data-primary="tests" data-secondary="testing advice" data-type="indexterm" id="OEBPS/ch05.html.id1879"></a>repeating some common advice (which is mostly not Rust-specific):</p>

<ul>
<li>
<p>As this Item has endlessly repeated, <em>run all your tests in CI on every change</em> (with
the exception of fuzz tests).<a data-primary="continuous integration" data-secondary="testing advice for" data-type="indexterm" id="OEBPS/ch05.html.id1880"></a></p>
</li>
<li>
<p>When you’re fixing a bug, <em>write a test that exhibits the bug before fixing the  bug</em>.  That way you
can be sure that the bug is fixed and that it won’t be accidentally reintroduced in the future.<a data-primary="features" data-secondary="testing" data-type="indexterm" id="OEBPS/ch05.html.id1881"></a><a data-primary="crates" data-secondary="testing advice for" data-type="indexterm" id="OEBPS/ch05.html.id1882"></a></p>
</li>
<li>
<p>If your crate has features (<a href="#OEBPS/ch04.html.file_features_md">Item 26</a>), <em>run tests over every possible combination of available features</em>.</p>
</li>
<li>
<p>More generally, if your crate includes any config-specific code (e.g., <code>#[cfg(target_os = "windows")]</code>), <em>run
tests for every platform</em> that has distinct code.<a data-primary="config-specific code" data-type="indexterm" id="OEBPS/ch05.html.id1883"></a></p>
</li>
</ul>

<p>This Item has covered a lot of different types of tests, so it’s up to you to decide how much each of them is relevant and
worthwhile for your project.</p>

<p>If you have a lot of test code and you are publishing your crate to  <a class="orm:hideurl" href="https://crates.io"><code>crates.io</code></a>, then you
might need to consider which of the tests make sense to include in the published crate.<a data-primary="crates.io" data-secondary="tests in published crates" data-type="indexterm" id="OEBPS/ch05.html.id1884"></a><a data-primary="Cargo" data-secondary="tests included in published crate" data-type="indexterm" id="OEBPS/ch05.html.id1885"></a>  By default, <code>cargo</code> will
include unit tests, integration tests, benchmarks, and examples (but not fuzz tests, because the <code>cargo-fuzz</code> tools
store these as a separate crate in a subdirectory), which may be more than end users need.  If that’s the case, you can
either <a href="https://oreil.ly/SCuug"><code>exclude</code></a> some of the
files or (for behavior tests) move the tests out of the crate and into a separate test crate.<a data-primary="behavior tests" data-type="indexterm" id="OEBPS/ch05.html.id1886"></a></p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id148">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Write unit tests for comprehensive testing that includes testing of internal-only code.<a data-primary="unit tests" data-type="indexterm" id="OEBPS/ch05.html.id1887"></a><a data-primary="cargo test" data-type="indexterm" id="OEBPS/ch05.html.id1888"></a>  Run them with <code>cargo test</code>.</p>
</li>
<li>
<p>Write integration tests to exercise your public API.<a data-primary="integration tests" data-type="indexterm" id="OEBPS/ch05.html.id1889"></a>  Run them with <code>cargo test</code>.</p>
</li>
<li>
<p>Write doc tests that exemplify how to use individual items in your public API.<a data-primary="doc tests" data-type="indexterm" id="OEBPS/ch05.html.id1890"></a> Run them with <code>cargo test</code>.</p>
</li>
<li>
<p>Write example programs that show how to use your public API as a whole.  Run them with <code>cargo test --examples</code> or <code>cargo run --example &lt;name&gt;</code>.<a data-primary="example code" data-secondary="testing" data-type="indexterm" id="OEBPS/ch05.html.id1891"></a></p>
</li>
<li>
<p>Write benchmarks if your code has significant performance requirements.  Run them with <code>cargo bench</code>.<a data-primary="benchmarks" data-type="indexterm" id="OEBPS/ch05.html.id1892"></a><a data-primary="cargo bench" data-type="indexterm" id="OEBPS/ch05.html.id1893"></a></p>
</li>
<li>
<p>Write fuzz tests if your code is<a data-primary="tests" data-startref="ix_test" data-type="indexterm" id="OEBPS/ch05.html.id1894"></a> exposed to untrusted inputs.<a data-primary="fuzz tests" data-type="indexterm" id="OEBPS/ch05.html.id1895"></a><a data-primary="cargo-fuzz" data-type="indexterm" id="OEBPS/ch05.html.id1896"></a>  Run them (continuously) with <code>cargo fuzz</code>.</p>
</li>
</ul>
</div></section>
</div></section>






<section class="pagebreak-before less_space" data-pdf-bookmark="Item 31: Take advantage of the tooling ecosystem" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_use-tools_md">
<h1>Item 31: Take advantage of the tooling ecosystem</h1>

<p>The Rust ecosystem has a rich collection of additional tools, which provide functionality above and beyond the essential
task of converting Rust into machine code.<a data-primary="tooling ecosystem" data-type="indexterm" id="OEBPS/ch05.html.ix_tooleco"></a></p>

<p>When setting up a Rust <a data-primary="tooling ecosystem" data-secondary="development environment tools" data-type="indexterm" id="OEBPS/ch05.html.id1897"></a><a data-primary="development environment, tools for" data-type="indexterm" id="OEBPS/ch05.html.id1898"></a>development environment, you’re likely to
want most of the following basic tools:<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1899" id="OEBPS/ch05.html.id1899-marker">7</a></sup></p>

<ul>
<li>
<p>The  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/"><code>cargo</code></a> tool for organizing dependencies (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) and driving
the compiler<a data-primary="Cargo" data-type="indexterm" id="OEBPS/ch05.html.id1900"></a></p>
</li>
<li>
<p>The  <a class="orm:hideurl" href="https://github.com/rust-lang/rustup"><code>rustup</code></a> tool, which manages the installed Rust toolchains<a data-primary="rustup" data-type="indexterm" id="OEBPS/ch05.html.id1901"></a></p>
</li>
<li>
<p>An IDE with Rust support, or an IDE/editor plug-in like
 <a class="orm:hideurl" href="https://github.com/rust-lang/rust-analyzer"><code>rust-analyzer</code></a>, that allows you to quickly
navigate around a Rust codebase, and provides autocompletion support for writing Rust code<a data-primary="IDE or IDE/editor plug-in" data-type="indexterm" id="OEBPS/ch05.html.id1902"></a><a data-primary="Rust playground" data-type="indexterm" id="OEBPS/ch05.html.id1903"></a></p>
</li>
<li>
<p>The  <a href="https://play.rust-lang.org">Rust playground</a>, for standalone
explorations of Rust’s syntax and for sharing the results with colleagues</p>
</li>
<li>
<p>A bookmarked link to the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/">documentation for the Rust standard library</a></p>
</li>
</ul>

<p>Beyond <a data-primary="documentation" data-secondary="for Rust standard library" data-secondary-sortas="Rust" data-type="indexterm" id="OEBPS/ch05.html.id1904"></a><a data-primary="tooling ecosystem" data-secondary="Cargo toolchain" data-type="indexterm" id="OEBPS/ch05.html.id1905"></a><a data-primary="Cargo" data-secondary="additional tools in" data-type="indexterm" id="OEBPS/ch05.html.id1906"></a>these basics, Rust includes many tools that help with the wider task of maintaining a codebase and improving the
quality of that codebase. The <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/commands/index.html">tools that are included</a> in the
official Cargo toolchain cover various essential tasks beyond the basics of <code>cargo build</code>, <code>cargo test</code>, and <code>cargo run</code>, for example:</p>
<dl>
<dt><code>cargo fmt</code></dt>
<dd>
<p>Reformats Rust code <a data-primary="cargo fmt" data-type="indexterm" id="OEBPS/ch05.html.id1907"></a>according to standard conventions.</p>
</dd>
<dt><code>cargo check</code></dt>
<dd>
<p>Performs compilation checks without generating machine code, which can be useful to get a fast
syntax check.<a data-primary="cargo check" data-type="indexterm" id="OEBPS/ch05.html.id1908"></a></p>
</dd>
<dt><code>cargo clippy</code></dt>
<dd>
<p>Performs lint checks, detecting inefficient or unidiomatic code (<a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a>).<a data-primary="cargo clippy" data-seealso="Clippy" data-type="indexterm" id="OEBPS/ch05.html.id1909"></a></p>
</dd>
<dt><code>cargo doc</code></dt>
<dd>
<p>Generates<a data-primary="cargo doc" data-type="indexterm" id="OEBPS/ch05.html.id1910"></a> documentation (<a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a>).</p>
</dd>
<dt><code>cargo bench</code></dt>
<dd>
<p>Runs <a data-primary="cargo bench" data-type="indexterm" id="OEBPS/ch05.html.id1911"></a>benchmarking tests (<a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>).</p>
</dd>
<dt><code>cargo update</code></dt>
<dd>
<p>Upgrades<a data-primary="cargo update" data-type="indexterm" id="OEBPS/ch05.html.id1912"></a> dependencies to the latest versions, selecting versions that are compliant with
semantic versioning (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) by default.</p>
</dd>
<dt><code>cargo tree</code></dt>
<dd>
<p>Displays<a data-primary="cargo tree" data-type="indexterm" id="OEBPS/ch05.html.id1913"></a> the<a data-primary="dependency graph" data-type="indexterm" id="OEBPS/ch05.html.id1914"></a> dependency graph (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>).</p>
</dd>
<dt><code>cargo metadata</code></dt>
<dd>
<p>Emits metadata about the packages that are present in the workspace and in their dependencies.<a data-primary="cargo metadata" data-type="indexterm" id="OEBPS/ch05.html.id1915"></a><a data-primary="metadata" data-type="indexterm" id="OEBPS/ch05.html.id1916"></a></p>
</dd>
</dl>

<p>The last of these<a data-primary="crates" data-secondary="tool emitting information on" data-type="indexterm" id="OEBPS/ch05.html.id1917"></a> is particularly useful, albeit indirectly: because there’s a tool that emits information about crates
in a well-defined format, it’s much easier for people to produce other tools that make use of that information
(typically via the  <a class="orm:hideurl" href="https://docs.rs/cargo_metadata/latest/cargo_metadata/"><code>cargo_metadata</code></a> crate, which provides
a set of Rust types to hold the metadata information).</p>

<p><a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a> described some of the tools that are enabled by this metadata availability, such <a data-primary="dependencies" data-type="indexterm" id="OEBPS/ch05.html.id1918"></a><a data-primary="cargo-udeps" data-type="indexterm" id="OEBPS/ch05.html.id1919"></a>as  <code>cargo-udeps</code> (which
allows detection<a data-primary="cargo-deny" data-type="indexterm" id="OEBPS/ch05.html.id1920"></a> of unused dependencies) or  <code>cargo-deny</code> (which allows checks for many things, including
duplicate dependencies, allowed licenses, and security advisories).</p>

<p>The extensibility of the Rust toolchain is not just limited to package metadata; the<a data-primary="abstract syntax tree" data-type="indexterm" id="OEBPS/ch05.html.id1921"></a> compiler’s  abstract syntax
tree can also be built upon, <a class="orm:hideurl" href="https://crates.io/crates/syn/reverse_dependencies">often via</a> the
 <a class="orm:hideurl" href="https://docs.rs/syn"><code>syn</code></a> crate.<a data-primary="syn crate" data-type="indexterm" id="OEBPS/ch05.html.id1922"></a><a data-primary="procedural macros" data-type="indexterm" id="OEBPS/ch05.html.id1923"></a>  This information is what makes procedural macros (<a href="#OEBPS/ch05.html.file_macros_md">Item 28</a>) so potent but
also powers a variety of other tools:</p>
<dl>
<dt><a class="orm:hideurl" href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a></dt>
<dd>
<p>Shows the complete source code produced by macro<a data-primary="cargo-expand" data-type="indexterm" id="OEBPS/ch05.html.id1924"></a><a data-primary="macros" data-type="indexterm" id="OEBPS/ch05.html.id1925"></a>
expansion, which can be essential for debugging tricky macro definitions.</p>
</dd>
<dt><a class="orm:hideurl" href="https://docs.rs/cargo-tarpaulin"><code>cargo-tarpaulin</code></a></dt>
<dd>
<p>Supports the generation and tracking of code coverage
information.<a data-primary="cargo-tarpaulin" data-type="indexterm" id="OEBPS/ch05.html.id1926"></a></p>
</dd>
</dl>

<p>Any list of specific tools will always be subjective, out of date, and incomplete; the more general point is to
<em>explore the available tools</em>.</p>

<p>For example, a <a class="orm:hideurl" href="https://docs.rs/releases/search?query=cargo-">search for <code>cargo-&lt;something&gt;</code> tools</a> gives dozens of
results; some will be inappropriate and some will be abandoned, but some might just do exactly what you want.<a data-primary="Cargo" data-secondary="searching for tools" data-type="indexterm" id="OEBPS/ch05.html.id1927"></a></p>

<p>There are also various efforts to    <a href="https://oreil.ly/51DfU">apply formal verification to Rust code</a>, which may be helpful if your code needs
higher levels of assurance about its correctness.<a data-primary="formal verification" data-type="indexterm" id="OEBPS/ch05.html.id1928"></a><a data-primary="verification (formal)" data-type="indexterm" id="OEBPS/ch05.html.id1929"></a></p>

<p>Finally, a reminder: if a tool<a data-primary="continuous integration" data-secondary="integrating useful tools into" data-type="indexterm" id="OEBPS/ch05.html.id1930"></a> is useful on more than a one-off basis, you should <em>integrate the tool into your
CI system</em> (as per <a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>).  If the tool is fast and false-positive free, it may also make sense
to <em>integrate the tool into your editor or IDE</em>; the Rust <a href="https://rust-lang.org/tools">Tools page</a>
provides links to relevant documentation for this.<a data-primary="IDE or IDE/editor plug-in" data-secondary="integrating tools into" data-type="indexterm" id="OEBPS/ch05.html.id1931"></a></p>








<section data-pdf-bookmark="Tools to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id150">
<h2>Tools to Remember</h2>

<p>In addition to the tools that should be configured to run over your codebase regularly and automatically (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>),
there are various other tools that have been mentioned elsewhere in the book. For reference, these are collated<a data-primary="tooling ecosystem" data-secondary="tools to remember" data-type="indexterm" id="OEBPS/ch05.html.id1932"></a>
here—but remember that there are many more <a data-primary="Miri" data-type="indexterm" id="OEBPS/ch05.html.id1933"></a>tools out there:</p>

<ul>
<li>
<p><a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a> recommends the use of  <a class="orm:hideurl" href="https://github.com/rust-lang/miri">Miri</a> when writing subtle <code>unsafe</code> code.</p>
</li>
<li>
<p>Items <a href="#OEBPS/ch04.html.file_semver_md">21</a> and <a href="#OEBPS/ch04.html.file_dep-graph_md">25</a> include mention of
<a class="orm:hideurl" href="https://docs.github.com/en/code-security/dependabot">Dependabot</a>, for<a data-primary="Dependabot" data-type="indexterm" id="OEBPS/ch05.html.id1934"></a> managing dependency updates.</p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_semver_md">Item 21</a> also mentions  <a class="orm:hideurl" href="https://github.com/obi1kenobi/cargo-semver-checks"><code>cargo-semver-checks</code></a> as a possible
option <a data-primary="cargo-server-checks" data-type="indexterm" id="OEBPS/ch05.html.id1935"></a>for checking that semantic versioning has been done correctly.</p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_macros_md">Item 28</a> explains that  <a class="orm:hideurl" href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> can help when debugging macro
problems.<a data-primary="cargo-expand" data-type="indexterm" id="OEBPS/ch05.html.id1936"></a></p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a> is entirely dedicated to the use of  Clippy.</p>
</li>
<li>
<p>The  <a href="https://rust.godbolt.org">Godbolt compiler explorer</a> allows you to explore the machine code<a data-primary="Clippy" data-type="indexterm" id="OEBPS/ch05.html.id1937"></a><a data-primary="Godbolt compiler explorer" data-type="indexterm" id="OEBPS/ch05.html.id1938"></a>
corresponding to your source code, as described in <a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>.</p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_testing_md">Item 30</a> also<a data-primary="tests" data-secondary="testing tools" data-type="indexterm" id="OEBPS/ch05.html.id1939"></a><a data-primary="cargo-fuzz" data-type="indexterm" id="OEBPS/ch05.html.id1940"></a><a data-primary="criterion crate" data-type="indexterm" id="OEBPS/ch05.html.id1941"></a><a data-primary="bindgen" data-type="indexterm" id="OEBPS/ch05.html.id1942"></a> mentions additional testing tools, such as
<a class="orm:hideurl" href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a> for fuzz testing and
<a class="orm:hideurl" href="https://crates.io/crates/criterion"><code>criterion</code></a> for benchmarking.</p>
</li>
<li>
<p><a href="#OEBPS/ch06.html.file_bindgen_md">Item 35</a> covers the use of  <a class="orm:hideurl" href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a> for auto-generating Rust FFI
wrappers from C code.<a data-primary="FFI (foreign-function interface)" data-type="indexterm" id="OEBPS/ch05.html.id1943"></a><a data-primary="tooling ecosystem" data-startref="ix_tooleco" data-type="indexterm" id="OEBPS/ch05.html.id1944"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 32: Set up a continuous integration (CI) system" data-type="sect1"><div class="sect1" id="OEBPS/ch05.html.file_ci_md">
<h1>Item 32: Set up a continuous integration (CI) system</h1>

<p>A  CI system is a mechanism for automatically running tools over your codebase, which is
triggered whenever there’s a change to the codebase—or a proposed change to the codebase.</p>

<p>The recommendation to <em>set up a CI system</em> is not at all Rust-specific, so this Item is a
mélange of general advice mixed with Rust-specific tool suggestions.</p>








<section data-pdf-bookmark="CI Steps" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id205">
<h2>CI Steps</h2>

<p>Moving to specifics, what kinds of steps should be included in your CI system?  The obvious initial candidates
are the following:</p>

<ul>
<li>
<p>Build the code.</p>
</li>
<li>
<p>Run the tests for the code.</p>
</li>
</ul>

<p>In each case, a CI step should run cleanly, quickly, deterministically, and with a zero false positive rate; more on this
in the next section.</p>

<p>The “deterministic” requirement also leads to advice for the build step: <em>use rust-toolchain.toml to specify
a fixed version of the toolchain in your CI build</em>.</p>

<p>The
<a class="orm:hideurl" href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><em>rust-toolchain.toml</em></a> file indicates which
version of Rust should be used to build the code—either a specific version (e.g., <code>1.70</code>), or a channel
(<code>stable</code>, <code>beta</code>, or <code>nightly</code>) possibly with an optional date  (e.g., <code>nightly-2023-09-19</code>).<sup><a data-type="noteref" href="#OEBPS/ch05.html.id1945" id="OEBPS/ch05.html.id1945-marker">8</a></sup>  Choosing a floating channel value here would make the CI results vary as new
toolchain versions are released; a fixed value is more deterministic and allows you to deal with toolchain upgrades
separately.</p>

<p>Throughout this book, various Items have suggested tools and techniques that can help improve your codebase; wherever
possible, these should be included with the CI system.  For example, the two fundamental parts of a CI system previously mentioned can be enhanced:</p>

<ul>
<li>
<p>Build the code.</p>

<ul>
<li>
<p><a href="#OEBPS/ch04.html.file_features_md">Item 26</a> describes the use of  <em>features</em> to conditionally include different chunks of code. If your
crate has features, <em>build every valid combination of features in CI</em> (and realize that this may involve
2<sup>N</sup> different variants—hence the advice to avoid feature creep).</p>
</li>
<li>
<p><a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a> suggests that you consider making library code  <code>no_std</code> compatible where possible. You can be
confident that your code is genuinely <code>no_std</code> compatible only if you <em>test <code>no_std</code> compatibility in CI</em>.  One
option is to make use of the Rust compiler’s cross-compilation abilities and build for an explicitly <code>no_std</code>
target (e.g., <code>thumbv6m-none-eabi</code>).</p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_semver_md">Item 21</a> includes a discussion around declaring a  minimum supported Rust version (MSRV) for your code. If you
have this, <em>check your MSRV in CI</em> by including a step that tests with that specific Rust version.</p>
</li>
</ul>
</li>
<li>
<p>Run the tests for the code.</p>

<ul>
<li>
<p><a href="#OEBPS/ch05.html.file_testing_md">Item 30</a> describes the various different styles of test; <em>run all test types in CI</em>.  Some test types are
automatically included in <code>cargo test</code>  (unit tests,  integration tests, and
 doc tests), but other test types (e.g., example programs) may need to be explicitly triggered.</p>
</li>
</ul>
</li>
</ul>

<p>However, there are other tools and suggestions that can help improve the quality of your codebase:</p>

<ul>
<li>
<p><a href="#OEBPS/ch05.html.file_clippy_md">Item 29</a> waxes lyrical about the advantages of running  Clippy over your code; <em>run Clippy in CI</em>.
To ensure that failures are flagged, set the <code>-Dwarnings</code> option (for example, via <code>cargo clippy -- -Dwarnings</code>).</p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_documentation_md">Item 27</a> suggests documenting your public API; use the  <code>cargo doc</code> tool to check that the documentation
generates correctly and that any hyperlinks in it resolve correctly.</p>
</li>
<li>
<p><a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a> mentions tools such as  <code>cargo-udeps</code> and  <code>cargo-deny</code> that can help manage your dependency
graph; running these as a CI step prevents regressions.</p>
</li>
<li>
<p><a href="#OEBPS/ch05.html.file_use-tools_md">Item 31</a> discusses the Rust tool ecosystem; consider which of these tools are worth regularly running over your
codebase.  For example, running  <code>rustfmt</code> / <code>cargo fmt</code> in CI allows detection of code that doesn’t comply with
your project’s style guidelines. To ensure that failures are flagged, set the <code>--check</code> option.</p>
</li>
</ul>

<p>You can also include CI steps that measure particular aspects of your code:</p>

<ul>
<li>
<p>Generate code coverage statistics (e.g., with  <a class="orm:hideurl" href="https://docs.rs/cargo-tarpaulin"><code>cargo-tarpaulin</code></a>) to show what
proportion of your codebase is exercised by your tests.</p>
</li>
<li>
<p>Run benchmarks (e.g., with  <code>cargo-bench</code>; <a href="#OEBPS/ch05.html.file_testing_md">Item 30</a>) to measure the performance of your code on key scenarios.
However, note that most CI systems run in shared environments where external factors can affect the results; getting
more reliable benchmark data is likely to require a more dedicated environment.</p>
</li>
</ul>

<p>These measurement suggestions are a bit more complicated to set up, because the output of a measurement step is more
useful when it’s compared to previous results.  In an ideal world, the CI system would detect when a code change is not
fully tested or has an adverse effect on performance; this typically involves integration with some external tracking
system.</p>

<p>Here are other suggestions for CI steps that may or may not be relevant for your codebase:</p>

<ul>
<li>
<p>If your project is a library, recall (from <a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) that any checked-in  <em>Cargo.lock</em> file will be ignored by
the users of your library. In theory, the semantic version constraints (<a href="#OEBPS/ch04.html.file_semver_md">Item 21</a>) in <em>Cargo.toml</em> should mean that
everything works correctly anyway; in practice, consider including a CI step that builds without any local
<em>Cargo.lock</em>, to detect whether the current versions of dependencies still work correctly.</p>
</li>
<li>
<p>If your project includes any kind of machine-generated resources that are version-controlled (e.g., code
generated from  protocol buffer messages by  <a class="orm:hideurl" href="https://docs.rs/prost"><code>prost</code></a>), then include a CI step that
regenerates the resources and checks that there are no differences compared to the checked-in version.</p>
</li>
<li>
<p>If your codebase includes platform-specific (e.g., <code>#[cfg(target_arch = "arm")]</code>) code, run CI steps that confirm that
the code builds and (ideally) works on that platform.  (The former is easier than the latter because the Rust
toolchain includes support for cross-compilation.)</p>
</li>
<li>
<p>If your project manipulates secret values such as access tokens or cryptographic keys, consider including a CI step
that searches the codebase for secrets that have been inadvertently checked in.  This is particularly important if
your project is public (in which case it may be worth moving the check from CI to a <a class="orm:hideurl" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">version-control presubmit check</a>).</p>
</li>
</ul>

<p>CI checks don’t always need to be integrated with Cargo and the Rust toolchains; sometimes a simple
shell script can give more bang for the buck, particularly when a codebase has a local convention that’s not universally
followed.  For example, a codebase might include a convention that any panic-inducing method invocation (<a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>) has a
special marker comment or that every <code>TODO:</code> comment has an owner (a person or a tracking ID), and a shell script is ideal
for checking this.</p>

<p>Finally, consider examining the CI systems of public Rust projects to get ideas for additional CI steps that might be
useful for your project.  For example,  Cargo has a <a href="https://oreil.ly/DOqCc">CI system</a> that includes many steps that may
provide 
<span class="keep-together">inspiration</span>.</p>
</div></section>








<section data-pdf-bookmark="CI Principles" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id206">
<h2>CI Principles</h2>

<p>Moving from the specific to the general, there are some overall principles that should guide the details of your CI system.</p>

<p>The most fundamental principle is <em>don’t waste the time of humans</em>.  If a CI system unnecessarily wastes
people’s time, they will start looking for ways to avoid it.</p>

<p>The most annoying waste of an engineer’s time is a <em>flaky</em> test: sometimes it passes and sometimes it fails, even when the setup and codebase are identical. Whenever possible, be ruthless with flaky tests: hunt them
down, and put in the time up front to investigate and fix the cause of the flakiness—it will pay for itself in
the long run.</p>

<p>Another common waste of engineering time is a CI system that takes a long time to run and that runs only <em>after</em> a request for a code review has been triggered.  In this situation, there’s the potential to waste two
people’s time: both the author and also the code reviewer, who may spend time spotting and pointing out issues with the
code that the CI bots could have flagged.</p>

<p>To help with this, try to make it easy to run the CI checks manually, independent from the automated system. This allows
engineers to get into the habit of triggering them regularly so that code reviewers never even see problems that the CI
would have flagged.  Better still, make the integration even more continuous by incorporating some of the tools into your
editor or IDE setup so that (for example) poorly formatted code never even makes it to disk.</p>

<p>This may also require splitting the checks up if there are time-consuming tests that rarely find problems but are
there as a backstop to prevent obscure scenarios 
<span class="keep-together">breaking</span>.</p>

<p>More generally, a large project may need to divide up its CI checks according to the cadence at which they are run:</p>

<ul>
<li>
<p>Checks that are integrated into each engineer’s development environment (e.g., <code>rustfmt</code>)</p>
</li>
<li>
<p>Checks that run on every code review request (e.g., <code>cargo build</code>, <code>cargo clippy</code>) and are easy to run
manually</p>
</li>
<li>
<p>Checks that run on every change that makes it to the main branch of the project (e.g., full <code>cargo test</code> in all
supported environments)</p>
</li>
<li>
<p>Checks that run at scheduled intervals (e.g., daily or weekly), which can catch rare regressions after the fact
(e.g., long-running integration tests and benchmark comparison tests)</p>
</li>
<li>
<p>Checks that run on the current code at all times (e.g., fuzz tests)</p>
</li>
</ul>

<p>It’s important that the CI system be integrated with whatever code review system is used for your project so that a
code review can clearly see a green set of checks and be confident that its code review can focus on the important
meaning of the code, not on trivial details.</p>

<p>This need for a green build also means that there can be no exceptions to whatever checks your CI system has put in
place.  This is worthwhile even if you have to work around an occasional false positive from a tool; once your CI system
has an accepted failure (“Oh, everyone knows that test never passes”), then it’s vastly harder to spot new regressions.</p>

<p><a href="#OEBPS/ch05.html.file_testing_md">Item 30</a> included the common advice of adding a test to reproduce a bug, before fixing the  bug. The same principle
applies to your CI system: when you discover process problems <em>add a CI step that detects a process issue,
before fixing the issue</em>.  For example, if you discover that some auto-generated code has gotten out of sync with its
source, add a check for this to the CI system.  This check will initially fail but then turn green once the problem is
solved—giving you confidence that this category of process error will not occur again in the future.</p>
</div></section>








<section class="pagebreak-before lesss_space" data-pdf-bookmark="Public CI Systems" data-type="sect2"><div class="sect2" id="OEBPS/ch05.html.id207">
<h2>Public CI Systems</h2>

<p>If your codebase is open source and visible to the public, there are a few extra things to think about with your
CI system.</p>

<p>First is the good news: there are lots of free, reliable options for building a CI system for
open source code.  At the time of writing,  <a class="orm:hideurl" href="https://docs.github.com/en/actions">GitHub Actions</a> are probably the
best choice, but it’s far from the only choice, and more systems appear all the time.</p>

<p>Second, for open source code it’s worth bearing in mind that your CI system can act as a guide for how to set up any
prerequisites needed for the codebase.  This isn’t a concern for pure Rust crates, but if your codebase requires
additional dependencies—databases, alternative toolchains for FFI code, configuration, etc.—then your
CI scripts will be an existence proof of how to get all of that working on a fresh system. Encoding these setup steps in
reusable scripts allows both the humans and the bots to get a working system in a straightforward way.</p>

<p>Finally, there’s bad news for publicly visible crates: the possibility of abuse and attacks. This can range from
attempts to perform cryptocurrency mining in your CI system to <a href="https://oreil.ly/yP-8m">theft of codebase access tokens</a>,  supply chain
attacks, and worse. To mitigate these risks, consider these guidelines:</p>

<ul>
<li>
<p>Restrict access so that CI scripts run automatically only for known collaborators and have to
be triggered manually for new contributors.</p>
</li>
<li>
<p>Pin the versions of any external scripts to particular versions, or (better yet) specific known hashes.</p>
</li>
<li>
<p>Closely monitor any integration steps that need more than just read access to the codebase.</p>
</li>
</ul>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch05.html.id1626"><sup><a href="#OEBPS/ch05.html.id1626-marker">1</a></sup> Historically, this option used to be called <code>intra_doc_link_resolution_failure</code>.</p><p data-type="footnote" id="OEBPS/ch05.html.id1639"><sup><a href="#OEBPS/ch05.html.id1639-marker">2</a></sup> The default behavior of automatically including <em>README.md</em> can be overridden with the <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-readme-field"><code>readme</code> field in <em>Cargo.toml</em></a>.</p><p data-type="footnote" id="OEBPS/ch05.html.id1654"><sup><a href="#OEBPS/ch05.html.id1654-marker">3</a></sup> Scott Meyers,  <em>More Effective C++</em> (Addison-Wesley), Item 32.</p><p data-type="footnote" id="OEBPS/ch05.html.id1683"><sup><a href="#OEBPS/ch05.html.id1683-marker">4</a></sup> An eagle-eyed reader might notice that <code>format_args!</code> still looks like a macro invocation, even after macros have been expanded.  That’s because it’s a special macro that’s built into the compiler.</p><p data-type="footnote" id="OEBPS/ch05.html.id1712"><sup><a href="#OEBPS/ch05.html.id1712-marker">5</a></sup> The <a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/index.html"><code>std::fmt</code> module</a> also includes various other traits that are used when displaying data in particular formats.<a data-primary="traits" data-secondary="used to display data in formats" data-type="indexterm" id="OEBPS/ch05.html.id1946"></a> For example, <a class="orm:hideurl" href="https://doc.rust-lang.org/std/fmt/trait.LowerHex.html"><code>LowerHex</code></a> is used when an <code>x</code> format specifier indicates that lower-case hexadecimal output is required.</p><p data-type="footnote" id="OEBPS/ch05.html.id1875"><sup><a href="#OEBPS/ch05.html.id1875-marker">6</a></sup> If your code is a widely used open source crate, the  <a class="orm:hideurl" href="https://google.github.io/oss-fuzz/getting-started/accepting-new-projects/">Google OSS-Fuzz program</a> may be willing to run fuzzing on your behalf.</p><p data-type="footnote" id="OEBPS/ch05.html.id1899"><sup><a href="#OEBPS/ch05.html.id1899-marker">7</a></sup> This list may be reduced in some environments.<a data-primary="Android" data-type="indexterm" id="OEBPS/ch05.html.id1947"></a> For example, <a href="https://oreil.ly/nptNC">Rust development in Android</a> has a centrally controlled toolchain (so no <code>rustup</code>) and integrates with  Android’s  Soong build system (so no <code>cargo</code>).</p><p data-type="footnote" id="OEBPS/ch05.html.id1945"><sup><a href="#OEBPS/ch05.html.id1945-marker">8</a></sup> If your code relies on particular features that are available only in the nightly compiler, a <em>rust-toolchain.toml</em> file also makes that toolchain dependency clear.</p></div></div></section></div></div>
<div id="OEBPS/ch06.html"><div data-type="book">
<section data-pdf-bookmark="Chapter 6. Beyond Standard Rust" data-type="chapter" epub:type="chapter"><div class="chapter" id="OEBPS/ch06.html.file_beyond-std_md">
<h1><span class="label">Chapter 6. </span>Beyond Standard Rust</h1>


<p>The Rust toolchain includes support for <a data-primary="nonstandard Rust environments" data-type="indexterm" id="OEBPS/ch06.html.id1948"></a>a much wider variety of environments than just pure Rust application code,
running in userspace:</p>

<ul>
<li>
<p>It supports  <em>cross-compilation</em>, where the system running the toolchain (the <em>host</em>) is not the same as<a data-primary="cross-compilation" data-type="indexterm" id="OEBPS/ch06.html.id1949"></a>
the system that the compiled code will run on (the <em>target</em>), which makes it easy to target embedded systems.</p>
</li>
<li>
<p>It supports linking with code compiled from languages other than Rust, via built-in FFI capabilities.<a data-primary="FFI (foreign-function interface)" data-secondary="linking with code from languages other than Rust" data-type="indexterm" id="OEBPS/ch06.html.id1950"></a></p>
</li>
<li>
<p>It supports configurations without the full standard library <code>std</code>, allowing systems that do not<a data-primary="operating systems" data-secondary="systems not having full OS" data-type="indexterm" id="OEBPS/ch06.html.id1951"></a> have a full operating
system (e.g., no filesystem, no networking) to be targeted.</p>
</li>
<li>
<p>It even supports configurations that do not support <a data-primary="heap" data-type="indexterm" id="OEBPS/ch06.html.id1952"></a><a data-primary="stack" data-type="indexterm" id="OEBPS/ch06.html.id1953"></a><a data-primary="alloc" data-type="indexterm" id="OEBPS/ch06.html.id1954"></a>heap allocation but only have a stack (by omitting use of
the standard <code>alloc</code> library).</p>
</li>
</ul>

<p>These nonstandard Rust environments can be harder to work in and may be less <span class="keep-together">safe—</span>they can even be
<code>unsafe</code>—but they give more options for getting the job done.<a data-primary="unsafe mode" data-type="indexterm" id="OEBPS/ch06.html.id1955"></a></p>

<p>This chapter of the book discusses just a few of the basics for working in these environments.<a data-primary="Rustonomicon" data-type="indexterm" id="OEBPS/ch06.html.id1956"></a> Beyond these basics, you’ll
need to consult more environment-specific documentation (such as the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/nomicon/"><em>Rustonomicon</em></a>).</p>






<section data-pdf-bookmark="Item 33: Consider making library code 
no_std compatible" data-type="sect1"><div class="sect1" id="OEBPS/ch06.html.file_no-std_md">
<h1>Item 33: Consider making library code 
<span class="keep-together"><code>no_std</code> compatible</span></h1>

<p>Rust comes with a <a data-primary="libraries" data-secondary="making library code no_std-compatible" data-type="indexterm" id="OEBPS/ch06.html.ix_libnostd"></a><a data-primary="std library" data-secondary="wide variety of common tasks covered in" data-type="indexterm" id="OEBPS/ch06.html.id1957"></a>standard library called  <code>std</code>, which includes code for a wide variety of common tasks, from standard
data structures to networking, from multithreading support to file I/O.  For convenience, several of the items from <code>std</code>
are automatically imported into your program, via the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/prelude/index.html"><em>prelude</em></a>: a set of common  <code>use</code> statements <a data-primary="prelude" data-type="indexterm" id="OEBPS/ch06.html.id1958"></a><a data-primary="use statements" data-type="indexterm" id="OEBPS/ch06.html.id1959"></a><a data-primary="types" data-secondary="making common types available without using full names" data-type="indexterm" id="OEBPS/ch06.html.id1960"></a>that
make common types available without needing to use their full names (e.g., <code>Vec</code> rather than <code>std::vec::Vec</code>).</p>

<p>Rust also supports building code <a data-primary="std library" data-secondary="code for environments where full std not provided" data-type="indexterm" id="OEBPS/ch06.html.id1961"></a>for environments where it’s not possible to provide this full standard library, such as
bootloaders, firmware, or embedded platforms in general.<a data-primary="bootloaders" data-type="indexterm" id="OEBPS/ch06.html.id1962"></a><a data-primary="firmware" data-type="indexterm" id="OEBPS/ch06.html.id1963"></a><a data-primary="embedded platforms" data-type="indexterm" id="OEBPS/ch06.html.id1964"></a><a data-primary="crates" data-secondary="no_std compatibility" data-type="indexterm" id="OEBPS/ch06.html.id1965"></a><a data-primary="no_std attribute" data-type="indexterm" id="OEBPS/ch06.html.id1966"></a>  Crates indicate that they should be built in this way by
including the  
<span class="keep-together"><code>#![no_std]</code></span> crate-level attribute at the top of <em>src/lib.rs</em>.</p>

<p>This Item explores what’s lost when building for <code>no_std</code> and what library functions you can still rely on—which
turns out to be quite a lot.</p>

<p>However, this Item is specifically about <code>no_std</code> support in <em>library</em> code.  <a data-primary="no_std attribute" data-secondary="binary, difficulty of creating" data-type="indexterm" id="OEBPS/ch06.html.id1967"></a>The difficulties of making a <code>no_std</code>
<em>binary</em> are beyond this text,<sup><a data-type="noteref" href="#OEBPS/ch06.html.id1968" id="OEBPS/ch06.html.id1968-marker">1</a></sup> so the focus here is how to make sure that library code is available
for those poor souls who do have to work in such a minimal environment.</p>








<section data-pdf-bookmark="core" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id153">
<h2><code>core</code></h2>

<p>Even when building for the most restricted of platforms, many of the fundamental types from the standard library are
still available.<a data-primary="core library" data-type="indexterm" id="OEBPS/ch06.html.id1969"></a><a data-primary="libraries" data-secondary="making library code no_std-compatible" data-tertiary="core library" data-type="indexterm" id="OEBPS/ch06.html.id1970"></a>  For example,  <a class="orm:hideurl" href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>Option</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a> are<a data-primary="Option type" data-type="indexterm" id="OEBPS/ch06.html.id1971"></a><a data-primary="Iterator trait" data-type="indexterm" id="OEBPS/ch06.html.id1972"></a><a data-primary="Result type" data-type="indexterm" id="OEBPS/ch06.html.id1973"></a> still available, albeit under a different
name, as are various flavors of  <a class="orm:hideurl" href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>.</p>

<p>The different<a data-primary="no_std attribute" data-secondary="core library in no_std environments" data-type="indexterm" id="OEBPS/ch06.html.id1974"></a> names for these fundamental types start with <code>core::</code>, indicating <a data-primary="types" data-secondary="core and std" data-type="indexterm" id="OEBPS/ch06.html.id1975"></a><a data-primary="std library" data-secondary="core library types equivalent to" data-type="indexterm" id="OEBPS/ch06.html.id1976"></a>that they come from the  <code>core</code>
library, a standard library that’s available even in the most <code>no_std</code> of environments. These <code>core::</code> types behave
exactly the same as the equivalent <code>std::</code> types, because they’re actually the same types—in each case, the
<code>std::</code> version is just a  re-export of the underlying <code>core::</code> type.</p>

<p>This means that there’s a quick and dirty way to tell if a <code>std::</code>
item is available in a <code>no_std</code> environment: visit the <a class="orm:hideurl" href="https://doc.rust-lang.org/std/index.html"><code>doc.rust-lang.org</code></a>
page for the <code>std</code> item you’re interested in and follow the “source” link (at the top right).<sup><a data-type="noteref" href="#OEBPS/ch06.html.id1977" id="OEBPS/ch06.html.id1977-marker">2</a></sup>  If that takes you to a
<em>src/core/…​</em> location, then the item is available under <code>no_std</code> via <code>core::</code>.</p>

<p>The types from <code>core</code> are available for all Rust programs automatically.  However, they typically need to be
explicitly <code>use</code>d in a <code>no_std</code> environment, because the <code>std</code>  prelude is absent.<a data-primary="use statements" data-secondary="core types in no_std environments" data-type="indexterm" id="OEBPS/ch06.html.id1978"></a></p>

<p>In practice, relying purely on <code>core</code> is too limiting for many environments, even <code>no_std</code> ones.<a data-primary="heap" data-secondary="no heap allocation for core library" data-type="indexterm" id="OEBPS/ch06.html.id1979"></a><a data-primary="core library" data-secondary="no heap allocation performed by" data-type="indexterm" id="OEBPS/ch06.html.id1980"></a>  A
core (pun intended) constraint of <code>core</code> is that it performs <em>no heap allocation</em>.</p>

<p>Although Rust excels at putting items on the stack and safely tracking the corresponding lifetimes (<a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>), this
restriction still means that<a data-primary="data structures" data-secondary="standard" data-type="indexterm" id="OEBPS/ch06.html.id1981"></a><a data-primary="vectors" data-type="indexterm" id="OEBPS/ch06.html.id1982"></a><a data-primary="maps" data-type="indexterm" id="OEBPS/ch06.html.id1983"></a><a data-primary="sets" data-type="indexterm" id="OEBPS/ch06.html.id1984"></a> standard data <span class="keep-together">structures—</span>vectors, maps, sets—can’t be provided,
because they need to allocate  heap space for their contents.  In turn, this also drastically reduces the number of
available crates that work in this environment.</p>
</div></section>








<section data-pdf-bookmark="alloc" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id154">
<h2><code>alloc</code></h2>

<p>However, if a <code>no_std</code> environment <em>does</em> support heap allocation, then many of the standard data structures from <code>std</code> can
still be supported.<a data-primary="heap" data-secondary="no_std environment supporting heap allocation" data-type="indexterm" id="OEBPS/ch06.html.id1985"></a><a data-primary="alloc library" data-type="indexterm" id="OEBPS/ch06.html.id1986"></a><a data-primary="libraries" data-secondary="making library code no_std-compatible" data-tertiary="alloc library" data-type="indexterm" id="OEBPS/ch06.html.id1987"></a>  These data structures, along with other allocation-using functionality, are grouped into Rust’s
 <a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> library.</p>

<p>As with <code>core</code>, these <code>alloc</code> variants are actually the same types under the covers.  For example, the real name of
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>std::vec::Vec</code></a> is actually
<a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec</code></a>.</p>

<p>A <code>no_std</code> Rust crate <a data-primary="no_std attribute" data-secondary="opting in to alloc use" data-type="indexterm" id="OEBPS/ch06.html.id1988"></a>needs to explicitly opt in to the use of <code>alloc</code>, by adding an  <code>extern crate alloc;</code> declaration<a data-primary="extern crate alloc" data-type="indexterm" id="OEBPS/ch06.html.id1989"></a><a data-primary="extern crate" data-type="indexterm" id="OEBPS/ch06.html.id1990"></a> to <em>src/lib.rs</em>:<sup><a data-type="noteref" href="#OEBPS/ch06.html.id1991" id="OEBPS/ch06.html.id1991-marker">3</a></sup></p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">//! My `no_std` compatible crate.</code>
<code class="cp">#![no_std]</code><code class="w"></code>

<code class="c1">// Requires `alloc`.</code>
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">alloc</code><code class="p">;</code><code class="w"></code></pre>

<p>Pulling in the <code>alloc</code> crate enables <a data-primary="alloc library" data-secondary="types available in" data-type="indexterm" id="OEBPS/ch06.html.id1992"></a>many familiar friends, now addressed by their true names:</p>

<ul class="two-col">
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>alloc::boxed::Box&lt;T&gt;</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html"><code>alloc::rc::Rc&lt;T&gt;</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/sync/struct.Arc.html"><code>alloc::sync::Arc&lt;T&gt;</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec&lt;T&gt;</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/string/struct.String.html"><code>alloc::string::String</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/macro.format.html"><code>alloc::format!</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html"><code>alloc::collections::BTreeMap​&lt;K,</code>&nbsp;<code>V&gt;</code></a></p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/collections/btree_set/struct.BTreeSet.html"><code>alloc::collections::BTreeSet&lt;T&gt;</code></a></p>
</li>
</ul>

<p>With these things available, it becomes possible for many library crates to be <code>no_std</code> compatible—for
example, if a library doesn’t involve I/O or networking.</p>

<p>There’s a notable absence from the <a data-primary="data structures" data-secondary="made available from alloc" data-type="indexterm" id="OEBPS/ch06.html.id1993"></a><a data-primary="HashMap type" data-type="indexterm" id="OEBPS/ch06.html.id1994"></a>data structures that <code>alloc</code> makes available, <span class="keep-together">though—</span>the
collections
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a> are specific to <code>std</code>, not <code>alloc</code>.
That’s because these hash-based containers rely on random seeds to protect against hash collision attacks, but safe<a data-primary="random number generation" data-type="indexterm" id="OEBPS/ch06.html.id1995"></a> random
number generation requires assistance from the operating system—which <code>alloc</code> can’t assume exists.<a data-primary="HashSet type" data-type="indexterm" id="OEBPS/ch06.html.id1996"></a><a data-primary="synchronization primitives" data-type="indexterm" id="OEBPS/ch06.html.id1997"></a></p>

<p>Another notable absence is synchronization functionality like
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>std::sync::Mutex</code></a>, which is required for
multithreaded code (<a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>).  <a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch06.html.id1998"></a>These types are specific to  <code>std</code> because they rely on OS-specific synchronization
primitives, which aren’t available without an OS.<a data-primary="operating systems" data-secondary="synchronization primitives" data-type="indexterm" id="OEBPS/ch06.html.id1999"></a><a data-primary="spin crate" data-type="indexterm" id="OEBPS/ch06.html.id2000"></a>  If you need to write code that is both <code>no_std</code> and multithreaded,
third-party crates such as  <a class="orm:hideurl" href="https://docs.rs/spin/"><code>spin</code></a> are probably your only option.</p>
</div></section>








<section data-pdf-bookmark="Writing Code for no_std" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id155">
<h2>Writing Code for <code>no_std</code></h2>

<p>The previous sections made it clear that for <em>some</em> library crates, making the code <code>no_std</code> compatible just <a data-primary="no_std attribute" data-secondary="writing code for no_std environment" data-type="indexterm" id="OEBPS/ch06.html.id2001"></a><a data-primary="libraries" data-secondary="making library code no_std-compatible" data-tertiary="writing code for no-std" data-type="indexterm" id="OEBPS/ch06.html.id2002"></a><a data-primary="core library" data-secondary="using full type names" data-type="indexterm" id="OEBPS/ch06.html.id2003"></a><a data-primary="alloc library" data-secondary="full type names required" data-type="indexterm" id="OEBPS/ch06.html.id2004"></a><a data-primary="types" data-secondary="full type names required when not using std" data-type="indexterm" id="OEBPS/ch06.html.id2005"></a><a data-primary="BTreeMap type" data-type="indexterm" id="OEBPS/ch06.html.id2006"></a><a data-primary="BTreeSet type" data-type="indexterm" id="OEBPS/ch06.html.id2007"></a><a data-primary="std library" data-secondary="replacing std types with identical core and alloc crates" data-type="indexterm" id="OEBPS/ch06.html.id2008"></a>involves the following:</p>

<ul>
<li>
<p>Replacing <code>std::</code> types with identical <code>core::</code> or <code>alloc::</code> crates (which requires  <code>use</code> of the full type name,
due to the absence of the <code>std</code>  prelude)</p>
</li>
<li>
<p>Shifting from <code>HashMap</code>/<code>HashSet</code> to <code>BTreeMap</code>/<code>BTreeSet</code></p>
</li>
</ul>

<p>However, this only makes sense if all of the crates that you depend on (<a href="#OEBPS/ch04.html.file_dep-graph_md">Item 25</a>) are also <code>no_std</code>
compatible—there’s no point in becoming <code>no_std</code> compatible if any user of your crate is forced to link in <code>std</code>
anyway.<a data-primary="crates" data-secondary="no_std compatibility" data-type="indexterm" id="OEBPS/ch06.html.id2009"></a></p>

<p>There’s also a catch here: the Rust compiler will not tell you if your <code>no_std</code> crate depends on a <code>std</code>-using
dependency.<a data-primary="std library" data-secondary="no_std crate depending on std-using dependency" data-type="indexterm" id="OEBPS/ch06.html.id2010"></a> This means that it’s easy to undo the work of making a crate <code>no_std</code> compatible—all it
takes is an added or updated dependency that pulls in <code>std</code>.<a data-primary="dependencies" data-type="indexterm" id="OEBPS/ch06.html.id2011"></a></p>

<p>To protect against this, <em>add a CI check for a <code>no_std</code> build</em> so that your  CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) will
warn you if this happens.  <a data-primary="continuous integration" data-secondary="check for no_std build" data-type="indexterm" id="OEBPS/ch06.html.id2012"></a><a data-primary="cross-compilation" data-type="indexterm" id="OEBPS/ch06.html.id2013"></a>The Rust toolchain supports cross-compilation out of the box, so this can be as simple as
performing a
<a href="https://oreil.ly/DAbwt">cross-compile</a> for a
target system that does not support <code>std</code> (e.g., <code>--target thumbv6m-none-eabi</code>); any code that inadvertently requires
<code>std</code> will then fail to compile for this target.</p>

<p>So: if your dependencies support it, and the simple transformations above are all that’s needed, then <em>consider
making library code <code>no_std</code> compatible</em>.  When it is possible, it’s not much additional work, and it allows for the
widest reuse of the library.</p>

<p>If those transformations <em>don’t</em> cover all of the code in your crate but the parts that aren’t covered are only a small
or well-contained fraction of the code, then consider adding a  feature (<a href="#OEBPS/ch04.html.file_features_md">Item 26</a>) to your crate that turns on just
those parts.<a data-primary="features" data-secondary="std and alloc" data-type="indexterm" id="OEBPS/ch06.html.id2014"></a></p>

<p>Such a feature is conventionally named either <code>std</code>, if it enables use of <code>std</code>-specific functionality:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#![cfg_attr(not(feature = </code><code class="s">"std"</code><code class="cp">), no_std)]</code><code class="w"></code></pre>

<p>or <code>alloc</code>, if it turns on use of <code>alloc</code>-derived functionality:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[cfg(feature = </code><code class="s">"alloc"</code><code class="cp">)]</code><code class="w"></code>
<code class="k">extern</code><code class="w"> </code><code class="k">crate</code><code class="w"> </code><code class="n">alloc</code><code class="p">;</code><code class="w"></code></pre>

<p>Note that there’s a trap for the unwary here: don’t have a <code>no_std</code> feature that <em>disables</em> functionality requiring
<code>std</code> (or a <code>no_alloc</code> feature similarly).<a data-primary="features" data-secondary="no_standard and no_alloc, avoiding" data-type="indexterm" id="OEBPS/ch06.html.id2015"></a>  As explained in <a href="#OEBPS/ch04.html.file_features_md">Item 26</a>, features need to be additive, and there’s no way
to combine two users of the crate where one configures <code>no_std</code> and one doesn’t—the former will trigger the
removal of code that the latter relies on.</p>

<p>As ever with feature-gated code, make sure that your CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>) builds all the relevant
combinations—including a build with the <code>std</code> feature disabled on an explicitly <code>no_std</code> platform.</p>
</div></section>








<section data-pdf-bookmark="Fallible Allocation" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id156">
<h2>Fallible Allocation</h2>

<p>The earlier sections of this Item <a data-primary="libraries" data-secondary="making library code no_std-compatible" data-tertiary="fallible allocation" data-type="indexterm" id="OEBPS/ch06.html.id2016"></a><a data-primary="allocation" data-secondary="fallible" data-type="indexterm" id="OEBPS/ch06.html.id2017"></a><a data-primary="fallible allocation" data-type="indexterm" id="OEBPS/ch06.html.id2018"></a>considered two different <code>no_std</code> environments: a fully embedded environment with no
heap allocation whatsoever (<code>core</code>) and a more generous environment where heap allocation is allowed (<code>core</code> +
<code>alloc</code>).</p>

<p>However, there are some important environments that fall between these two camps⁠—​in particular, those where heap<a data-primary="heap" data-secondary="heap allocation possible, but may fail" data-type="indexterm" id="OEBPS/ch06.html.id2019"></a>
allocation is possible but may fail because there’s a limited amount of heap.</p>

<p>Unfortunately, Rust’s standard  <code>alloc</code> library includes a pervasive assumption that  heap allocations cannot fail, and that’s not always a valid assumption.<a data-primary="alloc library" data-secondary="assumption that heap allocation can't fail" data-type="indexterm" id="OEBPS/ch06.html.id2020"></a></p>

<p>Even a<a data-primary="Vec type" data-type="indexterm" id="OEBPS/ch06.html.id2021"></a> simple use of <code>alloc::vec::Vec</code> could potentially allocate on every line:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>
<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"> </code><code class="c1">// might allocate</code>
<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"> </code><code class="c1">// might allocate</code>
<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"> </code><code class="c1">// might allocate</code>
<code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code><code class="w"> </code><code class="c1">// might allocate</code></pre>

<p>None of these operations returns a <code>Result</code>, so what happens if those allocations fail?</p>

<p>The answer depends on the toolchain, target, and
<a href="https://oreil.ly/5kPxH">configuration</a> but is likely to descend into
 <code>panic!</code> and program termination.<a data-primary="panics" data-type="indexterm" id="OEBPS/ch06.html.id2022"></a><a data-primary="failures" data-secondary="allocation failure" data-type="indexterm" id="OEBPS/ch06.html.id2023"></a>  There is certainly no answer that allows an allocation failure on line 3 to be
handled in a way that allows the program to move on to line 4.</p>

<p class="pagebreak-before less_space">This assumption of  <em>infallible allocation</em> gives good <a data-primary="infallible allocation" data-type="indexterm" id="OEBPS/ch06.html.id2024"></a>ergonomics for code that runs in a “normal”
userspace, where there’s effectively infinite memory—or at least where running out of memory indicates that the
computer as a whole has bigger problems 
<span class="keep-together">elsewhere</span>.<a data-primary="allocation" data-secondary="infallible" data-type="indexterm" id="OEBPS/ch06.html.id2025"></a></p>

<p>However, infallible allocation is utterly unsuitable for code that needs to run in environments where memory is
limited and programs are required to cope.  This is a (rare) area where there’s better support in older, less
memory-safe, languages:</p>

<ul>
<li>
<p>C is sufficiently low-level that allocations are<a data-primary="C" data-secondary="manual allocations, malloc" data-type="indexterm" id="OEBPS/ch06.html.id2026"></a> manual, and so the return value from <code>malloc</code> can be checked for <code>NULL</code>.</p>
</li>
<li>
<p>C++ can use its<a data-primary="C++" data-secondary="allocation failures, caught with exception system" data-type="indexterm" id="OEBPS/ch06.html.id2027"></a>  exception mechanism to catch allocation failures in the form
of <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc"><code>std::bad_alloc</code></a> exceptions.<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2028" id="OEBPS/ch06.html.id2028-marker">4</a></sup></p>
</li>
</ul>

<p>Historically, the <a data-primary="std library" data-secondary="inability to cope with failed allocation" data-type="indexterm" id="OEBPS/ch06.html.id2029"></a>inability of Rust’s standard library to cope with failed allocation was flagged in some high-profile
contexts (such as the <a href="https://oreil.ly/hzzCR">Linux kernel</a>, Android, and the <a href="https://oreil.ly/jvfOw">Curl tool</a>), and so work to fix the
omission is ongoing.<a data-primary="Linux kernel" data-type="indexterm" id="OEBPS/ch06.html.id2030"></a><a data-primary="Android" data-type="indexterm" id="OEBPS/ch06.html.id2031"></a><a data-primary="Curl tool" data-type="indexterm" id="OEBPS/ch06.html.id2032"></a></p>

<p>The first step was the  <a href="https://oreil.ly/gyhpR">“fallible collection allocation” changes</a>, which added  fallible alternatives to many of the collection
APIs that involve allocation.<a data-primary="collections" data-secondary="fallible allocation changes in" data-type="indexterm" id="OEBPS/ch06.html.id2033"></a>  This generally adds a <code>try_&lt;operation&gt;</code> variant that results in a <code>Result&lt;_,</code> 
<span class="keep-together"><code>AllocError&gt;</code></span>;
for example:</p>

<ul>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve"><code>Vec::try_reserve</code></a> is available as an<a data-primary="try_reserve method" data-type="indexterm" id="OEBPS/ch06.html.id2034"></a><a data-primary="try_new method" data-type="indexterm" id="OEBPS/ch06.html.id2035"></a>
alternative to
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a>.</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.try_new"><code>Box::try_new</code></a> is available (with the nightly
toolchain) as an alternative to <a class="orm:hideurl" href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a>.</p>
</li>
</ul>

<p>These fallible APIs only go so far; for example, there is (as yet) no fallible equivalent to
<a class="orm:hideurl" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>Vec::push</code></a>, so code that assembles a vector may need
to do careful calculations<a data-primary="push method" data-type="indexterm" id="OEBPS/ch06.html.id2036"></a><a data-primary="Vec type" data-secondary="Vec::push" data-type="indexterm" id="OEBPS/ch06.html.id2037"></a> to ensure that allocation errors can’t happen:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">fn</code> <code class="nf">try_build_a_vec</code><code class="p">()</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="nb">Vec</code><code class="o">&lt;</code><code class="kt">u8</code><code class="o">&gt;</code><code class="p">,</code><code class="w"> </code><code class="nb">String</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Vec</code>::<code class="n">new</code><code class="p">();</code><code class="w"></code>

<code class="w">    </code><code class="c1">// Perform a careful calculation to figure out how much space is needed,</code>
<code class="w">    </code><code class="c1">// here simplified to...</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">required_size</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">4</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">try_reserve</code><code class="p">(</code><code class="n">required_size</code><code class="p">)</code><code class="w"></code>
<code class="w">        </code><code class="p">.</code><code class="n">map_err</code><code class="p">(</code><code class="o">|</code><code class="n">_e</code><code class="o">|</code><code class="w"> </code><code class="fm">format!</code><code class="p">(</code><code class="s">"Failed to allocate {} items!"</code><code class="p">,</code><code class="w"> </code><code class="n">required_size</code><code class="p">))</code><code class="o">?</code><code class="p">;</code><code class="w"></code>

<code class="w">    </code><code class="c1">// We now know that it's safe to do:</code>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="n">v</code><code class="p">.</code><code class="n">push</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code><code class="w"></code>

<code class="w">    </code><code class="nb">Ok</code><code class="p">(</code><code class="n">v</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>As well as adding fallible <a data-primary="infallible allocation" data-secondary="disabling" data-type="indexterm" id="OEBPS/ch06.html.id2038"></a>allocation entrypoints, it’s also possible to disable <em>infallible</em> allocation operations,
by turning off the  <a class="orm:hideurl" href="https://github.com/rust-lang/rust/pull/84266"><code>no_global_oom_handling</code></a> config flag (which is
on by default).<a data-primary="no_global_oom_handling config flag" data-type="indexterm" id="OEBPS/ch06.html.id2039"></a>  Environments with limited heap (such as the Linux kernel) can explicitly disable this flag, ensuring
that no use of infallible allocation can inadvertently creep into the code.</p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id176">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Many items in the <code>std</code> crate actually come from <code>core</code> or <code>alloc</code>.</p>
</li>
<li>
<p>As a result, making library code <code>no_std</code> compatible may be more straightforward than you might think.</p>
</li>
<li>
<p>Confirm that <code>no_std</code> code remains <code>no_std</code> compatible by checking it in CI.</p>
</li>
<li>
<p>Be aware that working in a limited-heap environment currently has limited library support.<a data-primary="libraries" data-secondary="making library code no_std-compatible" data-startref="ix_libnostd" data-type="indexterm" id="OEBPS/ch06.html.id2040"></a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 34: Control what crosses FFI boundaries" data-type="sect1"><div class="sect1" id="OEBPS/ch06.html.file_ffi_md">
<h1>Item 34: Control what crosses FFI boundaries</h1>

<p>Even though Rust comes with a comprehensive <a class="orm:hideurl" href="https://doc.rust-lang.org/std/index.html">standard library</a> and a
burgeoning <a class="orm:hideurl" href="https://crates.io">crate ecosystem</a>, there is still a lot more non-Rust code in the world
than there is Rust code.<a data-primary="FFI (foreign-function interface)" data-type="indexterm" id="OEBPS/ch06.html.ix_FFI"></a></p>

<p>As with other recent languages, Rust helps with this problem by offering a <em>foreign function interface</em> (FFI)
mechanism, which allows interoperation with code and data structures written in different languages—despite the
name, FFI is not restricted to just functions.  This opens up the use of existing libraries in different languages, not
just those that have succumbed to the Rust community’s efforts to  “rewrite it in Rust” (RiiR).<a data-primary="rewrite it in Rust (RiiR)" data-type="indexterm" id="OEBPS/ch06.html.id2041"></a></p>

<p>The default target for Rust’s interoperability is the  C programming language, which is the same interop target
that other languages aim at.<a data-primary="C" data-secondary="default target for Rust's interoperability" data-type="indexterm" id="OEBPS/ch06.html.id2042"></a>  This is partly driven by the ubiquity of C libraries but is also driven by simplicity: C
acts as a “least common denominator” of interoperability, because it doesn’t need toolchain support of any of the more
advanced features that would be necessary for compatibility with other languages (e.g., garbage collection for Java or
Go, exceptions and templates for C++, function overrides for Java and C++, etc.).<a data-primary="Java" data-type="indexterm" id="OEBPS/ch06.html.id2043"></a><a data-primary="Go" data-type="indexterm" id="OEBPS/ch06.html.id2044"></a><a data-primary="C++" data-secondary="exceptions and templates" data-type="indexterm" id="OEBPS/ch06.html.id2045"></a></p>

<p>However, that’s not to say that interoperability with plain C is simple.  By including code written in a different
language, all of the guarantees and protections that Rust offers are up for grabs, particularly those involving memory
safety.</p>

<p>As a result, FFI code in Rust is automatically <code>unsafe</code>, and <a data-primary="unsafe code" data-secondary="FFI code in Rust" data-type="indexterm" id="OEBPS/ch06.html.id2046"></a>the advice in <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a> has to be bypassed. This Item
explores some replacement advice, and <a href="#OEBPS/ch06.html.file_bindgen_md">Item 35</a> will explore some tooling that helps to avoid some (but not all) of the
footguns involved in working with FFI.<a data-primary="Rustonomicon" data-type="indexterm" id="OEBPS/ch06.html.id2047"></a>  (The <a href="https://oreil.ly/2jHBA">FFI chapter</a> of the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/nomicon/"><em>Rustonomicon</em></a> also contains helpful advice and information.)</p>








<section data-pdf-bookmark="Invoking C Functions from Rust" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id158">
<h2>Invoking C Functions from Rust</h2>

<p>The <a data-primary="FFI (foreign-function interface)" data-secondary="invoking C functions from Rust" data-type="indexterm" id="OEBPS/ch06.html.id2048"></a><a data-primary="C" data-secondary="invoking C functions from Rust" data-type="indexterm" id="OEBPS/ch06.html.ix_Cfnct"></a>simplest FFI interaction is for Rust code to invoke a C function, taking “immediate” arguments that don’t involve
pointers, references, or memory addresses:</p>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* File lib.c */</code><code class="w"></code>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"lib.h"</code><code class="cp"></code>

<code class="cm">/* C function definition. */</code><code class="w"></code>
<code class="kt">int</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This C code provides a <em>definition</em> of the function and is typically accompanied by a  header file
that provides a <em>declaration</em> of the function, which allows other C code to use it:</p>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* File lib.h */</code><code class="w"></code>
<code class="cp">#ifndef LIB_H</code>
<code class="cp">#define LIB_H</code>

<code class="cm">/* C function declaration. */</code><code class="w"></code>
<code class="kt">int</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"></code>

<code class="cp">#endif  </code><code class="cm">/* LIB_H */</code><code class="cp"></code></pre>

<p>The declaration roughly says: somewhere out there is a function called <code>add</code>, which takes two integers as input and
returns another integer as output.  This allows C code to use the <code>add</code> function, subject to a promise that the actual
code for <code>add</code> will be provided at a later date—specifically, at  link time.</p>

<p>Rust code that wants to use <code>add</code> needs to have a similar declaration, with a similar purpose: to describe the
 signature of the function and to indicate that the corresponding code will be available later:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">use</code><code class="w"> </code><code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">;</code><code class="w"></code>
<code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="n">x</code>: <code class="nc">c_int</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="nc">c_int</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">c_int</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The declaration is
marked as  <code>extern "C"</code> to indicate that an<a data-primary="extern C" data-type="indexterm" id="OEBPS/ch06.html.id2049"></a> external C library will provide the code for the function.<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2050" id="OEBPS/ch06.html.id2050-marker">5</a></sup>   The <code>extern "C"</code> marker also automatically marks the function as
 <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/abi.html?highlight=no_mangle#the-no_mangle-attribute"><code>no_mangle</code></a>,
which we explore in <a data-type="xref" href="#OEBPS/ch06.html.name-mingling">“Name mangling”</a>.<a data-primary="no_mangle attribute" data-type="indexterm" id="OEBPS/ch06.html.id2051"></a></p>










<section data-pdf-bookmark="Linking logistics" data-type="sect3"><div class="sect3" id="OEBPS/ch06.html.id159">
<h3>Linking logistics</h3>

<p>The details of how the C<a data-primary="FFI (foreign-function interface)" data-secondary="invoking C functions from Rust" data-tertiary="linking logistics" data-type="indexterm" id="OEBPS/ch06.html.id2052"></a> toolchain generates an external C library—and its format—are environment-specific
and beyond the scope of a Rust book like this.<a data-primary="static library file" data-type="indexterm" id="OEBPS/ch06.html.id2053"></a><a data-primary="ar tool" data-type="indexterm" id="OEBPS/ch06.html.id2054"></a>  However, one simple variant that’s common on Unix-like systems is a
 <em>static library</em> file, which will normally have the form <em>lib&lt;something&gt;.a</em> (e.g., <em>libcffi.a</em>) and
which can be generated using the  <a class="orm:hideurl" href="https://man7.org/linux/man-pages/man1/ar.1.html"><code>ar</code></a> tool.</p>

<p>The Rust build system then needs an indication of which library holds the relevant C code.<a data-primary="link attribute" data-type="indexterm" id="OEBPS/ch06.html.id2055"></a> This can be specified either
via the <a href="https://oreil.ly/_N-Fv"><code>link</code> attribute</a> in the
code:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[link(name = </code><code class="s">"cffi"</code><code class="cp">)]</code><code class="w"> </code><code class="c1">// An external library like `libcffi.a` is needed</code>
<code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>
<code class="p">}</code><code class="w"></code></pre>

<p>or via a  <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> that emits a
<a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-lib"><code>cargo:rustc-link-lib</code></a>
instruction<a data-primary="cargo:rustc-link-lib" data-type="indexterm" id="OEBPS/ch06.html.id2056"></a><a data-primary="build scripts" data-secondary="emitting C library linkage information" data-type="indexterm" id="OEBPS/ch06.html.id2057"></a><a data-primary="links key" data-type="indexterm" id="OEBPS/ch06.html.id2058"></a> to <code>cargo</code>:<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2059" id="OEBPS/ch06.html.id2059-marker">6</a></sup></p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// File build.rs</code>
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// An external library like `libcffi.a` is needed</code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="s">"cargo:rustc-link-lib=cffi"</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The latter option is more flexible, because the build script can examine its environment and behave differently
depending on what it finds.</p>

<p>In either case, the Rust build system is also likely to need information about how to find the C library, if it’s not in
a standard system location.<a data-primary="cargo:rustc-link-search" data-type="indexterm" id="OEBPS/ch06.html.id2060"></a>  This can be specified by having a build script that emits a
<a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#rustc-link-search"><code>cargo:rustc-link-search</code></a> instruction
to <code>cargo</code>, containing the library location:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// File build.rs</code>
<code class="k">fn</code> <code class="nf">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// ...</code>

<code class="w">    </code><code class="c1">// Retrieve the location of `Cargo.toml`.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">dir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">std</code>::<code class="n">env</code>::<code class="n">var</code><code class="p">(</code><code class="s">"CARGO_MANIFEST_DIR"</code><code class="p">).</code><code class="n">unwrap</code><code class="p">();</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Look for native libraries one directory higher up.</code>
<code class="w">    </code><code class="fm">println!</code><code class="p">(</code><code class="w"></code>
<code class="w">        </code><code class="s">"cargo:rustc-link-search=native={}"</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">std</code>::<code class="n">path</code>::<code class="n">Path</code>::<code class="n">new</code><code class="p">(</code><code class="o">&amp;</code><code class="n">dir</code><code class="p">).</code><code class="n">join</code><code class="p">(</code><code class="s">".."</code><code class="p">).</code><code class="n">display</code><code class="p">()</code><code class="w"></code>
<code class="w">    </code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></section>










<section data-pdf-bookmark="Code concerns" data-type="sect3"><div class="sect3" id="OEBPS/ch06.html.id160">
<h3>Code concerns</h3>

<p>Returning to the source code, even this simplest of examples comes with some gotchas.<a data-primary="FFI (foreign-function interface)" data-secondary="invoking C functions from Rust" data-tertiary="code concerns" data-type="indexterm" id="OEBPS/ch06.html.id2061"></a><a data-primary="unsafe code" data-secondary="FFI code in Rust" data-type="indexterm" id="OEBPS/ch06.html.id2062"></a>  First, use of FFI functions is
automatically <code>unsafe</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">add</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">);</code><code class="w"></code></pre>

<pre data-code-language="text" data-type="programlisting">error[E0133]: call to unsafe function is unsafe and requires unsafe function
              or block
   --&gt; src/main.rs:176:13
    |
176 |     let x = add(1, 1);
    |             ^^^^^^^^^ call to unsafe function
    |
    = note: consult the function's documentation for information on how to
            avoid undefined behavior</pre>

<p>and so needs to be wrapped in <code>unsafe { }</code>.</p>

<p>The next<a data-primary="int type (in C)" data-type="indexterm" id="OEBPS/ch06.html.id2063"></a> thing to watch out for is the use of C’s <code>int</code> type, represented as
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/os/raw/type.c_int.html"><code>std::os::raw::c_int</code></a>. How big is an <code>int</code>?  It’s
<em>probably</em> true that the following<a data-primary="std::os::raw::c_int, size of" data-type="indexterm" id="OEBPS/ch06.html.id2064"></a> two things are the same:</p>

<ul>
<li>
<p>The size of an <code>int</code> for the toolchain that compiled the C library</p>
</li>
<li>
<p>The size of a <code>std::os::raw::c_int</code> for the Rust toolchain</p>
</li>
</ul>

<p>But why take the chance?  <em>Prefer sized types at FFI boundaries</em>, where possible—which<a data-primary="types" data-secondary="sized types at FFI boundaries" data-type="indexterm" id="OEBPS/ch06.html.id2065"></a> for C means
making use of the types (e.g., <code>uint32_t</code>) defined in <code>&lt;stdint.h&gt;</code>.  However, if you’re dealing with an existing codebase
that already uses <code>int</code>/<code>long</code>/<code>size_t</code>, this may be a luxury you don’t have.</p>

<p>The final practical concern is that the C code and the equivalent Rust declaration need to exactly match.  Worse still,
if there’s a mismatch, the build tools will not emit a warning—they will just silently emit incorrect code.<a data-primary="bindgen" data-type="indexterm" id="OEBPS/ch06.html.id2066"></a></p>

<p><a href="#OEBPS/ch06.html.file_bindgen_md">Item 35</a> discusses the use of the  <code>bindgen</code> tool to prevent this problem, but it’s worth understanding the basics
of what’s going on under the covers to understand <em>why</em> the build tools can’t detect the problem on their
own.  In particular, it’s worth understanding the basics of  <em>name mangling</em>.</p>
</div></section>










<section class="pagebreak-before" data-pdf-bookmark="Name mangling" data-type="sect3"><div class="sect3" id="OEBPS/ch06.html.name-mingling">
<h3>Name mangling</h3>

<p>Compiled languages <a data-primary="FFI (foreign-function interface)" data-secondary="invoking C functions from Rust" data-tertiary="name mangling" data-type="indexterm" id="OEBPS/ch06.html.id2067"></a><a data-primary="name mangling" data-type="indexterm" id="OEBPS/ch06.html.id2068"></a>generally support  <em>separate compilation</em>, where<a data-primary="separate compilation" data-type="indexterm" id="OEBPS/ch06.html.id2069"></a> different parts of the program are converted
into machine code as separate chunks (object files), which can then be combined into a complete program by the
 <em>linker</em>.  <a data-primary="linker" data-type="indexterm" id="OEBPS/ch06.html.id2070"></a>This means that if only one small part of the program’s source code changes, only the corresponding
object file needs to be regenerated; the link step then rebuilds the program, combining both the changed object and all
the other unmodified objects.</p>

<p>The <a href="https://oreil.ly/gzfEl">link step is (roughly speaking) a “join-the-dots” operation</a>: some
object files provide definitions of functions and variables, and other object files have placeholder markers indicating that
they expect to use a definition from some other object, but it wasn’t available at compile time.  The linker combines
the two: it ensures that any placeholder in the compiled code is replaced with a reference to the corresponding concrete
definition.</p>

<p>The linker performs this correlation between the placeholders and the definitions by simply checking for a matching
name, meaning that there is a single global namespace for all of these correlations.</p>

<p>Historically, this was fine for linking C language programs, where a single name could not be reused in any
way—the name of a function is exactly what appears in the object file.  (As a result, a common convention for C
libraries is to manually add a prefix to all symbols so that <code>lib1_process</code> doesn’t clash with <code>lib2_process</code>.)</p>

<p>However, the<a data-primary="C++" data-secondary="overridden definitions with same name" data-type="indexterm" id="OEBPS/ch06.html.id2071"></a> introduction of  C++ caused a problem because C++ allows overridden definitions with the same name:</p>

<pre data-code-language="c++" data-type="programlisting"><code class="c1">// C++ code</code>
<code class="k">namespace</code><code class="w"> </code><code class="nn">ns1</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="kt">int32_t</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int32_t</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int32_t</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="kt">int64_t</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int64_t</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int64_t</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="k">namespace</code><code class="w"> </code><code class="nn">ns2</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="kt">int32_t</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int32_t</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int32_t</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The solution for this is  <em>name mangling</em>: the <a class="orm:hideurl" href="https://lurklurk.org/linkers/linkers.html#namemangling">compiler encodes the signature and type information</a> for the overridden functions into the name that’s
emitted in the object file, and the linker continues to perform its simple-minded 1:1 correlation between placeholders
and definitions.</p>

<p>On Unix-like systems, the  <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Nm_%28Unix%29"><code>nm</code></a> tool can help<a data-primary="nm tool" data-type="indexterm" id="OEBPS/ch06.html.id2072"></a> show what the linker
works with:</p>

<pre data-code-language="text" data-type="programlisting">% nm ffi-lib.o | grep add  # what the linker sees for C
0000000000000000 T _add

% nm ffi-cpp-lib.o | grep add  # what the linker sees for C++
0000000000000000 T __ZN3ns13addEii
0000000000000020 T __ZN3ns13addExx
0000000000000040 T __ZN3ns23addEii</pre>

<p>In this case, it shows three mangled<a data-primary="text section" data-type="indexterm" id="OEBPS/ch06.html.id2073"></a><a data-primary="c++filt" data-type="indexterm" id="OEBPS/ch06.html.id2074"></a> symbols, all of which refer to code (the <code>T</code> indicates the  <em>text section</em> of
the binary, which is the traditional name for where code lives).</p>

<p>The  <a class="orm:hideurl" href="https://man7.org/linux/man-pages/man1/c%2b%2bfilt.1.html"><code>c++filt</code></a> tool helps translate this back into what
would be visible in C++ code:</p>

<pre data-code-language="text" data-type="programlisting">% nm ffi-cpp-lib.o | grep add | c++filt  # what the programmer sees
0000000000000000 T ns1::add(int, int)
0000000000000020 T ns1::add(long long, long long)
0000000000000040 T ns2::add(int, int)</pre>

<p>Because the mangled name includes type information, the linker can and will complain about any mismatch in the type
information between placeholder and definition.<a data-primary="type safety" data-type="indexterm" id="OEBPS/ch06.html.id2075"></a> This gives some measure of type safety: if the definition changes but
the place using it is not updated, the toolchain will complain.</p>

<p>Returning to Rust, <code>extern "C"</code> foreign<a data-primary="extern C" data-type="indexterm" id="OEBPS/ch06.html.id2076"></a> functions are implicitly marked as  <code>#[no_mangle]</code>, and the
symbol in the object file is the bare name, exactly as it would be for a C program.  This means that the type safety of
function signatures is lost: because the linker sees only the bare names for functions, if there are any differences in
type expectations between definition and use, the linker will carry on regardless and problems will arise only at
runtime.<a data-primary="type safety" data-secondary="of function signatures" data-secondary-sortas="function" data-type="indexterm" id="OEBPS/ch06.html.id2077"></a><a data-primary="C" data-secondary="invoking C functions from Rust" data-startref="ix_Cfnct" data-type="indexterm" id="OEBPS/ch06.html.id2078"></a></p>
</div></section>
</div></section>








<section data-pdf-bookmark="Accessing C Data from Rust" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id162">
<h2>Accessing C Data from Rust</h2>

<p>The C <code>add</code> example in the previous section passed the simplest possible type of data back and forth between Rust and C:
an integer that fits in a machine register.<a data-primary="FFI (foreign-function interface)" data-secondary="accessing C data from Rust" data-type="indexterm" id="OEBPS/ch06.html.ix_FFICdata"></a><a data-primary="C" data-secondary="accessing C data from Rust" data-type="indexterm" id="OEBPS/ch06.html.ix_Cdata"></a>  Even so, there were still things to be careful about, so it’s no surprise
then that dealing with more complex data structures also has wrinkles to watch out for.</p>

<p>Both C and Rust use the  <code>struct</code> to combine related data into a single data structure.<a data-primary="struct types" data-secondary="in C and Rust" data-secondary-sortas="C" data-type="indexterm" id="OEBPS/ch06.html.id2079"></a>  However, when a <code>struct</code>
is realized in memory, the two languages may well choose to put different fields in different places or even in
different orders (the  <em><a href="https://oreil.ly/cjkXO">layout</a></em>).  <a data-primary="repr(C)" data-type="indexterm" id="OEBPS/ch06.html.id2080"></a>To prevent mismatches,
<em>use  <code>#[repr(C)]</code> for Rust types used in FFI</em>; this <a class="orm:hideurl" href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation">representation is designed for the purpose of allowing C interoperability</a>:</p>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C data structure definition. */</code><code class="w"></code>
<code class="cm">/* Changes here must be reflected in lib.rs. */</code><code class="w"></code>
<code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kt">uint8_t</code><code class="w"> </code><code class="n">byte</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">integer</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">;</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Equivalent Rust data structure.</code>
<code class="c1">// Changes here must be reflected in lib.h / lib.c.</code>
<code class="cp">#[repr(C)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">byte</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">integer</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The structure definitions have a comment to remind the humans involved that the two places need to be kept in sync.
Relying on the constant vigilance of humans is likely to go wrong in the long term; as for <a data-primary="bindgen" data-type="indexterm" id="OEBPS/ch06.html.id2081"></a>function signatures, it’s
better to automate this synchronization between the two languages via a tool like <code>bindgen</code> (<a href="#OEBPS/ch06.html.file_bindgen_md">Item 35</a>).</p>

<p>One particular type of data that’s worth thinking about carefully for FFI interactions is strings.<a data-primary="strings" data-secondary="in Rust and C" data-secondary-sortas="Rust" data-type="indexterm" id="OEBPS/ch06.html.id2082"></a>  The default
definitions of what makes up a string are somewhat different between C and Rust:</p>

<ul>
<li>
<p>A Rust  <a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/string/struct.String.html"><code>String</code></a> holds  UTF-8 encoded data,
possibly including zero bytes,  with an explicitly known length.<a data-primary="String type" data-type="indexterm" id="OEBPS/ch06.html.id2083"></a></p>
</li>
<li>
<p>A C string (<code>char *</code>) holds byte values (which may or may not be signed), with its length implicitly determined by the
first zero byte (<code>\0</code>) found in the data.<a data-primary="char * (C string)" data-type="indexterm" id="OEBPS/ch06.html.id2084"></a></p>
</li>
</ul>

<p>Fortunately, dealing with C-style strings in Rust is comparatively straightforward, because the Rust library designers
have already done the heavy lifting by providing a pair of types to encode them. <em>Use the
 <a class="orm:hideurl" href="https://doc.rust-lang.org/alloc/ffi/struct.CString.html"><code>CString</code></a> type</em> to hold (owned) strings that need to<a data-primary="CString type" data-type="indexterm" id="OEBPS/ch06.html.id2085"></a>
be interoperable with C, and use the corresponding
 <a class="orm:hideurl" href="https://doc.rust-lang.org/core/ffi/struct.CStr.html"><code>CStr</code></a> type when dealing with borrowed string
values.<a data-primary="CStr type" data-type="indexterm" id="OEBPS/ch06.html.id2086"></a>  The latter type includes the <a class="orm:hideurl" href="https://doc.rust-lang.org/core/ffi/struct.CStr.html#method.as_ptr"><code>as_ptr()</code></a>
method, which can be used to pass the string’s contents to any FFI function that’s expecting a <code>const char*</code> C string.<a data-primary="const char* (C string)" data-type="indexterm" id="OEBPS/ch06.html.id2087"></a><a data-primary="as_ptr method" data-type="indexterm" id="OEBPS/ch06.html.id2088"></a>
Note that the <code>const</code> is important: this can’t be used for an FFI function that needs to modify the contents (<code>char *</code>)
of the string that’s passed to it.<a data-primary="FFI (foreign-function interface)" data-secondary="accessing C data from Rust" data-startref="ix_FFICdata" data-type="indexterm" id="OEBPS/ch06.html.id2089"></a><a data-primary="C" data-secondary="accessing C data from Rust" data-startref="ix_Cdata" data-type="indexterm" id="OEBPS/ch06.html.id2090"></a></p>
</div></section>








<section data-pdf-bookmark="Lifetimes" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id163">
<h2>Lifetimes</h2>

<p>Most data structures are too big to fit in a register and so have to be held in memory instead.<a data-primary="lifetimes" data-type="indexterm" id="OEBPS/ch06.html.id2091"></a><a data-primary="FFI (foreign-function interface)" data-secondary="lifetimes" data-type="indexterm" id="OEBPS/ch06.html.id2092"></a>  That in turn means that
access to the data is performed via the location of that memory.<a data-primary="pointers" data-secondary="in C" data-secondary-sortas="C" data-type="indexterm" id="OEBPS/ch06.html.id2093"></a> In C terms, this means a  <em>pointer</em>: a number
that encodes a memory address—with no other semantics attached (<a href="#OEBPS/ch01.html.file_references_md">Item 8</a>).</p>

<p>In Rust, a location<a data-primary="references" data-type="indexterm" id="OEBPS/ch06.html.id2094"></a><a data-primary="raw pointers" data-type="indexterm" id="OEBPS/ch06.html.id2095"></a> in memory is generally represented as a  <em>reference</em>, and its numeric value can be extracted
as a  <em>raw pointer</em>, ready to feed into an FFI boundary:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// C function that does some operation on the contents</code>
<code class="w">    </code><code class="c1">// of an `FfiStruct`.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">use_struct</code><code class="p">(</code><code class="n">v</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="n">v</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="n">byte</code>: <code class="mi">1</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="n">integer</code>: <code class="mi">42</code><code class="p">,</code><code class="w"></code>
<code class="p">};</code><code class="w"></code>
<code class="kd">let</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">use_struct</code><code class="p">(</code><code class="o">&amp;</code><code class="n">v</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"></code></pre>

<p>However, a Rust <a data-primary="references" data-secondary="lifetimes of" data-type="indexterm" id="OEBPS/ch06.html.id2096"></a>reference comes with additional constraints around the  <em>lifetime</em> of the associated chunk of
memory, as described in <a href="#OEBPS/ch03.html.file_lifetimes_md">Item 14</a>; these constraints get lost in the conversion to a raw pointer.</p>

<p>As a result, the use of raw pointers is inherently <code>unsafe</code>, as a marker that  Here Be Dragons: the C code<a data-primary="Here Be Dragons" data-type="indexterm" id="OEBPS/ch06.html.id2097"></a><a data-primary="unsafe code" data-secondary="raw pointers" data-type="indexterm" id="OEBPS/ch06.html.id2098"></a> on the
other side of the FFI boundary <a data-primary="memory" data-secondary="safety of" data-type="indexterm" id="OEBPS/ch06.html.id2099"></a>could do any number of things that will destroy Rust’s memory safety:</p>

<ul>
<li>
<p>The C code could hang<a data-primary="use-after-free" data-type="indexterm" id="OEBPS/ch06.html.id2100"></a> onto the value of the pointer and use it at a later point when the associated memory has
either been freed from the heap or reused on the stack  (<em>use-after-free</em>).</p>
</li>
<li>
<p>The C code could<a data-primary="const (pointers)" data-type="indexterm" id="OEBPS/ch06.html.id2101"></a> decide to cast away the <code>const</code>-ness of a pointer that’s passed to it and modify data that Rust
expects to be immutable.</p>
</li>
<li>
<p>The C code is not subject to Rust’s <code>Mutex</code> protections, so <a data-primary="Mutex type" data-type="indexterm" id="OEBPS/ch06.html.id2102"></a><a data-primary="data races" data-type="indexterm" id="OEBPS/ch06.html.id2103"></a>the specter of data races (<a href="#OEBPS/ch03.html.file_deadlock_md">Item 17</a>)
rears its ugly head.</p>
</li>
<li>
<p>The C code could mistakenly return associated heap memory to the allocator (by <a data-primary="free function (in C)" data-type="indexterm" id="OEBPS/ch06.html.id2104"></a>calling C’s   <code>free()</code>
library function), meaning that the <em>Rust</em> code might now be performing use-after-free operations.<a data-primary="heap" data-secondary="C code freeing heap memory" data-type="indexterm" id="OEBPS/ch06.html.id2105"></a></p>
</li>
</ul>

<p>All of these dangers form part of the cost-benefit analysis of using an existing library via FFI.<a data-primary="FFI (foreign-function interface)" data-secondary="using existing library via, cost-benefit analysis" data-type="indexterm" id="OEBPS/ch06.html.id2106"></a>  On the plus side, you
get to reuse existing code that’s (presumably) in good working order, with only the need to write (or auto-generate)
corresponding declarations.<a data-primary="memory" data-secondary="protections in Rust" data-type="indexterm" id="OEBPS/ch06.html.id2107"></a>  On the minus side, you lose the memory protections that are a big reason to use Rust in the
first place.</p>

<p>As a first step to reduce the chances of memory-related problems, <em>allocate and free memory on the same side of
the FFI boundary</em>.<a data-primary="memory" data-secondary="allocating and freeing on same side of FFI boundary" data-type="indexterm" id="OEBPS/ch06.html.id2108"></a>  For example, this might appear as a symmetric pair of functions:</p>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C functions. */</code><code class="w"></code>

<code class="cm">/* Allocate an `FfiStruct` */</code><code class="w"></code>
<code class="n">FfiStruct</code><code class="o">*</code><code class="w"> </code><code class="nf">new_struct</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">v</code><code class="p">);</code><code class="w"></code>
<code class="cm">/* Free a previously allocated `FfiStruct` */</code><code class="w"></code>
<code class="kt">void</code><code class="w"> </code><code class="nf">free_struct</code><code class="p">(</code><code class="n">FfiStruct</code><code class="o">*</code><code class="w"> </code><code class="n">s</code><code class="p">);</code><code class="w"></code></pre>

<p>with corresponding Rust FFI declarations:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// C code to allocate an `FfiStruct`.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new_struct</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="c1">// C code to free a previously allocated `FfiStruct`.</code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">free_struct</code><code class="p">(</code><code class="n">s</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">);</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>To make sure that allocation and freeing are kept in sync, it can be a good idea to implement <a data-primary="RAII (Resource Acquisition Is Initialization) pattern" data-secondary="wrapper that prevents C memory leaks" data-type="indexterm" id="OEBPS/ch06.html.id2109"></a><a data-primary="RAII (Resource Acquisition Is Initialization) pattern" data-type="indexterm" id="OEBPS/ch06.html.id2110"></a>an  RAII wrapper that
automatically prevents C-allocated memory from being leaked (<a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>).  The wrapper structure owns the C-allocated
memory:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Wrapper structure that owns memory allocated by the C library.</code>
<code class="k">struct</code> <code class="nc">FfiWrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Invariant: inner is non-NULL.</code>
<code class="w">    </code><code class="n">inner</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>and the  <code>Drop</code> implementation <a data-primary="Drop trait" data-type="indexterm" id="OEBPS/ch06.html.id2111"></a>returns that memory to the C library to avoid the potential for
leaks:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="sd">/// Manual implementation of [`Drop`], which ensures that memory allocated</code>
<code class="sd">/// by the C library is freed by it.</code>
<code class="k">impl</code><code class="w"> </code><code class="nb">Drop</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">FfiWrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">drop</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Safety: `inner` is non-NULL, and besides `free_struct()` copes</code>
<code class="w">        </code><code class="c1">// with NULL pointers.</code>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">free_struct</code><code class="p">(</code><code class="bp">self</code><code class="p">.</code><code class="n">inner</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The same principle applies to more than just heap memory: <em>implement <code>Drop</code> to apply RAII to FFI-derived resources</em>—open files, database connections, etc. (see <a href="#OEBPS/ch02.html.file_raii_md">Item 11</a>).</p>

<p>Encapsulating the interactions with <a data-primary="struct types" data-secondary="encapsulating interaction with C library in wrapper struct" data-type="indexterm" id="OEBPS/ch06.html.id2112"></a><a data-primary="wrapper struct for C library interaction" data-type="indexterm" id="OEBPS/ch06.html.id2113"></a>the C library into a wrapper <code>struct</code> also makes it possible to catch some other
potential footguns, for example, by transforming an otherwise invisible failure into a <code>Result</code>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">type</code> <code class="nc">Error</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">String</code><code class="p">;</code><code class="w"></code>

<code class="k">impl</code><code class="w"> </code><code class="n">FfiWrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">val</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nb">Result</code><code class="o">&lt;</code><code class="bp">Self</code><code class="p">,</code><code class="w"> </code><code class="n">Error</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">p</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">new_struct</code><code class="p">(</code><code class="n">val</code><code class="p">)</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Raw pointers are not guaranteed to be non-NULL.</code>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="n">p</code><code class="p">.</code><code class="n">is_null</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="nb">Err</code><code class="p">(</code><code class="s">"Failed to get inner struct!"</code><code class="p">.</code><code class="n">into</code><code class="p">())</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="nb">Ok</code><code class="p">(</code><code class="bp">Self</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">inner</code>: <code class="nc">p</code><code class="w"> </code><code class="p">})</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>The wrapper structure can then offer safe methods that allow use of the C library’s functionality:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">FfiWrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">set_byte</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">,</code><code class="w"> </code><code class="n">b</code>: <code class="kt">u8</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Safety: relies on invariant that `inner` is non-NULL.</code>
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="n">r</code>: <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">inner</code><code class="w"> </code><code class="p">};</code><code class="w"></code>
<code class="w">        </code><code class="n">r</code><code class="p">.</code><code class="n">byte</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>Alternatively, if the underlying C data structure has an equivalent Rust mapping, and if it’s safe<a data-primary="AsRef trait" data-type="indexterm" id="OEBPS/ch06.html.id2114"></a><a data-primary="AsMut trait" data-type="indexterm" id="OEBPS/ch06.html.id2115"></a>
to directly manipulate that data structure, then implementations of the  <code>AsRef</code> and
 <code>AsMut</code> traits (described in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a>) allow more direct use:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="nb">AsMut</code><code class="o">&lt;</code><code class="n">FfiStruct</code><code class="o">&gt;</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">FfiWrapper</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">fn</code> <code class="nf">as_mut</code><code class="p">(</code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="bp">self</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kp">&amp;</code><code class="nc">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Safety: `inner` is non-NULL.</code>
<code class="w">        </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="bp">self</code><code class="p">.</code><code class="n">inner</code><code class="w"> </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">wrapper</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FfiWrapper</code>::<code class="n">new</code><code class="p">(</code><code class="mi">42</code><code class="p">).</code><code class="n">expect</code><code class="p">(</code><code class="s">"real code would check"</code><code class="p">);</code><code class="w"></code>
<code class="c1">// Directly modify the contents of the C-allocated data structure.</code>
<code class="n">wrapper</code><code class="p">.</code><code class="n">as_mut</code><code class="p">().</code><code class="n">byte</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">12</code><code class="p">;</code><code class="w"></code></pre>

<p>This example illustrates a useful principle for dealing with FFI: <em>encapsulate access to an <code>unsafe</code> FFI
library inside safe Rust code</em>.<a data-primary="unsafe code" data-secondary="FFI code in Rust" data-tertiary="encapsulating in safe code" data-type="indexterm" id="OEBPS/ch06.html.id2116"></a> <a data-primary="FFI (foreign-function interface)" data-secondary="encapsulating access to unsafe library in safe Rust code" data-type="indexterm" id="OEBPS/ch06.html.id2117"></a>This allows the rest of the application to follow the advice in <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a> and avoid
writing <code>unsafe</code> code.  It also concentrates all of the dangerous code in one place, which you can then study (and test)
carefully to uncover problems—and treat as the most likely suspect when something does go wrong.</p>
</div></section>








<section data-pdf-bookmark="Invoking Rust from C" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id164">
<h2>Invoking Rust from C</h2>

<p>What counts as “foreign” depends<a data-primary="FFI (foreign-function interface)" data-secondary="invoking Rust from C" data-type="indexterm" id="OEBPS/ch06.html.ix_FFICRust"></a><a data-primary="C" data-secondary="invoking Rust from" data-type="indexterm" id="OEBPS/ch06.html.ix_CRust"></a> on where you’re standing: if you’re writing an application in C, then it may be a
<em>Rust</em> library that’s accessed via a foreign function interface.</p>

<p>The basics of exposing a Rust library to C code are similar to the opposite direction:</p>

<ul>
<li>
<p>Rust functions that are exposed to C need an  <code>extern "C"</code> marker to ensure they’re C-compatible.<a data-primary="extern C" data-type="indexterm" id="OEBPS/ch06.html.id2118"></a><a data-primary="functions" data-secondary="Rust, exposed to C" data-type="indexterm" id="OEBPS/ch06.html.id2119"></a></p>
</li>
<li>
<p>Rust symbols <a data-primary="name mangling" data-type="indexterm" id="OEBPS/ch06.html.id2120"></a>are name mangled by default (like C++),<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2121" id="OEBPS/ch06.html.id2121-marker">7</a></sup> so function
definitions also need a <code>#[no_mangle]</code> attribute to ensure that they’re accessible via a simple name.  This in turn
means that the function name is part of a single global namespace that can clash with any other symbol defined in the
program.  As such, <em>consider using a prefix for exposed names</em> to avoid ambiguities (<code>mylib_…​</code>).</p>
</li>
<li>
<p>Data structure definitions need the <code>#[repr(C)]</code> attribute to ensure that the layout of the contents is compatible
with an equivalent C data structure.<a data-primary="data structures" data-secondary="Rust data structures exposed to C" data-type="indexterm" id="OEBPS/ch06.html.id2122"></a><a data-primary="repr(C)" data-type="indexterm" id="OEBPS/ch06.html.id2123"></a></p>
</li>
</ul>

<p>Also like the opposite direction, more subtle problems arise when dealing with pointers, references, and lifetimes.<a data-primary="pointers" data-secondary="in Rust and C" data-secondary-sortas="Rust" data-type="indexterm" id="OEBPS/ch06.html.id2124"></a><a data-primary="references" data-type="indexterm" id="OEBPS/ch06.html.id2125"></a><a data-primary="lifetimes" data-type="indexterm" id="OEBPS/ch06.html.id2126"></a>
A C pointer is different from a Rust reference, and you forget that at your peril:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch06.html.id2127">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add_contents</code><code class="p">(</code><code class="n">p</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="c1">// Convert the raw pointer provided by the caller into</code>
<code class="w">    </code><code class="c1">// a Rust reference.</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code>: <code class="kp">&amp;</code><code class="nc">FfiStruct</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="o">&amp;*</code><code class="n">p</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// Ruh-roh</code>
<code class="w">    </code><code class="n">s</code><code class="p">.</code><code class="n">integer</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">byte</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* C code invoking Rust. */</code><code class="w"></code>
<code class="kt">uint32_t</code><code class="w"> </code><code class="n">result</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">add_contents</code><code class="p">(</code><code class="nb">NULL</code><code class="p">);</code><code class="w"> </code><code class="c1">// Boom!</code></pre>

<p>When you’re<a data-primary="raw pointers" data-type="indexterm" id="OEBPS/ch06.html.id2128"></a> dealing with raw pointers, it’s your responsibility to ensure that any use of them complies with Rust’s
assumptions and guarantees around references:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add_contents_safer</code><code class="p">(</code><code class="n">p</code>: <code class="o">*</code><code class="k">const</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code> <code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">match</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">p</code><code class="p">.</code><code class="n">as_ref</code><code class="p">()</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="nb">Some</code><code class="p">(</code><code class="n">r</code><code class="p">)</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="n">r</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="nb">None</code><code class="w"> </code><code class="o">=&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="c1">// Pesky C code gave us a NULL.</code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="w">    </code><code class="n">s</code><code class="p">.</code><code class="n">integer</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">s</code><code class="p">.</code><code class="n">byte</code><code class="w"> </code><code class="k">as</code><code class="w"> </code><code class="kt">u32</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>In these examples, the C code provides a raw pointer to the Rust code, and the Rust code converts it to a reference
in order to operate on the structure.  But where did that pointer come from?  What does the Rust reference refer to?</p>

<p>The very first example in <a href="#OEBPS/ch01.html.file_references_md">Item 8</a> showed how Rust’s memory safety<a data-primary="memory" data-secondary="safety of" data-type="indexterm" id="OEBPS/ch06.html.id2129"></a><a data-primary="stack" data-secondary="prevention of references to expired stack objects" data-type="indexterm" id="OEBPS/ch06.html.id2130"></a><a data-primary="references" data-secondary="prevention of references to expired stack objects" data-type="indexterm" id="OEBPS/ch06.html.id2131"></a> prevents references to expired stack objects from
being returned; those problems reappear if you hand out a raw pointer:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch06.html.id2132">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="k">impl</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="nc">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="bp">Self</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">            </code><code class="n">byte</code>: <code class="mi">0</code><code class="p">,</code><code class="w"></code>
<code class="w">            </code><code class="n">integer</code>: <code class="nc">v</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// No compilation errors here.</code>
<code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new_struct</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FfiStruct</code>::<code class="n">new</code><code class="p">(</code><code class="n">v</code><code class="p">);</code><code class="w"></code>
<code class="w">    </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="c1">// return raw pointer to a stack object that's about to expire!</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>Any pointers passed back from Rust to C should generally refer to heap memory, not stack memory.<a data-primary="pointers" data-secondary="passed back from Rust to C" data-type="indexterm" id="OEBPS/ch06.html.id2133"></a><a data-primary="heap" data-secondary="pointers passed from Rust to C" data-type="indexterm" id="OEBPS/ch06.html.id2134"></a>  But naively trying to
put the object on the heap via a <code>Box</code> doesn’t help:</p>
<aside class="not_desired_behavior" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="OEBPS/ch06.html.id2135">
<h1></h1>
<pre data-code-language="rust" data-type="programlisting"><code class="c1">// No compilation errors here either.</code>
<code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new_struct_heap</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FfiStruct</code>::<code class="n">new</code><code class="p">(</code><code class="n">v</code><code class="p">);</code><code class="w"> </code><code class="c1">// create `FfiStruct` on stack</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="k">mut</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"> </code><code class="c1">// move `FfiStruct` to heap</code>
<code class="w">    </code><code class="o">&amp;</code><code class="k">mut</code><code class="w"> </code><code class="o">*</code><code class="n">b</code><code class="w"> </code><code class="c1">// return raw pointer to a heap object that's about to expire!</code>
<code class="p">}</code><code class="w"></code></pre>
</div></aside>

<p>The owning <code>Box</code> is on the stack, so when it goes out of scope, it will free the heap object and the returned raw pointer
will again be invalid.</p>

<p>The tool<a data-primary="Box type" data-secondary="Box::into_raw method" data-type="indexterm" id="OEBPS/ch06.html.id2136"></a> for the job here is
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a>, which abnegates
responsibility for the heap object, effectively “forgetting” about it:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">new_struct_raw</code><code class="p">(</code><code class="n">v</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FfiStruct</code>::<code class="n">new</code><code class="p">(</code><code class="n">v</code><code class="p">);</code><code class="w"> </code><code class="c1">// create `FfiStruct` on stack</code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Box</code>::<code class="n">new</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"> </code><code class="c1">// move `FfiStruct` to heap</code>

<code class="w">    </code><code class="c1">// Consume the `Box` and take responsibility for the heap memory.</code>
<code class="w">    </code><code class="nb">Box</code>::<code class="n">into_raw</code><code class="p">(</code><code class="n">b</code><code class="p">)</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>This raises the question of how the heap object now gets freed.<a data-primary="heap" data-secondary="freeing memory from Rust side" data-type="indexterm" id="OEBPS/ch06.html.id2137"></a> The previous advice was to perform allocation and
freeing of memory on the same side of the FFI boundary, which means that we need to persuade the Rust side of things to
do the freeing.<a data-primary="Box type" data-secondary="Box::from_raw method" data-type="indexterm" id="OEBPS/ch06.html.id2138"></a>  The corresponding tool for the job is
 <a class="orm:hideurl" href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code>Box::from_raw</code></a>, which builds a <code>Box</code> from
a raw pointer:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cp">#[no_mangle]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="k">fn</code> <code class="nf">free_struct_raw</code><code class="p">(</code><code class="n">p</code>: <code class="o">*</code><code class="k">mut</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="n">p</code><code class="p">.</code><code class="n">is_null</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="k">return</code><code class="p">;</code><code class="w"> </code><code class="c1">// Pesky C code gave us a NULL</code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="n">_b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">unsafe</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">        </code><code class="c1">// Safety: p is known to be non-NULL</code>
<code class="w">        </code><code class="nb">Box</code>::<code class="n">from_raw</code><code class="p">(</code><code class="n">p</code><code class="p">)</code><code class="w"></code>
<code class="w">    </code><code class="p">};</code><code class="w"></code>
<code class="p">}</code><code class="w"> </code><code class="c1">// `_b` drops at end of scope, freeing the `FfiStruct`</code></pre>

<p>This still leaves the Rust code at the mercy of the C code; if the C code gets confused and asks Rust to free the
same pointer twice, Rust’s allocator is likely to become terminally confused.</p>

<p>That illustrates the general theme of this Item: using FFI exposes you to risks that aren’t present in standard Rust.
That may well be worthwhile, as long as you’re aware of the dangers and costs involved.  Controlling the details of what
passes across the FFI boundary helps to reduce that risk but by no means eliminates it.</p>

<p>Controlling the <a data-primary="panics" data-secondary="preventing from crossing FFI boundary" data-type="indexterm" id="OEBPS/ch06.html.id2139"></a>FFI boundary for C code invoking Rust also involves one final concern: if your Rust code ignores the
advice in <a href="#OEBPS/ch03.html.file_panic_md">Item 18</a>, you should <em>prevent  <code>panic!</code>s from crossing the FFI boundary</em>, as this
always results in undefined behavior—undefined but
<a href="https://oreil.ly/qmUe0">bad</a>!<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2140" id="OEBPS/ch06.html.id2140-marker">8</a></sup><a data-primary="C-unwind ABI" data-type="indexterm" id="OEBPS/ch06.html.id2141"></a><a data-primary="FFI (foreign-function interface)" data-secondary="invoking Rust from C" data-startref="ix_FFICRust" data-type="indexterm" id="OEBPS/ch06.html.id2142"></a><a data-primary="C" data-secondary="invoking Rust from" data-startref="ix_CRust" data-type="indexterm" id="OEBPS/ch06.html.id2143"></a></p>
</div></section>








<section data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id165">
<h2>Things to Remember</h2>

<ul>
<li>
<p>Interfacing with code in other languages uses C as a least common denominator, which means that symbols all live
in a single global namespace.</p>
</li>
<li>
<p>Minimize the chances of problems at the FFI boundary by doing the following:</p>

<ul>
<li>
<p>Encapsulating <code>unsafe</code> FFI code in safe wrappers</p>
</li>
<li>
<p>Allocating and freeing memory consistently on one side of the boundary or the other</p>
</li>
<li>
<p>Making data structures use C-compatible layouts</p>
</li>
<li>
<p>Using sized integer types</p>
</li>
<li>
<p>Using FFI-related helpers from the standard library</p>
</li>
<li>
<p>Preventing <code>panic!</code>s from escaping from Rust<a data-primary="FFI (foreign-function interface)" data-startref="ix_FFI" data-type="indexterm" id="OEBPS/ch06.html.id2144"></a></p>
</li>
</ul>
</li>
</ul>
</div></section>
</div></section>






<section data-pdf-bookmark="Item 35: Prefer bindgen to manual FFI mappings" data-type="sect1"><div class="sect1" id="OEBPS/ch06.html.file_bindgen_md">
<h1>Item 35: Prefer <code>bindgen</code> to manual FFI mappings</h1>

<p><a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a> discussed the mechanics of invoking C code from a Rust program, describing how declarations of C structures and<a data-primary="bindgen" data-type="indexterm" id="OEBPS/ch06.html.ix_bndg"></a><a data-primary="FFI (foreign-function interface)" data-secondary="preferring bindgen to FFI mappings" data-type="indexterm" id="OEBPS/ch06.html.ix_FFIbindg"></a><a data-primary="C" data-secondary="preferring bindgen to FFI mappings" data-type="indexterm" id="OEBPS/ch06.html.ix_Cbndg"></a>
functions need to have an equivalent Rust declaration to allow them to be used over FFI. The C and Rust declarations
need to be kept in sync, and <a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a> also warned that the toolchain wouldn’t help with this—mismatches would be
silently ignored, hiding problems that would arise later.</p>

<p>Keeping two things perfectly in sync sounds like a good target for automation, and the Rust project provides the
right tool for the job:  <a class="orm:hideurl" href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a>. The primary function of <code>bindgen</code>
is to parse a C header file and emit the corresponding Rust declarations.</p>

<p>Taking some of the example C declarations from <a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>:</p>

<pre data-code-language="c" data-type="programlisting"><code class="cm">/* File lib.h */</code><code class="w"></code>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdint.h&gt;</code><code class="cp"></code>

<code class="k">typedef</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="kt">uint8_t</code><code class="w"> </code><code class="n">byte</code><code class="p">;</code><code class="w"></code>
<code class="w">    </code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">integer</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"> </code><code class="n">FfiStruct</code><code class="p">;</code><code class="w"></code>

<code class="kt">int</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"></code>
<code class="kt">uint32_t</code><code class="w"> </code><code class="nf">add32</code><code class="p">(</code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">uint32_t</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"></code></pre>

<p>the <code>bindgen</code> tool can be manually <a data-primary="build.rs" data-type="indexterm" id="OEBPS/ch06.html.id2145"></a>invoked (or invoked by a  <code>build.rs</code> <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>) to create a corresponding Rust file:</p>

<pre data-code-language="shell" data-type="programlisting">%<code class="w"> </code>bindgen<code class="w"> </code>--no-layout-tests<code class="w"> </code><code class="se">\</code>
<code class="w">          </code>--allowlist-function<code class="o">=</code><code class="s2">"add.*"</code><code class="w"> </code><code class="se">\</code>
<code class="w">          </code>--allowlist-type<code class="o">=</code>FfiStruct<code class="w"> </code><code class="se">\</code>
<code class="w">          </code>-o<code class="w"> </code>src/generated.rs<code class="w"> </code><code class="se">\</code>
<code class="w">          </code>lib.h<code class="w"></code></pre>

<p>The generated Rust is identical to the handcrafted declarations in <a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="cm">/* automatically generated by rust-bindgen 0.59.2 */</code><code class="w"></code>

<code class="cp">#[repr(C)]</code><code class="w"></code>
<code class="cp">#[derive(Debug, Copy, Clone)]</code><code class="w"></code>
<code class="k">pub</code><code class="w"> </code><code class="k">struct</code> <code class="nc">FfiStruct</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">byte</code>: <code class="kt">u8</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="n">integer</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add</code><code class="p">(</code><code class="w"></code>
<code class="w">        </code><code class="n">x</code>: ::<code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">,</code><code class="w"></code>
<code class="w">        </code><code class="n">y</code>: ::<code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">,</code><code class="w"></code>
<code class="w">    </code><code class="p">)</code><code class="w"> </code>-&gt; ::<code class="n">std</code>::<code class="n">os</code>::<code class="n">raw</code>::<code class="n">c_int</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code>
<code class="k">extern</code><code class="w"> </code><code class="s">"C"</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="k">pub</code><code class="w"> </code><code class="k">fn</code> <code class="nf">add32</code><code class="p">(</code><code class="n">x</code>: <code class="kt">u32</code><code class="p">,</code><code class="w"> </code><code class="n">y</code>: <code class="kt">u32</code><code class="p">)</code><code class="w"> </code>-&gt; <code class="kt">u32</code><code class="p">;</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre>

<p>and can be pulled into Rust code with the source-level  <a class="orm:hideurl" href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code> macro</a>:</p>

<pre data-code-language="rust" data-type="programlisting"><code class="c1">// Include the auto-generated Rust declarations.</code>
<code class="fm">include!</code><code class="p">(</code><code class="s">"generated.rs"</code><code class="p">);</code><code class="w"></code></pre>

<p class="pagebreak-before less_space">For anything but the most trivial FFI declarations, <em>use <code>bindgen</code> to generate Rust bindings for C
code</em>—this is an area where machine-made, mass-produced code is definitely preferable to artisanal handcrafted
declarations.  If a C function definition changes, the C compiler will complain if the C declaration no longer matches
the C definition, but nothing will complain that a handcrafted Rust declaration no longer matches the C declaration;
auto-generating the Rust declaration from the C declaration ensures that the two stay in sync</p>

<p>This also means <a data-primary="continuous integration" data-secondary="bindgen step in" data-type="indexterm" id="OEBPS/ch06.html.id2146"></a>that the <code>bindgen</code> step is an ideal candidate to include in a CI system (<a href="#OEBPS/ch05.html.file_ci_md">Item 32</a>);
if the generated code is included in source control, the CI system can error out if a freshly generated file doesn’t
match the checked-in version.</p>

<p>The <code>bindgen</code> tool comes into its own when you’re dealing with an existing C codebase that has a large API.  Creating
Rust equivalents to a big <em>lib_api.h</em> header file is manual and tedious, and therefore error-prone—and as noted, many categories of mismatch error will not be detected by the toolchain.  <code>bindgen</code> also has a
<a class="orm:hideurl" href="https://rust-lang.github.io/rust-bindgen/allowlisting.html">panoply</a> of
<a href="https://oreil.ly/WSC8t">options</a> that allow specific subsets of an API to be
targeted (such as the <code>--allowlist-function</code> and <code>--allowlist-type</code> options previously illustrated).<sup><a data-type="noteref" href="#OEBPS/ch06.html.id2147" id="OEBPS/ch06.html.id2147-marker">9</a></sup></p>

<p>This also allows a layered approach for exposing an existing C library in Rust; a common convention for wrapping some
<code>xyzzy</code> library is to have the following:</p>

<ul>
<li>
<p>An <code>xyzzy-sys</code> crate that holds (just) the <code>bindgen</code>-erated code—use of which is necessarily <code>unsafe</code></p>
</li>
<li>
<p>An <code>xyzzy</code> crate that encapsulates the <code>unsafe</code> code and provides safe Rust access to the underlying functionality</p>
</li>
</ul>

<p>This concentrates the <code>unsafe</code> code in one layer and allows the rest of the program to follow the advice in <a href="#OEBPS/ch03.html.file_unsafe_md">Item 16</a>.<a data-primary="FFI (foreign-function interface)" data-secondary="preferring bindgen to FFI mappings" data-startref="ix_FFIbindg" data-type="indexterm" id="OEBPS/ch06.html.id2148"></a><a data-primary="C" data-secondary="preferring bindgen to FFI mappings" data-startref="ix_Cbndg" data-type="indexterm" id="OEBPS/ch06.html.id2149"></a></p>








<section data-pdf-bookmark="Beyond C" data-type="sect2"><div class="sect2" id="OEBPS/ch06.html.id167">
<h2>Beyond C</h2>

<p>The <code>bindgen</code> tool has the ability to <a href="https://oreil.ly/vn8Hf">handle some C++ constructs</a>
but only a subset and in a limited fashion.<a data-primary="C++" data-secondary="bindgen handling some constructs" data-type="indexterm" id="OEBPS/ch06.html.id2150"></a><a data-primary="cxx crate" data-type="indexterm" id="OEBPS/ch06.html.id2151"></a> For better (but still somewhat limited) integration, <em>consider using
the  <a class="orm:hideurl" href="https://cxx.rs"><code>cxx</code></a> crate for C++/Rust interoperation</em>. <a data-primary="C++" data-secondary="cxx crate for interoperating with Rust" data-type="indexterm" id="OEBPS/ch06.html.id2152"></a>Instead of generating Rust code from C++
declarations, <code>cxx</code> takes the approach of auto-generating <em>both</em> Rust and C++ code from a common schema, allowing for
tighter integration.<a data-primary="bindgen" data-startref="ix_bndg" data-type="indexterm" id="OEBPS/ch06.html.id2153"></a></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="OEBPS/ch06.html.id1968"><sup><a href="#OEBPS/ch06.html.id1968-marker">1</a></sup> See <a href="https://oreil.ly/x74WK"><em>The Embedonomicon</em></a> or Philipp Oppermann’s <a href="https://oreil.ly/WTn-j">older blog post</a> for information about what’s involved in creating a <code>no_std</code> binary.</p><p data-type="footnote" id="OEBPS/ch06.html.id1977"><sup><a href="#OEBPS/ch06.html.id1977-marker">2</a></sup> Be <a data-primary="Error trait" data-type="indexterm" id="OEBPS/ch06.html.id2154"></a>aware that this can occasionally go wrong.  For example, at the time of writing, the  <code>Error</code> trait is defined in <a class="orm:hideurl" href="https://doc.rust-lang.org/1.70.0/core/error/trait.Error.html"><code>core::</code></a> but is marked as unstable there; only the <a class="orm:hideurl" href="https://doc.rust-lang.org/1.70.0/std/error/trait.Error.html"><code>std::</code> version</a> is stable.</p><p data-type="footnote" id="OEBPS/ch06.html.id1991"><sup><a href="#OEBPS/ch06.html.id1991-marker">3</a></sup> Prior to Rust 2018, <code>extern crate</code> declarations were used to pull in dependencies.  This is now entirely handled by <em>Cargo.toml</em>, but the <code>extern crate</code> mechanism is still used to pull in those parts of the Rust standard library (the  <em><a href="https://oreil.ly/sJzAv">sysroot crates</a></em>) that are optional in <code>no_std</code> environments.</p><p data-type="footnote" id="OEBPS/ch06.html.id2028"><sup><a href="#OEBPS/ch06.html.id2028-marker">4</a></sup> It’s also possible to add the  <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/memory/new/nothrow"><code>std::nothrow</code></a> overload to calls to <code>new</code> and check for <code>nullptr</code> return values.  However, there are still container methods like <a class="orm:hideurl" href="https://en.cppreference.com/w/cpp/container/vector/push_back"><code>vector&lt;T&gt;::push_back</code></a> that allocate under the covers and that can therefore signal allocation failure only via an exception.</p><p data-type="footnote" id="OEBPS/ch06.html.id2050"><sup><a href="#OEBPS/ch06.html.id2050-marker">5</a></sup> If the FFI functionality you want to use is part of the standard C  library, then you don’t need to create these declarations—the <a class="orm:hideurl" href="https://docs.rs/libc"><code>libc</code></a> crate already provides them.</p><p data-type="footnote" id="OEBPS/ch06.html.id2059"><sup><a href="#OEBPS/ch06.html.id2059-marker">6</a></sup> A corresponding <a class="orm:hideurl" href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key"><code>links</code></a> key in the  <em>Cargo.toml</em> manifest can help to make this<a data-primary="Cargo.toml file" data-secondary="links key" data-type="indexterm" id="OEBPS/ch06.html.id2155"></a> dependency visible to Cargo.</p><p data-type="footnote" id="OEBPS/ch06.html.id2121"><sup><a href="#OEBPS/ch06.html.id2121-marker">7</a></sup> A Rust equivalent of the <code>c++filt</code> tool for translating mangled<a data-primary="c++filt" data-type="indexterm" id="OEBPS/ch06.html.id2156"></a><a data-primary="rustfilt" data-type="indexterm" id="OEBPS/ch06.html.id2157"></a> names back to programmer-visible names is  <a class="orm:hideurl" href="https://crates.io/crates/rustfilt"><code>rustfilt</code></a>, which builds on the <a class="orm:hideurl" href="https://github.com/rust-lang/rustc-demangle"><code>rustc-demangle</code></a> command.</p><p data-type="footnote" id="OEBPS/ch06.html.id2140"><sup><a href="#OEBPS/ch06.html.id2140-marker">8</a></sup> Note that Rust version 1.71 includes the <a href="https://oreil.ly/VVqVY">C-unwind ABI</a>, which makes some cross-language unwinding functionality possible.</p><p data-type="footnote" id="OEBPS/ch06.html.id2147"><sup><a href="#OEBPS/ch06.html.id2147-marker">9</a></sup> The example also used the <code>--no-layout-tests</code> option to keep the output simple; by default, the generated code will include <code>#[test]</code> code to check that structures are indeed  laid out correctly.</p></div></div></section></div></div>
<div id="OEBPS/afterword01.html"><div data-type="book">
<section data-pdf-bookmark="Afterword" data-type="afterword" epub:type="afterword"><div class="appendix" id="OEBPS/afterword01.html.file_afterword_md">
<h1>Afterword</h1>


<p>Hopefully the advice, suggestions, and information in this book will help you  become a fluent,
productive Rust programmer. As the <a href="#OEBPS/preface01.html.file_preface_md">Preface</a> describes, this book is intended to cover the second step in this process, after you’ve learned the basics from a core Rust reference book. But there are more steps you can take and directions to explore<a data-primary="suggestions for future learning" data-type="indexterm" id="OEBPS/afterword01.html.id2158"></a>:</p>

<ul>
<li>
<p><em>Async Rust</em>   is not covered in this<a data-primary="async" data-type="indexterm" id="OEBPS/afterword01.html.id2159"></a> book but is likely to be needed for efficient, concurrent
server-side applications.  The <a href="https://oreil.ly/a9r1B">online documentation</a> provides an
introduction to <code>async</code>, and the forthcoming <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/async-rust/9781098149086/"><em>Async Rust</em></a> by Maxwell Flitton and Caroline
Morton (O’Reilly, 2024) may also help.</p>
</li>
<li>
<p>Moving in the other direction,  <em>bare-metal Rust</em> might align with your interests and requirements.<a data-primary="bare-metal Rust" data-type="indexterm" id="OEBPS/afterword01.html.id2160"></a>  This goes
beyond the introduction to <code>no_std</code> in <a href="#OEBPS/ch06.html.file_no-std_md">Item 33</a> to a world where there’s no operating system and no allocation. The
<a href="https://oreil.ly/h_cfR">bare-metal Rust section</a> of the  <a class="orm:hideurl" href="https://google.github.io/comprehensive-rust">Comprehensive Rust</a> online course provides a good introduction here.<a data-primary="Comprehensive Rust online course" data-type="indexterm" id="OEBPS/afterword01.html.id2161"></a></p>
</li>
<li>
<p>Regardless of whether your interests are low-level or high-level, the <a class="orm:hideurl" href="https://crates.io"><code>crates.io</code></a> ecosystem of
third-party, open source crates is worth exploring—and contributing to.<a data-primary="crates.io" data-secondary="third-party, open source crates" data-type="indexterm" id="OEBPS/afterword01.html.id2162"></a>  Curated summaries like
<a class="orm:hideurl" href="https://blessed.rs"><em>blessed.rs</em></a> or <a class="orm:hideurl" href="https://lib.rs"><em>lib.rs</em></a> can help navigate the huge number of
possibilities.<a data-primary="lib.rs" data-type="indexterm" id="OEBPS/afterword01.html.id2163"></a></p>
</li>
<li>
<p>Rust discussion forums such as the <a href="https://users.rust-lang.org">Rust language forum</a> or <a class="orm:hideurl" href="https://reddit.com/r/rust">Reddit’s r/rust</a> can provide help—and include a searchable index of questions that have been
asked (and answered!) previously.<a data-primary="discussion forums" data-type="indexterm" id="OEBPS/afterword01.html.id2164"></a></p>
</li>
<li>
<p>If you find yourself relying on an existing library that’s not written in Rust (as per <a href="#OEBPS/ch06.html.file_ffi_md">Item 34</a>), you could
 <em>rewrite it in Rust</em> (RiiR).  <a data-primary="rewrite it in Rust (RiiR)" data-type="indexterm" id="OEBPS/afterword01.html.id2165"></a>But don’t <a href="https://oreil.ly/iKRzI">underestimate the effort required</a> to reproduce a battle-tested,
mature codebase.</p>
</li>
<li>
<p>As you become more skilled in Rust,  Jon Gjengset’s  <em>Rust for Rustaceans</em> (No Starch, 2022)
is an essential reference for more advanced aspects of Rust<a data-primary="Rust for Rustaceans (Gjengset)" data-type="indexterm" id="OEBPS/afterword01.html.id2166"></a><a data-primary="Gjengset, Jon" data-type="indexterm" id="OEBPS/afterword01.html.id2167"></a>.</p>
</li>
</ul>

<p>Good luck!</p>
</div></section></div></div>
<div id="OEBPS/ix01.html"><div data-type="book">
<section data-type="index" epub:type="index"><div class="index" id="OEBPS/ix01.html.id195"><h1>Index</h1><div data-type="index"><div data-type="indexdiv"><h3><span data-gentext="indexsymbols">Symbols</span></h3><ul><li><span data-type="index-term">! (exclamation mark)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1684">Declarative Macros</a></li><li><span data-type="index-term">()</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id342">Closures</a></li><li><span data-type="index-term">2018 edition of Rust</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id219">Rust Version</a></li><li><span data-type="index-term">2021 edition of Rust</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id221">Rust Version</a></li><li><span data-type="index-term">? (question mark) operator</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id233">Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id305">Result&lt;T, E&gt;</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id387">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id418">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id727">Building Collections from Result Values</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id743">When Explicit Is Better</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1689">Declarative Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1848">Examples</a><ul><li><span data-type="index-term">applied to Result iterators</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id730">Building Collections from Result Values</a></li><li><span data-type="index-term">converting result types to form where ? applies</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id396">Things to Remember</a></li><li><span data-type="index-term">using to pass error on to next caller</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1317">Item 18: Don’t panic</a></li></ul></li><li><span data-type="index-term">π</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1787">Item 29: Listen to Clippy</a></li></ul></div><div data-type="indexdiv"><h3>A</h3><ul><li><span data-type="index-term">aborting on panic</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1307">Item 18: Don’t panic</a></li><li><span data-type="index-term">abstract classes</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id317">Item 2: Use the type system to express common behavior</a></li><li><span data-type="index-term">abstract syntax tree</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1662">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1921">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">access control</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_accctl">Access Control</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1100">Borrow Rules</a></li><li><span data-type="index-term">Adams, Douglas</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1301">Item 18: Don’t panic</a></li><li><span data-type="index-term">adapters</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1470">Visibility Syntax</a></li><li><span data-type="index-term">Add trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id837">Operator Overloads</a></li><li><span data-type="index-term">AddAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id843">Summary</a></li><li><span data-type="index-term">AddressSanitizer</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1866">Fuzz Testing</a></li><li><span data-type="index-term">afraid, reasons to be</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1223">Item 17: Be wary of shared-state parallelism</a></li><li><span data-type="index-term">aggregate types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id286">Aggregate Types</a></li><li><span data-type="index-term">algebraic data type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id229">Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id293">enums with Fields</a></li><li><span data-type="index-term">aliasing</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1108">Borrow Rules</a></li><li><span data-type="index-term">alignment</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id549">Rust References</a></li><li><span data-type="index-term">all method (on Iterator)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id702">Iterator Consumers</a></li><li><span data-type="index-term">alloc</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1954">Beyond Standard Rust</a></li><li><span data-type="index-term">alloc library</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1187">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1397">Who’s Afraid of the Big Bad Copy?</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1607">What to Depend On</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1602">Features</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1986">alloc</a><ul><li><span data-type="index-term">assumption that heap allocation can't fail</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2020">Fallible Allocation</a></li><li><span data-type="index-term">full type names required</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2004">Writing Code for no_std</a></li><li><span data-type="index-term">types available in</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1992">alloc</a></li></ul></li><li><span data-type="index-term">allocation</span><ul><li><span data-type="index-term">fallible</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2017">Fallible Allocation</a></li><li><span data-type="index-term">infallible</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2025">Fallible Allocation</a></li></ul></li><li><span data-type="index-term">allow attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1790">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">also-implements</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id956">More Trait Bounds</a></li><li><span data-type="index-term">Android</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1947">Item 31: Take advantage of the tooling ecosystem</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2031">Fallible Allocation</a></li><li><span data-type="index-term">anonymous lifetimes</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1069">Anonymous Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1076">Things to Remember</a></li><li><span data-type="index-term">any method (on Iterator)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id701">Iterator Consumers</a></li><li><span data-type="index-term">Any trait</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1351">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1378">Upcasting in Future Versions of Rust</a></li><li><span data-type="index-term">anyhow crate</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id430">Trait Objects</a></li><li><span data-type="index-term">API guidelines</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1323">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1474">Visibility Semantics</a></li><li><span data-type="index-term">ar tool</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2054">Linking logistics</a></li><li><span data-type="index-term">Arc type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id625">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1147">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1259">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1402">References and Smart Pointers</a></li><li><span data-type="index-term">array expression</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id582">Slices</a></li><li><span data-type="index-term">array type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id287">Aggregate Types</a></li><li><span data-type="index-term">arrays</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id577">Slices</a></li><li><span data-type="index-term">as keyword</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id437">Item 5: Understand type conversions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id475">Casts</a><ul><li><span data-type="index-term">preferring from / into conversions over as casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id482">Casts</a></li></ul></li><li><span data-type="index-term">AsMut trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id571">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id597">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id876">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2115">Lifetimes</a></li><li><span data-type="index-term">AsRef trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id748">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id570">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id596">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id875">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2114">Lifetimes</a></li><li><span data-type="index-term">assert_eq! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1825">Unit Tests</a></li><li><span data-type="index-term">associated types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id335">Closures</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id569">Pointer Traits</a></li><li><span data-type="index-term">async</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1166">Self-referential data structures</a>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2159">Afterword</a></li><li><span data-type="index-term">as_ptr method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2088">Accessing C Data from Rust</a></li><li><span data-type="index-term">as_Ref method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id747">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">atomics</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1569">Conditional Compilation</a></li><li><span data-type="index-term">attackers, code exposed to</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1862">Fuzz Testing</a></li><li><span data-type="index-term">attribute macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1730">Attribute macros</a></li><li><span data-type="index-term">auto traits</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1265">Standard marker traits</a></li><li><span data-type="index-term">automatic type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id439">Item 5: Understand type conversions</a><ul><li><span data-type="index-term">Into trait automatically provided from From implementation</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id454">User-Defined Type Conversions</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>B</h3><ul><li><span data-type="index-term">B language</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id634">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">backward compatibility</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id220">Rust Version</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id996">Item 13: Use default implementations 
to minimize required trait methods</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1421">Semver Essentials</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1486">Item 23: Avoid wildcard imports</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1845">Examples</a><ul><li><span data-type="index-term">crate author determining for changes</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1430">Semver for Crate Authors</a></li></ul></li><li><span data-type="index-term">Barbarossa, Hector</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id208">Preface</a></li><li><span data-type="index-term">bare-metal Rust</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2160">Afterword</a></li><li><span data-type="index-term">behavior tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1837">Integration Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1886">Testing Advice</a></li><li><span data-type="index-term">benchmarks</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1851">Benchmarks</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1892">Things to Remember</a></li><li><span data-type="index-term">bindgen</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1942">Tools to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2066">Code concerns</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2081">Accessing C Data from Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_bndg">Item 35: Prefer bindgen to manual FFI mappings</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2153">Beyond C</a></li><li><span data-type="index-term">BitAnd trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id846">Summary</a></li><li><span data-type="index-term">BitAndAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id847">Summary</a></li><li><span data-type="index-term">BitOr trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id848">Summary</a></li><li><span data-type="index-term">BitOrAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id849">Summary</a></li><li><span data-type="index-term">BitXor trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id850">Summary</a></li><li><span data-type="index-term">BitXorAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id851">Summary</a></li><li><span data-type="index-term">black_box function</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1857">Benchmarks</a></li><li><span data-type="index-term">blanket trait implementations</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id456">User-Defined Type Conversions</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id950">Basic Comparisons</a><ul><li><span data-type="index-term">AsMut and BorrowMut traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id599">More Pointer Traits</a></li><li><span data-type="index-term">AsRef and Borrow traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id598">More Pointer Traits</a></li><li><span data-type="index-term">for smart pointer types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id461">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">Bloch, Joshua</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1367">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1477">Visibility Semantics</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1611">Item 27: Document public interfaces</a></li><li><span data-type="index-term">bool type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id269">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id671">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1794">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">making Boolean arguments clear with newtype</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id506">Item 6: Embrace the newtype pattern</a></li></ul></li><li><span data-type="index-term">bootloaders</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1962">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">borrow</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id652">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1083">Item 15: Understand the borrow checker</a></li><li><span data-type="index-term">borrow checker</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id213">Preface</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id548">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id553">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1004">Concepts</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchk">Item 15: Understand the borrow checker</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1181">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1381">Data Structures and Allocation</a><ul><li><span data-type="index-term">borrowing rules</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchkrule">Borrow Rules</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1112">Borrow Rules</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1242">Data races in Rust</a></li><li><span data-type="index-term">checks moved from compile time to runtime</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1254">Data races in Rust</a></li><li><span data-type="index-term">deliberate error inserted for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1025">Scope of a Lifetime</a></li><li><span data-type="index-term">mutable references, moving value out and replacing it</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1095">Access Control</a></li><li><span data-type="index-term">owner operations and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1113">Owner Operations</a></li><li><span data-type="index-term">points to remember</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1177">Things to Remember</a></li><li><span data-type="index-term">winning fights against</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchkwin">Winning Fights Against the Borrow Checker</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1176">Things to Remember</a><ul><li><span data-type="index-term">creating self-referential data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchkwinselfDS">Self-referential data structures</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1172">Things to Remember</a></li><li><span data-type="index-term">using data structure design</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchkwinDSD">Data structure design</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1144">Smart pointers</a></li><li><span data-type="index-term">using local code refactoring</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1123">Local code refactoring</a></li><li><span data-type="index-term">using smart pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_brwchkwinsmptr">Smart pointers</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1163">Self-referential data structures</a></li></ul></li></ul></li><li><span data-type="index-term">borrow method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id620">Smart Pointer Types</a></li><li><span data-type="index-term">Borrow trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id594">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id877">Summary</a></li><li><span data-type="index-term">BorrowMut trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id595">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id878">Summary</a></li><li><span data-type="index-term">Bos, Mara</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1195">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1570">Conditional Compilation</a></li><li><span data-type="index-term">bounds checking</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id716">Iterator Consumers</a></li><li><span data-type="index-term">bounds method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id933">Generics</a></li><li><span data-type="index-term">Box type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id558">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id972">Trait Object Safety</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1049">The 'static Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1801">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">Box::from_raw method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2138">Invoking Rust from C</a></li><li><span data-type="index-term">Box::into_raw method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2136">Invoking Rust from C</a></li><li><span data-type="index-term">Box::new method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1056">Lifetimes and the Heap</a></li><li><span data-type="index-term">ownership of values on the heap</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1055">Lifetimes and the Heap</a></li></ul></li><li><span data-type="index-term">broken_intra_doc_links crate attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1625">Tooling</a></li><li><span data-type="index-term">BTreeMap type</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2006">Writing Code for no_std</a></li><li><span data-type="index-term">BTreeSet type</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2007">Writing Code for no_std</a></li><li><span data-type="index-term">build scripts</span><ul><li><span data-type="index-term">dependency running arbitrary code during build</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1548">What to Depend On</a></li><li><span data-type="index-term">emitting C library linkage information</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2057">Linking logistics</a></li></ul></li><li><span data-type="index-term">build.rs</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2145">Item 35: Prefer bindgen to manual FFI mappings</a></li><li><span data-type="index-term">builder pattern</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id522">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id528">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id782">Default</a></li><li><span data-type="index-term">builders</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_bldr">Item 7: Use builders for complex types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id543">Item 7: Use builders for complex types</a><ul><li><span data-type="index-term">helper methods for populating fields</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id529">Item 7: Use builders for complex types</a></li><li><span data-type="index-term">issues with</span><ul><li><span data-type="index-term">only one item built at a time</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id533">Item 7: Use builders for complex types</a></li><li><span data-type="index-term">separating out stages of build process</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id531">Item 7: Use builders for complex types</a></li></ul></li><li><span data-type="index-term">support for building multiple items</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id538">Item 7: Use builders for complex types</a></li></ul></li><li><span data-type="index-term">byteorder crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1211">Item 16: Avoid writing unsafe code</a></li></ul></div><div data-type="indexdiv"><h3>C</h3><ul><li><span data-type="index-term">C</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1023">Scope of a Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1411">Dependencies</a><ul><li><span data-type="index-term">accessing C data from Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_Cdata">Accessing C Data from Rust</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2090">Accessing C Data from Rust</a></li><li><span data-type="index-term">C-like enums</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id478">Casts</a></li><li><span data-type="index-term">code defects exposed by fuzzers</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1864">Fuzz Testing</a></li><li><span data-type="index-term">default target for Rust's interoperability</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2042">Item 34: Control what crosses FFI boundaries</a></li><li><span data-type="index-term">for loop</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id632">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">invoking C functions from Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_Cfnct">Invoking C Functions from Rust</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2078">Name mangling</a></li><li><span data-type="index-term">invoking Rust from</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_CRust">Invoking Rust from C</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2143">Invoking Rust from C</a></li><li><span data-type="index-term">line-based preprocessor</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1560">Conditional Compilation</a></li><li><span data-type="index-term">macro argument with side effects</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1696">Declarative Macros</a></li><li><span data-type="index-term">manual allocations, malloc</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2026">Fallible Allocation</a></li><li><span data-type="index-term">old-style pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1185">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">pointers and references, comparison with Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1079">Item 15: Understand the borrow checker</a></li><li><span data-type="index-term">preferring bindgen to FFI mappings</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_Cbndg">Item 35: Prefer bindgen to manual FFI mappings</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2149">Item 35: Prefer bindgen to manual FFI mappings</a></li><li><span data-type="index-term">preprocessor macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1677">Declarative Macros</a></li><li><span data-type="index-term">printf statement</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1707">Declarative Macros</a></li></ul></li><li><span data-type="index-term">C++</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id214">Who This Book Is For</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id238">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id312">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id755">Item 10: Familiarize yourself with standard traits</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1412">Dependencies</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1657">What Not to Document</a><ul><li><span data-type="index-term">== operator</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id785">PartialEq and Eq</a></li><li><span data-type="index-term">allocation failures, caught with exception system</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2027">Fallible Allocation</a></li><li><span data-type="index-term">allocation, hidden</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1390">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">bindgen handling some constructs</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2150">Beyond C</a></li><li><span data-type="index-term">code defects exposed by fuzzers</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1863">Fuzz Testing</a></li><li><span data-type="index-term">code that manually locks and unlocks a mutex</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id900">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">combination of enum with union</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id294">enums with Fields</a></li><li><span data-type="index-term">copy-constructors</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id772">Copy</a></li><li><span data-type="index-term">cxx crate for interoperating with Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2152">Beyond C</a></li><li><span data-type="index-term">data races in</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_Cpldarc">Data races in C++</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1238">Data races in C++</a></li><li><span data-type="index-term">exception safety for template code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1311">Item 18: Don’t panic</a></li><li><span data-type="index-term">exception system</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1304">Item 18: Don’t panic</a></li><li><span data-type="index-term">exceptions and templates</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2045">Item 34: Control what crosses FFI boundaries</a></li><li><span data-type="index-term">explicit constraints on template types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id362">Trait bounds</a></li><li><span data-type="index-term">for statement, loop declaration in</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id635">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">interoperating with Rust code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1213">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">iostream, operator&lt;&lt; overload</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id811">Debug and Display</a></li><li><span data-type="index-term">line-based preprocessor</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1561">Conditional Compilation</a></li><li><span data-type="index-term">macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1661">Item 28: Use macros judiciously</a></li><li><span data-type="index-term">object destruction</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1024">Scope of a Lifetime</a></li><li><span data-type="index-term">one definition rule for C/C++ code accessed via Rust's  FFI</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1517">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">operator overloads, avoiding for unrelated types</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id836">Operator Overloads</a></li><li><span data-type="index-term">overridden definitions with same name</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2071">Name mangling</a></li><li><span data-type="index-term">pointers and references, comparison with Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1080">Item 15: Understand the borrow checker</a></li><li><span data-type="index-term">RAII patterns in</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id893">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">RAII patterns used for memory management</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id904">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">run-time type identification (RTTI)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1342">Item 19: Avoid reflection</a></li><li><span data-type="index-term">shared_pointer</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id608">Smart Pointer Types</a></li><li><span data-type="index-term">switch arms for enums, warning about missing</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id746">enums</a></li><li><span data-type="index-term">templates</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id929">Generics</a></li><li><span data-type="index-term">unique_ptr</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id561">Rust References</a></li><li><span data-type="index-term">virtual functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id368">Trait objects</a></li><li><span data-type="index-term">visibility guidelines</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1481">Visibility Semantics</a></li><li><span data-type="index-term">weak_ptr</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id612">Smart Pointer Types</a></li></ul></li><li><span data-type="index-term">c++filt</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2074">Name mangling</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2156">Invoking Rust from C</a></li><li><span data-type="index-term">C-unwind ABI</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2141">Invoking Rust from C</a></li><li><span data-type="index-term">cackle maniacally</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1017">Evolution of Lifetimes</a></li><li><span data-type="index-term">Cargill, Tom</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1310">Item 18: Don’t panic</a></li><li><span data-type="index-term">Cargo</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1414">Dependencies</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1535">Version Specification</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1551">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1900">Item 31: Take advantage of the tooling ecosystem</a><ul><li><span data-type="index-term">additional tools in</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1906">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">allowing multiple versions of a crate in a build</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1516">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">automatic dependency selection by semver</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1415">Item 21: Understand what semantic versioning promises</a></li><li><span data-type="index-term">dependency resolution process</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1419">Item 21: Understand what semantic versioning promises</a></li><li><span data-type="index-term">feature activation</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1573">Features</a></li><li><span data-type="index-term">restrictions in multiple-version support</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1521">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">searching for tools</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1927">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">supporting different versions of library crate linked into single binary</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1499">Item 24: Re-export dependencies whose types 
appear in your API</a></li><li><span data-type="index-term">tests included in published crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1885">Testing Advice</a></li><li><span data-type="index-term">version selection algorithm</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1524">Item 25: Manage your dependency graph</a></li></ul></li><li><span data-type="index-term">cargo bench</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1854">Benchmarks</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1893">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1911">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo check</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1908">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo clippy</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1909">Item 31: Take advantage of the tooling ecosystem</a><ul><li>(<span data-gentext="see">see also</span> Clippy)</li></ul></li><li><span data-type="index-term">cargo doc</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1624">Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1632">Additional Documentation Locations</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1910">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo fmt</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1907">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo metadata</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1915">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo test</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1620">Item 27: Document public interfaces</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1840">Doc Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1888">Things to Remember</a></li><li><span data-type="index-term">cargo tree</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1541">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1542">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1553">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1913">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo update</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1448">Semver for Crate Users</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1533">Version Specification</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1912">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo-deny</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1442">Semver for Crate Authors</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1539">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1554">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1920">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo-expand</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1680">Declarative Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1767">Disadvantages of Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1924">Item 31: Take advantage of the tooling ecosystem</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1936">Tools to Remember</a></li><li><span data-type="index-term">cargo-fuzz</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1896">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1940">Tools to Remember</a></li><li><span data-type="index-term">cargo-semver-checks</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1439">Semver for Crate Authors</a></li><li><span data-type="index-term">cargo-server-checks</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1935">Tools to Remember</a></li><li><span data-type="index-term">cargo-tarpaulin</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1926">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">cargo-udeps</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1538">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1555">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1919">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">Cargo.lock file</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1525">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1552">Things to Remember</a></li><li><span data-type="index-term">Cargo.toml file</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1509">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1537">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1575">Features</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1592">Features</a><ul><li><span data-type="index-term">dependencies section</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1579">Features</a></li><li><span data-type="index-term">determining crate's features in</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1585">Features</a></li><li><span data-type="index-term">links key</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2155">Linking logistics</a></li></ul></li><li><span data-type="index-term">cargo:rustc-link-lib</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2056">Linking logistics</a></li><li><span data-type="index-term">cargo:rustc-link-search</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2060">Linking logistics</a></li><li><span data-type="index-term">casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id253">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id474">Casts</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1798">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">preferring from / into conversions over as casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id484">Casts</a></li><li><span data-type="index-term">Rust code appearing to make implicit casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id472">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">catch_unwind</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1306">Item 18: Don’t panic</a></li><li><span data-type="index-term">Cell type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id623">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1150">Smart pointers</a><ul><li><span data-type="index-term">not implementing Sync</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1268">Standard marker traits</a></li></ul></li><li><span data-type="index-term">cfg attribute</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1558">Conditional Compilation</a></li><li><span data-type="index-term">cfg(test) attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1817">Unit Tests</a></li><li><span data-type="index-term">cfg_attr attribute</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1559">Conditional Compilation</a></li><li><span data-type="index-term">channels (Go)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1289">Advice</a></li><li><span data-type="index-term">char * (C string)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2084">Accessing C Data from Rust</a></li><li><span data-type="index-term">char type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id276">Fundamental Types</a></li><li><span data-type="index-term">Clang</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1235">Data races in C++</a></li><li><span data-type="index-term">Clippit</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1779">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">Clippy</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id483">Casts</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id773">Copy</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1218">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_Clpy">Item 29: Listen to Clippy</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1813">Item 29: Listen to Clippy</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1937">Tools to Remember</a><ul><li><span data-type="index-term">links to webpage describing error</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1788">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">warnings about Rust usage</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1781">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">warnings corresponding to Items in this book</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1792">Item 29: Listen to Clippy</a></li></ul></li><li><span data-type="index-term">Clone trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id539">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id601">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id661">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id995">Item 13: Use default implementations 
to minimize required trait methods</a><ul><li><span data-type="index-term">Copy trait implementation of</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id768">Copy</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id762">Clone</a></li><li><span data-type="index-term">traits that impose Clone trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id971">Trait Object Safety</a></li><li><span data-type="index-term">where it can't or shouldn't be implemented</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id763">Clone</a></li></ul></li><li><span data-type="index-term">clone-on-write</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id603">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1161">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1202">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">cloned method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id665">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id994">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">cloning data in data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1136">Data structure design</a></li><li><span data-type="index-term">closures</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id310">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id332">Closures</a><ul><li><span data-type="index-term">in iterator transforms</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id663">Iterator Transforms</a><ul><li><span data-type="index-term">failures of</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id703">Iterator Consumers</a></li></ul></li><li><span data-type="index-term">with locks held, avoiding invoking</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1293">Advice</a></li><li><span data-type="index-term">traits representing</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id821">Standard Traits Covered Elsewhere</a></li></ul></li><li><span data-type="index-term">code bloat with macro use</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1768">Disadvantages of Macros</a></li><li><span data-type="index-term">code reuse</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1406">Dependencies</a></li><li><span data-type="index-term">code, distinguishing from text</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1616">Item 27: Document public interfaces</a></li><li><span data-type="index-term">collect method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id709">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id742">When Explicit Is Better</a></li><li><span data-type="index-term">collections</span><ul><li><span data-type="index-term">allowing iteration over contents</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id647">Iterator Traits</a></li><li><span data-type="index-term">fallible allocation changes in</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2033">Fallible Allocation</a></li><li><span data-type="index-term">length returned as usize</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id254">Fundamental Types</a></li><li><span data-type="index-term">preceded by &amp;</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id654">Iterator Traits</a></li><li><span data-type="index-term">of zero things</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id300">Option&lt;T&gt;</a></li></ul></li><li><span data-type="index-term">comments, documentation</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1613">Item 27: Document public interfaces</a><ul><li><span data-type="index-term">describing how some other code uses the method</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1651">What Not to Document</a></li><li><span data-type="index-term">focusing on the why</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1652">What Not to Document</a></li><li><span data-type="index-term">out-of-sync comment</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1644">What Not to Document</a></li><li><span data-type="index-term">overly verbose</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1642">What Not to Document</a></li></ul></li><li><span data-type="index-term">comparison traits</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id796">PartialOrd and Ord</a></li><li><span data-type="index-term">compiler messages on errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id262">Fundamental Types</a></li><li><span data-type="index-term">Comprehensive Rust online course</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2161">Afterword</a></li><li><span data-type="index-term">concepts in writing Rust code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1003">Concepts</a></li><li><span data-type="index-term">concision</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1783">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">concrete methods</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id997">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">concurrency</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1222">Item 17: Be wary of shared-state parallelism</a><ul><li>(<span data-gentext="see">see also</span> shared-state parallelism)</li></ul></li><li><span data-type="index-term">conditional compilation</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1557">Item 26: Be wary of feature creep</a></li><li><span data-type="index-term">conditionals</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1687">Declarative Macros</a></li><li><span data-type="index-term">config options, name/value variants of</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1562">Conditional Compilation</a></li><li><span data-type="index-term">config-specific code</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1883">Testing Advice</a></li><li><span data-type="index-term">const</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1044">The 'static Lifetime</a></li><li><span data-type="index-term">const (pointers)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2101">Lifetimes</a></li><li><span data-type="index-term">const char* (C string)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2087">Accessing C Data from Rust</a></li><li><span data-type="index-term">constants</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1458">Visibility Syntax</a></li><li><span data-type="index-term">constructors</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id896">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">consuming iterators</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id651">Iterator Traits</a></li><li><span data-type="index-term">continuous integration</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1540">Solving Problems with Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1549">What to Depend On</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1630">Tooling</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1791">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">bindgen step in</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2146">Item 35: Prefer bindgen to manual FFI mappings</a></li><li><span data-type="index-term">check for no_std build</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2012">Writing Code for no_std</a></li><li><span data-type="index-term">check spotting new potentially panicking code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1333">Item 18: Don’t panic</a></li><li><span data-type="index-term">integrating useful tools into</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1930">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">integration tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1841">Doc Tests</a></li><li><span data-type="index-term">testing advice for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1880">Testing Advice</a></li><li><span data-type="index-term">testing example code</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1844">Examples</a></li></ul></li><li><span data-type="index-term">control flow</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1685">Declarative Macros</a><ul><li><span data-type="index-term">avoiding nonlocal operations in macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1771">Advice</a></li></ul></li><li><span data-type="index-term">copied method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id666">Iterator Transforms</a></li><li><span data-type="index-term">copies, reducing</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1389">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">copy semantics</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id770">Copy</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1393">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">Copy trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id622">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id653">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id667">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1394">Who’s Afraid of the Big Bad Copy?</a><ul><li><span data-type="index-term">deciding whether to implement it</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id775">Copy</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id766">Copy</a></li></ul></li><li><span data-type="index-term">core library</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id408">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1188">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1969">core</a><ul><li><span data-type="index-term">no heap allocation performed by</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1980">core</a></li><li><span data-type="index-term">using full type names</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2003">Writing Code for no_std</a></li></ul></li><li><span data-type="index-term">corpus for fuzzing</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1878">Fuzz Testing</a></li><li><span data-type="index-term">Cow enum</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id602">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1160">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1201">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">CPAN (Comprehensive Perl Archive Network)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1409">Dependencies</a></li><li><span data-type="index-term">crates</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1508">Item 25: Manage your dependency graph</a><ul><li><span data-type="index-term">caution with use of another crate's types in your API</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1501">Item 24: Re-export dependencies whose types 
appear in your API</a></li><li><span data-type="index-term">crate names and feature names sharing namespace</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1582">Features</a></li><li><span data-type="index-term">external, using instead of macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1776">Advice</a></li><li><span data-type="index-term">multiple versions in dependency graph</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1808">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">no_std compatibility</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1965">Item 33: Consider making library code 
no_std compatible</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2009">Writing Code for no_std</a></li><li><span data-type="index-term">proc-macro crate type</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1720">Procedural Macros</a></li><li><span data-type="index-term">pub(crate) visibility</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1465">Visibility Syntax</a></li><li><span data-type="index-term">semantic versioning for authors</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1426">Semver for Crate Authors</a></li><li><span data-type="index-term">semantic versioning for users</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1443">Semver for Crate Users</a></li><li><span data-type="index-term">testing advice for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1882">Testing Advice</a></li><li><span data-type="index-term">tool emitting information on</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1917">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">vulnerability to dependency problems</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1545">What to Depend On</a></li></ul></li><li><span data-type="index-term">crates.io</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1156">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1171">Self-referential data structures</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1428">Semver for Crate Authors</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1447">Semver for Crate Users</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1504">Item 24: Re-export dependencies whose types 
appear in your API</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1510">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1583">Features</a><ul><li><span data-type="index-term">encapsulating unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1208">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">names for crates published on</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1513">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1550">Things to Remember</a></li><li><span data-type="index-term">published crate documentation</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1636">Published Crate Documentation</a></li><li><span data-type="index-term">tests in published crates</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1884">Testing Advice</a></li><li><span data-type="index-term">third-party, open source crates</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2162">Afterword</a></li></ul></li><li><span data-type="index-term">criterion crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1859">Benchmarks</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1941">Tools to Remember</a></li><li><span data-type="index-term">cross-compilation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1949">Beyond Standard Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2013">Writing Code for no_std</a></li><li><span data-type="index-term">cross-reference identifiers</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1618">Item 27: Document public interfaces</a></li><li><span data-type="index-term">cross-references (in documentation)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1617">Item 27: Document public interfaces</a></li><li><span data-type="index-term">CRUD</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1088">Access Control</a></li><li><span data-type="index-term">CStr type</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2086">Accessing C Data from Rust</a></li><li><span data-type="index-term">CString type</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2085">Accessing C Data from Rust</a></li><li><span data-type="index-term">Curl tool</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2032">Fallible Allocation</a></li><li><span data-type="index-term">cxx crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1212">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2151">Beyond C</a></li></ul></div><div data-type="indexdiv"><h3>D</h3><ul><li><span data-type="index-term">data races</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1111">Borrow Rules</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_darace">Data Races</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1274">Deadlocks</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2103">Lifetimes</a><ul><li><span data-type="index-term">in C++</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_daraceC">Data races in C++</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1237">Data races in C++</a></li><li><span data-type="index-term">in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_daraceRst">Data races in Rust</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1261">Standard marker traits</a></li></ul></li><li><span data-type="index-term">data structures</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id232">Types</a><ul><li><span data-type="index-term">and allocation</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_DSalloc">Data Structures and Allocation</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1388">Data Structures and Allocation</a></li><li><span data-type="index-term">designing with borrow checker in mind</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_dastrctdes">Data structure design</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1143">Smart pointers</a></li><li><span data-type="index-term">lifetimes in</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1059">Lifetimes in Data Structures</a></li><li><span data-type="index-term">made available from alloc</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1993">alloc</a></li><li><span data-type="index-term">Rust data structures exposed to C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2122">Invoking Rust from C</a></li><li><span data-type="index-term">self-referential</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_dastrctself">Self-referential data structures</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1173">Things to Remember</a></li><li><span data-type="index-term">standard</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1981">core</a></li><li><span data-type="index-term">using macros to avoid code repetition</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1753">When to Use Macros</a></li></ul></li><li><span data-type="index-term">deadlocks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1224">Item 17: Be wary of shared-state parallelism</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_deadl">Deadlocks</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1284">Advice</a><ul><li><span data-type="index-term">reducing chance of in shared-state parallelism</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1290">Advice</a></li></ul></li><li><span data-type="index-term">Debug trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id404">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id424">Nested Errors</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1709">Declarative Macros</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id812">Debug and Display</a></li><li><span data-type="index-term">from derive macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1744">Derive macros</a></li><li><span data-type="index-term">fmt method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1072">Anonymous Lifetimes</a></li></ul></li><li><span data-type="index-term">DebugDraw trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id949">Basic Comparisons</a></li><li><span data-type="index-term">declarative macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_decmac">Declarative Macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1716">Procedural Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1772">Advice</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1668">Item 28: Use macros judiciously</a></li><li><span data-type="index-term">expression with side effects as input</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1695">Declarative Macros</a></li><li><span data-type="index-term">formatting values</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1701">Declarative Macros</a></li><li><span data-type="index-term">hygienic macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1674">Declarative Macros</a></li><li><span data-type="index-term">inserting code at point of invocation</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1678">Declarative Macros</a></li><li><span data-type="index-term">preferring macros with behavior aligned with normal Rust</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1691">Declarative Macros</a></li></ul></li><li><span data-type="index-term">default features</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1437">Semver for Crate Authors</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1576">Features</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1588">Features</a></li><li><span data-type="index-term">default implementations</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id985">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">Default trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id524">Item 7: Use builders for complex types</a><ul><li><span data-type="index-term">combination with struct update syntax</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id780">Default</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id777">Default</a></li></ul></li><li><span data-type="index-term">defer statement (Go)</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id999">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">denial-of-service (DoS) attacks</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1871">Fuzz Testing</a></li><li><span data-type="index-term">Dependabot</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1449">Semver for Crate Users</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1527">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1934">Tools to Remember</a></li><li><span data-type="index-term">dependencies</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1918">Item 31: Take advantage of the tooling ecosystem</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2011">Writing Code for no_std</a><ul><li><span data-type="index-term">deciding when to take on</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1543">What to Depend On</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1407">Dependencies</a></li><li><span data-type="index-term">dependencies section of Cargo.toml</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1578">Features</a></li><li><span data-type="index-term">indirect</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1515">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">nonbreaking change causing compilation failure</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1487">Item 23: Avoid wildcard imports</a></li><li><span data-type="index-term">re-exporting dependencies whose types appear in your API</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_depreex">Item 24: Re-export dependencies whose types 
appear in your API</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1506">Item 24: Re-export dependencies whose types 
appear in your API</a></li><li><span data-type="index-term">selection by cargo by semantic versioning</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1417">Item 21: Understand what semantic versioning promises</a></li><li><span data-type="index-term">testing functionality of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1832">Unit Tests</a></li><li><span data-type="index-term">wildcard-imported, pinning to precise version</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1495">Item 23: Avoid wildcard imports</a></li></ul></li><li><span data-type="index-term">dependency graph</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1604">Item 24: Re-export dependencies whose types 
appear in your API</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_depgrp">Item 25: Manage your dependency graph</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1556">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1914">Item 31: Take advantage of the tooling ecosystem</a><ul><li><span data-type="index-term">expanded, controlling exposure to with optional features</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1599">Features</a></li><li><span data-type="index-term">multiple versions of a crate in</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1809">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">solving problems with tooling</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1536">Solving Problems with Tooling</a></li></ul></li><li><span data-type="index-term">dependency upgrades</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1528">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">deprecated attribute</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1441">Semver for Crate Authors</a></li><li><span data-type="index-term">Deref trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id494">Coercion</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id564">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id826">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id880">Summary</a></li><li><span data-type="index-term">DerefMut trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id495">Coercion</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id566">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id827">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id881">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1251">Data races in Rust</a></li><li><span data-type="index-term">derive attribute</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id519">Newtype Limitations</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id525">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id761">Common Standard Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id778">Default</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id786">PartialEq and Eq</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id832">Standard Traits Covered Elsewhere</a></li><li><span data-type="index-term">derive macros</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id757">Item 10: Familiarize yourself with standard traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1372">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1671">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_dermac">Derive macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1746">Derive macros</a><ul><li><span data-type="index-term">declaring associated helper attributes</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1735">Derive macros</a></li><li><span data-type="index-term">preferring to procedural macro that emits a type</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1774">Advice</a></li></ul></li><li><span data-type="index-term">DeriveInput data structure</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1741">Derive macros</a></li><li><span data-type="index-term">derive_builder crate</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id541">Item 7: Use builders for complex types</a></li><li><span data-type="index-term">Deserialize macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1736">Derive macros</a></li><li><span data-type="index-term">destructors</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id897">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1046">The 'static Lifetime</a></li><li><span data-type="index-term">development environment, tools for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1898">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">diagnostic information from macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1758">When to Use Macros</a></li><li><span data-type="index-term">discussion forums</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2164">Afterword</a></li><li><span data-type="index-term">Display trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id403">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id425">Nested Errors</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id810">Debug and Display</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1708">Declarative Macros</a></li><li><span data-type="index-term">Div trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id852">Summary</a></li><li><span data-type="index-term">DivAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id853">Summary</a></li><li><span data-type="index-term">dividing by zero</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1331">Item 18: Don’t panic</a></li><li><span data-type="index-term">dlopen function</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1369">Item 19: Avoid reflection</a></li><li><span data-type="index-term">doc tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1838">Doc Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1890">Things to Remember</a></li><li><span data-type="index-term">docs.rs</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1638">Published Crate Documentation</a></li><li><span data-type="index-term">documentation</span><ul><li><span data-type="index-term">conventions for documentation comments</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1811">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">documenting public interfaces</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.i_docu">Item 27: Document public interfaces</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1658">Things to Remember</a><ul><li><span data-type="index-term">additional documentation locations</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1631">Additional Documentation Locations</a></li><li><span data-type="index-term">published crate documentation</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1637">Published Crate Documentation</a></li><li><span data-type="index-term">Rust documentation comment format</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1615">Item 27: Document public interfaces</a></li><li><span data-type="index-term">tooling for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1623">Tooling</a></li><li><span data-type="index-term">what not to document</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1640">What Not to Document</a></li></ul></li><li><span data-type="index-term">requiring</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1629">Tooling</a></li><li><span data-type="index-term">for Rust standard library</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1904">Item 31: Take advantage of the tooling ecosystem</a></li></ul></li><li><span data-type="index-term">domain-specific language (DSL)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1754">When to Use Macros</a></li><li><span data-type="index-term">DoubleEndedIterator</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id888">Summary</a></li><li><span data-type="index-term">downcast_mut method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1357">Item 19: Avoid reflection</a></li><li><span data-type="index-term">downcast_ref method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1356">Item 19: Avoid reflection</a></li><li><span data-type="index-term">Draw trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id934">Generics</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id954">More Trait Bounds</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1364">Item 19: Avoid reflection</a><ul><li><span data-type="index-term">methods accepting Shape and</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id964">More Trait Bounds</a></li><li><span data-type="index-term">vtable for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id959">More Trait Bounds</a></li></ul></li><li><span data-type="index-term">drop method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id920">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">Drop trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id823">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id889">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2111">Lifetimes</a><ul><li><span data-type="index-term">implementing for synchronization resources</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id911">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">implementing for types holding resources that must be released</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id908">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">implementing RAII pattern</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id919">Item 11: Implement the Drop trait for RAII patterns</a></li></ul></li><li><span data-type="index-term">dropping items</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1022">Scope of a Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1090">Access Control</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1120">Owner Operations</a><ul><li><span data-type="index-term">in multithreaded environment</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1257">Data races in Rust</a></li></ul></li><li><span data-type="index-term">dynamically typed languages</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1336">Item 19: Avoid reflection</a></li><li><span data-type="index-term">dynamic_cast (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1345">Item 19: Avoid reflection</a></li></ul></div><div data-type="indexdiv"><h3>E</h3><ul><li><span data-type="index-term">Effective C++ (Meyers)</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id217">Who This Book Is For</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1479">Visibility Semantics</a></li><li><span data-type="index-term">Effective Java (Bloch)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1366">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1476">Visibility Semantics</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1610">Item 27: Document public interfaces</a></li><li><span data-type="index-term">efficiency (optimal), fine-tuning for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1392">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">elision rules</span> (<span data-gentext="see">see</span> lifetime elision rules)</li><li><span data-type="index-term">embedded platforms</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1964">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">enumerate method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id668">Iterator Transforms</a></li><li><span data-type="index-term">enums</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id230">Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_enum">enums</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id296">enums with Fields</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id324">Functions and Methods</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1158">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1431">Semver for Crate Authors</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1732">Derive macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1775">Advice</a><ul><li><span data-type="index-term">avoiding code repetition with macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1752">When to Use Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1755">When to Use Macros</a></li><li><span data-type="index-term">C-like, casts between</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id477">Casts</a></li><li><span data-type="index-term">Default trait derived for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id779">Default</a></li><li><span data-type="index-term">derive macro use</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1742">Derive macros</a></li><li><span data-type="index-term">deriving Copy</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1395">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">disadvantage of macros for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1762">Disadvantages of Macros</a></li><li><span data-type="index-term">enum types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id236">Item 1: Use the type system to express 
your data structures</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id297">Ubiquitous enum Types</a><ul><li><span data-type="index-term">Option</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id298">Option&lt;T&gt;</a></li><li><span data-type="index-term">Result</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id302">Result&lt;T, E&gt;</a></li></ul></li><li><span data-type="index-term">field comparisons with Ord and PartialOrd</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id801">PartialOrd and Ord</a></li><li><span data-type="index-term">holding values not in list of allowed variants</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1831">Unit Tests</a></li><li><span data-type="index-term">making public</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1460">Visibility Syntax</a></li><li><span data-type="index-term">nested error types in</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id423">Nested Errors</a></li></ul></li><li><span data-type="index-term">eprintln! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1705">Declarative Macros</a></li><li><span data-type="index-term">Eq trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id758">Item 10: Familiarize yourself with standard traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id809">Hash</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id783">PartialEq and Eq</a></li><li><span data-type="index-term">required by Ord</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id800">PartialOrd and Ord</a></li></ul></li><li><span data-type="index-term">equality (==) checks</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id784">PartialEq and Eq</a></li><li><span data-type="index-term">Err variant of Result</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id380">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id675">Iterator Transforms</a></li><li><span data-type="index-term">error conditions</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1649">What Not to Document</a></li><li><span data-type="index-term">error messages</span><ul><li><span data-type="index-term">borrowing rule broken</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1126">Local code refactoring</a></li><li><span data-type="index-term">fixing problem with borrow checker</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1127">Local code refactoring</a></li><li><span data-type="index-term">more complex problems with borrow checker</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1131">Local code refactoring</a></li></ul></li><li><span data-type="index-term">Error trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id379">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id401">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id822">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id870">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2154">core</a></li><li><span data-type="index-term">errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id376">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1796">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">from borrow checker</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1180">Things to Remember</a></li><li><span data-type="index-term">mapping</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id389">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">preferring idiomatic Error types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_erridtyp">Item 4: Prefer idiomatic Error types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id434">Things to Remember</a><ul><li><span data-type="index-term">minimal implementations</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id410">Minimal Errors</a></li><li><span data-type="index-term">nested errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id420">Nested Errors</a></li></ul></li><li><span data-type="index-term">preferring Result to Option for expressing errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id385">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">processing if function fails, using Result type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id304">Result&lt;T, E&gt;</a></li><li><span data-type="index-term">propagation with use of explicit match expression</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id386">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">in type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id448">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">ExactSizeIterator</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id887">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id986">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">example code</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1619">Item 27: Document public interfaces</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1633">Additional Documentation Locations</a><ul><li><span data-type="index-term">testing</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1843">Examples</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1891">Things to Remember</a></li></ul></li><li><span data-type="index-term">exception safety</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1308">Item 18: Don’t panic</a></li><li><span data-type="index-term">exceptions, panic! and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1305">Item 18: Don’t panic</a></li><li><span data-type="index-term">expect method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id382">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1319">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1806">Item 29: Listen to Clippy</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1822">Unit Tests</a></li><li><span data-type="index-term">expect_err method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1328">Item 18: Don’t panic</a></li><li><span data-type="index-term">explicit casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id476">Casts</a></li><li><span data-type="index-term">explicit constraints on target type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id361">Trait bounds</a></li><li><span data-type="index-term">extern C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2049">Invoking C Functions from Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2076">Name mangling</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2118">Invoking Rust from C</a></li><li><span data-type="index-term">extern crate</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1990">alloc</a></li><li><span data-type="index-term">extern crate alloc</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1989">alloc</a></li></ul></div><div data-type="indexdiv"><h3>F</h3><ul><li><span data-type="index-term">f32 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id270">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id793">PartialEq and Eq</a></li><li><span data-type="index-term">f64 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id271">Fundamental Types</a></li><li><span data-type="index-term">failures</span><ul><li><span data-type="index-term">allocation failure</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2023">Fallible Allocation</a></li><li><span data-type="index-term">designing software to cope with</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id377">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li></ul></li><li><span data-type="index-term">fallible allocation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2018">Fallible Allocation</a></li><li><span data-type="index-term">fat pointers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id498">Coercion</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id573">Fat Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id940">Trait Objects</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1353">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1361">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1799">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">slice</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id575">Slices</a></li><li><span data-type="index-term">trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id586">Trait objects</a></li></ul></li><li><span data-type="index-term">@FearlessSon</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1814">Item 30: Write more than unit tests</a></li><li><span data-type="index-term">feature option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1574">Features</a></li><li><span data-type="index-term">feature unification</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1529">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1589">Features</a></li><li><span data-type="index-term">features</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1511">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_featr">Item 26: Be wary of feature creep</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1603">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1810">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1572">Features</a></li><li><span data-type="index-term">no_standard and no_alloc, avoiding</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2015">Writing Code for no_std</a></li><li><span data-type="index-term">std and alloc</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2014">Writing Code for no_std</a></li><li><span data-type="index-term">testing</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1881">Testing Advice</a></li></ul></li><li><span data-type="index-term">FFI (foreign-function interface)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1214">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1518">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1943">Tools to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_FFI">Item 34: Control what crosses FFI boundaries</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2144">Things to Remember</a><ul><li><span data-type="index-term">accessing C data from Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_FFICdata">Accessing C Data from Rust</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2089">Accessing C Data from Rust</a></li><li><span data-type="index-term">encapsulating access to unsafe library in safe Rust code</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2117">Lifetimes</a></li><li><span data-type="index-term">invoking C functions from Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2048">Invoking C Functions from Rust</a><ul><li><span data-type="index-term">code concerns</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2061">Code concerns</a></li><li><span data-type="index-term">linking logistics</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2052">Linking logistics</a></li><li><span data-type="index-term">name mangling</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2067">Name mangling</a></li></ul></li><li><span data-type="index-term">invoking Rust from C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_FFICRust">Invoking Rust from C</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2142">Invoking Rust from C</a></li><li><span data-type="index-term">lifetimes</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2092">Lifetimes</a></li><li><span data-type="index-term">linking with code from languages other than Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1950">Beyond Standard Rust</a></li><li><span data-type="index-term">panic propagation interacting badly with FFI bounds</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1314">Item 18: Don’t panic</a></li><li><span data-type="index-term">preferring bindgen to FFI mappings</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_FFIbindg">Item 35: Prefer bindgen to manual FFI mappings</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2148">Item 35: Prefer bindgen to manual FFI mappings</a></li><li><span data-type="index-term">using existing library via, cost-benefit analysis</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2106">Lifetimes</a></li></ul></li><li><span data-type="index-term">file descriptors</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id910">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">file! MACRO</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1759">When to Use Macros</a></li><li><span data-type="index-term">filter method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id670">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id734">Loop Transformation</a></li><li><span data-type="index-term">find method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id698">Iterator Consumers</a></li><li><span data-type="index-term">firmware</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1963">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">flatten method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id674">Iterator Transforms</a></li><li><span data-type="index-term">flattening stream of Option / Result values</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id681">Iterator Transforms</a></li><li><span data-type="index-term">floating point types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id267">Fundamental Types</a><ul><li><span data-type="index-term">single-precision format</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id792">PartialEq and Eq</a></li></ul></li><li><span data-type="index-term">fmt method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1073">Anonymous Lifetimes</a></li><li><span data-type="index-term">fn (function pointer) types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id327">Function Pointers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id345">Closures</a></li><li><span data-type="index-term">Fn trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id341">Closures</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id818">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id867">Summary</a></li><li><span data-type="index-term">FnMut trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id340">Closures</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id819">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id868">Summary</a></li><li><span data-type="index-term">FnOnce trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id339">Closures</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id820">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id869">Summary</a></li><li><span data-type="index-term">fold method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id695">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id707">Iterator Consumers</a></li><li><span data-type="index-term">for loops</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id633">Item 9: Consider using iterator transforms 
instead of explicit loops</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id658">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id684">Iterator Consumers</a></li><li><span data-type="index-term">for-each loops</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id638">Item 9: Consider using iterator transforms 
instead of explicit loops</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id683">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id733">Loop Transformation</a></li><li><span data-type="index-term">foreign function interface</span> (<span data-gentext="see">see</span> FFI)</li><li><span data-type="index-term">formal verification</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1928">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">format! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1703">Declarative Macros</a></li><li><span data-type="index-term">format_args! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1682">Declarative Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1714">Declarative Macros</a></li><li><span data-type="index-term">for_each method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id685">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id705">Iterator Consumers</a></li><li><span data-type="index-term">free function (in C)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2104">Lifetimes</a></li><li><span data-type="index-term">From trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id390">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id417">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id824">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id871">Summary</a><ul><li><span data-type="index-term">from / into conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id505">Item 6: Embrace the newtype pattern</a></li><li><span data-type="index-term">From implementation and Into trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id471">User-Defined Type Conversions</a></li><li><span data-type="index-term">implementation for suberror types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id426">Nested Errors</a></li><li><span data-type="index-term">implementation for type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id450">User-Defined Type Conversions</a></li><li><span data-type="index-term">integral conversions where destination type includes all possible values of source</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id459">User-Defined Type Conversions</a></li><li><span data-type="index-term">preferring from / into conversions over as casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id481">Casts</a></li><li><span data-type="index-term">reflexive implementation</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id466">User-Defined Type Conversions</a></li><li><span data-type="index-term">use in user-defined type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id444">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">FromIterator trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id710">Iterator Consumers</a></li><li><span data-type="index-term">function pointers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id309">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id325">Function Pointers</a><ul><li><span data-type="index-term">for all trait implementation's methods</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id942">Trait Objects</a></li></ul></li><li><span data-type="index-term">function signatures, lifetimes</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1033">Algebra of Lifetimes</a></li><li><span data-type="index-term">function-like macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1725">Function-like macros</a></li><li><span data-type="index-term">functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id319">Functions and Methods</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1664">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1750">When to Use Macros</a><ul><li><span data-type="index-term">currently executing function, state of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1011">Introduction to the Stack</a></li><li><span data-type="index-term">lifetime elision rules for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1040">Lifetime Elision Rules</a></li><li><span data-type="index-term">related, defined by a trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id348">Traits</a></li><li><span data-type="index-term">Rust, exposed to C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2119">Invoking Rust from C</a></li><li><span data-type="index-term">using trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id943">Trait Objects</a></li><li><span data-type="index-term">using unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1203">Item 16: Avoid writing unsafe code</a></li></ul></li><li><span data-type="index-term">fuzz tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1861">Fuzz Testing</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1895">Things to Remember</a></li></ul></div><div data-type="indexdiv"><h3>G</h3><ul><li><span data-type="index-term">generics</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id753">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.ix_genrc">Item 12: Understand the trade-offs between 
generics and trait objects</a>-<a data-type="index:locator" href="#OEBPS/ch02.html.id983">Trade-Offs</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1665">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1751">When to Use Macros</a><ul><li><span data-type="index-term">generic functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id470">User-Defined Type Conversions</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id932">Generics</a></li><li><span data-type="index-term">generic method accepting items implementing Shape</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id965">More Trait Bounds</a></li><li><span data-type="index-term">generic methods</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id969">Trait Object Safety</a></li><li><span data-type="index-term">trade-offs with trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id978">Trade-Offs</a></li><li><span data-type="index-term">trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id365">Trait bounds</a></li><li><span data-type="index-term">trait bounds type parameter implementing multiple traits</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id947">Basic Comparisons</a></li><li><span data-type="index-term">trait having generic function</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id370">Trait objects</a></li><li><span data-type="index-term">versus trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id944">Basic Comparisons</a></li></ul></li><li><span data-type="index-term">Git, tracking commits</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1427">Semver for Crate Authors</a></li><li><span data-type="index-term">Gjengset, Jon</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1169">Self-referential data structures</a>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2167">Afterword</a></li><li><span data-type="index-term">glob imports</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1483">Item 23: Avoid wildcard imports</a><ul><li>(<span data-gentext="see">see also</span> wildcard imports)</li></ul></li><li><span data-type="index-term">Go</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id225">Rust Version</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id273">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id314">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id1000">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1286">Advice</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1339">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2044">Item 34: Control what crosses FFI boundaries</a></li><li><span data-type="index-term">Godbolt compiler explorer</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id744">When Explicit Is Better</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1858">Benchmarks</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1938">Tools to Remember</a></li><li><span data-type="index-term">Goldilocks version specification (dependencies)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1534">Version Specification</a></li><li><span data-type="index-term">Google OSS-Fuzz program</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1877">Fuzz Testing</a></li><li><span data-type="index-term">Graham, Paul</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1659">Item 28: Use macros judiciously</a></li><li><span data-type="index-term">gratuitous use of Latin</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1215">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">Group enum</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1765">Disadvantages of Macros</a></li></ul></div><div data-type="indexdiv"><h3>H</h3><ul><li><span data-type="index-term">Hash trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id750">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id795">PartialEq and Eq</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id806">Hash</a></li></ul></li><li><span data-type="index-term">HashMap type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id751">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id794">PartialEq and Eq</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id807">Hash</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1994">alloc</a></li><li><span data-type="index-term">HashSet type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id712">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id808">Hash</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1996">alloc</a></li><li><span data-type="index-term">heap</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id559">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id579">Slices</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1802">Item 29: Listen to Clippy</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1952">Beyond Standard Rust</a><ul><li><span data-type="index-term">C code freeing heap memory</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2105">Lifetimes</a></li><li><span data-type="index-term">freeing memory from Rust side</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2137">Invoking Rust from C</a></li><li><span data-type="index-term">heap allocation possible, but may fail</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2019">Fallible Allocation</a></li><li><span data-type="index-term">lifetimes and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1052">Lifetimes and the Heap</a></li><li><span data-type="index-term">no heap allocation for core library</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1979">core</a></li><li><span data-type="index-term">no_std environment supporting heap allocation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1985">alloc</a></li><li><span data-type="index-term">pointers passed from Rust to C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2134">Invoking Rust from C</a></li><li><span data-type="index-term">value allocated on and never freed</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1048">The 'static Lifetime</a></li></ul></li><li><span data-type="index-term">Here Be Dragons</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1217">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2097">Lifetimes</a></li><li><span data-type="index-term">hygienic macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1663">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1675">Declarative Macros</a></li><li><span data-type="index-term">Hyrum's Law</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1429">Semver for Crate Authors</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1445">Semver for Crate Users</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1451">Discussion</a></li></ul></div><div data-type="indexdiv"><h3>I</h3><ul><li><span data-type="index-term">i128 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id245">Fundamental Types</a></li><li><span data-type="index-term">i16 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id242">Fundamental Types</a></li><li><span data-type="index-term">i32 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id243">Fundamental Types</a></li><li><span data-type="index-term">i64 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id244">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id723">Building Collections from Result Values</a></li><li><span data-type="index-term">i8 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id241">Fundamental Types</a></li><li><span data-type="index-term">IDE or IDE/editor plug-in</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1902">Item 31: Take advantage of the tooling ecosystem</a><ul><li><span data-type="index-term">integrating tools into</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1931">Item 31: Take advantage of the tooling ecosystem</a></li></ul></li><li><span data-type="index-term">idioms, warning about</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1782">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">immutable references</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1104">Borrow Rules</a><ul><li><span data-type="index-term">owner operations and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1116">Owner Operations</a></li></ul></li><li><span data-type="index-term">impl Trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id936">Generics</a></li><li><span data-type="index-term">Index trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id583">Slices</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id882">Summary</a></li><li><span data-type="index-term">IndexMut trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id749">Slices</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id883">Summary</a></li><li><span data-type="index-term">infallible allocation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2024">Fallible Allocation</a><ul><li><span data-type="index-term">disabling</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2038">Fallible Allocation</a></li></ul></li><li><span data-type="index-term">Infallible error type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id464">User-Defined Type Conversions</a></li><li><span data-type="index-term">inherent implementation</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id1002">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">inheritance, trait bounds versus</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id955">More Trait Bounds</a></li><li><span data-type="index-term">inline functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id388">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">int type (in C)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2063">Code concerns</a></li><li><span data-type="index-term">integer types</span><ul><li><span data-type="index-term">converting larger to smaller, compile-time error</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id256">Fundamental Types</a></li><li><span data-type="index-term">matching pointer size, signed and unsigned</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id251">Fundamental Types</a></li><li><span data-type="index-term">specific sized, signed and unsigned</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id240">Fundamental Types</a></li></ul></li><li><span data-type="index-term">integration tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1635">Additional Documentation Locations</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1835">Integration Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1889">Things to Remember</a></li><li><span data-type="index-term">interfaces</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id316">Item 2: Use the type system to express common behavior</a></li><li><span data-type="index-term">interior mutability</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id614">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1045">The 'static Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1253">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1267">Standard marker traits</a></li><li><span data-type="index-term">internationalization</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id814">Debug and Display</a></li><li><span data-type="index-term">Into trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id446">User-Defined Type Conversions</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id873">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1797">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">automatically provided with From trait implementation</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id452">User-Defined Type Conversions</a></li><li><span data-type="index-term">blanket trait implementation</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id457">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">IntoIterator trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id648">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id886">Summary</a></li><li><span data-type="index-term">invariants</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1647">What Not to Document</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1828">Unit Tests</a><ul><li><span data-type="index-term">internal, preserving in presence of exceptions</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1309">Item 18: Don’t panic</a></li><li><span data-type="index-term">RAII types</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id898">Item 11: Implement the Drop trait for RAII patterns</a></li></ul></li><li><span data-type="index-term">is method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1355">Item 19: Avoid reflection</a></li><li><span data-type="index-term">isize</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id615">Smart Pointer Types</a></li><li><span data-type="index-term">is_empty method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id989">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">Item type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id645">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id662">Iterator Transforms</a><ul><li><span data-type="index-term">Ord implementation</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id691">Iterator Consumers</a></li></ul></li><li><span data-type="index-term">iter method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id656">Iterator Traits</a></li><li><span data-type="index-term">iterables</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id646">Iterator Traits</a></li><li><span data-type="index-term">iterator adaptors</span> (<span data-gentext="see">see</span> iterator transforms)</li><li><span data-type="index-term">Iterator trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id649">Iterator Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id659">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id828">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id885">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id987">Item 13: Use default implementations 
to minimize required trait methods</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1972">core</a><ul><li><span data-type="index-term">manipulation of, methods</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1803">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">methods to select single value from collection</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id697">Iterator Consumers</a></li><li><span data-type="index-term">single required method and default method implementations</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id992">Item 13: Use default implementations 
to minimize required trait methods</a></li></ul></li><li><span data-type="index-term">iterator transforms</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id639">Item 9: Consider using iterator transforms 
instead of explicit loops</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_itertrns">Iterator Traits</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id682">Iterator Transforms</a><ul><li><span data-type="index-term">converting loops to</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id731">Loop Transformation</a></li><li><span data-type="index-term">transformation expressions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id643">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">when explicit loops are better than</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id739">When Explicit Is Better</a></li></ul></li><li><span data-type="index-term">iterators</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_iter">Item 9: Consider using iterator transforms 
instead of explicit loops</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id745">When Explicit Is Better</a><ul><li><span data-type="index-term">building collections from Result values</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id721">Building Collections from Result Values</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id636">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">iterator consumers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_itercons">Iterator Consumers</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id720">Building Collections from Result Values</a></li></ul></li><li><span data-type="index-term">iter_mut method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id657">Iterator Traits</a></li></ul></div><div data-type="indexdiv"><h3>J</h3><ul><li><span data-type="index-term">Java</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id224">Rust Version</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id315">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1303">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1338">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1368">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1612">Item 27: Document public interfaces</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2043">Item 34: Control what crosses FFI boundaries</a><ul><li><span data-type="index-term">visibility guidelines</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1478">Visibility Semantics</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>L</h3><ul><li><span data-type="index-term">lambda expressions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id334">Closures</a></li><li><span data-type="index-term">lattice</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id803">PartialOrd and Ord</a></li><li><span data-type="index-term">let keyword</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id537">Item 7: Use builders for complex types</a></li><li><span data-type="index-term">lib.rs</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2163">Afterword</a></li><li><span data-type="index-term">libFuzzer</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1872">Fuzz Testing</a></li><li><span data-type="index-term">libraries</span><ul><li><span data-type="index-term">crates</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1507">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">making library code no_std-compatible</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.ix_libnostd">Item 33: Consider making library code 
no_std compatible</a>-<a data-type="index:locator" href="#OEBPS/ch06.html.id2040">Things to Remember</a><ul><li><span data-type="index-term">alloc library</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1987">alloc</a></li><li><span data-type="index-term">core library</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1970">core</a></li><li><span data-type="index-term">fallible allocation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2016">Fallible Allocation</a></li><li><span data-type="index-term">writing code for no-std</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2002">Writing Code for no_std</a></li></ul></li><li><span data-type="index-term">multiple versions of same library</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1370">Item 19: Avoid reflection</a></li><li><span data-type="index-term">unsafe code in Rust standard libraries</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1190">Item 16: Avoid writing unsafe code</a></li></ul></li><li><span data-type="index-term">licenses</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1546">What to Depend On</a><ul><li><span data-type="index-term">changing license for open source crate</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1436">Semver for Crate Authors</a></li></ul></li><li><span data-type="index-term">lifetime bound</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1352">Item 19: Avoid reflection</a></li><li><span data-type="index-term">lifetime checks</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id554">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1005">Concepts</a></li><li><span data-type="index-term">lifetime elision rules</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1034">Algebra of Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1062">Lifetimes in Data Structures</a><ul><li><span data-type="index-term">anonymous lifetimes and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1070">Anonymous Lifetimes</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1037">Lifetime Elision Rules</a></li></ul></li><li><span data-type="index-term">lifetime of a value, correlation with lifecycle of a resource</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id895">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">lifetime parameter</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1063">Lifetimes in Data Structures</a><ul><li><span data-type="index-term">elided</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1071">Anonymous Lifetimes</a></li></ul></li><li><span data-type="index-term">lifetimes</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id550">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1007">Item 14: Understand lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1383">Data Structures and Allocation</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2091">Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2126">Invoking Rust from C</a><ul><li><span data-type="index-term">algebra of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_lftalg">Algebra of Lifetimes</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1036">Lifetime Elision Rules</a></li><li><span data-type="index-term">anonymous</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1068">Anonymous Lifetimes</a></li><li><span data-type="index-term">in data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1060">Lifetimes in Data Structures</a></li><li><span data-type="index-term">evolution of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_lftevol">Evolution of Lifetimes</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1019">Evolution of Lifetimes</a></li><li><span data-type="index-term">issue with in multithreaded environment</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1255">Data races in Rust</a></li><li><span data-type="index-term">of items on the heap</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1053">Lifetimes and the Heap</a></li><li><span data-type="index-term">lifetime extension</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1128">Local code refactoring</a></li><li><span data-type="index-term">lifetime reduction</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1129">Local code refactoring</a></li><li><span data-type="index-term">lifetimes of multiple arguments</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1066">Lifetimes in Data Structures</a></li><li><span data-type="index-term">references</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1084">Item 15: Understand the borrow checker</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1101">Borrow Rules</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1179">Things to Remember</a></li><li><span data-type="index-term">scope of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_lftscp">Scope of a Lifetime</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1031">Algebra of Lifetimes</a></li><li><span data-type="index-term">static lifetime</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1041">The 'static Lifetime</a></li></ul></li><li><span data-type="index-term">line! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1760">When to Use Macros</a></li><li><span data-type="index-term">link attribute</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2055">Linking logistics</a></li><li><span data-type="index-term">linker</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id514">Bypassing the Orphan Rule for Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id946">Basic Comparisons</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2070">Name mangling</a></li><li><span data-type="index-term">links key</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2058">Linking logistics</a></li><li><span data-type="index-term">lint</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1789">Item 29: Listen to Clippy</a><ul><li>(<span data-gentext="see">see also</span> Clippy)</li></ul></li><li><span data-type="index-term">Linux kernel</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2030">Fallible Allocation</a></li><li><span data-type="index-term">Liskov substitution</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id962">More Trait Bounds</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1377">Upcasting in Future Versions of Rust</a></li><li><span data-type="index-term">Lisp</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id311">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1718">Procedural Macros</a></li><li><span data-type="index-term">local code refactoring</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1124">Local code refactoring</a></li><li><span data-type="index-term">localization</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id813">Debug and Display</a></li><li><span data-type="index-term">lock inversion</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1278">Deadlocks</a></li><li><span data-type="index-term">lock method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id914">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">locking hierarchy</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1295">Advice</a></li><li><span data-type="index-term">locks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1275">Deadlocks</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1292">Advice</a><ul><li>(<span data-gentext="see">see also</span> deadlocks)</li><li><span data-type="index-term">correct use of</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id918">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">in C++</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1232">Data races in C++</a></li><li><span data-type="index-term">reducing scope to prevent deadlocks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1280">Deadlocks</a></li><li><span data-type="index-term">in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1248">Data races in Rust</a></li></ul></li><li><span data-type="index-term">lock_guard (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1234">Data races in C++</a></li><li><span data-type="index-term">log crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1713">Declarative Macros</a></li><li><span data-type="index-term">loops</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1686">Declarative Macros</a><ul><li><span data-type="index-term">converting to iterator transforms</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id732">Loop Transformation</a></li><li><span data-type="index-term">increasing convenience and abstraction of</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id631">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li><li><span data-type="index-term">old-style, bounds checking and</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id719">Iterator Consumers</a></li><li><span data-type="index-term">rendering a list of shapes, OO example</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id981">Trade-Offs</a></li><li><span data-type="index-term">using explicit loops instead of iterator transforms</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id738">When Explicit Is Better</a></li><li><span data-type="index-term">using iterator transforms instead of</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id642">Item 9: Consider using iterator transforms 
instead of explicit loops</a></li></ul></li><li><span data-type="index-term">lossy conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id479">Casts</a></li><li><span data-type="index-term">LowerHex trait</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1711">Declarative Macros</a></li></ul></div><div data-type="indexdiv"><h3>M</h3><ul><li><span data-type="index-term">macros</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id540">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1371">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_mcro">Item 28: Use macros judiciously</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1777">Advice</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1925">Item 31: Take advantage of the tooling ecosystem</a><ul><li><span data-type="index-term">declarative</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1667">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_macrdec">Declarative Macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1715">Procedural Macros</a><ul><li><span data-type="index-term">expression with side effects as input</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1694">Declarative Macros</a></li><li><span data-type="index-term">formatting values</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1702">Declarative Macros</a></li><li><span data-type="index-term">inserting code at point of invocation</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1679">Declarative Macros</a></li><li><span data-type="index-term">preferring macros with behavior aligned with normal Rust</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1692">Declarative Macros</a></li></ul></li><li><span data-type="index-term">derive</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id756">Item 10: Familiarize yourself with standard traits</a></li><li><span data-type="index-term">disadvantages of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1761">Disadvantages of Macros</a></li><li><span data-type="index-term">general advice on use of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1769">Advice</a></li><li><span data-type="index-term">procedural</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1669">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_macrproc">Procedural Macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1747">Derive macros</a><ul><li>(<span data-gentext="see">see also</span> procedural macros)</li></ul></li><li><span data-type="index-term">when to use</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1749">When to Use Macros</a></li></ul></li><li><span data-type="index-term">main function</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1318">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1847">Examples</a></li><li><span data-type="index-term">major version</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1424">Semver Essentials</a></li><li><span data-type="index-term">map method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id664">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id736">Loop Transformation</a></li><li><span data-type="index-term">maps</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1983">core</a></li><li><span data-type="index-term">Markdown</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1614">Item 27: Document public interfaces</a></li><li><span data-type="index-term">marker traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id354">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id767">Copy</a><ul><li><span data-type="index-term">Eq</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id787">PartialEq and Eq</a></li><li><span data-type="index-term">standard, affecting copy semantics</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id769">Copy</a></li><li><span data-type="index-term">standard, affecting use of Rust objects between threads</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1260">Standard marker traits</a></li></ul></li><li><span data-type="index-term">match expressions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id381">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1757">When to Use Macros</a><ul><li><span data-type="index-term">explicit, preferring Option and Result transforms over</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_mtch">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id397">Things to Remember</a></li></ul></li><li><span data-type="index-term">max method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id689">Iterator Consumers</a></li><li><span data-type="index-term">max_by method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id693">Iterator Consumers</a></li><li><span data-type="index-term">memory</span><ul><li><span data-type="index-term">allocating and freeing on same side of FFI boundary</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2108">Lifetimes</a></li><li><span data-type="index-term">program memory layout</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1010">Introduction to the Stack</a></li><li><span data-type="index-term">protections in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2107">Lifetimes</a></li><li><span data-type="index-term">safety guarantees without runtime overhead</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1182">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">safety of</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id212">Preface</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2099">Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2129">Invoking Rust from C</a></li><li><span data-type="index-term">safety problems in C/C++</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1865">Fuzz Testing</a></li><li><span data-type="index-term">safety problems in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1868">Fuzz Testing</a></li></ul></li><li><span data-type="index-term">memory leaks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1051">The 'static Lifetime</a></li><li><span data-type="index-term">memory management, RAII patterns used for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id903">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">memory pointers</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id906">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">memory synchronization</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id912">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">metadata</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1916">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">metaprogramming</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1660">Item 28: Use macros judiciously</a></li><li><span data-type="index-term">methods</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id308">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id321">Functions and Methods</a><ul><li><span data-type="index-term">functions in traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id350">Traits</a></li><li><span data-type="index-term">on public traits, avoiding feature-gating</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1597">Features</a></li><li><span data-type="index-term">visibility</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1457">Visibility Syntax</a></li></ul></li><li><span data-type="index-term">Meyers, Scott</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id218">Who This Book Is For</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1480">Visibility Semantics</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1656">What Not to Document</a></li><li><span data-type="index-term">Microsoft Clippit</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1778">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">min method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id688">Iterator Consumers</a></li><li><span data-type="index-term">minimum supported Rust version (MSRV)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1438">Semver for Crate Authors</a></li><li><span data-type="index-term">minor version</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1423">Semver Essentials</a></li><li><span data-type="index-term">min_by method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id692">Iterator Consumers</a></li><li><span data-type="index-term">Miri</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1933">Tools to Remember</a></li><li><span data-type="index-term">mismatched types error</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id257">Fundamental Types</a></li><li><span data-type="index-term">missing copy implementations compiler lint</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id776">Copy</a></li><li><span data-type="index-term">missing Debug implementations compiler lint</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id815">Debug and Display</a></li><li><span data-type="index-term">missing safety doc Clippy lint</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1219">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">modules</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1454">Visibility Syntax</a><ul><li><span data-type="index-term">pub contents</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1463">Visibility Syntax</a></li><li><span data-type="index-term">tests or test</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1819">Unit Tests</a></li><li><span data-type="index-term">visibility</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1467">Visibility Syntax</a></li><li><span data-type="index-term">wildcard imports of</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1485">Item 23: Avoid wildcard imports</a></li></ul></li><li><span data-type="index-term">monomorphization (generics)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id359">Trait bounds</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id931">Generics</a><ul><li><span data-type="index-term">different monomorphized function for each type called with</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id938">Generics</a></li></ul></li><li><span data-type="index-term">More Effective C++ (Meyers)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1655">What Not to Document</a></li><li><span data-type="index-term">move keyword</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id337">Closures</a></li><li><span data-type="index-term">moving an item</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1089">Access Control</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1119">Owner Operations</a><ul><li><span data-type="index-term">data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1165">Self-referential data structures</a></li><li><span data-type="index-term">items moved to or from the stack</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1021">Scope of a Lifetime</a></li></ul></li><li><span data-type="index-term">Mul trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id854">Summary</a></li><li><span data-type="index-term">MulAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id855">Summary</a></li><li><span data-type="index-term">multithreading</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1227">Data races in C++</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1239">Data races in Rust</a><ul><li><span data-type="index-term">general advice on multithreaded code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1299">Advice</a></li></ul></li><li><span data-type="index-term">mutable references</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id556">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id565">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1081">Item 15: Understand the borrow checker</a><ul><li><span data-type="index-term">accessing contents of Rust items with</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1087">Access Control</a></li><li><span data-type="index-term">aliased</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1109">Borrow Rules</a></li><li><span data-type="index-term">borrow checker rule for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1241">Data races in Rust</a></li><li><span data-type="index-term">conversion to immutable</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id489">Coercion</a></li><li><span data-type="index-term">owner operations and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1117">Owner Operations</a></li><li><span data-type="index-term">replacing item content and returning previous value</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1091">Access Control</a></li><li><span data-type="index-term">rule for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1105">Borrow Rules</a></li></ul></li><li><span data-type="index-term">mutex (in C++)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1233">Data races in C++</a></li><li><span data-type="index-term">Mutex type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id626">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id764">Clone</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id901">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id917">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1148">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1192">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1245">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1998">alloc</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2102">Lifetimes</a><ul><li><span data-type="index-term">data structures protected by</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1276">Deadlocks</a></li><li><span data-type="index-term">providing interior mutability in multithreaded environment</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1271">Standard marker traits</a></li></ul></li><li><span data-type="index-term">MutexGuard type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id627">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id765">Clone</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id916">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1247">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1294">Advice</a></li></ul></div><div data-type="indexdiv"><h3>N</h3><ul><li><span data-type="index-term">name clashes</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1488">Item 23: Avoid wildcard imports</a><ul><li><span data-type="index-term">crates and features</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1584">Features</a></li></ul></li><li><span data-type="index-term">name mangling</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2068">Name mangling</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2120">Invoking Rust from C</a></li><li><span data-type="index-term">named_mut method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1137">Data structure design</a></li><li><span data-type="index-term">NaN (not a number) values</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id791">PartialEq and Eq</a></li><li><span data-type="index-term">Neg trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id838">Operator Overloads</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id856">Summary</a></li><li><span data-type="index-term">nested errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id419">Nested Errors</a></li><li><span data-type="index-term">newtype pattern</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_newtyp">Item 6: Embrace the newtype pattern</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id521">Newtype Limitations</a><ul><li><span data-type="index-term">function operating on it</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id468">User-Defined Type Conversions</a></li><li><span data-type="index-term">limitations of</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id517">Newtype Limitations</a></li><li><span data-type="index-term">making Boolean argument clear with</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id507">Item 6: Embrace the newtype pattern</a></li><li><span data-type="index-term">orphan rule and</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id511">Bypassing the Orphan Rule for Traits</a></li></ul></li><li><span data-type="index-term">next method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id991">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">nm tool</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2072">Name mangling</a></li><li><span data-type="index-term">--no-default-features flag (build command)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1577">Features</a></li><li><span data-type="index-term">non-lexical lifetimes</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1029">Scope of a Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1103">Borrow Rules</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1122">Owner Operations</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1130">Local code refactoring</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1178">Things to Remember</a></li><li><span data-type="index-term">None variant of Option</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id374">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id523">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id677">Iterator Transforms</a></li><li><span data-type="index-term">nonstandard Rust environments</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1948">Beyond Standard Rust</a></li><li><span data-type="index-term">non_exhaustive attribute</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1432">Semver for Crate Authors</a></li><li><span data-type="index-term">Not trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id857">Summary</a></li><li><span data-type="index-term">no_deadlocks crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1296">Advice</a></li><li><span data-type="index-term">no_global_oom_handling config flag</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2039">Fallible Allocation</a></li><li><span data-type="index-term">no_mangle attribute</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2051">Invoking C Functions from Rust</a></li><li><span data-type="index-term">no_panic crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1332">Item 18: Don’t panic</a></li><li><span data-type="index-term">no_std attribute</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id406">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1197">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1396">Who’s Afraid of the Big Bad Copy?</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1606">What to Depend On</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1600">Features</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1966">Item 33: Consider making library code 
no_std compatible</a><ul><li><span data-type="index-term">binary, difficulty of creating</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1967">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">core library in no_std environments</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1974">core</a></li><li><span data-type="index-term">opting in to alloc use</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1988">alloc</a></li><li><span data-type="index-term">writing code for no_std environment</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2001">Writing Code for no_std</a></li></ul></li><li><span data-type="index-term">nth element of iterator</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id700">Iterator Consumers</a></li></ul></div><div data-type="indexdiv"><h3>O</h3><ul><li><span data-type="index-term">object safety</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id371">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id967">Trait Object Safety</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1434">Semver for Crate Authors</a></li><li><span data-type="index-term">object-oriented programming</span><ul><li><span data-type="index-term">rendering a list of shapes</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id980">Trade-Offs</a></li></ul></li><li><span data-type="index-term">Ok variant of Result</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id679">Iterator Transforms</a></li><li><span data-type="index-term">once_cell crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1209">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">one definition rule</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1520">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">open source</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1410">Dependencies</a></li><li><span data-type="index-term">operating systems</span><ul><li><span data-type="index-term">resources</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id909">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">synchronization primitives</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1999">alloc</a></li><li><span data-type="index-term">systems not having full OS</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1951">Beyond Standard Rust</a></li><li><span data-type="index-term">target_os config value</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1563">Conditional Compilation</a></li></ul></li><li><span data-type="index-term">operator overloads</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id835">Operator Overloads</a></li><li><span data-type="index-term">optimization</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1110">Borrow Rules</a><ul><li><span data-type="index-term">avoiding over-optimization</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_optiover">Item 20: Avoid the temptation to over-optimize</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1403">References and Smart Pointers</a></li><li><span data-type="index-term">compiler optimizations giving misleading results</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1856">Benchmarks</a></li></ul></li><li><span data-type="index-term">Option type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id283">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id299">Option&lt;T&gt;</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id676">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1971">core</a><ul><li><span data-type="index-term">modifying, move restriction and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1092">Access Control</a></li><li><span data-type="index-term">preferring Option and Result transforms over explicit match expressions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_Opttrns">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id398">Things to Remember</a></li><li><span data-type="index-term">replace method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1098">Access Control</a></li></ul></li><li><span data-type="index-term">Option::None variant</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id373">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">Ord trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id690">Iterator Consumers</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id798">PartialOrd and Ord</a></li></ul></li><li><span data-type="index-term">orphan rule</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id412">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id427">Nested Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id527">Item 7: Use builders for complex types</a><ul><li><span data-type="index-term">bypassing for traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id509">Bypassing the Orphan Rule for Traits</a></li></ul></li><li><span data-type="index-term">OSS-Fuzz program</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1876">Fuzz Testing</a></li><li><span data-type="index-term">owner links in tree-like data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1153">Smart pointers</a></li><li><span data-type="index-term">owner of Rust items</span><ul><li><span data-type="index-term">accessing item contents through</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1086">Access Control</a></li><li><span data-type="index-term">operations performed by</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1114">Owner Operations</a></li></ul></li><li><span data-type="index-term">ownership</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id609">Smart Pointer Types</a><ul><li><span data-type="index-term">data structures owning all data they use</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1134">Data structure design</a></li><li><span data-type="index-term">of items on the heap</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1054">Lifetimes and the Heap</a></li><li><span data-type="index-term">shifting from single-owner to shared-owner model</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1400">References and Smart Pointers</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>P</h3><ul><li><span data-type="index-term">package manager for Rust</span> (<span data-gentext="see">see</span> Cargo)</li><li><span data-type="index-term">panic! macro</span><ul><li><span data-type="index-term">code path triggering, resulting in DoS attack</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1870">Fuzz Testing</a></li><li><span data-type="index-term">entrypoints triggering</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1322">Item 18: Don’t panic</a></li><li><span data-type="index-term">sensible uses of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1321">Item 18: Don’t panic</a></li></ul></li><li><span data-type="index-term">panics</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id621">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1151">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_panic">Item 18: Don’t panic</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1334">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1648">What Not to Document</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2022">Fallible Allocation</a><ul><li><span data-type="index-term">alternative to for dealing with error conditions</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1315">Item 18: Don’t panic</a></li><li><span data-type="index-term">avoiding</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1326">Item 18: Don’t panic</a></li><li><span data-type="index-term">Clippy checks for use of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1805">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">default behavior and alternatives to</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1302">Item 18: Don’t panic</a></li><li><span data-type="index-term">documenting</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1621">Item 27: Document public interfaces</a></li><li><span data-type="index-term">on failure</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id378">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">function that panics on invalid input</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1827">Unit Tests</a></li><li><span data-type="index-term">preventing from crossing FFI boundary</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2139">Invoking Rust from C</a></li><li><span data-type="index-term">signaling failing test</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1824">Unit Tests</a></li></ul></li><li><span data-type="index-term">parameters (function), limiting</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1793">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">parking_lot::deadlock</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1297">Advice</a></li><li><span data-type="index-term">parse_macro_input! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1739">Derive macros</a></li><li><span data-type="index-term">PartialEq trait</span><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id788">PartialEq and Eq</a></li><li><span data-type="index-term">required by PartialOrd</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id799">PartialOrd and Ord</a></li></ul></li><li><span data-type="index-term">PartialOrd trait</span><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id797">PartialOrd and Ord</a></li><li><span data-type="index-term">unexpected results from</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id804">PartialOrd and Ord</a></li></ul></li><li><span data-type="index-term">partition method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id714">Iterator Consumers</a></li><li><span data-type="index-term">patch version</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1422">Semver Essentials</a></li><li><span data-type="index-term">performance</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1784">Item 29: Listen to Clippy</a><ul><li><span data-type="index-term">benchmarks of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1853">Benchmarks</a></li></ul></li><li><span data-type="index-term">Pin type</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1170">Self-referential data structures</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1199">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">Pointer trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id593">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id884">Summary</a></li><li><span data-type="index-term">pointer traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id563">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id591">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1159">Smart pointers</a></li><li><span data-type="index-term">pointers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id545">Item 8: Familiarize yourself with reference 
and pointer types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1077">Item 15: Understand the borrow checker</a><ul><li><span data-type="index-term">in C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2093">Lifetimes</a></li><li><span data-type="index-term">coercion of pointer types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id488">Coercion</a></li><li><span data-type="index-term">passed back from Rust to C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2133">Invoking Rust from C</a></li><li><span data-type="index-term">raw</span> (<span data-gentext="see">see</span> raw pointers)</li><li><span data-type="index-term">in Rust and C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2124">Invoking Rust from C</a></li><li><span data-type="index-term">smart pointer types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id605">Smart Pointer Types</a></li><li><span data-type="index-term">unnecessary pointer indirections</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1800">Item 29: Listen to Clippy</a></li></ul></li><li><span data-type="index-term">poisoning (locks)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1250">Data races in Rust</a></li><li><span data-type="index-term">polymorphic type</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1343">Item 19: Avoid reflection</a></li><li><span data-type="index-term">position method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id699">Iterator Consumers</a></li><li><span data-type="index-term">preconditions</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1646">What Not to Document</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1829">Unit Tests</a></li><li><span data-type="index-term">prelude</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1494">Item 23: Avoid wildcard imports</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1958">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">principle of least astonishment</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1650">What Not to Document</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1690">Declarative Macros</a></li><li><span data-type="index-term">printf (C)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1706">Declarative Macros</a></li><li><span data-type="index-term">println! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1681">Declarative Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1704">Declarative Macros</a></li><li><span data-type="index-term">private</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1455">Visibility Syntax</a><ul><li><span data-type="index-term">preferring private code</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1473">Visibility Semantics</a></li></ul></li><li><span data-type="index-term">proc macros</span> (<span data-gentext="see">see</span> procedural macros)</li><li><span data-type="index-term">proc-macro crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1721">Procedural Macros</a></li><li><span data-type="index-term">proc-macro2 crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1722">Procedural Macros</a></li><li><span data-type="index-term">procedural macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1670">Item 28: Use macros judiciously</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_procmac">Procedural Macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1748">Derive macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1773">Advice</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1923">Item 31: Take advantage of the tooling ecosystem</a><ul><li><span data-type="index-term">attribute macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1731">Attribute macros</a></li><li><span data-type="index-term">derive macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_procmacder">Derive macros</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1745">Derive macros</a></li><li><span data-type="index-term">function-like macros</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1726">Function-like macros</a></li><li><span data-type="index-term">types of</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1724">Procedural Macros</a></li></ul></li><li><span data-type="index-term">product method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id687">Iterator Consumers</a></li><li><span data-type="index-term">programming in the future tense</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1653">What Not to Document</a></li><li><span data-type="index-term">Programming Rust (Blandy et al.)</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id216">Who This Book Is For</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id715">Iterator Consumers</a></li><li><span data-type="index-term">pub</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1459">Visibility Syntax</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1462">Visibility Syntax</a><ul><li><span data-type="index-term">pub(crate)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1464">Visibility Syntax</a></li><li><span data-type="index-term">pub(in crate)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1469">Visibility Syntax</a></li><li><span data-type="index-term">pub(in path)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1468">Visibility Syntax</a></li><li><span data-type="index-term">pub(self)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1471">Visibility Syntax</a></li><li><span data-type="index-term">pub(super)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1466">Visibility Syntax</a></li></ul></li><li><span data-type="index-term">public fields in structures, avoiding feature-gating</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1594">Features</a></li><li><span data-type="index-term">push method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2036">Fallible Allocation</a></li><li><span data-type="index-term">Python</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1337">Item 19: Avoid reflection</a></li></ul></div><div data-type="indexdiv"><h3>R</h3><ul><li><span data-type="index-term">RAII (Resource Acquisition Is Initialization) pattern</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.ix_RAII">Item 11: Implement the Drop trait for RAII patterns</a>-<a data-type="index:locator" href="#OEBPS/ch02.html.id925">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1246">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2110">Lifetimes</a><ul><li><span data-type="index-term">wrapper that prevents C memory leaks</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2109">Lifetimes</a></li></ul></li><li><span data-type="index-term">rand crate</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1210">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1500">Item 24: Re-export dependencies whose types 
appear in your API</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1580">Features</a></li><li><span data-type="index-term">random number generation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1995">alloc</a></li><li><span data-type="index-term">range expression</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id580">Slices</a></li><li><span data-type="index-term">Range type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id581">Slices</a></li><li><span data-type="index-term">raw identifier prefix (r#)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1405">Data Structures and Allocation</a></li><li><span data-type="index-term">raw memory</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id913">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">raw pointers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id546">Item 8: Familiarize yourself with reference 
and pointer types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1184">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1272">Standard marker traits</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2095">Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2128">Invoking Rust from C</a></li><li><span data-type="index-term">Rc type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id606">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id629">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1140">Data structure design</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1145">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1154">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1401">References and Smart Pointers</a><ul><li><span data-type="index-term">not implementing Send</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1266">Standard marker traits</a></li></ul></li><li><span data-type="index-term">re-export</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_reex">Item 24: Re-export dependencies whose types 
appear in your API</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1505">Item 24: Re-export dependencies whose types 
appear in your API</a></li><li><span data-type="index-term">readability</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1785">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">Receiver</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1288">Advice</a></li><li><span data-type="index-term">reduce method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id694">Iterator Consumers</a></li><li><span data-type="index-term">Ref type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id616">Smart Pointer Types</a></li><li><span data-type="index-term">RefCell type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id617">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1141">Data structure design</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1146">Smart pointers</a><ul><li><span data-type="index-term">not implementing Sync</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1269">Standard marker traits</a></li></ul></li><li><span data-type="index-term">reference-counted pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1258">Data races in Rust</a></li><li><span data-type="index-term">references</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id344">Closures</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id393">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_refr">Item 8: Familiarize yourself with reference 
and pointer types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id574">Fat Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1380">Data Structures and Allocation</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2094">Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2125">Invoking Rust from C</a><ul><li><span data-type="index-term">borrowing, rules for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1099">Borrow Rules</a></li><li><span data-type="index-term">coercions of reference types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id487">Coercion</a></li><li><span data-type="index-term">creation and use of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1078">Item 15: Understand the borrow checker</a></li><li><span data-type="index-term">lifetime scope and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1020">Scope of a Lifetime</a></li><li><span data-type="index-term">lifetimes of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1028">Scope of a Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1074">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1085">Item 15: Understand the borrow checker</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2096">Lifetimes</a></li><li><span data-type="index-term">macro expansions that insert, avoiding</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1770">Advice</a></li><li><span data-type="index-term">mutable</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id336">Closures</a></li><li><span data-type="index-term">prevention of references to expired stack objects</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2131">Invoking Rust from C</a></li><li><span data-type="index-term">and smart pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1398">References and Smart Pointers</a></li><li><span data-type="index-term">stored in data structures, lifetimes of</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1058">Lifetimes in Data Structures</a></li></ul></li><li><span data-type="index-term">reflection</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_reflct">Item 19: Avoid reflection</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1379">Upcasting in Future Versions of Rust</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1719">Procedural Macros</a><ul><li><span data-type="index-term">languages with full reflection support</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1335">Item 19: Avoid reflection</a></li><li><span data-type="index-term">reflection-like features in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1346">Item 19: Avoid reflection</a></li><li><span data-type="index-term">upcasting in future Rust versions</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1374">Upcasting in Future Versions of Rust</a></li></ul></li><li><span data-type="index-term">reflexive implementation of From</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id467">User-Defined Type Conversions</a></li><li><span data-type="index-term">reflexivity</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id789">PartialEq and Eq</a></li><li><span data-type="index-term">registry of crates</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1605">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">release method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id923">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">Rem trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id842">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id858">Summary</a></li><li><span data-type="index-term">RemAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id859">Summary</a></li><li><span data-type="index-term">render method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id953">More Trait Bounds</a></li><li><span data-type="index-term">replace function</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1096">Access Control</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1206">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">repr(C)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2080">Accessing C Data from Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2123">Invoking Rust from C</a></li><li><span data-type="index-term">repr(transparent)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id508">Item 6: Embrace the newtype pattern</a></li><li><span data-type="index-term">Resource Acquisition Is Initialization</span> (<span data-gentext="see">see</span> RAII pattern)</li><li><span data-type="index-term">Result type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id303">Result&lt;T, E&gt;</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id678">Iterator Transforms</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id741">When Explicit Is Better</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1973">core</a><ul><li><span data-type="index-term">avoiding unwrap calls for</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1850">Examples</a></li><li><span data-type="index-term">building collections from values</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id722">Building Collections from Result Values</a></li><li><span data-type="index-term">error types as second type argument of</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id400">Item 4: Prefer idiomatic Error types</a></li><li><span data-type="index-term">holding MutexGuard</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1249">Data races in Rust</a></li><li><span data-type="index-term">macro emitting</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1693">Declarative Macros</a></li><li><span data-type="index-term">manipulations of, Clippy pointing out redundancies</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1795">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">preferring to Option for expressing errors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id384">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">returned by release method</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id924">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">returned in type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id449">User-Defined Type Conversions</a></li><li><span data-type="index-term">returning with proper error type instead of panic!</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1316">Item 18: Don’t panic</a></li><li><span data-type="index-term">values from try_borrow</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id618">Smart Pointer Types</a></li></ul></li><li><span data-type="index-term">Result::Err variant</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id375">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">return statements</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1688">Declarative Macros</a></li><li><span data-type="index-term">rewrite it in Rust (RiiR)</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2041">Item 34: Control what crosses FFI boundaries</a>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2165">Afterword</a></li><li><span data-type="index-term">RTTI (run-time type identification)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1341">Item 19: Avoid reflection</a></li><li><span data-type="index-term">Rust Atomics and Locks (Bos)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1196">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1571">Conditional Compilation</a></li><li><span data-type="index-term">Rust for Rustaceans (Gjengset)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1168">Self-referential data structures</a>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2166">Afterword</a></li><li><span data-type="index-term">Rust Fuzz Book</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1874">Fuzz Testing</a></li><li><span data-type="index-term">Rust playground</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1903">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">The Rust Programming Language (Klabnik and Nichols)</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id215">Who This Book Is For</a></li><li><span data-type="index-term">rustc</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id222">Rust Version</a></li><li><span data-type="index-term">RustCrypto crates</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1497">Item 24: Re-export dependencies whose types 
appear in your API</a></li><li><span data-type="index-term">rustfilt</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2157">Invoking Rust from C</a></li><li><span data-type="index-term">rustfmt, inapplicability to macro invocations</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1764">Disadvantages of Macros</a></li><li><span data-type="index-term">Rustonomicon</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1956">Beyond Standard Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2047">Item 34: Control what crosses FFI boundaries</a></li><li><span data-type="index-term">rustup</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1901">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">RwLock type</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1149">Smart pointers</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1193">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1270">Standard marker traits</a></li></ul></div><div data-type="indexdiv"><h3>S</h3><ul><li><span data-type="index-term">safety</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id210">Preface</a></li><li><span data-type="index-term">scan method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id696">Iterator Consumers</a></li><li><span data-type="index-term">scope</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_scp">Scope of a Lifetime</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1030">Algebra of Lifetimes</a><ul><li><span data-type="index-term">locks, keeping small and obvious</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1291">Advice</a></li><li><span data-type="index-term">reducing for locks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1279">Deadlocks</a></li><li><span data-type="index-term">reference scope smaller than lifetime of item referred to</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1102">Borrow Rules</a></li><li><span data-type="index-term">rules for declarative macro use</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1672">Declarative Macros</a></li></ul></li><li><span data-type="index-term">segments (stack)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1009">Introduction to the Stack</a></li><li><span data-type="index-term">self keyword</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id322">Functions and Methods</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id349">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1039">Lifetime Elision Rules</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1252">Data races in Rust</a></li><li><span data-type="index-term">Self type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id369">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id530">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id535">Item 7: Use builders for complex types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id650">Iterator Traits</a><ul><li><span data-type="index-term">object safety of types with sizes known at compile time</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id975">Trait Object Safety</a></li><li><span data-type="index-term">trait object safety and</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id968">Trait Object Safety</a></li></ul></li><li><span data-type="index-term">self-referential data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_selfDS">Self-referential data structures</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1174">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1200">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">semantic versioning</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_semver">Item 21: Understand what semantic versioning promises</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1452">Discussion</a><ul><li><span data-type="index-term">Cargo and</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1522">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">for crate authors</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1425">Semver for Crate Authors</a></li><li><span data-type="index-term">for crate users</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1444">Semver for Crate Users</a></li><li><span data-type="index-term">essentials of</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1420">Semver Essentials</a></li><li><span data-type="index-term">multiple semver-incompatible versions of a crate in the build</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1514">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">ranges of acceptable versions</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1418">Item 21: Understand what semantic versioning promises</a></li><li><span data-type="index-term">understanding its concepts and limitations</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1450">Discussion</a></li><li><span data-type="index-term">updating</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1846">Examples</a></li><li><span data-type="index-term">version specification for dependencies</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1532">Version Specification</a></li></ul></li><li><span data-type="index-term">semi-automatic type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id438">Item 5: Understand type conversions</a></li><li><span data-type="index-term">Send trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id830">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id891">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1262">Standard marker traits</a></li><li><span data-type="index-term">Sender/Receiver pair</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1287">Advice</a></li><li><span data-type="index-term">separate compilation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2069">Name mangling</a></li><li><span data-type="index-term">serde crate</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id515">Bypassing the Orphan Rule for Traits</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1737">Derive macros</a></li><li><span data-type="index-term">sets</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1984">core</a></li><li><span data-type="index-term">Shape trait</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1362">Item 19: Avoid reflection</a><ul><li><span data-type="index-term">methods accepting, Draw and</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id963">More Trait Bounds</a></li><li><span data-type="index-term">requirement for Draw implementation</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id952">More Trait Bounds</a></li><li><span data-type="index-term">vtable for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id958">More Trait Bounds</a></li></ul></li><li><span data-type="index-term">shapes, rendering in OO example</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id982">Trade-Offs</a></li><li><span data-type="index-term">shared-state parallelism</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id628">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id915">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_SSpar">Item 17: Be wary of shared-state parallelism</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1300">Advice</a><ul><li><span data-type="index-term">advice for avoiding problems with</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1285">Advice</a></li><li><span data-type="index-term">data races</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_SSpardarc">Data Races</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1273">Deadlocks</a></li><li><span data-type="index-term">deadlocks</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_SSpardead">Deadlocks</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1283">Advice</a></li></ul></li><li><span data-type="index-term">shared_pointer (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id607">Smart Pointer Types</a></li><li><span data-type="index-term">Shl trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id844">Summary</a></li><li><span data-type="index-term">ShlAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id860">Summary</a></li><li><span data-type="index-term">should_panic attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1826">Unit Tests</a></li><li><span data-type="index-term">Shr trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id861">Summary</a></li><li><span data-type="index-term">ShrAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id862">Summary</a></li><li><span data-type="index-term">Sized trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id890">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id974">Trait Object Safety</a></li><li><span data-type="index-term">skip method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id660">Iterator Transforms</a></li><li><span data-type="index-term">skip_while method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id673">Iterator Transforms</a></li><li><span data-type="index-term">sleep</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1228">Data races in C++</a></li><li><span data-type="index-term">SliceIndex type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id585">Slices</a></li><li><span data-type="index-term">slices</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id576">Slices</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1330">Item 18: Don’t panic</a><ul><li><span data-type="index-term">bounds checking</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id717">Iterator Consumers</a></li><li><span data-type="index-term">slice types in structures, lifetime parameter for</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1064">Lifetimes in Data Structures</a></li></ul></li><li><span data-type="index-term">smart pointer types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id604">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1067">Lifetimes in Data Structures</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_smptr">Smart pointers</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1175">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1399">References and Smart Pointers</a><ul><li><span data-type="index-term">behaving like references</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id568">Pointer Traits</a></li><li><span data-type="index-term">blanket trait implementations for</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id462">User-Defined Type Conversions</a></li><li><span data-type="index-term">use of unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1191">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">user-defined types acting as</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id496">Coercion</a></li></ul></li><li><span data-type="index-term">Some variant of Option</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id680">Iterator Transforms</a></li><li><span data-type="index-term">sorting, using marker trait in</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id353">Traits</a></li><li><span data-type="index-term">spin crate</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2000">alloc</a></li><li><span data-type="index-term">Square object</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1359">Item 19: Avoid reflection</a></li><li><span data-type="index-term">square! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1697">Declarative Macros</a></li><li><span data-type="index-term">square_once! macro</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1699">Declarative Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1763">Disadvantages of Macros</a></li><li><span data-type="index-term">stack</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id557">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id560">Rust References</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id590">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1953">Beyond Standard Rust</a><ul><li><span data-type="index-term">introduction to</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1008">Introduction to the Stack</a></li><li><span data-type="index-term">prevention of references to expired stack objects</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2130">Invoking Rust from C</a></li></ul></li><li><span data-type="index-term">stack pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1012">Introduction to the Stack</a></li><li><span data-type="index-term">state inconsistency sequence</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1281">Deadlocks</a></li><li><span data-type="index-term">static library file</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2053">Linking logistics</a></li><li><span data-type="index-term">static lifetime</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1032">Algebra of Lifetimes</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1042">The 'static Lifetime</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1075">Things to Remember</a></li><li><span data-type="index-term">static typing</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id237">Fundamental Types</a></li><li><span data-type="index-term">static, global variable marked as</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1057">Lifetimes and the Heap</a></li><li><span data-type="index-term">statically typed languages</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id223">Rust Version</a><ul><li><span data-type="index-term">supporting reflection</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1340">Item 19: Avoid reflection</a></li></ul></li><li><span data-type="index-term">std library</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id407">The Error Trait</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1189">Item 16: Avoid writing unsafe code</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1601">Features</a><ul><li><span data-type="index-term">code for environments where full std not provided</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1961">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">core library types equivalent to</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1976">core</a></li><li><span data-type="index-term">inability to cope with failed allocation</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2029">Fallible Allocation</a></li><li><span data-type="index-term">no_std crate depending on std-using dependency</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2010">Writing Code for no_std</a></li><li><span data-type="index-term">replacing std types with identical core and alloc crates</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2008">Writing Code for no_std</a></li><li><span data-type="index-term">wide variety of common tasks covered in</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1957">Item 33: Consider making library code 
no_std compatible</a></li></ul></li><li><span data-type="index-term">std::any::type_name</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1349">Item 19: Avoid reflection</a></li><li><span data-type="index-term">std::any:tname</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1347">Item 19: Avoid reflection</a></li><li><span data-type="index-term">std::fmt</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1710">Declarative Macros</a></li><li><span data-type="index-term">std::mem functions</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1207">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">std::os::raw::c_int, size of</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2064">Code concerns</a></li><li><span data-type="index-term">String type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id411">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id572">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2083">Accessing C Data from Rust</a><ul><li><span data-type="index-term">absence of a value</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id301">Option&lt;T&gt;</a></li></ul></li><li><span data-type="index-term">String::from_utf8</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1324">Item 18: Don’t panic</a></li><li><span data-type="index-term">String::from_utf8_unchecked</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1325">Item 18: Don’t panic</a></li><li><span data-type="index-term">strings</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1065">Lifetimes in Data Structures</a><ul><li><span data-type="index-term">library function returning first line of file as string</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id421">Nested Errors</a></li><li><span data-type="index-term">in Rust and C</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2082">Accessing C Data from Rust</a></li></ul></li><li><span data-type="index-term">struct types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id289">Aggregate Types</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1734">Derive macros</a><ul><li><span data-type="index-term">in C and Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2079">Accessing C Data from Rust</a></li><li><span data-type="index-term">contents made public, avoiding making fields feature-dependent</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1590">Features</a></li><li><span data-type="index-term">derive macro use</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1743">Derive macros</a></li><li><span data-type="index-term">encapsulating interaction with C library in wrapper struct</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2112">Lifetimes</a></li><li><span data-type="index-term">field-by-field comparison for Eq</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id759">Item 10: Familiarize yourself with standard traits</a></li><li><span data-type="index-term">methods added to</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id323">Functions and Methods</a></li><li><span data-type="index-term">private fields in</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1475">Visibility Semantics</a></li><li><span data-type="index-term">traits versus, for flexible code</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id351">Traits</a></li><li><span data-type="index-term">using builder pattern with complex structs</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_strctbldr">Item 7: Use builders for complex types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id542">Item 7: Use builders for complex types</a></li></ul></li><li><span data-type="index-term">struct update syntax</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id781">Default</a></li><li><span data-type="index-term">structs</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1433">Semver for Crate Authors</a></li><li><span data-type="index-term">Sub trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id839">Operator Overloads</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id863">Summary</a></li><li><span data-type="index-term">SubAssign trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id864">Summary</a></li><li><span data-type="index-term">subtyping</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id492">Coercion</a></li><li><span data-type="index-term">suggestions for future learning</span>, <a data-type="index:locator" href="#OEBPS/afterword01.html.id2158">Afterword</a></li><li><span data-type="index-term">sum method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id686">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id737">Loop Transformation</a></li><li><span data-type="index-term">supply chain attacks</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1547">What to Depend On</a></li><li><span data-type="index-term">swap function</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1205">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">syn crate</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1728">Function-like macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1738">Derive macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1922">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">Sync trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id831">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id865">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id892">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1263">Standard marker traits</a></li><li><span data-type="index-term">synchronization primitives</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1244">Data races in Rust</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1997">alloc</a><ul><li><span data-type="index-term">keeping two data structures in sync</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1282">Deadlocks</a></li><li><span data-type="index-term">use of unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1194">Item 16: Avoid writing unsafe code</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>T</h3><ul><li><span data-type="index-term">T (target type) in generics, monomorphization into particular type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id360">Trait bounds</a></li><li><span data-type="index-term">take function</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1204">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">take method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id735">Loop Transformation</a></li><li><span data-type="index-term">take_while method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id672">Iterator Transforms</a></li><li><span data-type="index-term">target_arch config option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1564">Conditional Compilation</a></li><li><span data-type="index-term">target_endian config option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1567">Conditional Compilation</a></li><li><span data-type="index-term">target_has_atomic config option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1568">Conditional Compilation</a></li><li><span data-type="index-term">target_os config option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1565">Conditional Compilation</a></li><li><span data-type="index-term">target_pointer_width config option</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1566">Conditional Compilation</a></li><li><span data-type="index-term">templates (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id930">Generics</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1312">Item 18: Don’t panic</a></li><li><span data-type="index-term">test attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1816">Unit Tests</a></li><li><span data-type="index-term">test modules</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1492">Item 23: Avoid wildcard imports</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1820">Unit Tests</a></li><li><span data-type="index-term">tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1634">Additional Documentation Locations</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_test">Item 30: Write more than unit tests</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1894">Things to Remember</a><ul><li><span data-type="index-term">benchmarks</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1852">Benchmarks</a></li><li><span data-type="index-term">doc tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1839">Doc Tests</a></li><li><span data-type="index-term">of examples</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1842">Examples</a></li><li><span data-type="index-term">fuzz tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1860">Fuzz Testing</a></li><li><span data-type="index-term">integration tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1836">Integration Tests</a></li><li><span data-type="index-term">testing advice</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1879">Testing Advice</a></li><li><span data-type="index-term">testing tools</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1939">Tools to Remember</a></li><li><span data-type="index-term">unit tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_testunit">Unit Tests</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1833">Unit Tests</a></li></ul></li><li><span data-type="index-term">text section</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2073">Name mangling</a></li><li><span data-type="index-term">@thingskatedid</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id235">Item 1: Use the type system to express 
your data structures</a></li><li><span data-type="index-term">thread safety in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1243">Data races in Rust</a></li><li><span data-type="index-term">thread-compatible</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1229">Data races in C++</a></li><li><span data-type="index-term">thread-hostile</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1404">Data races in C++</a></li><li><span data-type="index-term">thread-safe</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1230">Data races in C++</a></li><li><span data-type="index-term">threading</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id624">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id829">Standard Traits Covered Elsewhere</a><ul><li><span data-type="index-term">Send/Sync marker traits and</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1264">Standard marker traits</a></li></ul></li><li><span data-type="index-term">threads</span><ul><li><span data-type="index-term">deadlock sequence</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1277">Deadlocks</a></li><li><span data-type="index-term">sharing state between</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1225">Item 17: Be wary of shared-state parallelism</a></li></ul></li><li><span data-type="index-term">ThreadSanitizer</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1298">Advice</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1867">Fuzz Testing</a></li><li><span data-type="index-term">TLV (type-length-value) structure</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_TLV">Data Structures and Allocation</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1387">Data Structures and Allocation</a></li><li><span data-type="index-term">tokens</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1740">Derive macros</a></li><li><span data-type="index-term">TokenTree::Punct tokens</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1727">Function-like macros</a></li><li><span data-type="index-term">Tolnay, David</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id431">Trait Objects</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1723">Procedural Macros</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1729">Function-like macros</a></li><li><span data-type="index-term">tooling</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1766">Disadvantages of Macros</a><ul><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1608">Tooling</a></li></ul></li><li><span data-type="index-term">tooling ecosystem</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_tooleco">Item 31: Take advantage of the tooling ecosystem</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1944">Tools to Remember</a><ul><li><span data-type="index-term">Cargo toolchain</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1905">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">development environment tools</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1897">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">tools to remember</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1932">Tools to Remember</a></li></ul></li><li><span data-type="index-term">ToOwned trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id600">More Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id879">Summary</a></li><li><span data-type="index-term">trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id356">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id926">Item 12: Understand the trade-offs between 
generics and trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id935">Generics</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1363">Item 19: Avoid reflection</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1666">Item 28: Use macros judiciously</a><ul><li><span data-type="index-term">for Error types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id402">The Error Trait</a></li><li><span data-type="index-term">more uses for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id951">More Trait Bounds</a></li><li><span data-type="index-term">trait methods imposing</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id993">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">use with generics</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id364">Trait bounds</a></li><li><span data-type="index-term">using Into trait for in type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id455">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">trait coherence rules</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id451">User-Defined Type Conversions</a></li><li><span data-type="index-term">trait methods with default implementations</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id990">Item 13: Use default implementations 
to minimize required trait methods</a></li><li><span data-type="index-term">trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id357">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id367">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id587">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id927">Item 12: Understand the trade-offs between 
generics and trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id939">Trait Objects</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1348">Item 19: Avoid reflection</a><ul><li><span data-type="index-term">different compile time and runtime types</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1358">Item 19: Avoid reflection</a></li><li><span data-type="index-term">encoding implementation vtable for only single trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id948">Basic Comparisons</a></li><li><span data-type="index-term">generics versus</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id945">Basic Comparisons</a></li><li><span data-type="index-term">no conversions between related trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id961">More Trait Bounds</a></li><li><span data-type="index-term">safety</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id966">Trait Object Safety</a></li><li><span data-type="index-term">trade-offs between generics and</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id977">Trade-Offs</a></li><li><span data-type="index-term">for traits having trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id957">More Trait Bounds</a></li><li><span data-type="index-term">upcasting in Rust version 1.76</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1376">Upcasting in Future Versions of Rust</a></li></ul></li><li><span data-type="index-term">traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id234">Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id313">Item 2: Use the type system to express common behavior</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1365">Item 19: Avoid reflection</a><ul><li><span data-type="index-term">attempting to implement foreign trait for foreign type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id512">Bypassing the Orphan Rule for Traits</a></li><li><span data-type="index-term">auto-generated implementations from derive macros</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id760">Item 10: Familiarize yourself with standard traits</a></li><li><span data-type="index-term">breaking changes in</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1435">Semver for Crate Authors</a></li><li><span data-type="index-term">bypassing orphan rule for</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id510">Bypassing the Orphan Rule for Traits</a></li><li><span data-type="index-term">coercion of concrete item into trait object</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id490">Coercion</a></li><li><span data-type="index-term">common standard traits</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.ix_traitCS">Common Standard Traits</a>-<a data-type="index:locator" href="#OEBPS/ch02.html.id816">Debug and Display</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id840">Summary</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id346">Traits</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id752">Traits</a></li><li><span data-type="index-term">example for displaying graphical objects</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id928">Item 12: Understand the trade-offs between 
generics and trait objects</a></li><li><span data-type="index-term">Fn, FnOnce, and FnMut</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id338">Closures</a></li><li><span data-type="index-term">iterator</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id644">Iterator Traits</a></li><li><span data-type="index-term">less common standard traits</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id817">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id866">Summary</a></li><li><span data-type="index-term">making public</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1461">Visibility Syntax</a></li><li><span data-type="index-term">marker</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id355">Traits</a></li><li><span data-type="index-term">new upcasting feature</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1375">Upcasting in Future Versions of Rust</a></li><li><span data-type="index-term">newtype and traits implemented on inner type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id518">Newtype Limitations</a></li><li><span data-type="index-term">operator overload traits summary</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id841">Summary</a></li><li><span data-type="index-term">pointer</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id562">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id592">More Pointer Traits</a></li><li><span data-type="index-term">public, with feature gate on a method</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1595">Features</a></li><li><span data-type="index-term">relating to operator overloads</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id834">Operator Overloads</a></li><li><span data-type="index-term">standard traits</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id754">Item 10: Familiarize yourself with standard traits</a><ul><li><span data-type="index-term">implementation checks by Clippy</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1804">Item 29: Listen to Clippy</a></li></ul></li><li><span data-type="index-term">used to display data in formats</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1946">Declarative Macros</a></li><li><span data-type="index-term">in user-defined type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id443">User-Defined Type Conversions</a></li><li><span data-type="index-term">using default implementations to minimize required trait methods</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id984">Item 13: Use default implementations 
to minimize required trait methods</a></li></ul></li><li><span data-type="index-term">transformations</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id641">Item 9: Consider using iterator transforms 
instead of explicit loops</a><ul><li>(<span data-gentext="see">see also</span> iterator transforms)</li><li><span data-type="index-term">Option and Result, methods for</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id391">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li></ul></li><li><span data-type="index-term">tree data structures</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1135">Data structure design</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1152">Smart pointers</a></li><li><span data-type="index-term">TryFrom trait</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id825">Standard Traits Covered Elsewhere</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id872">Summary</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1756">When to Use Macros</a><ul><li><span data-type="index-term">blanket implementation for any type implementing Into trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id463">User-Defined Type Conversions</a></li><li><span data-type="index-term">implementations for source not fitting destination type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id460">User-Defined Type Conversions</a></li><li><span data-type="index-term">implementations for standard library types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id458">User-Defined Type Conversions</a></li><li><span data-type="index-term">use in user-defined type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id445">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">TryInto trait</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id447">User-Defined Type Conversions</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id874">Summary</a></li><li><span data-type="index-term">try_.. methods</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id740">When Explicit Is Better</a></li><li><span data-type="index-term">try_borrow method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id619">Smart Pointer Types</a></li><li><span data-type="index-term">try_find method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id708">Iterator Consumers</a></li><li><span data-type="index-term">try_fold method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id706">Iterator Consumers</a></li><li><span data-type="index-term">try_for_each method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id704">Iterator Consumers</a></li><li><span data-type="index-term">try_new method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2035">Fallible Allocation</a></li><li><span data-type="index-term">try_reserve method</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2034">Fallible Allocation</a></li><li><span data-type="index-term">tuple struct</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id290">Aggregate Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id416">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id500">Item 6: Embrace the newtype pattern</a></li><li><span data-type="index-term">tuple type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id288">Aggregate Types</a></li><li><span data-type="index-term">turbofish</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id729">Building Collections from Result Values</a></li><li><span data-type="index-term">type aliases</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id414">Minimal Errors</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id503">Item 6: Embrace the newtype pattern</a></li><li><span data-type="index-term">type coercion</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id330">Function Pointers</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id486">Coercion</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id567">Pointer Traits</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1360">Item 19: Avoid reflection</a><ul><li><span data-type="index-term">implicit coercion</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id436">Item 5: Understand type conversions</a></li></ul></li><li><span data-type="index-term">type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typcnv">Item 5: Understand type conversions</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id497">Coercion</a><ul><li><span data-type="index-term">casts</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id473">Casts</a></li><li><span data-type="index-term">coercion</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id485">Coercion</a></li><li><span data-type="index-term">error attempting to convert larger integer type into smaller integer type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id260">Fundamental Types</a></li><li><span data-type="index-term">explicit coercion to fn type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id328">Function Pointers</a></li><li><span data-type="index-term">manual</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id435">Item 5: Understand type conversions</a></li><li><span data-type="index-term">user-defined</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id441">User-Defined Type Conversions</a></li></ul></li><li><span data-type="index-term">type erasure</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id979">Trade-Offs</a></li><li><span data-type="index-term">type safety</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id211">Preface</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2075">Name mangling</a><ul><li><span data-type="index-term">of function signatures</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2077">Name mangling</a></li></ul></li><li><span data-type="index-term">type system</span>, <a data-type="index:locator" href="#OEBPS/preface01.html.id209">Preface</a><ul><li><span data-type="index-term">encoding behavior into</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id231">Types</a></li><li><span data-type="index-term">not documenting things already expressed by</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1830">Unit Tests</a></li></ul></li><li><span data-type="index-term">type-length-value (TLV) structure</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_typeLV">Data Structures and Allocation</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1386">Data Structures and Allocation</a></li><li><span data-type="index-term">TypeId</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1350">Item 19: Avoid reflection</a></li><li><span data-type="index-term">typeid (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1344">Item 19: Avoid reflection</a></li><li><span data-type="index-term">types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typ">Item 1: Use the type system to express 
your data structures</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id306">Result&lt;T, E&gt;</a><ul><li><span data-type="index-term">aggregate</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id285">Aggregate Types</a></li><li><span data-type="index-term">closures</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id331">Closures</a></li><li><span data-type="index-term">core and std</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1975">core</a></li><li><span data-type="index-term">defined</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id228">Types</a></li><li><span data-type="index-term">expressing common behaviors</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id307">Item 2: Use the type system to express common behavior</a></li><li><span data-type="index-term">full type names required when not using std</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2005">Writing Code for no_std</a></li><li><span data-type="index-term">function pointers</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id326">Function Pointers</a></li><li><span data-type="index-term">functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id318">Functions and Methods</a></li><li><span data-type="index-term">fundamental</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typfnd">Fundamental Types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id284">Aggregate Types</a><ul><li><span data-type="index-term">bool</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id265">Fundamental Types</a></li><li><span data-type="index-term">char</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id275">Fundamental Types</a></li><li><span data-type="index-term">floating point types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id264">Fundamental Types</a></li><li><span data-type="index-term">integer types matching pointer size on target system</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id252">Fundamental Types</a></li><li><span data-type="index-term">integer types with specific sizes</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id239">Fundamental Types</a></li><li><span data-type="index-term">stricter conversions in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id258">Fundamental Types</a></li><li><span data-type="index-term">unit</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id266">Fundamental Types</a></li></ul></li><li><span data-type="index-term">idiomatic Error types, preferring</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typiderr">Item 4: Prefer idiomatic Error types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id433">Things to Remember</a></li><li><span data-type="index-term">including as much semantics as possible Rust type system</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1641">What Not to Document</a></li><li><span data-type="index-term">making common types available without using full names</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1960">Item 33: Consider making library code 
no_std compatible</a></li><li><span data-type="index-term">methods</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id320">Functions and Methods</a></li><li><span data-type="index-term">newtype pattern</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typnew">Item 6: Embrace the newtype pattern</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id520">Newtype Limitations</a></li><li><span data-type="index-term">preferring Option and Result transforms over explicit match expressions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typOptRes">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id399">Things to Remember</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id372">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a></li><li><span data-type="index-term">sized types at FFI boundaries</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2065">Code concerns</a></li><li><span data-type="index-term">traits</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id347">Traits</a><ul><li>(<span data-gentext="see">see also</span> trait bounds; trait objects; traits)</li><li><span data-type="index-term">trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id358">Trait bounds</a></li><li><span data-type="index-term">trait objects</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id366">Trait objects</a></li></ul></li><li><span data-type="index-term">using builders for complex types</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.ix_typbld">Item 7: Use builders for complex types</a>-<a data-type="index:locator" href="#OEBPS/ch01.html.id544">Item 7: Use builders for complex types</a></li><li><span data-type="index-term">visibility</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1456">Visibility Syntax</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>U</h3><ul><li><span data-type="index-term">u128 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id250">Fundamental Types</a></li><li><span data-type="index-term">u16 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id247">Fundamental Types</a></li><li><span data-type="index-term">u32 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id248">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id277">Fundamental Types</a><ul><li><span data-type="index-term">values not valid for Unicode code points</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id280">Fundamental Types</a></li></ul></li><li><span data-type="index-term">u64 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id249">Fundamental Types</a></li><li><span data-type="index-term">u8 type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id246">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id724">Building Collections from Result Values</a></li><li><span data-type="index-term">Unicode</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id274">Fundamental Types</a></li><li><span data-type="index-term">union</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1530">Item 25: Manage your dependency graph</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1586">Features</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1733">Derive macros</a></li><li><span data-type="index-term">unique_ptr (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id905">Item 11: Implement the Drop trait for RAII patterns</a></li><li><span data-type="index-term">unit tests</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.ix_unit">Unit Tests</a>-<a data-type="index:locator" href="#OEBPS/ch05.html.id1834">Unit Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1887">Things to Remember</a><ul><li><span data-type="index-term">common elements</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1815">Unit Tests</a></li><li><span data-type="index-term">optional elements</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1818">Unit Tests</a></li></ul></li><li><span data-type="index-term">unit type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id268">Fundamental Types</a></li><li><span data-type="index-term">unreachable! macro</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1327">Item 18: Don’t panic</a></li><li><span data-type="index-term">unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id1001">Item 11: Implement the Drop trait for RAII patterns</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1006">Concepts</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1869">Fuzz Testing</a><ul><li><span data-type="index-term">avoiding writing</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.ix_unsf">Item 16: Avoid writing unsafe code</a>-<a data-type="index:locator" href="#OEBPS/ch03.html.id1221">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">documenting</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1622">Item 27: Document public interfaces</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1812">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">FFI code in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2046">Item 34: Control what crosses FFI boundaries</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2062">Code concerns</a><ul><li><span data-type="index-term">encapsulating in safe code</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2116">Lifetimes</a></li></ul></li><li><span data-type="index-term">occasions requiring</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1186">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">raw pointers</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2098">Lifetimes</a></li><li><span data-type="index-term">use by replace</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1097">Access Control</a></li><li><span data-type="index-term">using raw and un-smart pointers</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1157">Smart pointers</a></li></ul></li><li><span data-type="index-term">unsafe functions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id282">Fundamental Types</a></li><li><span data-type="index-term">unsafe keyword</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1183">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">unsafe mode</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1955">Beyond Standard Rust</a></li><li><span data-type="index-term">unsafe_op_in_unsafe_fn lint</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1220">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">unstable features in Rust</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1855">Benchmarks</a></li><li><span data-type="index-term">unwrap method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id383">Item 3: Prefer Option and Result transforms 
over explicit match expressions</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1320">Item 18: Don’t panic</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1823">Unit Tests</a>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1849">Examples</a></li><li><span data-type="index-term">unwrap_err method</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1329">Item 18: Don’t panic</a></li><li><span data-type="index-term">unzip method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id713">Iterator Consumers</a></li><li><span data-type="index-term">upcasting in future Rust versions</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1373">Upcasting in Future Versions of Rust</a></li><li><span data-type="index-term">usability</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1391">Who’s Afraid of the Big Bad Copy?</a></li><li><span data-type="index-term">use statements</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1484">Item 23: Avoid wildcard imports</a>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1493">Item 23: Avoid wildcard imports</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1959">Item 33: Consider making library code 
no_std compatible</a><ul><li><span data-type="index-term">core types in no_std environments</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1978">core</a></li></ul></li><li><span data-type="index-term">use-after-free</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2100">Lifetimes</a></li><li><span data-type="index-term">user-defined type conversions</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id442">User-Defined Type Conversions</a></li><li><span data-type="index-term">user-defined types</span><ul><li><span data-type="index-term">coercions affected by</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id493">Coercion</a></li><li><span data-type="index-term">operator overloads for</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id833">Operator Overloads</a></li></ul></li><li><span data-type="index-term">usize</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id255">Fundamental Types</a></li><li><span data-type="index-term">UTF-8</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id278">Fundamental Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id422">Nested Errors</a></li></ul></div><div data-type="indexdiv"><h3>V</h3><ul><li><span data-type="index-term">Vec type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id578">Slices</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id630">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id711">Iterator Consumers</a>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2021">Fallible Allocation</a><ul><li><span data-type="index-term">Result holding a Vec</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id728">Building Collections from Result Values</a></li><li><span data-type="index-term">Vec::push</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2037">Fallible Allocation</a></li></ul></li><li><span data-type="index-term">vectors</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id1982">core</a><ul><li><span data-type="index-term">bounds checking</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id718">Iterator Consumers</a></li><li><span data-type="index-term">converting vector of i64 values to bytes (u8)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id725">Building Collections from Result Values</a></li></ul></li><li><span data-type="index-term">verification (formal)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1929">Item 31: Take advantage of the tooling ecosystem</a></li><li><span data-type="index-term">version control, Cargo.lock file</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1526">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">version selection algorithm (Cargo)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1523">Item 25: Manage your dependency graph</a></li><li><span data-type="index-term">version specification (dependencies)</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1531">Version Specification</a></li><li><span data-type="index-term">visibility</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_visi">Item 22: Minimize visibility</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1482">Visibility Semantics</a><ul><li><span data-type="index-term">restricting</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1472">Visibility Semantics</a></li><li><span data-type="index-term">syntax for</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1453">Visibility Syntax</a></li><li><span data-type="index-term">unit tests and</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1821">Unit Tests</a></li></ul></li><li><span data-type="index-term">void (C)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id272">Fundamental Types</a></li><li><span data-type="index-term">vtable</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id499">Coercion</a>, <a data-type="index:locator" href="#OEBPS/ch01.html.id588">Trait objects</a>, <a data-type="index:locator" href="#OEBPS/ch02.html.id941">Trait Objects</a><ul><li><span data-type="index-term">entry for Any</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1354">Item 19: Avoid reflection</a></li><li><span data-type="index-term">trait object</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id970">Trait Object Safety</a></li><li><span data-type="index-term">trait objects for trait bounds</span>, <a data-type="index:locator" href="#OEBPS/ch02.html.id960">More Trait Bounds</a></li></ul></li></ul></div><div data-type="indexdiv"><h3>W</h3><ul><li><span data-type="index-term">warn(missing_docs) attribute</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1628">Tooling</a></li><li><span data-type="index-term">warnings about Rust usage (Clippy)</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1780">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">Weak type</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id613">Smart Pointer Types</a>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1155">Smart pointers</a></li><li><span data-type="index-term">weak_ptr (C++)</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id611">Smart Pointer Types</a></li><li><span data-type="index-term">wildcard dependency</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1446">Semver for Crate Users</a></li><li><span data-type="index-term">wildcard imports</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.ix_wldimp">Item 23: Avoid wildcard imports</a>-<a data-type="index:locator" href="#OEBPS/ch04.html.id1496">Item 23: Avoid wildcard imports</a><ul><li><span data-type="index-term">avoiding from crates you don't control</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1491">Item 23: Avoid wildcard imports</a></li><li><span data-type="index-term">Clippy checks on</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1807">Item 29: Listen to Clippy</a></li><li><span data-type="index-term">name clashes from</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1489">Item 23: Avoid wildcard imports</a></li></ul></li><li><span data-type="index-term">Wilde, Oscar</span>, <a data-type="index:locator" href="#OEBPS/ch04.html.id1408">Dependencies</a></li><li><span data-type="index-term">Winters, Titus</span>, <a data-type="index:locator" href="#OEBPS/ch05.html.id1609">Tooling</a></li><li><span data-type="index-term">wrapper layer holding unsafe code</span>, <a data-type="index:locator" href="#OEBPS/ch03.html.id1216">Item 16: Avoid writing unsafe code</a></li><li><span data-type="index-term">wrapper struct for C library interaction</span>, <a data-type="index:locator" href="#OEBPS/ch06.html.id2113">Lifetimes</a></li></ul></div><div data-type="indexdiv"><h3>Z</h3><ul><li><span data-type="index-term">zip method</span>, <a data-type="index:locator" href="#OEBPS/ch01.html.id669">Iterator Transforms</a></li></ul></div></div></div></section></div></div>
<div id="OEBPS/colophon01.html"><div data-type="book">
<section class="abouttheauthor" data-pdf-bookmark="About the Author" data-type="colophon" epub:type="colophon"><div class="colophon" id="OEBPS/colophon01.html.id196">
  <h1>About the Author</h1>
  <p><strong>David Drysdale</strong> is a staff software engineer at Google and has been primarily working in Rust since 2019.  He is the author of the Rust port of the Tink cryptography library and also led the project to replace Android’s hardware cryptography library (KeyMint) with a Rust version. He has extensive prior experience in C/C++ and Go and has previously worked on projects as diverse as the Linux kernel, networking control plane software, and mobile video conferencing apps.</p>
</div></section></div></div>
<div id="OEBPS/colophon02.html"><div data-type="book">
<section data-pdf-bookmark="Colophon" data-type="colophon" epub:type="colophon"><div class="colophon" id="OEBPS/colophon02.html.colophon">
<h1>Colophon</h1>

<p>The animal on the cover of <em>Effective Rust</em> is a speckled swimming crab (<em>Arenaeus cribrarius</em>). It is known for its nocturnal and solitary behavior, but can exhibit aggressive qualities when threatened. The animal can be found in several places along the Atlantic shoreline from Massachusetts in the United States to areas in Argentina.</p>

<p>The speckled swimming crab’s hard upper shell can be light brown, light maroon, or olive with white or tan spots. Each side of the carapace has nine lateral teeth, and there are six other teeth found between the crab’s eye sockets. The animal can reach between 4.5 and 6 inches wide, and it is twice as wide as it is long.</p>

<p>The speckled swimming crab’s colors allow it to camouflage in its surrounding areas while waiting for its prey, which primarily consists of detritus. The animal has also been known to eat fish, mollusks, and other crustaceans.</p>

<p>The conservation status of the speckled swimming crab has not been evaluated, but the species is commercially gathered in Brazil, which may influence its population size. Many of the animals on O’Reilly covers are endangered; all of them are important to the world.</p>

<p>The cover illustration is by Karen Montgomery, based on an antique line engraving from <em>Museum of Animated Nature</em>. The series design is by Edie Freedman, Ellie Volckhausen, and Karen Montgomery. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.</p>
</div></section></div></div>
</div>

</body></html>