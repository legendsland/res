<!DOCTYPE html><html><head>
<meta name="dc.identifier" content="res/dc0e2ff3031cafb57e6a7c4964d9a199c60dfeff">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)</title>
<style>
.calibre {
    display: block;
    font-size: 1em;
    padding-left: 0;
    padding-right: 0;
    margin: 0 5pt
    }
.calibre1 {
    display: block
    }
.calibre2 {
    height: auto;
    width: auto
    }
.calibre3 {
    display: block
    }
.calibre4 {
    display: block;
    line-height: 1.2
    }
.calibre5 {
    display: block;
    text-indent: 0;
    margin: 0.5em 0 1em
    }
.calibre6 {
    font-style: italic
    }
.calibre7 {
    border-collapse: separate;
    border-spacing: 2px;
    display: table;
    margin-bottom: 0;
    margin-top: 0;
    text-indent: 0
    }
.calibre8 {
    display: table-row-group;
    vertical-align: middle
    }
.calibre9 {
    display: table-row;
    vertical-align: inherit
    }
.calibre10 {
    display: table-cell;
    text-align: inherit;
    vertical-align: top;
    padding: 1px
    }
.calibre11 {
    display: table-cell;
    text-align: inherit;
    vertical-align: inherit;
    padding: 1px
    }
.calibre12 {
    display: table-column
    }
.calibre13 {
    font-weight: bold
    }
.calibre14 {
    line-height: 1.2
    }
.calibre15 {
    display: table-row;
    vertical-align: middle
    }
.calibre16 {
    font-size: 1.125em;
    line-height: 1.2
    }
.calibre17 {
    color: gray;
    display: block;
    height: 2px;
    width: 20%;
    margin: 0.5em auto;
    border: currentColor inset 1px
    }
.calibre18 {
    display: block;
    font-size: 1.41667em;
    font-weight: bold;
    line-height: 1.2;
    margin: 1em 0 0;
    padding: 0
    }
.calibre19 {
    display: block;
    list-style-type: disc;
    margin-bottom: 1em;
    margin-right: 0;
    margin-top: 1em
    }
.calibre20 {
    display: list-item
    }
.calibre21 {
    font-family: monospace
    }
.calibre22 {
    height: auto;
    width: fit
    }
.calibre23 {
    display: block;
    font-size: 1.125em;
    font-weight: bold;
    line-height: 1.2;
    margin: 1em 0
    }
.calibre24 {
    height: auto;
    width: 85%
    }
.calibre25 {
    height: auto;
    width: 50%
    }
.calibre26 {
    display: block;
    font-weight: bold;
    margin: 1em 0 1.33em
    }
.calibre27 {
    display: block;
    margin: 1em 0
    }
.calibre28 {
    display: block;
    font-style: italic
    }
.calibre29 {
    display: block;
    margin-left: 40px
    }
.calibre30 {
    height: auto;
    width: 80%
    }
.calibre31 {
    height: auto;
    width: 60%
    }
.calibre32 {
    height: auto;
    width: 75%
    }
.calibre33 {
    text-decoration: underline
    }
.calibre34 {
    height: auto;
    width: 90%
    }
.calibre35 {
    font-size: 0.91667em;
    line-height: 1.2
    }
.calibre36 {
    height: auto;
    width: 45%
    }
.calibre37 {
    height: auto;
    width: 70%
    }
.calibre38 {
    font-style: italic;
    line-height: 1.2
    }
.calibre39 {
    display: block;
    font-size: 1.125em;
    font-weight: bold;
    line-height: 1.2;
    text-align: center;
    margin: 0 0 1em
    }
.calibre40 {
    display: block;
    margin: 1em
    }
.calibre41 {
    font-size: 0.75em
    }
.calibre42 {
    background-color: #aaa;
    color: white;
    display: table-cell;
    font-weight: bold;
    vertical-align: inherit;
    padding: 1px
    }
.calibre43 {
    height: auto;
    width: 43%
    }
.calibre44 {
    color: #666
    }
.calibre45 {
    font-family: sans-serif
    }
.calibre46 {
    display: block;
    list-style-type: decimal;
    margin-bottom: 1em;
    margin-right: 0;
    margin-top: 1em
    }
.calibre47 {
    height: auto;
    width: 100%
    }
.calibre48 {
    font-size: 0.75em;
    line-height: normal;
    vertical-align: sub
    }
.calibre49 {
    height: auto;
    width: 52%
    }
.codewrap {
    display: block;
    padding-left: 3em;
    text-align: left;
    text-indent: -3em;
    white-space: pre-line;
    word-wrap: break-word
    }
.pagebreak {
    display: block
    }
.pagebreak1 {
    display: block;
    text-indent: 0;
    margin: 0.5em 0 1em
    }
.pagebreak2 {
    display: block;
    font-size: 2em;
    font-weight: bold;
    line-height: 1.2;
    margin: 1em 0 0.67em
    }
.part-title {
    display: block;
    font-size: 2em;
    font-weight: bold;
    line-height: 1.2;
    text-align: center;
    margin: 10% 0 0.67em
    }
.right {
    display: block;
    font-size: 2em;
    font-weight: bold;
    line-height: 1.2;
    text-align: right;
    margin: 1em 0 0.67em
    }
.right1 {
    display: block;
    font-size: 1.125em;
    font-weight: bold;
    line-height: 1.2;
    text-align: right;
    margin: 1em 0
    }
.right2 {
    display: block;
    font-weight: bold;
    text-align: right;
    margin: 1em 0 1.33em
    }
.xsmall {
    display: block;
    font-size: 0.41667em;
    text-indent: 0;
    margin: 0.5em 0 1em
    }
</style>
<style>
@page {
    margin-bottom: 5pt;
    margin-top: 5pt
    }

</style>
<style id="res-style" type="text/css">

.book-toc-wrapper {
    position: fixed;
    top: 0;
}

.book-toc {
    background: #f9f9f9 none repeat scroll 0 0;
    border: 1px solid #aaa;
    font-size: 95%;
    margin-bottom: 1em;
    padding: 20px;
    width: auto;
    overflow-y: scroll;
    height:800px;
    max-width: 600px;
    display: none;
}

.book-toc a {
    text-decoration: none;
}
.book-toc a:link, .book-toc a:visited {
    color: blue;
}
.book-toc a:hover {
    color: red;
}

.toc-transparent {
    opacity: 0.2;
}

/*img {*/
/*    width: 40% !important;*/
/*}*/

#res-toc-container {
    position: fixed;
    top: 0;
}

#res-toc-content {
    background-color: #f9f9f9;
    overflow: scroll;
    height: 800px;
}

#res-toc-content.transparent {
    opacity: 0.2;
}

#res-toc-content ul {
    list-style-type: none;
}

#res-toc-content a {
    text-decoration: none;
}
#res-toc-content a:link, #res-toc-content a:visited {
    color: blue;
}
#res-toc-content a:hover {
    color: red;
}



</style>
</head>
<body>

<div id="titlepage.xhtml"><div>

        <div>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 750 900" preserveAspectRatio="none">
                <image width="750" height="900" xlink:href="data:image/jpeg;base64,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"></image>
            </svg>
        </div>
    

</div></div>
<div id="text/part0000_split_000.html"><div class="calibre">
<a id="text/part0000_split_000.html.cover"></a><div class="calibre1"><img src="data:image/jpeg;base64,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" class="calibre2"></div><div class="calibre3" id="text/part0000_split_000.html.calibre_pb_0"></div>

</div></div>
<div id="text/part0000_split_001.html"><div class="calibre">

<div id="text/part0000_split_001.html.toc-2" style="height:0pt"></div><h1 class="right" height="20%" id="text/part0000_split_001.html.calibre_pb_2">Language Implementation Patterns</h1><h3 class="right1">Create Your Own Domain-Specific and <br class="calibre4">General Programming Languages</h3><p height="20%" class="calibre5">&nbsp;</p><h4 class="right2">by Terence Parr</h4><div class="calibre3" id="text/part0000_split_001.html.calibre_pb_3"></div>

</div></div>
<div id="text/part0000_split_002.html"><div class="calibre">

<p class="pagebreak1" id="text/part0000_split_002.html.calibre_pb_4">&nbsp;</p><p class="xsmall">Copyright  2010 Terence Parr.
        This book is licensed to
	the individual who purchased it. We don't copy-protect it
	because that would limit your ability to use it for your
	own purposes. Please don't break this trust-don't allow others
	to use your copy of the book. Thanks. 
      <br class="calibre1">- Dave &amp; Andy.</p><p class="xsmall">
      Many of the designations used by manufacturers and sellers to
      distinguish their products are claimed as trademarks. Where those
      designations appear in this book, and The Pragmatic Programmers, LLC
      was aware of a trademark claim, the designations have been printed in
      initial capital letters or in all capitals. The Pragmatic Starter Kit,
      The Pragmatic Programmer, Pragmatic Programming, Pragmatic Bookshelf
      and the linking 
      <i class="calibre6">g</i>
      device are trademarks of The Pragmatic Programmers,
      LLC. 
    </p><p class="xsmall">
      Every precaution was taken in the preparation of this
      book. However, the publisher assumes no responsibility for errors or
      omissions, or for damages that may result from the use of information
      (including program listings) contained herein.
    </p><p class="xsmall">
      Our Pragmatic courses,
      workshops, and other products can help you and your team create better
      software and have more fun. For more information, as well as the
      latest Pragmatic titles, please visit us at 
      <a href="http://pragprog.com">http://pragprog.com</a>.
    </p><p class="xsmall">
      No part of this publication may be
      reproduced, stored in a retrieval system, or transmitted, in any form,
      or by any means, electronic, mechanical, photocopying, recording, or
      otherwise, without the prior consent of the publisher.
      <br class="calibre1">Printed in the United States of America.<br class="calibre1">ISBN-13: 978-1-934356-45-6</p><p class="xsmall">Book version: P5.0September 2014</p><a id="text/part0000_split_002.html.toc"></a><div class="calibre3" id="text/part0000_split_002.html.calibre_pb_5"></div>

</div></div>
<div id="text/part0000_split_003.html"><div class="calibre">

<h1 class="pagebreak2" id="text/part0000_split_003.html.calibre_pb_6">Table of Contents</h1><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre10"></td><td class="calibre11"><a href="#text/part0000_split_005.html.chp.credits">Acknowledgments</a></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre10"></td><td class="calibre11"><a href="#text/part0000_split_006.html.chp.preface">Preface</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_007.html.d24e124">What to Expect from This Book</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_008.html.d24e149">How This Book Is Organized</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_009.html.d24e185">What Youll Find in the Patterns</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_010.html.d24e215">Who Should Read This Book</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_011.html.d24e224">How to Read This Book</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_012.html.d24e273">Languages and Tools Used in This Book</a></td></tr></tbody></table><div class="calibre1"><a href="#text/part0000_split_013.html.d24e328"><strong class="calibre13">I. Getting Started with Parsing</strong></a></div><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_014.html.chp.intro">1. </a></td><td class="calibre11"><a href="#text/part0000_split_014.html.chp.intro">Language Applications Cracked Open</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_016.html.sec.big-pic">The Big Picture</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_017.html.sec.tour">A Tour of the Patterns</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_018.html.d24e999">Dissecting a Few Applications</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_019.html.d24e1778">Choosing Patterns and Assembling Applications</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_020.html.chp.parsing">2. </a></td><td class="calibre11"><a href="#text/part0000_split_020.html.chp.parsing">Basic Parsing Patterns</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_022.html.sec.if-diag-tree">Identifying Phrase Structure</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_023.html.d24e2032">Building Recursive-Descent Parsers</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_024.html.d24e2257">Parser Construction Using a Grammar DSL</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_025.html.sec.tokenizing">Tokenizing Sentences</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_026.html.tip.grammar-parser-mapping">Pattern 1. Mapping Grammars to Recursive-Descent Recognizers</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_027.html.tip.lexer">Pattern 2. <em class="calibre6">LL(1)</em> Recursive-Descent Lexer</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_028.html.tip.recursive-descent">Pattern 3. <em class="calibre6">LL(1)</em> Recursive-Descent Parser</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser">Pattern 4. <em class="calibre6">LL(k)</em> Recursive-Descent Parser</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_031.html.chp.advanced-parsing">3. </a></td><td class="calibre11"><a href="#text/part0000_split_031.html.chp.advanced-parsing">Enhanced Parsing Patterns</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_033.html.sec.arbitrary-lookahead">Parsing with Arbitrary Lookahead</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_034.html.d24e5768">Parsing like a Pack Rat</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_035.html.sec.sempred">Directing the Parse with Semantic Information</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_036.html.tip.backtracker">Pattern 5. Backtracking Parser</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_037.html.tip.packrat">Pattern 6. Memoizing Parser</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_038.html.tip.predicated-parser">Pattern 7. Predicated Parser</a></td></tr></tbody></table><div class="calibre1"><a href="#text/part0000_split_040.html.d24e8312"><strong class="calibre13">II. Analyzing Languages</strong></a></div><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_041.html.chp.IR">4. </a></td><td class="calibre11"><a href="#text/part0000_split_041.html.chp.IR">Building Intermediate Form Trees</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_043.html.d24e8486">Why We Build Trees</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_044.html.d24e8571">Building Abstract Syntax Trees</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_045.html.sec.antlr.intro">Quick Introduction to ANTLR</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_046.html.sec.ASTs-with-ANTLR">Constructing ASTs with ANTLR Grammars</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_047.html.tip.parse-tree">Pattern 8. Parse Tree</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_048.html.tip.homo">Pattern 9. Homogeneous AST</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_049.html.tip.hetero-normalized">Pattern 10. Normalized Heterogeneous AST</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_050.html.tip.hetero">Pattern 11. Irregular Heterogeneous AST</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_052.html.chp.walking">5. </a></td><td class="calibre11"><a href="#text/part0000_split_052.html.chp.walking">Walking and Rewriting Trees</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_054.html.d24e11599">Walking Trees and Visitation Order</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_055.html.d24e12066">Encapsulating Node Visitation Code</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_056.html.sec.generating-visitors">Automatically Generating Visitors from Grammars</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_057.html.sec.tree-pattern-descr">Decoupling Tree Traversal from Pattern Matching</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_058.html.tip.embedded-walker">Pattern 12. Embedded Heterogeneous Tree Walker</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_059.html.tip.visitor">Pattern 13. External Tree Visitor</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_060.html.tip.tree-grammar">Pattern 14. Tree Grammar</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_061.html.tip.tree-pattern-matcher">Pattern 15. Tree Pattern Matcher</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_063.html.chp.symtab">6. </a></td><td class="calibre11"><a href="#text/part0000_split_063.html.chp.symtab">Tracking and Identifying Program Symbols</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_065.html.sec.info-sym">Collecting Information About Program Entities</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_066.html.sec.symtab-scopes">Grouping Symbols into Scopes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_067.html.sec.symtab-resolving">Resolving Symbols</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_068.html.tip.monolithic-symtab">Pattern 16. Symbol Table for Monolithic Scope</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_069.html.tip.nested-symtab">Pattern 17. Symbol Table for Nested Scopes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_071.html.chp.aggr-symtab">7. </a></td><td class="calibre11"><a href="#text/part0000_split_071.html.chp.aggr-symtab">Managing Symbol Tables for Data Aggregates</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_073.html.sec.struct-scope-trees">Building Scope Trees for Structs</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_074.html.sec.class-scope-trees">Building Scope Trees for Classes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_075.html.tip.struct-symtab">Pattern 18. Symbol Table for Data Aggregates</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_076.html.tip.class-symtab">Pattern 19. Symbol Table for Classes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_078.html.chp.semantics">8. </a></td><td class="calibre11"><a href="#text/part0000_split_078.html.chp.semantics">Enforcing Static Typing Rules</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_080.html.tip.type-computation">Pattern 20. Computing Static Expression Types</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_081.html.tip.type-promotion">Pattern 21. Automatic Type Promotion</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_082.html.tip.type-safety">Pattern 22. Enforcing Static Type Safety</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_083.html.tip.type-safety-oo">Pattern 23. Enforcing Polymorphic Type Safety</a></td></tr></tbody></table><div class="calibre1"><a href="#text/part0000_split_085.html.d24e26951"><strong class="calibre13">III. Building Interpreters</strong></a></div><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_086.html.chp.interp">9. </a></td><td class="calibre11"><a href="#text/part0000_split_086.html.chp.interp">Building High-Level Interpreters</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_088.html.sec.interp-mem">Designing High-Level Interpreter Memory Systems</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_089.html.sec.interp-symtab">Tracking Symbols in High-Level Interpreters</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_090.html.sec.interp-proc">Processing Instructions</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_091.html.tip.syntax-directed-interp">Pattern 24. Syntax-Directed Interpreter</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_092.html.tip.tree-interp">Pattern 25. Tree-Based Interpreter</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_094.html.chp.interp-bytecode">10. </a></td><td class="calibre11"><a href="#text/part0000_split_094.html.chp.interp-bytecode">Building Bytecode Interpreters</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_096.html.d24e29086">Programming Bytecode Interpreters</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_097.html.d24e29275">Defining an Assembly Language Syntax</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_098.html.d24e29409">Bytecode Machine Architecture</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_099.html.d24e30009">Where to Go from Here</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_100.html.tip.bytecode-asm">Pattern 26. Bytecode Assembler</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_101.html.tip.stack-bytecode">Pattern 27. Stack-Based Bytecode Interpreter</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_102.html.tip.reg-bytecode">Pattern 28. Register-Based Bytecode Interpreter</a></td></tr></tbody></table><div class="calibre1"><a href="#text/part0000_split_104.html.d24e33757"><strong class="calibre13">IV. Translating and Generating Languages</strong></a></div><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_105.html.chp.trans">11. </a></td><td class="calibre11"><a href="#text/part0000_split_105.html.chp.trans">Translating Computer Languages</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_107.html.d24e33864">Syntax-Directed Translation</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_108.html.d24e33912">Rule-Based Translation</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_109.html.d24e34025">Model-Driven Translation</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_110.html.d24e34860">Constructing a Nested Output Model</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_111.html.tip.syntax-directed">Pattern 29. Syntax-Directed Translator</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_112.html.tip.rule-based">Pattern 30. Rule-Based Translator</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_113.html.tip.gen-obj">Pattern 31. Target-Specific Generator Classes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_115.html.chp.gen">12. </a></td><td class="calibre11"><a href="#text/part0000_split_115.html.chp.gen">Generating DSLs with Templates</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_117.html.sec.ST-getting-started">Getting Started with StringTemplate</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_118.html.d24e37613">Characterizing StringTemplate</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_119.html.d24e37820">Generating Templates from a Simple Input Model</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_120.html.sec.ast-dot">Reusing Templates  with a Different Input Model</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_121.html.sec.tree-grammar-templates">Using a Tree Grammar to Create Templates</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_122.html.sec.ooschema">Applying Templates to Lists of Data</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_123.html.sec.gen-java">Building Retargetable Translators</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre10"><a href="#text/part0000_split_125.html.chp.tasks">13. </a></td><td class="calibre11"><a href="#text/part0000_split_125.html.chp.tasks">Putting It All Together</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_127.html.d24e41671">Finding Patterns in Protein Structures</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_128.html.d24e41773">Using a Script to Build 3D Scenes</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_129.html.d24e41840">Processing XML</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_130.html.d24e41953">Reading Generic Configuration Files</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_131.html.sec.tweak-source">Tweaking Source Code</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_132.html.sec.add-type">Adding a New Type to Java</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_133.html.d24e42229">Pretty Printing Source Code</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="1em" class="calibre12"><col width="1em" class="calibre12"><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"></td><td class="calibre11"><a href="#text/part0000_split_134.html.d24e42333">Compiling to Machine Code</a></td></tr></tbody></table><table class="calibre7"><colgroup><col width="2em" class="calibre12"></colgroup><tbody class="calibre8"><tr class="calibre9"><td class="calibre10"></td><td class="calibre11"><a href="#text/part0000_split_135.html.chp.bibliography">Bibliography</a></td></tr></tbody></table><div class="calibre3" id="text/part0000_split_003.html.calibre_pb_7"></div>

</div></div>
<div id="text/part0000_split_004.html"><div class="calibre">

<h1 class="pagebreak2" id="text/part0000_split_004.html.calibre_pb_9">
	What Readers Are Saying About
	<span class="calibre14">Language Implementation Patterns</span>
      </h1><div class="calibre1"><div class="calibre1">
	  Throw away your compiler theory book! Terence Parr shows how to write
practical parsers, translators, interpreters, and other language
applications using modern tools and design patterns. Whether you're
designing your own DSL or mining existing code for bugs or gems,
you'll find example code and suggested patterns in this clearly
written book about all aspects of parsing technology.
	  </div><table class="calibre7"><tbody><tr class="calibre15"><td class="calibre11"><big class="calibre16"></big></td><td class="calibre11">Guido van Rossum</td></tr><tr class="calibre15"><td class="calibre11">
</td><td class="calibre11">Creator of the Python language</td></tr></tbody></table></div><div class="calibre1"><div class="calibre1">
	  My Dragon book is getting jealous!
	  </div><table class="calibre7"><tbody><tr class="calibre15"><td class="calibre11"><big class="calibre16"></big></td><td class="calibre11">Dan Bornstein</td></tr><tr class="calibre15"><td class="calibre11">
</td><td class="calibre11">Designer, Dalvik Virtual Machine for the Android platform</td></tr></tbody></table></div><div class="calibre1"><div class="calibre1">
	  Invaluable, practical wisdom for any language designer.
	  </div><table class="calibre7"><tbody><tr class="calibre15"><td class="calibre11"><big class="calibre16"></big></td><td class="calibre11">Tom Nurkkala, PhD</td></tr><tr class="calibre15"><td class="calibre11">
</td><td class="calibre11">Associate Professor, Computer Science and Engineering, Taylor University</td></tr></tbody></table></div><div class="calibre1"><div class="calibre1">
	   Terence makes language design concepts clear and approachable. If you ever wanted to build your own language but didn't know where to start or thought it was too hard, start with this book.
	  </div><table class="calibre7"><tbody><tr class="calibre15"><td class="calibre11"><big class="calibre16"></big></td><td class="calibre11">Adam Keys</td></tr><tr class="calibre15"><td class="calibre11">
</td><td class="calibre11">http://therealadam.com</td></tr></tbody></table></div><div class="calibre1"><div class="calibre1">
	   This is a book of broad and lasting scope, written in the engaging and accessible style of the mentors we remember best. Language Implementation Patterns does more than explain how to create languages; it explains how to think about creating languages. It's an invaluable resource for implementing robust, maintainable domain-specific languages. 
	  </div><table class="calibre7"><tbody><tr class="calibre15"><td class="calibre11"><big class="calibre16"></big></td><td class="calibre11">Kyle Ferrio, PhD</td></tr><tr class="calibre15"><td class="calibre11">
</td><td class="calibre11">Director of Scientific Software Development, Breault Research Organization</td></tr></tbody></table></div><div class="calibre3" id="text/part0000_split_004.html.calibre_pb_10"></div>

</div></div>
<div id="text/part0000_split_005.html"><div class="calibre">

<div id="text/part0000_split_005.html.chp.credits" style="height:0pt"></div><div id="text/part0000_split_005.html.toc-3" style="height:0pt"></div><h1 class="right" id="text/part0000_split_005.html.calibre_pb_12">Acknowledgments</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">Id like to start out by recognizing my development editor, the
talented Susannah Pfalzer. She and I brainstormed and experimented for
eight months until we found the right formula for this book. She was
invaluable throughout the construction of this book.</p><p height="10" width="0" class="calibre5">Next, Id like to thank the cadre of book reviewers (in no
particular order): Kyle Ferrio, Dragos Manolescu, Gerald Rosenberg,
Johannes Luber, Karl Pfalzer, Stuart Halloway, Tom Nurkkala, Adam
Keys, Martijn Reuvers, William Gallagher, Graham Wideman, and Dan
Bornstein.  Although
not an official reviewer, Wayne Stewart provided a huge amount of
feedback on the errata website. Martijn Reuvers also created the ANT
build files for the code directories.  </p><p height="10" width="0" class="calibre5">Gerald Rosenberg and Graham Wideman deserve special attention for
their ridiculously thorough reviews of the manuscript as well as
provocative conversations by phone.</p><div class="calibre3" id="text/part0000_split_005.html.calibre_pb_13"></div>

</div></div>
<div id="text/part0000_split_006.html"><div class="calibre">

<div id="text/part0000_split_006.html.toc-4" style="height:0pt"></div><div id="text/part0000_split_006.html.chp.preface" style="height:0pt"></div><h1 class="right" id="text/part0000_split_006.html.calibre_pb_15">Preface</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">The more language applications you build, the more patterns youll
see. The truth is that the architecture of most language applications
is freakishly similar. A broken record plays in my head every time I
start a new language application: First build a syntax
recognizer that creates a data structure in memory.  Then sniff the
data structure, collecting information or altering the
structure. Finally, build a report or code generator that feeds off
the data structure. You even start seeing patterns within the
tasks themselves.  Tasks share lots of common algorithms and data
structures.</p><p height="10" width="0" class="calibre5">Once you get these language implementation design patterns and the
general architecture into your head, you can build pretty much
whatever you want.  If you need to learn how to build languages
pronto, this book is for you. Its a pragmatic book that identifies
and distills the common design patterns to their essence. Youll learn
why you need the patterns, how to implement them, and how they fit
together. Youll be a competent language developer in no time!</p><p height="10" width="0" class="calibre5">Building a new language doesnt require a great deal of theoretical
computer science. You might be skeptical because every book youve
picked up on language development has focused on compilers.  Yes, building
a compiler for a general-purpose programming language requires a
strong computer science background. But, most of us dont build
compilers. So, this book focuses on the things that we build all the
time: configuration file readers, data readers, model-driven code
generators, source-to-source translators, source analyzers, and
interpreters.  Well also code in Java rather than a primarily
academic language like Scheme so that you can directly apply what you
learn in this book to real-world projects.</p>

</div></div>
<div id="text/part0000_split_007.html"><div class="calibre">

<h2 id="text/part0000_split_007.html.d24e124" class="calibre18">What to Expect from This Book</h2><p height="10" width="0" class="calibre5">This book gives you just the tools youll need to develop
day-to-day language applications.  Youll be able to handle all but
the really advanced or esoteric situations.  For example, we wont
have space to cover topics such as machine code generation, register
allocation, automatic garbage collection, thread models, and extremely
efficient interpreters.  Youll get good all-around expertise
implementing modest languages, and youll get respectable expertise in processing
or translating complex languages.</p><p height="10" width="0" class="calibre5">This book explains how existing language applications work so you
can build your own. To do so, were going to break them down into a
series of well-understood and commonly used patterns. But, keep in
mind that this book is a learning tool, not a library of language
implementations.  Youll see many sample implementations throughout
the book, though. Samples make the discussions more concrete and
provide excellent foundations from which to build new
applications.</p><p height="10" width="0" class="calibre5">Its also important to point out that were going to focus on
building applications for languages that already exist (or languages
you design that are very close to existing languages). Language
design, on the other hand, focuses on coming up with a syntax (a set of
valid sentences) and describing the complete semantics (what every
possible input means).  Although we wont specifically study how to
design languages, youll actually absorb a lot as we go through the
book. A good way to learn about language design is to look at lots of
different languages. Itll help if you research the history of
programming languages to see how languages change over time.</p><p height="10" width="0" class="calibre5">When we talk about language applications, were not just talking
about <em class="calibre6">implementing</em> languages with a compiler or
interpreter.  Were talking about any program that processes,
analyzes, or translates an input file.  Implementing a language means
building an application that executes or performs tasks according to
sentences in that language.  Thats just one of the things we can do
for a given language definition. For example, from the definition of C,
we can build a C compiler, a translator from C to Java, or a tool that
instruments C code to isolate memory leaks.  Similarly, think about
all the tools built into the Eclipse development environment for
Java.  Beyond the compiler, Eclipse can refactor, reformat, search,
syntax highlight, and so on.</p><p height="10" width="0" class="calibre5">You can use the patterns in this book to build language
applications for any computer language, which of course includes domain-specific languages (DSLs). A domain-specific language is just
that: a computer language designed to make users particularly
productive in a specific domain.  Examples include Mathematica,
shell scripts, wikis, UML, XSLT, makefiles, PostScript, formal
grammars, and even data file formats like comma-separated values and
XML. The opposite of a DSL is a general-purpose programming language
like C, Java, or Python. In common usage, DSLs also typically have
the connotation of being smaller because of their focus. This isnt
always the case, though. SQL, for example, is a lot bigger than most
general-purpose programming languages.</p>
<div class="calibre3" id="text/part0000_split_007.html.calibre_pb_17"></div>

</div></div>
<div id="text/part0000_split_008.html"><div class="calibre">

<h2 id="text/part0000_split_008.html.d24e149" class="calibre18">How This Book Is Organized</h2><p height="10" width="0" class="calibre5">This book is divided into four parts:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Getting Started with Parsing</em>: Well start out by
looking at the overall architecture of language applications and then
jump into the key language recognition (parsing) patterns.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Analyzing Languages</em>:  To analyze DSLs and
programming languages, well use parsers to build trees that represent
language constructs in memory.  By walking those trees, we can track
and identify the various symbols (such as variables and functions) in
the input. We can also compute expression result-type information (such as
<code class="calibre21">int</code> and <code class="calibre21">float</code>). The patterns in
this part explain how to check whether an input stream
makes sense.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Building Interpreters</em>: This part has four different
interpreter patterns.  The interpreters vary in terms of
implementation difficulty and run-time efficiency.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Translating and Generating Languages</em>: In the final
part, we will learn how to translate one language to another and how to
generate text using the StringTemplate template engine. In the final
chapter, well lay out the architecture of some interesting language
applications to get you started building languages on your
own.</li></ul><p height="10" width="0" class="calibre5">The chapters within the different parts proceed in the order youd
follow to implement a language.  <a href="#text/part0000_split_017.html.sec.tour"><em class="calibre6">A Tour of the Patterns</em></a> describes
how all the patterns fit together.</p>

</div></div>
<div id="text/part0000_split_009.html"><div class="calibre">

<h2 id="text/part0000_split_009.html.d24e185" class="calibre18">What Youll Find in the Patterns</h2><p height="10" width="0" class="calibre5">There are 31 patterns in this book. Each one describes a common
data structure, algorithm, or strategy youre likely to find in language
applications.  Each pattern has four parts:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Purpose</em>: This section briefly describes what the pattern is for. For
example, the purpose of Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a> says how to
automatically and safely promote arithmetic operand types. Its a
good idea to scan the Purpose section before jumping into a pattern
to discover exactly what its trying to solve.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Discussion</em>: This section describes the problem in
more detail, explains when to use the pattern, and describes how the
pattern works.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Implementation</em>: Each pattern has a sample
implementation in Java (possibly using language tools such as
ANTLR). The sample implementations are not intended to be libraries
that you can immediately apply to your problem. They demonstrate, in
code, what we talk about in the Discussion sections.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Related Patterns</em>. This section lists alternative
patterns that solve the same problem or patterns we depend on
to implement this pattern.</li></ul><p height="10" width="0" class="calibre5">The chapter introductory materials and the patterns themselves often
provide comparisons between patterns to keep everything in proper 
perspective.</p>

</div></div>
<div id="text/part0000_split_010.html"><div class="calibre">

<h2 id="text/part0000_split_010.html.d24e215" class="calibre18">Who Should Read This Book</h2><p height="10" width="0" class="calibre5">If youre a practicing software developer or computer science student
and you want to learn how to implement computer languages, this book
is for you.  By computer language, I mean everything from data
formats, network protocols, configuration files, specialized math
languages, and hardware description languages to general-purpose
programming languages.</p><p height="10" width="0" class="calibre5">You dont need a background in formal language theory, but the code
and discussions in this book assume a solid programming background.</p><p height="10" width="0" class="calibre5">To get the most out of this book, you should be fairly comfortable
with recursion. Many algorithms and processes are inherently
recursive. Well use recursion to do everything from recognizing
input, walking trees, and building interpreters to generating output.</p>

</div></div>
<div id="text/part0000_split_011.html"><div class="calibre">

<h2 id="text/part0000_split_011.html.d24e224" class="calibre18">How to Read This Book</h2><p height="10" width="0" class="calibre5">If youre new to language implementation, start with Chapter 1, <a href="#text/part0000_split_014.html.chp.intro"><em class="calibre6">Language Applications Cracked Open</em></a>
because it provides an architectural overview of how we build
languages. You can then move on to Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a> and Chapter 3, <a href="#text/part0000_split_031.html.chp.advanced-parsing"><em class="calibre6">Enhanced Parsing Patterns</em></a> to get some background on grammars (formal language
descriptions) and language recognition.</p><p height="10" width="0" class="calibre5">If youve taken a fair number of computer science courses, you can
skip ahead to either Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a> or Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>. Even if youve built a
lot of trees and tree walkers in your career, its still worth looking
at Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> and Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>.</p><p height="10" width="0" class="calibre5">If youve done some basic language application work before, you
already know how to read input into a handy tree data structure and
walk it. You can skip ahead to Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a> and Chapter 7, <a href="#text/part0000_split_071.html.chp.aggr-symtab"><em class="calibre6">Managing Symbol Tables for Data Aggregates</em></a>, which
describe how to build symbol tables. Symbol tables answer the question
What is <em class="calibre6">x</em>? for some input symbol <em class="calibre6">x</em>. They
are necessary data structures for the patterns in Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, for
example.</p><p height="10" width="0" class="calibre5">More advanced readers might want to jump directly to Chapter 9, <a href="#text/part0000_split_086.html.chp.interp"><em class="calibre6">Building High-Level Interpreters</em></a> and
Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>. If you really know what youre doing, you can skip around the
book looking for patterns of interest.  The truly impatient can grab a
sample implementation from a pattern and use it as a kernel for a new
language (relying on the book for explanations).</p><p height="10" width="0" class="calibre5">If you bought the e-book version of this book, you can click the
gray boxes above the code samples to download code snippets directly.
If youd like to participate in conversations with me and other
readers, you can do so at the web page for this book (<a href="http://www.pragprog.com/titles/tpdsl">http://www.pragprog.com/titles/tpdsl</a>) or on the ANTLR users
  list (<a href="http://www.antlr.org/support.html">http://www.antlr.org/support.html</a>). You can also post book
errata and download all the source code on the books web page.</p>

</div></div>
<div id="text/part0000_split_012.html"><div class="calibre">

<h2 id="text/part0000_split_012.html.d24e273" class="calibre18">Languages and Tools Used in This Book</h2><p height="10" width="0" class="calibre5">The code snippets and implementations in this book are written in Java, but their substance applies equally well to any other general
programming language. I had to pick a single programming language for
consistency. Java is a good choice because its widely used in
industry (<a href="http://langpop.com">http://langpop.com</a> and <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html</a>).
Remember, this book is about design patterns, not language recipes.
You cant just download a patterns sample implementation and apply it
to your problem without modification.</p><p height="10" width="0" class="calibre5">Well use state-of-the-art language tools wherever possible in this
book. For example, to recognize (parse) input phrases, well use a parser generator (well, that is, after we learn how to build parsers
manually in Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>). Its no fair using a parser generator until
you know how parsers work. Thatd be like using a calculator before
learning to do arithmetic. Similarly, once we know how to build tree
walkers by hand, we can let a tool build them for us.</p><p height="10" width="0" class="calibre5">In this book, well use ANTLR extensively. ANTLR is a parser generator
and tree walker generator that Ive honed over the past two decades
while building language applications.  I could have used any similar
language tool, but I might as well use my own. My point is that this
book is not about ANTLR itselfits about the design patterns common
to most language applications.  The code samples merely help you to
understand the patterns.</p><p height="10" width="0" class="calibre5">Well also use a template engine called StringTemplate a lot in
Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a> to generate output. StringTemplate is like
an unparser generator, and templates are like output
grammar rules.  The alternative to a template engine would be to use
an unstructured blob of generation logic interspersed with print
statements.</p><p height="10" width="0" class="calibre5">Youll be able to follow the patterns in this book even if youre
not familiar with ANTLR and StringTemplate. Only the sample
implementations use them. To get the most out of the patterns, though,
you should walk through the sample implementations.  To really
understand them, its a good idea to learn more about the ANTLR
project tools.  Youll get a taste in <a href="#text/part0000_split_045.html.sec.antlr.intro"><em class="calibre6">Quick Introduction to ANTLR</em></a>.  You can also visit the website to get
documentation and examples or purchase <a href="#text/part0000_split_135.html.d2381e296"><em class="calibre6">The
Definitive ANTLR Reference</em>&nbsp;[Par07]</a> (shameless plug).</p><p height="10" width="0" class="calibre5">One way or another, youre going to need language tools to
implement languages.  Youll have no problem transferring your
knowledge to other tools after you finish this book. Its like
learning to flyyou have no choice but to pick a first airplane.
Later, you can move easily to another airplane.  Gaining piloting
skills is the key, not learning the details of a particular aircraft
cockpit.</p><p height="10" width="0" class="calibre5">I hope this book inspires you to learn about languages and motivates
you to build domain-specific languages (DSLs) and other language
tools to help fellow programmers.</p><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td width="24%" class="calibre11"><div class="calibre1"><img id="text/part0000_split_012.html.d24e324" class="calibre2" src="data:image/gif;base64,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" alt="images/parrt_antlers.png"></div></td><td class="calibre11"><div class="calibre1"><div class="calibre1">
</div><div class="calibre1">Terence Parr</div><div class="calibre1"><a href="#text/mailto:parrt@cs.usfca.edu">mailto:parrt@cs.usfca.edu</a></div><div class="calibre1">December 2009</div></div></td></tr></tbody></table><div class="calibre3" id="text/part0000_split_012.html.calibre_pb_23"></div>

</div></div>
<div id="text/part0000_split_013.html"><div class="calibre">

<div id="text/part0000_split_013.html.toc-5" style="height:0pt"></div><h1 class="part-title" id="text/part0000_split_013.html.d24e328"><span class="calibre14">Part 1</span><br class="calibre4"><span class="calibre14">Getting Started with Parsing</span></h1><div class="calibre3" id="text/part0000_split_013.html.calibre_pb_27"></div>

</div></div>
<div id="text/part0000_split_014.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_014.html.calibre_pb_28">&nbsp;</p><a id="text/part0000_split_014.html.toc-6"></a><h4 class="right2" id="text/part0000_split_014.html.chp.intro">Chapter 1</h4>
</div></div>
<div id="text/part0000_split_015.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_015.html.calibre_pb_29">Language Applications Cracked Open</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">In this first part of the book, were going to learn how to
recognize computer languages. (A <em class="calibre6">language</em> is just a set of valid
sentences.) Every language application we look at will have a parser
(recognizer) component, unless its a pure code generator.</p><p height="10" width="0" class="calibre5">We cant just jump straight into the patterns, though. We need to
see how everything fits together first. In this chapter, well get an
architectural overview and then tour the patterns at our disposal.
Finally, well look at the guts of some sample language applications
to see how they work and how they use patterns.</p>

</div></div>
<div id="text/part0000_split_016.html"><div class="calibre">

<h2 id="text/part0000_split_016.html.sec.big-pic" class="calibre18">The Big Picture</h2><p height="10" width="0" class="calibre5">Language applications can be very complicated beasts, so we need to
break them down into bite-sized components.  
The components fit
together into a multistage pipeline that analyzes or manipulates an
input stream.  The pipeline gradually converts an input sentence
(valid input sequence) to a handy internal data structure or
translates it to a sentence in another language.</p><p height="10" width="0" class="calibre5"> We can see the overall data flow within the pipeline in Figure 1, <a href="#text/part0000_split_016.html.fig.bigpic"><em class="calibre6">The multistage pipeline of a language application</em></a>. The
basic idea is that a reader recognizes input and builds an <em class="calibre6">intermediate representation</em> (IR) that feeds the
rest of the application. At the opposite end, a generator emits output
based upon the IR and what the application learned in the intermediate
stages. The intermediate stages form the <em class="calibre6">semantic
analyzer</em> component.  Loosely speaking, semantic analysis
figures out what the input means (anything beyond syntax is called the  <em class="calibre6">semantics</em>).  </p><p height="10" width="0" class="calibre5">The kind of application were building dictates the stages of the
pipeline and how we hook them together.  There are four broad application
categories:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Reader</em>: A reader builds a data structure
from one or more input streams.  The input streams are usually text
but can be binary data as well. Examples include configuration file
readers, program analysis tools such as a method cross-reference tool,
and class file loaders.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Generator</em>: A generator walks an internal data
structure and emits output. Examples include object-to-relational
database mapping tools, object serializers, source code generators,
and web page generators.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Translator</em> or
<em class="calibre6">Rewriter</em>: A translator reads text or binary input
and emits output conforming to the same or a different language.  It
is essentially a combined reader and generator.  Examples include
translators from extinct programming languages to modern languages,
wiki to HTML translators, refactorers, profilers that instrument code,
log file report generators, pretty printers, and macro preprocessors.
Some translators, such as assemblers and compilers, are so common that
they warrant their own subcategories.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Interpreter</em>: An interpreter reads, decodes,
and executes instructions. Interpreters range from simple calculators
and POP protocol servers all the way up to programming language
implementations such as those for Java, Ruby, and Python.
</li></ul><div class="calibre1" id="text/part0000_split_016.html.fig.bigpic"><img id="text/part0000_split_016.html.d24e419" class="calibre22" src="data:image/jpeg;base64,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" alt="images/intro/bigpic.png"><hr class="calibre17"><b class="calibre13">Figure 1. The multistage pipeline of a language application</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p>

</div></div>
<div id="text/part0000_split_017.html"><div class="calibre">

<h2 id="text/part0000_split_017.html.sec.tour" class="calibre18">A Tour of the Patterns</h2><p height="10" width="0" class="calibre5">This section is a road map of this books 31 language implementation patterns.  
Dont worry if this quick tour is hard to digest at first.
The fog will clear as we go through the book and get acquainted with
the patterns.</p><h3 class="calibre23">Parsing Input Sentences</h3><p height="10" width="0" class="calibre5">Reader components use the 
patterns discussed in Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a> and Chapter 3, <a href="#text/part0000_split_031.html.chp.advanced-parsing"><em class="calibre6">Enhanced Parsing Patterns</em></a> to <em class="calibre6">parse</em> (recognize) input
structures.  There are five alternative parsing patterns between the
two chapters. Some languages are tougher to parse than others, and so
we need parsers of varying strength. The trade-off is that the
stronger parsing patterns are more complicated and sometimes a bit
slower.</p><p height="10" width="0" class="calibre5">Well also explore a little about grammars (formal language
specifications) and figure out exactly how parsers recognize languages.  
Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a> shows us how to convert grammars to hand-built
  parsers.  ANTLR<a id="text/part0000_split_017.html.FNPTR-1" href="#text/part0000_split_019.html.FOOTNOTE-1">[1]</a> (or any similar parser
generator) can do this conversion automatically for us, but its a
good idea to familiarize ourselves with the underlying patterns.</p><p height="10" width="0" class="calibre5">

  The most basic reader component combines Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> together with Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> to recognize sentences.   
  More complicated languages
will need a stronger parser, though.  We can increase the
recognition strength of a parser by allowing it to look at more of the input at
once 
(Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>).</p><p height="10" width="0" class="calibre5">When things get really hairy, we can only distinguish sentences by
looking at an entire sentence or phrase (subsentence) using Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>.

Backtrackings strength comes at the cost of slow execution
speed. With some tinkering, however, we can dramatically improve its
efficiency. We just need to save and reuse some partial parsing
results with 
Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a>.</p><p height="10" width="0" class="calibre5">For the ultimate parsing power, we can resort to 
Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a>. A
predicated parser can alter the normal parsing flow based upon run-time
information. For example, input <code class="calibre21">T(i)</code> can mean different things
depending on how we defined <code class="calibre21">T</code> previously. A predicate parser can
look up <code class="calibre21">T</code> in a dictionary to see what it is.</p><p height="10" width="0" class="calibre5">Besides tracking input symbols like <code class="calibre21">T</code>, a parser can execute actions
to perform a transformation or do some analysis. This approach is
usually too simplistic for most applications, though.  Well need to
make multiple passes over the input.  These passes are the stages of
the pipeline that are beyond the reader component.
</p><h3 class="calibre23">Constructing Trees</h3><p height="10" width="0" class="calibre5">Rather than repeatedly parsing the input text in every stage, well
construct an IR.  
The IR is a highly processed version of the input
text thats easy to traverse.  The nodes or elements of the IR are
also ideal places to squirrel away information for use by later
stages.  In Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a>, well discuss why we build trees and how they
encode essential information from the input.</p><p height="10" width="0" class="calibre5">The nature of an application dictates what kind of data structure we
use for the IR.  Compilers require a highly specialized IR that is
very low level (elements of the IR correspond very closely with
machine instructions).  Because were not focusing on compilers in
this book, though, well generally use a higher-level tree structure.</p><p height="10" width="0" class="calibre5">The first tree pattern well look at is Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>. Parse trees are pretty noisy, though.  They include a record of the rules used
to recognize the input, not just the input itself. Parse trees are useful
primarily for building syntax-highlighting editors. For implementing
source code analyzers, translators, and the like, well build 
<em class="calibre6">abstract syntax trees</em> (ASTs) because they are
easier to work with.</p><p height="10" width="0" class="calibre5">An AST has a node for every important token and uses operators as
subtree roots. For example, the AST for assignment statement
<code class="calibre21">this.x=y;</code> is as follows:</p><div class="calibre1"><img id="text/part0000_split_017.html.d24e692" class="calibre2" src="data:image/gif;base64,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" alt="images/intro/assign.png"></div><p height="10" width="0" class="calibre5">The AST implementation pattern you pick depends on how you plan on
traversing the AST (Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a> discusses AST construction in detail).</p><p height="10" width="0" class="calibre5"> Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a> is as simple as you can get. 
It uses a single object type
to represent every node in the tree.  Homogeneous nodes also have to represent
specific children by position within a list rather than with named
node fields.  We call that a 
<em class="calibre6">normalized child list</em>.</p><p height="10" width="0" class="calibre5">If we need to store different data depending on the kind of tree node,
we need to introduce multiple node types with Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>.
For example, we might want different node types for addition operator
nodes and variable reference nodes.  When building heterogeneous node
types, its common practice to track children with fields rather than
lists 
(Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>).</p><h3 class="calibre23">Walking Trees</h3><p height="10" width="0" class="calibre5">Once weve got an appropriate representation of our input in memory, we
can start extracting information or performing transformations. 

To do
that, we need to traverse the IR (AST, in our case).  There are two
basic approaches to tree walking. Either we embed methods within each
node class 
(Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>) or we encapsulate those methods
in an external visitor 
(Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>). The external visitor is nice
because it allows us to alter tree-walking behavior without modifying
node classes.</p><p height="10" width="0" class="calibre5">Rather than build external visitors manually, though, we can automate
visitor construction just like we can automate parser construction.
To  recognize tree structures, well use 
Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> or 
Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>.  A tree grammar describes the entire structure
of all valid trees, whereas a tree pattern matcher lets us focus on
just those subtrees we care about.  Youll use one or more of these
tree walkers to implement the next stages in the pipeline.
</p><h3 class="calibre23">Figuring Out What the Input Means</h3><p height="10" width="0" class="calibre5">Before we can generate output, we need to analyze the input to extract
bits of information relevant to generation (semantic analysis). 
Language analysis is rooted in a fundamental question: for
a given symbol reference <code class="calibre21">x</code>, what is it? Depending on the
application, we might need to know whether its a variable or method,
what type it is, or where its defined.  To answer these questions, we
need to track all input symbols using one of the 
<em class="calibre6">symbol tables</em> in Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a> or Chapter 7, <a href="#text/part0000_split_071.html.chp.aggr-symtab"><em class="calibre6">Managing Symbol Tables for Data Aggregates</em></a>. A symbol
table is just a dictionary that maps symbols to their
definitions.</p><p height="10" width="0" class="calibre5">The semantic rules of your language dictate which symbol table
pattern to use. There are four common kinds of 
scoping rules: languages with a single scope, nested scopes, C-style <code class="calibre21">struct</code>
scopes, and class scopes.  Youll find the associated implementations in 
Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>, 
Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>, 
Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>, and
Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.</p><p height="10" width="0" class="calibre5">Languages such as Java, C#, and C++ have a ton of semantic
compile-time rules. Most of these rules deal with type compatibility
between operators or assignment statements. For example, we cant
multiply a string by a class name.  Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a> describes how to
compute the types of all expressions and then check operations and
assignments for type compatibility. For non-object-oriented 
languages like C, wed apply 
Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.  For object-oriented
languages like C++ or Java, wed apply 
Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a>.  To make
these patterns easier to absorb, well break out some of the necessary
infrastructure in 
Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a> and 
Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a>.</p><p height="10" width="0" class="calibre5">If youre building a reader like a configuration file reader or Java
<tt class="calibre21">.class</tt> file reader, your application pipeline would be complete at
this point. To build an interpreter or translator, though, we have
to add more stages.</p><h3 class="calibre23">Interpreting Input Sentences</h3><p height="10" width="0" class="calibre5">Interpreters execute instructions stored in the IR but usually need
other data structures too, like a symbol table. 
Chapter 9, <a href="#text/part0000_split_086.html.chp.interp"><em class="calibre6">Building High-Level Interpreters</em></a> describes
the most common interpreter implementation patterns, including 
Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a>, Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a>, Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>, and Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>.  From a capability standpoint, the interpreter patterns
are equivalent (or could be made equally powerful). The differences
between them lie in the instruction set, execution efficiency,
interactivity, ease-of-use, and ease of implementation.</p><h3 class="calibre23">Translating One Language to Another</h3><p height="10" width="0" class="calibre5">Rather than interpreting a computer language, 
we can translate
programs to another language (at the extreme, compilers translate high-level programs down to machine code).  The final component of any
translator is a generator that emits structured text or binary. The
output is a function of the input and the results of semantic
analysis. For simple translations, we can combine the reader and
generator into a single pass using 
Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>.  Generally,
though, we need to decouple the order in which we compute output
phrases from the order in which we emit output phrases. For example,
imagine reversing the statements of a program. We cant generate the
first output statement until weve read the final input statement. To
decouple input and output order, well use a model-driven approach. (See Chapter 11, <a href="#text/part0000_split_105.html.chp.trans"><em class="calibre6">Translating Computer Languages</em></a>.)</p><p height="10" width="0" class="calibre5">Because generator output always conforms to a language, it makes sense
to use a formal language tool to emit structured text.  What we need
is an unparser called a 
<em class="calibre6">template engine</em>. There are many excellent template engines out there
but, for our sample implementations, well use StringTemplate.<a id="text/part0000_split_017.html.FNPTR-2" href="#text/part0000_split_019.html.FOOTNOTE-2">[2]</a> (See Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>.)</p><p height="10" width="0" class="calibre5">So, thats how patterns fit into the overall language implementation
pipeline.  Before getting into them, though, its worth
investigating the architecture of some common language
applications. Itll help keep everything in perspective as you read
the patterns chapters.</p>

</div></div>
<div id="text/part0000_split_018.html"><div class="calibre">

<h2 id="text/part0000_split_018.html.d24e999" class="calibre18">Dissecting a Few Applications</h2><p height="10" width="0" class="calibre5">Language applications are a bit like fractals. 
As you zoom in on their
architecture diagrams, you see that their pipeline stages are
themselves multistage pipelines.  For example, though we see compilers
as black boxes, they are actually deeply nested pipelines. They are so
complicated that we have to break them down into lots of simpler
components. Even the individual top-level components are pipelines.
Digging deeper, the same data structures and algorithms pop up across
applications and stages.</p><p height="10" width="0" class="calibre5">This section dissects a few language applications to expose their
architectures. Well look at a bytecode interpreter, a bug finder
(source code analyzer), and a C/C++ compiler. The goal is to emphasize
the architectural similarity between applications and even between the
stages in a single application.  The more you know about existing
language applications, the easier itll be to design your own. Lets
start with the simplest architecture. </p><h3 class="calibre23">Bytecode Interpreter</h3><p height="10" width="0" class="calibre5">An <em class="calibre6">interpreter</em> is a program that executes other programs. 
In effect,
an interpreter simulates a hardware processor in software, which is
why we call them <em class="calibre6">virtual machines</em>.  An
interpreters instruction set is typically pretty low level but higher
level than raw machine code.  We call the instructions <em class="calibre6">bytecodes</em> because we can represent each
instruction with a unique integer code from 0..255 (a bytes
range).</p><div class="calibre1" id="text/part0000_split_018.html.fig.intro-interp"><img id="text/part0000_split_018.html.d24e1052" class="calibre24" src="data:image/jpeg;base64,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" alt="images/intro/interp.png"><hr class="calibre17"><b class="calibre13">Figure 2. Bytecode interpreter pipeline</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">We can see the basic architecture of a bytecode
interpreter in Figure 2, <a href="#text/part0000_split_018.html.fig.intro-interp"><em class="calibre6">Bytecode interpreter pipeline</em></a>.  A reader loads the bytecodes from a file before the
interpreter can start execution. To execute a program, the interpreter
uses a <em class="calibre6">fetch-decode-execute cycle</em>. Like a real
processor, the interpreter has an instruction pointer that tracks which
instruction to execute next. Some instructions move data around, some
move the instruction pointer (branches and calls), and some emit
output (which is how we get the program result).  There are a lot of
implementation details, but this gives you the basic idea.</p><p height="10" width="0" class="calibre5">Languages with bytecode interpreter implementations include Java,
Lua,<a id="text/part0000_split_018.html.FNPTR-3" href="#text/part0000_split_019.html.FOOTNOTE-3">[3]</a> Python, Ruby, C#, and Smalltalk.<a id="text/part0000_split_018.html.FNPTR-4" href="#text/part0000_split_019.html.FOOTNOTE-4">[4]</a> Lua
uses 
Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>, but the others use Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>.  Prior
to version 1.9, Ruby used something akin to Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a>.</p><h3 class="calibre23">Java Bug Finder</h3><p height="10" width="0" class="calibre5">Lets move all the way up to the source code level now and crack open
a Java bug finder application.  
To keep things simple, well look
for just one kind of bug called <em class="calibre6">self-assignment</em>.
Self-assignment is when we assign a variable to itself. For example, the <tt class="calibre21">setX</tt>
method in the following <code class="calibre21">Point</code> class has a useless self-assignment
because <code class="calibre21">this.x</code> and <code class="calibre21">x</code> refer to the same field <code class="calibre21">x</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">class</b> Point {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> x,y;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> setX(<b class="calibre13">int</b> y) { this.x = x; } <em class="calibre6">// oops! Meant setX(int x)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> setY(<b class="calibre13">int</b> y) { this.y = y; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The best way to design a language application is to start with the end in mind. First, figure out what information you need in order to generate the output. That tells you what the final stage
before the generator computes. Then figure out what that stage needs
and so on all the way back to the reader.</p><div class="calibre1" id="text/part0000_split_018.html.fig.findbug"><img id="text/part0000_split_018.html.d24e1182" class="calibre22" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAB2AZADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKmralZ6Rptxf6ncR21nboXllkOFUDvXO6n41Wz1OytbfQ9avre6jjlW8tbbdAqv0LMSMYHJqx45j0K7tdN0/xJloLu/hSCPBIkmDbkU47ZHfiuI+O+pKH0XSDqVvYxyO91NHeSSQ293EgwYWkTlSSQQO+KAO01vxa2l67b6aug61erMFP2u1t98Cbjjls8Y70ut+LW0vX4NMGg63eCXb/AKVbW++FMnHzNnjHevCdJ+IOv6TbaZp2gWt5bQRrFcJY3zieaZZGYsiliHMSop2sATyM1oT/ABB8ZiGTUm1QRW/2WG++yDTdxUS3BSOLOckmMEk/pQB7NrfixtL1+DTBoOt3gl2/6XbW++BMn+Js8Y70a14sfS9fg0waDrd4su3N3bW++BMn+Js8Y714ZH8XvFt9r95HpctvLb3iiOyiaEZhZpvLRsAknuWVsHHpTPFnjHxS9yLSfV/tEED3sMflW7RG+IdIgCqnplmxg9s0Ae7az4tbTPEEGlroOtXiy7f9LtrffAm71bPGO9Gs+LW0zxBBpY0HW7sS7f8AS7a33wJu9WzxjvXDfCrxTqmq3zPeazaSWkFm5n0qK1cvZCNti5k7uQpJU8+lcRYfFfxjq+v3cOjz20sN4I0tY2gB8hnm2KQASThQSwbB+lAHuGs+LW0zxDBpY0HW7sS7f9LtrffAm71bPGO9JrHi1tN8RQ6UNB1q7Em3/S7a3DwJu/vNnjHevC/EXxb8UWcM2n2GoxSXtpdyhrqW0WLz0EoRBtJ6cnO3JwO1XtG8d+IYNXk+wxs1z4lknlh87LR2ohkCNKP+mYQMcd+KAPZ9Y8WtpviKDShoOt3Ql2/6Xb2+6BN3q2eMd6NX8Wtp3iKDShoOt3Ql2/6Zb2+6Bd3q2eMd68RPxR8TRia6g16yvNMuroWltKbZIpIU5LTOrMAoOMKGIyetdh8KfE/jLxZq6DVpobTTbGCN5SLcbrwuWK5OcIdoBOM0Ad9q/ixtO8Rw6SNB1u6Em3/TLe33QLu9WzxjvRq3ixtO8Rw6SNB1u6Em3/TLe33QLu9WzxjvXS+Yvr+lOBB6GgDmNW8WNp/iOHSRoOt3Qk2/6Zb2+6Bd3q2eMd6NV8WNp/iSHSRoOt3KybP9Mgt90C7vVs9u9dPRQBz0/i7TLbxbH4dvDPbX86BrZpYiIrjjJVH6Fh3FdDWJ4xv00nRG1JrJLyS2li8tGHILSKm4HBwQGJrbFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFU9Y1O00fTZ7/AFCTyrWBdzvtLYH0HJoAuUVzmieNdC1vT76+067aS2shunZonXaMZ6EZPTtRonjXQtb06+vtOu2ktrIZnYwuu0YJ6EZPTtQB0dFc5onjXQta02+v9Ou2ktbIZncwuu0YJ6EZPA7UaJ410LWtNvr/AE67aS1shmdzC67RjPQjJ4HagDo6K5zRfGuha1pl9qGn3bSWtkMzuYXXaMZ6EZPA7UmjeNtB1jS77UbG8L2lkMzyNE6bBjPQjJ49KAOkoqhoms6brtgl7o17b3to/SWBww+lX6AOc8X/ANi/aNB/twuJf7Rj+w7QT/pHO3OO3XrxW9c2sF0qrcwRTBTuAkQNg+ozWD4vOii40H+3A/mHUY/sO0E/6Rztzjt168V0dAEZt4TMsxijMqjarlRuA9AfSn7F/uj8qWigCGO0t4mDRQRIwzyqAHnk08xRlw5jTcOA20ZFPooAZFDFEXMUaIXO5iqgbj6n1NMhtLeA5hgijPP3EA6nJ6e9TUUAV7i3tW+eeGFjjblkBOPSvLfHHijw54X1261G08u/8WTxJbW1n5xZ8EgBFXkRqScscfWtH4z+J7rQPB+q3OnSBLuOEmNiudpyBnHtnNa3wz8K6Jonh2yudNiiubu5iE0+oviSa4dwCzGTrgnt0FAHPQeBfFOsR+b4q8YSW5mG99P023jWKLByAHcEnHHOKhk+H3i65vY7PUvHk8ug4LytBAtvdv6JvHAX3HNZPxJ8Ka/qXxKW+tYrs6bJFFE1w1xtgghCsJW4YFW5BxtIbHauU8OeE/EPi/SNP1TUGuryItcWqMlw8Qkt4YWSByARne4De9AHoepfDjw1YTWVtN4m8R2l3dy+Xbt/a0m53AyQAcjpz0qtHY/FDTNRuNLt7/SbjToR5sWs34O94+6NGvVx68CvO7j4b+JbTWtFa70TUdW0O3it7i8thekyST+UVlIJYHOcdCOlaaeBvG4jtre5tr+XVCYGtNQ+25jsbdQd8Djd8zYOM4Oc9eKAO0i17x9pmk/2840XxNoZTzf+JYrwz+X3dVbIbHpmvQ/CviGz8RaRa6hYPvt7mMSISMHB9RWd8PtHurD4caXpN+jWt0lqYZACCYyc/wAs15vo1nqnwq8T6NoV7qQ1PQdT3x2U7oElhlX5jGwHUEHg0Aeu+LNWfRNCnv47f7S0bxKIs4zvkVM9D03Z/CtcVheItcfS/DkupW9v9qdHiURZPO+RUJ4B6Bs/hW7QAUUVheKvFekeFo7Z9buWgW4Zlj2xM+SBk/dBxQBu0Vz+oeL9F0/w7ba5dXTJptxt8uQRMSdwyPlAyOnpS6j4v0bTvDttrl3csmm3O3y5BE5J3DI+UDI6elAG/RWBqPi/RtO8O2uuXdy6abc7fKkETEncMj5QMjp6Ual4v0bTfD1rrd3csmm3O3ypBE5J3DI+UDI6elAG/RWBqXi/RtN8PWut3lyyabc7fKkETEncMj5QMjpUl14q0Wz0Sz1e91CK1067KCGefKKSwyoOemfegDbopsUiSxrJE6ujDKspyCPUGnUAFFFFABRRRQAUUUUAFFZ9zrelWszQ3OpWUMq/eSS4RWH1BNR/8JFon/QY07/wKT/GgDUorL/4SLRP+gxp3/gUn+NOtte0i6ufs9rqljNPx+7juEZuc44B9jQBpUUUUAFc34e0zUbTxB4k1DVLuSSC7njFpCXykMKRgZA7EsWz9BXSHpWH4e0+9tbvX21B98N3fGW3BfdiIxRrjHblW496APBtT+IHiC2nXWJ73WbfT7nW5IrW5URNYNaRsQV243kkI3OetdBF8btR+zPJP4dW2FwIWsjI7YbzGPysAMltgL/LnIBr1C50zwnDbWmm3MWlpDYOZILeR1AiY55Ck/7R/Osj/hFfh5/Z32D7Fof2TzhceX5q/wCsAwGzuz0JFAHneqfGbVdW8FXN3odnaW06QxrPMZyHSSWRkTyUK5chVLndj0qez+NGsyWkZsvDhvI51VLOWWQo0xMojRpOMfNyflziu/j8MfD2K5sriOz0NZrPHkMJU/d4JIxz2JP51Pp+h+BNOlMtjb6LBIZ1uNySJkSA5BBzxgnOOlAHU6YbtrCE6lHBHeFf3qwMWQH0BIBNWcDBGBg1Q/tvSv8AoJ2P/gQn+NS22p2F1KIra9tZpDyEjlVifwBoA5/SLrS9M8b3nh3TNMhtJJbT+05pYVCq7FwnIHf3rq6wF1SEePDpJsFW4OnG5F5gZZRIFKZ68Eg1v0Ac54vfRVuNBGuK5kbUYxY7QTi4525x269a6Ouc8XyaKlxoI1xHaRtRjFkVUnFxztJx0HXrWrrrMmiagyMVZbeQgg4IO00AXqK8k8EeD9J1Pwppl3eLctPJbxs7m8nyxKgkn5+tbS+BfD5LBYp2KnBxez8H3/eUAeg0V5+PBPhtZVjeJxIwyEbUJwxHsPMqz/wgvhxB81nPn/r+uP8A45QB29FcC/grw72sp/8AwOuP/i6gfwboA6Wc+f8Ar+uP/i6AOe+O1vcyaLeLbgiRomC5HBODXRfAnWNAvvh3pFn4fkVDZwCKe0d8ywyD7wYdeuT+NcRr2hQ23jJbDS1kjgn03fJG00kgZvOxn52ODj0rybxp4Jv9K1Ga806S5tJzkGW3kaNiPQlSKAPsXX7qWz0LULq3jWaWG3kkRGPDEKTg14xY/GueDRNKjvdKjjurmzRpJIZVxHJIjFNsY/hG3nmuW+GfxusdB8MQ+G/HdjeFLeJoBfRKZhMhzw4+9u5PNZtx4y+DUeoafaWelanJp0rBLicmWNLfbnY5Qn5iMkZ7CgDs4vjBrUHhjQpNYsfsd9cC3uzOpWRLq2LMJCFH3G+Xoa734ZfEq38c3l3bxafLaNFClzGxcOrxOSFzjo3HIrmdOtvg7baY0kGqaU9nlGHm3pcIqEkKoJ4XLE4HrXA6p8XPDXgjWPI+GOkrqqMCt1cTzyCPaPuRxMc/KMk8DFAH0l4m1uz8N6De6xqjOtlZxmWUohZgPYDrXzbrvxBf4m+NdDk0+xms9H0qRpommx5s0rDGcDooHbrWB4u+I/i/4l2o0qW2g0rSJSPOt7Zi7zY7M57ewr0n4VeBRapFJJHggDtQB6ZJq1xovg97+K2+0yxtEoi553SKhPAPQMT+FdeKwfEF9L4d8Ny3drbfaZY3iQRc87pFQnjngMT+FbwoAramLltNuxYFVuzE4hLdA+Dtz7ZxXCXl5qngD4Mvd38i3ms2NoDLJNIWVpmYAkn+6C2foK7fW4J7rRr+3tH2XMtvJHE2cbXKkA57c1keG9GeDwFYaT4o8q8kSzWG8Mzb1kIHzEk9frQB41dfEe98G+KPst9qer61MLAsYJlhMF1cOyiMxFBlFyWGD2Fa/wDwuTW2iuoj4etYLmyhuLq4kuZnSJoo8AbPlJ3FiVwRwRXY2vhj4a2trPb29p4fSGdPLkHnIdy5zjO7PWr6af4EjsjaINDW2MC2xjEyAGMNvCnn+9z7nrQB59c/G++SSe5i8NO2kx+anms53bkQfNwMbd5CevNOvfjHrFlqkWnz6Ppj3Cskdz5Ny7pC7RmRl3bcZRR8w/Ku5/sb4ffaL2fytC829x57ecmXwwb145APHXFJdaJ8PrrVZdTuItCe/lOXmM6bmO0rn73oSD60AcB4a+LOsxeH7a61ZdKuY45oEup2uCjsZ23KsaBedkZBJOOhr0nwXfXPjXweLvxJpVjHZ34Jitg5mDwn7pfIAyRzgdM1Tj0D4dx3EcyW+gCWO3+yq3nJxHjbt6+nGetdZo0mm/YY4NHltntbdRGiW7hlQAcDg8UAZPgTVbPULG+s9NsxZ22k3kmmpGDkYjOMj0HtXS1zvg3WLfWF1c2titoLXUZ7VyoAErocF+Oua6KgAopk80VvE0s8iRRLyzuwUD6k1Q/t7SP+grYf+BKf40AaVFUf7Y0z/oIWf/f9f8aP7Y0z/oIWf/f9f8aAL1FVbbUbK5k8u2u7eaTGdscqsfyBq1QB5h8PNE0rUtX8bTajpljdyjXJVDz26SMB5cfGSM4rtf8AhE/Dv/QB0n/wDj/+JrmvhX/yEfG//Yel/wDRcdcP8SviPHD4hhu/Dl5M1xpNtex3cBhdvJkDois6emckE8Y56UAeu/8ACJ+Hf+gDpP8A4Bx//E15j8bvDHhu2PhK5ksoNLiTVlSS8sYfKkiQxvyGQZ+8FP1FczpXxV8ZSaes4WG/+13smkW2y3UGO4IRoZGIOCCC+QOOK3fAXxE1jVvicugapd211aFrmMD7MsbI8RG0gdQThuvXqKAO2+HXjWz1i5n0GbU4r7V7KMSeciMn2mEnAkwQMNnhh69ODXd1xmqFIvippMpVQx0e7BbHJAlhwM/iay9V+KOl2t7c2scV9M8DmNmht9y7h1AOa0pUalV2pq5nUqwpq83Y9CknjRgruqs3Cgnk/Ssjw7Y3Vnd63LdT+bHd3puLcbidkflouOenKscD1rxfxl4t/wCEjm02O2i1C3FvO03msnllPkYAg565NXfAPjGXRry4tdfu5bhr65MqXj8Ip2KoQ/3fu5z0JNdkstrql7W3qupzRx9F1fZX9H0Ok0nw3pGs+J/F02p2FtcSrqe0PJEGbHkxcZPatoeBvDQ6aNYH6wLXHX3ii80PUtTbSoLKWbVPEq2Qa8dkjjDW8Z3Erz2rLuPjJfR2pMGn2Et3beb9riXzGXak3l70fIARuxOeQa887T0lPA3hrvoenf8Afhac3gzwsg/5AGmk/wDXBa4bVfiN4ngi1i8tNF0yTS7HUDYeYZZGlOMbnKDGQAeg5NZa/FrVr2W0XSNHttQUwRTztGXUEPIy/JuI24CnO7vxQB6I/g/wz20HTB/2wWuQ8aaVpuh6r4VutEsbaxuf7TVDJBGEJUqcg47e1d+t1FOXEUschjbawRg20+hx0NcB8V76K0PhyeZtscWpK7EjoNpppOTshNpK7PURqtv/AMJTb6a9uPtklg90LjA4QOqlfXksD6cVr+aucZwa8puviloi6jBFE6v/AKOWN0IzhSGA8vpnnr6cVw/hrxTqumkXVpcPcWs08kk1tMxywLnDITypxjjoa7aGXVqyk0rNd1a5y1sbSotXd0+3Q9u8Xy6LHcaCNbjd5H1GJbIqpO2452k46DrWp4g/5AWo/wDXtL/6Aa4OLxf4Z12PQpL8PNJ/aUcdquw7obnnbvH8Peu714htA1Ej/n2k/wDQDXHKLg+WSszqjJSV1seVXmrajoXwTsb7SMrci2tlMoTf5MbYDyY77RzXmjeI9f01NSTQddllsb3VpS+vTKED7YlKjJGFBPfHOMV7X4f1nTfDvws0jUtZmWGzjsoQ5K7txIACgdyfSmW/j7wzdafctva2hgt/tUsN1amIiMNtztI55IHHrUjPI7631O7vpPFOo3SX2pxf2XCqpCTEFlJDlDwccZ6d+a0ZfGHjOzMuopezXxuYNRMVk9qAkTQN+7K45JI9euK7a7+KvhGGd4WuJ3cEoNlo7B3UA+WpxywB6VmN8V9Cj8RJayKRpkllFdwXyRMQPMYqd4A+QDHJPegB/wAGtc1vV7HUTrWpwaiiPGYpVIMkZZcsjYAH09OlehM2a46Tx54fju72xsZ0e7iilkXbGRDNIiFyiuOC3qBT9E8d6Rqmp2umRySnUZIYnlWOFmjid0DbGfGAee9AEzIH+J9qGGR/ZY/9KK6Dxro9lNaOXVc4rmNSnFt8RbeQ8AaWv/pRXkWs+KPEV/Le/aNa8Qr4h+3Ns0iO0UWYgD8Hee2z360AT/D34daJ8RJNam17V5bC/huzaw2Fu4jaHackkN/rCy+nSs740fC7w54Olsm8N6ncSXN1Olsumu6zYbqzM2dy/L2x1qv4l8GSX+pNqFtC8V2W3CeFijg+oYfzrQ8DfD6RNWS7uIGkuSctPKS7sfUseTQBz1h8MHuiGWBSD3213nhz4SE7fMi/SvefDehwW9ookjGQPSugit4ohhEAoA808O/Dm2sSrGJcj2r0XT7KOziCooGPSrdFAGR4s1SfRtCnvrS2+0zRvEoi55DSKpPHPAYn8K1iwAyeK5nx/wCJm8MeG7zU4oRO9uUPl8/MC6qenfBJ/CuQvvipYPuWG01TqQM22P61tSw9Wqr04tmVStTp6TkkejamwvNOvrW1nVLh4XjVg3KMynBOOnXNczPp15pPwevNP1O4+03tto00c024tvYRNk5PNeN3mualdatreo6XPcWMt4qxgTDAdQm3lc8Edj1Fdf4b8TxS/CzUdEu7lpNVs9HmjmEhJZj5bfOCfvD3roxGX1aEFUa0f4ephQxtKtJwT1X4+h2OgeHdJk0PT5H0vS9zW8ZP+gxH+Af7NX18N6PnH9kaWf8Atxi/+JrnfGE+o2fws8/SXkjmS2t98kTASJF8nmFM8btucV5H/wAJFrN7pE/9i6hr03hmLVpIHmlMjzxxCFSikoN+N+7p+NcJ2H0GvhvRBy2jaV/4BRf/ABNMk0HQh00TSf8AwDj/AMK8atZPFd3c3F3cavrrjT4dLe1wpiSZnZVnLRkZPyk5B6V7bNIN7BTxk4oAz30TRB/zBdJ/8Aov/ia5vwLssvin4ntLKGC3tXS3JihiVFz5fXA4rqpH4OTXm1j4l0/Qfitr8uoXCwq8cGCwJ/g9hVRhKbtFXYpSUVeTset+GtVtdTs7qW1t/s6RXlxbsuB8zxyFWbj1IJ9ea11kVuhrxHXPiXpt/wCHtVhsibWeQXEUaKhDOeQJBgfxdfWqXhXxte6BDbWupSTXthwonY7pYBjo395R69RXZTy+vUpuajt0/wAjlnjaUJqDe/U9L+LUMVz4Na3uEWSCa9s45Eboym5jBB9iKl/4Vv4NP/Ms6V/4DiszxxqcGpeDIZbeRZEa/sSGU5B/0mPvXoFcJ1nDf8Kl8B5/5FjT/wDvlv8AGj/hUngP/oWNP/75b/GvHPEuv61Y+O9Y1KHUZvKsddihKLqmHMJ2Axpa4+fO7r9fStdvjRq8x0e2tDpv2i/tEM0z/cspWnMe+UZ+VQB0OOcUAS/FXwL4V8M654SvdPYeFbZ7maO41K0kMXlnyi0e4k4PzKOD15Fdl8JviRF4kvbrw/qd9YXWt2aeYtzZODDew9pU9D6r2Nafw31hvGvhq5k12PTL9rW+mtRLDHuhm8tsCRQ2etZfizRtO0/4o/D+50+zt7WVpruJzBEqb1MJODgc8igDQ+Ff/IR8b/8AYel/9Fx1cuvG3gi0v9SgudT02O6hVlu9yYJxgMpOMMRkAgZPNU/hX/yEfG//AGHpf/RcdZF/8MNUuftVvF4gii0+O7fULCH7EjGOdpRL+8J++oYEY44NAGrq3xG8E6ToLajBd2U6qryRQQx4dnj4IxtyhGQMsB1rU0DxV4V1XVoraxnshq8qeaYhH8+7aCw3YwWAPODkVwUvwd1USalfW/iG3XVdajmh1SR7TdG6yEH90uflIx1Oat+BfgzH4W8bR60NTFxbQNLLDGYiH8yRdrZOcY64wM9M0AdH4n3f8LH0nb1/si7/APRkNeI6rb6jZatqXm6fdsr3LyK6ICCCeD1r3nVEEnxR0hT0OkXf/o2CreoeG4bksSgJNdmDxk8JJygk79zlxWEhiUozex81/wBossyRywXERckKZEwMgZ9amhkmv7oWVpGJZXHzFhlEHq3+Fem+Lvh02pG3WCU24jkLMyL8xBUjA9OtWvAXw+/sWW/3gGKa582IZJIXYowc98gn8a9WWdv2Oi99/cjzVk8fa7+7+LOL03R/D9r4ej03xhdSvbx+J8IzKNkshgQ7ZCT8qYJ5z2FejXvh3wPqFraedp+iTW1nCWtyGXbHEGzkEH7ue54zXJeJfD1/q11qK6Ra2d1Jp3icXjW92+yORVt4/lJwfWueuvhz4ntdMvI9OTS5ptUsLm0uYnmKR2nmy7wIuOVHTFeBKTnJyluz24xUUkjvb288IajqMnhy4sIpftV08rKY/wB1JKsYcybgf7uOaba6X4K16/8Asdrp2m3jaQkW14wGSNXJZVDKeeVJIPSuIPwx1t7y6fz7SJZYpI1dZCSC1qsQOB/tKfwrsfhtoOq6TcajLrNhptgJbe1t4orB9ykRKwLNwOTmpGZej+KvDnhWz1CCG31hpG1eSCUm0JknunyxCjPzADH4Yrn/AIieILTX9F0LUdLM0kP9olSjJtkV1BBUqejD0rY1fwL4g8RXUiajHb2lqfEP9ph7a7Ik8gxhDg4+V/lB/GqN/wCFL3w/pXh7Rr4QTQQ6yRb3UZ+e4RgW3SDs+Tg+vWtKVR0pqa6O5FSCqQcH1OTl1WSK5W3ktrxZ2QyBCnJUHGevqRTo9TR7cTFyiH+/wRzjmvX9S0K1bxBbaULYGeSxa783jhVdV2+vVga5nR/hg0F2z37i52zM8ShcKgJJHHc89a96hnV1J1V6W6niVsnV0qT9bnNeGbaCTxJomoask9vGb+NLMIuWmm52l/RR+dfR2qZPhvUN3/PtJ/6Aa4660vRdIfQBrMDySTahHHZlFztnOdpPoOvNd7qFqbjTLq2jIVpYnjBPQEqR/WvFxOJliantJnr4ehHDwUInmdlo7eIfhPpGmrLFEZLOA5mgEyHABwVPY/nXK3XwtlMvhSymuJ76Cwu5rm7upGIBiOGFuq5zt3AY9MVN4rbxNovw2vNHuvD6iK2s0t2u4r8YIBUbgAuefTPelt/CYkUM/gqIE8/8hI/4Vzm5sW/gIQ3um3AvZCLLWptYC7PvGRcbPoPWsSb4V3XmTLa600Nrd2gsbyP7MGMkIlaTCn+E/NjNaUHg21JG/wAIW6/W/JrXtPAuktjzfC9qvrm6Y/1oA5+1+Ff2eZLZNTk/sO2knuLOzMQ3RSyxlCWfqyjOQKvaT8NprLxVY6uNSKx2qoPLhg8tptsYTbIwPzLxnkZroH8D+G40/wCRctWb/rs/+NUpvCOhLnZ4XtD/ANvDj+tAEeuWTXHxBiQKc/2Uvb/p5oufCjm8LSBguc81Wi8F6HLqJll8PWsKCMIMSu5J3Z9eK53RtRfQb/xxZaaTHBFO32aIsSqN5fGMk4GaAOj8R65onhe0jikjN7qUrrDBYW+GnmdugC9ce/QVDC3xFtR9rHg/SDbqN/2eLUP9IxjOBkbd3tVn9nzSdEu/BVj4hSx83XrjeLy+uk3TPMGIbDH+HPAxxim6v8Ur3w54g8TDV9Me50LTruK3W6hdVMJeLcFK9WyR17ZoAvWL/FC9tRdC08PaXj51s55JJZHHZXZeFPuM1Uj8d+NLG6k03UfA97d6pHhy2nyq1s8Z6MsjY57betSr8Y7WdtKtrDRbm51LU7WC5trUTKpPmlvlLHgYCk5qvpXxqtb/AFXS7KTQ7m2+2ssbPNOoCMWKkLxh8Ec8jr3oA2dC+JcdxrEGkeIdG1HQNUuM+RDeoCs3+5Ivyk+3WvQYpFkTcpyDXJfEnwavi/TbQR6jPpt9p832q1uYgDskAI5B7evtWJ8GfFVx4g8M20uoEG8QvDMyjCuyMVLKPQ4yKAK/xs+0jwfqH2aGSaT93iNASW/eL0Arx64mu4XYS6ferg94x/jX0j44kmstBuLyztftVwjxqsWCdwaRVJ454DE/hWbqvhKCUMVQdTg4rvwmYVMJFxik0+5xYrA08S1Kbeh88x6mjLKXDxeUcOJBtxxmrcWl3WraXqF8S9vaQWU7qy/LJIfLbj2X+ddxffC8XGoahOXLeem2KMj5Y2243H1Oa6Kz8JSaB8Kb+1vXEt1b6RMkkgz8zCNuea7cVm7nTUKa1a1f5pHJhsqjTqc8+j0/4JteINQ0jTfh2bjxBbm50pLOH7RCsfmFwQgA29+SK5O1+IXhjw5c22iWWk3mloGTzYjAkP2fzSAhZd2TuyDxnA5NdRqGlwa/4Nh0y7d0gntrfcyfeG0I38xWJq/gWzvvE41uC/u7S5YRCdI1RlnEf3c7gSOBg4614Z7BWPxZ0PbJPcQ6lbWIWUw3UsGEuGjba6pg5JyRj1zQnxL0wvHb3Gn6vFqTzrbjTxbhp9zLvU4BxgrznNYmgfCiD+yprfxLfXN5u88Q26PiK18x926Pvu4Xk+ldBo/w+srDUrTUp7+9vtSguBObm4ILSYj8tVOP4QvpQBc8J+I5fENpfPLpt5ZG3uZYAZ49oYI5UYOT83HI7V5P4oknT4i66YoJ5tyQD90ucfL35r2jQPDI0e+1SeK/u5re+lacWspBjhdiSxTvyTXM6VoyXvxS8RRuAQFt/wBY66MLiJYap7SKuzDEUI4iHs5bHlQ1sGKSQQ3flxsyO2zgFThh17Gp5NQCBMb3dyAiIMsxPoK9Mm8Mw+INH1E2UAtiLi5s+QD8yOULcepGab4V+Ha6e4aUtPOcbpXHP0A7CvZhnf7tua97ol+p5M8nXOlB6dTD0bSLzTPDFxLcTER3OpWDrar9yE/aY8ke579q+gb6+tNPg86+uoLaHON80gRc+mTXC+N9NSx8IRhRg/2hY/8ApTHXR+LfDsfiJdLjuPJaC0vUunjlj3hwqsMY+pB/CvCrVZVpupPdntUqcaUVCOyKB17wS9/eXJvNFN5ZASXExCb4skAEtjPUjvWN4gvfh9q3hze+q6ZZ2uozBEu7Vkjd5VYHrjnBAzuGPWvNNf8AgbqVhp+qSabNFfybj9lj+YtJ5lwjnzFJ2gKAcgda6WT4R6y17qOpre6KL/VoZra6gNowt4EkVFDQqDkONnJPWsyzpvDfiTwN4PlsfCem6vFJeT3TReWG8xzM2WJcgYGTx+IFWPHX/JRfh9/19XX/AKIasnwn8KpPDUNgtve2lzJa6wdQ82eA73iMRj2Eg53c5z0z2rW8df8AJRfh9/19XX/ohqAF07w34n0PVNcm0W/0VrXUr1r3bd20rOhZVUrlXAI+X0rR8vx3/wA/fhn/AMBZ/wD45XW0UAcl5fjv/n78M/8AgLP/APHKPL8d/wDP34Z/8BZ//jldbRQByGk6Jr8niyDWdfu9LdbezltY4rKCRCS7oxJLMemz9a6+iigBjRI3UA1keHtKn0281yWeUSLe3puYgCfkTy0Xb+ak/jW1XNWGmX+i614g1AXD3mm3m25jskTMqTBQrBWJAKkKuAe+aAOS1bSvF+l+IdYl0WHS7ixv7n7UpmEm9TsRCpwcfwZ/GoM+Pz/y4aL/AN8y/wCNd9puuz3tndzyaFq1o0AysNwkYebjomHI/MijTddnvbK7uJND1a0aAZWG4SMPNx0TDkfmRQBwQ/4T7/nx0X/vmX/GnqfHo/5ctE/74m/xrutN12e9sru4k0PVrRoBlYZ0jDzcdEw5H5kUabrs95Y3dxJoerWjQDKwzpGHm46JhyPzIoA4pZPHo/5c9D/74m/xqpf6R4r1y+0ltXi02G2sbn7V/oschdyBgL8xwOvWvQNO12e8sbu4k0PVrVoBlYJ0jEk3HRMOR+ZFJY67c3enXtz/AGDqttLbrlLe4WNXnOM4TDke3JFACjUoh4nttGe2/fvYNdefkcBXVSnr1bP4Vqi3jBzgVi+D73WtTtZr3xDpEOkys5FvbiUSyrF/00YcZJ5wOOldBQBzni640a2uNBXWbd5pJdRjjsiq52TnO1jzwOvNdHXOeL7rR7a40Fdatnnkm1GOOzKrny5znax54HXmujoA5L4s/wDJO9b/AOuI/wDQ1rjvi+dVmn8Labpt99lgvL2RZwHdDIEjLhdykEDj867H4r/8k91r/rkv/oa1X8Z69onh+90b+3VhVbm5kiguJsBYGCEkknpkcUAeV6R8RfEkOiA2kdjLDp2mR6jcSXjSSTTK07IUDZ64HU0SePdV8ReM/CcsN3bWWmPrktoLCNj9oZEj+9LzgqT0GK9OVvCrWkxgOj/ZWtlMpV02+QWypPP3N34ZrM2+CU8TySoNDXX48OzhkEwwOvX0/SgDsHk9TVd5Kz9N1jT9WieTS762vERtrtBIHCn0OKs96AFZia8eaze78ReNVQZ/0vBH/ABXsIFcb4BtI7nxl41STGDeAf8AjgoA8f8AD3xS8UfDKwfRo7G21TSoXZrdZyyyQqTkoCOo9M161pM3wt8W3Q8VTalYfa5gslzBPemNPMCY+eJiASASM4rl/i34dsYo7r7OYZLxULJBvAZjjIGOteW+HPAnw81nwydU17x4tlqSwbri2MIU28rHhdpG5wO4GfwoA9zh+G3g/wAS+G3ufh7f2295Y/8ASjK821ULERjkNHjPGMce1Yt1YfC34fy+HtP8U6l9r1a1Xczxuzxl0bcGlRSQME8Z5r578OeF7y9jkaxnuPJMrKskLNEJVBwH2g9xzXbaH8LLiWQO8Tbm+8xySfqe9AHTfFb4oy/EC/tNJ8Hz6na6MoYXcoJh+1Z6Ljrt969T+Dujtpul28KJsjRQFUdhWJ4K+GUdm6PLHyPUV7NpOnx2MCoigYFAFfxXqN3pWhTXmn232q5R4lWLaTkNIqscDngEn8K1iAwwRWT4s1C80vQp7vTrb7VdI8SrFtLZDSKrHA54BJ/CtcUAUdUsftemXlvCwjlmheNX/ukqQD+tYml+G7qD4bp4cursSXf9nNZPckFgWKFd3PJ610d5brdWc9u7MqzRtGWQ4IBGMg+tct4dt9S8GeCrKxvY7rXbi1PkIbNAZGjydpbewyQMAnPWgDmIbfxrawx22/RWEKrEG+yT8hQBn73tUgj8Znq+ij/tzuP/AIqu8vNYmt9Ghv10fUp5JNubOJUMyZ/vAuF474JovNYmttHgvl0fUp5JNubSJUMyZ/vAuF474JoA4ZYvGPeXRB/25XH/AMVUiJ4wH/LfQ/8AwCuP/iq7W91ia20eC+TR9SuJJdubSJUM0ef7wLheO+CaL3WJrbR4L5NH1O4kl25tIljM0eR/EC4XjvgmgDj1Hi8f8vGhf+ANz/8AF1L4Q0TUbXxXf6rqc9vNPfbMrbW7xJGEXaPvkk5rqr3WJrbR4L5NH1O4kl25tIljM0eR/EC4XjvgmqviHWtVtPDkV7o2gXV/qExVVsnkSJoiw6yHJAA74J9qAJ/Dmowa1Z3csdt9nWG8uLYrkHc0chUtx6kZrWSBE6KKr6OLoaZbHUYreG+ZA06W/KCQ/e2k9RnvVygDn/HWj3eueHJrPTZYIrxZYZ4mnBKFo5FkAbHODtxx61heb8TP+ffwl/31P/jXe0UAecG++Kn/AEBvCh/7e5v8KPt/xV/6A3hT/wAC5v8ACvR6KAPOPt/xV/6A3hT/AMC5v8Kr2ukeONZ8aeHtS8S2mh2llpUksv8Aoc8ju5eMpjDD3r0+igAooooAKKKKACiiigAooooAMUYoooAMUYoooAMUYoooAKKKKAOc8X3mkWtxoK6zbNPJNqMcVmVXPlznO1jzwOvNdHXOeMb7SLKbQv7ZtWnM2oxRWrhQRFOc7WJzx35ro6AOS+LH/JPNa/65L/6Gtc98TdE1PWrjQ7vR4tPuJ9LvHuTDfEiNwUKgdD611/j3SrnW/CGqadYeX9qni2x+axVSwIOCQDjpXJPqHjNmY/8ACLWXX/oJH/43QB5tc/DPxJZ2NxbaZcaXLHqOnLZXnnFl8nEpk/dAfw84APTFY1t4Y1f/AIS0eHotOjudOs7m5uWvrmBk80yxBdpfPzLngY5r1/7Z4yP/ADK9l/4MW/8AjdH2vxl38MWP/gxb/wCN0AY/wq8N6z4cs7+HWZonWWRDbxxyGQQoq427yASPTPSu8C8D3rnRd+MP+hYsf/Bi3/xupFvvGA/5lew/8GTf/G6AOkVPyrh/BMhh8ZeNSvP+mj/0AVsLqPi8dfC9h/4Mm/8AjVN8BaDqsOt69f6xaxWz6jP56xxSGRUG0DG4gZPHpQB5DrPgC6fxPdXx1BZkmvPthd7YG5B/uebnhPYCj/hXhu7wStbqWB4OwcV9DNoETTbyorSt9Nt4QP3a5+lAHnXgvwRBaxJ5sYGPavQrXSLS3A2Rrx7VeSNUGFAFOoAakaIPlUCnUUUAZHiy/vNM0Ke70y2+1XSPEqxbS2Q0iqxwOeFJP4VrisjxZf3um6FPdaXbfabtHiVYtpbIaRVY4HPCkn8K1xQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAU9U0yy1WBIdRtormJJFmVJBkB1OVP1BrKtl8TDxTKbm50ltBO4pGkUguBxxls7eue1FFABbDxL/AMJTKbi40k6B83lxpFILgcDGWJ29c9qLUeJv+EpmNzcaSdA+by40ikFwOBjLE7eue1FFABajxN/wlMxubjSToPzeXGkUguBwMZYnb1z2otR4m/4SiY3NxpJ0H5vLjjikFwOBjLE7eue1FFABaDxN/wAJRObq40k6D83lxxxSC4HAxlidvXPai0Hib/hKJzdXGktoPzeVHHFILgcDGWJ29c54oooALMeJv+EonN3caS2g/N5UccUguBwNuWJ29c54osx4m/4Sec3dxpLaD83lRxxSC4HA25Ynb654oooALIeJv+EnnN3caS2hfN5UccUguBwNu5idvrniiyHib/hJ7g3lxpLaF83lRxxSC4HTbuYnb654oooALEeJv+EnuDeXGktoXzeVHFFILgdNu5idvrniixHib/hJrg3txpLaF83kxxRSC4HTbuYnb65wKKKACxHib/hJrk3txpLaH83kxxRSC4HTbuYnb65wKLAeJv8AhJrk3txpLaH83kxxRSC4HTbuYnb65wKKKAEsLHxEfFFze6hq9sdHAZLfT4LbBOSMPJISSWHPAwK6KiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9kAAA==" alt="images/intro/findbug.png"><hr class="calibre17"><b class="calibre13">Figure 3. Source-level bug finder pipeline</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">For our bug finder, we need to generate a report showing all
self-assignments. To do that, we need to find all assignments of the
form <code class="calibre21">this.x = x</code> and flag those that assign to themselves. To do
that, we need to figure out (<em class="calibre6">resolve</em>) to which entity
<code class="calibre21">this.x</code> and <code class="calibre21">x</code> refer.  That means we need to track all symbol
definitions using a symbol table like 
Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>. 
We can see the pipeline for our bug finder in Figure 3, <a href="#text/part0000_split_018.html.fig.findbug"><em class="calibre6">Source-level bug finder pipeline</em></a>.</p><p height="10" width="0" class="calibre5">Now that weve identified the stages, lets walk the information flow
forward. The parser reads the Java code and builds an intermediate
representation that feeds the semantic analysis phases. To parse Java,
we can use Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>, Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>,
and Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a>.  We can get away with building a simple IR: Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.



</p><p height="10" width="0" class="calibre5">The semantic analyzer in our case needs to make two passes over the
IR. The first pass defines all the symbols encountered during the
walk. The second pass looks for assignment patterns whose left-side and
right-side resolve to the same field.  To find symbol definitions
and assignment tree patterns, we can use 
Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>.
Once we have a list of self-assignments, we can generate a report.</p><p height="10" width="0" class="calibre5">Lets zoom in a little on the reader:</p><div class="calibre1"><img id="text/part0000_split_018.html.d24e1368" class="calibre24" src="data:image/jpeg;base64,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" alt="images/intro/findbug-lexer.png"></div><p height="10" width="0" class="calibre5"> Most
text readers use a two-stage process. The first stage breaks up the
character stream into vocabulary symbols called <em class="calibre6">tokens</em>. The parser feeds off these tokens to
check syntax. In our case, the tokenizer (or <em class="calibre6">lexer</em>) yields a stream of vocabulary symbols like
this:</p><div class="calibre1"><img id="text/part0000_split_018.html.d24e1382" class="calibre25" src="data:image/gif;base64,R0lGODlhyAAlAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAADIACUAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMFWKm0mzps2bOGsOpLkzp8+fPAUG/ZeTIFCfPcUlxblUp9CZTW+SxOeuXdWrVrNi3aq1a7t37Ma9a/e1HTp4XbmqTcv23biy7t6VY1sVXrmzZNfqdedO3div686hXdsO3rl1Y7nCS8fu7zty+BLTbac0ZLt75zJr3sy5s+dzBxqXc3fgnDp4+OCV/sy6NWh35d6tO4BO3ll0nQ/IO0za9ed370gfWNdX9ecD8dT1Xa3ZHNh3+A4cgO0uuucD6eBVBmlWeunvoEH+gx8vPrz0c+YQk2snPTtic+bLkz8/P765dqPVwY+H7p188fGYBlt89BH43XRVmWOOOu2cZk595izmTjrkmVOdO+so2M59GRII2lnbfdRdZquVSGJ4KJrIXHqPufOgX+vAA198KZ5Yo4qZ3Rebfufw9w468wWo3Izg1XhjcOwdwKCDNh4oIYUonhNbYxnqiCGR5h1wj3YijWiikVF+eSKL5LiIHTzvhWmjkcwx1xx+7/DoI5CcmSOki2qCWWJwZi4pI5gRptPXjOE5F1mVG7bToZug3eNWl3SyeeKBX3qXo3p9yvYnjeRlCdqD5oGqY5z79UcneHYKWA6JoHJ6Xnj+cSXpJ5aTPllaqxZSqeFoHbL63ZYheuSlpJuFZpiJ0N2K6YPuvQOfm0XaeA+Q7ST37DrJSQennKZ+d1Y6qQ6JHjvHFptZOpEegKR0s2pW5AESqlNOdnROKZuGHBJ5TzzCOToOpAemSOmt78xzqnT1/ElmpjESekCrJBY4j13rADDPh/TUc4+2O5b6I8EXI6cqeu6EHLB08+ApHZ8vNvjnq+LBKyiPE8Nn6L1WLooOPfOoIx2wAGeGW3i4lZZOOigWfQ46uNHzjrItMoums+KlE9iB6EwrHTr1BGghAC7GA0CHo3L7MXb1bCiyuKUNjdvRGBtG4rpKugyf0rSBZqv+OezU43OuOCdKtjr1pLOqllxaBuRw9bDzYDv0qJPOPPXU03NsFwtWDz3y1PM0essqqemM8VSedmnumN7OOfIAAIBxrb8DANXobevx4u/Us/idq953MTw8Vw4POvMA4Pl3LNd92l3zBKil0+XE+yDXzt6MKK/PqkOPu/4CTFs9u+lGD/GRa789PACc0w7Y6sQOdZlSI/bw+uwIBgA67IDd39jpgF90OvQAwG7e1LEedcsc8pjHre4En9jUw37xSIfs8ME1/sBqLOyyW4QAcI/RAEBeEZzQd+SxG8AhKl9SwofufpU47tBpg+dIBwAUBQB8lKMc+ZOg7uYxD3OU4x7+xwNd1ETXsK+9A11Imwc9jka4eBwgYYc7R/GMcyvbGfBjUnQienhHsgeWTkoyxI/TQKWuqmTQQQsCgOMSiB7pSSl1hnvO9a4UQx6ap3uK+4461Lg+dKyPQsMBgA53psUDOO19ZmrWauBRD+O5Q4rGM12AumYz2RXPcTmy4pzM0T8qMlBK79hePMbHSbCVgx7GAU3y2nUOesTjHmB7kK1I9kF7nVBR5rhHAHnUqBaK6FRZnIc85vJBBeUwdzuTB6g8Z7PQwUhG2FEHOlIDNh6q45rQOUfCHlQx/tBjfFUs4Jxo48rvcNFCXtxeKTc0xgvKym7oyR0jAenG0RTOlrv+oqM6mnfHR1FESTNRxzn+MQ51kGMgI6KlGucFgACx7nwPZKTPZPe5hcXvac7hYDn2+BVBpqdx2nTiznSHw4aGk1RXXJwwASSgBuauR6SUIWzKOTczKu9lhDOp3gQFJeRczIT4wqWU+nYqoAmEHOr414ICig6ErG8c5BDgPw7wQYSmC4jgPMD6MlYPGzLyHLqsXMYq6szRKSljGbsY8QAQQIeKDR6ywyS81Dg/cXYLXtsDzTndIcrtYWeG5XCfKvnSMiaBpnX4eJb0SrNNoOYse+BslD//sceBro8c4xBgsAQyDnMQ5YZEMce/BDIs7EAJNOloBzs2piWk0cYq90D+FyIv+iz8gWVxthXo1iQnuRKhQ3K1s+vZ9pjYtakMHUiLbXikSZveDvadTHrYKF9oK8bNxnpBHVzhnmVUgppDKZ39bDkqktCT5UhBJXqWdB70KosS8WUPQy+rFOQu9j7LV8FF6Tj19lMuyue+ZGxVGftkN+ysD09tnNmD5KFFx+KHjt+bByDx6MJORYtTknJvswh1I3dJKlplu5235KGfT1bqw2WErozu47/VBKov85IHlByMQtTK42mI2yxHLsMo37jGHJEpE7vQtCkfG1mrOyrNfov1SSNvZpXwXBpnZLYcG1mPYxhqU4m6+5H6lUNBYA6zmMdMZh/6ZT03dBTuYr5c5ja72YcPNhxy+iOlMN/QMAxi85vFPJqx3DC1fmGznhUUPUF1kM/uaIy8cHgfefHZh/3R8Uaqso5KW/rSmM60pvHhF3iQA03EQROJ8aHpUpsa03aBR1/YYZt4sOPS+CD1xbClDlKfWtP8AjVf2mdpW1ea1CTmy69/3b7GyMZBcak1rCtdLUlrJEbvgKu0o03taVu72tiOtjrEUe0MYfva4P62uOEqDmirehzkyjZcyQGvcbtb2qurdhzDTW2khls1p6F2Qe8d7XXE5N8AD7jAB07wghv84AhPuMIXzvCGO/zhEI+4xCdOcZMEBAA7AAA=" alt="images/intro/findbug-tokens.png"></div><p height="10" width="0" class="calibre5">As the parser checks the syntax, it builds the IR. We have to build an
IR in this case because we make multiple passes over the input.
Retokenizing and reparsing the text input for every pass is
inefficient and makes it harder to pass information between
stages. Multiple passes also support forward references. For example,
we want to be able to see field <code class="calibre21">x</code> even if its defined after method
<tt class="calibre21">setX</tt>. By defining all symbols first, before trying to resolve them,
our bug-finding stage sees <code class="calibre21">x</code> easily.</p><p height="10" width="0" class="calibre5">Now lets jump to the final stage and zoom in on the generator. Since
we have a list of bugs (presumably a list of <code class="calibre21">Bug</code> objects), our
generator can use a simple <code class="calibre21">for</code> loop to print out the bugs.  For
more complicated reports, though, well want to use a template.  For example, if we assume that <code class="calibre21">Bug</code> has fields <code class="calibre21">file</code>, <code class="calibre21">line</code>, and <code class="calibre21">fieldname</code>, then we can use the following two
StringTemplate template definitions to generate a report (well
explore template syntax in Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>).</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">report(bugs) ::= "&lt;bugs:bug()&gt;" // apply template bug to each bug object</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">bug(b) ::= "bug: &lt;b.file&gt;:&lt;b.line&gt; self assignment to &lt;b.fieldname&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">All we have to do is pass the list of <code class="calibre21">Bug</code> objects to the <code class="calibre21">report</code>
template as attribute <code class="calibre21">bugs</code>, and StringTemplate does the rest.</p><p height="10" width="0" class="calibre5">Theres another way to implement this bug finder.  Instead of doing
all the work to read Java source code and populate a symbol table, we
can leverage the functionality of the <code class="calibre21">javac</code> Java compiler, as
well see next.</p><h3 class="calibre23">Java Bug Finder Part Deux</h3><p height="10" width="0" class="calibre5">The Java compiler generates <tt class="calibre21">.class</tt>
files that contain serialized versions of a symbol table and AST.  We
can use
Byte Code Engineering Library (BCEL)<a id="text/part0000_split_018.html.FNPTR-5" href="#text/part0000_split_019.html.FOOTNOTE-5">[5]</a>
or another class file reader to load
<code class="calibre21">.class</code> files instead of building a source code
reader (the fine tool
FindBugs<a id="text/part0000_split_018.html.FNPTR-6" href="#text/part0000_split_019.html.FOOTNOTE-6">[6]</a>
uses this approach). We can see the pipeline for this approach in Figure 4, <a href="#text/part0000_split_018.html.fig.findbug-classfile"><em class="calibre6">Java bug finder pipeline feeding off class files</em></a>.</p><div class="calibre1" id="text/part0000_split_018.html.fig.findbug-classfile"><img id="text/part0000_split_018.html.d24e1476" class="calibre22" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABoAZADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKhubhYELMQMUATEgdTio2mjXqwryTWfHet+J573Svh5pk93KjeQ2rOAtpbvkbuT98gdhVqL4OaTcbJNa17X77VyoeW4GoNFlv7yovCigD0yW+tooy8syIg6sxwB+NSJcRNjDjmvONM+DegJI83iC51HxBcuTl7+4Yrt7LsUgcDvVO++Eb2F5HN4I8RX+hpKxW6idzcIyHugY/Kw7dqAPVw6nowNLXjuteE/GXhLSrnWdI8bXmrNZxNLJZanCrJKijJAK8hjjg12Pw88ZWnivQLK/t5YmaaJWdI33eWxHKn6HigDsaKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACmTSxwoXmkVEAJLMcAAcmn15z4s0rTrG/17xrq18NR/s6yeO2s5H/c2p2HcCoPLOTgk84NAHbabrWl6okr6bqNpdpF/rGgmVwn1weKNM1vS9VaUaZqNndmL74gmV9v1weK8G+H3xG0rSLmSO403wva6VPYm6vJNF3kwtwFjkB6licD3rq9J8efDzw7pst/pOlvYtPNJBNDb2apKTGoZiwBxgA+vfigD03Tdc0rU5pIdO1Kzu5Y+XSCZXK/UA8UWGuaVqF3Ja2OpWdzcx53xRTK7Lg4OQDkV5JP4+8G+HHFx4K0WFrm6nhhmvIrQpAof52DyD+ILubHtVvRfH3w406fUNT0fTTBeZTc1vZDzblZXKqyAHLAtQB6ha65pV3fyWNrqVnNeR53wRzKzrjrlQc0Q65pU2pPp8OpWb36EhrdZlMgI65XOa5vUbXRPDmiah4v0vw7H/aX2VrkiO3CzyEjcVbHOc9a898JeNNCh1C88R6zp/htppPLEV7owLzyXEmd0LB8HcMAk8A0AezDXNKOpnThqVmdQBwbbzl8zPX7uc0Sa5pUepjTn1KzW/JAFsZlEhOM/dzmvJ5fiT8NIdTTXo9Mll1NlEst1DYbpYdzbBvYdCTxVi68efDw3I8ST6PMdTSaWNpXsQLiJogNxOTxgMO+aAPULjXNKttRSwuNSs4r58bbd5lEhz0wuc0XmuaVZXsdnealZwXcmNkMkyq7Z6YBOTXmWreOPAE/ic3Uuiy3urwyGGO8+w5/epHvCCQ9wtZOn+PPDniPVoNT13wzDJqKwQNb26WpmvvNYM4Cj+6FG7PvQB7HqGuaVp1zFb3+pWdtcS4KRzTKjNk44BPPNLqWt6VpckUepajZ2kkozGs8yoX+mTzXG+KtS8Gz6VpHiTWtHF69wVS08y0BnU8sFw2NpGD1IrD1/x38PNYutOk1fSZdQbyoJI5pLDzFt1mbEe5v4ckUAenanrel6WIjqWo2doJeY/PmVN/0yeaNR1rS9Mhil1HUbS1im/wBW80yoH+hJ5rybx14/8E6jZaglxoyanfaXFIbVLy1BjZlcRkKc5A3YHQe1X9X8a+BNa0LTX1XSm1SNLeS4SAWPmGBEOx2Kn7oyCB64oA9Kvtb0vT7aG5vtRtLa3m/1cksyqr8Z4JPPFcn8RtettP0cXD3cEUEy4jkaQBXyMjB78VzF98Rvhvruk6ZDf6c91aYDQ289kP8AR0JCK5UnhTnAIzkVY1qbQPHun3umWOmyz2ukyGDM9rthV0yuIyeuMY4oAi/ZevJLj4dzQebby21rfzxW7Rn5ym7OZB2JJP4YrC+LesXWh/Eu6u7TWbjS7k6KotESHzFvJhKMRHIPX2wfevJNc07XfBupXNx4Xv7zSTJxItq+1XA6ZXpXongX9oTR7TQ7Wz8eWd9/alqgVrxIhMJzn73qpoArn4p+NI7MWUgl/wCEiS7vTcWgt/8AUwrFmPPHQHkeuKpan8R/EVul6mm+LZtQsYJYc3TQLE5LRbmjDbCqkN6jnGM13Om/HH4eeKxqunazv0y2lRoxLeJsFxGRjIZeVPJ4rB1P4o/D3wDo13b+BIhr2pXciyOGZpEYjjLyN6DoKAPaPCGsDUfAGm6rrT+UJrRZLh7tBF25LAnABrx3QdX0T/hc+rS+CWtxoz2saXf2ZdsT3IY8pjj7uMkda43xz8YNf8f6NLoOn6PDpWnXShLhy/mSMvdR2ANdf8HvCklokTCLaoxgAYoA+hLKTzLdGPpU9czc+LdC0S9TS9QvvKvfl/d+TI33unIUj9aPFPjbSPDN5Bban9r82Ybl8i2eUYzjkqOKAOmorm/FXjTSfC7Ww1T7Xm4UsnkWzy8D12g4o8TeM9J8N21pPqX2vZdDdH5Ns8pxjPIUcfjQB0lFc54g8ZaVoOl2V/f/AGvyLsAxeVbPI2CM8qBkcetGr+MtJ0rQbLV7v7X9kuwpi8u2d3+YZGVAyPxoA6OiucvPGmh2Phy012/untdMucbZZomXbnpuGMr+Nbljd29/aRXVlPHPbSqHjljYMrA9waAJ6KKKACiiigAooooAKKKKACiorucW1pNOwJWJGcgd8DNeaaL4+8Xa3pdvqWmeBhLZXK74XbU0UsuSASNvHSgD1CivPP8AhKfHX/QhJ/4NU/8AiaP+Ep8df9CEn/g1T/4mgD0OivPD4p8dYOPASE/9hVP/AImoPht8V7Hxdqt3o1/YTaNrdvJJH9lncOspQ4cI44YjuOuOaAPSqKKZDNFMGMMiSBWKttYHBHUH3oAfRRRQAVwk/wAPbO80fxTpst/I8Gu3wu59qAGP7mUHrkJ1PrXd1x+n6Y3gyw8XavJN9sFxPNqgiA2bQIx8mef7nX3oAxvF/wAJNK8QNdmGc6eJreCFUhhXahik3qxHG70INc1efs/2NxbxxDX7xcxuswMCFXdjkuq9F6Ad+O9dnaeJ/FFzbQzR6BpIWVFkAOrHIDAH/nl71MNf8VnpoGkf+DY//GqAOXj+ClsS1vPr96+lGeS6FkkaoomdChbI9M5A7U7Q/gtZaO9neR6lLcalZy+dDI0SxISqFY1IXsDhie5rqP7b8W/9C/pH/g3P/wAapw1nxeenh7SP/Buf/jVADrzwpqOp+B7TSNQ166TV4fLlOpQcN5qndnHAK9sHqK4vU/gbZ6n/AKbea1NJrxn85r77LGFYbdu3yh8uO+eua7P+1/GH/Qu6T/4Nj/8AGqQ6z4vHXw9pH/g3P/xqgDG0n4RaRptr9mS5kliaW0kk8yNcutuxYKcdmY5NYHiP4C2Os3U839uXUP2gytKnkq4LvIX3AE8HkL7gCu2Ot+Lh/wAy9pH/AINz/wDGqY2v+LBn/in9I/8ABv8A/aqAMjUPhHY3+jQ2Nxql3vjmubn7QqgO0sy7dx/3R0qk3wYhivo9S0/xBfWer8xvdxxrloTGsewD+E4Xhh0zXf8Ag3xBF4l8PWOpJGIXuIhI8Ifd5ZPbPfp1rboA89+IXwzh8YWWjWj6tdWsOnI8eCol84MoXLZPLDHB56mqGmfB6ws/DZ0eXVLqeNp7eV5CoUkQqVRBjoOc16jSOyojO7BVUZJJwAKAPFNM+B8WiPLejV7rVJVjTNs0SR/aTHKJVVmJ5yygEml034OXF54cv1vtRl0m+1a9e8u4bbEqJEWLLbZOMoCcnHUk16b/AMJj4Z/6GHR//A2P/Gj/AITHwz/0MOj/APgbH/jQBw2p/Bq01TV7W+vtXmbZbwwTxx26J5hiGEKn+DtkD0rufDfh638OeGrfSo5pLiOEuxlk+85ZixJ/Eml/4THwz/0MOj/+Bsf+NVNR8Y+HfIPl+INIJ/6/I/8AGgDy74q6p4Xt7+TTZ7+3TUcDMWMlC33d2On415P4IbwBpInh+Ifh3UbzV455ZPtQVpIZh0RAFPHH4Z711/inRvDV/reo3cPiVYotQdZLu2iv4/KnKnI3c5xwOAaY+maHczbm1jSwPe7T/GgDzK18L2et+IdRn0DTbyw0aR1+zW92waRePm/DPT2rrG+Gd5baVNcWdo0067dsapknLAHj6EmvX/AmmaB9pit7fU9NuLhz8sUVyju30AOTXoXicy6F4aurzSbNbm8i2bIihbdl1U8DnoSfwoA858NfDKG1dWaIcH0rtNc8L3s2kWVno8sduTeQSXEhJDCFHDsFx3O0D6E12yqq9ABXN+NtP1i/Gi/2HcGEwajFNdYkKb4AG3L79RxQBF411W9t7vSdJ0qYW13qMkhM7ReZsiiXdJtUHJcg4X3ryHR/ilfaNrOs6VbnVtYuXu1jtbfUlzJbIsZaQsY1yR04xkZ5r3DxJ4c03xFDbpqcLs1vJ5sEsUrRSxN0yrqQw464PNYdx8MPB9xZrbS6LCUWY3G4MwdnIwxLZyc98nmgDz62+N2pXFk2oSaFb2lham2S7e4ndX3ytjEYC84X5uccUyX463oaSSHw1K9rcxs2nuzOm8mTZHvJGAHPQqTXrD+DfD7xNE2mQGJriO5MZHy+ZGmxDjpgKMY6VU034eeFtN3/AGPR4E3zpcHJLfOjblxk8AE529PagDznUvjJq1lq0mn/ANkafPJC8kMskFxI0YdIy7kPtwQuMEdetU/Dvxa1618K2l9qltYXkMM9vBe3JuGRy853ARpt52IRnOOhxXpUvwx8ISahc3raLD9puXd5HDMMl1KvxnjIJzTrf4aeEbe+S8i0aAXCQC2ViWICBdg4Jxnbxu60AO8AazfeMPDcmoazptnBY3buLaJZDL5sOSAzgjAzjOOaveD7qyK6npemWSWVrpN2bRY4+FPyLJkDt9+tjTLC20vT7eysIVgtbdBHHGvRVHQVneHr+zvL7XI7O1EElre+TcMFA82Ty0bdx14ZRz6UAbVFFFABRRRQAUUUUAFFFFAFLW/+QNf/APXvJ/6Ca5b4K/8AJLPDf/XqP/QjXU63/wAga/8A+veT/wBBNct8Ff8Aklfhv/r1H/oRoAsfE3xFceHfClzf6Y0LXcM9uhVhuwryqpyPoTiuOT45aYdUvbF9Gv1e1dd7Fk4j3hGkbn5QCQcdcGuu8QfD7Stc8Qrq11cXyOfJM1tFKFhuDExaMyLjnBPrXPaD8HvCdpLcy2Vze3EUkM9i8bTKyBHb5k4XqG5GeQRQBBr/AMbNL0mNbhdLurmwa4lhS6SVAriNgrOoPJGTwO4BrnF04TDxHYav4c18x3Oqtqul6vplt5hhZkXbIhByCMcjoc4NddqfwV8L32nadZb9QggsrP7CvlSqDJHu3fMSp5z3GM16Np9qllYW9rGzukEaxqznLEAYyfegDm/hv4im1/QmXUFkTVbGQ2t2ksRicuOjlD93cMMB714ZYXfiOLXNVsPDGt6hDqd5rN3E9g0J8qGEpkXAJHqOua9m0G6js/GHjuaVgsaXFszE9gLZSf5Vm6j8TfC15aTW0t80kEyFHCI4ypHOCOR9RWlOjUqfBFv0RnOrCn8ckvU8mu/EfijX5NC8Vtf39rDHcywW1qsfyGaO2IJYDqGlBXms7T/HXjeTRbuKbXbtBI9uwnkiIMbtnzI/NA/d/Qg4r1zSfiJ4T0XSodP0l2t7OBdscSQOQo69SMmuV8YeMo/EGq6SdJu7qKS2aWTzkRk2EoADyMH6GumjgK1Sai4tX6tMwq42jTg5KSdvNHrXwx1S61jwFo19qLStdyw/vGmADkhiMnHHOM+9Utf0mfT/AA74+uprgSx38E08Sc/u1FsExz7qTx61ynhD4hOJrbT/ABA6peSHYlwoxHMe3+63t+VdJq1vcxeG/HtzcXHmwXtvNNbJuJ8pBbBSMHp8yk8etYV6E6E+SorM2o1oVo88HdGn4bljh8PaWkjxoz28QUMQCx2LwPU1pkg+leR/ERZ0h+GUlrG0k0V4joAufmFtkfriuZtvHerQaNeXUfiDVdVKadHLfL5AhNhdNMq7FbYdowWyCCQFzWJqfQipnnino0ZQPGysh6MpBB/GvnTRvH+tzW1qNX8SXdvo41ae3m1S2QSN5YiVo03mMZyxPO3nFep/CSXd8M/D5Du4MDEO4wzAyMckep60AdpJL2FV2fNNZsdageTPSgB7vjgVA5yD9D/KgmoppAikn0P8qAMr4IjHg/T/AHtU/m1eikgDmvCfht480zQ/Dlna3b3CSxwLGwW3dhkE55Arpbr4qaOyERyXRP8A16yf4V0fU8R/I/uZj9Zo/wA6+9HpguIySA6kg4OD0NUfEpB8Oarj/n0l/wDQDXgA8R37+JdS1jR7qaES3CHyplYRzoEUEFT05zyK9D0vxvaa94f1iD5obuK0mEkEn3l/dtyPUe4rbEYCrQgqjWjX3eTMqGNp1puCeq/H0NHwRpdpL4P0V3tbMH7FB/y6xn/lmvcitr+ybL/nzsj/ANusf+FUvAw/4o7RB/04wf8Aotal8ay3dr4N1y506RI7yGymkid+ikITn68ce9cJ1l1dIsf4tPsvxtU/wpx0vTFHzadYk/8AXsn+FeAeHvEfijwbDdafJeR6lqLQWMqNczO8WblxycjIIz9K3o/iH4pvjDosUWjxa813d20lxIWFvthRSSo65O4flQB6xJp+ng8adY/+Ayf4VA1jYD/mH2H/AICx/wCFY3w8u5rnwD4enupGluJLKNpJGOSzY5Oa3C3pQBx/jeOKz1PwpNZ29tBMuqcPFAin/UyccCu58Ra1c6R4Pk1SCAXNzGsZEZz8251U9OehJrz74kXkFnL4anuZUiiTU8s7nAH7mTqa2dR+Juj6T4Z+0Wt5ZXlzDGgFus4BbLAH8gSfwq405S1irkuUVuz0gsB1Ncz42i1qcaL/AMI/KyFNSie82uFzbgNvB9R04rA1r4h6IIJxBq1kzbWA2zD0NeZ2HjzxJZaZ4eiN20sH2mJ7i7ONwgOdyOO45Hze1dFPBVqkJTituhhUxVKnJRk9z1v4rwx3WmaJbXCeZbzaxbRyRliA6ktwcdqrr4C8ObFZtF0/kA9ZP/iqb411CHULPw28Lq6nW7Ugqcgj5qzvizrF5ouk6NLBfXenWMt6sV/eWsXmPDFtJGMg4y2BnHeuQ6TUXwH4Z76JZfgZP/iqlXwB4WP3tEtP++n/APiq8OHj7xVNo+iSHxDJaWVxb3bpqVx+786VJ2VFYrG2cKB8uBnPWtyz8TeLZHvtUm126kFprVpZLaJEBbyRSKN5wV3e/UYoA9TfwJ4TXpodqf8AgT//ABVQN4J8Kj/mBWn/AH1J/wDFV0MknJAqvI+AaAOT8EeTonxF1/S9Mt0gsJEtW8oMxCsUOSMk9a73Q7jS5bzWV02MRzRXmy8Ozbum8tDn3+Urz7V5rpd9HbfFXWXkZQNlp1OP+WbVo634o02y0rxRJoUiw3waRrh16/aBEuG56/Ls6cVUYuTSXUUnZXPUAwPQ1zXxMvLnT/h/4gu7Gd7e6hspXjljOGRgvBHvXnnhL4k3Nu9vY+J2UOwAjvlGElOOjD+Fv0rsfiZeR3fwu8SsjA/8S6U8f7ta4jDVMPPkqIyoYiFePNBlPwz4POo+HdLvLjxJ4oM1xaxyuRqbgFmUE8YqSX4VaRNK8k2reI3kc5ZjqkmSa6XwP/yJuh/9eMP/AKAK4j4o+M9Z0DXJ7PSZNixaUb5UTTJLxpZBIV2kowCLgdTWBsX/APhU2i/9BPxF/wCDSWsLxx8LtPsPCmq6lpuseIINQsbaS5t5W1KRwjopboeD0xVjRPjHY3GiJd39qVeO4trS4khcNHvlTcWU+g54rX8O+OrLxjqLaBfaHfWkeoac15EbgoUuLVjsz8rZBOelAHO/D7xxqujRaLp/jef7VZanAj2Gsn+J2APkz44V/Q9DXsdeSeN/g14RbwbqsemWU1hPHbtLFJFdSkKyAsuQWIOCPSvQvBc0lx4P0KaZi8slhA7MTkkmNSTQBc1v/kDX/wD17yf+gmuW+Cv/ACSvw3/16j/0I11Ot/8AIGv/APr3k/8AQTXLfBX/AJJX4b/69R/6EaAOG+I3iS/v/EEP2e58Rado0UE0cDafA4kmvkcAKwxymOmeDzXC+OdV8WaPFGuivrNrcJc3l1sgR/LmY3R6hV+Y4GeTjBr6d1m/j0rSL3UJ1dorWF5mVBkkKM4H5V5F4Y+NseozaWup2MFnHeSHe/nH9xH5fmBmBHpQB5+/iHxq2paxnV/EJN1buxkjs3AtPunBhI+UdgyHPfFey/Ay/wBTv/BTHWWvpbiG6kiWa7YsZVGMMhIDFeeN3NdD4N8Z6H4wguZNCuzP9nYLKjIUZcjIODzgjoa6OgDyfVS41b4irGCSzQDA7/6IK8attSihtIEkEissaggxMMEAe1fQOi2ouvGPjhCP+Xq1/wDSZaZf+EUnkJKZzXoYHMHhFJKN7nDjMCsVa7tY8E/te3/vt/37b/CnRatBLII0ky5BIBUjP5iva5fBMew/Ia4Xxh4E1Ga6sjpaom1nEjv/AAAjrjua9ShnSnNRnGy73/4B51XJ1CDcJNvscjJci4lW0jj8+eUfLF/U+g969K8K6frWm/DnxdHrl2bsyW08luTIX2R+Rjbz0wc/zp/hDwLHZOGKlpTjfK33mPvXTX+m6hY+F/Hn29ibR7eU2I3A7YvswBGO3z7utefmOYfWnyRVor7zuwGB+rK7er+4g13xjY+DtI8InUrdnh1FobUzDnyP3QO/ABJ+g5q/a+NvC97DO9nqdlJGls15LhSMRKcF2GOx4IPNYHi3w7qev6V4NutDurO3vNIeG8T7UrMjnyQMHbzXE6x8MZ8+GLFpJ5rqa/nudVu4AUgMTne8Z7gFgoANeWeidvpXxM8K6idVQ3EdvBYS7C8kLBZBgYZfl9SAB19quzeP/C8FlFcHVoFikdokAjfduX7w2Bdwx34rjvE3w41PVH1q1g1GzTSby9i1KCN0bek6KFCtjjZgduahs/h5rmm39nrGk3Oh2msQmZHRYZGgdJMZJJJYv7mgDt4PHHhu51KOxh1i2e6kwFX5gCSu7G4jbnHOM5rGT4m6BNr32C3uVktFtJLuW++ZY4wrbduCPm+ozXOSfC3Urvdp15qlp/Ycl62oyCGIrP5zJghT0C55HfFVH+E2s6hDDbaxq2ntbWenGwsxBEwPDhlaTPXpggUAd9/wnnhj7OJv7XiK+YYtojkL7gu4jZt3dOelaN3dR3Wnx3NpIJIJoxJG4/iUjINea3Pwq1q5090jbw9aXjzeYZ7ZJ0dfkK5D5LZ56dMcV6pp2kPaaDZWM0vny29ukLykY3lVwW/GgD540/VYY7KJC7ZUEcIx7n2qf+2YB1kf/vhv8K9J+HPhhL3wvpshXO60Rv1Nb194KQRnCV7/APbsv5Px/wCAeK8lg3fnZ47BqMdwrNE+4KcHgjB/Gonju9Yt7saU/lvDFJvugSNgCnKgjqSOMV00nw91GbxBdtIwi05pAwVD88nygY9hmu+sfCkWneHNQCRLGiWk2ABgf6tq0xWcR9mo01eTWvZeXmZ4bKmqjlN6J6d2dX4KCp4P0NsAZsLc49P3a1Pr9xapouoNqC7rFbeQzqBnMYU7h+Waz/CL/wDFIaEP+ofb/wDotaZ4qilvPDOr21uu+aazmiRfVmQgD8zXzh7xQTTfDOpxx36w2cu9LdQ+4EgIA0SnngjjAqprHhrwpdwS/wBpWWnmE3TXDtK4AEzABjnPBIAyK8pg8HazFa3V5o/huXTIIksP9A+0LvuJYWDSSDkgEjgetVNdsbuzSPVPFOlQmyl1C8uP7Lu7xULl0Xy2znDEYPFAHutg2m6dZ2VhZy20NusYS2iEi8oOm3nkfSrxBwa8A0zwnrE934R1Ow0aWaQWNosjXRVoI0X7xGSGRx9Oa+hduc7emaAPI/jdMFsdF8wgKNSQnPQfI1cf/aFpn/WW/wD30tenfEzS1u7jw5E6Bkk1EghhkH9zIf6Vn614V0/SPDrapc2SPFCiFlRFBO5gvf3YV6+BzNYWn7Nxvrfc8vGZc8TU5+a2hwP2+0/56W/5rU32tdmcjZjOc8Yrtda8ARRRyhLWPcAQMRj0rz5PCuuRw6E8ts5SS6jhktQm7ahByz+mMCvTp5xSlCU5q1um9zz6mUVIyjGLvf8AA2/Bsl4+o6ILUsNFfW7YhZM/6z5uY/RfXt6V6/8AEuXwquhW8PjO7+zWMkwWJhK8ZaQAkAFOemeKxdV0YaXB4bIULjW7UDHH9+tHxz4dl8R3Hh2SOaJF0vUkvpFkUnzFUEbR78187ia/1iq6lrXPew9H2NNQvexV0XxP4H0yxtdH0q+s47WFMxRmNiq5XefmK43EZJBOaktviF4RvLe4mttZs2hhiFxIzKyjZnG4ZUbueOM1w2sfDK6h1TW7uz/s26s7qWa9VZo5DcJIyEbUAOzqeDjNY2ifC/W9d8LaO2v3dvZ3VhYJDYQLEQYWD7/32ev0Fc5seoy+PfDCaeL59YgW1M/2beyuD5mN20rjdnHPSqvhXxxpXiv7ammPIZLaV4yGRgHUHG8EgDB9OtZeh+BdQTXo9a1u7sp7+XUfttykMRERAhaNQgPf5s5Na/hPw5qmiX+tpLdWs2lXl093AiKwlRnOSG7EemKAPLvGv2eXx9qZu0iYiCAAv/umszydM5/cWvPXpzXaal4Xg1j4iaylxCJdiWoGe2UJrJ1vwFYW1nrEmnoJZ4S/mIrFjHIEB2AduMHHvX0GEzanTpwpOLutDxMTltSpUlUUtGZs80ckDJMqtERyG6Yq5pOqao/gTxZZxlp9CTTpRHLKfmVsfdU/xLUHh7whqOsGKTU4ngtcArbnhn92/wAK9M8T6GunfC3xGFQKqadLgAYA4p5pj6U4ujBc3n29BZbgakH7WTt5f5nofgf/AJE3Q/8Arxh/9AFZvivwNZ+I9Wj1CbUdVspRbG0kWyuTCJYixba2OoyTTLJrxPhPA2l+Z9vGjqbfyxlvM8n5cDuc4rxrxFJ450jxVLbWWo6s00QjktPtDSSK8JizMzYXYcNnO4gggYr549w9Nb4N+FkvIZrWG5t4ImjkWzSZvIaRAQrMvc4PNZXws+HGqeF/E1zrWv38UiQWf2C1RJndVhDbs/P90Dso6V5poGv+KNU0Ozu7DU/E15aS28Z1+4KEtCPOAJt/l6+XnO3PHPWr9pp/ibxIuoWlze+JP7AWwv5NOZnMclwi48pZDjJzk4B5IoA+hfErK/hfVWRgymzlIIOQfkNVvAX/ACI/h7/sHW//AKLWsHwvGYfgvaRsJwyaMVYT53g+Uc7s85re8Bf8iP4e/wCwdb/+i1oA0Nb/AOQNf/8AXvJ/6Ca5b4Kkf8Ks8N/9eo/9CNdpKiyxvHIoZGBVlPQg9q4D/hT3gsZ2aZIikk7UuZFAyc8AHigDttVtRqGmXdmX2C4iaLd1xuGM147qPwHtNRECXWtSeVHBHCQkQBOyERg5z6gH9K6z/hT/AIN/6B0//gXL/wDFUf8ACn/Bv/QOn/8AAuX/AOKoAT4UfDqLwGNQf7VDcTXYjU+VEY1VUGO7Eknqea9BJHqK8/8A+FP+Df8AoHT/APgXL/8AFVZs/hV4Otd+NHSXdj/XyvJj6ZPFAFjwl/yPPjf/AK+bX/0mSuwwKyvD/h7SfD0M0Wi2EFnHM/mSCIY3tjGT68DFatACEA9hVaayjkOSBVqigCCK2ji+6BXIa+dV/wCEd8ff2ln7GIJvsOcf6r7MM9Ofv7+tdtXMaBNqWq3fiiy8QWqiyS7NvbIU+WW3MS9/4sktn8qAK2jyf8SXTvX7LD3/AOma1OzE9x+dYb/Cbw5vYx6faKmflXY3A9OtH/Cp/D3/AD4Wn/ftv8aANkn6fnRj6fnWOPhR4ex/yD7P/v23+NOHwq8Pf9A6y/79t/jQBrgVMkfrj86xB8LfD3/QMsP+/Tf40o+F3h7/AKBdh/36b/4qgDfVfpUyRZB6dD39q5wfDDw9/wBArT/+/Tf/ABVOHwy8Pf8AQJ07/vy3/wAVQAfCAY8HaP72Mf8ANq7l0VxggVm6FpEWkQLBbrHHBHGsUUUSbUjQdABWpQBUNhEWztGah1m0abQ7+3t03Sy28iIOmSVIArRooA8g0XxLfabo1hp9z4W1zz7S2igk2iHG5UAOP3nTIq1/wlt2cY8La9+UH/xyvS5NPs5JGeS2iZ25JK9ab/Zlj/z6xf8AfNAHmw8UXh6eFdd/8gf/AByh9fuJwol8H63IFYMu5bc4I6EZkr0n+zLL/n1i/wC+aP7Nsv8An1i/75oA8+TxJe9/CevH/vx/8cqdPEt928I69/5L/wDxyu6/s2y/59ov++aP7Nsv+faL/vmgDzfVLjUNd1TQAPD2qWMNnem5mnumhCKnlOv8Lk5yw7V2Ws3un6X4Pa71a2+0WUaR+ZHsD7suoHB4PJB/Ctf+zbP/AJ9ov++awviBrWj6HoUSazbi6iu54rWGzC7mmdnG0Be+OvtigDeubOObOVHNcp4wnudB/sVtNs1uTd6jFazZQtsiYNluOmMDmu1rmPiF4huvC+iwanb2Qu7dLqJLvqTFCxw0gA6kZHFAGf8AFJxZ6Vo10YpmgtdWtppTDE0hRAWy21QTgZrDPj3QmUYkvz/3Dp//AIivTz5dxB/ejkXtnkGs8aJZDosv/fxqAPP/APhOdEJ+/qH/AILrj/4inL430Q/xaj/4Lbj/AOIr0D+xrQf89v8Av41L/ZFsO8//AH9agDg18baIeral/wCC24/+IqZPG2h+upf+Cy4/+Irt/wCyrcfxT/8Af1qcNMhHR7j/AL+tQB534Tmi1Tx1rWoW8Nz9ilNpHHJPbvDvKxkNgOATiuv0/QtOiu9Yks5hNLd3nn3Klg3lyeWi7eOnyqpwfWtKW2s7NftVzMUjh+bfNKdq+/NUPB9vpxi1DVtIvRe2ur3JvBIuCudix4UjqPkoAtQaPDG+QgFZHxSgZvhr4ljgRndrCUBVGSfl9K62ggEEEZB6g0AcH4O8beF4PCWjRTeItISRLOFWVryMFSEGQRmprv4m+Bcy29x4j01hyjgSbgR3GRwRXUf2Ppv/AED7P/vwv+FOGlaeBgWFp/35X/CgDjNO+JHw902xhs7DXtMt7WFdscSEhVHoBirP/C1fA3/Qy2H/AH0f8K6r+ytP/wCfG1/78r/hR/ZWn/8APja/9+V/woA4XxD8UfBU/h/U4ofEdg0j2sqqoY8kocDpXVeAwR4I8PA8Eadb/wDota0P7K0//nxtf+/K/wCFW1UKoVQAoGAB2oAWiiigAooooAKKKKACiiigAooooAKyvE2g2niPSzYX8lzHCWD7raZonBH+0vNFFAFBfBumr4XOgibUPsRbdvN2/m5zn/WZzRaeDdNtfDM+hRzagbOZizO925lBOOj5yOlFFABpng3TdO8P3mjwTag1rdEmRpbt3kGcfdcnI6dqNE8G6bo+kX2m2s2oPb3n+saa7eRxxj5WJyv4UUUAHh7wbpug2V9a2c2oSR3i7ZDcXbysBgj5ST8vXtSeGvBmm+HVvFsZtQkF0uyT7TdvLgc/d3Hjr2oooAPDPgvTfDlzczWE2oSPcJscXN28oAzngMeKTw54K0zw/qU99Yzai80ylWW4u3lQAnPCscCiigBND8E6ZoutS6paTai1xIGBWa7eSMbjzhScCjS/BOmab4hfWbebUWunLEpJdu8Q3dcITiiigAtvBOmW/iY67HNqJvC7Psa8cxZIwfkzig+CdMPica952o/bBJ5mz7W/lZx/czjHtRRQAXngnTLvxKmuSTaiLxHWQIl46xEjplM4o1bwTpmqa/FrFxNqK3UZVgsV46Rnb0ygOKKKADX/AATpmuaxFqV5NqKXEYUBYLt40ODkZUHBpfEvgrTPEV/DeX02oxyxKFUW928SkA55CnBoooAXxP4L03xJLbSX82oRtAuxfs128QI99p5pfEvg3TfEMVpHfTahGLVdiG3u3iJH+1tPPTvRRQAeIPBum67p9jZ3k2oJFZqFjaC7eNiMAfMQfm6d60bfQtPih01Ht1nbThi1ln/ePGcYJDHnJHeiigDToIBGCAR70UUAYer+FdH1fUI72/t5ZLmPG1luZYwMHI+VWAP5UuueFtI1y6juNTt5ZZYxhSlzLGAM56IwBoooAXXfC+k688LapbyytEu1NlzLFgf8AYZ/GjW/DGk63Fbx6lbyyJANsYS4ljwOn8LDP40UUALq3hjStXs7a1v4JZILYBYlW4kQgAY5KsCePXNGoeGNJ1DTLXT7uCV7S2AESrcSoRgYGWDAn8SaKKAItT8IaHqmgwaLqNiLnS4cbIJZXYcdMnOW/EmtiytLextIrWyhjgt4l2pHGoVVHoAKKKAJqKKKACiiigAooooAKKKKAP/ZAA==" alt="images/intro/findbug-classfile.png"><hr class="calibre17"><b class="calibre13">Figure 4. Java bug finder pipeline feeding off <tt class="calibre21">.class</tt> files</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The overall architecture is roughly the same as before. We have just
short-circuited the pipeline a little bit. We dont need a source code
parser, and we dont need to build a symbol table. The Java compiler
has already resolved all symbols and generated bytecode that refers to
unique program entities. To find self-assignment bugs, all we have to
do is look for a particular bytecode sequence. Here is the bytecode
for method <tt class="calibre21">setX</tt>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0:&nbsp;&nbsp; aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// push 'this' onto the stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1:&nbsp;&nbsp; aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// push 'this' onto the stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">2:&nbsp;&nbsp; getfield #2; // push field this.x onto the stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">5:&nbsp;&nbsp; putfield #2; // store top of stack (this.x) into field this.x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">8:&nbsp;&nbsp; return&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">#2</code> operand is an offset into a symbol table and uniquely
identifies the <code class="calibre21">x</code> (field) symbol.  In this case, the bytecode clearly
gets and puts the same field. If <code class="calibre21">this.x</code> referred to a different
field than <code class="calibre21">x</code>, wed see different symbol numbers as operands of
<code class="calibre21">getfield</code> and <code class="calibre21">putfield</code>.</p><p height="10" width="0" class="calibre5">Now, lets look at the compilation process that feeds this bug finder.
<code class="calibre21">javac</code> is a compiler just like a traditional C compiler. The only
difference is that a C compiler translates programs down to
instructions that run natively on a particular CPU.
</p><h3 id="text/part0000_split_018.html.sec.c-compiler" class="calibre23">C Compiler</h3><p height="10" width="0" class="calibre5">A C compiler looks like one big program because we use a single
command to launch it (via <code class="calibre21">cc</code> or <code class="calibre21">gcc</code> on UNIX machines). 
Although the actual C compiler is the most complicated component, the C
compilation process has lots of players.</p><div class="calibre1" id="text/part0000_split_018.html.fig.C-bigpic"><img id="text/part0000_split_018.html.d24e1554" class="calibre22" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABPAZADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAo63qI0nSri+a2uboQru8m2TfI/sq9zWP4V8Wr4huZYV0TW9P8ALUN5l/bCJW9gcnJo0rR9Rg8d67qt1NvsLq3t4bVN5Pl7N2/jtksK8X8RaNrvjjxp4qv7FJYLOyvEs4786k8S2ghA8x1iHDnqeeKAPafDvixdb1S4sl0XWrIwg5mvLYRxtg4+U5OaND8Wrq2tXGnLoutWhh3ZuLq2CQtg4+VsnOe3FeDav8UvH2kaNps4urG5F/bSXsUgt1DJCj7EDZPzM3BOORnivc/A3iPVddRhqvh+80vy4YnE8zLsnZlBbYByADnrQBNpPixdS1+fShoutW5iLj7VcWwSBtpxlWzzntxRp/ixbzxJNo40XWoWiZl+1y2wW3bb3D55B7cV0tFAHLxeL1k8Ttoo0TW1ZZDH9sa2Atzgfe37un4V0Nle2t8jvZ3EU6I5jZonDBWHVTjuPSp65fwnoGnaJr/iWbTrwyPqFwlzPaAjbbuVxwB03Yyc0AdRRUdzcQ2sRluZY4Yx1eRgoH4mnRSJNGskTq8bDKspyCPY0AUdQ1nTtPvrGyvbuOG6vnMdtEx+aVgMkD8KydG8WrqmuTaYuia3bGPdm5ubYJCdvo27nPbih9P0O7+IAvnmWbX7Kx2LAWz5MTt98L2JIxmvLfFOpaJrnjHxbB441S8tLXSPKg0/T7eZ43kLrnzkReZGLEAY44oA9S0zxct/4hl0kaJrcBjZl+1T2wWA7e4bd0Pbiiz8XLc+JX0caJrUbI7J9rktgLc47h93Q9uK8Uf4neJdLsI5dOvoLqC0lmsRpt5CBdskMRLXEzD7pzjjoc1NdePviLoryzald6ZdRWdzbxTQR2u0yGSEzPGCDxsUZzQB7LF4uWTxO2ijRNaVlcp9sa2Atzgdd+7p+FB8XKPE/wDYv9ia2W37Ptn2YfZ+mc793T8K8LuviV4m1DTLaCbUNL1GPVLaC5KQJ5X2Ql2fyywPLbE59KztB+LPirS59OsobZFtIpP9IFz87StIGlJyfmVQpGMccc0AfQtx4uWHxMujf2JrcjFwn2tLYG3GRnO/d0H0rpgQehzXH/C258Q6l4VttU8U3NvJcXyrcRRQQ7BDGwyoJ7nBFT+ENCm8MDxBJeX4ntru/lv492f3CMASpz6EE8cc0AdTRXyxa+NfE+keKdW8Wy291b6d4ihnh06S6HmRB4zmDCryq7c5Peon+NHi4WTMNStsQu2+X7LGWc7AQEP3HGc8L82KAPqyivmVPi742na+mT7LHIsc5WxaJQ8SJBvWYoRvxnnk45xTPFPjrxxp+j6r9t1aG8tg1tZtElisZf7RbF2IYcjacYx+NAH07RXyfZeJNfvvDnhzRtN1pNTWP7A6ypDsNlckuohkYffzgE559a9h+D/izX/GX9qXep+Xb2tmiWJjEOM3aZEzhu65xgUAdr4j8Qx6Lp63aWN/qSmTyymnxiV1PqRkcVVtfFa3HhmfWf7G1mNYjj7JJbgXD8gZVM89fXtWd4btLT4feALmbUb1LhIGnvLq6TJErs5Yke/QY9q8V0vx34n0fxF4jvdRjey1bWtPjubG21NvLhRxIVRI+33GHXGWHNAHvdh4rW88O3erjRtZhW3JH2WW3CzyYx91c89fWjS/Fa6hoV7qY0bWbcW2f9Gntws0uB/Auefzrw1fi34se00Yx6jYOWlK3pW0BnjJk2qrRZ5U4PzpmoI/jR4zub+6CW1rDDdK0VmoiDiGRpPLiYnOSCc5BwfSgD3nRvFa6ppF9fro2s2otQT5FzbhJZcDPyLnmjQfFa6xp19dro2s2YtVLeVd24SSXgnCDJyeK8K1n4keLLHT71dX1uxltpTf2MZhtPKYtEgVZN2eB5hwKztW8fa/osFnpd1errdtpMkc8N7YqUWbyofmjZh99Q7R5b60AfQvh7xYutWl7ONG1myFqm4peWwjaTgnCDJyeKf4M8YaZ4utbiTTftEU1s/lXFrdRGKaFuoDKfUV4p4P+InxD8SanZ6MrWNtPc3jK160Cv5aJGGkTaDg43DDZ7817Dca7NY/EHStAWyjdL6yluZrwLg7oyAAccc570AdZRRRQAUUUUAFFFFABRRRQAUUUUAc9q3jbwzo9/JZaprunWl3GAXhmnVWXIyMiqf/AAsjwZ/0M+kf+BK1z/hbTLC/+KHj5r6ytrhlltApliDkfuR613H/AAjmif8AQI0//wAB0/woAx/+FkeDP+hn0j/wJWpbX4g+Ebu6it7bxJpUk8rBI0W5XLMegHPWtL/hHNE/6BGn/wDgOn+Fed/tAeGdOPwr1eSw0a0NzCYpVMVuoZQJF3EYGfu5oA9aBBAIOQe9FeQfDDxfotjq0XhvTdeTUtJuP+QaJGbz7ZsZMDbhuZcAlW7AEHtn1+gAopjyKnUihJFf7poA53SNP1WDxxr17dyltKuIbdbRN+QrLu3/AC9uoqw2v+HLXUZtKbUNNivW3PLa+YoYnGWLL345NV9JttYj8b6/cXkjto8kNuLNd+QGAbzMDt2rxmy8B+K/E0GrajDaadpT3mpXN/DNcq32o5UxJGwK/Ku0seDzxxQB642ueBrwabvvdAnDP5dluMTfMD0j9Dn0rWbxToK3N9btrFgJ7Fd9zGZ1zCvqw7V5JqXwfv5HvNN0+HSLbTbuO0QXgXE1qsSfMsa7cZZxu3ZBrJv/AINeI9R8OWVjdnR0msJAS8Dsst8C5d2kl2/Kc4IGG5FAHtreL/DqwWMza3p4ivm22zmdcSnOML688U9fFegNLfRjWLAyWIzdL565hHT5ueK8LtPgZrVpLpnkyaY0sbCWa7d2fkvudGiYFZFwBgjac5NWNO+D2u2k8l2bTRXC3cVx/Z7zs0UuCxcBym5EOVOw7hkUAe0weL/D05shDrWnyG9JFsFnU+cQcHb681F4f0O307xR4j1GG9E82pPA0sGAPI2IVH55zzXFfDv4b32j+KH1fxD/AGZclYne1SCPAtppZN8mwYwAOADXaeH9BXTfFPiTUxeLM2pvAxhC4MOxCvJzznOe1AHE/GWOy/4SfwpN4ohml8JRGc3nys0Cy4XyjKF7Z3Yz3rpvhOunL4YY6DZ6haaQ1xI9ol4fvRk5DRg8rGf4Qe1dhKyBSHwR6GkjkQgBSPTFAGHb6Vp0Pju71NLonVbixSJ7csOIlc4cDr1JGa1J9K0+4vY7yewtJbuPGyd4VaRcdMMRkVUGn2X/AAlral9o/wCJibEW5g3j/VeYW3bev3uM9K16AKP9j6Ybiec6dZ+dOMSyeQu6QejHGT+NVdf8N6brek3en3UAjiuQfMeEBHyRgkNjgkcZ9OK2KKAMuz8PaPZ2kdtb6XZJCmMKIE5OMZPHXHGamOjaYbg3B06yM5TyjJ5C7tmMbc4zjHar1FADY0SONUjVURQAqqMAAdgK53wrod7pl14gfUrpbqHUL5riBCzMI4iijYQenIPA45rpKw/D2n6jZ6nr02oXPnW91eCW0TeW8uPy0Xbg9PmDHA9aANU2dqYoozbw+XF/q12DCcY4HavP/EPirSdLvdQ0qw8JzavBpCLc3hs4IjHbluRhSRl8c4UZxXo9eYaz4O8VWPiXW7zwXqOnWtrr2x7x7pGaW2lVdvmRY4OR2PegDprbxJ4SvNSEIvNMGpXMAZopNqzGMpv2sDz93nBrNg8d+Cr27v4heaXJaWiQyy3ZaMxF3LKq5/vAIfwIrhNY+DWtaolxo1xq9s2iSXTaj9tZCbxp2iCbW7bcjP44qs/wm8U3Q+130uhpd2i2iW0NsZIYphCJFzIy4YNhwQR0xigD2ixtdG1LSPM0tLRrK7G9ZrVVAYkYDggdR2NR+GvDVh4a8PjSNHR0gG87pHLO7tyWZu5J71m/DTw8PB/hCz0eWWJ5Yy8khiLFQzsWIG4k45711gYMODQBzfgjw22ieDbLRdVaC9aHfvJXcjZkZhw31FbV7plhfgi+srW5BXZiaJX+XrjkdOBxVHwhY3+naFFbatcfaLtZZmaTeXyrSsyjJ9FIH4Vs0AZ66JpSy28q6ZYiW3G2FxbpmIeinHH4UsGjaXbtI0Gm2UTSOJHKQKpZgchjgcnPer9FAFKbSNNnQJNp9nIgz8rwKRycnqO55pItI02GBYYtPs0hVWRY1gUKFb7wAx0Pf1q9RQBUs9MsLIRizsbW3EYIQRRKm0HqBgcZrGvNfeLx/p+gpYh1nspLp7rP+r2sFC9Oc/Wukrn5/EQi8dWvh77Lkz2L3n2jd93a4XbjH45zQB0FFNd1RSWIAHJNRQ3UMyq0UiOjDIZTkGgCLWb5dL0i+v5ELpawPOyr1YKpbA/KvP8AS/G/jLVNOtr+y8CF7W5jEsTHUogSpGRx2rsPHPPgnxB/2D7j/wBFtVb4Z/8AJPvDv/XhD/6CKAML/hKPHX/Qhf8AlTho/wCEo8df9CF/5U4a9CooA89/4Sjx1/0IX/lTho/4Sjx1/wBCF/5U4a9C4o4oA8x8I/GDS9W1qTRdcsbvQdXjnNqY7sDynlAyUWQcZxjAOM9q9OHNeHanouq2mv8Aje0v/A1zr+j63dpcRvFPEgAEYXI3MCGB6EVN8LPFOs6J4qh8F+JLHVo7W4jaTS7jUApkG0ZaFnUkOAOQ3XtQB1Xgj/kp3xA/67Wn/ogV6DXn3gj/AJKd8QP+u1p/6IFdZN4j0aDVm0ubVLOPUVjMpt2lAcKBknH0oA8QuJNEn1XxDqfi3XNTs/FFrrAgtILaZvNhj3L5Qii6MrAnJwe9fQbKrqVcBlPBBGQa5SfxF4Nls28Qve6NNHA3lC9yjMrjoobrn2qTw9470HW7HSp4r6GCXU0MltbzOFlcZI6fUUAc78aLa3ttI0K6ggiinj1uz2yIgVhmTB5HqCRWjrXxF0LTb+4s579Fnhba6BWJU+nAqh8eOPC2lY6/2xZ/+jBXkPiV7q08Uay8trdlJbgurpESrDHrXdgMPTxE3GrKysceNr1KEFKnG7Or8feN9P8AEGmw2FncvIXu4WIQMp2g5POKseG/H93pUxh1+fzbLIEd5j5lHpIP/Zvzrzj+11DojrcIWYKC8ZAyakmvckRKpmlcYWJRkv8A/Wr345fh/YOne63vpp8zxJY/Ee2U7WfbufQnha81S78X63PcSM+iSQW5scMCu7Db8f8AjtdlXinwRttesdT1O31UuNN8qFrSMcxxk7t6qevpmvax0FfK1IqM3GLul1PpYScoptWYUUUVBQUUUUANlcRoSa8r/wCEg0rwn408S3N/q0Rl1MwSrbhGLQhUK89RzXpGrki1bb1xXzL4pgvbDxxrl3LHcSw3flNG0UbMFwpBBrrwVGFeqoVHZHNi6s6NNzgrs7Hx94807XNEk0+zuWleaWIbVVhkBwTzj0pvh7x1eaHK0esTvdaaCPLnIzJCPR/7w9+teetrCqwEiXKZIXLxEDJqaa+CDGGd24WNRlnPoBX0dPL8P7F073W99NPmeBUx+I9sp2s+3c+jNHFhqHiJNchuxJcSWC2yxqylTH5hcOO/U49K6mvEvg7oFxYapLqt1MVmntRAtmOVhTfuyD7nqOle2J90Zr5WtCMJuMXdLqfS05OUFKSs+wtFFFZlhRRRQBHNIIkLE15jb+ObbRNe8RQa1q8bb7xXtYtzP5MXlKNvA+X5snHvXoGuEi2O3rivmnX5Ly18Ras1xbXZWWfejpGWUjaB1FduAw9PEVHGpKyt/W5yYyvUoQUqcbs9fPxT0HPGop/3w3+FJ/wtPQf+gin/AHy/+FeI/wBqN/zwvP8Avy1H9qN/zwvP+/LV639k4X/n5+KPN/tLE/8APv8ABnt3/C09B/6CKf8AfL/4VHcfFLQyh2aghP8AuP8A4V4r/ajf88Lz/vy1IdVI6w3n/flqP7Kwv/Pz8UH9pYn/AJ9/gzp7jxLd3HijVtY0O9ZJH8pELgmKQBBlSp9+46V6d4I8d22ryraXBFvqCqGkt2PbuVP8Q968Mt9SW437TIChwwdSpFW9GiuNX1mCLT2eGSFgTeqP9T/u+p9unrW+LwFB0E27cq3/AM+5hhcbXVdq17vbsfSHgyHULfQIotZn8+9EkzM+/flTIxQZ9lKj8K3K5T4bxarB4YtItemafUVMgklYglhvbaeOPu7a6uvlT6QKKKKACiiigBGOATXAeMPiJp3hrxNa6de2srNNatOLmJQ20BtuzHXnrXeXOfJbFfO/xcuXXx1p0KQTSzfYpJP3Sbjt346DnrXVg6UK1ZQqOyOfFVJ0qTlTV2dTq/xX02e2mSBb0lkZR+4I6giuG8Ja9qfhWztms3kubFkUzWUjZZDjkoT0+lYcmovED5lteLjrmFqG1OJbdZ2fEbAEE9Tn2r6ahgMNGEoR95PfW587XxuJcoykrNbaHutz4psvEHw812ezmV1bT7gEfxIfLbgjsa0fB9xJafCTTLiAgSw6SsiHGfmEeRx+FeJeGtJvpNO17WGL2cDadcL5C9Zh5bfM/wDnNe8/DVQ3w88PKwBU2EQIPf5RXzGLpU6VVwpyuj6LDVJ1aalUjZnibfEDx1p+nDU7vWUuoobTT7uS3GnovmG4cq6ZAyAAOMc5qnZfGPxNcXt0h1GNLSZQVuHtU/0MfaAjOUAzhUPKtk9zX0s1paBDut4NoAzlBjC9PyrlB4t8CeTdzDVND2QPsnYMnDOcHPrkgj3xXMdB4vqXifxDH4m1LXtI8SLqI0/R9yTrYBUu0F2VClTwOM/MvXtV3S/FnimDRL260y/isYrSKe+ktxZq/nObsIFy3KjbnpzXqPiPx74O0HRYrtbjT7oTRJ9ntrcoWmjLhQFHTAJJ/A1uaVrfhrVb+fTtPutOnvY1/fW8e0sBnJBHfB6+9AHl/wAMfiB4o8RePI7TVJLNLSVrkS2IUCS3VP8AVnG3cM+rHnPFd/41jQ+LvA8hRfMXUJlDY5ANtLkfoK6yO1t47h544IknkGHkVAGYe56muV8af8jV4I/7CMv/AKTS0AZ3gj/kp3xA/wCu1p/6IFch4q+E+t6tqfiCO2m0lbTVL1r4X0ys1zFlAoiUY4XI656HpW9IPFHhvx94nv8ATvDD6vZao0DxSx3iRbdkYUghh6itH/hL/GP/AET24/8ABnF/hQBxZ+FuvtqUesfZNBW5j2QjS97G0ZBAYjKTs/1mTkHHTj3rH8NfArWtI8Q6HfT3lpcray200h851EXluSVRNvzA5GORg5r0z/hL/GP/AET24/8ABnF/hTovFvjGSRU/4QCZNxxufU4wB7n5elAEPxwXd4d0ZfXWrIf+RRWlrPheO7lkbbnJNYni6z8XeKodLs5fD1nYwwajb3ckx1MSYWNwxAUIMnFenYoA8J8ZeAbq4stmmiNLgSo4aTOAAeelT+FfACWc4ldTLOwAeVurf4D2r2iW2STqBRFbRx9AK29vUVP2Kfu7mfsYc/tGtTjvCUGqQeMNbtbqFl0mGG3NmxTCsx3b8Hv0FdxXNaRqOqz+N9esbqErpVtDbtavswGZt2/5u/QV0tYmgUUUUAFFFFAEdxEJYyprzOPwNdjxL4hvbuRJLS9eJrZAxJjCqQ2R2yT2r1Cua8PaXqlp4q8TXl/MJLC8eA2aeYW2BUIbj+HkigDzHxj4CuLnTpY9PWNbjcrIZOF4YHnFJ4W+HwtbkTz5muWADSMP0A7CvbpbdJOoFJFaxxnIArZYioqfsU/d3MnRg5+0a1OZ0Twstn4i/tYTYzYiz8nb6SF92f0xXW1jDR5B4wbWfP8A3RsBZ+Rg9RIX3Z6d8Vs1iahRRRQAUUUUAQ3UImjKmvObfwtqF1qWuHVYz9n+1j7DnH+p8tc9P9rd15r0ysPw9Lq8mp68uqoVtUvAtiSoG6Hy1OeOvzbutAHJHwNFn7n6Uf8ACDRf3P0r0nFGKAPNv+EGi/ufpUF14HjEZwnP0r1DFIyhhgigD5yvfhxeT65dM8gjsJdhCxk72IGCD6CvSPB/hKKwEK+UFjXA2gdq7xrOMtnAqeONYxhRW1XEVKsYxk9FojKnRhTblFavcxfBUOpw+H4V1wH+0PMl35x93zG2dOPuba3axvCMmqS6FE+vIUvzLMGBUD5RKwTgcfc21s1iahRRRQAUUUUAIw3DBriNZTSrjxpbaRJaltVlsnuEn2DCxB8Fd3XrzjpXcVgT3+kL44tbGS2zrj2Lyxz+UDiEOAV39ue1AHJ674NSSGURoMlSB+VcF4X+Gc9s8Mmqstxcx4Cqv3I8enqfevoWSNXGCKiS0jVs4H5VtTr1KcJQg7J7mU6MJyUpK7WxxGraIlj4G10hcEafcf8Aotq2vhn/AMk+8O/9eMP/AKCKt+NImfwbrscKMztYTqqqMkkxtgAVxngPx54e07wXolne3dxDcwWccckbWU+VYKAQfkrE1PSLyD7TaTwFiolRk3DtkYzXjFt8M/FFtHpUiXHhxptCZE0+M2eFmRVZd0rfeDYbOBkZGa7z/hZPhb/oITf+ANx/8RR/wsnwt/0EJv8AwBuP/iKAPMIPgv4g07T7mzsNT0yePVRG2oNcRNmF1m8z9xjoOcc10Pwx+FV14S8TJfXc9nPDaJPHbzIZDLIJWydwLbVx7Dmuu/4WT4W/6CE3/gDcf/EUf8LJ8Lf9BCb/AMAbj/4igDsK4/xp/wAjV4I/7CMv/pNLR/wsnwt/0EJv/AG4/wDiKxtS8TaV4j8YeD4tGmnuHgvpZZf9FlQIv2eQZJZQOpA/GgD0mjFFFABiiiigAooooAKKKKAOXfVNZtfiAun3Fi0ug3dqHt7qJM+TMpO5JD2BBBB9qvWPirQr/W59Hs9UtptUg3ebbI2XTb97I9sitqq8dlaxXDXEdtAk7Z3SLGAxz1yetAGba+KtCutfl0S31S2k1aLcHtVb512jJyPbNEXirQ5fED6HHqls2rpkNaBv3gwMnj6c1pJZWqXLXCW0C3DZzKIwGP49aFsrVbo3K20AuD1lEY3/AJ9aAM3/AISrQ/8AhIf7C/tS2/tjp9k3fvPu7un05ol8VaHF4gTQpNUtl1d8bbQt+8ORuHH05rS+xWv2r7T9mg+0/wDPXyxv9OvWhrK1a6Fy1tAbgdJTGN/59aAMy68VaFa69FolxqlrHq0u0Jas/wA7bhkYHvVLwpY65B4h8T3uszA2V1coNPgD7vLiRMEn0LEk49q6CSxtJLgXElrA84xiRowWGOnPWrFABRRRQBzd/bTWHiyXX7q7ii0eLTTBMrsw2MJC2/HTGOM9ataN4q0PW7K5vNJ1S2u7W2/10kTZCcZ5/Ctl1V1KuoZSMEEZBqG3srW2jeO3toIkf7yxxhQfqBQBmaH4q0LXbe5n0fVLa8hthmZ4myE4J5/I0mheK9C19bltG1S2vFthmYxNnYOev5GtS2srW1V1traCFX+8I4wob64otrK1tQ4traCHf97y4wufrigDL0LxXoWvyXKaNqlrePbDMwibOwe/5GjQ/Fmha9c3Fvo+qWt5PbjMqRNkoM45/GtS2srW1Lm2toIS/wB4xxhc/XFJb2VrbO721tBC7/eaOMKT9cUAZekeLdC1q8uLPSNTtry7twWlhhbLLg4OR9eKqfD+81/UdKub3xLa/YpZ7qRra1ZNskMAOEEnq3GfxrfgsrW3kaS3toIpH+8yRhSfqRVigAooooAKKKKACiiigDkdD8QXun6HqV145SHTPsd5JELgnEcsO7924+oIH1BrSt/FugXGhTazBqtq+lQnbJdBvkU8dT+IrZnhiuIjHPGksZ6q6hgfwNRLZWiWxt1toFt26xCMBT+HSgDLs/Fug3mi3Or2uq2sumWxxNcq2UT6n8RRYeLdA1DSbrVLLVbWfT7XPnzo2Vj78mtRLK0jt2gjtoFgb70axgKfqOlEVlaRQPDFawJC/wB6NYwFb6igDL0zxboGq6bd6hp2q2txZWgzPNG2VjGM8n6UaR4t0HWLK7u9L1W1ura0XdPJG2RGMZyfwFakNlaQQvFDawRxP95EjADfUd6ILG0t43jgtYIo3+8qRhQ31A60AZei+LtA1uC6n0nVbW7itV3zPE2RGMZyfyNZ3hTWdB8X6rc6xpNpLJJZA2ceoSQsiyqfmYRk/eXPeult7G0tkdbe1giV/vCOMKG+uOtTxosaBI1CoBgKowBQAtFFFABRRRQAUUUUAFFFFABRRRQB/9kAAA==" alt="images/intro/C-bigpic.png"><hr class="calibre17"><b class="calibre13">Figure 5. C compilation process pipeline</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Before we can get to actual compilation, we have to preprocess C files
to handle includes and macros. The preprocessor spits out pure C code
with some line number directives understood by the compiler. The compiler munches
on that for a while and then spits out assembly code (text-based
human-readable machine code). A separate assembler translates the
assembly code to binary machine code. With a few command-line options,
we can expose this pipeline.</p><p height="10" width="0" class="calibre5">Lets follow the pipeline (shown in Figure 5, <a href="#text/part0000_split_018.html.fig.C-bigpic"><em class="calibre6">C compilation process pipeline</em></a>) for the C function in file <code class="calibre21">t.c</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() { ; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">First we preprocess <code class="calibre21">t.c</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">cpp t.c tmp.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># preprocess t.c, put output into tmp.c</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">That gives us the following C code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"># 1 <em class="calibre6">"t.c"</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// line information generated by preprocessor</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"># 1 <em class="calibre6">"&lt;built-in&gt;"</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// it's not C code per se</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"># 1 <em class="calibre6">"&lt;command line&gt;"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"># 1 <em class="calibre6">"t.c"</em>&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() { ; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we had included <code class="calibre21">stdio.h</code>, wed see a huge pile of stuff in front
of <tt class="calibre21">f</tt>.
To compile <code class="calibre21">tmp.c</code> down to assembly code instead of all the way to
machine code, we use option <code class="calibre21">-S</code>. The following session compiles
and prints out the generated assembly code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">gcc -S tmp.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b><em class="calibre6"># compile tmp.c to tmp.s</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">cat tmp.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># print assembly code to standard output</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.text</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.globl _f&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">_f:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; define function f</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pushl&nbsp;&nbsp; %ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; do method bookkeeping</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;movl&nbsp;&nbsp;&nbsp;&nbsp;%esp, %ebp&nbsp;&nbsp;; you can ignore this stuff</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subl&nbsp;&nbsp;&nbsp;&nbsp;$8, %esp</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; clean up stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return to invoking function</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.subsections_via_symbols</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To assemble <code class="calibre21">tmp.s</code>, we run <code class="calibre21">as</code> to get the object file <code class="calibre21">tmp.o</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">as -o tmp.o tmp.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># assemble tmp.s to tmp.o</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">ls tmp.*</b>&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tmp.c&nbsp;&nbsp; tmp.o&nbsp;&nbsp; tmp.s</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now that we know about the overall compilation process, lets zoom in
on the pipeline inside the C compiler itself.</p><div class="calibre1" id="text/part0000_split_018.html.fig.C-compiler"><img id="text/part0000_split_018.html.d24e1702" class="calibre22" src="data:image/jpeg;base64,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" alt="images/intro/C-compiler.png"><hr class="calibre17"><b class="calibre13">Figure 6. Isolated C compiler application pipeline</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5"> The main components are highlighted in Figure 6, <a href="#text/part0000_split_018.html.fig.C-compiler"><em class="calibre6">Isolated C compiler application pipeline</em></a>. Like other language
applications, the C compiler has a reader that parses the input and
builds an IR. On the other end, the generator traverses the IR,
emitting assembly instructions for each subtree. These components (the 
<em class="calibre6">front end</em> and <em class="calibre6">back end</em>) are
not the hard part of a compiler. </p><p height="10" width="0" class="calibre5">All the scary voodoo within a compiler happens inside the semantic
analyzer and optimizer. From the IR, it has to build all sorts of
extra data structures in order to produce an efficient version of the
input C program in assembly code. Lots of set and graph theory
algorithms are at work.  Implementing these complicated algorithms is
challenging. If youd like to dig into compilers, I recommend the
famous Dragon book: <a href="#text/part0000_split_135.html.d2381e2"><em class="calibre6">Compilers:
Principles, Techniques, and Tools</em>&nbsp;[ALSU06]</a> (Second Edition).</p><p height="10" width="0" class="calibre5">Rather than build a complete compiler, we can also leverage an
existing compiler. In the next section, well see how to implement a
language by translating it to an existing language.
</p><h3 class="calibre23">Leveraging a C Compiler to Implement C++</h3><p height="10" width="0" class="calibre5">Imagine you are Bjarne Stroustrup, the designer and original
implementer of C++. 
You have a cool idea for extending C to have
classes, but youre faced with a mammoth programming project to
implement it from scratch.</p><div class="calibre1" id="text/part0000_split_018.html.fig.cpp-compiler"><img id="text/part0000_split_018.html.d24e1744" class="calibre22" src="data:image/jpeg;base64,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" alt="images/intro/cpp.png"><hr class="calibre17"><b class="calibre13">Figure 7. C++ (cfront) compilation process pipeline</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">To get C++ up and running in fairly short order, Stroustrup simply
reduced C++ compilation to a known problem: C compilation. In other
words, he built a C++ to C translator called 
<code class="calibre21">cfront</code>. He didnt have to build a compiler
at all. By generating C, his nascent language was instantly available
on any machine with a C compiler.  We can see the overall C++ application pipeline in Figure 7, <a href="#text/part0000_split_018.html.fig.cpp-compiler"><em class="calibre6">C++ (cfront) compilation process pipeline</em></a>. If we zoomed in on
<code class="calibre21">cfront</code>, wed see yet another reader,
semantic analyzer, and generator pipeline.
</p><p height="10" width="0" class="calibre5">As you can see, language applications are all pretty similar.
Well, at least they all use the same basic architecture and share many
of the same components. To implement the components, they use a lot of
the same patterns.  Before moving on to the patterns in the subsequent
chapters, lets get a general sense of how to hook them together into
our own applications.
</p>

</div></div>
<div id="text/part0000_split_019.html"><div class="calibre">

<h2 id="text/part0000_split_019.html.d24e1778" class="calibre18">Choosing Patterns and Assembling Applications</h2><p height="10" width="0" class="calibre5">I chose the patterns in this book because of their importance and
how often youll find yourself using them. 
From my own experience and
from listening to the chatter on the ANTLR interest list, we
programmers typically do one of two things.  Either we implement DSLs
or we process and translate general-purpose programming languages.  In
other words, we tend to implement graphics and mathematics languages,
but very few of us build compilers and interpreters for full
programming languages.  Most of the time, were building tools to
refactor, format, compute software metrics, find bugs, instrument, or
translate them to another high-level language.</p><p height="10" width="0" class="calibre5">If were not building implementations for general-purpose programming
languages, you might wonder why Ive included some of the patterns I
have. For example, all compiler textbooks talk about 
symbol table management and computing the types of expressions. This book also
spends roughly 20 percent of the page count on those subjects. The reason is
that some of the patterns wed need to build a compiler are also
critical to implementing DSLs and even just processing general-purpose
languages. Symbol table management, for example, is the bedrock of
most language applications youll build.  Just as a parser is the key
to analyzing the syntax, a symbol table is the key to understanding
the semantics (meaning) of the input.  In a nutshell, syntax tells us
what to do, and semantics tells us what to do it to.
</p><p height="10" width="0" class="calibre5">As a language application developer, youll be faced with a number of
important decisions. Youll need to decide which patterns
to use and how to assemble them to build an application.  Fortunately,
its not as hard as it seems at first glance. The nature of an
application tells us a lot about which patterns to use, and, amazingly,
only two basic architectures cover the majority of language
applications.
</p><p height="10" width="0" class="calibre5">Organizing the patterns into groups helps us pick the ones we
need. This book organizes them more or less according to Figure 1, <a href="#text/part0000_split_016.html.fig.bigpic"><em class="calibre6">The multistage pipeline of a language application</em></a>.  We have patterns for reading input (part I),
analyzing input (part II), interpreting input (part III), and
generating output (part IV).  The simplest applications use patterns from
part I, and the most complicated applications need patterns from I, II,
and III or from I, II, and IV. So, if all we need to do is load some data
into memory, we pick patterns from part I. To build an interpreter, we
need patterns to read the input and at least a pattern from part III
to execute commands.  To build a translator, we again need patterns to
parse the input, and then we need patterns from part IV to generate
output.  For all but the simplest languages, well also need patterns
from part II to build internal data structures and analyze the input.
</p><p height="10" width="0" class="calibre5">The most basic architecture combines lexer and parser patterns. Its
the heart of 
Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a> and Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>. Once we recognize input sentences,
all we have to do is call a method that executes or translates
them. For an interpreter, this usually means calling some
implementation function like <tt class="calibre21">assign</tt> or
<tt class="calibre21">drawLine</tt>.  For a translator, it means
printing an output statement based upon symbols from the input
sentence.
</p><p height="10" width="0" class="calibre5">The other common architecture creates an 
AST from the input (via tree
construction actions in the parser) instead of trying to process the input
on the fly.  Having an AST lets us sniff the input multiple times
without having to reparse it, which would be pretty inefficient.  For
example, 
Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a> revisits AST nodes all the
time as it executes <code class="calibre21">while</code> loops, and so on.
</p><p height="10" width="0" class="calibre5">The AST also gives us a convenient place to store information that we
compute in the various stages of the application pipeline.  For
example, its a good idea to annotate the AST with pointers into the
symbol table. The pointers tell us what kind of symbol the AST node
represents and, if its an expression, what its result type is. Well
explore such annotations in Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a> and Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>.
</p><p height="10" width="0" class="calibre5">Once weve got a suitable AST with all the necessary information in
it, we can tack on a final stage to get the output we want. If were
generating a report, for example, wed do a final pass over the AST to
collect and print whatever information we need.  If were building a
translator, wed tack on a generator from Chapter 11, <a href="#text/part0000_split_105.html.chp.trans"><em class="calibre6">Translating Computer Languages</em></a>
or Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>.  The simplest generator walks the AST
and directly prints output statements, but it works only when the
input and output statement orders are the same.  A more flexible
strategy is to construct an output model composed of strings,
templates, or specialized output objects.
</p><p height="10" width="0" class="calibre5">Once you have built a few language applications, you will get a feel for
whether you need an AST.  If Im positive I can just bang out
an application with a parser and a few actions, Ill do so for
simplicity reasons. When in doubt, though, I build an AST so I dont
code myself into a corner.
</p><p height="10" width="0" class="calibre5">Now that weve gotten some perspective, we can begin our adventure
into language implementation.</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-1" href="#text/part0000_split_017.html.FNPTR-1">[1]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org">http://www.antlr.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-2" href="#text/part0000_split_017.html.FNPTR-2">[2]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-3" href="#text/part0000_split_018.html.FNPTR-3">[3]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.lua.org">http://www.lua.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-4" href="#text/part0000_split_018.html.FNPTR-4">[4]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://en.wikipedia.org/wiki/Smalltalk_programming_language">http://en.wikipedia.org/wiki/Smalltalk_programming_language</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-5" href="#text/part0000_split_018.html.FNPTR-5">[5]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://jakarta.apache.org/bcel/">http://jakarta.apache.org/bcel/</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_019.html.FOOTNOTE-6" href="#text/part0000_split_018.html.FNPTR-6">[6]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a></p></dd></dl><div class="calibre3" id="text/part0000_split_019.html.calibre_pb_34"></div>

</div></div>
<div id="text/part0000_split_020.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_020.html.calibre_pb_35">&nbsp;</p><a id="text/part0000_split_020.html.toc-7"></a><h4 class="right2" id="text/part0000_split_020.html.chp.parsing">Chapter 2</h4>
</div></div>
<div id="text/part0000_split_021.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_021.html.calibre_pb_36">Basic Parsing Patterns</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">Language recognition is a critical step in just about any language
application.  
To interpret or translate a phrase, we first have to
recognize what kind of phrase it is (sentences are made up of phrases). Once we know that a phrase is an
assignment or function call, for example, we can act on it.  To
recognize a phrase means two things.  First, it means we can distinguish
it from the other constructs in that language. And, second, it means we
can identify the elements and any substructures of the phrase.  For
example, if we recognize a phrase as an assignment, we can identify
the variable on the left of the <code class="calibre21">=</code> and the expression substructure on
the right.  The act of recognizing a phrase by computer is 
called <em class="calibre6">parsing</em>.</p><p height="10" width="0" class="calibre5">This chapter introduces the most common parser design patterns that
you will need to build recognizers by hand.  There are multiple parser
design patterns because certain languages are harder to parse than
others.  As usual, there is a trade-off between parser simplicity and
parser strength. Extremely complex languages like C++ typically
require less efficient but more powerful parsing strategies. Well
talk about the more powerful parsing patterns in the next chapter.
For now, well focus on the following basic patterns to get up to
speed:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.  
This pattern
tells us how to convert a grammar (formal language specification) to a
hand-built parser. Its used by the next three patterns.</li><li height="6" class="calibre20"><span></span>Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>. 
This pattern breaks up character streams into
tokens for use by the parsers defined in the subsequent patterns.</li><li height="6" class="calibre20"><span></span>Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>.  
This is the most well-known
recursive-descent parsing pattern. It only needs to look at the
current input symbol to make parsing decisions. For each rule in a
grammar, there is a parsing method in the parser.  </li><li height="6" class="calibre20"><span></span>Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>. 
This pattern
augments an <em class="calibre6">LL(1)</em> recursive-descent parser so that it
can look multiple symbols ahead (up to some fixed number
<em class="calibre6">k</em>) in order to make decisions.</li></ul><p height="10" width="0" class="calibre5">Before jumping into the parsing patterns, this chapter
provides some background material on language recognition.  Along the
way, we will define some important terms and learn about grammars.  You
can think of grammars as functional specifications or design documents
for parsers.  To build a parser, we need a guiding specification that
precisely defines the language we want to parse.</p><p height="10" width="0" class="calibre5">Grammars are more than designs, though. They are actually executable
programs written in a domain-specific language (DSL) specifically designed for expressing
language structures.  Parser generators such as ANTLR can
automatically convert grammars to parsers for us. In fact, ANTLR
mimics what wed build by hand using the design patterns in this
chapter and the next.</p><p height="10" width="0" class="calibre5">After we get a good handle on building parsers by hand, well rely on
grammars throughout the examples in the rest of the book.  Grammars
are often 10 percent the size of hand-built recognizers and provide more
robust solutions. The key to understanding ANTLRs behavior, though,
lies in these parser design patterns.  If you have a solid
background in computer science or already have a good handle
on parsing, you can probably skip this chapter and the next.</p><p height="10" width="0" class="calibre5">Lets get started by figuring out how to identify the various
substructures in a phrase.</p>

</div></div>
<div id="text/part0000_split_022.html"><div class="calibre">

<h2 id="text/part0000_split_022.html.sec.if-diag-tree" class="calibre18">Identifying Phrase Structure</h2><p height="10" width="0" class="calibre5">In elementary school, 
we all learned (and probably forgot) how to
identify the parts of speech in a sentence like <em class="calibre6">verb</em> and
<em class="calibre6">noun</em>. We can do the same thing with computer languages
(we call it <em class="calibre6">syntax analysis</em>). Vocabulary symbols (<em class="calibre6">tokens</em>) play different roles like <em class="calibre6">variable</em> and
<em class="calibre6">operator</em>. We can even identify the role of token
subsequences like <em class="calibre6">expression</em>.</p><p height="10" width="0" class="calibre5">Take <code class="calibre21">return x+1;</code>, for example. Sequence <code class="calibre21">x+1</code> plays the role of an
expression and the entire phrase is a return statement, which is also
a kind of statement. If we represent that visually, we get a sentence
diagram of sorts:</p><div class="calibre1"><img id="text/part0000_split_022.html.d24e2003" class="calibre30" src="data:image/gif;base64,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" alt="images/parsing/return.png"></div><p height="10" width="0" class="calibre5">Flip that over, and you get what we call a 
<em class="calibre6">parse tree</em>:</p><div class="calibre1"><img id="text/part0000_split_022.html.d24e2016" class="calibre30" src="data:image/gif;base64,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" alt="images/parsing/return-tree.png"></div><p height="10" width="0" class="calibre5">Tokens hang from the parse tree as leaf nodes, while the interior nodes
identify the phrase substructures. The actual names of the
substructures arent important as long as we know what they mean.  For
a more complicated example, take a look at the substructures and parse
tree for an <code class="calibre21">if</code> statement:</p><div class="calibre1"><img id="text/part0000_split_022.html.d24e2023" class="calibre24" src="data:image/gif;base64,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" alt="images/parsing/if-diag-tree.png"></div><p height="10" width="0" class="calibre5">Parse trees are important because they tell us everything we need to
know about the syntax (<em class="calibre6">structure</em>) of a phrase.  To parse,
then, is to conjure up a two-dimensional parse tree from a flat token
sequence.
</p>

</div></div>
<div id="text/part0000_split_023.html"><div class="calibre">

<h2 id="text/part0000_split_023.html.d24e2032" class="calibre18">Building Recursive-Descent Parsers</h2><p height="10" width="0" class="calibre5">A parser checks whether a sentence conforms to the syntax of a <em class="calibre6">language</em>. (A language is just a set of valid
sentences.)  To verify language membership, a parser has to identify a
sentences parse tree. The cool thing is that the parser doesnt
actually have to construct a tree data structure in memory.  Its
enough to just recognize the various substructures and the associated
tokens.  Most of the time, we only need to execute some code on the
tokens in a substructure. In practice, we want parsers to do
this when they see that.</p><p height="10" width="0" class="calibre5">To avoid building parse trees, we trace them out implicitly via a
function call sequence (a call tree).  All we have to do is make a
function for each named substructure (interior node) of the parse
tree. Each function, say, <em class="calibre6">f</em>, executes code to match its
children. To match a substructure (subtree), <em class="calibre6">f</em> calls the function
associated with that subtree. To match token children, <em class="calibre6">f</em> can call
a <tt class="calibre21">match</tt> support function.  Following this simple formula, we
arrive at the following functions from the parse tree for
<code class="calibre21">return x+1;</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** To parse a statement, call stat(); */</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void stat()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { returnstat(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void returnstat() { match("return"); expr(); match(";"); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void expr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { match("x"); match("+"); match("1"); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Function <tt class="calibre21">match</tt> advances an input cursor after comparing the current
input token to its argument.   For example, before calling
<code class="calibre21">match("return")</code>, the input token sequence looks like this:</p><div class="calibre1"><img id="text/part0000_split_023.html.d24e2103" class="calibre30" src="data:image/gif;base64,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" alt="images/parsing/return-lookahead1.png"></div><p height="10" width="0" class="calibre5"> <code class="calibre21">match("return")</code> makes sure that current (first) token is <code class="calibre21">return</code>
and advances to the next (second) token.  When we advance the cursor,
we <em class="calibre6">consume</em> that token since the parser never has to look at it
again. We can represent consumed tokens with a dark gray box:</p><div class="calibre1"><img id="text/part0000_split_023.html.d24e2121" class="calibre30" src="data:image/gif;base64,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" alt="images/parsing/return-lookahead2.png"></div><p height="10" width="0" class="calibre5">To make things more interesting, lets figure out how to parse the
three kinds of statements found in our parse trees: <code class="calibre21">if</code>, <code class="calibre21">return</code>, and
assignment statements.  To distinguish what kind of statement is coming
down the road, <tt class="calibre21">stat</tt> needs to branch according to the token under
the input cursor (the light gray box).  We call that token the 
<em class="calibre6">lookahead token</em>.  Heres one way to implement <tt class="calibre21">stat</tt>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void stat() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( <em class="calibre6">lookahead token is return</em> )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnstat();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if ( <em class="calibre6">lookahead token is identifier</em> ) assign();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if ( <em class="calibre6">lookahead token is if</em> )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifstat();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else <em class="calibre6">parse error</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We call this kind of parser a <em class="calibre6">top-down parser</em>
because it starts at the top of the parse tree and works its way down
to the token leaf nodes. </p><p height="10" width="0" class="calibre5">More specifically, were using 
Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>.  <em class="calibre6">Descent</em>
refers to its top-down nature, and <em class="calibre6">recursive</em> refers to the fact
that its functions potentially call themselves.  For example, in <a href="#text/part0000_split_022.html.sec.if-diag-tree"><em class="calibre6">Identifying Phrase Structure</em></a>, the <em class="calibre6">stat</em> substructure for the assignment
statement appears within (under) the <em class="calibre6">stat</em> for the  <code class="calibre21">if</code>
statement.  Nesting in a parse tree begets recursion in a
recursive-descent parser. The formal designation for a top-down parser
that uses a single lookahead token is <em class="calibre6">LL(1)</em>.  The first <em class="calibre6">L</em> means read
the input from left to right. The second <em class="calibre6">L</em> means descend into
parse tree children from left to right. For complicated languages,
we can use more lookahead yielding Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>.</p><p height="10" width="0" class="calibre5">At this point, weve got a parser that can recognize the various
substructures using different functions. But, thats all it does.  To
execute application-specific code upon seeing a particular
substructure, we have to add code to the appropriate
function. For example, if we want to print found return every time
we see a return statement, we can add the following anywhere in <tt class="calibre21">returnstat</tt>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">System.out.println("found return");</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The patterns that follow this introductory material fill in some
details, but thats really all there is to building parsers:
predicting which kind of phrase approaches, invoking functions to
match substructures, matching tokens, and executing
application-specific actions (code).</p><p height="10" width="0" class="calibre5">The first few 
recursive-descent parsers you build are pretty fun.
After a while, though, building them is monotonous.  The parsing
functions are so similar and consistent that we can easily generate
them automatically.  The only problem is describing the structure of
our language to the computer. Since most languages have an infinite
number of sentences, we cant just delineate them.  For the same
reason, we cant delineate all possible parse trees.  What
we need is a DSL for specifying languages.
</p>

</div></div>
<div id="text/part0000_split_024.html"><div class="calibre">

<h2 id="text/part0000_split_024.html.d24e2257" class="calibre18">Parser Construction Using a Grammar DSL</h2><p height="10" width="0" class="calibre5">Building recursive-descent parsers in a general-purpose programming
language is tedious and error-prone. 
We have to type the same code
templates over and over again.  Its much more productive to use a DSL
specifically designed for describing languages.
Programs in this DSL are called <em class="calibre6">grammars</em>.  Tools that translate grammars to
parsers are called <em class="calibre6">parser generators</em>.  Grammars
are concise and act like functional specifications for languages. They
are much easier to read than the equivalent recursive-descent parser
implementations.</p><p height="10" width="0" class="calibre5">Substructures in the parse tree and functions in the parser correspond
to <em class="calibre6">rules</em> in a grammar. The children of a substructure become
references to rules and tokens on the right side of a rule
definition.  The if-then-else code template in the parser becomes a <code class="calibre21">|</code>
separated list of alternative substructures. Here is one way to
encode the recursive-descent parser from the previous section as an
ANTLR grammar:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : returnstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// "return x+0;" or</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | assign&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// "x=0;" or</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ifstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// "if x&lt;0 then x=0;"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">returnstat : <em class="calibre6">'return'</em> expr <em class="calibre6">';'</em> ; <em class="calibre6">// single-quoted strings are tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'x'</em> <em class="calibre6">'='</em> expr ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ifstat&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'if'</em> expr <em class="calibre6">'then'</em> stat ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'x'</em> <em class="calibre6">'+'</em> <em class="calibre6">'0'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// used by returnstat</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | <em class="calibre6">'x'</em> <em class="calibre6">'&lt;'</em> <em class="calibre6">'0'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// used by if conditional</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | <em class="calibre6">'0'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// used in assign</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This example foreshadows much of Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.</p><p height="10" width="0" class="calibre5">Read rule <code class="calibre21">stat</code> as A <code class="calibre21">stat</code> can be either a <code class="calibre21">returnstat</code>, an <code class="calibre21">assign</code>, or an <code class="calibre21">ifstat</code>.  We can use a <em class="calibre6">syntax diagram</em> to
visualize the control flow within that rule (using ANTLRWorks):</p><div class="calibre1"><img id="text/part0000_split_024.html.d24e2397" class="calibre31" src="data:image/jpeg;base64,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" alt="images/parsing/stat-syndiag.png"></div><p height="10" width="0" class="calibre5">If there is only one alternative, such as in rule <code class="calibre21">returnstat</code>, the
syntax diagram shows just a sequence of elements:</p><div class="calibre1"><img id="text/part0000_split_024.html.d24e2403" class="calibre2" src="data:image/jpeg;base64,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" alt="images/parsing/return-syndiag.png"></div><p height="10" width="0" class="calibre5">When rules get more complicated, syntax diagrams come in 
handy. For example, here is the syntax diagram for rule <code class="calibre21">expr</code>:</p><div class="calibre1"><img id="text/part0000_split_024.html.d24e2413" class="calibre32" src="data:image/jpeg;base64,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" alt="images/parsing/expr-syndiag.png"></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">expr</code> might look a little funny to you, and it should. It says
that expressions can only be  one of three alternative token
sequences. Further, variables can only be <code class="calibre21">x</code>, and integers can only be
<code class="calibre21">0</code>. This brings us to the last piece of the language recognition
puzzle: combining input characters into vocabulary symbols
(tokens).
</p>

</div></div>
<div id="text/part0000_split_025.html"><div class="calibre">

<h2 id="text/part0000_split_025.html.sec.tokenizing" class="calibre18">Tokenizing Sentences</h2><p height="10" width="0" class="calibre5">Humans unconsciously combine letters into words before recognizing
grammatical structure while reading.  
As adults, we are so good at it
that we dont notice it.  Beginning readers, on the other hand,
move along with their fingers trying to sound out the words.</p><p height="10" width="0" class="calibre5">Reading Morse code exposes this hidden process nicely by forcing us to
move character by character. Before interpreting a sentence as
English, we have to convert the dots and dashes to letters and then
combine the letters into words.  Once we have words, we can apply
English grammatical structure.  For example, here is <code class="calibre21">print 34</code> in
Morse code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.--. .-. .. -. - -- .-</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;&nbsp; i&nbsp;&nbsp;n&nbsp;&nbsp;t 3&nbsp;&nbsp;&nbsp;&nbsp; 4</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Recognizers that feed off character streams are called <em class="calibre6">tokenizers</em> or <em class="calibre6">lexers</em> (see Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>). Just as an overall
sentence has structure, the individual tokens have structure. At the
character level, we refer to syntax as the <em class="calibre6">lexical structure</em>.</p><p height="10" width="0" class="calibre5">Grammars describe language structures, and so we can also use them for
lexical specifications.</p><p height="10" width="0" class="calibre5">For example, here are suitable definitions for
numbers and identifiers:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Number : <em class="calibre6">'0'</em>..<em class="calibre6">'9'</em>+ ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// 1-or-more digits (0..9)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ID&nbsp;&nbsp;&nbsp;&nbsp; : (<em class="calibre6">'a'</em>..<em class="calibre6">'z'</em>|<em class="calibre6">'A'</em>..<em class="calibre6">'Z'</em>)+ ; <em class="calibre6">// 1-or-more upper or lower case letters</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now we can make a better version of rule <code class="calibre21">expr</code> using generic
variable names and numbers instead of specific ones:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ID <em class="calibre6">'+'</em> Number&nbsp;&nbsp;<em class="calibre6">// used by returnstat</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ID <em class="calibre6">'&lt;'</em> Number&nbsp;&nbsp;<em class="calibre6">// used by if conditional</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// used in assign</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This rule still isnt general enough, but it demonstrates how lexical
and syntactic rules can interact. To make things more concrete, lets look at a real grammar for a
simple language. Say we want to recognize lists of names such as
<code class="calibre21">[a,b,c]</code> and nested lists such as <code class="calibre21">[a,[b,c],d]</code>.  We could use the
following ANTLR grammar with three syntactic rules and one lexical
rule (lexical rules start with an uppercase letter):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/topdown/NestedNameList.g">parsing/topdown/NestedNameList.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">grammar</b> NestedNameList;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'['</em> elements <em class="calibre6">']'</em> ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match bracketed list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">elements : element (<em class="calibre6">','</em> element)* ;&nbsp;&nbsp;<em class="calibre6">// match comma-separated list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME | list ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// element is name or nested list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">NAME&nbsp;&nbsp;&nbsp;&nbsp; : (<em class="calibre6">'a'</em>..<em class="calibre6">'z'</em>|<em class="calibre6">'A'</em>..<em class="calibre6">'Z'</em>)+ ;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// NAME is sequence of &gt;=1 letter</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> We can see the parse trees for those two sentences in the following diagram:</p><div class="calibre1"><img id="text/part0000_split_025.html.d24e2588" class="calibre34" src="data:image/gif;base64,R0lGODlhaAHFAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAABoAcUAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fNcelu0fuwAFxQJMqXcr04rh38MqtY4d04LiqTbNq3frzqbty7NKJM3eOnLmwWLmqXcu2JTp5YeEdKAcvHjt39Nqlbcu3r1+O+OSZuyfvQLp579K5k3fvr+PHkCO2e0euHbxxB+a5qxzPXOTPoEOTq6tOHjx07OLNO/Du3bjQsGP3PQAPXjvT6+TJi3cPHmXZwINnFVeOHLnix4uPO75XuPPnN9Wpe60QHT5y0LNrh6mO3rtyA8f+iiWoTjP27ejTk+zOGOs4dvDOCxzXzrtn9fjzYxS3jp7ctOMsJt987NATzwH6JaigQ+SwU09UBtEnz4Dz5SYPOgtmqOFA5bhTTzsUzifgQeIQNg+GG6aInzis5UVdhLeFKBCL8dAznoo4ZodOjeu8GOGICZXDY3M5FgmaiesQaVWMCz3lopFQfiZOd/Ggo+RA5CwGXpN4fXVllGBm9Z6B53z5zziB1eMaQ/SRGeabamVZj5dstlMPAPRsudCU88zTGJyAKiXOOfDQw46PC6FzZ3wOibMjPeqYGeikMZUoDz1JQlTOPPSg+JA5hbajJ6WkzsTfPPHc+JA4+MQj40L+cr6DYKm0vvSemuZIehA59+gaYYG8+VrrsBMhhZU443T4IaIn8SfPPJEWZCyx1Eq0nHHGIYWOZZgKCxKhhqaDHbbYVmsuQ8Sdc84B6o5jTjwAfOhtSOTIE2+PZLG77rznkppuOuqkgw5r8Z4mkzjtzIPnOuagE/DA/PY7qTjkoFNoqgnHE6mkY5U5EovuIIZaPVUeJfHJ4ZVD2JzoDHyVQwfE0w6zEImj63LoAPwsxCijTDGSZTUqUGazVjXtP2kZjfSZ60y3dJPq3sZzzxL//Kw659AsLTrusHOAOvFcxU5i67jTjjtmu2OlOmhP9Q7a6tQXzznrvKPOqzMaxc7+hSZT3a/V0Ga9pzrv7KZObQ0WajYA8cBTz6XqtMrpZPQ8eza066BqpULuHrD31H6bCzjWWg90gOX3nAMXleyc5V1dqZ0Tj5rq3BPPO+vIZZm7po16UOdS9x16taMLrhA+3mGdWeGGqnOAO/Dk1s7eubmjjjn94VOahemc886JTZrjOd8RD2/k6AfgLdBb0a+rWcLtrKNY7fB4L886MuNzzmT7y5OwbXWRVfjGBzrzDctqhkJH6QbCtXQwrRzjiJs5xoGOcqhsUNPZ33TY9Y+clQNr2GvHrDjXsMIV0IC0Io7tSOa0Ri0wIsJKFjsAQD4UEoti54BPOxTYkOWkI1P+F2GR88ghqWSBzR3nyJUNbziOJjbxS8h6HqfcYTQlEclmM9pb5e7xMoUgy4nlW6K/hAKPZ72DizNyGKKIs7mClCMd1HHXbeYBFyKK8Y4IEUc6CjUPUb3IUhAiyHvCZhB05OVY5ChN5UQVRjxSa5B9wocSw0OYKv1oQjA6JEFw+D3NTNKRBgRLjeRxvb1YSh7n+B2TYCSvCHGtcmd8IaA6JC58jBCU/zjAbQyUDt+lUTep/B2QftVKVxYoebIM0z0+1CDfWdCGjtplYnw5I8KgMiESwlubZpZH1FwKHuqgJqDSwZsfJisd3SMnOwwYzT65Q1wJOWUwERIgTGLTTof+iucB8PegcJYKH1GJh6vcEY/7vaNTwxvH/uihGY/F8y3X5Nwq71kPqizkLLPjjTihNJqvxGMz77BLh9oROoXWp6FmkidDyPG9T9LTTnphiChJdo9y2ANO95gHO1THjjfOYx07sijKTNqndzjUixCdJzbxMY85bXRJFU1mOdpRI97YEUzdYUd30Lajtz1JYpjBC2KEh1RgNoSld8pTD/Hpq8pc6kJdNNKOroc7d0AFHblxYL/C6s4DJBNpSX3IOe7kKofQp5joatBb4dhI4djsicj64lUii8UDIk2KmvHrqgL7kE3ZKIZsXVWDOKUxmzU2NnPd0zq4SasGca2vf/3+ZURXhT/1qbKi3qJY5gzUDqyd9jMrU4cg2dEr8swptjgClYHkgUTkAtasEuEVvw4r1FV98Fl0zGeC3vJTH9WLtTPCB64mJRR7AcBP88KeNZUKQ4pQ9xzwtO4M4/UV/ZQnVXuplzvWiLwDBYoztQEvPS14HOM4qHHsPQmayjiPXFmQwGaiTV3q91u+TIlMzfkus06FXzgRpxzmKA4Uy3GOlg0sHea9DEscZa96OK9lJQ4aCUEMQfXc6h33MYh+aabHS6nqXCRWFzrOAgD6OncjjqJHkVOlribbVkGVmRPeNJwQcPUoOxS85UiCrK57fM8d63gyicmqkSlRdR62REf+k4/8j4o99TPmeMeyFLJjhbRIu87JDDz24xAuw5cdnmIIT9kcniuVQ3v6GtiTD9IdfASR0JW6s5nG4b8XHnYzwVnOWD6KlGyRA4yfng8RKbacq5yjhQvxs4y9aJw2X5PUTnziVT19FSJGMMwKKYea1yza1+SmMaXW9GTtSDFbXwtZAKtwSvTYJyDaGTHlmLSDKKNsnxAHoCUm5aC4ejazES5JnPnaOyaDNTpqGSFcVvSeCEWZ0uQKbL0dt9nqdhRdJmZshMOrgZ6q6yavuknoGHfijHM4rYLTeocrU8BldTaonPq4gmLPjxFCjtk96M1I68/cqs2TroITbG+Ey9z+DvpW+zC4bAbqY2ZiKlN///sgthNowDuzN80UiI4GghQ5G3e2lGtvHnoN0q7b1RBx7K02XANRGWsTshrRUadgq4uQKkePe+QG4zYZ09wY1OL9Fh3FP+V4TsRxULvY2xxm/Pldlusbkn3ly/d7C9b/oWr1xcw/+BDS9PpUPyrppjSvjAc+CAMPwuzPv7netbpX+ix46Kx2lVPbQXPnG5ldym4Vr82FxqYUZdW3UeKtR4LjKTtNQkYcgjdLaboGdBJ/j3DWmwc8UKUuumgVLnvLcarpNviXF+Qe9HCHUU5HOefp8jTyGDdzdRri8twebPF4M4nXgY/FezFz95hLwuD+cyBzvAsee7sHfELWunMEZua5+421wYXnPtNx7gMxh4cw/RhxlHGH/Ym9XWQHZlIuEyqaoQ57Qzdz8j2BFk+up1PpoxCqo1MA4x14YRepsVNVUih7w1xf0xnwgyrSZz/rsIAMAXy2MVUVVR/Wg3b3cBuEI3vZBX0shRjesWiVAnbO9hABEi0R0SAPclR+YRji4mYUJDCYcRxlUTHe1zLelzW8koQySGIWCIL0dACpY0EDQ2LdQxYQVG/oYBZDYRyeQWJjZiauJw/ds2iOIoQqYxw5kytlAoYHMDA5cw4klisN84a6pxNGhyrFJRHEQWgX1h6Uki7t0A6pI4MpoWv+7LBDUOgckTVZSGMW9YFjLcFs0LKFSNOIlVUkZqFm3gdpIlEUajYXnrgWxHEA3hdidLcYwTeKGWExlnMVpniKhrgisRZXNCFZTwQdLKIu7FIc7bBkrKgRqrMw5MCLtSd2ODGEPmEWyPgRFtSMIcEiDoMP3WMnsleD9HRV9LI3jwNU69A0cgiNNYFiwsUT76FiPTEZsxhpb4Ep6dAabbQn73iHIEEOuRM/hVJ42vgYjdYT2dQTZBd9SSGNfbQuowZ6hWERfVh06XI4jLGPjtGP5jhMeBhS8Hcwb6iALoVNtmaRl/hYIqZpj3gVpUZEO5JK5aBZnHMOXsYY0fYZErn+E//IE+JAUBfJjv5jFLJEKDIjJIdSN3bRKoVTF9H3PP6DP40jF44jgK1RjglRjHuUKhD5FzGpE/W0jisGFTcJEwS5UxO0EIQyRapzati1do7zdEDZR+lAQ4UTM5TxPevwZgq1Rw8pjjRRlTkxkzsRkFv5EtKYkyqZEOswJ3KYGuVwUJIkO4lxP7VxUGrTY/jQGnShQOWxDmwCX3UhLnY5E3iZjBQ5djY5kBnpNYGJEPknMAVVGgVZIOwAUKejG8nDNUaVXX0UFuN2mXRJFJspE91hmeY4URUZSD/xl17zlQxYG1hjV6hxOw6zU9ozGr2FnOlAXHTRDgC1WnbllNj+VGKFo5uRQRtuYpVgYyjBKBJC0SfsgJUuQZC8YZz6xENFAVgI0kRtZmqwqEAUE0VEdBQRBEds4k11GRm/GC/rpBNygid9iRLjAC8AIJwA+YY10jp/NRbqeRDmYIgR9D2F95KQcRiMQ482sUwNWqHN4g5F5pvDyYXrUBaSUhT4gw+nVZMas5EkYhjqUEEkOpAmSlI8sSn1MHE3cQ6ccoBtwUmVU3hVEWo6RiT0iTStQg+GUhzagUVIkTnjYVrJSFU5+jFUKpkfyRYUAzZ05A65UhV0gaJLMnFoQn82s0ecIitbyhXJ8mDk8ENzQafl6RGJlKccgSwPZkFalRwExhX+yDKeaLaPQuJiOlZpBYEmq1ho3sN3PBQcqhZjLsenHbGbxaJqQ9dkIAoUFDNHPwWRiYqNruZ1BdEgwUchYzFHqWKLUlKMTdapQxensZEuQiZkMFZiZAYUU/VWFdQcpUokVKZjBUJ/gnRofSJSsVGpLqdmmHoRReGIOIGr/kY4IsSLmtoR3lMjp/Eqw0pxzKU1bYKq0hJyBtJToIFDLteuxlMpZwMW1VUT1tpkTGVUJUajO/Fa3mGJ6DY7pooljPpSqxok5MRbo9cXfsZ97eNkM+EVgxKP/5A6B8Nl9wA98qAm7DJk2xpEXKMbO6Q+4fqU4ypRBWuwcqZTPGhhskr+lqYhe/4WrRURM8K3ovYYFpmjfn4ZZK/0LACArxxLk9tCRyIkhgA7aQN7TyeLTYpRDyrbsYfYZFEpZ6jksDLxa+UBX3g3OwI2iTz7LKulsfkKtTA0tDkpKSMbT4dxGmaiqsjKtAdFD/pDtiTBrqc2exk7N7wmE2MzDrnDIprRIZ1RsUKmhzkrZPpaKftDtL16EHRRDwGbqi0mkLCSMObqRYQDpbYksy7BZVRLcrUqE0/xDjsSFWH5PJTLlTwbSXYiK2ObdYvLXJ/quLMDow2xKfS1aOU6oXsEpT3FuSphtyeVsWi2tzARMx9lGkJZgam7s0J2UH0itkE7E5BItIn+S7v1YLtrVQ/1cG5PeayxpUezlxc1thUWuxi+8Q47pS62mhH9iT03ylXkMHg3VSnphr7voD/5WinLcQ4h00fX67iOo70MUjmzWBmPuiq20ycgkotLUa8mZmLG6xLHQR1USqVtxqHrSWKKF8FC1rgKOjaq0Uca3Ge1Oy9PAaSwAr414ygXYxkSCxQta4w0/K4tMRrwoHuZKBCHMa8rUa/r0q6zaxKHyb3yYEu5RRwDzC8LGV0mCKt7olAhdV7qKiglecWf9ml0Gx6PgoNnEpk+EiC4ZStYXMYuETNFBgAgsiem9RqVARXZS7aVAS1q85GRdVHmpSYJqh+DAjkAEjL+FCLGXYseFORkI2YU4lOMStYtLJFI9lI/Kel9c7EniWbDYOIsjAEj9iRIdnK55/OGluogBAq8e+Ih8RJOMHZC1aJ1K3smwGkVyCMrWwymZMGrpYEniUHKmDs7P+tvQ3YyhyWJwrTJ0qJx3mu+vlUSu9hk+BMWi3Zqe3xRbGM3/gbCnJMzuuwYclLFqkTM0nJfKpwVhuTFE7EcRQfK6iIwvlKT9UCkEXGh2zl0v2wtBJWjyTLLnes4Ptyonykt5BR2W6FQ4PEW2EFixjF8xaFZZpE+IZaSRRE/srTMr5tqcyGj0RbJIGYWx6FZAu0uKelXtKGdEaIvE327WRMg73D+WeljQeJDYwKRkhY0F6JIONH8wMoVuUsiD7KkXPssw4dLVckSMviQMbuxGBV0G/eDvkecMOScR+i8L15kP1FhG3X6PcpXOFCBSvaYfKojUKh0UOF8JiQ9zw2hS0A3aAFHSiFVRiH1DizC1otRUIspDzWdFOUFdOgSljFsoQc1yNZGUPBgPRjYOILnIQUle2p9pO+IKqQUGGY41gE8dR+1Iy1DR+NWIIWyG6QEPV2TGaYhGHa1QJhRzbqCdtBzDyh2D6UBH+CSj74RM0UdgcyFYlQEGmOSySslZ+eVsI3aulPJE+yBRG+BcuA3VX2UfPjT1cKXDphyOBaDjpQswdb+3EH+ISoDGInpcDrIR3l4Kyqq0yqdgTtN8oYmNsThcVDR8x6zqRlb+FGLAT224R1hFjJsA2g/ZdseIswNkQ534s0KoXF7vRMFIj8lphkFlTOscXtj4z8nomaLMZ1w4R/JxCJ71A5J9CVgA1/gAm/sUh7TcyBE+VOnBj1o5z9J+zvmAHtQvScyhw5e9lHeYRhSAzeoUlDwBZ20XR9N7Rd0EXwX6aM4bRCWgmb4LBG00ZOqIx2mcaOkK0G10RuBPVWi0hq0PeEpjhgXzoDJ11OFk0PM6WXyByJvg5RMfh2+8eDhgzynEcAzkhun4T2JsRgWPhm6dKN9VBq4c5gtAxf+ueHORSo7LuZcEnKTgxIqRV4zxRhtfTgW6RNsBX3RFe1pRCSlRZfit5PlCMiizIgZfpWf2aIcBr3oBVa+2GQO97riA1RrtmaKxQZrIpbIxGEzE5Qs2eyXYBfgMoVqEBFnUrYgFA6O080SmDGdN8rmmsgOmmMRkKaqbJsgFENgImYTz14clF4kJZktdBeZwXfMJvGHYUGSWayk2YGlhx5PGFwkdtsuLIUn6RkTwHdecFTL7BLsN6Fr1pZ95c4m92DepBhk+tIgS1bXZWbKVTJm2qoUh5PvsFKyPCGkBXp6FbNa1JgbH3U3KxWOI2F+6A1f1qnKwA0PCk9nJ54TPCX+JSqTseCED63zEG/h1x5RImDWHzWUFAnfE3XW8HARq4QBKb6XR69RDmSIFC9jWkeDNK9B9GeiLo81aUYRPCHvEDXPE8W6EyUfGcUT0R90NyhGRHQzMAFTOymOHUJxN6eGV4OBGIOxQ1CkNzMPFFG/EzdP9Tlv9bxyNT3/e6oBTloZGH2EF7qBKj8VcHUx1Cw4iDqVGtpGQrrU9j/x9gY68jhR9RBvIqQDKyS3U/7DXRjzIAKVV90ddbdRNoJxGDpLT+LzOfRuE46fE3GvE5Jff3UfOC+0VbmSGZEJLdFGVa0CZlXiPxPUm7ZjMUxWRrw9H+Lj9AgP8jYP+UE695P+b/ezH3kD4x/obXBhcT+qQfHtYA5UNbT14T8EhdeKj/pPn2pa1O5W6SHmsRO94bRB5xhXDytlE5eVkURDnd1FmD7SoWu9ZRYT5DAAgY7dvXPs3KUb90/hQob/xh04wE4eugPiGl7EmFHjRo4Zx70DAEAeuY4lTZ5sWI5eyHckUb6EiTHdSgDtYt7EmXOhuHL35tV7h7CjOJfiEv4zynGcxZ0WExolx3TjuHLq5s2jKFXn1pPqANRrp5XrWIbj2tWrh47s2obi3IlUy1YuV6Ln2rlrd+/oXLJU1b1rd86cWL5rD8iTd6DwWnP05rlczHUdAHeEI1/WOE6z5qiYdRr+3Uxur+eb4kybHoev8mnTpIee/kfuHbuorF1zZC3uADx1SGHfBs6V3LnRCqkSJlcx+PJyzZ2jS+fcuWXgRKWbS3fgevHlSKU3R3fvO/fu5TeWgxevXFt17rj7VEfePN8D5+zfx29f+fxx5vL/P2e9+ZAC8D8BB0QwpXfmwac4s0a6CL151KEuQbrMQafA+/Yzrz/7wiMoP3QONE8cDT88pzMLEyznHXrW4W4cdyCMEJ4J5VsxJ3H8O/EcDsvz8Bx15IknQ/xGRNDEHgPMEcEWXyTvQcgaMsfG+Joka0cjz0Gnyy19rNC1INWhR550uLwPyQGVTLPLNFMME8vLyon+B0qPZpwyJSvjlLOkHe9bBx555uFtQz4xG/OneeQplEsSy2PznHXiWfSdLR/tk7TD7PSoHRozkpDCTHHS0j535nnnHaCM/LG7MekBCh6w7sN0uUhlfSeeWe2rddTFzJGH0zs/zajKCQ/1tS0eC5onHl2L1A/ZyF41Mx1Cz1RzvkiJDI8dde5TMdnIgBW2U2JB3VPck0o959T06oEWzAETxeoweAjKtkT85HlHyHa+5VXdwsx5KFgYO5Lx3GKthEhg3JaV1R2QJop2Xh7JBMsdegILeE38KG2nTnZodVgucdp5x8YGS3oQRyrhgRmec0rOiN126ClzUValXSzIdCj+xTkegPOFFD92FH0nRDhpJosceb5qx+Wd0Em3pHTkqacmpjGqz757UF5HnXaMHMziD9VRLa80e60uv3UAU5rJrbcShx2awiqJHHeynofthmYKCR6pxdUtQ8MNRzOreQ9AvPEP/XbNRMcdL4fnuTEaJx6ReBtcIXSyjidPjcwJuZ4XL1+oHIhWN2f11StfU3XXW3f9ANFtpZ312m1HPSfZ3llP2nJ+Wkdao9SBh53effMtt9+SdN42yyOLPjeklsdJM5jMegwmo6bHPnzxx29rHHLQaYdg8Mlnv333MeIJxXPWf79++8P/E7/O7+e/f8x4ghzdyvEmngHQfwdEYE7+zPEOfFBvgPpDSZWUl0AKVrAj99iYTga4kfihiGcYZAf9/kQ/C5YwQYzTi7XSYaJ7EARfXVJH5ciRjhGdIx3piCF6BKeRDt5ncAe4BzrGcQ/1SI5LNHRTOszxDwyJ5xwtPNM5nEVCE1axO7sJFjoChZ1BzeNog6rHT9pRDndQ6mcioYc60kGZ2ymkhxmK0zng4Ri0vUMc6AhWPOYoqDLRwx3neEew0gEPAPzEHeuoRwituMhkjWOOgDmAO9gBLHlI8h78olR6JDmPdqRvjiHDYTyWyMMH3idMjiRUOwIVmGa9Yx0akxij4oEyVLmjRagS2iD3x0hedocci1pHOfD+6K1VkXEegGyHRCjlRdvJo5PzSAc7dkjK8NBwfhs5R7PUMcON2W1sspEHO+LhrXE6hh0DlIc6JPK2afbSnSty2iG/hqoF/etn71BHkfBBj0AKjR2TssvGFjQzapYxOy7LpiQl5cdAqmMdu2GHRNSJKiL9a0YR8WOzCPpOjq7pbbQB5D1IF5RyjOwc+Jhh+u4Bj3YAcR3k+No98IGPMPEEHTM6KAfbAQ8YAXJE73CHENlxgGiWIx3pG+QY1UEhsX2teB2FqrZEg5SlOKQzS2HNU6aa1e/hRphlJIjUzPeUqprPKaihKlK2apHvVTWqb72fTe9hTSrC1a69hAo59Br+rrv2FYFjzdL11qLXuvrVsJ5JxzsU06d02PKwj+3TWe6RqaNtFLKXTdDNJtsniVgWs58tj2YpKw/Pgta0txEtZ0l7WtYCJ7Vy6mxrZeuZ12IptrPFbWFulo7Rlja3v9UJOnTljjZqS470oA1wlfuZvRWSt1hqR0iKtFzq3mSfABClnKILgHZW17t509w6+nSOp03wu+ftiMbiIqcZjRK973XjZjSjToLJV1vyFYdD5as9+Hr3Ia7Tz+x2ORei1C7APoJIYftr1+GciCIDnksp0QQgBS/4rQ22oTq+5ENIYbhAcLTwcjHcDi9OmEsHgLBcJMylDV8zxMBt8E3pAQ/BSX4pxWupy32OykAjgfjFv43xWXDmxw+h2DylXOmQ/2jKHwP5QzcLyqAAZuTu5Lhd9eApo4pc4Sa7M8Yaw8ctTUqcI99HVkgFmH243GVeBhm5u5nHOjhcZQyramx42TKbZ/vlejCKHvEic3lKuc9mYRk/a9azFWPcHkE16sEdTpM4+SXnEyM60Sb0sH2sCUFB5+ceaWbypU+baQBR2Vak/k+rRH1ZnpCjHK6G9aubw9fgmE/Wsca1pVe9a173uoQBAQA7" alt="images/parsing/list-call-graph.png"></div><p height="10" width="0" class="calibre5">The leaves of the parse tree (highlighted nodes) are the tokens from
the input stream. The interior nodes are rule names from the grammar.
Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> and Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> show how to build a lexer and
parser for this grammar.
</p><p height="10" width="0" class="calibre5">When reading the lexer and parser design patterns, youll notice that
they are nearly identical. This makes sense given that both patterns
look for structure in input sequences. The only difference lies in the
type of their input symbols, characters or tokens. We can even take
this one step further.  
Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> recognizes structure in tree
node sequences.</p><p height="10" width="0" class="calibre5">With this preparatory grammar and parsing discussion out of the way,
we can define four classic parsing patterns.  After looking at them,
well be able to build parsers for lots of languages.
Ultimately well use ANTLR grammars rather than hand-built
recursive-descent parsers because its a lot easier.  Knowledge of
these parsing design patterns still matters, though, because grammars
are what drive our parser generators. We still need a good
understanding of the underlying mechanism to build grammars
effectively.</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_026.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_026.html.tip.grammar-parser-mapping" class="pagebreak2"><small class="calibre35">Pattern 1:</small>&nbsp;&nbsp;&nbsp;Mapping Grammars to Recursive-Descent Recognizers</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This translates a grammar to a recursive-descent recognizer that matches
phrases and sentences in the language specified by the grammar.</em>
</p><p height="10" width="0" class="calibre5">This pattern identifies the core control-flow framework for any
recursive-descent lexer, parser, or tree parser.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Even when building lexers and parsers by hand, the best starting point
is a grammar. Grammars are a very concise way to express the languages
you intend to recognize. Not only that, but grammars are excellent
documentation that can go into a reference manual and into parsing
code as comments.  This pattern gives us a way to build recognizers
directly from grammars.</p><p height="10" width="0" class="calibre5">A word of caution:  this pattern works for many but not all
grammars. The most obvious troublesome grammar construct is <em class="calibre6">left recursion</em> (a rule that invokes itself without consuming a
token).  Left recursion results in an infinite method invocation loop.
For example, the following rule yields a parser that does not
terminate:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">r : r X ;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Using this design pattern, wed end up with a function that
immediately called itself, leading to an infinite loop:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> r() { r(); match(X); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Besides left-recursive rules, there are other grammar constructs
that yield 
<em class="calibre6">nondeterministic</em> recursive-descent recognizers.  A
nondeterministic recognizer cannot decide which path to take. The parsers in Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a> and Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>, use more and more
lookahead to increase the strength of the recognizer. The more
powerful the underlying recognition strategy, the easier it is to
write a grammar. That is because more powerful parsing strategies
allow a larger set of grammars.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">A grammar, <code class="calibre21">G</code>, is a set of rules from which we generate a class
definition (in any object-oriented programming language) containing a
method for each rule:
  
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> G <b class="calibre13">extends</b> <b class="calibre13">Parser</b> { <em class="calibre6">// parser definition written in Java</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">token-type-definitions</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">suitable-constructor</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">rule-methods</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Class <code class="calibre21">Parser</code> defines the state a typical parser needs, such as
a lookahead token or tokens and an input stream.</p><h4 class="calibre26">Converting Rules</h4><p height="10" width="0" class="calibre5">For each rule, <code class="calibre21">r</code>, defined in a grammar, we build a method of the
same name:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> r() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The inside of a rule looks exactly like a subrule (a rule embedded within another rule), as well see shortly.</p><p height="10" width="0" class="calibre5">Rule references to <code class="calibre21">r</code> become method calls: <code class="calibre21">r()</code>.</p><h4 class="calibre26">Converting Tokens</h4><p height="10" width="0" class="calibre5">Token references for token type <code class="calibre21">T</code> become calls
to <code class="calibre21">match(T)</code>. <tt class="calibre21">match</tt>
is a support method in <code class="calibre21">Parser</code> that consumes a
token if <code class="calibre21">T</code> is the current lookahead token. If there
is a mismatch, <tt class="calibre21">match</tt> throws an exception.</p><p height="10" width="0" class="calibre5">Also, we need to define token type <code class="calibre21">T</code> somewhere, either in the
parser object or in our lexer object. For every token <code class="calibre21">T</code>, we write this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> T = <em class="calibre6">sequential-integer</em>;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Well also probably need this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> INVALID_TOKEN_TYPE = 0; <em class="calibre6">// to be explicit</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> EOF = -1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// EOF token type</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You might wonder why Im not using the <code class="calibre21">enum</code> functionality in Java
to represent sets of integers.  Its because I always end up wanting to treat them
as simple integers.</p><h4 id="text/part0000_split_026.html.sec.parsing-decisions" class="calibre26">Converting Subrules</h4><p height="10" width="0" class="calibre5">Alternatives become either a <code class="calibre21">switch</code> or an <code class="calibre21">if</code>-<code class="calibre21">then</code>-<code class="calibre21">else</code> sequence,
depending on the complexity of the lookahead decision. Each
alternative gets an expression that predicts whether that alternative
would succeed at the current input location.  Consider the
following generic subrule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(<em class="calibre6">alt1</em>|<em class="calibre6">alt2</em>|..|<em class="calibre6">altN</em>)</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The control flow looks like this:</p><div class="calibre1"><img id="text/part0000_split_026.html.d24e2881" class="calibre36" src="data:image/jpeg;base64,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" alt="images/parsing/subrule.png"></div><p height="10" width="0" class="calibre5">The most general subrule implementation looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( <em class="calibre6">lookahead-predicts-alt1</em> ) { <em class="calibre6">match-alt1</em> }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> <b class="calibre13">if</b> ( <em class="calibre6">lookahead-predicts-alt2</em> ) { <em class="calibre6">match-alt2</em> }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> <b class="calibre13">if</b> ( <em class="calibre6">lookahead-predicts-altN</em> ) { <em class="calibre6">match-altN</em> }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> <em class="calibre6"><b class="calibre13">throw</b>-exception</em> <em class="calibre6">// parse error (no viable alternative)</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If all of those lookahead expressions only test  a single symbol
lookahead, we can generate a <code class="calibre21">switch</code> statement, which is usually
more efficient:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">switch</b> ( <em class="calibre6">lookahead-token</em> ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token1-predicting-alt1</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token2-predicting-alt1</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token1-predicting-alt2</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token2-predicting-alt2</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token1-predicting-altN</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">token2-predicting-altN</em> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-altN</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">default</b> : <em class="calibre6"><b class="calibre13">throw</b>-exception</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As an optimization, we can collapse subrules whose alternatives are
token references such as <code class="calibre21">(A|B|C)</code> into sets.  Testing the current
symbol of lookahead against a set is usually much faster and smaller
than a <code class="calibre21">switch</code>.</p><p height="10" width="0" class="calibre5">All recursive-descent recognizers make decisions according to this
template.  To implement a recognizer, we fill in those 
lookahead prediction expressions. The nature of the expressions dictates the
strength of the strategy. Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> and Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> have
<em class="calibre6">LL(1)</em> decisions, which means their prediction expressions test one
symbol of lookahead.  Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a> has <em class="calibre6">LL(k)</em> decisions
whose prediction expressions test <em class="calibre6">k</em> symbols of lookahead. Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a> and Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a> augment <em class="calibre6">LL(k)</em> decisions with an
arbitrary amount of lookahead and arbitrary user-defined run-time
tests, respectively.</p><h4 class="calibre26">Converting Subrule Operators</h4><p height="10" width="0" class="calibre5">Optional subrules are easy to convert because all we have to do
is remove the <code class="calibre21">default</code> error clause from the subrules in the
previous section. If the subrule is optional, there is no possibility
of an error. 
For example, the control flow of optional subrule <code class="calibre21">(T)?</code> looks like this:</p><div class="calibre1"><img id="text/part0000_split_026.html.d24e3091" class="calibre36" src="data:image/jpeg;base64,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" alt="images/parsing/optional.png"></div><p height="10" width="0" class="calibre5">In code, these subrules become conditional statements. For example,
<code class="calibre21">(T)?</code> becomes the following:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( <em class="calibre6">lookahead-is-T</em> ) { match(T); } <em class="calibre6">// no error else clause</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The control flow of one or more <code class="calibre21">(...)+</code> subrules looks like this:</p><div class="calibre1"><img id="text/part0000_split_026.html.d24e3113" class="calibre37" src="data:image/jpeg;base64,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" alt="images/parsing/one-or-more.png"></div><p height="10" width="0" class="calibre5">In code, <code class="calibre21">(...)+</code> subrules become <code class="calibre21">do</code>-<code class="calibre21">while</code> loops:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">do</b> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">code-matching-alternatives</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">} <b class="calibre13">while</b> ( <em class="calibre6">lookahead-predicts-an-alt-of-subrule</em> );</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Zero or more <code class="calibre21">(...)*</code> subrules are like optional one-or-more
loops. Their control flow looks like this:</p><div class="calibre1"><img id="text/part0000_split_026.html.d24e3149" class="calibre30" src="data:image/jpeg;base64,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" alt="images/parsing/zero-or-more.png"></div><p height="10" width="0" class="calibre5">In code, <code class="calibre21">(...)*</code> subrules become <code class="calibre21">while</code> loops:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">while</b> ( <em class="calibre6">lookahead-predicts-an-alt-of-subrule</em> ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">code-matching-alternatives</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This way, the recognizer can skip over the subrule if the lookahead
does not predict an alternative within the subrule.</p><p height="10" width="0" class="calibre5">In the next pattern, we will look at how to build lexers using this
grammar-to-recognizer mapping as scaffolding.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_027.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_027.html.tip.lexer" class="pagebreak2"><small class="calibre35">Pattern 2:</small>&nbsp;&nbsp;&nbsp;<em class="calibre38">LL(1)</em> Recursive-Descent Lexer</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">Lexers derive a stream of tokens from a character stream by
recognizing lexical patterns.</em>
</p><p height="10" width="0" class="calibre5">Lexers are also called <em class="calibre6">scanners</em>,
<em class="calibre6">lexical analyzers</em>, and
<em class="calibre6">tokenizers</em>.  As a bonus, this pattern can
recognize nested lexical structures such as nested comments (even
though languages typically dont have super-complicated lexical
structure).</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The goal of the lexer is to emit a sequence of tokens.  Each token has
two primary attributes: a <em class="calibre6">token type</em> (symbol category) and
the text associated with it.  In the English language, weve got
categories such as verbs and nouns as well as punctuation symbols such
as commas and periods. All words within a particular category are said
to have the same token type, though their associated text is
different.</p><p height="10" width="0" class="calibre5">Lets identify the token types from the list language in <a href="#text/part0000_split_025.html.sec.tokenizing"><em class="calibre6">Tokenizing Sentences</em></a>. The token type <code class="calibre21">NAME</code> represents the identifier
category. Then we need token types for the fixed string vocabulary
symbols: <code class="calibre21">COMMA</code>, <code class="calibre21">LBRACK</code>, and <code class="calibre21">RBRACK</code>.  Lexers also typically
deal with whitespace and comments.  Because the parser ignores these,
we dont bother defining token types for them. We can just have the
lexer throw out such character sequences if it finds them between
tokens.</p><p height="10" width="0" class="calibre5">To build a lexer by hand, we write a method for each token definition
(lexical rule).  In other words, token <code class="calibre21">T</code>s definition becomes method <tt class="calibre21">T</tt>.
These methods recognize the pattern expressed in the associated
lexical rule. In programming languages, for example, there are methods
to match integers, floating-point numbers, identifiers, operators, and
so on. </p><p height="10" width="0" class="calibre5">To write the code for the lexer rules, we follow Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.</p><p height="10" width="0" class="calibre5">To make the lexer look like an enumeration of tokens, its handy to
define a method called <tt class="calibre21">nextToken</tt>.  <tt class="calibre21">nextToken</tt> uses the lookahead
character (character under the input cursor) to route control flow to
the appropriate recognition method.  For example, upon seeing a
letter, <tt class="calibre21">nextToken</tt> would call a method to recognize the identifier
pattern.</p><p height="10" width="0" class="calibre5">Here is the core of a typical lexer <tt class="calibre21">nextToken</tt> that skips
whitespace and comments:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Token nextToken() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;while ( <em class="calibre6">lookahead-char</em>!=EOF ) { // EOF==-1 per java.io</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( <em class="calibre6">comment-start-sequence</em> ) { COMMENT(); continue; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // other skip tokens</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch ( <em class="calibre6">lookahead-char</em> ) { // which token approaches?</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">whitespace</em> : { consume(); continue; } // skip</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">chars-predicting-T1</em> : return T1(); // match T1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">chars-predicting-T2</em> : return T2();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">chars-predicting-Tn</em> : return Tn();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default : <em class="calibre6">error</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;return <em class="calibre6">EOF-token</em>; // return token with EOF_TYPE token type</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To use this lexer pattern, we create an instance of a lexer from an input
string or stream reader. Our parser object feeds off this lexer,
calling its <tt class="calibre21">nextToken</tt> method to extract tokens. The code would look
something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MyLexer lexer = <b class="calibre13">new</b> MyLexer(<em class="calibre6">"<em class="calibre6">input-sentence</em>"</em>);&nbsp;&nbsp;<em class="calibre6">// create lexer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MyParser parser = <b class="calibre13">new</b> MyParser(lexer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// create parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parser.<em class="calibre6">start_rule</em>(); <em class="calibre6">// begin parsing, looking for a list sentence</em></code></span></div></td></tr></tbody></table></div><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">As a sample implementation, lets build a lexer for the nested
list-of-names grammar shown in <a href="#text/part0000_split_025.html.sec.tokenizing"><em class="calibre6">Tokenizing Sentences</em></a>.  
Our goal is a lexer that we can treat like an enumeration. Here is a loop
from the test rig that pulls tokens out of the lexer until it returns
a token with type <code class="calibre21">EOF_TYPE</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Test.java">parsing/lexer/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ListLexer lexer = <b class="calibre13">new</b> ListLexer(args[0]);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token t = lexer.nextToken();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">while</b> ( t.type != Lexer.EOF_TYPE ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;t = lexer.nextToken();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(t); <em class="calibre6">// EOF</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Wed like output like this from the list argument:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test '[a, b ]'</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;'[',LBRACK&gt;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;'a',NAME&gt;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;',',COMMA&gt;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;'b',NAME&gt;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;']',RBRACK&gt;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;'&lt;EOF&gt;',&lt;EOF&gt;&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To implement this, well need <code class="calibre21">Token</code> objects, an abstract <code class="calibre21">Lexer</code>
for support code, and finally a concrete <code class="calibre21">ListLexer</code> to do the
actual work.  Lets start by defining tokens to have token type and
text properties.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Token.java">parsing/lexer/Token.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Token {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">int</b> type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> text;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Token(<b class="calibre13">int</b> type, <b class="calibre13">String</b> text) {this.type=type; this.text=text;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> tname = ListLexer.tokenNames[type];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <em class="calibre6">"&lt;'"</em>+text+<em class="calibre6">"',"</em>+tname+<em class="calibre6">"&gt;"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For now, lets skip over the support code,
<code class="calibre21">Lexer</code>, to focus on the list language lexer.  We
need to define token types, and we might as well define them in our
lexer:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/ListLexer.java">parsing/lexer/ListLexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> ListLexer <b class="calibre13">extends</b> Lexer {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">int</b> NAME = 2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">int</b> COMMA = 3;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">int</b> LBRACK = 4;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">int</b> RBRACK = 5;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">String</b><b class="calibre13">[]</b> tokenNames =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <em class="calibre6">"n/a"</em>, <em class="calibre6">"&lt;EOF&gt;"</em>, <em class="calibre6">"NAME"</em>, <em class="calibre6">"COMMA"</em>, <em class="calibre6">"LBRACK"</em>, <em class="calibre6">"RBRACK"</em> };</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> getTokenName(<b class="calibre13">int</b> x) { <b class="calibre13">return</b> tokenNames[x]; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> ListLexer(<b class="calibre13">String</b> input) { super(input); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> isLETTER() { <b class="calibre13">return</b> c&gt;=<em class="calibre6">'a'</em>&amp;&amp;c&lt;=<em class="calibre6">'z'</em> || c&gt;=<em class="calibre6">'A'</em>&amp;&amp;c&lt;=<em class="calibre6">'Z'</em>; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">getTokenName</tt> method helps us generate good error messages and
generate readable <code class="calibre21">Token</code>.<tt class="calibre21">toString</tt> output.</p><p height="10" width="0" class="calibre5">Following the <tt class="calibre21">nextToken</tt> code template, here is the method 
matching tokens or routes traffic to the appropriate method:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/ListLexer.java">parsing/lexer/ListLexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Token nextToken() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( c!=EOF ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">switch</b> ( c ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">' '</em>: <b class="calibre13">case</b> <em class="calibre6">'\t'</em>: <b class="calibre13">case</b> <em class="calibre6">'\n'</em>: <b class="calibre13">case</b> <em class="calibre6">'\r'</em>: WS(); <b class="calibre13">continue</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">','</em> : consume(); <b class="calibre13">return</b> <b class="calibre13">new</b> Token(COMMA, <em class="calibre6">","</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">'['</em> : consume(); <b class="calibre13">return</b> <b class="calibre13">new</b> Token(LBRACK, <em class="calibre6">"["</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> <em class="calibre6">']'</em> : consume(); <b class="calibre13">return</b> <b class="calibre13">new</b> Token(RBRACK, <em class="calibre6">"]"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">default</b>:</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( isLETTER() ) <b class="calibre13">return</b> NAME();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"invalid character: "</em>+c);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> Token(EOF_TYPE,<em class="calibre6">"&lt;EOF&gt;"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To match an identifier, we need to buffer characters while the lookahead
character is a letter:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/ListLexer.java">parsing/lexer/ListLexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** NAME : ('a'..'z'|'A'..'Z')+; // NAME is sequence of &gt;=1 letter */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token NAME() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">StringBuilder</b> buf = <b class="calibre13">new</b> <b class="calibre13">StringBuilder</b>();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">do</b> { buf.append(c); consume(); } <b class="calibre13">while</b> ( isLETTER() );</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> Token(NAME, buf.toString());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If <tt class="calibre21">nextToken</tt> finds a whitespace character, it calls 
<tt class="calibre21">WS</tt> to
consume all the whitespace without buffering it up or returning a
token. Here is <tt class="calibre21">WS</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/ListLexer.java">parsing/lexer/ListLexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** WS : (' '|'\t'|'\n'|'\r')* ; // ignore any whitespace */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> WS() {&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( c==<em class="calibre6">' '</em> || c==<em class="calibre6">'\t'</em> || c==<em class="calibre6">'\n'</em> || c==<em class="calibre6">'\r'</em> ) consume();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">On to the support code in our <code class="calibre21">Lexer</code> base class. Here are the
necessary fields to maintain state:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Lexer.java">parsing/lexer/Lexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> Lexer {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">char</b> EOF = (<b class="calibre13">char</b>)-1; <em class="calibre6">// represent end of file char</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> EOF_TYPE = 1;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// represent EOF token type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> input; <em class="calibre6">// input string</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> p = 0;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// index into input of current character</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">char</b> c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// current character</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The constructor records the input string and primes the lookahead by
loading the first character into lookahead character <code class="calibre21">c</code>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Lexer.java">parsing/lexer/Lexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Lexer(<b class="calibre13">String</b> input) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;this.input = input;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;c = input.charAt(p); <em class="calibre6">// prime lookahead</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">consume</tt> advances the input pointer and sets lookahead
character <code class="calibre21">c</code> to the next character in the string. This method also
detects when the lexer has run out of input characters, setting the lookahead
character to <code class="calibre21">EOF</code> (-1).</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Lexer.java">parsing/lexer/Lexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Move one character; detect "end of file" */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> consume() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( p &gt;= input.length() ) c = EOF;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> c = input.charAt(p);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Ensure x is next character on the input stream */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> match(<b class="calibre13">char</b> x) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( c == x) consume();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"expecting "</em>+x+<em class="calibre6">"; found "</em>+c);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Class <code class="calibre21">Lexer</code> is abstract because it has no code to match tokens.
Any concrete subclasses, such as our <code class="calibre21">ListLexer</code>, need to implement
the following methods:
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/lexer/Lexer.java">parsing/lexer/Lexer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> Token nextToken();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">String</b> getTokenName(<b class="calibre13">int</b> tokenType);</code></span></div></td></tr></tbody></table></div><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">There is a great similarity between the structure of this lexer and
the structure of Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>. Theyre both
instances of recursive-descent recognizers generated using Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.

</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_028.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_028.html.tip.recursive-descent" class="pagebreak2"><small class="calibre35">Pattern 3:</small>&nbsp;&nbsp;&nbsp;<em class="calibre38">LL(1)</em> Recursive-Descent Parser</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern analyzes the syntactic structure of the
token sequence of a phrase using a single lookahead token.</em>
</p><p height="10" width="0" class="calibre5">This parser belongs to the <em class="calibre6">LL(1)</em> top-down parser class
in particular because it uses a single token of lookahead (hence the
1 in the name). Its the core mechanism of all
subsequent parsing patterns.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">This pattern shows how to implement parsing decisions that use a
single token of lookahead.  Its the weakest form of recursive-descent
parser but the easiest to understand and implement. If you can
conveniently implement your language with this <em class="calibre6">LL(1)</em>
pattern, you should do so.  Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a> uses multisymbol lookahead,
which is more powerful but has more complicated infrastructure. </p><p height="10" width="0" class="calibre5">To implement an <em class="calibre6">LL(1)</em> recursive-descent parser,  we can start by
filling in the lookahead expressions from the parsing decisions shown in
Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>. To make parsing decisions, the parser
tests the current lookahead token against the alternatives lookahead
sets.  A lookahead set is the set of tokens that can begin a
particular alternative.  The parser should attempt the alternative
that can start with the current lookahead token. In the next two
sections, well figure out how to compute lookahead sets and how to
detect decisions with more than one viable path.</p><h4 class="calibre26">Computing Lookahead Sets</h4><p height="10" width="0" class="calibre5">Formally, we compute lookahead sets using two computations: <em class="calibre6">FIRST</em> and <em class="calibre6">FOLLOW</em>.  In practice, though, its easier to simply
ask ourselves, What tokens can possibly start phrases beginning at
this alternative?  
The exact definition of FIRST is a bit much to
chew on for our purposes here, but if youre interested, a web search
reveals plenty of decent descriptions.<a id="text/part0000_split_028.html.FNPTR-7" href="#text/part0000_split_030.html.FOOTNOTE-7">[7]</a></p><p height="10" width="0" class="calibre5">Lets start with the easiest lookahead computation case: an
alternative that begins with a token reference. Its lookahead set is
just that token. For example, here is a programming language statement
rule where each alternative begins with single token reference:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat: <em class="calibre6">'if'</em> &nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// lookahead set is {if}</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">'while'</em>  <em class="calibre6">// lookahead set is {while}</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">'for'</em> &nbsp;&nbsp; <em class="calibre6">// lookahead set is {for}</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If an alternative begins with a rule reference instead of a token
reference, the lookahead set is whatever begins any alternative of
that rule.</p><p height="10" width="0" class="calibre5">Here is a rule whose first alternative invokes <code class="calibre21">stat</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">body_element&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: stat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// lookahead is {if, while, for}</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| LABEL <em class="calibre6">':'</em> <em class="calibre6">// lookahead is {LABEL}</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The lookahead set for the first alternative is the union of the
lookahead sets from <code class="calibre21">stat</code>.
Lookahead computations only get complicated when we consider empty
alternatives.  For example, its not immediately obvious what tokens
predict the empty alternative in the following rule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">optional_init</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: <em class="calibre6">'='</em> expr</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">// empty alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The lookahead for the first alternative is <code class="calibre21">=</code>.  For the empty
alternative, the lookahead is the set of tokens following references
to <code class="calibre21">optional_init</code>. So, lets add some other rules that invoke <code class="calibre21">optional_init</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">decl: <em class="calibre6">'int'</em> ID optional_init <em class="calibre6">';'</em> ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">arg : <em class="calibre6">'int'</em> ID optional_init ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">func_call: ID <em class="calibre6">'('</em> arg <em class="calibre6">')'</em> ; <em class="calibre6">// calls arg; ')' included in lookahead</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In this case, <code class="calibre21">;</code> follows <code class="calibre21">optional_init</code> in <code class="calibre21">decl</code> so we know that
at least <code class="calibre21">;</code> is in the set.  Rule <code class="calibre21">arg</code> also references <code class="calibre21">optional_init</code>, but there is no token following it. This means that we
have to include whatever follows <code class="calibre21">arg</code>.  Token <code class="calibre21">)</code> can follow a
reference to <code class="calibre21">arg</code>, so tokens <code class="calibre21">';' and ')'</code> can follow a reference to
<code class="calibre21">optional_init</code>.</p><p height="10" width="0" class="calibre5">Dont worry if you dont fully understand these lookahead computations in
detail. Most likely you wont have to compute them yourself; ANTLR
likes nothing better than to compute these for you. With this general
understanding of lookahead computation in mind, lets consider what
happens when the same token predicts more than one alternative.</p><h4 id="text/part0000_split_028.html.sec.deterministic-ll" class="calibre26">Deterministic Parsing Decisions</h4><p height="10" width="0" class="calibre5"> <em class="calibre6">LL</em> parsing decisions work only when the lookahead
sets predicting the alternatives are disjoint (the sets have no tokens
in common).  </p><p height="10" width="0" class="calibre5">
For example, here is a rule whose parsing decision is
deterministic because the single lookahead token uniquely predicts
which alternative to choose:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Match -3, 4, -2.1 or x, salary, username, and so on */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr: <em class="calibre6">'-'</em>? (INT|FLOAT) <em class="calibre6">// '-', INT, or FLOAT predicts this alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// ID predicts this alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Upon <code class="calibre21">-</code>, <code class="calibre21">INT</code>, or <code class="calibre21">FLOAT</code>, rule <code class="calibre21">expr</code> knows to predict the first
alternative. Upon <code class="calibre21">ID</code>, it knows to predict the second.</p><p height="10" width="0" class="calibre5">If the lookahead sets overlap, though, the parser is 
<em class="calibre6">nondeterministic</em>it cannot determine which alternative to
choose. For example, heres a rule thats nondeterministic for an <em class="calibre6">LL(1)</em> parser:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr: ID <em class="calibre6">'++'</em>&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match "x++"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID <em class="calibre6">'--'</em>&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match "x--"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The two alternatives begin with the same token (<code class="calibre21">ID</code>). The token beyond
dictates which alternative phrase is approaching.  In other words, <code class="calibre21">expr</code> is LL(2).  An <em class="calibre6">LL(1)</em> parser cant see past the left common prefix
with only one symbol of lookahead.  Without seeing the suffix operator
after the <code class="calibre21">ID</code>, the parser cannot predict which alternative will
succeed.  To handle grammatical constructs like this, either tweak your
grammar or use Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>.  By left-factoring out the
common <code class="calibre21">ID</code> left-prefix, we get an <em class="calibre6">LL(1)</em> grammar that matches the
same language:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr: ID (<em class="calibre6">'++'</em>|<em class="calibre6">'--'</em>) ;&nbsp;&nbsp; <em class="calibre6">// match "x++" or "x--"</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If you plan on building lots of parsers by hand, its worth spending
time to get good at computing lookahead sets.  Otherwise, you can just
let a parser generator do it for you.</p><p height="10" width="0" class="calibre5">To see how the lookahead computations fit into the grammar to parser
mapping, lets build a parser for the nested list-of-names language in
<a href="#text/part0000_split_025.html.sec.tokenizing"><em class="calibre6">Tokenizing Sentences</em></a>.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Were going to build a parser, <code class="calibre21">ListParser</code>, to go with the lexer
from Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>. Heres the grammar again:
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/recursive-descent/NameList.g">parsing/recursive-descent/NameList.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'['</em> elements <em class="calibre6">']'</em> ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match bracketed list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">elements : element (<em class="calibre6">','</em> element)* ;&nbsp;&nbsp;<em class="calibre6">// match comma-separated list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME | list ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// element is name or nested list</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Following the grammar-to-parser mapping weve established, we
arrive at the following parser:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/recursive-descent/ListParser.java">parsing/recursive-descent/ListParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> ListParser <b class="calibre13">extends</b> <b class="calibre13">Parser</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> ListParser(Lexer input) { super(input); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** list : '[' elements ']' ; // match bracketed list */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> list() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(ListLexer.LBRACK); elements(); match(ListLexer.RBRACK);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** elements : element (',' element)* ; */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> elements() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( lookahead.type==ListLexer.COMMA ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(ListLexer.COMMA); element();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** element : name | list ; // element is name or nested list */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> element() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( lookahead.type==ListLexer.NAME ) match(ListLexer.NAME);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( lookahead.type==ListLexer.LBRACK ) list();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"expecting name or list; found "</em>+lookahead);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rules <code class="calibre21">elements</code> and <code class="calibre21">element</code> use lookahead to make parsing
decisions.  In <code class="calibre21">elements</code>, <code class="calibre21">COMMA</code> predicts entering the <code class="calibre21">(...)*</code>
subrule. In <code class="calibre21">element</code>, <code class="calibre21">NAME</code> predicts the first alternative, and <code class="calibre21">LBRACK</code> predicts the second alternative.</p><p height="10" width="0" class="calibre5">To support this concrete class, we need to build some support code in
an abstract <code class="calibre21">Parser</code> class. First, we need two state variables: an
input token stream and a lookahead buffer. In this case, we can use a
single lookahead variable, <code class="calibre21">token</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/recursive-descent/Parser.java">parsing/recursive-descent/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Lexer input;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// from where do we get tokens?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token lookahead; <em class="calibre6">// the current lookahead token</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Alternatively, we could use a big token buffer that holds all
tokens. In this way, we could track an index into the token buffer
rather than a <code class="calibre21">token</code> field. For this particular implementation of
this pattern, well assume that we cannot buffer all the input (we
might be reading from a socket).</p><p height="10" width="0" class="calibre5">Next, we need methods to compare expected tokens against the lookahead
symbol and to consume input.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/recursive-descent/Parser.java">parsing/recursive-descent/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** If lookahead token type matches x, consume &amp; return else error */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> match(<b class="calibre13">int</b> x) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( lookahead.type == x ) consume();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"expecting "</em>+input.getTokenName(x)+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">"; found "</em>+ lookahead);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> consume() { lookahead = input.nextToken(); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To test our parser, we need a test rig like the following:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/recursive-descent/Test.java">parsing/recursive-descent/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ListLexer lexer = <b class="calibre13">new</b> ListLexer(args[0]); <em class="calibre6">// parse command-line arg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ListParser parser = <b class="calibre13">new</b> ListParser(lexer);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parser.list(); <em class="calibre6">// begin parsing at rule list</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Upon valid input, the test rig emits nothing because we dont
have any application-specific code in there. We could easily add
actions to track a list of names, for example.  Upon error, we want to
throw an exception like the following:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test '[a, ]'</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Exception in thread "main" java.lang.Error:</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;expecting name or list; found &lt;']',RBRACK&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at ListParser.element(ListParser.java:24)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at ListParser.elements(ListParser.java:16)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at ListParser.list(ListParser.java:8)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Test.main(Test.java:6)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Building an <em class="calibre6">LL(1)</em> parser is the easiest way to learn
about parsers. In practice, though, we really need more than a
single token of lookahead. The next pattern describes how to
build an <em class="calibre6">LL(k)</em> parser for <em class="calibre6">k&gt;1</em>.</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">See Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>, Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, and Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_029.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_029.html.tip.fixed-lookahead-parser" class="pagebreak2"><small class="calibre35">Pattern 4:</small>&nbsp;&nbsp;&nbsp;<em class="calibre38">LL(k)</em> Recursive-Descent Parser</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern analyzes the syntactic structure of the
token sequence of a phrase using <em class="calibre6">k&gt;1</em> lookahead tokens.</em>
</p><p height="10" width="0" class="calibre5">An <em class="calibre6">LL(k)</em> parser augments the previous pattern with up
to a fixed number of lookahead tokens, <em class="calibre6">k</em>.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The strength of a recursive-descent parser depends entirely on the
strength of its lookahead decisions.  
A single token of lookahead is
pretty weak in that we usually have to contort grammars to make them
<em class="calibre6">LL(1)</em>. By allowing a larger (but still fixed) lookahead buffer, we get
a parser strong enough for most computer languages. This includes
configuration files, data formats, network protocols, graphics
languages, and many programming languages.  Some programming languages
present tougher challenges, though, for which well need a more
powerful recognition pattern.  Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a> introduces an
extension to this fixed-lookahead recursive-descent recognizer that,
in effect, allows arbitrary lookahead.</p><p height="10" width="0" class="calibre5">Having more lookahead is like being able to see farther down
multiple paths emanating from a fork in a maze. The farther we can see
ahead, the easier it is to decide which path to take.  More powerful
parsing decisions make it easier to build parsers. We dont have to
contort our parsers (or grammars) as much to suit a weak underlying
parsing strategy.</p><p height="10" width="0" class="calibre5">In this Discussion section, were going to figure out why we need more
than a single token of lookahead and figure out how to build circular
lookahead buffers. In the Implementation section, well use that
lookahead buffer in an <em class="calibre6">LL(k)</em> parser.</p><h4 class="calibre26">Motivating the Need for More Lookahead</h4><p height="10" width="0" class="calibre5">To see why we need <em class="calibre6">k&gt;1</em> lookahead, lets augment the list-of-names grammar from <a href="#text/part0000_split_025.html.sec.tokenizing"><em class="calibre6">Tokenizing Sentences</em></a> to allow assignments as list
elements.  For example, we want to recognize input such as <code class="calibre21">[a, b=c,
[d,e]]</code>.  To accommodate this change, we can add an alternative to <code class="calibre21">element</code> that matches assignments:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'['</em> elements <em class="calibre6">']'</em> ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match bracketed list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">elements : element (<em class="calibre6">','</em> element)* ;&nbsp;&nbsp;<em class="calibre6">// match comma-separated list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME <em class="calibre6">'='</em> NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// match assignment such as a=b</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | NAME</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | list</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The new alternative renders <code class="calibre21">element</code>
non-<em class="calibre6">LL(1)</em> since the first two alternatives start with the
same <code class="calibre21">NAME</code> token.  Now, we need two lookahead tokens
to distinguish the alternatives. The grammar is
<em class="calibre6">LL(2)</em>. Each time we look for an
<code class="calibre21">element</code>, we need to decide whether its an
assignment or just a name. If the lookahead sequence is
<code class="calibre21">NAME</code> followed by <code class="calibre21">=</code>, the
parsing decision should predict the first alternative (an assignment).
Otherwise, the parser should predict the second alternative.  For
example, the following diagram represents the lookahead available to
the parsing decision in <code class="calibre21">element</code> for input
<code class="calibre21">[a,b=c]</code>:</p><div class="calibre1"><img id="text/part0000_split_029.html.d24e5009" class="calibre37" src="data:image/gif;base64,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" alt="images/parsing/ll2-lookahead.png"></div><p height="10" width="0" class="calibre5">If we  had only an <em class="calibre6">LL(1)</em> parser, wed have to rewrite <code class="calibre21">element</code> to
look like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME (<em class="calibre6">'='</em> NAME)?&nbsp;&nbsp;<em class="calibre6">// match assignment such as a=b or just a</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | list</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This <code class="calibre21">(..)?</code> optional subrule version works but is less clear. There
are lots of similar situations that occur in real grammars.</p><h4 class="calibre26">Building a Circular Lookahead Buffer</h4><p height="10" width="0" class="calibre5">The simplest way to provide lots of parser lookahead is to buffer up
all the input tokens. 
The input cursor can be an integer index,
say, <code class="calibre21">p</code> into that buffer. We can execute <code class="calibre21">p++</code> to consume tokens. The
next <em class="calibre6">k</em> tokens of lookahead would be
<code class="calibre21">tokens[p]</code>..<code class="calibre21">tokens[p+k-1]</code>. This approach works for finite and
reasonably small input. This obviously doesnt work for infinite token
streams like network sockets.</p><p height="10" width="0" class="calibre5">When we cant buffer up all of the input, we need to make a <em class="calibre6">k</em>-sized buffer of tokens. Well have at most <em class="calibre6">k</em> tokens in memory
at once.  Our index, <code class="calibre21">p</code>, now moves only through the fixed lookahead
buffer.  To consume a token, we increment <code class="calibre21">p</code> and add a token to the
end of the buffer.</p><p height="10" width="0" class="calibre5">The only complication is that the buffer size is fixed so we have to
add tokens in a circular fashion: <code class="calibre21">p</code> ranges from =0..<em class="calibre6">k-1</em>.  A
circular buffer is one where indexes that fall off the end wrap to the
beginning. In other words, in a circular buffer of, say, three tokens,
index 2 is the last valid index. Index <code class="calibre21">p</code>=3 actually wraps to become
index 0.  Modulo expression <code class="calibre21">p%3</code> wraps indexes nicely for a buffer of
size 3.</p><p height="10" width="0" class="calibre5">Graphically, here is how <code class="calibre21">p</code> moves through the lookahead
buffer as the parser consumes tokens from input sentence <code class="calibre21">[a,b=c]</code>:</p><div class="calibre1"><img id="text/part0000_split_029.html.d24e5106" class="calibre37" src="data:image/gif;base64,R0lGODlhGAE4AOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAAAYATgAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLB8mNe7ix4Thy4jCKHEmypMmTKDGumycvHcNx7t41LCdvXjxyKXPq3Mmz585x89Ctk8cQHQB4Ddu9A4rOp9OnUKNGJTevnDl4IReyi9dQo7qqUsOKHUs2Ijl65MxxZbi1oTh38MyVnUu3rlhx8pQiZbtWKwB86jraHUy4MMlz8eDhZHgOX8N08N7BK2e4suXLmDNr3izWnOfPn62CDj1a9OjTpj1nHTjOc2rSp0G/nl369OKB4l6bo30gtmzfqF3vLigO+G7fuo8jr+26YGvgyZXDDv579G2I87Jr3y6PXr3t4Ln+06NXMzz47uwKqqNn3vz39tznvYefvXs8wf/W09fenfz+7PX49588q+UnIH39/QeggtqdQ1A7B9I3H4LyKdgdVhKhcw86GnK44T3ntBOPhyR2aCI+73S4oYkrggiPOwWt0845H5a4IjrpyIOPjTyulA6LPKLzFWUDiUgjkCye8w47SLboIT3tqBgkh/Dgp9SRTgIZjztNlpgOPTtmKeY89+AGDztYTnmPPEx22SE+9PwoZonr3CfRAXjmqWc5W5mj5595lqOOO+UACmg57sBIkDr4FGqonufIo46fj+JpTo7oUFqpOWsSKZBSjlZ6AKLrhPqon/OwY2qlSz3Yzqr+hpYDz6ui9obOPOrA+qef8pQpkDjvlForr5MO+1Wmw6ZjZ0TnNNvsAc+eY85W50AbbbXRmqPOO+Y4a+23zZrzjqIDrYNPt85iq+4B6Ehq7brpHqCOPOi8a6+36cxzXTtxeXuttea4sw668Kp7TqoEg2twq0W60+29Bl/VTsL/VnvrwPFe62yvuL1zbroFNysPxgUDvF69Gfsrb5USYavwOeWIqPDL2r5TTsnZjhvjx9DOjK27IX+Lac/+qnupPJ7+w6+fRYMbMMY+RzvPxDi7zPCnhDZ9rcQPV1wtu/RM6jW4HP8aLMXwQgv02NKe7PO7ly4LEdEKTxsP0TjXjG7+1NLqTJC5TON979rgfntAvii7/O/h+j7Yr+DXkro32wizje3VSmetOLxcW87uPFB7/bOv/wALNeTRjjx5wdrSg/LLACuLn0MggxszPDjDPWjXeftd7scpk60O6usObXDdOSa99LshP8075NBO/XzFB2DeTtYQwz3r9MejE/bqhYtMuukEa6328FW37frbzsY9e0PzyuOOxnaHz/m24Gtcju8CAX54PCSjW6TQlzZ8BcV+cMvXvuLCrnjMqGLOY5u1Klc1aFkva+iYlf06l7vPhS5okRrf2ZQkDwf6THVaw1brXhctvLlPIu0AwDzmZzuZHa9oNbtZ1KAlLnL171z+B8AHAKjGvPMVMWOHoxfe0pZE5TEwHQCQxxFhJjDu3Ut6FazWBf10j3rAY4k83F76wCY2EKpNhBh7Bz2OAsYB2s9obtOYv14YEQjdUFpbsdefVIg/y/XNh//w3zoAoKqvKQ5oj3oW4hDYPgU6josAiIem4FZFjUGOgjtUkpWydg96TOZr2qNaBS/WNUCpq2ylG6G22NhCkX1wc+pjoSmlJTsY1iNkt3MZOt6RnXgQMIdZ7OHO/DTId/CSTf5a2znYUZO8uMx42QtX8h55uCi6Izvzc5bkFCfA6BFRgls8QBcdiM1sibGbuvzes3aZHXjcg2ioJF/bWDk4AqIzlrH+g0c5pSm3h0BIluHKo8XkAQD2AKAeYtObH/cHSEHW46DyGWLXEOkOiD70HT1bZCu56cgiPfGhMlwj7nhYSW7CC5Nsu+DNOgkAGT70i+ESo0l75sGHtSukUUxcPFWpDlbCC4Uz5WEcD7fGeYiUn+9jSDtu+bKY3a1aUBxpDNnRLWBmUph/A+Ig6bGOc6ynHumwFtDM0Z17XKoeUoSqEu9I02l61E/peCia7jEPAKDPef+Th171Oo+RHuybuQsnS/FxjhwBAGNcE+deFwuPenlPbAeI4TuaFY/DMm2niO0pTBXmLnktlq/zW2HP4DHEc9yqHu/8X1IX8k/I1c9i7FD+hzpERMiq9jF9WP0dMQHgsN6QtlhurJZs08GOd0QxowdsJfMu1bi3ijOKfpoWb6taRXl5px7Yxa48sIVSnKmURvSQ5KhiSLXEfim72e2VOUgpMgDU63BREisabetTsg3MHEJEL3ZxJ1pxfidPs0WqLe+YS2y5Y40HrW3bbBZM/gVSqwqunl3RhciVPPShaU0iC5FIS6RR8x6RDFcxSUoykJlWaoB9m2C9WFV28PZmHDQxOtapzoPV43WFGl3HMkvPZBJQxuFy23O3G64c0xEidqSZQA9Q0bzISMEKNRrvYOZgQUpUWr+97PAOFyB3AIY9yE1cz5jWyOZ+ioEgTqv+OQbpMGlV9x6JinOiZhQ9qm4Nct/tYr/MQd6qbo9dco4znUkJLe+g7B7veKf4dkxfmG5OdYcLdKII298092xQiuynQ5a6OWg5tWcETQc59ndYGG9Lh9iS7daqDOHtdks+YRXZ8KT7jlFDUR4Pg2a17rEOWbr1zJB0XaEqe9fqrgOkLW3pPLj7TWipI9ZW2yQXx5OOYVsWyxOrZrKTTQ+zPvZhpC2VuOwqX0bPc7M+xpOLt91SVwv5tPcolDxujKda1nF99FuycbcUj4fGI6zy4pa3vEePiLHaT0K0JkEx+rMtq6PL8FhjPdDEuMS5WcFf6yiwuSzDd1R2uyRG1zr+Rk7ydaiDu3aW5lHgpVKidryy8VChTEtO8pPXVLgFlUxOy202Hjvavn4SCs3XkQ58SiuG8/D4ymmp6aTcsmIFbqCyt3LY3vSRaEZlYW5/6Kev6POgk4Un+iJ74XGtXMNE4/MQbyZNDzuXrvGoqxcTt83exIbZpUQHWgUXznbVpKWNpek5fWOxGh+AHQj2JTzni3N0i33MpxEqvqHljrKj7Mi4yZRAuhWScqCDHBDqTd0Emuper/fkbWuzy5KszYM3C0RCAXjq7JkOondLHanVKI2/ydwFMg32qqZkiU2sLgr+7Oda3CTbZywkm7dPpsT/Gnt71nw8pY7x5Yiq/YD+Gn2jf43Xsmf6+8aB1tIR9ABKA0A6Yuhl/dmQpoEzmcCx7g4XHpymoq8n3cgcOF0HjEwJ5HbAZkj5ly2VxDfeVEr5Emvf8l2GRClGc06iQ0aTI3oag1ndgiI9NnuMFGST9yyBI2DE0Q7rUDqzhRPo4DBwUg8x50J5xDwQtDvX4nwq5HrR93hyZC+6B1WKpkIapzQMlIPaVFKwg3J7wy49GG0Pgj1yJHOiVIQ3V4Q6ZjaNgg79Rg8C10ooFE3eB4M+2HSMETww834FFGTz9yzWZzSuBz0c2GnFs1aGEzG/BoTTUzcHWIYJuC4ClHxLyHbhAzASaFKFV0Z/OIWpNHz+G2VEypUtQ1WGmEc7S9Q+1NJ97bMOqkeJW/dg5UN87KJMN7iDn2hmdEiJ4eJlmxh9qeKFxLdFpFgtGkSK4gQ6p0h8O8UzBmNiI6OK8bISSXiD6sAyEcEcroEPcWEaxhga6UAowrGMx4EogKQO65AWzGiMB9ASxziNawIz02GM7aI8NjONpBEzubKNoXEA89Ao4Cgc+2Mlr5KOzfgO7XiNzXgw4ygdqWEVO1WP5Dhs+iiP2bds/hgaVrhaCmEu5oIPBokPgKFPB5mQDomQ7gBACDmRDwkY8iATfxMsD5mQCIl4AkORCsmRMjJxGwmSMkIPyoMrJgmSgBEP78AoJZn+kF4EkxMZkiDZTyJCkwfJkisBDyO3kg3JDvXwkTE5kXFiJi8JlCBJD0RZkyZZeexQlAYZkQSZEEN3lViZlVpJcviAfgRRDgi5lVoJjWI5lgWyZmWZlmrJlepQIGC5lnCZltfRGHFZcmRZl+aCDgUSEePglZwxEOhQlZUxDg5CEedwHZshDuewl0/BTIJpGORwS38pEOdQD0nDETc2mf8QmYUZFXgBAJ3JGT2FkX9pXOowEVGlmS5GmlAxDhEXmpuBD/XAmpsBlRNxbLSpGUKZm06hLZopEMOjmeVQghRxcpo5DuyAmE8hKL/5D2ElnKdJEc85meKAD8rpFOVAOpP+iQ6XqRnZWRGaR53qcJ1OwZiJaZ6ZgZ5uoZ6XwZ47QQ7r8A4u8ZfjsH7uQJ6VQQ7bwg6P6Rz3cD3deRn62Q7tgJ86sQ7dFhR/WQ4TFxN/GVc5QpwPUQ5QAhfuORhGsQ4vIhWW+A9n8pdq8Q/lIIqYoSz/wA7pARHlEA/iQBUBWhm3IqJguBPzQhPzuRkjKhQsyhl0pRYpOqFBUScXahfeE1m8yRP60Q5DahcjqldywRne01cGehBNKkV/6T169aI7YYkgMZlqUQ79ORjK0qURsaJgup36EqYnYRW/SZi/SQ6w+RCKuaSDAafNead4mqd6uqd82qd++qeAGqiCOqgFhIoRAQEAOwA=" alt="images/parsing/fixed-lookahead-buffer.png"></div><p height="10" width="0" class="calibre5">When we start parsing, the lookahead buffer looks like the leftmost
diagram where <code class="calibre21">p</code>=0.  The second diagram (where <code class="calibre21">p</code>=1) shows the
buffer after weve consumed the first <code class="calibre21">[</code> token. We add tokens behind
<code class="calibre21">p</code> as we advance. The rightmost diagram shows the state of the
lookahead buffer after weve loaded the final <code class="calibre21">]</code> token.  <code class="calibre21">p</code> points
at <code class="calibre21">=</code>, and so the parser needs to consume three more times before
running out of input (those <code class="calibre21">p</code> positions arent shown).</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Lets implement the list-of-names language augmented with
assignments from the previous section. 
First well build the lookahead
infrastructure, and then well implement <em class="calibre6">LL(2)</em> rule
<code class="calibre21">element</code>.</p><p height="10" width="0" class="calibre5">To support a fixed lookahead buffer, our
<code class="calibre21">Parser</code> support class needs the following
fields:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/Parser.java">parsing/multi/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Lexer input;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// from where do we get tokens?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token<b class="calibre13">[]</b> lookahead; <em class="calibre6">// circular lookahead buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// how many lookahead symbols</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> p = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// circular index of next token position to fill</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because different parsers need different amounts of lookahead, the
constructor takes a size argument and initializes the lookahead
buffer:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/Parser.java">parsing/multi/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Parser</b>(Lexer input, <b class="calibre13">int</b> k) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;this.input = input;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;this.k = k;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;lookahead = <b class="calibre13">new</b> Token[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// make lookahead buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (<b class="calibre13">int</b> i=1; i&lt;=k; i++) consume(); <em class="calibre6">// prime buffer with k lookahead</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To consume a token, the parser advances the token index in a circular
fashion and adds another token to the buffer.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/Parser.java">parsing/multi/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> consume() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;lookahead[p] = input.nextToken();&nbsp;&nbsp; <em class="calibre6">// fill next position with token</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;p = (p+1) % k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// increment circular index</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To isolate the lookahead mechanism from the parser, its a good idea
to create lookahead methods, 
<tt class="calibre21">LA</tt> and <tt class="calibre21">LT</tt>.  Method <tt class="calibre21">LA</tt> returns
lookahead token types up to <em class="calibre6">k</em> symbols ahead starting at <em class="calibre6">k=1</em>.  Recall that token types are integers representing  input symbol categories.  Method <tt class="calibre21">LT</tt> returns the actual lookahead token at a
particular lookahead depth.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/Parser.java">parsing/multi/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Token LT(<b class="calibre13">int</b> i) {<b class="calibre13">return</b> lookahead[(p+i-1) % k];} <em class="calibre6">// circular fetch</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">int</b> LA(<b class="calibre13">int</b> i) { <b class="calibre13">return</b> LT(i).type; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> match(<b class="calibre13">int</b> x) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( LA(1) == x ) consume();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"expecting "</em>+input.getTokenName(x)+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">"; found "</em>+LT(1));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Only rule <code class="calibre21">element</code> needs more than single token of lookahead in our case.
Its implementation method tests the first two tokens of lookahead, <code class="calibre21">LA(1)</code>
and <code class="calibre21">LA(2)</code>, to predict the first alternative:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/LookaheadParser.java">parsing/multi/LookaheadParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** element : NAME '=' NAME | NAME | list ; assignment, NAME or list */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> element() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( LA(1)==LookaheadLexer.NAME &amp;&amp; LA(2)==LookaheadLexer.EQUALS ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(LookaheadLexer.NAME);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(LookaheadLexer.EQUALS);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(LookaheadLexer.NAME);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( LA(1)==LookaheadLexer.NAME ) match(LookaheadLexer.NAME);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( LA(1)==LookaheadLexer.LBRACK ) list();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> Error(<em class="calibre6">"expecting name or list; found "</em>+LT(1));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because the method tests the alternatives in order, the second
alternative prediction expression gets away with looking only a single
symbol ahead. Also note that a single lookahead, <code class="calibre21">[</code>, uniquely
predicts the third alternative.  The lookahead depth <em class="calibre6">k</em> in <em class="calibre6">LL(k)</em>
is really a maximum not the exact, fixed amount of lookahead each
parsing decision uses.</p><p height="10" width="0" class="calibre5">Our test rig is the same as that in Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> except that
we need to pass in the necessary lookahead depth to the parser
constructor.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/multi/Test.java">parsing/multi/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">LookaheadLexer lexer = <b class="calibre13">new</b> LookaheadLexer(args[0]); <em class="calibre6">// parse arg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">LookaheadParser parser = <b class="calibre13">new</b> LookaheadParser(lexer, 2);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parser.list(); <em class="calibre6">// begin parsing at rule list</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we pass in a valid list such as <code class="calibre21">[a,b=c,[d,e]]</code>, the test rig
quietly returns this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test '[a,b=c,[d,e]]'</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Upon error, however, the parser throws an exception:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test '[a,b=c,,[d,e]]'</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Exception in thread "main" java.lang.Error:</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> expecting name or list; found &lt;',',,&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at LookaheadParser.element(LookaheadParser.java:25)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at LookaheadParser.elements(LookaheadParser.java:12)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at LookaheadParser.list(LookaheadParser.java:7)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at Test.main(Test.java:6)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern builds on Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> and uses Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> to
feed it tokens.  Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a> extends this pattern with arbitrary
lookahead.
</p>

</div></div>
<div id="text/part0000_split_030.html"><div class="calibre">

<h2 id="text/part0000_split_030.html.d24e5520" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">At this point, weve got the most important parsing patterns down.
To handle really tough language problems, well need to dress up the
recursive-descent parser even further.  The next chapter defines
patterns for arbitrary lookahead and using semantic information to
guide the parse.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_030.html.FOOTNOTE-7" href="#text/part0000_split_028.html.FNPTR-7">[7]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.cs.virginia.edu/~cs415/reading/FirstFollowLL.pdf">http://www.cs.virginia.edu/~cs415/reading/FirstFollowLL.pdf</a></p></dd></dl><div class="calibre3" id="text/part0000_split_030.html.calibre_pb_46"></div>

</div></div>
<div id="text/part0000_split_031.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_031.html.calibre_pb_47">&nbsp;</p><a id="text/part0000_split_031.html.toc-8"></a><h4 class="right2" id="text/part0000_split_031.html.chp.advanced-parsing">Chapter 3</h4>
</div></div>
<div id="text/part0000_split_032.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_032.html.calibre_pb_48">Enhanced Parsing Patterns</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">In the previous chapter, we looked at the fundamental language recognition
patterns. Theyre sufficient to handle most parsing tasks, but some
languages defy even Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>. In this chapter,
well explore how to crank up the parsing power at the cost of some
complexity and run-time efficiency.  Well look at three important
specialized parsing patterns:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>. 
This pattern adds a
speculative parsing facility to recursive-descent parsers.  Its
useful to have because sometimes its hard to distinguish between
alternatives without simply trying them. A
<em class="calibre6">backtracking</em> parser attempts alternatives in
order until one of them matches the current input. In effect, this
supports arbitrarily deep lookahead as opposed to the fixed lookahead
of Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>.  This pattern is
extremely powerful but can be very expensive at run-time.</li><li height="6" class="calibre20"><span></span>Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a>.  
This pattern dramatically
increases speculative parsing performance at the cost of a small
amount of memory.</li><li height="6" class="calibre20"><span></span>Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a>.  
Predicated parsers allow us to alter
parser control-flow with arbitrary boolean expressions called <em class="calibre6">semantic predicates</em>.  We can extend any of the parsing patterns in
this book with predicates.</li></ul><p height="10" width="0" class="calibre5">These patterns are tedious to implement by hand, but again,
its important to understand how they work.  The code generated by
parser generators like ANTLR make a lot more sense when youre
familiar with the underlying pattern.  When debugging parsers, for
example, stepping through the code will make much more sense.</p><p height="10" width="0" class="calibre5">You might have seen backtracking and predicated parsers before if
you have a computer science background. Its OK to skip this chapter
in that case.  Memoizing parsers are new enough, though, that you
might want to take a look at them. They really make backtracking
parsers practical.</p><p height="10" width="0" class="calibre5">Lets begin learning about advanced parsing by figuring out why we
sometimes need arbitrary lookahead.</p>

</div></div>
<div id="text/part0000_split_033.html"><div class="calibre">

<h2 id="text/part0000_split_033.html.sec.arbitrary-lookahead" class="calibre18">Parsing with Arbitrary Lookahead</h2><p height="10" width="0" class="calibre5">Differentiating some language constructs is easy. 
For example, in the
following <code class="calibre21">element</code> rule from the list-of-names language in <a href="#text/part0000_split_025.html.sec.tokenizing"><em class="calibre6">Tokenizing Sentences</em></a>, a single token of lookahead dictates which alternative to
choose:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME | list ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// element is name or nested list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'['</em> elements <em class="calibre6">']'</em> ; <em class="calibre6">// match bracketed list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Token <code class="calibre21">NAME</code> predicts the first alternative, and <code class="calibre21">[</code> predicts the
second because <code class="calibre21">list</code> starts with <code class="calibre21">[</code>.</p><p height="10" width="0" class="calibre5">Sometimes, though, the most natural way to express a given language
construct does not fit in Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> or Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>.  Such language constructs are typically very
similar and only differ  on the right side. For example, C++ function
definitions and declarations are identical until the parser sees <code class="calibre21">;</code>
or <code class="calibre21">{</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void bar() {} // a function definition</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void bar();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a function declaration (forward declaration)</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because C++ function headers can be arbitrarily long, the
distinguishing token does not appear at a fixed lookahead position
from the left side of the statement. Consequently, Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a> is
too weak to distinguish function definitions from declarations using
a natural grammar. The natural grammar rule defining C++ function
definitions and declarations might look like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">function : def | decl ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">def : functionHead <em class="calibre6">'{'</em> body <em class="calibre6">'}'</em> ; <em class="calibre6">// E.g., "void bar() {}"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">decl: functionHead <em class="calibre6">';'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// E.g., "void bar();"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">functionHead :  ; <em class="calibre6">// E.g., "int (*foo)(int *f[], float)"</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To distinguish these two constructs starting at the left edge in
<code class="calibre21">function</code>, we need to scan past the entire function
header to the token that follows. Such constructs have always been a
drag to parse.  In a parser
with backtracking machinery, however, its not too bad (see Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>).  We can make a parsing method for rule
<code class="calibre21">function</code> that follows this pseudocode:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void function() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( <em class="calibre6">speculatively-match-def</em> ) def();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if ( <em class="calibre6">speculatively-match-decl</em> ) decl();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else throw new RecognitionError("expecting function");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The parser can speculatively parse as far ahead as it needs. If the
first parsing conditional in <tt class="calibre21">function</tt> doesnt match, the parser
simply rewinds the input and tries the next alternative.</p><p height="10" width="0" class="calibre5">There is a subtle but important point here.  Speculatively matching
the alternatives of a rule effectively orders them. The first
alternative that matches wins.  This is great because we can use
ordering to specify precedence. 
For example, in some cases, two
alternatives of a rule can match the same input. With ordered
alternatives, there is no ambiguity because the parser consistently
chooses the first of two ambiguous alternatives.</p><p height="10" width="0" class="calibre5">By having the parser pay attention to the order of alternatives, we can solve a nasty C++ ambiguity.  C++
input <code class="calibre21">T(a)</code> can be both a declaration and an
expression (see Chapter 12 in <a href="#text/part0000_split_135.html.d2381e296"><em class="calibre6">The
Definitive ANTLR Reference</em>&nbsp;[Par07]</a> for more details). The C++
reference manual says that phrases that look like both should be
treated as declarations.  In a parser that can backtrack, all we have
to do is attempt to match declarations before expressions. Using a syntactic predicate in an ANTLR grammar to invoke backtracking within a specific rule, wed say this: </p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat: (declaration)=&gt; declaration <em class="calibre6">// if it looks like declaration, it is</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// else it's an expression</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Though speculative parsing has a lot of advantages, there are two
drawbacks. First, it can make debugging more difficult.  When the
parser speculatively parses ahead, its easy to get lost with all of
the scanning ahead and rewinding.  Second, backtracking can be
extremely slow. Fortunately, we can fix the efficiency issue. All we
have to do is avoid redundant parsing.
</p>

</div></div>
<div id="text/part0000_split_034.html"><div class="calibre">

<h2 id="text/part0000_split_034.html.d24e5768" class="calibre18">Parsing like a Pack Rat</h2><p height="10" width="0" class="calibre5">Until a backtracking parser finds a winning alternative, it might
speculatively parse the same input with the same rule multiple times. 
Almost by definition, we use backtracking parsers only when we
need to distinguish between similar language constructs. If the
constructs are similar, the associated grammar likely contains
repeated references to the same rule.</p><p height="10" width="0" class="calibre5">In the implementation section of Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>,
well augment the list-of-names language to allow parallel assignments
like Python does: <code class="calibre21">[a,b]=[c,d]</code>. The
<code class="calibre21">stat</code> rule needs to backtrack because it cannot
distinguish the two alternatives with finite lookahead:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat: list <b class="calibre13">EOF</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// try this alternative first</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| list <em class="calibre6">'='</em> list&nbsp;&nbsp; <em class="calibre6">// if 1st alternative fails, try this one</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Upon input <code class="calibre21">[a,b]=[c,d]</code>, <code class="calibre21">stat</code> speculatively parses the first
alternative, which immediately references <code class="calibre21">list</code>.  The first
alternative will fail, causing a backtracking parser to rewind the
input and attempt the second alternative.  The second alternative
immediately calls <code class="calibre21">list</code> again, which is a waste since we already
know it matches.</p><p height="10" width="0" class="calibre5">Memoizing allows us to skip the second parse of <code class="calibre21">list</code>.  <code class="calibre21">list</code> can
skip ahead to where it left off the last time and then return
immediately to <code class="calibre21">stat</code>.  To make this work, we have to <em class="calibre6">memoize</em> (squirrel away) the result of invoking the various parsing methods.  Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a> explains the exact mechanism.</p><p height="10" width="0" class="calibre5">A backtracking strategy allows us to squeeze the maximum power
from a top-down parser, and memoization allows us to do this
efficiently. In some cases, though, syntax alone wont let us
distinguish between sentences. The next section explores how to handle
cases where the same phrase means different things depending on its
context.
</p>

</div></div>
<div id="text/part0000_split_035.html"><div class="calibre">

<h2 id="text/part0000_split_035.html.sec.sempred" class="calibre18">Directing the Parse with Semantic Information</h2><p height="10" width="0" class="calibre5">The parsers were working with in this book recognize <em class="calibre6">context-free languages</em>. 
A context-free language is a language whose
constructs dont depend on the presence of other constructs.
Unfortunately, some programming languages have 
<em class="calibre6">context-sensitive</em> phrases.  To handle context-sensitive phrases with
a context-free parser, we have to predicate alternatives. In effect, a
predicate is just a run-time boolean test that says when its OK to
match an alternative. The predicates gate the associated alternatives
in and out.</p><p height="10" width="0" class="calibre5">To see why we need predicates, lets look at a context-sensitive
phrase within a programming language.  C++ is the traditional parsing
punching bag, so lets get our gloves on and limber up a bit.</p><p height="10" width="0" class="calibre5">In C++, the expression <code class="calibre21">T(6)</code> is either a function call or a
constructor-style typecast depending on whether <code class="calibre21">T</code> is a function or
type name. A C++ parser literally does not know how to interpret
<code class="calibre21">T(6)</code> without seeing the definition of <code class="calibre21">T</code>. Such a construct is
context sensitive and, in this case, ambiguous from a purely syntactic
point of view.  This ambiguity becomes painfully
obvious when you look at the grammar.  The following rule is an
idealized representation of a C++ expression rule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr: INTEGER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// integer literal</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID <em class="calibre6">'('</em> expr <em class="calibre6">')'</em> <em class="calibre6">// function call; AMBIGUOUS WITH NEXT ALT</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID <em class="calibre6">'('</em> expr <em class="calibre6">')'</em> <em class="calibre6">// constructor-style typecast</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Ambiguous grammars lead to 
<em class="calibre6">nondeterministic parsers</em>, parsers
that cannot determine which path to take. In this case, the second and
third alternatives are identicalthe parser could use either. Using
Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>, wed end up with the following method:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void expr() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;// if lookahead is an integer, match an integer</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if (LA(1)==INTEGER) match(INTEGER);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if (LA(1)==ID) <em class="calibre6">match-function-call</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if (LA(1)==ID) <em class="calibre6">match-typecast</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DEAD CODE!</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else <em class="calibre6">error</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The last <code class="calibre21">if</code> statement is dead, unreachable code.  Worse, the
compiler doesnt warn us about it. This error would only show up
during testing.</p><p height="10" width="0" class="calibre5">To solve the problem, we need to augment the final two <code class="calibre21">if</code>-conditions
to test what kind of thing <code class="calibre21">T</code> is.  By introducing two method calls
within the parsing decision itself, we can disambiguate the
alternatives:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void expr() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( LA(1)==INTEGER) match(INTEGER);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if ( LA(1)==ID &amp;&amp; isFunction(LT(1).text) ) <em class="calibre6">match-function-call</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else if ( LA(1)==ID &amp;&amp; isType(LT(1).text) )&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">match-typecast</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else <em class="calibre6">error</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This code follows Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a>. Functions 
<tt class="calibre21">isFunction</tt> and
<tt class="calibre21">isType</tt> answer whether an identifier is a function or type.
Their implementation details arent important for this discussion
(well learn how to implement them in Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a>).</p><p height="10" width="0" class="calibre5">At this point, weve covered the four key parsing strategies, so lets
summarize what weve learned:</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">ANTLR Warns About Dead Code</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">One of the problems with writing parsers by hand is that we dont get
warnings about unreachable parser regions.  
Using a parser generator,
on the other hand, would provide us with a warning. Here is the
ambiguity warning wed get out of ANTLR for the idealized C++ <code class="calibre21">expr</code>
rule:</small></p></blockquote><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Decision can match input such as "ID '(' INTEGER ')'"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;using multiple alternatives: 2, 3</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">As a result, alternative(s) 3 were disabled for that input</code></span></div></td></tr></tbody></table></div></div><hr class="calibre17"></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This is the most
basic parsing strategy that undergraduate computer science students
learn. Start out with this pattern since itll work for most DSLs.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">If a single token
of lookahead cant distinguish between rule alternatives, you need to
use this pattern. 
A more powerful parsing strategy means its easier
to build the grammar.  You dont need to factor the grammar as much to suit
weaker parsing decisions.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Some languages are pretty
complex with equally complicated grammars.  
At least a few parsing
decisions will be difficult to make with a fixed amount lookahead.
When rule alternatives look almost the same, we often have to
speculatively parse entire phrases to distinguish them. This is
precisely what a backtracking parser does.  Use Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a> to
make backtracking efficient.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Use this pattern when
syntax alone is insufficient to make parsing decisions. 
For example,
C++  expression <code class="calibre21">T(6)</code> has multiple interpretations for the same
syntax depending on how we defined <code class="calibre21">T</code>. Semantic predicates let us
alter the parse based upon run-time information (we can direct by
looking up <code class="calibre21">T</code> in a dictionary).</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">Now, lets learn more about the advanced parsing strategies by diving
into their pattern definitions.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_036.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_036.html.tip.backtracker" class="pagebreak2"><small class="calibre35">Pattern 5:</small>&nbsp;&nbsp;&nbsp;Backtracking Parser</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern adds speculative parsing support (arbitrary
lookahead) to any recursive-descent recognizer.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">As we saw in Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>, we cant map all grammars to
recursive-descent parsers.  Only non-left-recursive grammars work (no
rule can directly or indirectly invoke itself without consuming a
token).  Then <a href="#text/part0000_split_028.html.sec.deterministic-ll"><em class="calibre6">Deterministic Parsing Decisions</em></a> showed that we cant always get
properly functioning (deterministic) parsers even from
non-left-recursive grammars.  The problem is that fixed lookahead <em class="calibre6">LL</em>
parsers need the lookahead sets predicting alternatives to be
disjoint.</p><p height="10" width="0" class="calibre5">This pattern overcomes this lookahead issue by allowing arbitrary
lookahead, which lets us parse much more complicated languages.
To look arbitrarily ahead, we need infrastructure to support
backtracking.  Backtracking also gives us a way to specify the
precedence of ambiguous rule alternatives (alternatives that can match
the same input). Backtracking parsers, by definition, try the
alternatives in order.</p><p height="10" width="0" class="calibre5">The backtracking strategy well explore in this pattern supports
any parsing mechanism or technique that needs to speculatively match
alternatives.  For example, ANTLR supports <em class="calibre6">syntactic
predicates</em> that let you control speculative
parsing. Syntactic predicates are grammar fragments that specify the
lookahead language predicting an alternative.</p><p height="10" width="0" class="calibre5">Bryan Ford formalized and extended ANTLRs notion of grammars plus
syntactic predicates, calling them 
<em class="calibre6">Parsing Expression Grammars</em> (PEGs) <a href="#text/part0000_split_135.html.d2381e137"><em class="calibre6">Parsing Expression Grammars: A
Recognition-Based Syntactic Foundation</em>&nbsp;[For04]</a>.  In the functional
language world, syntactic predicates are called <em class="calibre6">parser
combinators</em>; see Parsec.<a id="text/part0000_split_036.html.FNPTR-8" href="#text/part0000_split_039.html.FOOTNOTE-8">[8]</a></p><p height="10" width="0" class="calibre5">Syntactic predicates and speculative parsing are extremely useful
when parsing phrases that look the same from the left edge.
Distinguishing between C++ function definitions and declarations is a
prime example, as we saw in <a href="#text/part0000_split_033.html.sec.arbitrary-lookahead"><em class="calibre6">Parsing with Arbitrary Lookahead</em></a>.
Before diving into the guts of a sample implementation, lets look at
the basic code templates we need, how to manage the input stream, and
then how to handle application-specific actions.</p><h4 class="calibre26">Backtracking Code Templates</h4><p height="10" width="0" class="calibre5">The easiest way to implement a backtracking strategy for a parsing
decision is to speculatively attempt the alternatives in order until
we find one that matches.  Upon success, the parser rewinds the input
and parses the alternative normally (well see why we parse it twice
when we discuss actions).  Upon failing to match an alternative, the
parser rewinds the input and tries the next one.  If the parser cant
find any matching alternative, it throws a no viable
alternative exception.  Here is a template in pseudocode that
implements that strategy:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> <em class="calibre6">rule</em>() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( speculate_<em class="calibre6">alt1</em>() ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// attempt alt 1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( speculate_<em class="calibre6">alt2</em>() ) { <em class="calibre6">// attempt alt 2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( speculate_<em class="calibre6">altN</em>() ) { <em class="calibre6">// attempt alt N</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-altN</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must be an error; no alternatives matched</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> NoViableException(<em class="calibre6">"expecting <em class="calibre6">rule</em>"</em>)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The speculation methods amount to syntactic predicates and look like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> speculate_<em class="calibre6">alt</em>() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> success = true;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;mark(); <em class="calibre6">// mark this spot in input so we can rewind</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">try</b> { <em class="calibre6">match-alt</em> } <em class="calibre6">// attempt to match the alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">catch</b> (RecognitionException e) { success = false; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;release(); <em class="calibre6">// either way, rewind to where we were before attempt</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> success;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Why Using Exceptions for Parser Control Flow Is OK</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">There are two common objections to using exceptions to implement
backtracking. 
First, using exceptions for control flow is usually a
very bad idea because they act like <code class="calibre21">goto</code>s.  In the
case of the backtracking parser, however, the parser really is
detecting syntax errors. We want it to roll back to where it started
speculating no matter how deeply nested the method calls
are. Exceptions work perfectly for this. Besides, were throwing
exceptions for errors anyway and might as well keep the same mechanism
for both.  The second issue is that exceptions can be very
slow. Fortunately, only the creation of
<code class="calibre21">Exception</code> objects is expensive. Throwing and
catching them is approximately the same cost as unrolling the stack
with a sequence of return instructions. All we need to do is create a
single shared exception for use for backtracking.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">By using these pseudocode templates, we can reuse code templates
from Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>. All we need is some
machinery to mark and rewind the input stream.  The most important
change to the usual recursive-descent parsing strategy is that we use
syntax errors (thrown exceptions) to guide the parse.  In other words,
when speculating, a parser does not report syntax errors. Instead, it
forces the parser to roll back to where it started speculating.
Thats what the <code class="calibre21">try-catch</code> is for in the
<code class="calibre21">speculate_</code><em class="calibre6">alt</em><code class="calibre21">()</code>
code template.</p><h4 class="calibre26">Rewinding the Token Stream</h4><p height="10" width="0" class="calibre5">The heart of a backtracking parser lies in its token buffer
management. 
The buffer must handle an arbitrary amount of lookahead
and support nested mark and release operations. The easiest way to
deal with arbitrary lookahead is simply to buffer up the entire token
stream.  That way, the parsers current token index would simply step
through the buffer as the parser consumes tokens. This approach works
great unless we need to parse an infinite token
stream. 
To support infinite token streams or simply to reduce the
memory footprint of our parser, we need a lookahead buffer that caches
as few tokens as possible.</p><p height="10" width="0" class="calibre5">Our parser can start out with a small fixed buffer size,
<code class="calibre21">n</code>.  Like Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, well use
<code class="calibre21">p</code> as the index of the current token in the
lookahead buffer. The difference is that we need to hold more than
(fixed) <em class="calibre6">k</em> tokens in a backtracking parser.  Our
goal is to keep <code class="calibre21">n</code> from growing while
still holding critical tokens.  To do this, we need to reset
<code class="calibre21">p</code> to 0 when it falls off the end of the
buffer rather than stretching the buffer.  We also want lookahead
operations (via <tt class="calibre21">LT</tt>) to stay within the
confines of the lookahead buffer. </p><p height="10" width="0" class="calibre5">Visually these two situations look like this:</p><div class="calibre1"><img id="text/part0000_split_036.html.d24e6446" class="calibre37" src="data:image/gif;base64,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" alt="images/parsing/backtracking-confined-buffer.png"></div><p height="10" width="0" class="calibre5">If we request a lookahead token beyond the end of the buffer with <tt class="calibre21">LT</tt>, though, we need to stretch the buffer to make room, like this:</p><div class="calibre1"><img id="text/part0000_split_036.html.d24e6452" class="calibre43" src="data:image/jpeg;base64,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" alt="images/parsing/backtracking-stretch-buffer.png"></div><p height="10" width="0" class="calibre5">We also need to stretch the buffer while speculating.  The parser
can never throw out tokens that it speculatively matches.  Well need
to reparse those tokens.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">speculate_</code><em class="calibre6">alt</em><code class="calibre21">()</code> code template manages the lookahead
buffer with 
<tt class="calibre21">mark</tt> and <tt class="calibre21">release</tt> methods. <tt class="calibre21">mark</tt> pushes the current
token index onto a stack.  <tt class="calibre21">release</tt> pops the index back off the
stack and rewinds <code class="calibre21">p</code> to that position. We need a stack of markers to
handle nested backtracking.</p><p height="10" width="0" class="calibre5">By rewinding the input, we are sort of undoing the <tt class="calibre21">consume</tt>
operations that the parser executes. But, things get a lot trickier
when programmers stick application-specific code into the parser.</p><h4 class="calibre26">Dealing with Actions While Backtracking</h4><p height="10" width="0" class="calibre5">Application-specific parser actions can have side effects we cant
undo such as launch missiles.  There are three choices. Either we
disallow actions or disallow actions with side effects, or we parse
winning alternatives twice.  Well choose the third alternative. Its
the least efficient but the most flexible since we need those
programmer-defined actions.  They are often the easiest way to
implement a language application.</p><p height="10" width="0" class="calibre5">A backtracking parser parses the winning alternative once during
speculation and then again during normal alternative matching.  To
allow actions with side effects in a backtracking parser, all we have
to do is gate actions with a test to see whether the parser is
speculating:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( <em class="calibre6">not-speculating</em> ) { <em class="calibre6">arbitrary-action</em> }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">During speculation, all actions are off. Once the parser knows an
alternative will match, however, it can match the alternative again
with feeling to do the actions.</p><p height="10" width="0" class="calibre5">The one caveat to action gating is that there are some actions we must
execute during speculation. Tracking variable and method names is
critical if we need to guide the parse with such information (see Pattern 7, <a href="#text/part0000_split_038.html.tip.predicated-parser"><em class="calibre6">Predicated Parser</em></a>). Actions that must always execute shouldnt have the action gate.</p><p height="10" width="0" class="calibre5">Enough generalities. Lets build a backtracking parser!</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">For this patterns example, lets augment our list-of-names language
to allow parallel assignments like Python does: <code class="calibre21">[a,b]=[c,d]</code>.  
Here is our usual grammar with a new start rule, <code class="calibre21">stat</code>, that adds
parallel list assignment:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/NameListWithParallelAssign.g">parsing/backtrack/NameListWithParallelAssign.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat&nbsp;&nbsp;&nbsp;&nbsp; : list <b class="calibre13">EOF</b> | assign <b class="calibre13">EOF</b> ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign&nbsp;&nbsp; : list <em class="calibre6">'='</em> list ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list&nbsp;&nbsp;&nbsp;&nbsp; : <em class="calibre6">'['</em> elements <em class="calibre6">']'</em> ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match bracketed list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">elements : element (<em class="calibre6">','</em> element)* ;&nbsp;&nbsp;<em class="calibre6">// match comma-separated list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">element&nbsp;&nbsp;: NAME <em class="calibre6">'='</em> NAME | NAME | list ; <em class="calibre6">//element is name, nested list</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The parallel assignment construct in <code class="calibre21">stat</code> would cause trouble for
Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>.  Both alternatives begin with a call to
<code class="calibre21">list</code>.  Because <code class="calibre21">list</code> can be arbitrarily long, no fixed-lookahead
recursive-descent parser can distinguish between <code class="calibre21">stat</code>s
alternatives.  We need to parse at least an entire <code class="calibre21">list</code> plus one
token before deciding which alternative will succeed. Following the
code templates from the previous section, <code class="calibre21">stat</code> looks like this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/BacktrackParser.java">parsing/backtrack/BacktrackParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** stat : list EOF | assign EOF ; */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> stat() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// attempt alternative 1: list EOF</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( speculate_stat_alt1() ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list(); match(Lexer.EOF_TYPE);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// attempt alternative 2: assign EOF</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( speculate_stat_alt2() ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assign(); match(Lexer.EOF_TYPE);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must be an error; neither matched; LT(1) is lookahead token 1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> NoViableAltException(<em class="calibre6">"expecting stat found "</em>+LT(1));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The speculative parsing support methods look like this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/BacktrackParser.java">parsing/backtrack/BacktrackParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> speculate_stat_alt1() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> success = true;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;mark(); <em class="calibre6">// mark this spot in input so we can rewind</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">try</b> { list(); match(Lexer.EOF_TYPE); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">catch</b> (RecognitionException e) { success = false; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;release(); <em class="calibre6">// either way, rewind to where we were</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> success;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> speculate_stat_alt2() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> success = true;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;mark(); <em class="calibre6">// mark this spot in input so we can rewind</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">try</b> { assign(); match(Lexer.EOF_TYPE); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">catch</b> (RecognitionException e) { success = false; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;release(); <em class="calibre6">// either way, rewind to where we were</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> success;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">All the other rules follow Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, so we dont
need to look at those here (theres no point in speculating in the
other rules if <em class="calibre6">LL(k)</em> is sufficient).  The only thing left to do is
build the support machinery for managing the lookahead buffer.</p><p height="10" width="0" class="calibre5">Our <code class="calibre21">Parser</code> base class tracks the input stream, a stack of markers for 
<tt class="calibre21">mark</tt> and <tt class="calibre21">release</tt>, the lookahead buffer itself, and an index
for the current token:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/Parser.java">parsing/backtrack/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Lexer input;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// from where do we get tokens?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">List</b>&lt;<b class="calibre13">Integer</b>&gt; markers; <em class="calibre6">// stack of index markers into lookahead buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">List</b>&lt;Token&gt; lookahead; <em class="calibre6">// dynamically-sized lookahead buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> p = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// index of current lookahead token;</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// LT(1) returns lookahead[p]</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The token access and testing methods are very similar to the
fixed-lookahead parser versions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/Parser.java">parsing/backtrack/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Token LT(<b class="calibre13">int</b> i) { sync(i); <b class="calibre13">return</b> lookahead.get(p+i-1); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">int</b> LA(<b class="calibre13">int</b> i) { <b class="calibre13">return</b> LT(i).type; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> match(<b class="calibre13">int</b> x) <b class="calibre13">throws</b> MismatchedTokenException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( LA(1) == x ) consume();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> MismatchedTokenException(<em class="calibre6">"expecting "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input.getTokenName(x)+<em class="calibre6">" found "</em>+LT(1));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The only difference is that <tt class="calibre21">LT</tt> treats <code class="calibre21">lookahead</code> as a simple list,
not a circular list (there is no modulo operator in the index
computation).  That implies that there must always be a valid token at
index <code class="calibre21">p+i-1</code> (<code class="calibre21">i</code> tokens ahead). This is where the call to 
<tt class="calibre21">sync</tt>
comes in.  The <tt class="calibre21">sync</tt> method makes sure that the lookahead buffer
always has valid tokens from index <code class="calibre21">p</code> to <code class="calibre21">p+i-1</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/Parser.java">parsing/backtrack/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Make sure we have i tokens from current position p */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> sync(<b class="calibre13">int</b> i) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( p+i-1 &gt; (lookahead.size()-1) ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// out of tokens?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> n = (p+i-1) - (lookahead.size()-1); <em class="calibre6">// get n tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill(n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> fill(<b class="calibre13">int</b> n) { <em class="calibre6">// add n tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (<b class="calibre13">int</b> i=1; i&lt;=n; i++) { lookahead.add(input.nextToken()); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To advance through the input stream, the parser calls 
<tt class="calibre21">consume</tt>.  The
<tt class="calibre21">consume</tt> method is the same as in the fixed-lookahead parser except
that we clear the lookahead buffer when we hit the end.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/Parser.java">parsing/backtrack/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> consume() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// have we hit end of buffer when not backtracking?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( p==lookahead.size() &amp;&amp; !isSpeculating() ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// if so, it's an opportunity to start filling at index 0 again</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = 0;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lookahead.clear(); <em class="calibre6">// size goes to 0, but retains memory</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;sync(1); <em class="calibre6">// get another to replace consumed token</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The marker management methods are simple because all they do is manage
the <code class="calibre21">markers</code> stack:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/backtrack/Parser.java">parsing/backtrack/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">int</b> mark() { markers.add(p); <b class="calibre13">return</b> p; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> release() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> marker = markers.get(markers.size()-1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;markers.remove(markers.size()-1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;seek(marker);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> seek(<b class="calibre13">int</b> index) { p = index; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> isSpeculating() { <b class="calibre13">return</b> markers.size() &gt; 0; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To learn more about backtracking parsers, take a look at Chapter 14 in
<a href="#text/part0000_split_135.html.d2381e296"><em class="calibre6">The Definitive ANTLR Reference</em>&nbsp;[Par07]</a>,
which explains how ANTLR implements backtracking.  Chapters 11 and 12 in that book provide examples and discuss how ANTLR optimizes away a lot of
backtracking.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">The pattern described here extends Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>, with arbitrary
lookahead and backtracking support.  Pattern 6, <a href="#text/part0000_split_037.html.tip.packrat"><em class="calibre6">Memoizing Parser</em></a> shows how to
avoid unnecessary reparsing by recording partial parsing results.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_037.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_037.html.tip.packrat" class="pagebreak2"><small class="calibre35">Pattern 6:</small>&nbsp;&nbsp;&nbsp;Memoizing Parser</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern records partial parsing results during
backtracking to guarantee linear parsing performance, at the cost of a
small amount of memory.</em> 
</p><p height="10" width="0" class="calibre5">Memoizing is a form of dynamic programming and lets us avoid reparsing
the same input with the same rule.  Another name for <em class="calibre6">memoizing
recursive-descent parser</em> is <em class="calibre6">packrat parser</em>, a fabulous term
coined by Bryan Ford in <a href="#text/part0000_split_135.html.d2381e97"><em class="calibre6">Packrat
parsing:: simple, powerful, lazy, linear time, functional
pearl</em>&nbsp;[For02]</a>.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Without memoization to avoid redundant parsing, backtracking can lead
to impractically slow (exponentially complex) parse times. This
pattern guarantees linear parse time at the cost of a bit of
memory. The extra memory is well worth the gain in parsing speed. Ive
seen backtracking parse times go from hours to seconds with the
introduction of memoization.</p><p height="10" width="0" class="calibre5">Memoization only helps us, though,  if we invoke the same rule at
the same input position more than once. For example, upon input
<code class="calibre21">(3+4);</code>, a backtracking parser derived from
the following rule invokes <code class="calibre21">expr</code> twice:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">s&nbsp;&nbsp;&nbsp;&nbsp;: expr <em class="calibre6">'!'</em> <em class="calibre6">// assume backtracking parser tries this alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; | expr <em class="calibre6">';'</em> <em class="calibre6">// and then this one</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr :  ; <em class="calibre6">// match input such as "(3+4)"</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">s</code> invokes <code class="calibre21">expr</code> to speculatively match the first
alternative.  <code class="calibre21">expr</code> succeeds, but <code class="calibre21">s</code> finds that the next input
symbol is <code class="calibre21">;</code> and not <code class="calibre21">!</code>. Rule <code class="calibre21">s</code> rewinds the input and tries the
second alternative. The parser immediately calls <code class="calibre21">expr</code> again and at
the same input position.  Thats a waste of CPU time. To avoid
reparsing, all we have to do is remember that <code class="calibre21">expr</code> succeeded the
last time we tried it at this position.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Why Packrat Parsing Is Fast</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Memoization of parsing results guarantees there is no way to
      parse the same rule at the same input position more than once. 
      Therefore, parsing speed is bounded by how many rules and how
      many input tokens there are. Because the number of rules in a grammar
      is fixed, the dominant component of the speed function is the number
      of input tokens. Consequently, packrat parsers are guaranteed to have
      linear performance, albeit with some heavy overhead sometimes. As for
      memory requirements, the most we can record is a single integer per
      rule per input position leading also to a linear space complexity.  In
      the worst case, we have to call every rule once for each input
      position (saving an integer for each invocation). In practice, packrat
      parser generators must do a great deal of optimization to approach the
      performance of fixed-lookahead parsers.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">expr</code> can avoid parsing if it succeeded the
last time by just pretending to parse. To simulate a successful
speculative parse, we skip ahead to where <code class="calibre21">expr</code> left
off the last time and return immediately.</p><p height="10" width="0" class="calibre5">Oddly enough, we can also avoid parsing with
<code class="calibre21">expr</code> if it failed the last time. We know it wont
match, so we can return immediately.  The invoking parser rule will
rewind the input to try the next alternative, so we dont have to
adjust the input position.</p><p height="10" width="0" class="calibre5">To record partial results, we need a 
memoizing dictionary for each
rule that maps an integer token buffer index to a condition
value. There are three possible conditions: <em class="calibre6">unknown</em>,
<em class="calibre6">failed</em>, or <em class="calibre6">succeeded</em>. 
An <em class="calibre6">unknown</em> dictionary result indicates that the associated
rule method hasnt parsed at that position before. <em class="calibre6">Failed</em>
indicates that the parser failed the last time it tried to parse
starting at that input position. Any other result indicates a
previously successful parse.</p><p height="10" width="0" class="calibre5">We can represent the <em class="calibre6">failed</em> condition with a negative
number in the dictionary. The <em class="calibre6">unknown</em> condition happens
by default when the dictionary has no entry for that input position.
The integers zero and greater indicate a previously successful parse.
The integer also records the token index one past where the parsing
method finished previously. (The position is an index into the
lookahead token buffer, not an absolute token position within the
input stream.)</p><p height="10" width="0" class="calibre5">To turn Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a> into a packrat parser, we
also need a memoizing method for each rule method. The memoizing
method either avoids reparsing or records the success or failure of
the normal parsing method.  The code template looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Map input position to FAILED or previous stop token index.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;Missing value implies we've not parsed this rule at that index.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Map</b>&lt;<b class="calibre13">Integer</b>, <b class="calibre13">Integer</b>&gt; <em class="calibre6">rule</em>_memo = <b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">Integer</b>, <b class="calibre13">Integer</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> <em class="calibre6">rule</em>() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> failed = false;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> startTokenIndex = index();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( isSpeculating() &amp;&amp; alreadyParsedRule(<em class="calibre6">rule</em>_memo) ) <b class="calibre13">return</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must not have previously parsed rule at token index; parse it</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">try</b> { _<em class="calibre6">rule</em>(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">catch</b> (RecognitionException re) { failed = true; <b class="calibre13">throw</b> re; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">finally</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// succeed or fail, we must record result if backtracking</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> (isSpeculating())</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memoize(<em class="calibre6">rule</em>_memo, startTokenIndex, failed);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This memoizing method assumes the role of the original rule
method. Other rules that refer to it dont need to change. We can
rename the original parsing rule method to be _<em class="calibre6">rule</em>.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">To demonstrate packrat parsing, lets memoize the <code class="calibre21">list</code> method
from Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>.  
Rule <code class="calibre21">stat</code> invokes rule <code class="calibre21">list</code> multiple
times from its left edge during backtracking:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat&nbsp;&nbsp;&nbsp;&nbsp; : list <b class="calibre13">EOF</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// try this alternative first</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | list <em class="calibre6">'='</em> list&nbsp;&nbsp; <em class="calibre6">// if 1st alternative fails, try this one</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The parser method, <tt class="calibre21">_list</tt>, is the same except for the <code class="calibre21">_</code> prefix:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/memoize/BacktrackParser.java">parsing/memoize/BacktrackParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// match '[' elements ']'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> _list() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(<em class="calibre6">"parse list rule at token index: "</em>+index());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;match(BacktrackLexer.LBRACK);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;elements();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;match(BacktrackLexer.RBRACK);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To memoize it, we create the following method using the code template
from the previous section:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** list : '[' elements ']' ; // match bracketed list */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> list() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">boolean</b> failed = false;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> startTokenIndex = index(); <em class="calibre6">// get current token position</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( isSpeculating() &amp;&amp; alreadyParsedRule(list_memo) ) <b class="calibre13">return</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must not have previously parsed list at tokenIndex; parse it</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">try</b> { _list(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">catch</b> (RecognitionException re) { failed = true; <b class="calibre13">throw</b> re; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">finally</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">//&nbsp;&nbsp;succeed or fail, must record result if backtracking</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> (isSpeculating()) memoize(list_memo, startTokenIndex, failed);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We also need to augment the support code in <code class="calibre21">Parser</code>. First, we need
a constant to represent failed parsing results:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> FAILED = -1;&nbsp;&nbsp;<em class="calibre6">// parsing failed on last attempt</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, we need to implement
<tt class="calibre21">alreadyParsedRule</tt> and
<tt class="calibre21">memoize</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/memoize/Parser.java">parsing/memoize/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Have we parsed a particular rule before at this input position?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If no memoization value, we've never parsed here before.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If memoization value is FAILED, we parsed and failed before.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If value &gt;= 0, it is an index into the token buffer.&nbsp;&nbsp;It indicates</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;a previous successful parse.&nbsp;&nbsp;This method has a side effect:</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;it seeks ahead in the token buffer to avoid reparsing.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> alreadyParsedRule(<b class="calibre13">Map</b>&lt;<b class="calibre13">Integer</b>, <b class="calibre13">Integer</b>&gt; memoization)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">throws</b> PreviousParseFailedException</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Integer</b> memoI = memoization.get(index());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( memoI==null ) <b class="calibre13">return</b> false;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> memo = memoI.intValue();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(<em class="calibre6">"parsed list before at index "</em>+index()+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">"; skip ahead to token index "</em>+memo+<em class="calibre6">": "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookahead.get(memo).text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( memo==FAILED ) <b class="calibre13">throw</b> <b class="calibre13">new</b> PreviousParseFailedException();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// else skip ahead, pretending we parsed this rule ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;seek(memo);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> true;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** While backtracking, record partial parsing results.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If invoking rule method failed, record that fact.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If it succeeded, record the token position we should skip to</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;next time we attempt this rule for this input position.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> memoize(<b class="calibre13">Map</b>&lt;<b class="calibre13">Integer</b>, <b class="calibre13">Integer</b>&gt; memoization,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> startTokenIndex, <b class="calibre13">boolean</b> failed)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// record token just after last in rule if success</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> stopTokenIndex = failed ? FAILED : index();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;memoization.put(startTokenIndex, stopTokenIndex);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">int</b> index() { <b class="calibre13">return</b> p; } <em class="calibre6">// return current input position</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">One final detail:  recall that 
<tt class="calibre21">consume</tt>
resets lookahead buffer index <code class="calibre21">p</code> to 0 and
clears the lookahead buffer when no longer speculating.  That means
that all the indexes in the memoization dictionaries are no longer
valid. We dont need that data anymore anyway. If the parser isnt
speculating, then its committed to a particular
alternative. Memoization data for positions earlier in the input are
no longer useful. Heres the critical part of that method:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/memoize/Parser.java">parsing/memoize/Parser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// if so, it's an opportunity to start filling at index 0 again</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">lookahead.clear(); <em class="calibre6">// size goes to 0, but retains memory</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">clearMemo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// clear any rule_memo dictionaries</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To convince ourselves that were actually avoiding some reparsing,
lets make a test rig:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/memoize/Test.java">parsing/memoize/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BacktrackLexer lexer = <b class="calibre13">new</b> BacktrackLexer(args[0]); <em class="calibre6">// parse arg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BacktrackParser parser = <b class="calibre13">new</b> BacktrackParser(lexer);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parser.stat(); <em class="calibre6">// begin parsing at rule stat</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Here is a sample run with input <code class="calibre21">[a,b]=[c,d]</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test '[a,b]=[c,d]'</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">attempt alternative 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parse list rule at token index: 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">attempt alternative 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parsed list before at index 0; skip ahead to token index 5: =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parse list rule at token index: 6</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">predict alternative 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parse list rule at token index: 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">parse list rule at token index: 6</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets interpret the output.  Rule <code class="calibre21">stat</code> attempts its first
alternative (a simple list followed by <code class="calibre21">EOF</code>). It enters memoized <tt class="calibre21">list</tt>, which calls <tt class="calibre21">_list</tt> and then records a successful parse at
token index 0. The first alternative ultimately fails, though, because
<code class="calibre21">=</code> follows the list, not <code class="calibre21">EOF</code>.</p><p height="10" width="0" class="calibre5">Rule <code class="calibre21">stat</code> therefore attempts the second alternative.  It calls
memoized <tt class="calibre21">list</tt> (via <code class="calibre21">assign</code>) and finds that the dictionary
contains token index 5 for key 0. That means the parser remembers
parsing <code class="calibre21">list</code> at index 0. More important, the dictionary tells us
that the parser left off at index 5 the last time. Instead of parsing,
<tt class="calibre21">list</tt> can just skip ahead.  To finish speculative parsing of the
second alternative, the parser matches <code class="calibre21">=</code> (index 5) and then another
<code class="calibre21">list</code> (index 6). At this point, the parser has convinced itself that
the second alternative of <code class="calibre21">stat</code> will succeed.</p><p height="10" width="0" class="calibre5">After the speculative parse, the parser knows to match the second
alternative. It rewinds and matches the second alternative of
<code class="calibre21">stat</code> normally (recall that a backtracking parser
rematches the alternative to execute any application-specific
actions).  The last two <code class="calibre21">parse list
rule</code> lines in the output show the parser matching
lists on the left and right of the assignment operator.</p><p height="10" width="0" class="calibre5">So, the output shows that adding memoization prevents the parser from
performing a redundant computation.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern extends Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a> to make it more efficient.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_038.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_038.html.tip.predicated-parser" class="pagebreak2"><small class="calibre35">Pattern 7:</small>&nbsp;&nbsp;&nbsp;Predicated Parser</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern augments any top-down parser with arbitrary
boolean expressions that help make parsing decisions.</em>
</p><p height="10" width="0" class="calibre5">These boolean expressions are called <em class="calibre6">semantic predicates</em> and
specify the semantic applicability of an alternative.  Predicates that
evaluate to false effectively turn off a parser decision path.
From a grammar point of view, false predicates make alternatives
invisible.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">We need semantic predicates when the parser cannot use syntax alone
to make parsing decisions, that is, when the parser cannot distinguish
between alternatives without using run-time information. The most
common case is when we need to use symbol table information to guide
the parse. (See Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a>.)  As we saw in <a href="#text/part0000_split_035.html.sec.sempred"><em class="calibre6">Directing the Parse with Semantic Information</em></a>, C++ expression <code class="calibre21">T(6)</code>
can be a function call or typecast depending on whether
<code class="calibre21">T</code> is a function or a class.</p><p height="10" width="0" class="calibre5">Predicates are also useful when a parser must recognize multiple
versions of an input language.  For example, the GCC C compiler adds
a number of extensions beyond C.  Java 5.0 introduced the <code class="calibre21">enum</code>
keyword to support enumerated types. To handle multiple language
versions with the same parser, we can make a core version that matches
the most complete language version.  Then, we can predicate parsing
decisions to turn off various version-dependent language
constructs.</p><p height="10" width="0" class="calibre5">Predicated parsing decisions look exactly like those in <a href="#text/part0000_split_026.html.sec.parsing-decisions"><em class="calibre6">Converting Subrules</em></a>.  The only difference is the introduction of
arbitrary boolean tests after the lookahead tests.  Here is the basic
decision code template:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> <em class="calibre6">rule</em>() <b class="calibre13">throws</b> RecognitionException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( <em class="calibre6">lookahead-test-alt1</em> &amp;&amp; <em class="calibre6">pred1</em> ) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// attempt alt 1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( <em class="calibre6">lookahead-test-alt2</em> &amp;&amp; <em class="calibre6">pred2</em> ) { <em class="calibre6">// attempt alt 2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-alt2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( <em class="calibre6">lookahead-test-altN</em> &amp;&amp; <em class="calibre6">predN</em> ) { <em class="calibre6">// attempt alt N</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">match-altN</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must be an error; no alternatives matched</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">throw</b> <b class="calibre13">new</b> NoViableException(<em class="calibre6">"expecting <em class="calibre6">rule</em>"</em>)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Predicated loop decisions for grammar <code class="calibre21">(...)*</code> and <code class="calibre21">(...)+</code> subrules
look like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">while ( <em class="calibre6">lookahead-test-for-loop-alts</em> &amp;&amp; <em class="calibre6">pred</em> ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">subrule-code-to-match-alts</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To see how semantic predicates solve a surprisingly nasty parsing
problem, lets do battle with C++ again in the Implementation section.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">C++ allows multiple type specifiers before the variable name, as follows:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">volatile unsigned long int x; // lots of type specifiers before x</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">But an identifier can also be a type name as in <code class="calibre21">const T y;</code>. To see
why thats a problem, lets build a simplified C++ grammar to deal
with variable declarations.  To match the type specifiers before the
<code class="calibre21">ID</code> variable name, lets loop around rules <code class="calibre21">qualifier</code> and <code class="calibre21">types</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">declaration : (qualifier|type)+ ID <em class="calibre6">';'</em> ; <em class="calibre6">// E.g., "const int x;"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">qualifier&nbsp;&nbsp; : <em class="calibre6">'const'</em> | <em class="calibre6">'volatile'</em> ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <em class="calibre6">'int'</em> | <em class="calibre6">'unsigned'</em> | <em class="calibre6">'long'</em>| ID ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Unfortunately, the loop in <code class="calibre21">declaration</code> cant decide what to do upon
seeing <code class="calibre21">ID</code>.  The loop doesnt know whether to match <code class="calibre21">ID</code> now or to
leave it to the following <code class="calibre21">ID</code> reference.  If the loop matches it,
the parser interprets <code class="calibre21">ID</code> as a type name. By letting the loop exit,
the parser interprets <code class="calibre21">ID</code> as the variable name.  For example, upon
<code class="calibre21">T</code> in <code class="calibre21">const T y;</code>, the loop doesnt know whether <code class="calibre21">T</code> is a type name
or a variable name. The loop decision will match <code class="calibre21">T</code> no matter what:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">while ( LA(1)==CONST || LA(1)==VOLATILE || LA(1)==INT ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LA(1)==UNSIGNED || LA(1)==LONG || LA(1)==ID ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;// match qualifier or type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The correct solution is to match <code class="calibre21">ID</code> inside <code class="calibre21">type</code> only if its a
type name. In an ANTLR grammar, we can prefix the <code class="calibre21">ID</code> alternative
with a semantic predicate that checks the lookahead tokens status as
a type name:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">type:&nbsp;&nbsp; <em class="calibre6">'int'</em> | <em class="calibre6">'unsigned'</em> | <em class="calibre6">'long'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; {isTypeName(LT(1).getText())}? ID <em class="calibre6">// type name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Assume method 
<tt class="calibre21">isTypeName</tt> looks up the lookahead tokens text in a type table. (<code class="calibre21">LT(1)</code> is the current lookahead token.)
To do the same thing manually, we just add a new
clause to the <code class="calibre21">(...)+</code> loop condition from <code class="calibre21">declaration</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">while ( LA(1)==CONST || LA(1)==VOLATILE || LA(1)==INT ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LA(1)==UNSIGNED || LA(1)==LONG ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(LA(1)==ID&amp;&amp;isTypeName(LT(1).getText())) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;// match qualifier or type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now, the parser will only match <code class="calibre21">ID</code>s as part of the type qualifiers
if they are type names. The key lesson here is that we need to
predicate the parsing decision with information that is only available 
at run-time.</p><p height="10" width="0" class="calibre5">In this case, we need context information (is <code class="calibre21">T</code> a type
name?) to figure out how to parse declarations.
</p>

</div></div>
<div id="text/part0000_split_039.html"><div class="calibre">

<h2 id="text/part0000_split_039.html.d24e8307" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">Weve just spent two chapters learning how to build recognizers.
Were ready to move on to the second part of the book. Were going to
learn how to build internal data structures from the input, how to
walk those structures, and how to analyze sentences to check for
correctness.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_039.html.FOOTNOTE-8" href="#text/part0000_split_036.html.FNPTR-8">[8]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">Daan Leijen. Parsec, A Fast
Combinator Parser.
<a href="http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf">http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf</a>.</p></dd></dl><div class="calibre3" id="text/part0000_split_039.html.calibre_pb_56"></div>

</div></div>
<div id="text/part0000_split_040.html"><div class="calibre">

<div id="text/part0000_split_040.html.toc-9" style="height:0pt"></div><h1 class="part-title" id="text/part0000_split_040.html.d24e8312"><span class="calibre14">Part 2</span><br class="calibre4"><span class="calibre14">Analyzing Languages</span></h1><div class="calibre3" id="text/part0000_split_040.html.calibre_pb_60"></div>

</div></div>
<div id="text/part0000_split_041.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_041.html.calibre_pb_61">&nbsp;</p><a id="text/part0000_split_041.html.toc-10"></a><h4 class="right2" id="text/part0000_split_041.html.chp.IR">Chapter 4</h4>
</div></div>
<div id="text/part0000_split_042.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_042.html.calibre_pb_62">Building Intermediate Form Trees</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">Before interpreting or translating an input phrase, we have to
fully understand that phrase. 
That means we have to verify its syntax
and verify that it makes sense. In the previous part of this book, we
learned how to check phrase syntax.  In this part of the book, were
going to explore the patterns that help us analyze input
phrases.</p><p height="10" width="0" class="calibre5">Only the simplest language applications get away with reading input
and directly generating output. Such applications are called
<em class="calibre6">syntax-directed</em> applications because they can
generate output as soon as they recognize a construct.  For example,
if we wanted to convert a wiki markup format to HTML, we could translate it
almost character by character. The key characteristic of
syntax-directed applications is that they translate input
phrase by phrase using a <em class="calibre6">single</em> pass over the input.</p><p height="10" width="0" class="calibre5">Most  language applications, however, need to build an 
<em class="calibre6">intermediate representation</em> (IR) or <em class="calibre6">intermediate form</em>.  The goal of an
applications reader component is to fill an IR data structure with
elements of interest from the input stream.  Some language
applications, such as configuration file readers, stop after building
an IR. Usually, though, readers are just the first stage in a
pipeline of components. Thats why the <em class="calibre6">I</em> in IR stands for
intermediate, not internal.</p><p height="10" width="0" class="calibre5">The needs of the intended application dictate the nature of the IR.
For example, if we need to track word occurrences in a document, an
unordered set of words works fine. 
If the order of word occurrence is
important, we need to construct a list rather than a set.  Generally
speaking, though, to get a computer to understand a nontrivial
sentence, we have to break it down into a series of operations and
operands. Thats just the way computers like to do things.</p><p height="10" width="0" class="calibre5">Once we identify the operators and operands among the input tokens, we
need to build an IR data structure.  For most language applications,
that means building a tree data structure. In particular, well build
an <em class="calibre6">abstract syntax tree</em> (AST). ASTs hold the key tokens from the input
stream and record grammatical relationships discovered during the
parse.  ASTs are so central to translator and interpreter design that
its worth spending an entire chapter on them.</p><p height="10" width="0" class="calibre5">ASTs are the <em class="calibre6">lingua franca</em> spoken by the various stages
in a language application. Each stage performs a computation, rewrites
the tree, or creates another data structure before passing the tree
along to the next stage. To do their work, the stages need to walk the
trees and trigger actions when they encounter specific subtree
patterns.  As well see in the next chapter, tree pattern matching is
a pain to do by hand. Fortunately, we can automate tree matching just
like we do with flat sentence parsing.</p><p height="10" width="0" class="calibre5">Before we get into tree walking and matching, though, we need to learn
everything we can about ASTs. In this chapter, well discuss:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Why we build trees in the first place</li><li height="6" class="calibre20"><span></span>How we should structure ASTs and why</li><li height="6" class="calibre20"><span></span>How to implement ASTs in an object-oriented language</li><li height="6" class="calibre20"><span></span>How to enforce tree structure with an implementation languages static type system</li><li height="6" class="calibre20"><span></span>How to construct ASTs with ANTLRs AST operators and rewrite rules</li></ul><p height="10" width="0" class="calibre5">During our introductory discussion, well explore the four most common
IR tree patterns and then formally define them:
</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>. 
Parse trees record how a parser recognizes an
input sentence. The interior nodes are rule names, and the leaves are
tokens. Although parse trees are less suitable than ASTs for most
language applications, parsers can create them automatically.</li><li height="6" class="calibre20"><span></span>Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>. 
The most important thing about a tree is its shape, not
its node data type.  Unless were writing a lot of code by hand, we
can get away with a few or even just one node data type. If all the
nodes have the same type, we say that they are homogeneous. With a
single node type, there can be no  specialty fields to reference child subtrees.
Nodes track children with lists of child pointers.</li><li height="6" class="calibre20"><span></span>Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>. 
Trees with a multitude of node types are
called <em class="calibre6">heterogeneous trees</em>.   Normalized heterogeneous trees use a
normalized list of children like homogeneous trees.</li><li height="6" class="calibre20"><span></span>Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>. 
When we refer to an AST as heterogeneous, we also
assume that the nodes have irregular children. Instead of a normalized
child list, the nodes have named fields, one per child.</li></ul><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Representing Nested Structures with Trees</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">A <em class="calibre6">tree</em> is a data structure composed of a set of nodes organized
into a hierarchy. Each node has a parent and an ordered list of zero,
one, or multiple children. The children can be simple nodes or
complete subtrees.  In computer science, we draw trees with the root
node at the top and the branches descending below.  Root nodes
are analogous to the root directory on a disk. Children are analogous
to files and subdirectories.</small></p></blockquote></div><hr class="calibre17"></div>

</div></div>
<div id="text/part0000_split_043.html"><div class="calibre">

<h2 id="text/part0000_split_043.html.d24e8486" class="calibre18">Why We Build Trees</h2><p height="10" width="0" class="calibre5">As we saw in Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>, being able to recognize an input phrase
means being able to identify and extract key input elements.
For example, recognizing the English phrase Rebecca runs to the park means
we know Rebecca is the subject, runs is the verb, and to the
park is the object.  Language recognition is more complicated than
simply picking out the parts of speech, though.  The order of those
elements counts. In a modern English sentence, for example, the verb
usually sits between the subject and the object. It sounds wrong
(despite being intelligible) to say Rebecca to the park
runs.<a id="text/part0000_split_043.html.FNPTR-9" href="#text/part0000_split_051.html.FOOTNOTE-9">[9]</a></p><p height="10" width="0" class="calibre5">Order is not the only important sentence recognition issue. Many
languages have subphrases and nested structures.  
For example, some
object-oriented languages allow nested class definitions. An inner
class definition is a phrase nested within another phrase (the outer
class).  So, our IR must record not only the elements of interest but
the relationship between them as well.  It turns out that trees are
the perfect data structure to represent ordered and nested
structures. There are two general kinds of trees were going to look at: 
<em class="calibre6">parse trees</em> and <em class="calibre6">abstract syntax trees</em>.</p><p height="10" width="0" class="calibre5">Since were already familiar with parse trees from Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>
(sometimes called <em class="calibre6">syntax trees</em>), lets look at them first.
Parse trees record the sequence of rules a parser applies as well as
the tokens it matches.  Interior parse tree nodes represent rule
applications, and leaf nodes represent token matches.</p><p height="10" width="0" class="calibre5">Parsers dont normally create parse trees, though.  Instead,
recursive-descent rule method invocations simply trace out the parse
tree during the parse. Because the rules for constructing parse trees
are simple and regular, though, the parser can automatically
construct them in memory. The parse tree acts like an execution
trace. See Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>.</p><p height="10" width="0" class="calibre5">Given assignment <code class="calibre21">x=0;</code>, our parser might create a parse tree like
Figure 8, <a href="#text/part0000_split_043.html.fig.assign"><em class="calibre6">x=0; assignment statement parse tree</em></a>.  The tree represents the tokens from the assignment as
well as its grammatical structure. It has everything we need to know about
interpreting the sequence of input symbols as an assignment.  The
interior nodes organize and identify what roles their children play.</p><div class="calibre1" id="text/part0000_split_043.html.fig.assign"><img id="text/part0000_split_043.html.d24e8555" class="calibre30" src="data:image/gif;base64,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" alt="images/IR/assign.png"><hr class="calibre17"><b class="calibre13">Figure 8. <code class="calibre21">x=0;</code> assignment statement parse tree</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Parse trees are nice to look at and help us understand how a parser
interpreted an input phrase.  But, a parser execution trace isnt
really the best IR.  Certainly we need to pinpoint the various
substructures, but we dont need to name them explicitly.
Surprisingly, we dont need the internal rule nodes at all.  The next
section describes how to construct suitable intermediate form trees
using only the tokens.
</p>

</div></div>
<div id="text/part0000_split_044.html"><div class="calibre">

<h2 id="text/part0000_split_044.html.d24e8571" class="calibre18">Building Abstract Syntax Trees</h2><p height="10" width="0" class="calibre5">Rather than simply taking what the parser can give us for free (parse
trees), lets take a second to design what we actually want in an
IR. The critter that we end up with is called an <em class="calibre6">abstract
syntax tree</em> (AST).
</p><p height="10" width="0" class="calibre5">To figure out what ASTs should look like, lets start with a list of
design guidelines.  An IR tree should be the following:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Dense</em>: No unnecessary nodes</li><li height="6" class="calibre20"><span></span><em class="calibre6">Convenient</em>: Easy to walk</li><li height="6" class="calibre20"><span></span><em class="calibre6">Meaningful</em>: Emphasize operators, operands, and the
relationship between them rather than artifacts from the grammar</li></ul><p height="10" width="0" class="calibre5">The first two points imply that it should be easy and fast to identify
patterns in the tree. Language applications that use intermediate
trees usually make multiple passes over the trees in order to analyze
or build other data structures.  The structure of intermediate trees
should be brain-dead simple.</p><p height="10" width="0" class="calibre5">The last point implies that the tree structure should be insensitive
to changes in the grammar (at least those unrelated to language
syntax). During development and maintenance, grammars change all
the time. We dont want to let a simple rule name change in the grammar
break other components in our application.</p><p height="10" width="0" class="calibre5">OK, using our design guidelines, lets build a suitable tree structure
for assignment <code class="calibre21">x=0;</code>.  To start, we can strip away the unnecessary
nodes from the parse tree in Figure 8, <a href="#text/part0000_split_043.html.fig.assign"><em class="calibre6">x=0; assignment statement parse tree</em></a>. The <code class="calibre21">;</code> node disappears
because semicolons convey no meaning; they exist only to help the
parser (and us humans) separate statements.</p><p height="10" width="0" class="calibre5">Believe it or not, we can also get rid of the rule nodes. We know that
we fed a statement to the parser so the <em class="calibre6">statement</em> root
node is unnecessary. What about the <em class="calibre6">assignment</em> node,
though?  We can drop this too because we only need to know what kind of statement we fed in, not what the grammar calls it.  The <code class="calibre21">=</code>
operator tells us everything we need to know.  Computers only care
about operators and operands.</p><p height="10" width="0" class="calibre5">By condensing the input to its essential elements, we decouple it from
the original syntax.  So,  for example, assignment syntax boils down to an
assignment operator and two operands.  Decoupling does two things. First, it gets us
closer to the operator-operand model of the CPU.  Second, we can have
different languages share a common intermediate form. Compiler writers
often leverage an existing optimizer and code generator by translating
multiple languages to an established IR.</p><p height="10" width="0" class="calibre5">At this point, weve removed all but three nodes: <code class="calibre21">x</code>, <code class="calibre21">=</code>, and <code class="calibre21">0</code>.
The only thing left to figure out is the relationship between those
nodes.  One thing is certain: We definitely cant get rid of the
two-dimensional structure of the tree. A flat tree is a linked list,
which is essentially just a copy of the input stream.  In that case,
the parser would be throwing away everything it learned about
sentence structure.</p><p height="10" width="0" class="calibre5">The key idea behind AST structure is that tokens representing
operators or operations become subtree roots.  All other tokens become
operands (children of operator nodes). Finally, we arrive at the AST
for <code class="calibre21">x=0;</code>:</p><div class="calibre1"><img id="text/part0000_split_044.html.d24e8648" class="calibre30" src="data:image/gif;base64,R0lGODlhPAAzAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAAA8ADMAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnOhQnMWLFilqVDgOHbt2IEGuG7exZMFx6uDJWykv3jtyJmP+G3fuY8h2I2XGxIhRp8+fQIMKHUq0qNGh4saRI3lQHLly4o4eHIcP3zmEVOGZiyp1oDh08tiVS6guXruxXQUecBcvHdeD5drJU8dU6jh28tbBTCjuQDx497qKS/fuJcNx6+S521tUXDl48NA1dMo2Z1Fy+MLWZYjuXbxzb4OKuyev3QGI4tQpNkd0bbwDoRvGzRtbJ7l28ehKFHcOsmSgg10yjihuHbyXtTWSI2cO8j17yuXiKzdu80Rx5tiqVDd8YjrIfy3+U/w6D0A9eu1Yaywuj555eN2Jo4sHoH7bjbfrv4+P+hx98+zwB1E68tSz30Zf0VfPO6CVRM467tUDH4LnFBgPOslJRI479UgoYEUVziNeSY7Bs+CHk8WFD4q73dMOO9btZg6LE41TzlZp5ajjjjwSRc456JxDo44dteNOO+pk2GM66lB3zzrnxHhAOvf0tQ46MYqmjlszocOdQee8iJI76WQZVDq//VOOWAbx1iQ6ZUo1WJrluINWQdixg2FaaA605p0E0aQOOoA2tqVAHX15kpfkpMMObFKp0yQ5XkaJpzru0JWOS4UORc497ITKpUFPwUTOATgelVQ5rJrZ46sDMQUEADs=" alt="images/IR/assign-ast.png"></div><p height="10" width="0" class="calibre5">Lets examine this AST to see how it fits our design guidelines. There
are no unnecessary nodes; the tree is the smallest possible.  Without
all of those interior rule nodes, walking this AST would be much
faster than walking the parse tree.  Its easy to identify subtrees
because each subtree root uniquely identifies what the subtree does;
in this case, the subtree performs an assignment. Lastly, this AST is
an abstract representation of an assignment. No matter what assignment
looks like in a programming language, we could translate it to this
AST.</p><p height="10" width="0" class="calibre5">Now that weve got the basics down, lets think about the relationship
between subtrees in more complicated trees.</p><h3 class="calibre23">How ASTs Encode Operator Precedence</h3><p height="10" width="0" class="calibre5">There is only one operation in <code class="calibre21">x=0;</code> and, hence, just one subtree in
its AST.  
Assignment <code class="calibre21">x=1+2;</code>, on the other hand, has two operations:
an assignment and an addition. We know that there should be two
subtrees, one for each operation, but we need to figure out how they
fit together.</p><p height="10" width="0" class="calibre5">The answer depends on which operation needs to happen first. The
semantics of assignment dictate that the right-side expression
be evaluated before the assignment. To encode x happens
before y, we make x lower than y in the tree. In this case, we make
the addition subtree a child (an operand) of the assignment subtree:</p><div class="calibre1"><img id="text/part0000_split_044.html.d24e8681" class="calibre30" src="data:image/gif;base64,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" alt="images/IR/assign-ast2.png"></div><p height="10" width="0" class="calibre5">To perform the assignment, we first need the value of the
right child. This mirrors the precedence of the <code class="calibre21">=</code> and <code class="calibre21">+</code> operators
(<code class="calibre21">+</code> has higher precedence).</p><p height="10" width="0" class="calibre5">The same rule applies for operators within the same
expression. Operators with higher precedence appear lower in the
AST. For example, in expression <code class="calibre21">3+4*5</code>, the <code class="calibre21">*</code> operator has higher
precedence than <code class="calibre21">+</code>.  The <code class="calibre21">*</code> subtree is a subtree of the <code class="calibre21">+</code> operator
node.  If we alter the precedence of the operators in the expression
with parentheses, <code class="calibre21">(3+4)*5</code>, the <code class="calibre21">+</code> subtree becomes a child of the
<code class="calibre21">*</code> node.  Here are the two AST representations:
</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">AST for 3+4*5</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">AST for (3+4)*5</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><img id="text/part0000_split_044.html.d24e8745" class="calibre2" src="data:image/gif;base64,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" alt="images/IR/add-mult.png"></div></td><td class="calibre11"><div class="calibre1"><img id="text/part0000_split_044.html.d24e8747" class="calibre2" src="data:image/gif;base64,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" alt="images/IR/mult-add.png"></div></td></tr></tbody></table><h3 id="text/part0000_split_044.html.sec.text-trees" class="calibre23">Representing Trees in Text</h3><p height="10" width="0" class="calibre5">In future chapters, well need a terse, text-based encoding for trees.
To arrive at a suitable notation, lets look at these trees as 
nested function calls:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">add(3, mul(4,5)); // 3+4*5</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">mul(add(3,4), 5); // (3+4)*5</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we move the <code class="calibre21">(</code> to the left of the function name and replace the
function name with the equivalent operator token, we get the following
LISP-inspired notation:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(+ 3 (* 4 5))&nbsp;&nbsp;&nbsp;&nbsp;// 3+4*5</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* (+ 3 4) 5)&nbsp;&nbsp;&nbsp;&nbsp;// (3+4)*5</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Notation <code class="calibre21">(a b c)</code> means <code class="calibre21">a</code> is the root with children <code class="calibre21">b</code> and <code class="calibre21">c</code>.</p><p height="10" width="0" class="calibre5">At this point, we know what to do with language constructs dealing
with operator tokens. Now lets figure out how to create
ASTs for nonexecutable language statements such as variable
declarations.
</p><h3 class="calibre23">Representing Pseudo-operations in ASTs</h3><p height="10" width="0" class="calibre5">Not all programming language constructs map directly to executable code. 
There are even languages without executable statements. For
example, DOT<a id="text/part0000_split_044.html.FNPTR-10" href="#text/part0000_split_051.html.FOOTNOTE-10">[10]</a> is a purely declarative
graphics language. We can only define nodes and the relationship
between nodes. DOT figures out how to draw the diagram.</p><p height="10" width="0" class="calibre5">To represent such language constructs, we have to invent
pseudo-operations.  For example, here is a DOT declaration for a node
labeled <code class="calibre21">car</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node "car" [shape=ellipse, fontsize=14]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because there is no executable operation for this declaration, we can
use the <code class="calibre21">node</code> token as a define node operator. The property
assignments for the declaration are the nodes operands. Each property
assignment is a subtree of the <code class="calibre21">node</code>:</p><div class="calibre1"><img id="text/part0000_split_044.html.d24e8859" class="calibre32" src="data:image/gif;base64,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" alt="images/IR/dot-node.png"></div><p height="10" width="0" class="calibre5">In some cases, there is no reasonable input token to use as a subtree
root. We must invent an 
<em class="calibre6">imaginary token</em>, a token for which
there is no corresponding input token. For example, variable
declarations in languages derived from C usually need an imaginary
token. We can use whatever we want, but something like <code class="calibre21">VARDECL</code> works
well.  The AST for <code class="calibre21">int i;</code> would have <code class="calibre21">VARDECL</code> at the root and
<code class="calibre21">int</code> and <code class="calibre21">i</code> as children. We need something similar for function
declarations, class declarations, formal argument declarations, and so
on.</p><p height="10" width="0" class="calibre5">OK, so now we know what trees look like and how to map input
constructs to AST subtrees.  Lets figure out how to represent ASTs
in memory. After that, we can build some ASTs using an ANTLR grammar.
</p><h3 id="text/part0000_split_044.html.sec.AST-in-Java" class="calibre23">Implementing ASTs in Java</h3><p height="10" width="0" class="calibre5">In our discussion so far, weve never mentioned the data type or types
of the AST nodes.
 Thats because, technically, we  need only one data
type: a generic tree node with a list of children.  What we really
care about is the tree structure (relationships between nodes), not
necessarily the node implementation type(s) themselves. We could use a
single class like the following to represent every node in the tree:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class AST {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// node is derived from which token?</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;List&lt;AST&gt; children; // operands</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public AST(Token token) { this.token = token; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public void addChild(AST t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( children==null ) children = new ArrayList&lt;AST&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.add(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Trees built from a single data type are called 
<em class="calibre6">homogeneous trees</em>.  See Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.  If there is only one data type, you might be
wondering how we can distinguish between an addition and an assignment
node. We can use a nodes token type: <code class="calibre21">t.token.getType()</code> for node
<code class="calibre21">t</code>. Each node stores the token from which we created it.</p><p height="10" width="0" class="calibre5">Because there is only a single type, we can use a 
<em class="calibre6">normalized child list</em> representation: <code class="calibre21">List&lt;AST&gt;</code>. Again, we dont care about
the type of the children, just that they are nodes or subtrees. We
dont even care about naming the fields really. For a <code class="calibre21">+</code> node, we
know that the first child, <code class="calibre21">children[0]</code>,<a id="text/part0000_split_044.html.FNPTR-11" href="#text/part0000_split_051.html.FOOTNOTE-11">[11]</a> is the left operand, and the
second child, <code class="calibre21">children[1]</code>, is the right.</p><p height="10" width="0" class="calibre5">By normalizing the references to the children of every node, its
much easier to provide tree construction and tree-walking support
machinery.  Later in this chapter, for example, well try  some of
ANTLRs cool tree construction facilities. To use them, though, our
trees must have normalized children. In Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>,
well see that its harder to automatically generate tree visitors for
irregular child lists.  Just because we use normalized children,
though, doesnt mean we cant have different node types.</p><p height="10" width="0" class="calibre5">In Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, well discuss annotating trees
with various bits of information. For example, we might want to
annotate expression trees with result types (expression
<code class="calibre21">3+4.0</code> has result type
<code class="calibre21">float</code>).  With homogeneous tree nodes,
however, adding a <code class="calibre21">evalType</code> field means
all nodes (even nonexpression nodes) get the field. We end up
including the union of all fields needed by all nodes in the
homogeneous AST class definition. This costs memory and makes it hard
to figure out which nodes need which fields.</p><p height="10" width="0" class="calibre5">To overcome this weakness, we can build a <em class="calibre6">heterogeneous tree</em>,
where different kinds of nodes have different types. Well explore
heterogeneous tree nodes with normalized children in Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>. But, the core idea is to use the homogeneous <code class="calibre21">AST</code> class as a base class:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> ExprNode <b class="calibre13">extends</b> AST { DataType evalType;  }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AddNode <b class="calibre13">extends</b> ExprNode {  }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> MultNode <b class="calibre13">extends</b> ExprNode {  }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> IntNode <b class="calibre13">extends</b> ExprNode {  }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">One objection to heterogeneous trees with normalized children is that
we have to refer to children by position, not by name. For example, we
say <code class="calibre21">children[0]</code> and <code class="calibre21">children[1]</code>, not, say, <code class="calibre21">left</code> and <code class="calibre21">right</code>.  In
many cases, having irregular, named fields leads to more readable
code. 
We will explore such trees in more detail later (Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>). In
the meantime, here is what <code class="calibre21">ExprNode</code> and <code class="calibre21">AddNode</code> would look
like with irregular children:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> AST {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// missing normalized list of children; subclasses define fields</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> ExprNode <b class="calibre13">extends</b> AST {  }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AddNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ExprNode left, right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// irregular, named fields</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">fields-specific-to-AddNode</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">By using heterogeneous node types, we can also enforce a bit of
structure, as well see next.
</p><h3 id="text/part0000_split_044.html.sec.co-opting-type-system" class="calibre23">Enforcing Tree Structure with the Type System</h3><p height="10" width="0" class="calibre5">We all make mistakes when writing software.  
So, if possible, its a
good idea to write code in such a way that it compiles only when were
doing things properly. To avoid creating improperly structured ASTs,
we can co-opt the implementation languages static type system to
enforce structure. For example, we could make the constructor for
heterogeneous type <code class="calibre21">AddNode</code> take two <code class="calibre21">ExprNode</code>
arguments:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> AddNode(ExprNode left, ExprNode right) {}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The types of the constructors arguments make it very clear that addition only
 works  on expressions. We cant use a statement or declaration as
an addition operand:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Constructor enforces structure using type system</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// COMPILER ERROR: PrintNode is not an ExprNode</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a = <b class="calibre13">new</b> AddNode(<b class="calibre13">new</b> IntNode(1), <b class="calibre13">new</b> PrintNode());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We can enforce many structures easily this way but not all.  The <code class="calibre21">VectorNode</code> is a perfect example. To allow an arbitrary number of vector
elements, we have to pass in a list:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> VectorNode(<b class="calibre13">List</b>&lt;ExprNode&gt; elements) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (ExprNode node : elements) { addChild(node); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Unfortunately, this constructor cannot enforce proper structure.  We
could pass in an empty list, but the grammar requires at least one
vector element.  There is simply no way to specify cardinality (how
many there are) with the type system of commonly used programming
languages.</p><p height="10" width="0" class="calibre5">By relying on the implementation languages type system to
represent structure, the only sure way to determine the exact order
and cardinality of children is to examine how methods use those
children.  The set of valid data structure organizations is therefore
not explicitly described.</p><p height="10" width="0" class="calibre5">Worse, node functionality is spread across multiple node class
definition files. The data structure organization is not encapsulated
into a single description file. In Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>, we see how to formally
and tersely describe the set of possible structures with a single tree
grammar file. Also note that co-opting a static type system to specify
structure is not even an option for dynamically typed languages such
as Ruby and Python.</p><p height="10" width="0" class="calibre5">The best way to create ASTs and to verify their structure is with a
formal mechanism.  In <a href="#text/part0000_split_046.html.sec.ASTs-with-ANTLR"><em class="calibre6">Constructing ASTs with ANTLR Grammars</em></a>, well see
how to create trees explicitly with tree grammar fragments.  Then, in
Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>, well see how to enforce structure and
do pattern matching also with tree grammar fragments. But, first,
lets get a taste of ANTLR to make that discussion clear.
</p>

</div></div>
<div id="text/part0000_split_045.html"><div class="calibre">

<h2 id="text/part0000_split_045.html.sec.antlr.intro" class="calibre18">Quick Introduction to ANTLR</h2><p height="10" width="0" class="calibre5">Once you know how to build lexers and parsers by hand, its a good
idea to use a parser generator to make your life easier. 
This section
gets you started using
ANTLR<a id="text/part0000_split_045.html.FNPTR-12" href="#text/part0000_split_051.html.FOOTNOTE-12">[12]</a> and
its grammar DSL. (You can skip to the next chapter if youre already
familiar with it.) Were going to build a simple grammar, run it
through ANTLR, and write a test rig to exercise the generated lexer
and parser.</p><p height="10" width="0" class="calibre5">Lets build a grammar for a simple graphics DSL with a single
command for drawing lines. Heres how wed draw a box 10 units on a
side:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/antlr/box">parsing/antlr/box</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line from 0,0 to 0,10</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line from 0,10 to 10,10</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line from 10,10 to 10,0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line from 10,0 to 0,0</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The syntax of the DSL is a list of <code class="calibre21">line</code> commands:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/antlr/Graphics.g">parsing/antlr/Graphics.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">grammar</b> Graphics;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">file : command+ ; <em class="calibre6">// a file is a list of commands</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">command : <em class="calibre6">'line'</em> <em class="calibre6">'from'</em> point <em class="calibre6">'to'</em> point ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">point : INT <em class="calibre6">','</em> INT ; <em class="calibre6">// E.g., "0,10"</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">There are three rules: <code class="calibre21">file</code>,
<code class="calibre21">command</code>, and <code class="calibre21">point</code>. The
single-quoted strings are tokens representing the keywords in our
language. The references to <code class="calibre21">INT</code> are references to
integer tokens.  Here are the lexical rules (minus the implicit rules
for matching keywords):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/antlr/Graphics.g">parsing/antlr/Graphics.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">INT : <em class="calibre6">'0'</em>..<em class="calibre6">'9'</em>+ ; <em class="calibre6">// lexer rule to match 1-or-more digits</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Skip whitespace */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">WS : (<em class="calibre6">' '</em> | <em class="calibre6">'\t'</em> | <em class="calibre6">'\r'</em> | <em class="calibre6">'\n'</em>) {skip();} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">WS</code> rule matches whitespace but immediately
throws it away so that the parser doesnt see those characters. That
way, the parser doesnt have to check for whitespace between all 
the rule elements.</p><p height="10" width="0" class="calibre5">Running ANTLR on the grammar gets us the lexer and parser classes:
  <code class="calibre21">Graphics</code><code class="calibre21">Lexer</code> and
<code class="calibre21">GraphicsParser</code>. Make sure 
<code class="calibre21">antlr-3.2.jar</code> from the main code directory is in
your <code class="calibre21">CLASSPATH</code> environment variable and then
say:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Graphics.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">ls</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Graphics.g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GraphicsLexer.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Graphics.tokens&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GraphicsParser.java</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Or, if youd prefer to use the JAR file explicitly, invoke Java
with the following <code class="calibre21">-cp</code> option, assuming
youre in the <code class="calibre21">code/parsing/antlr</code> directory:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java -cp ../../antlr-3.2.jar org.antlr.Tool Graphics.g</b></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The tokens file contains a list of the token types (which we can
ignore it for our purposes here). If you take a look at the generated
parser, youll see that the methods of the class follow Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.</p><p height="10" width="0" class="calibre5">For example, here is the core
of the generated method for rule <code class="calibre21">point</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/antlr/GraphicsParser.java">parsing/antlr/GraphicsParser.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Graphics.g:8:9: INT ',' INT</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(input,INT,FOLLOW_INT_in_point39);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(input,9,FOLLOW_9_in_point41);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(input,INT,FOLLOW_INT_in_point43);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">FOLLOW_INT_in_point37</code> reference is a
set of tokens the generated parser uses to automatically resynchronize
after syntax errors.</p><p height="10" width="0" class="calibre5">To test the parser, we can use the following main program:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/parsing/antlr/Test.java">parsing/antlr/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">void</b> main(<b class="calibre13">String</b><b class="calibre13">[]</b> args) <b class="calibre13">throws</b> Exception {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;CharStream input = null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Pick an input stream (filename from commandline or stdin)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( args.length&gt;0 ) input = <b class="calibre13">new</b> ANTLRFileStream(args[0]);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> input = <b class="calibre13">new</b> ANTLRInputStream(<b class="calibre13">System</b>.in);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Create the lexer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;GraphicsLexer lex = <b class="calibre13">new</b> GraphicsLexer(input);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Create a buffer of tokens between lexer and parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;CommonTokenStream tokens = <b class="calibre13">new</b> CommonTokenStream(lex);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Create the parser, attaching it to the token buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;GraphicsParser p = <b class="calibre13">new</b> GraphicsParser(tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;p.file();&nbsp;&nbsp; <em class="calibre6">// launch parser at rule file</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Since we havent  inserted actions into the grammar to generate
output, running the test rig appears to do nothing. But, if we give
the program erroneous input, it spits out a syntax error:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># or, javac -cp ../../antlr-3.2.jar *.java</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test box&nbsp;&nbsp;&nbsp;&nbsp;</b><em class="calibre6"># or, java&nbsp;&nbsp;-cp .:../../antlr-3.2.jar Test box</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test</b>&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line to 2,3&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 1:5 mismatched input 'to' expecting 'from'</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Using the DSL of a parser generator saves a huge amount of work. We
wrote a 15-line grammar and ANTLR generated more than 500 lines of Java
code for us.  To learn more, you can visit the website or purchase
<a href="#text/part0000_split_135.html.d2381e296"><em class="calibre6">The Definitive ANTLR Reference</em>&nbsp;[Par07]</a>.
In the next section, well see that ANTLR can also help us build
ASTs without resorting to code in a general-purpose programming
language.
</p>

</div></div>
<div id="text/part0000_split_046.html"><div class="calibre">

<h2 id="text/part0000_split_046.html.sec.ASTs-with-ANTLR" class="calibre18">Constructing ASTs with ANTLR Grammars</h2><p height="10" width="0" class="calibre5">To learn about ANTLRs AST construction mechanism, lets build ASTs
for a simple vector math language with addition, multiplication, and
dot product.
</p><p height="10" width="0" class="calibre5">To design our grammar, we need to look at some sample sentences.  Here
are some valid vector math statements:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x = 1+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">y = 1*2+3&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">z = [1, 2] + [3, 4]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a = [1, 2] . [3, 4]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">b = 3 * [1, 2]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print x+2&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At the coarsest level, that looks like a series of assignment and
print statements. We can express that syntax grammatically as follows:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Vec/VecMath.g">IR/Vec/VecMath.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">statlist : stat+ ;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match multiple statements</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat: ID <em class="calibre6">'='</em> expr&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// match an assignment like "x=3+4"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">'print'</em> expr&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match a print statement like "print 4"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Within the statements, we find various math operators (<code class="calibre21">+</code>, <code class="calibre21">*</code>, and
<code class="calibre21">.</code>) and operands (integers, identifiers, and vector literals).</p><p height="10" width="0" class="calibre5">We can
describe these expressions grammatically as follows:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Vec/VecMath.g">IR/Vec/VecMath.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr:&nbsp;&nbsp; multExpr (<em class="calibre6">'+'</em> multExpr)* ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// E.g., "3*4 + 9"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">multExpr: primary ((<em class="calibre6">'*'</em>|<em class="calibre6">'.'</em>) primary)* ; <em class="calibre6">// E.g., "3*4"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// any integer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// any variable name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'['</em> expr (<em class="calibre6">','</em> expr)* <em class="calibre6">']'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// vector literal; E.g. "[1,2,3]"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To build ASTs, weve got two options. We can add actions to the grammar to
manually build trees, or we can use ANTLRs AST construction operators
and rewrite rules.</p><p height="10" width="0" class="calibre5">Building trees by hand is easy but tedious. Here are a few rules
augmented with tree construction actions (code fragments in curly
braces) to give you the flavor:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr returns [AST tr] <em class="calibre6">// expr returns a subtree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; a=multExpr {$tr = $a.tr;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( <em class="calibre6">'+'</em> b=multExpr {$tr = <b class="calibre13">new</b> AddNode($tr, $b.tr);} )*</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primary returns [AST tr]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; INT {$tr = <b class="calibre13">new</b> IntNode($INT.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">AST construction is so important, ANTLR has built-in AST construction
support.  By setting the <code class="calibre21">output</code> option to <code class="calibre21">AST</code>, ANTLR adds a <code class="calibre21">tree</code>
return value to each rule method (like we just did by hand). The tree
return value from the start rule represents the root of the entire
tree created while parsing. ANTLR also injects code to create an AST
node (of type <code class="calibre21">CommonTree</code>) for each input token matched.</p><p height="10" width="0" class="calibre5">Given no instructions to the contrary, ANTLR builds a flat tree (a
linked list) of these nodes. Here is the start of our grammar file
with the <code class="calibre21">output</code> option set (and the definition of an imaginary token
well need after that):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Vec/VecMathAST.g">IR/Vec/VecMathAST.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">grammar</b> VecMathAST;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">options</b> {output=AST;} <em class="calibre6">// we want to create ASTs</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">tokens</b> {VEC;} <em class="calibre6">// define imaginary token for vector literal</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The following rules use ANTLRs AST rewrite notation to specify tree
structure:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Vec/VecMathAST.g">IR/Vec/VecMathAST.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">statlist : stat+ ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// builds list of stat trees</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat: ID <em class="calibre6">'='</em> expr&nbsp;&nbsp;-&gt; ^(<em class="calibre6">'='</em> ID expr)&nbsp;&nbsp;<em class="calibre6">// '=' is operator subtree root</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">'print'</em> expr -&gt; ^(<em class="calibre6">'print'</em> expr) <em class="calibre6">// 'print' is subtree root</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We use notation <code class="calibre21">^(...)</code> for tree patterns
not <code class="calibre21">(...)</code> in order to distinguish them from
grammar subrules. The assignment tree has the same structure weve
used so far with the <code class="calibre21">=</code> operator at the
root.</p><p height="10" width="0" class="calibre5">Aside from its succinctness and expressivity, ANTLRs formal AST
construction mechanism provides another important benefit: this
mechanism is language neutral.  ANTLRs code generator can generate
code in a variety of languages, whereas code blocks we add by hand are
language specific.</p><p height="10" width="0" class="calibre5">Sometimes the rewrite notation is inconvenient, particularly with
expressions. Its easier to tell ANTLR which tokens are operators
using the <code class="calibre21">^</code> suffix operator. All other tokens default to
operands. Here are the expression rules augmented with AST
construction operations (except for the vector literal alternative,
which has a rewrite):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Vec/VecMathAST.g">IR/Vec/VecMathAST.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr:&nbsp;&nbsp; multExpr (<em class="calibre6">'+'</em>^ multExpr)* ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// '+' is root node</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">multExpr: primary ((<em class="calibre6">'*'</em>^|<em class="calibre6">'.'</em>^) primary)* ; <em class="calibre6">// '*', '.' are roots</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; INT&nbsp;&nbsp; <em class="calibre6">// automatically create AST node from INT's text</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// automatically create AST node from ID's text</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'['</em> expr (<em class="calibre6">','</em> expr)* <em class="calibre6">']'</em> -&gt; ^(VEC expr+)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">^(VEC expr+)</code> AST rewrite is
particularly satisfying. It says create a tree with imaginary token
<code class="calibre21">VEC</code> at the root and the list of vector elements as
children.  ANTLR automatically buffers up the trees returned from all
<code class="calibre21">expr</code> invocations.  Referencing
<code class="calibre21">expr+</code> in the tree constructor (tree pattern
to the right of <code class="calibre21">-&gt;</code>) says, Put all 
the <code class="calibre21">expr</code> return values here. To really dive
into AST construction, see Chapter 7 of <a href="#text/part0000_split_135.html.d2381e296"><em class="calibre6">The
Definitive ANTLR Reference</em>&nbsp;[Par07]</a> or the ANTLR tree construction
  documentation.<a id="text/part0000_split_046.html.FNPTR-13" href="#text/part0000_split_051.html.FOOTNOTE-13">[13]</a></p><p height="10" width="0" class="calibre5">By default ANTLR builds homogeneous trees of type <code class="calibre21">CommonTree</code>, but
we can easily tell it to create heterogeneous trees.  We can suffix
any token reference with a fully qualified node class name. For
example, here is the <code class="calibre21">primary</code> rule augmented with heterogeneous node
types:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; INT&lt;IntNode&gt;&nbsp;&nbsp; <em class="calibre6">// create IntNode from INT's text</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID&lt;VarNode&gt;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// create VarNode from ID's text</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'['</em> expr (<em class="calibre6">','</em> expr)* <em class="calibre6">']'</em> -&gt; ^(VEC&lt;VectorNode&gt; expr+)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">ANTLR generates <code class="calibre21">new
IntNode(</code><em class="calibre6">INT-token</em><code class="calibre21">);</code>
from <code class="calibre21">INT&lt;IntNode&gt;</code>. Without the
heterogeneous tree node type, we get
<code class="calibre21">adaptor.create(</code><em class="calibre6">INT-token</em><code class="calibre21">);</code>.
The <code class="calibre21">adaptor</code> is an instance of the
<code class="calibre21">TreeAdaptor</code> interface.  The interface acts, in
part, as a factory, converting tokens to AST nodes.</p><p height="10" width="0" class="calibre5">The AST constructor to build a subtree representing a vector,
<code class="calibre21">^(VEC expr+)</code>, is an example of a tree
pattern. What were really doing here is transforming a linear
sequence of tokens into a two-dimensional AST using a
grammar-to-tree-grammar rewrite.  The key is that we are declaring
what the AST should look like, not how to build it. It is analogous to
using a grammar to specify syntax rather than building a parser.  Well talk more
about this in Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>.
</p><p height="10" width="0" class="calibre5">In this chapter, we looked at two different ways to structure
intermediate representations (parse trees and ASTs) and three
different ways to implement ASTs. Each one is useful in different
circumstances. The following list summarizes all the pros and cons:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>. <em class="calibre6">Pros</em>: Parser
generators can automatically build these for
us. 
<em class="calibre6">Cons</em>: Parse trees are full of noise
(unnecessary nodes). They are sensitive to changes in the grammar
unrelated to syntax. If a parser generator generates heterogeneous
node types, there can be literally hundreds of class
definitions.</li><li height="6" class="calibre20"><span></span>Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>. <em class="calibre6">Pros</em>: Homogeneous trees are very
simple.  
<em class="calibre6">Cons</em>: Its cumbersome to annotate AST nodes
because the single node type has the union of all needed fields. There
is no way to add methods specific to a particular kind of node.</li><li height="6" class="calibre20"><span></span>Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>. <em class="calibre6">Pros</em>: Its easy to add
operator or operand-specific data and
methods. 
<em class="calibre6">Cons</em>: Large grammars like Javas need
about 200 class definitions to be fully heterogeneous. Thats a lot of
files to read and write.</li><li height="6" class="calibre20"><span></span>Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>. <em class="calibre6">Pros</em>: Its easy to add operator- or operand-specific data and methods.  
Sometimes code operating on nodes is more
readable because the children (operands) have names rather than
positions like <code class="calibre21">children[0]</code>. Building tree-walking methods for a
small set of heterogeneous nodes is quick and
easy. <em class="calibre6">Cons</em>: As with Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>, there
are lots of AST classes to read and write. Having irregular
children makes building external visitors difficult.  Most of the time
we have to build tree walkers by hand using Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>.</li></ul><p height="10" width="0" class="calibre5">If youre in doubt about which is best in your situation, choosing
Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a> is a safe bet. That said, I
tend to use Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a> because I care most about tree
structure, not about node types.  If I have to annotate trees, though,
I add some distinct node types, thus moving toward a heterogeneous
tree.</p><p height="10" width="0" class="calibre5">Now that weve got an overall picture of intermediate representations,
lets look at the tree patterns in more detail.  After that, well
tackle tree walking. In future chapters, well make heavy use of tree
walking to extract information and perform computations.</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_047.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_047.html.tip.parse-tree" class="pagebreak2"><small class="calibre35">Pattern 8:</small>&nbsp;&nbsp;&nbsp;Parse Tree</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">A parse tree describes how a parser recognized an input
sentence.</em>
</p><p height="10" width="0" class="calibre5">A parse tree is sometimes called a <em class="calibre6">syntax tree</em>
(as opposed to an abstract syntax tree). Despite not being that useful for building interpreters and translators, Im including this pattern because parse trees are heavily used by
development environments and text rewriting systems.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Parse trees record the sequence of rules a parser applies as well
as the tokens it matches.  Interior parse tree nodes represent rule
applications, and leaf nodes represent token matches.  Parse trees
describe sentence structure by grouping input symbols into
subtrees. Subtrees represent the structure of phrases (sentence
fragments). For example, the following parse tree clearly identifies
the parts of speech in sentence the cat runs quickly:</p><div class="calibre1"><img id="text/part0000_split_047.html.d24e10173" class="calibre30" src="data:image/gif;base64,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" alt="images/IR/catrunsquickly.png"></div><p height="10" width="0" class="calibre5">By successfully applying a rule to a phrase, the parser identifies the
role it plays in the sentence.  So, for example, the parse tree
identifies cat as a noun and the cat as the sentence subject.</p><p height="10" width="0" class="calibre5">Parse trees are specific to a grammar. Here is the core of the
grammar for that parse tree:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">grammar</b> English;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">sentence : subject predicate ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">subject : article? noun ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">predicate : verb adverb? ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The interior nodes of computer language parse trees also name language
substructures.  For example, we can see the parse
tree for <code class="calibre21">5*[1,2]</code> in a vector math language in Figure 9, <a href="#text/part0000_split_047.html.fig.vecmult-parsetree"><em class="calibre6">Parse tree for 5*[1,2]</em></a>.</p><div class="calibre1" id="text/part0000_split_047.html.fig.vecmult-parsetree"><img id="text/part0000_split_047.html.d24e10204" class="calibre30" src="data:image/gif;base64,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" alt="images/IR/vecmult.png"><hr class="calibre17"><b class="calibre13">Figure 9. Parse tree for <code class="calibre21">5*[1,2]</code></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Parse trees are really easy to build by hand and are so regular that
tools like ANTLR can automate the process for us. Thats the good
news. The bad news is that parse trees are extremely inconvenient to
walk and transform.  Parse trees are full of noise because of all the
interior rule nodes. They are also very sensitive to changes in the
grammar.  For comparison, Figure 10, <a href="#text/part0000_split_047.html.fig.vecmult-ast"><em class="calibre6">A more appropriate AST structure</em></a> shows a more appropriate AST structure.</p><div class="calibre1" id="text/part0000_split_047.html.fig.vecmult-ast"><img id="text/part0000_split_047.html.d24e10212" class="calibre30" src="data:image/gif;base64,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" alt="images/IR/vecmult-ast.png"><hr class="calibre17"><b class="calibre13">Figure 10. A more appropriate AST structure</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">An AST captures just the essential information from the input: all of
the input tokens and the appropriate structure. The interior nodes are
operators or operations rather than rule names.</p><p height="10" width="0" class="calibre5">Nonetheless, parse trees are still very useful as intermediate representations
for some tools and applications.  For example, development
environments use parse trees to good effect for syntax highlighting
and error-checking. A number of text rewriting systems and pretty
printing tools also use parse trees as intermediate representations.
For these tools, it makes sense because we want to express
transformations in the concrete syntax of the language. We want to
name the parts of speech when we transform. For example, informally we
might say, When you see an assignment, replace <code class="calibre21">=</code> with <code class="calibre21">:=</code>. Or,
in English, Find all adjectives within sentence subjects. We can
refer to parts of speech by using rule names from the grammar if we
use parse trees.</p><p height="10" width="0" class="calibre5">Parse trees mirror the function call graphs of a recursive-descent
parser, which leads us directly to a construction mechanism.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">To construct parse trees, we have to add a new interior node to the
tree every time we enter a rule. Heres a template for a parser rule
method:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void <em class="calibre6">rule</em>() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;RuleNode r = new RuleNode("<em class="calibre6">rule</em>");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( root==null ) root = r;&nbsp;&nbsp; // we're the start rule</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else currentNode.addChild(r); // add this rule to current node</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ParseTree _save = currentNode;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;currentNode = r;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "descend" into this rule</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">normal-rule-code</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;currentNode = _save;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// restore node to previous value</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We also need to track the overall root of the parse tree and
the current node:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class MyParser extends Parser {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ParseTree root;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// root of the parse tree</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ParseTree currentNode;&nbsp;&nbsp; // the current node we're adding children to</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public void match(int x) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // override default behavior</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentNode.addChild(LT(1)); // add current lookahead token node</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.match(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// match as usual</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">rule-methods</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We override method <tt class="calibre21">match</tt> to make it add token leaf nodes as it
consumes tokens.  The core parsing machinery remains unchanged.</p><p height="10" width="0" class="calibre5">As far as the trees themselves, here is a generic parse tree node:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/ParseTree.java">IR/ParseTree.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">import</b> java.util.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Nodes are instances of this class; there's no Node class per se</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> ParseTree {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">List</b>&lt;ParseTree&gt; children; <em class="calibre6">// normalized child list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> RuleNode addChild(<b class="calibre13">String</b> value) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RuleNode r = <b class="calibre13">new</b> RuleNode(value);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild(r);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> r;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> TokenNode addChild(Token value) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TokenNode t = <b class="calibre13">new</b> TokenNode(value);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> t;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> addChild(ParseTree t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( children==null ) children = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;ParseTree&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.add(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You can take a look at its subclasses, <code class="calibre21">TokenNode</code> and <code class="calibre21">RuleNode</code>,
in the sample code.  Theres not that much to building parse trees.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_048.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_048.html.tip.homo" class="pagebreak2"><small class="calibre35">Pattern 9:</small>&nbsp;&nbsp;&nbsp;Homogeneous AST</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">A homogeneous tree implements an abstract syntax tree (AST)
using a single node data type and a normalized child list
representation.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The key idea behind an AST is the operator-operand tree structure, not
the node data type.  The node data type is really just how we
implement ASTs.  An AST contains the essence of the input token stream
and the relationships between operator and operand tokens.</p><p height="10" width="0" class="calibre5">We dont need to use the type system of our
implementation language to distinguish between
nodes.  Nodes in any AST derive from tokens, so we can use the token
type to identify nodes.  In fact, homogeneous ASTs are the only
convenient choice for non-object-oriented languages like C.  To
implement Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>, for example, C would have to
cut and paste or manually include a reference to the normalized children definition into each node
<code class="calibre21">struct</code> definition.</p><p height="10" width="0" class="calibre5">Homogeneous ASTs necessarily use a normalized child representation:
<code class="calibre21">List&lt;AST&gt;</code>. This makes it particularly easy to build external
visitors (Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>), which rely on a uniform child list for
walking.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">A homogeneous AST has two key fields: the token from which it was
created and a list of children:

</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Homo/AST.java">IR/Homo/AST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AST {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Homogeneous AST node type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// From which token did we create node?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;AST&gt; children; <em class="calibre6">// normalized list of children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AST()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ; } <em class="calibre6">// for making nil-rooted nodes</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AST(Token token)&nbsp;&nbsp; { this.token = token; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** Create node from token type; used mainly for imaginary tokens */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AST(<b class="calibre13">int</b> tokenType) { this.token = <b class="calibre13">new</b> Token(tokenType); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** External visitors execute the same action for all nodes</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;with same node type while walking. */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">int</b> getNodeType() { <b class="calibre13">return</b> token.type; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> addChild(AST t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( children==null ) children = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;AST&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children.add(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">boolean</b> isNil() { <b class="calibre13">return</b> token==null; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">isNil</tt> method helps us represent flat
lists.  A list is a subtree without a root, which we can simulate with
a nil root node. A nil node is a node with
<code class="calibre21">token==null</code>.</p><p height="10" width="0" class="calibre5">To print out a tree using a text-based encoding (see <a href="#text/part0000_split_044.html.sec.text-trees"><em class="calibre6">Representing Trees in Text</em></a>), we need a recursive <tt class="calibre21">toStringTree</tt> method. This
leaves <tt class="calibre21">toString</tt> to convert a single node to text.  The following <tt class="calibre21">toStringTree</tt> generates strings of the following form: <code class="calibre21">(root child1 child2 ...)</code>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Homo/AST.java">IR/Homo/AST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Compute string for single node */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">String</b> toString() { <b class="calibre13">return</b> token!=null?token.toString():<em class="calibre6">"nil"</em>; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Compute string for a whole tree not just a node */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">String</b> toStringTree() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( children==null || children.size()==0 ) <b class="calibre13">return</b> this.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">StringBuilder</b> buf = <b class="calibre13">new</b> <b class="calibre13">StringBuilder</b>();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !isNil() ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">"("</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(this.toString());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">' '</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (<b class="calibre13">int</b> i = 0; i &lt; children.size(); i++) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AST t = (AST)children.get(i); <em class="calibre6">// normalized (unnamed) children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( i&gt;0 ) buf.append(<em class="calibre6">' '</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(t.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !isNil() ) buf.append(<em class="calibre6">")"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> buf.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The following test code creates and prints the AST for <code class="calibre21">1+2</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Homo/Test.java">IR/Homo/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token plus = <b class="calibre13">new</b> Token(Token.PLUS,<em class="calibre6">"+"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token one = <b class="calibre13">new</b> Token(Token.INT,<em class="calibre6">"1"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token two = <b class="calibre13">new</b> Token(Token.INT,<em class="calibre6">"2"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">AST root = <b class="calibre13">new</b> AST(plus);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">root.addChild(<b class="calibre13">new</b> AST(one));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">root.addChild(<b class="calibre13">new</b> AST(two));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"1+2 tree: "</em>+root.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">AST list = <b class="calibre13">new</b> AST(); <em class="calibre6">// make nil node as root for a list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list.addChild(<b class="calibre13">new</b> AST(one));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">list.addChild(<b class="calibre13">new</b> AST(two));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"1 and 2 in list: "</em>+list.toStringTree());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Here is a sample session:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test</b>&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1+2 tree: (+ 1 2)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1 and 2 in list: 1 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The next pattern, Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>, is an extension to this
pattern that allows multiple node types while retaining the normalized
child list.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a> uses normalized lists of children as well but allows nodes to have different class types.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_049.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_049.html.tip.hetero-normalized" class="pagebreak2"><small class="calibre35">Pattern 10:</small>&nbsp;&nbsp;&nbsp;Normalized Heterogeneous AST</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern implements an abstract syntax tree (AST) using
more than a single node data type but with a normalized child list
representation.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">This pattern is a variation on Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.  All were doing differently
is distinguishing between nodes with our implementation languages
type system. Because this pattern also uses a normalized child list,
we can derive heterogeneous nodes using <code class="calibre21">AST</code> from Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a> as a
base class.</p><p height="10" width="0" class="calibre5">This pattern makes the most sense when we need to store node-specific
data and plan on using Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>. The normalized child list makes
it much easier to build external visitors.  If you need lots of
node-specific methods or plan on using Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>, use Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a> instead. (An embedded walker has walking methods distributed across the heterogeneous node type definitions.)</p><p height="10" width="0" class="calibre5">Lets flesh out some of the heterogenous node details from <a href="#text/part0000_split_044.html.sec.AST-in-Java"><em class="calibre6">Implementing ASTs in Java</em></a>.  We added a field, <code class="calibre21">evalType</code>, to track expression type
information (see also Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>). <code class="calibre21">evalType</code> tracks the
type of the value computed by the expression. For example, the type of
<code class="calibre21">1+2</code> is integer. We can put this field into an abstract class:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Normalized/ExprNode.java">IR/Normalized/ExprNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> ExprNode <b class="calibre13">extends</b> AST {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tINVALID = 0; <em class="calibre6">// invalid expression type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tINTEGER = 1; <em class="calibre6">// integer expression type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tVECTOR = 2;&nbsp;&nbsp;<em class="calibre6">// vector expression type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** Track expression type (integer or vector) for each expr node.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;This is the type of the associated value not the getNodeType()</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;used by an external visitor to distinguish between nodes. */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">int</b> getEvalType() { <b class="calibre13">return</b> evalType; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> ExprNode(Token payload) { super(payload); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** ExprNode's know about the type of an expresson, include that */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( evalType != tINVALID ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> super.toString()+<em class="calibre6">"&lt;type="</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (evalType == tINTEGER ? <em class="calibre6">"tINTEGER"</em> : <em class="calibre6">"tVECTOR"</em>)+<em class="calibre6">"&gt;"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> super.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rather than creating a generic node and then adding children to
form a <code class="calibre21">+</code> (addition) subtree, we can use
<code class="calibre21">AddNode</code>s constructor:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Normalized/AddNode.java">IR/Normalized/AddNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AddNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AddNode(ExprNode left, Token addToken, ExprNode right) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(addToken);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild(left);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addChild(right);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">int</b> getEvalType() { <em class="calibre6">// ...</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Note that its still a good idea to track the <code class="calibre21">+</code> token in the AST
node. This helps with a number of things including producing better
error messages.</p><p height="10" width="0" class="calibre5">Operand node types for integer and vector literals are straightforward
subclasses of <code class="calibre21">ExprNode</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Normalized/IntNode.java">IR/Normalized/IntNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> IntNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> IntNode(Token t) { super(t); evalType = tINTEGER; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Normalized/VectorNode.java">IR/Normalized/VectorNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">import</b> java.util.List;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> VectorNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VectorNode(Token t, <b class="calibre13">List</b>&lt;ExprNode&gt; elements) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(t); <em class="calibre6">// track vector token; likely to be imaginary token</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalType = tVECTOR;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (ExprNode e : elements) { addChild(e); } <em class="calibre6">// add as kids</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The following test code creates and prints an AST for <code class="calibre21">1+2</code>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Normalized/Test.java">IR/Normalized/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token plus = <b class="calibre13">new</b> Token(Token.PLUS,<em class="calibre6">"+"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token one = <b class="calibre13">new</b> Token(Token.INT,<em class="calibre6">"1"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Token two = <b class="calibre13">new</b> Token(Token.INT,<em class="calibre6">"2"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ExprNode root = <b class="calibre13">new</b> AddNode(<b class="calibre13">new</b> IntNode(one), plus, <b class="calibre13">new</b> IntNode(two));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(root.toStringTree());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Here is a sample session:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test</b>&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(+ 1&lt;type=tINTEGER&gt; 2&lt;type=tINTEGER&gt;)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The serialized tree output indicates that the <code class="calibre21">1</code> and <code class="calibre21">2</code> children
have type <code class="calibre21">tINTEGER</code>. Naturally, the result of the addition operation
is also an integer, so the root should have type <code class="calibre21">tINTEGER</code>. In Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, well figure out how to do this computation properly. Well
leave it blank for now.</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern defines node types that subclass <code class="calibre21">AST</code> from Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.
The next pattern, Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>, uses an irregular child list rather
than a normalized list like this pattern.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_050.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_050.html.tip.hetero" class="pagebreak2"><small class="calibre35">Pattern 11:</small>&nbsp;&nbsp;&nbsp;Irregular Heterogeneous AST</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern implements an abstract syntax tree (AST) using
more than a single node data type and with an irregular child list
representation.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">This pattern only differs from Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>
 in the implementation of its child pointers. Instead of a uniform
list of children, each node data type has specific (named) child
fields. In this sense, the child pointers are irregular. In some
cases, named fields lead to more readable code. For example, methods
can refer to <code class="calibre21">left</code> and
<code class="calibre21">right</code> instead of, say,
<code class="calibre21">children[0]</code> and
<code class="calibre21">children[1]</code>.</p><p height="10" width="0" class="calibre5">When building trees from scratch, most programmers follow this
pattern. Its very natural to name the fields of a class, in this case
naming the children of a node.  The big downside to using nodes with
irregular children is that its much less convenient to build tree
walkers (such as Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>).  This pattern is fine
for small projects where the extra gain in readability is worth
the small bit of extra work to implement visitors. Larger projects
tend to do so much tree walking, though, that the irregular children
prove to be a big hassle.</p><p height="10" width="0" class="calibre5">To see where the pain comes from, look again at the
<tt class="calibre21">toStringTree</tt> tree printing method shown in
Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.  Because the children of each node look
the same, a single <tt class="calibre21">toStringTree</tt> works for all
nodes.  With irregular children, each node has to have its own
<tt class="calibre21">toStringTree</tt>.  There is no way to access a
nodes children generically. That means duplicating essentially the
same logic just to use different field names.  In the source code
directory, youll see that both <code class="calibre21">ListNode.java</code> and
<code class="calibre21">AddNode.java</code> have node-specific
<tt class="calibre21">toStringTree</tt> implementations.</p><p height="10" width="0" class="calibre5">Since each node defines its own child fields, the abstract base class
<code class="calibre21">HeteroAST</code> doesnt have a normalized list of children:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Hetero/HeteroAST.java">IR/Hetero/HeteroAST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> HeteroAST {&nbsp;&nbsp; <em class="calibre6">// Heterogeneous AST node type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Node created from which token?</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Node type <code class="calibre21">AddNode</code> is a typical irregular heterogeneous AST
implementation. It has specific named child fields and node-specific
methods.  In this case, there is a method for printing out the tree
structure:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/IR/Hetero/AddNode.java">IR/Hetero/AddNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AddNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ExprNode left, right; <em class="calibre6">// named, node-specific, irregular children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AddNode(ExprNode left, Token addToken, ExprNode right) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(addToken);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.left = left;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.right = right;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toStringTree() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( left==null || right==null ) <b class="calibre13">return</b> this.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">StringBuilder</b> buf = <b class="calibre13">new</b> <b class="calibre13">StringBuilder</b>();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">"("</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(this.toString());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">' '</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(left.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">' '</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(right.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(<em class="calibre6">")"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> buf.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The other node type definitions are available in the source
directory; they differ only in the child field definitions.  There is
also a test file in <code class="calibre21">Test.java</code>.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">See Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a>.
</p>

</div></div>
<div id="text/part0000_split_051.html"><div class="calibre">

<h2 id="text/part0000_split_051.html.d24e11507" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">This completes the last tree construction pattern. The next chapter
explores how to build tree walkers for these data structures.</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_051.html.FOOTNOTE-9" href="#text/part0000_split_043.html.FNPTR-9">[9]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">To a Middle English speaker (the language of
Geoffrey Chaucer), however, this might sound more normal, as the
main verb could appear at the end of the sentence.  We still have some vestiges of this
in sentences like something wicked this way comes
and with this ring I thee wed.</p></dd>
<dt class="calibre28"><a id="text/part0000_split_051.html.FOOTNOTE-10" href="#text/part0000_split_044.html.FNPTR-10">[10]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.graphviz.org">http://www.graphviz.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_051.html.FOOTNOTE-11" href="#text/part0000_split_044.html.FNPTR-11">[11]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">The reader will
forgive me for using <code class="calibre21">children[i]</code> instead of <code class="calibre21">children.get(i)</code>
everywhere for clarity.</p></dd>
<dt class="calibre28"><a id="text/part0000_split_051.html.FOOTNOTE-12" href="#text/part0000_split_045.html.FNPTR-12">[12]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org">http://www.antlr.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_051.html.FOOTNOTE-13" href="#text/part0000_split_046.html.FNPTR-13">[13]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/ANTLR3/Tree+construction">http://www.antlr.org/wiki/display/ANTLR3/Tree+construction</a></p></dd></dl><div class="calibre3" id="text/part0000_split_051.html.calibre_pb_72"></div>

</div></div>
<div id="text/part0000_split_052.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_052.html.calibre_pb_73">&nbsp;</p><a id="text/part0000_split_052.html.toc-11"></a><h4 class="right2" id="text/part0000_split_052.html.chp.walking">Chapter 5</h4>
</div></div>
<div id="text/part0000_split_053.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_053.html.calibre_pb_74">Walking and Rewriting Trees</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">In the previous chapter, we learned how to build ASTs, and in the
following chapters, well start extracting information from
them. 
Were even going to restructure the trees
for simplification and translation purposes. For example, we might want
to simplify <code class="calibre21">x+0</code> to <code class="calibre21">x</code> or translate <code class="calibre21">x==y</code> to <code class="calibre21">strcmp(x,y)</code>. To
support such data extraction and rewriting operations, well need
to know about tree walking. Tree walking is one of the key processes
going on in a large language application.</p><p height="10" width="0" class="calibre5">At first glance, tree walking seems like no big deal. Many of us
learned to write simple recursive functions to walk trees fairly early
in our programming careers. In real applications, though, tree walking
gets surprisingly complicated. There are a number of different
variations, sometimes even within the same application.</p><p height="10" width="0" class="calibre5">The variation
we choose depends on whether we have the source code for our tree
nodes, whether the trees have normalized children, whether the trees
are homogeneous or heterogeneous, whether we need to rewrite trees
while walking, and even in which order we need to walk the nodes.  In
this chapter, were going to explore the four key tree-walking
patterns suitable for most language applications:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>. 
Heterogeneous AST node classes define walking
methods that execute appropriate actions and walk any children. Tree
walking code is distributed across potentially hundreds of class
files. This is the simplest pattern but the least flexible.</li><li height="6" class="calibre20"><span></span>Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>. 
This pattern encapsulates tree
walking code (for both homogeneous and heterogeneous ASTs) into a
single class definition.  It allows us to alter tree-walking behavior
without altering AST node definitions.  Both the visitor and embedded
walker pattern are straightforward but tedious to implement
manually.</li><li height="6" class="calibre20"><span></span>Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>. 
A tree grammar describes the structure of valid
ASTs. Just as we can automate parser construction from grammars, we
can automate tree visitor construction from tree grammars. Tree
grammars work on homogeneous or heterogeneous trees because they rely
on node token types rather than node types (like <code class="calibre21">AddNode</code>). Tree grammars explicitly dictate node visitation order like
the embedded walker and visitor patterns.</li><li height="6" class="calibre20"><span></span>Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>. 
Instead of specifying an entire tree
grammar, this pattern lets us focus on just those subtrees we care
about. Thats useful because different phases of an application care
about different parts of the tree.  A tree pattern matcher also
decouples the order in which we apply tree patterns from the tree
patterns themselves.  Unlike embedded walkers, visitors, and tree
grammars, tree patterns dont specify how to walk the tree.  The
pattern matching engine dictates the tree traversal strategy.  In its
simplest form, a pattern matcher repeatedly tries to match patterns
against subtrees. When it finds a match, the pattern matcher triggers
an action or tree rewrite.</li></ul><p height="10" width="0" class="calibre5">To decide between these design patterns, we need to know
how each one works and know their strengths and weaknesses. So, before
getting into the patterns themselves, we should take a quick tour of
tree walking.  Its instructive to see how the weakness of one pattern
inspires the development of another. Lets start our tree walking
adventure by figuring out the difference between walking and visiting
a tree.</p>

</div></div>
<div id="text/part0000_split_054.html"><div class="calibre">

<h2 id="text/part0000_split_054.html.d24e11599" class="calibre18">Walking Trees and Visitation Order</h2><p height="10" width="0" class="calibre5">When we talk about 
<em class="calibre6">visiting</em> a tree, we mean
executing some actions on the nodes of a tree.  The order in which we
traverse the nodes is important because that affects the order in
which we execute the actions.  There are three key traversals:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Preorder traversal</em> or <em class="calibre6">top-down
traversal</em>: <code class="calibre21">+ 1 2</code>.  
Visit a
(parent) node before visiting its children.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Inorder traversal</em>: 
<code class="calibre21">1 +
2</code>. Visit a node in between visiting children.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Postorder traversal</em> or <em class="calibre6">bottom-up
traversal</em>: 
<code class="calibre21">1 2 +</code>. Visit a node
after visiting its children.</li></ul><p height="10" width="0" class="calibre5">Humans can pick out tree traversals by looking at a tree and,
perhaps, tapping a pen on the nodes in a particular sequence.  To
implement this in code, we typically use a tree-walking algorithm
called <em class="calibre6">depth-first search</em>.  A depth-first search
starts at the root of a tree or subtree and then recursively walks the
children in order.</p><p height="10" width="0" class="calibre5">When a tree walk reaches node <em class="calibre6">t</em>, we say that it <em class="calibre6">discovers</em> that node. In other words, we discover
<em class="calibre6">t</em> when execution of our
<tt class="calibre21">walk</tt> method begins on node
<em class="calibre6">t</em>.  When <tt class="calibre21">walk</tt> finishes
processing <em class="calibre6">t</em> and returns, we say that it has 
<em class="calibre6">finished</em> with <em class="calibre6">t</em>.</p><p height="10" width="0" class="calibre5">Visiting a node means to execute an action somewhere
between discovering and finishing that node.  A particular tree-walking mechanism, such as depth-first search, has a fixed node
discovery sequence. But, that same discovery sequence can generate
three different tree traversals (node visitation sequences). It all
depends on where we put actions in <tt class="calibre21">walk</tt>.</p><p height="10" width="0" class="calibre5">Lets look at a simple example to see the difference between
walking and visiting.  With Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>, we can build
a tree structure to represent integer addition using classes
<code class="calibre21">AddNode</code> and <code class="calibre21">IntNode</code>.</p><p height="10" width="0" class="calibre5">
For example, heres the AST for <code class="calibre21">1+2</code>:</p><div class="calibre1"><img id="text/part0000_split_054.html.d24e11748" class="calibre2" src="data:image/gif;base64,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" alt="images/walking/add12.png"></div><p height="10" width="0" class="calibre5">In code, wed have an abstract class,
<code class="calibre21">ExprNode</code>, that represents a generic tree node
type and a tree-walking method:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Abstract class for heterogeneous AST with irregular children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;(each node defines their child fields) */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// AST nodes are based on tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> walk(); <em class="calibre6">// a basic walk operation</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We only have  two concrete expression node types in this case: <code class="calibre21">IntNode</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> IntNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> walk() { ; } <em class="calibre6">// no children; nothing to do</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">and <code class="calibre21">AddNode</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AddNode <b class="calibre13">extends</b> ExprNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ExprNode left, right; <em class="calibre6">// named, node-specific, irregular children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> walk() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left.walk();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// walk the left operand subtree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right.walk();&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// walk the right operand subtree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Invoking <tt class="calibre21">walk</tt> on the
<code class="calibre21">+</code> root node executes
<code class="calibre21">AddNode</code>.<tt class="calibre21">walk</tt>. This
method then invokes <tt class="calibre21">walk</tt> on each integer
operand (executing
<code class="calibre21">IntNode</code>.<tt class="calibre21">walk</tt>) from
left to right.  We discover nodes in this order: <code class="calibre21">+ 1
2</code>, which corresponds to a preorder traversal.</p><div class="calibre1" id="text/part0000_split_054.html.fig.traversal-order"><img id="text/part0000_split_054.html.d24e11891" class="calibre34" src="data:image/gif;base64,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" alt="images/walking/traversal-order.png"><hr class="calibre17"><b class="calibre13">Figure 11. Tree Node Discovery vs. Traversal Order</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Lets analyze how <tt class="calibre21">walk</tt> discovers nodes in
a slightly larger tree. The AST for expression
<code class="calibre21">1+2+3</code> appears in the left tree in Figure 11, <a href="#text/part0000_split_054.html.fig.traversal-order"><em class="calibre6">Tree Node Discovery vs. Traversal Order</em></a>, with a dashed line showing
<tt class="calibre21">walk</tt>s depth-first search path.</p><p height="10" width="0" class="calibre5">The <tt class="calibre21">walk</tt> method starts at the root of a
tree and then recursively walks its children in order. So,
<tt class="calibre21">walk</tt> discovers the root and then descends
into the children. It discovers the left child (the
<code class="calibre21">+</code> subtree) before discovering the right child
(node <code class="calibre21">3</code>).  On the way down, it discovers
nodes, and on the way up it finishes nodes.
<tt class="calibre21">walk</tt> discovers and immediately finishes leaf
nodes.</p><p height="10" width="0" class="calibre5">If we look closely at the dashed line, the depth-first search
provides multiple opportunities per node to execute actions. The right
tree (in Figure 11, <a href="#text/part0000_split_054.html.fig.traversal-order"><em class="calibre6">Tree Node Discovery vs. Traversal Order</em></a>) indicates those
locations with stars. We can execute an action upon discovery (the
star to the left of the <code class="calibre21">+</code> nodes), in between
child discovery (the star below), or upon finishing (the star to the
right). For leaf nodes, there is only one action execution
opportunity.  The complete discovery sequence is <code class="calibre21">+ + 1 2
3</code>, which corresponds to a preorder traversal. The
finishing sequence is <code class="calibre21">1 2 + 3 +</code>, which
corresponds to a postorder traversal.  Executing actions in between
child discovery corresponds to an inorder traversal: <code class="calibre21">1 + 2
+ 3</code>.</p><p height="10" width="0" class="calibre5">To obtain a different traversal, wed alter
<code class="calibre21">AddNode</code>.<tt class="calibre21">walk</tt> to
execute actions before, during, or after walking its children
(depending on the application, we might do one, two, or all
actions):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> walk() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">preorder-action</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;left.walk();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">inorder-action</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;right.walk();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">postorder-action</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For example, to print nodes out in postorder, wed add a print
statement at the end of <code class="calibre21">AddNode</code>s <tt class="calibre21">walk</tt>.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> walk() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;left.walk();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;right.walk();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(token); <em class="calibre6">// print "+" token</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">And then wed add a print statement in <code class="calibre21">IntNode</code> (which has only one
opportunity to execute an action since it has no children):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> walk() { <b class="calibre13">System</b>.out.println(token); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Tree-walking mechanisms such as this that embed walking code in each
heterogeneous node follow Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>. 
The beauty of the
embedded walker is its simplicity: its pretty obvious whats going
on.</p><p height="10" width="0" class="calibre5">Unfortunately, there are a number of disadvantages.  For one, the
walking code is distributed across potentially hundreds of node class
definition files.  That makes it hard to get a feel for the overall
tree structure.  The main problem, though, is that we cant alter our
walking algorithm or add new walking tasks without modifying the node
classes.  We might not even have the source code for the nodes.  Lack
of source makes adding new embedded walking methods impossible for
most programming languages. A better way is to collect all walking
methods into a separate specification, one that is external to the
tree classes.
</p>

</div></div>
<div id="text/part0000_split_055.html"><div class="calibre">

<h2 id="text/part0000_split_055.html.d24e12066" class="calibre18">Encapsulating Node Visitation Code</h2><p height="10" width="0" class="calibre5">By collecting all of the tree walking methods from 
Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a> into a single class definition, we arrive at Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>. 
Our primary goal is to separate our tree-walking code from
our tree node definitions.  The key advantage of a visitor is that
its external to the objects it walks.</p><p height="10" width="0" class="calibre5">There are a number of ways to achieve this separation, depending on
the programming language we use. Languages such as Ruby and Python
make short work of the visitor pattern because they can add methods at
run-time. Static languages like Java and C++ require some gymnastics.</p><p height="10" width="0" class="calibre5">The first, and most common solution for Java, is to leave a general <tt class="calibre21">visit</tt> method in each heterogeneous node definition. But, again, this
requires modification of the source code, which we might not
have. Take a look at the sample code in the Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a> for a
complete example.</p><p height="10" width="0" class="calibre5">A better solution involves a completely independent visitor that never
has to touch the node class definitions. For example, imagine we
want to mimic the postorder print actions we saw in the previous
section. We could combine the <tt class="calibre21">walk</tt> methods from <code class="calibre21">AddNode</code> and <code class="calibre21">IntNode</code> into a single class with a dispatcher method:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Completely encapsulated and independent node visitor */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> IndependentPostOrderPrintVisitor {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** visitor dispatcher according to argument type */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> print(ExprNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( n.getClass() == AddNode.class ) print((AddNode)n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( n.getClass() == IntNode.class ) print((IntNode)n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <em class="calibre6">error-unhandled-node-type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> print(AddNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(n.left);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// visit left child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(n.right);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// visit right child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(n.token); <em class="calibre6">// action in postorder position</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> print(IntNode n) { <b class="calibre13">System</b>.out.print(n.token); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">print</tt> dispatcher method figures out which overloaded method to
call according to the run-time argument type (either <code class="calibre21">AddNode</code> or <code class="calibre21">IntNode</code>). Such a dispatcher method fakes method argument type
polymorphism in Java.  Its what gives the visitor its independence
from the node class definition files. For a large number of node
classes, the <code class="calibre21">if</code>-<code class="calibre21">then</code>-<code class="calibre21">else</code> chain would be pretty inefficient,
though. Its more efficient to have the dispatcher switch on the
nodes token type.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> print(ExprNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">switch</b> ( n.token.type ) { <em class="calibre6">// switch on token type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.PLUS : print((AddNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.INT&nbsp;&nbsp;: print((IntNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">default</b> : <em class="calibre6">error-unhandled-node-type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This visitor pattern is an improvement over the embedded walker, but
it too has weaknesses. First, it cries out for some kind of
automation. Writing the dispatcher method by hand is tedious. Also,
many of the <tt class="calibre21">print</tt> methods (for example, all binary operators)
are similar or identical.  That is just asking for a cut-and-paste
error. Fortunately, we can solve this problem by using a Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>, as well see in the next section.</p><p height="10" width="0" class="calibre5">The second weakness is more serious.  The mechanisms weve described
so far execute actions when they see a node of a particular type. In
practice, we need to match subtree patterns, not just single node
types. We rarely want to match any old <code class="calibre21">ID</code> node.  Usually we want to
match <code class="calibre21">ID</code> nodes that are assignment left sides or that are
names in method definition subtrees.  Writing tree pattern matching
code by hand is error prone and unpleasant. The good news is that tree
grammars make this easier too.
</p>

</div></div>
<div id="text/part0000_split_056.html"><div class="calibre">

<h2 id="text/part0000_split_056.html.sec.generating-visitors" class="calibre18">Automatically Generating Visitors from Grammars</h2><p height="10" width="0" class="calibre5">Rather than writing parsers by hand, we write grammars and have a
parser generator like ANTLR generate parsers automatically for us. Similarly, ANTLR can automatically generate tree visitors from tree
grammars.  Thats great because we get to express ourselves in a DSL
designed to describe trees.  We tell ANTLR <em class="calibre6">what</em> the trees
look like, and it figures out <em class="calibre6">how</em> to walk them.  The only
wrinkle is describing a two-dimensional tree structure with a grammar.</p><p height="10" width="0" class="calibre5">To parse a two-dimensional structure, we have to serialize the tree to
a one-dimensional list of nodes. Then we can use a conventional
parser.  To serialize, we start with the flat text-based tree
format from <a href="#text/part0000_split_044.html.sec.text-trees"><em class="calibre6">Representing Trees in Text</em></a> and then replace parentheses with
imaginary <code class="calibre21">UP</code> and <code class="calibre21">DOWN</code> navigation nodes.</p><p height="10" width="0" class="calibre5">For example, the
text-based form of the AST for <code class="calibre21">1+2</code> is <code class="calibre21">(+ 1 2)</code>, a preorder
traversal with subtrees wrapped in parentheses.</p><p height="10" width="0" class="calibre5">The serialization of
<code class="calibre21">(+ 1 2)</code> looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+ DOWN 1 2 UP</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The navigation nodes simulate the up-and-down movement of a tree
walker, forcing a one-dimensional parser to do the same.</p><p height="10" width="0" class="calibre5">Lets figure out what the grammar for our little addition expression
trees should look like.  Nodes are either integers or addition
subtrees whose children are nodes or subtrees.  Grammatically we can
describe that structure with a single rule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr : ^(<em class="calibre6">'+'</em> expr expr) <em class="calibre6">// E.g., "(+ 1 2)" and "(+ (+ 1 2) 3)"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; | INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// E.g., 1 and 2</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The recursion in the first alternative highlights the self-similar
nature of expression treesthe children of an expression operator can
also be expressions.  The <code class="calibre21">^</code> prefix is necessary to distinguish tree
constructs from normal subrules.</p><p height="10" width="0" class="calibre5">ANTLR automatically translates tree pattern <code class="calibre21">^('+'
expr expr)</code> to <code class="calibre21">'+' DOWN expr expr UP</code>.  ANTLR generates a parser
(following Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>) from rule <code class="calibre21">expr</code>, which is akin to the following:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> expr() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match an expression subtree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( LA(1)==Token.PLUS ) {&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// if next token is +</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(Token.PLUS);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(DOWN);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// simulate down movement</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expr();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expr();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(UP);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// simulate up movement</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <b class="calibre13">if</b> ( LA(1)==Token.INT ) { <em class="calibre6">// if next token is INT</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match(Token.INT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// match single INT node expr</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> <em class="calibre6">invalid-tree</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// detected malformed tree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Looking back at our heterogeneous node definitions now (Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>), we see that they actually say sort of
the same thing as rule <code class="calibre21">expr</code>. An
<code class="calibre21">ExprNode</code> is an <code class="calibre21">AddNode</code>
or <code class="calibre21">IntNode</code> (because they are subclasses of
<code class="calibre21">ExprNode</code>).  An <code class="calibre21">AddNode</code>
has two <code class="calibre21">ExprNode</code> children
(<code class="calibre21">left</code> and
<code class="calibre21">right</code>). Rule <code class="calibre21">expr</code>
makes it clearer what the trees look like, though.</p><p height="10" width="0" class="calibre5">As with any grammar, we can embed actions.  To print out a tree in
postorder, we add print statements at the end of the two
alternatives.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr : ^(<em class="calibre6">'+'</em> expr expr) {System.out.println(<em class="calibre6">"+"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; | INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{System.out.println($INT.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For tree <code class="calibre21">(+ 1 2)</code>, the ANTLR-generated tree visitor would print <code class="calibre21">1 2
+</code>. Rather than creating a visitor function based upon a node type, we
tell the parser to execute actions when it comes across a
particular tree pattern.  Actions at the start of alternative are in
node discovery position. Actions at the end of an alternative are in
node finishing position. Actions embedded within the alternative
happen in between node discovery and finishing.</p><p height="10" width="0" class="calibre5">A tree grammar specifies the complete syntax of all
valid ASTs for a particular application just as a parser grammar
specifies a valid set of sentences. Tree grammars are extremely useful
as a form of executable documentation describing the trees generated
by a parser.</p><p height="10" width="0" class="calibre5">Not only does the tree grammar describe the set of valid trees, but
running an ANTLR-generated visitor over a tree checks its
structure. Instead of co-opting the type system to enforce structure
during construction like <a href="#text/part0000_split_044.html.sec.co-opting-type-system"><em class="calibre6">Enforcing Tree Structure with the Type System</em></a>,
we can check it later at run-time.  Catching structural errors at
compile time is great, but we have to walk the trees anyway. We might
as well check their structure as we go.  Also, the type system isnt
always sufficient to prevent invalid tree structures.  If were using
a dynamically typed language, we dont even have the option. We have
to use a tree grammar to enforce tree structure in that case.</p><p height="10" width="0" class="calibre5">Tree grammars are most useful when weve got lots of work to do on
the tree.  In other words, theyre most useful when we have actions all over the grammar.
A good example is a final tree-walking phase that generates source
code. (Well use a tree grammar to emit a subset of C in <a href="#text/part0000_split_121.html.sec.tree-grammar-templates"><em class="calibre6">Using a Tree Grammar to Create Templates</em></a>.)  In that case, the tree
grammar provides a terse means of specifying a complete visitor and
associated code generation actions.</p><p height="10" width="0" class="calibre5">But, many of the intermediate tree-walking phases only care  about
certain sections or pieces of the tree. Its a burden to build a
complete tree grammar when all we care about is, say, collecting
information at method and variable definition subtrees. Ive often
created a prototype tree grammar and then made copies of that grammar
for every phase.  Unfortunately, this poses a maintenance problem
because AST structure can change, particularly during
development. Ive had to push changes to all grammar copies.</p><p height="10" width="0" class="calibre5">For intermediate tree-walking phases, we need a solution that lets us
focus only on the tree patterns we care about for a particular phase.
To make this work, we need to separate our tree traversal strategy
from pattern matching and action execution. In the next section, well
explore how to do that with tree pattern matchers (based upon tree
grammars).
</p>

</div></div>
<div id="text/part0000_split_057.html"><div class="calibre">

<h2 id="text/part0000_split_057.html.sec.tree-pattern-descr" class="calibre18">Decoupling Tree Traversal from Pattern Matching</h2><p height="10" width="0" class="calibre5">Imagine we need to print a list of all assignments to simple
variables in a Python program. 
It would be overkill to create or use
an existing full Python parser. The pattern were looking for is
unique. Using regular expressions and UNIX <code class="calibre21">awk</code>, we could filter
Python programs looking for assignments with a one-liner:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">awk '/[ \t]+[a-zA-Z]+ =/ {print $1}' &lt; myprog.py </b><em class="calibre6"># $1 is left of '='</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">style&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">keymap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">pt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Dont worry about the details (which arent perfect anyway). The key
is that we made a tool consisting of a just one pattern and associated
action. We left the details of traversing the input to <code class="calibre21">awk</code>.  We
really dont care, in this case, if <code class="calibre21">awk</code> walks the input lines
forward, backward, or randomly. When <code class="calibre21">awk</code> matches a line to a
pattern, it triggers the action.  We dont have to specify traversal
instructions in the pattern itself.  For example, the <code class="calibre21">print $1</code>
action doesnt include code telling <code class="calibre21">awk</code> to walk the remainder of
the file.</p><p height="10" width="0" class="calibre5">If youre asking yourself why we would ever entangle pattern matching
with traversal, note that embedded walker and external visitor
patterns both do it. Take a look at one of the visitor methods we
built earlier:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> print(AddNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print(n.left);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// visit left child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print(n.right);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// visit right child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(n.token); <em class="calibre6">// action in postorder position</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The first two statements specifically tell the visitor to visit the
left child and then the right child. That is clearly encoding the tree
traversal strategy in the method that matches an
<code class="calibre21">AddNode</code>.  Forget the first
<tt class="calibre21">print</tt> call, and the visitor wont walk the
left operand subtree of any addition node.</p><p height="10" width="0" class="calibre5">When we only care about  some of the subtrees, building a full tree
grammar or complete external visitor is overkill.  But, only specifying
 some of the rules or visitor methods wont work. We need a
pattern for each subtree and node because the pattern code includes
the traversal instructions. We couldnt visit all nodes without a
complete tree specification.</p><p height="10" width="0" class="calibre5">The way around this is to decouple the tree traversal strategy from
pattern matching. In other words, we want to think about pattern
matching and actions separately from how and when we apply those
patterns.  In fact, we might want to use one set of patterns on the
way down the tree and another on the way up.</p><p height="10" width="0" class="calibre5">For example, on the way down, it makes sense to eliminate
unreachable code so we dont waste time traversing it.  Take the
<code class="calibre21">if</code> statement.  There is no point in descending into
an <code class="calibre21">if</code>s statement when the conditional expression
is boolean literal <code class="calibre21">false</code>.</p><p height="10" width="0" class="calibre5">In other cases, it makes more sense to do rewrites on the way
up. Eliminating multiply-by-zero operations is a good example. Wed
like to rewrite expression <code class="calibre21">4*0*2</code> to be <code class="calibre21">0</code>. Its AST looks like this:</p><div class="calibre1"><img id="text/part0000_split_057.html.d24e12774" class="calibre24" src="data:image/gif;base64,R0lGODlhWQBhAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAABZAGEAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEN+FCdOpEmJ5cydXLlQHLlx59K9LMmy5sBx5g6wa3eOHE2bNV2qgxcP3TigSMepU5duHTmkQMWdK0fuwFGoNseV/Im1q9evYMOKHUtW3NWCZrmSpaiU3VmB49DhO7fWorh08eA9Jag0XrtydSeKO5A3ndp/49zBw/c2cENz7uKpayxwsDt5Mh07JLdOHr69B8WhgwcP3WHNaIe+A6xwXLp5f1EnlJr3wOmC5PD5pSz7H7l38dbdNlgu8uTefNXJYwe64eh4tpH/E3cP3juVEJXSY8datlTgplH+tpO3zvu44rsFE36HrpzWwOfUsZP3LrrgofDa3WsuNnE9evOoM1xD5LRTTz3xpLMWbQAAUA8+A7Z0zjsN1uNOhECN0w49DQLQDm8OiRZPh/GUg2FN5chTIT3rgOjQAe7U0+A8LfZ3D4cIGnWROOXgg2M8/HUFGQDzuBMeRkLF89+RX5nTjl8HdEQdUeeceBKPBwSZkUvpuIgUSSGRZKV00oHJklnjzISUOVqCRI467bzTTpsfpTnOPUa9J1I595xzzj1M0dkROeac0w53eoZUTpXTnYNPlCuJY8468bzDaE1xqdPdST0uJSCm6KxjIqY9lWPfSTClc+mZV41p1zj+B6QDKZkTlbPUqK7SKpBycrLDjqi6QmToOsSuo2mwmiVKUFrIJkQOO58SRE5TmzY70JvyuNNYOewE5yWZ1NFHl0HmvAOPYdYOhI65TC47GjyrIovecQiNQ+lq1j6bnkLP0ihosq+5Uy1CTkqWa1jnkNbubAcorOuz8tDbkDj3/lvWOvBoGxE57gT4rVjUVWpOrt/FM26ysAIn3ESuydNOlh9DJRqcsA38kIbWsXNOzECRoyQ9Jh88EI/w/GfpWq7N0yA96Nh1j4oA0KPOWuXK6GC0LKujdINzkoUOhw7OszBEohXdYIJC14lPhZamPfQ5MTp4oVijEfmy28uaw46o0vL4FNa68eBjs0X25jUqWDhZNdIBY3dl5kg8p7ugmEGNYznetaZzT+Q7HtCOO+00TeqvFmsUE57EHn4S4+kIztJSJdnaZaTqWAXslemIzuNnqPpp+e0n5T5QcYNzxC0+6ajjzski3SX6P+XEZhK3nysWb0jq3FPZAU5Fajm3xXNE8afmpDM7S9wevdIBnhrrN/rrcHdmrEzNKvn9+Oev//789+8/mQEBADs=" alt="images/walking/zeros.png"></div><p height="10" width="0" class="calibre5">We need to reduce the <code class="calibre21">4*0</code> subtree to <code class="calibre21">0</code> before checking the topmost
<code class="calibre21">*</code> node.  Otherwise, we wont see it as <code class="calibre21">0*2</code> and replace it with <code class="calibre21">0</code>.</p><p height="10" width="0" class="calibre5">Repeatedly applying rules to subtrees using a separate (usually bottom-up)
traversal strategy is called 
<em class="calibre6">term rewriting</em>. A <em class="calibre6">term</em> is
just a subtree.  There are a number of nice tools specifically
designed to rewrite terms. ASF+SDF<a id="text/part0000_split_057.html.FNPTR-14" href="#text/part0000_split_062.html.FOOTNOTE-14">[14]</a> is one of the most popular.  Eelco
Visser took term writing to a new level by supporting programmable
rewriting strategies in his Stratego/XT<a id="text/part0000_split_057.html.FNPTR-15" href="#text/part0000_split_062.html.FOOTNOTE-15">[15]</a>
tool. He also has some useful documentation on Strategos website about
separating tree traversal from transformation patterns if youd like
to learn more about this topic.</p><p height="10" width="0" class="calibre5">These tools require a pure functional programming style, though, which
is an uphill struggle for many of us.  They dont allow arbitrary
actions, which can make it harder to integrate transformation phases
into existing applications.  One term-rewriting tool, Tom,<a id="text/part0000_split_057.html.FNPTR-16" href="#text/part0000_split_062.html.FOOTNOTE-16">[16]</a> though, acts as an extension to Java.</p><p height="10" width="0" class="calibre5">As well see in Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>, ANTLR
can do tree pattern matching also.  
It uses a depth-first tree walker
that invokes tree grammar rules at each node, looking for a match.  If
a tree pattern doesnt match the current subtree, ANTLR tries another
pattern. If it doesnt find one, it walks to a new node in the tree
and looks for a matching pattern again.</p><p height="10" width="0" class="calibre5">All the patterns described in this chapter have their place.  Which
one we use depends on the nature of our task.  The following table
summarizes their strengths and weaknesses.</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td width="1.25in" class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Embedding walking methods
in tree nodes is the simplest mechanism for building a tree
walker. It doesnt work so well with 50 or 100 node types
because walker functionality is distributed across 50 or 100
files.
</p></div></td></tr><tr class="calibre9"><td width="1.25in" class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Visitors encapsulate tree
walkers into a single class and allow us to change visitors on the fly.
Visitors are useful for collecting information or doing some simple
interpretation, 
such as expression evaluation. They are not well suited to tree
pattern matching applications. Visitors simply walk the tree node by
node.</p></div></td></tr><tr class="calibre9"><td width="1.25in" class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Embedded walkers and visitors are
hand-built.  
ANTLR can generate external tree visitors for us automatically
from tree grammars, which are smaller and easier to read. Tree
grammars specify the structure of entire trees. They are most 
effective when we need to execute actions in many or most rules. For
example, tree-walking code generators typically need to emit code for
every subtree. There are actions strewn throughout the grammar.</p></div></td></tr><tr class="calibre9"><td width="1.25in" class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">If youre only
interested in executing actions on a few subtree patterns, its a
burden to fill out an entire tree grammar (or build a complete visitor,
for that matter). 
All visitors, automatically generated or not,
entangle tree traversal instructions 
with action execution.  To walk the entire tree looking for patterns,
then, we need to give a complete tree grammar specification. To
operate only on a specific subset of an AST structures, we can use a
tree pattern matcher.</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">With this comparison in mind, were ready to tackle the details of
the four tree-walking patterns.  To keep a common thread, well work
with the little vector math language from <a href="#text/part0000_split_046.html.sec.ASTs-with-ANTLR"><em class="calibre6">Constructing ASTs with ANTLR Grammars</em></a>.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_058.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_058.html.tip.embedded-walker" class="pagebreak2"><small class="calibre35">Pattern 12:</small>&nbsp;&nbsp;&nbsp;Embedded Heterogeneous Tree Walker</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern walks heterogeneous ASTs using a set of recursive
methods defined within the node class definitions.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">As object-oriented programmers, it is natural for us to think about
adding tree-walking methods to node definitions.  For each task, wed
add a different set of recursive methods. For example, to print trees
back to text, we could define an abstract <tt class="calibre21">print</tt> method in the root
class. To evaluate expressions, we could add an abstract <tt class="calibre21">eval</tt>
method to the abstract expression class.</p><p height="10" width="0" class="calibre5">This is the easiest tree-walking pattern to understand, but,
ultimately, this approach doesnt scale well.  Because it distributes
tree-walking code across all node definitions, it works best when
there are only a few node definitions. More important, we need
access to node source code. If we dont have source code (or we need
to change tree walker functionality on the fly), we have to use Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a> instead.</p><p height="10" width="0" class="calibre5">Building an embedded walker means adding a walking method like this
(assuming we only need preorder actions):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class <em class="calibre6">NodeName</em> extends <em class="calibre6">common-root</em> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public void <em class="calibre6">walking-method-name</em>() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">preorder-action-for-this-node-or-subtree</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">walk-any-children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The walking methods serve two purposes: first, to execute an action or
actions per node and second, to guide the walk through the tree. If a walking
method forgets to walk a nodes children, those children wont ever be
visited.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">The sample code for this pattern defines heterogeneous AST nodes
for the vector math language from <a href="#text/part0000_split_046.html.sec.ASTs-with-ANTLR"><em class="calibre6">Constructing ASTs with ANTLR Grammars</em></a>.  
The generic
root class defines the token payload:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/embedded/HeteroAST.java">walking/embedded/HeteroAST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> HeteroAST {<em class="calibre6">// Heterogeneous AST node type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// This node created from which token?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> HeteroAST()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> HeteroAST(Token token)&nbsp;&nbsp; { this.token = token; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toString()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <b class="calibre13">return</b> token.toString(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">A generic <code class="calibre21">VecMathNode</code> node embeds a walking method
called <tt class="calibre21">print</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/embedded/VecMathNode.java">walking/embedded/VecMathNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** A generic heterogeneous tree node used in our vector math trees */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> VecMathNode <b class="calibre13">extends</b> HeteroAST {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VecMathNode() {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VecMathNode(Token token) { super(token); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> print() { <em class="calibre6">// generic print tree-walker method</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(token != null ? token.toString() : <em class="calibre6">"&lt;null&gt;"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Our vector math language has two general node categories: statements
(assignment and print) and expressions. We can use <code class="calibre21">StatNode</code> and
<code class="calibre21">ExprNode</code> to group related nodes.  The concrete subclasses override
<tt class="calibre21">print</tt>.</p><p height="10" width="0" class="calibre5">For example, heres <code class="calibre21">AssignNode</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/embedded/AssignNode.java">walking/embedded/AssignNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> AssignNode <b class="calibre13">extends</b> StatNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;VarNode id;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ExprNode value;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> AssignNode(VarNode id, Token token, ExprNode value) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(token); this.id = id; this.value = value;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> print() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// walk left child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">"="</em>); <em class="calibre6">// print operator</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// walk right child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Notice that <tt class="calibre21">print</tt> walks the children in addition to printing the
assignment operator.</p><p height="10" width="0" class="calibre5">The <tt class="calibre21">print</tt> method in the <code class="calibre21">AddNode</code> operator node is similar:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/embedded/AddNode.java">walking/embedded/AddNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> print() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;left.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// walk left child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">"+"</em>); <em class="calibre6">// print operator</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;right.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// walk right child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The test rig within the source code directory manually builds a tree
holding two statements: an assignment and print statement.  For
simplicity, it builds trees with code rather than relying on an
AST-constructing parser. To launch the embedded walker, the rig calls
<tt class="calibre21">print</tt> on the root node:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/embedded/Test.java">walking/embedded/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">statlist.print(); <em class="calibre6">// Launch embedded walker</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Running the test rig prints the statements:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test</b>&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x=3+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print x*[2, 3, 4]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The next pattern collects embedded tree-walking methods into a single,
external class.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_059.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_059.html.tip.visitor" class="pagebreak2"><small class="calibre35">Pattern 13:</small>&nbsp;&nbsp;&nbsp;External Tree Visitor</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern encapsulates all tree-walking code associated
with a particular task into a single visitor class.</em>
</p><p height="10" width="0" class="calibre5">Visitors combine tree walking and action execution code outside the
AST node definitions.  Consequently, we can change the functionality
of the tree walker without having to change the AST class definitions
and can even switch visitors on the fly.  An external visitor can walk
either heterogeneous or homogeneous AST nodes.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The visitor pattern is the workhorse of choice for tree walking in
most language applications.  Ultimately you might get tired of
manually building visitors, though, and you might come to rely on either
Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> or Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>.  That said, the key to
understanding automatically generated visitors is to know how to build
visitors manually.</p><p height="10" width="0" class="calibre5">Visitors use similar code to what wed find in Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>. The only difference is that visitors
are external to the AST node definitions, giving us a nice separation
of concerns. The tree-walking methods live within a single visitor
class.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">There are two ways to implement this pattern. 
The first is more
traditional and relies on the node types themselves.  The second
relies on the nodes token type instead.  This section gives examples
of both using the AST nodes from the vector math language in <a href="#text/part0000_split_046.html.sec.ASTs-with-ANTLR"><em class="calibre6">Constructing ASTs with ANTLR Grammars</em></a>.</p><h4 class="calibre26">Visitor Switching on Node Type</h4><p height="10" width="0" class="calibre5">The traditional implementation of the visitor pattern
originally specified in <a href="#text/part0000_split_135.html.d2381e177"><em class="calibre6">Design
Patterns: Elements of Reusable Object-Oriented Software</em>&nbsp;[GHJV95]</a>
relies on a double-dispatch method within each AST
node. The double-dispatch method redirects
<tt class="calibre21">visit</tt> calls on a node to an appropriate
method in a visitor servicing that node type.  The visitor is like a
set of callback methods. To make this work, we need to define the
crucial <tt class="calibre21">visit</tt> double-dispatch method
signature in our generic node:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/VecMathNode.java">walking/visitor/VecMathNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** A generic heterogeneous tree node used in our vector math trees */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">class</b> VecMathNode <b class="calibre13">extends</b> HeteroAST {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VecMathNode() {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VecMathNode(Token t) { this.token = t; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">abstract</b> <b class="calibre13">void</b> visit(VecMathVisitor visitor); <em class="calibre6">// dispatcher</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Unfortunately, we need to implement <tt class="calibre21">visit</tt> in every class
(well look at its argument type, <code class="calibre21">VecMathVisitor</code>, in a second).
Surprisingly, every <tt class="calibre21">visit</tt> method is identical.  Here it is
in <code class="calibre21">AddNode</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/AddNode.java">walking/visitor/AddNode.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> visit(VecMathVisitor visitor) { visitor.visit(this); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Calling a nodes <tt class="calibre21">visit</tt> method immediately
redirects (which is why its called <em class="calibre6">double-dispatch</em>) to the associated visitors
method. For example, if <code class="calibre21">n</code> points at
an <code class="calibre21">AddNode</code> at run-time, then a method dispatch
to <code class="calibre21">n.visit(myVisitor)</code> immediately redispatches to <code class="calibre21">myVisitor.visit((AddNode)n)</code>.</p><p height="10" width="0" class="calibre5">Given this double-dispatch mechanism, lets figure out what the
visitor itself looks like. The only constraint on the visitor objects
is that they implement <code class="calibre21">VecMathVisitor</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/VecMathVisitor.java">walking/visitor/VecMathVisitor.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">interface</b> VecMathVisitor {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(AssignNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(PrintNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(StatListNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(VarNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(AddNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(DotProductNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(IntNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(MultNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">void</b> visit(VectorNode n);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As a sample implementation, lets write a visitor that prints out
vector math nodes just like we did in Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a>. The output
will be the same, but the mechanism is different.  </p><p height="10" width="0" class="calibre5">Here is
the start of a <code class="calibre21">PrintVisitor</code> with the code for visiting <code class="calibre21">AssignNode</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/PrintVisitor.java">walking/visitor/PrintVisitor.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> PrintVisitor <b class="calibre13">implements</b> VecMathVisitor {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> visit(AssignNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n.id.visit(this);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">"="</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n.value.visit(this);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To print a tree, we invoke <tt class="calibre21">visit</tt> on the root node and pass in a
visitor:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/Test.java">walking/visitor/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PrintVisitor visitor = <b class="calibre13">new</b> PrintVisitor();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">statlist.visit(visitor); <em class="calibre6">// tell root node to visit with this visitor</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This visitor implementation requires heterogeneous nodes and, sadly,
isnt truly independent of the AST nodes because of the double-dispatch
<tt class="calibre21">visit</tt> method. The implementation in the next section works on
homogeneous nodes as well and is completely independent of the AST
node definitions.</p><h4 class="calibre26">Switching on the Token Type to Build Independent Visitors</h4><p height="10" width="0" class="calibre5">For language applications, we build trees from tokens. Since we can
distinguish between tokens using the token type, we can also
distinguish between AST nodes using the token type. By switching on
the token type rather than the AST node type, we can avoid the
<tt class="calibre21">visit</tt> method in each AST node.  In its place,
we use just one dispatch method inside the visitor:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/IndependentPrintVisitor.java">walking/visitor/IndependentPrintVisitor.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> print(VecMathNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">switch</b> ( n.token.type ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.ID :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print((VarNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.ASSIGN :&nbsp;&nbsp;&nbsp;&nbsp;print((AssignNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.PRINT :&nbsp;&nbsp;&nbsp;&nbsp; print((PrintNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.PLUS :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print((AddNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.MULT :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print((MultNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.DOT :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print((DotProductNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.INT :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print((IntNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.VEC :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print((VectorNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> Token.STAT_LIST : print((StatListNode)n); <b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">default</b> :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// catch unhandled node types</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">throw</b> <b class="calibre13">new</b> UnsupportedOperationException(<em class="calibre6">"Node "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n.getClass().getName()+ <em class="calibre6">" not handled"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The dispatch method invokes the appropriate overloaded method. For
example, here is the visitor method for <code class="calibre21">AddNode</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/IndependentPrintVisitor.java">walking/visitor/IndependentPrintVisitor.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> print(AddNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print(n.left);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// walk left child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">"+"</em>); <em class="calibre6">// print operator</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print(n.right);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// walk right child</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To walk an AST, we pass an AST node to the visitor instead of passing
the visitor to an AST node. The following snippet from the test rig
creates a visitor and then tells it to visit the root node:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/visitor/Test.java">walking/visitor/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">IndependentPrintVisitor indepVisitor = <b class="calibre13">new</b> IndependentPrintVisitor();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">indepVisitor.print(statlist); <em class="calibre6">// tell visitor to print from root</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This implementation has a number of advantages over a traditional double-dispatch visitor.  By switching on the token type instead, the method names can be relevant to
the task at hand such as <tt class="calibre21">print</tt>. A traditional visitor has to name
every method <tt class="calibre21">visit</tt> because the visitors have to follow the
interface.  This implementation does not need an interface at all and
has a double-dispatch mechanism that is completely encapsulated within
the visitor. The only disadvantage is that we lose compile-time
checking if we forget a visitor method for a node type. We have to
wait until run-time before throwing an <code class="calibre21">UnsupportedOperationException</code> from the dispatch method.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern effectively collects the tree-walking methods from the
nodes discussed in Pattern 12, <a href="#text/part0000_split_058.html.tip.embedded-walker"><em class="calibre6">Embedded Heterogeneous Tree Walker</em></a> and puts them into a single class.
ANTLR can automatically build an external visitor from Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_060.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_060.html.tip.tree-grammar" class="pagebreak2"><small class="calibre35">Pattern 14:</small>&nbsp;&nbsp;&nbsp;Tree Grammar</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">Tree grammars are a terse and formal way of building an
external visitor.</em>
</p><p height="10" width="0" class="calibre5">Visitors generated from tree grammars are usually called <em class="calibre6">tree
parsers</em> because they are the two-dimensional analog of conventional
parsers.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">In <a href="#text/part0000_split_056.html.sec.generating-visitors"><em class="calibre6">Automatically Generating Visitors from Grammars</em></a>, we saw that tree grammars look just like
conventional parser grammars except that we can match subtree patterns
as well.  As with parser grammars, we can embed actions to
extract information or reorganize the input (a tree, in this case).</p><p height="10" width="0" class="calibre5">In order to convert tree grammars to tree parsers (visitors), we can follow
Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a>.  The only extra mapping we need is for
tree structures:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// match ^(<em class="calibre6">root</em> <em class="calibre6">children</em>)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(<em class="calibre6">root</em>);&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(DOWN); // simulate downward movement of a tree walker</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">match-children</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">match(UP);&nbsp;&nbsp; // simulate upward movement of a tree walker</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> <em class="calibre6">root</em> is usually a token but can be a set of tokens. <em class="calibre6">children</em> can be any token, any rule, or even a nested tree reference.</p><p height="10" width="0" class="calibre5">ANTLR generates tree walkers from tree grammars that literally act
like parsers.  For example, the walkers automatically detect tree
structure errors and emit error messages (analogous to syntax
errors). If we build an invalid tree such as <code class="calibre21">'=' (x 1)</code> instead of
<code class="calibre21">('=' x 1)</code>, a tree walker might emit something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Printer.g: node from line 1:0 extraneous input 'x' expecting &lt;DOWN&gt;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Tree grammars do not care about the implementation language classes
used to represent AST nodes (they work with both homogeneous and
heterogeneous AST nodes). Instead, they rely on token type differences
between AST node token payloads to distinguish different kinds of
nodes. So, the tree walker differentiates between node
<code class="calibre21">x</code> and node <code class="calibre21">1</code> by
comparing their <code class="calibre21">ID</code> and <code class="calibre21">INT</code> token
types (as opposed to, say, <code class="calibre21">VarNode</code> and
<code class="calibre21">IntNode</code> types).</p><p height="10" width="0" class="calibre5">Once youre comfortable with tree grammars, youll find them easier to
write and more robust than hand-built visitors (Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>). Tree
grammars and visitors are equally powerful; its really the difference
between using a grammar and writing a parser by hand.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">To compare tree grammars to hand-built visitors, lets implement the
same printing functionality as <code class="calibre21">IndependentPrintVisitor</code> from Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>.
The most obvious difference is that <code class="calibre21">IndependentPrintVisitor.java</code> is 81 lines,
but our functionally equivalent tree grammar is only 26 lines.</p><p height="10" width="0" class="calibre5">The header for our tree grammar tells ANTLR that well be using token
types from a <code class="calibre21">VecMath.g</code> parser grammar (provided in the source code
directory) that builds vector math ASTs.  It also says well be using
homogeneous tree nodes (the default ANTLR <code class="calibre21">CommonTree</code>).</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/tree-grammar/Printer.g">walking/tree-grammar/Printer.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">tree</b> <b class="calibre13">grammar</b> Printer; <em class="calibre6">// this grammar is a tree grammar called Printer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">options</b> {&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;tokenVocab=VecMath;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// use token vocabulary from VecMath.g</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ASTLabelType=CommonTree; <em class="calibre6">// use homogeneous CommonTree for $ID, etc.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@members</b> { void print(String s) { System.out.print(s); } }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Our trees are lists of statement subtrees, and there are two kinds of
statements:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/tree-grammar/Printer.g">walking/tree-grammar/Printer.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">prog:&nbsp;&nbsp; stat+ ; <em class="calibre6">// match list of statement subtrees</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// match trees like ('=' x 1) and ('print' ('+' 3 4))</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stat:&nbsp;&nbsp; ^(<em class="calibre6">'='</em> ID&nbsp;&nbsp;{print($ID.text+<em class="calibre6">" = "</em>);} expr) {print(<em class="calibre6">"\n"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(<em class="calibre6">'print'</em> {print(<em class="calibre6">"print "</em>);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expr) {print(<em class="calibre6">"\n"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">print</code> actions occur after the immediately preceding grammar
element and before the following element. So, the newline <code class="calibre21">print</code> at
the end of each alternative occurs after the tree walker prints the
statements.  The ANTLR-generated tree walker executes actions as it
walks the tree-matching patterns just like a hand-built visitor.</p><p height="10" width="0" class="calibre5">To print out expressions, we provide a subtree pattern for each
operator and then the three literals (vectors, integers, and
identifiers):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/tree-grammar/Printer.g">walking/tree-grammar/Printer.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr:&nbsp;&nbsp; ^(<em class="calibre6">'+'</em> expr {print(<em class="calibre6">"+"</em>);} expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(<em class="calibre6">'*'</em> expr {print(<em class="calibre6">"*"</em>);} expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(<em class="calibre6">'.'</em> expr {print(<em class="calibre6">"."</em>);} expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(VEC {print(<em class="calibre6">"["</em>);} expr ({print(<em class="calibre6">", "</em>);} expr)* {print(<em class="calibre6">"]"</em>);})</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; INT {print($INT.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID&nbsp;&nbsp;{print($ID.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Our test rig builds trees from vector math statements read from
standard input:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/tree-grammar/Test.java">walking/tree-grammar/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Create lexer/parser to build trees from stdin</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">VecMathLexer lex = <b class="calibre13">new</b> VecMathLexer(<b class="calibre13">new</b> ANTLRInputStream(<b class="calibre13">System</b>.in));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTokenStream tokens = <b class="calibre13">new</b> CommonTokenStream(lex);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">VecMathParser p = <b class="calibre13">new</b> VecMathParser(tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">RuleReturnScope r = p.prog(); <em class="calibre6">// launch parser by calling start rule</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// get tree result</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTree tree = (CommonTree)r.getTree();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(tree.toStringTree()); <em class="calibre6">// print out LISP style</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rig then walks the tree it gets back from the parsers start rule:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/tree-grammar/Test.java">walking/tree-grammar/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// serialize tree into node stream</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(tree);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Printer tp = <b class="calibre13">new</b> Printer(nodes); <em class="calibre6">// create tree walker</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tp.prog();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// launch by calling start rule</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You can build this code by running ANTLR on the appropriate grammars
and compiling:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool VecMath.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Printer.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The output looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t1&nbsp;&nbsp; </b><em class="calibre6"># t1 contains an assignment and print statement</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(= x (+ 3 4)) (print (* x (VEC 2 3 4)))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x = 3+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print x*[2, 3, 4]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The tree walker, <code class="calibre21">Printer</code>, emits the last two lines.</p><p height="10" width="0" class="calibre5">The source code directory for this pattern includes two AST-building
parser grammars, one for creating homogeneous trees and one for
creating heterogeneous trees. To support the heterogeneous tree
construction, youll also find heterogeneous AST node definitions.
Tree grammar <code class="calibre21">Printer</code> works with either kind of tree.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">We translate tree grammars to tree walkers using Pattern 1, <a href="#text/part0000_split_026.html.tip.grammar-parser-mapping"><em class="calibre6">Mapping Grammars to Recursive-Descent Recognizers</em></a> as a base.  The resulting walker is a Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>. The sample code in Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a> uses tree
grammar rules to match subtrees.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_061.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_061.html.tip.tree-pattern-matcher" class="pagebreak2"><small class="calibre35">Pattern 15:</small>&nbsp;&nbsp;&nbsp;Tree Pattern Matcher</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern walks trees, triggering actions or tree rewrites
as it encounters tree patterns of interest.</em>
</p><p height="10" width="0" class="calibre5">The process of matching and rewriting trees is formally called <em class="calibre6">term rewriting</em>.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Using a tree pattern matcher differs from using a tree grammar in two
important ways:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>We have to specify patterns only for the subtrees we care about.</li><li height="6" class="calibre20"><span></span>We dont need to direct the tree walk.</li></ul><p height="10" width="0" class="calibre5">As we saw in <a href="#text/part0000_split_057.html.sec.tree-pattern-descr"><em class="calibre6">Decoupling Tree Traversal from Pattern Matching</em></a>, a tree
pattern matcher is analogous to text rewriting tools such as
<code class="calibre21">awk</code>, <code class="calibre21">sed</code>, and
<code class="calibre21">perl</code>.  We get to focus on input patterns of
interest and what to do when we match those patterns.  Whichever
pattern matcher tool were using deals with tree walking and when to
apply the patterns. In contrast, a tree grammar needs a pattern for
each subtree. The grammar rules include traversal instructions just
like a hand-built visitor. Without a complete tree specification, a
visitor would not discover every node.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Avoiding Infinite Tree Rewriting Loops</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">A word of caution about tree rewriting: depending on the tree-walking
      strategy and the patterns we specify, we can cause infinite
      loops. Imagine a rule that converts <code class="calibre21">x+0</code> to <code class="calibre21">x</code> and another rule that
      converts <code class="calibre21">x</code> to <code class="calibre21">x+0</code>.  Repeatedly applying these two patterns would
      prevent termination of our program.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">Tree pattern matching makes a lot more sense after looking at an
example.  Lets take a look at a few Boolean simplification rewrite
rules using two mature rewriting tools, Meta-Environment<a id="text/part0000_split_061.html.FNPTR-17" href="#text/part0000_split_062.html.FOOTNOTE-17">[17]</a> (ASF+SDF) and Stratego/XT.<a id="text/part0000_split_061.html.FNPTR-18" href="#text/part0000_split_062.html.FOOTNOTE-18">[18]</a> Both tools use a slightly different syntax
than ANTLR for specifying subtrees.  They use <code class="calibre21">and(x,y)</code>, whereas ANTLR
uses <code class="calibre21">^('and' x y)</code>.  In this case, <code class="calibre21">and</code> is the root (operator); <code class="calibre21">x</code>
and <code class="calibre21">y</code> are its children.  Using ASF equations, we can easily specify
Boolean simplification rewrites.<a id="text/part0000_split_061.html.FNPTR-19" href="#text/part0000_split_062.html.FOOTNOTE-19">[19]</a></p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">equations&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> not(true) = false</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> not(false) = true</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> and(X, true) = X</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> and(true, X) = X</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Stratego/XT uses a similar syntax.  From the documentation,<a id="text/part0000_split_061.html.FNPTR-20" href="#text/part0000_split_062.html.FOOTNOTE-20">[20]</a>
here is how wed say the same thing:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;E : Not(True)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; False</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;E : Not(False)&nbsp;&nbsp;&nbsp;&nbsp; -&gt; True</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;E : And(True, x)&nbsp;&nbsp; -&gt; x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;E : And(x, True)&nbsp;&nbsp; -&gt; x</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The cool thing about Stratego/XT is that it supports programmable
rewriting strategies. We can explicitly tell it how to traverse the
tree and the order to apply rules. For example, the appropriate
strategy for simplifying Boolean subtrees is as follows:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">strategies&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;eval = bottomup(repeat(E))</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">That means it should try to match <code class="calibre21">E</code>s alternatives using a
bottom-up traversal over the entire tree. At each subtree, it should
repeatedly apply <code class="calibre21">E</code> rules until nothing changes.</p><p height="10" width="0" class="calibre5">We can also do tree pattern matching with ANTLR using the <code class="calibre21">filter</code>
option in a tree grammar.  Here are the same Boolean simplification rules using an ANTLR tree
grammar rule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">e : ^('!' 'true')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 'false'&nbsp;&nbsp;// !true -&gt; false</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;| ^('!' 'false')&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 'true'&nbsp;&nbsp; // !false -&gt; true</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;| ^('&amp;&amp;' 'true' x=.) -&gt; $x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true &amp;&amp; x -&gt; x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;| ^('&amp;&amp;' x=. 'true') -&gt; $x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x &amp;&amp; true -&gt; x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This assumes that <code class="calibre21">'!'</code> and <code class="calibre21">'&amp;&amp;'</code> are the token types for
not and logical and. The dot element is a wildcard that matches
any node or subtree. The rule specifies a tree pattern to
tree pattern mapping.  In this case, we are reducing subtrees to
single nodes based upon an understanding of Boolean logic.
</p><p height="10" width="0" class="calibre5">Like Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>, tree pattern matchers
dont rely on the implementation language classes used to represent
nodes, so they work on both Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a> and Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a> trees.  They do, however, require
normalized children (see Pattern 10, <a href="#text/part0000_split_049.html.tip.hetero-normalized"><em class="calibre6">Normalized Heterogeneous AST</em></a> and
Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>). Node-independent tree-walking strategies
must access and descend into a nodes child list using a common
interface.  Its the shape of the tree that really matters, not the
node implementation types.</p><p height="10" width="0" class="calibre5">The next section provides two full tree rewrite examples and discusses
traversal strategy details.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Lets get our heads wrapped around tree pattern matching with a few
concrete examples (that use ANTLR).  
First, well revisit our vector
math language and convert scalar-vector multiplies to vectors (by
distributing the scalar-multiply across the vector elements).  Second,
well do a few expression optimizations that compilers typically
do.</p><p height="10" width="0" class="calibre5">Dont worry if the details, such as the tree pattern syntax, are a bit
much at this point in the book.  Your goal is to just to get the gist;
you can revisit these examples if you need to do tree rewrites in the
future. Well see plenty of tree pattern matching in future chapters
such as Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a>. There, well match subtrees and
execute actions rather than doing rewrites (which are a little harder
to absorb at first).  </p><h4 class="calibre26">Rewriting and Simplifying Scalar-Vector Multiplication</h4><p height="10" width="0" class="calibre5">Lets say we want to 
rewrite the tree for input <code class="calibre21">4 * [0,
5*0, 3]</code> to be <code class="calibre21">[4*0, 4*5*0, 4*3]</code>.
Then, for fun, we want to simplify multiply-by-zero operations,
yielding <code class="calibre21">[0, 0, 4*3]</code>. Refer to the transformation sequence in
tree form in Figure 12, <a href="#text/part0000_split_061.html.fig.vecmult-simplify"><em class="calibre6">Simplification of 4 * [0, 5*0, 3] via AST rewriting</em></a>. The original AST on the left in that figure comes to us
courtesy of <code class="calibre21">VecMath.g</code>, an AST-constructing parser
grammar used throughout this chapter.</p><div class="calibre1" id="text/part0000_split_061.html.fig.vecmult-simplify"><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5"><code class="calibre21">4 * [0, 5*0, 3]</code></p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5"><code class="calibre21">[4*0, 4*5*0, 4*3]</code></p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5"><code class="calibre21">[0, 0, 4*3]</code></p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td width="24%" class="calibre11"><div class="calibre1"><img id="text/part0000_split_061.html.d24e14442" class="calibre2" src="data:image/gif;base64,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" alt="images/walking/t1.png"></div></td><td width="49%" class="calibre11"><div class="calibre1"><img id="text/part0000_split_061.html.d24e14444" class="calibre2" src="data:image/gif;base64,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" alt="images/walking/t1.dist.png"></div></td><td width="27%" class="calibre11"><div class="calibre1"><img id="text/part0000_split_061.html.d24e14446" class="calibre2" src="data:image/gif;base64,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" alt="images/walking/t1.final.png"></div></td></tr></tbody></table></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Tree rewrites in ANTLR consist of a tree pattern to match and a tree
pattern to generate. They look like tree grammar fragment to fragment
transformations.  To multiply a scalar across a vector is a bit
tricky, so lets break it down.
Here is the tree pattern that matches a scalar multiply whose
second operand is a vector subtree:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">^('*' INT ^(VEC .+))&nbsp;&nbsp; // '*' at root with 2nd child as vector</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In a complete tree grammar, wed have to specify what the vector
children looked like because we have to direct the walk. Tree pattern
<code class="calibre21">^(VEC .+)</code> matches any number of child nodes
or subtrees under a <code class="calibre21">VEC</code> root. To perform the
multiply transformation, we need to track the children and include
them in the new <code class="calibre21">VEC</code> tree
(<code class="calibre21">e+=.</code> puts all children into list
<code class="calibre21">$e</code>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Simplify.g">walking/patterns/Simplify.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">scalarVectorMult : ^(<em class="calibre6">'*'</em> INT ^(VEC (e+=.)+)) -&gt; ^(VEC ^(<em class="calibre6">'*'</em> INT $e)+) ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The tree rewrite fragment to the right of the <code class="calibre21">-&gt;</code> creates a vector
whose children are scalar multiply subtrees.  Pattern <code class="calibre21">^('*' INT $e)+</code>
is a one-or-more loop around a multiply subtree. It makes a new
multiply subtree for each element held in list <code class="calibre21">$e</code>.</p><p height="10" width="0" class="calibre5">When we create new multiply subtrees, we sometimes create multiply
by zero subtrees.  To simplify things like <code class="calibre21">5*0</code> to <code class="calibre21">0</code>, we need to
replace multiply subtrees where an operand is <code class="calibre21">0</code> with <code class="calibre21">0</code>. Here are
the rules we need:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Simplify.g">walking/patterns/Simplify.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">zeroX : ^(<em class="calibre6">'*'</em> a=INT b=INT {$a.int==0}?) -&gt; $a ; <em class="calibre6">// 0*x -&gt; 0</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">xZero : ^(<em class="calibre6">'*'</em> a=INT b=INT {$b.int==0}?) -&gt; $b ; <em class="calibre6">// x*0 -&gt; 0</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The tree patterns themselves match any integer multiply subtree.  The
predicates, such as <code class="calibre21">{$a.int==0}</code>?, prevent the alternatives from
matching unless one of the integers has a 0 value.</p><p height="10" width="0" class="calibre5">The only thing left to specify is which rule to apply on the way down and
which rules to apply on the way up. Rather than add special syntax,
ANTLR asks you to define special rules:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Simplify.g">walking/patterns/Simplify.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">topdown : scalarVectorMult ; <em class="calibre6">// tell ANTLR when to attempt which rule</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">bottomup: zeroX | xZero ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">ANTLR does a depth first search, applying <code class="calibre21">topdown</code> rules upon node
discovery and <code class="calibre21">bottomup</code> rules upon node finishing.</p><p height="10" width="0" class="calibre5">If we did the scalar-vector multiply bottom-up, wed miss
multiply-by-zero opportunities created by distributing the multiply
by 4 across the vector.  In a bottom-up traversal, wed visit the
elements of the vector first, then the vector itself, and finally the
multiplication above the vector. We would not revisit the vector
elements again to reduce <code class="calibre21">4*0</code> to <code class="calibre21">0</code>.</p><p height="10" width="0" class="calibre5"> Multiply-by-zero rewrites,on the other hand, cant be done
top-down. In subtree <code class="calibre21">(* 4 (* 5 0))</code>, wed only rewrite the <code class="calibre21">(* 5 0)</code>,
yielding <code class="calibre21">(* 4 0)</code>.  Instead, we want reductions to bubble up the
expression tree. Using a bottom-up traversal, <code class="calibre21">(* 5 0)</code> becomes
<code class="calibre21">0</code>, and then we rewrite the resulting <code class="calibre21">(* 4 0)</code> subtree to be <code class="calibre21">0</code>.</p><p height="10" width="0" class="calibre5">To test all this, we first need to have the <code class="calibre21">VecMath</code> parser
build us an initial AST from the input. Then, we need to invoke a
down up rule application strategy on that AST.  The <tt class="calibre21">downup</tt>
method in ANTLRs <code class="calibre21">TreeRewriter</code> class launches the tree walk. Here
is a test rig:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Test.java">walking/patterns/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"Original tree: "</em>+t.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Traverse tree down then up, applying rewrite rules</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Simplify s = <b class="calibre13">new</b> Simplify(nodes);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">t = (CommonTree)s.downup(t, true); <em class="calibre6">// walk t, trace transforms</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"Simplified tree: "</em>+t.toStringTree());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Test file <code class="calibre21">t1</code> contains <code class="calibre21">x = 4 * [0, 5*0, 3]</code>.  Running our test rig
on it shows the original tree, the intermediate transformations, and
the final tree:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t1 </b><em class="calibre6"># t1 is "x = 4 * [0, 0*5, 3]"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Original tree: (= x (* 4 (VEC 0 (* 0 5) 3)))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 4 (VEC 0 (* 0 5) 3)) -&gt; (VEC (* 4 0) (* 4 (* 0 5)) (* 4 3))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 4 0) -&gt; 0&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 0 5) -&gt; 0&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 4 0) -&gt; 0&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Simplified tree: (= x (VEC 0 0 (* 4 3)))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In this example, we needed to apply only one rule for a given
subtree. Sometimes, though, we need to repeatedly apply rules to a
single subtree until nothing changes. In the next example, well look
at gradually morphing expression subtrees to get simpler operations.</p><h4 class="calibre26">Applying Optimizations Repeatedly to a Single Subtree</h4><p height="10" width="0" class="calibre5">Compiler optimizers try to reduce operations to simpler equivalents in
an effort to generate faster code. For example, a compiler might
reduce <code class="calibre21">3+3</code> to the equivalent <code class="calibre21">3&lt;&lt;1</code>, which is a fast shift left by
one bit (multiply by 2).  Thats a pretty big jump, though, so it
might try to convert <code class="calibre21">3+3</code> to <code class="calibre21">2*3</code> first. Then, it could rewrite the
multiply to be a left shift. We can also combine contiguous shifts
such as <code class="calibre21">x&lt;&lt;1&lt;&lt;2</code> into <code class="calibre21">x&lt;&lt;3</code>. 
  To get the ball rolling, lets provide a rewrite for the addition of
identical operands:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Reduce.g">walking/patterns/Reduce.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// x+x -&gt; 2*x&nbsp;&nbsp;(notation INT["2"] creates an INT node with text "2")</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">xPlusx: ^(<em class="calibre6">'+'</em> i=INT j=INT {$i.int==$j.int}?) -&gt; ^(MULT[<em class="calibre6">"*"</em>] INT[<em class="calibre6">"2"</em>] $j);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">{$i.int==$j.int}?</code> predicate ensures that the pattern matches
only when the operands are the same.</p><p height="10" width="0" class="calibre5">To replace multiply by 2 subtrees, we match an integer multiply
subtree and use a predicate to verify that the integer operand is
<code class="calibre21">2</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Reduce.g">walking/patterns/Reduce.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// 2*x to be x&lt;&lt;1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">multBy2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'*'</em> x=INT {$x.int==2}? y=.) -&gt; ^(SHIFT[<em class="calibre6">"&lt;&lt;"</em>] $y INT[<em class="calibre6">"1"</em>])</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(<em class="calibre6">'*'</em> a=. b=INT {$b.int==2}?) -&gt; ^(SHIFT[<em class="calibre6">"&lt;&lt;"</em>] $a INT[<em class="calibre6">"1"</em>])</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Finally, we need to combine adjacent shift operators. The following
rule matches a shift subtree whose left child is also a shift
subtree. The right operands of the shift operators must be integers in
order for us to combine them.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Reduce.g">walking/patterns/Reduce.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">combineShifts <em class="calibre6">// x&lt;&lt;n&lt;&lt;m to be x&lt;&lt;(n+m)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;^(SHIFT ^(SHIFT e=. n=INT) m=INT)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; ^(SHIFT[<em class="calibre6">"&lt;&lt;"</em>] $e INT[String.valueOf($n.int+$m.int)])</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To specify that ANTLR should apply these rules bottom-up, we list them
as alternatives in the <code class="calibre21">bottomup</code> rule (there is nothing to do on the
way down).</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Reduce.g">walking/patterns/Reduce.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">bottomup <em class="calibre6">// match these rules bottom-up</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;xPlusx</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;multBy2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;combineShifts</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">By default, ANTLRs down then up strategy repeatedly applies
bottom-up rules until nothing changes.  If, for example, we 
applied the <code class="calibre21">bottomup</code> rules only once, wed leave <code class="calibre21">3+3</code> as <code class="calibre21">2*3</code> rather
than <code class="calibre21">3&lt;&lt;1</code>.</p><p height="10" width="0" class="calibre5">Lets see our transformations in action using test rig <code class="calibre21">Test2</code>. It
differs from <code class="calibre21">Test</code> only in that calls <tt class="calibre21">downup</tt> on the tree pattern
matcher <code class="calibre21">Reduce.g</code>, not <code class="calibre21">Simplify.g</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/walking/patterns/Test2.java">walking/patterns/Test2.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"Original tree: "</em>+t.toStringTree());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Reduce red = <b class="calibre13">new</b> Reduce(nodes);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">t = (CommonTree)red.downup(t, true); <em class="calibre6">// walk t, trace transforms</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"Simplified tree: "</em>+t.toStringTree());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Test file <code class="calibre21">u1</code> contains <code class="calibre21">x = 2*(3+3)</code>.  Running <code class="calibre21">Test2</code> on it shows
the original tree, the intermediate reductions, and the final tree (with manually added comments):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test2 &lt; u1 </b><em class="calibre6"># u1 is "x = 2*(3+3)"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Original tree: (= x (* 2 (+ 3 3)))&nbsp;&nbsp;&nbsp;&nbsp; # x = 2*(3+3)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(+ 3 3) -&gt; (* 2 3)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 2 3) -&gt; (&lt;&lt; 3 1)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(* 2 (&lt;&lt; 3 1)) -&gt; (&lt;&lt; (&lt;&lt; 3 1) 1)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">(&lt;&lt; (&lt;&lt; 3 1) 1) -&gt; (&lt;&lt; 3 2)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Simplified tree: (= x (&lt;&lt; 3 2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# reduced to x = 3 &lt;&lt; 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If youre curious to learn more about how ANTLR implements tree
pattern matching on top of tree grammars, please see <code class="calibre21">TreeParser</code>
subclasses <code class="calibre21">TreeFilter</code> and <code class="calibre21">TreeRewriter</code> in package
<code class="calibre21">org.antlr.runtime.tree</code>.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern uses tree grammar fragments (Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>) to match subtrees.  Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a> and Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a> use tree
pattern matchers extensively.
</p>

</div></div>
<div id="text/part0000_split_062.html"><div class="calibre">

<h2 id="text/part0000_split_062.html.d24e14909" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">In the next chapter, were going to start analyzing sentences by
walking trees using these patterns.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-14" href="#text/part0000_split_057.html.FNPTR-14">[14]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.meta-environment.org">http://www.meta-environment.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-15" href="#text/part0000_split_057.html.FNPTR-15">[15]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://strategoxt.org">http://strategoxt.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-16" href="#text/part0000_split_057.html.FNPTR-16">[16]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://tom.loria.fr">http://tom.loria.fr</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-17" href="#text/part0000_split_061.html.FNPTR-17">[17]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.meta-environment.org">http://www.meta-environment.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-18" href="#text/part0000_split_061.html.FNPTR-18">[18]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://strategoxt.org">http://strategoxt.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-19" href="#text/part0000_split_061.html.FNPTR-19">[19]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.meta-environment.org/Meta-Environment/Documentation">http://www.meta-environment.org/Meta-Environment/Documentation</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_062.html.FOOTNOTE-20" href="#text/part0000_split_061.html.FNPTR-20">[20]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://buildfarm.st.ewi.tudelft.nl/releases/strategoxt/strategoxt-manual-unstable-latest/manual">http://buildfarm.st.ewi.tudelft.nl/releases/strategoxt/strategoxt-manual-unstable-latest/manual</a></p></dd></dl><div class="calibre3" id="text/part0000_split_062.html.calibre_pb_84"></div>

</div></div>
<div id="text/part0000_split_063.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_063.html.calibre_pb_85">&nbsp;</p><a id="text/part0000_split_063.html.toc-12"></a><h4 class="right2" id="text/part0000_split_063.html.chp.symtab">Chapter 6</h4>
</div></div>
<div id="text/part0000_split_064.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_064.html.calibre_pb_86">Tracking and Identifying Program Symbols</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">The previous chapters gave us three critical language implementation
skills. We can now write parsers for input sentences, we can make
parsers build abstract syntax trees, and we can build tree walkers
that visit or rewrite those trees. That means were almost ready to
tackle <em class="calibre6">semantic analysis</em>. Semantic analysis is just a fancy
way to say were sniffing a program to see whether it makes sense. The
term <em class="calibre6">semantics</em> is synonymous with meaning.</p><p height="10" width="0" class="calibre5">Well explore semantic analysis in Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>,
but we need to build some infrastructure before we get there.  To
enforce language semantics, we need to track symbol definitions and be
able to identify those symbols later. (A symbol is just a name for a
program entity like a variable or method.) Its like keeping track of
characters in a novel. Novels introduce characters and then refer to
them later.  To understand the story, weve got to remember each
character and something about their attributes.  Killing off a
character means there should be no further references to it (as being alive).
Similarly, computer language sentences can define and reference
symbols in code blocks. At the end of the code block, the symbols go
out of scope.</p><p height="10" width="0" class="calibre5">Language applications track symbols in an abstract data structure
called a <em class="calibre6">symbol table</em>.</p><p height="10" width="0" class="calibre5">In this chapter, we will define and
implement two basic symbol table patterns:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>. 
All symbols exist within a single scope
(set of symbols).  Simple property files and early BASIC are the best
examples.</li><li height="6" class="calibre20"><span></span>Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>. 
There are multiple scopes
and scopes can nest inside other scopes.  C is a typical language that
has nested scopes.  Scopes start and end at the start and end
of language structures such as functions.</li></ul><p height="10" width="0" class="calibre5">Each pattern includes sample code that shows how to populate and query
the symbol table.  To get the most out of these patterns, we need to
learn about representing program symbols, grouping symbols into
scopes, and resolving symbols to their definitions.</p>

</div></div>
<div id="text/part0000_split_065.html"><div class="calibre">

<h2 id="text/part0000_split_065.html.sec.info-sym" class="calibre18">Collecting Information About Program Entities</h2><p height="10" width="0" class="calibre5">To build a symbol table, we need to formalize what we do
implicitly when we read and write software. 
First, lets figure
out how to represent program entities.  Take a look at the following
C++ code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class T {  };&nbsp;&nbsp;<em class="calibre6">// define class T</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">T f() {  }&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define function f returning type T</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// define variable x of type int</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We unconsciously define three <em class="calibre6">symbols</em> (program
entities) in our head: class <code class="calibre21">T</code>, function
<code class="calibre21">f</code>, and variable
<code class="calibre21">x</code>.  To build a language application, we
need to mimic this in software.  For those definitions, we need to do
something like the following:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Type</b> c = <b class="calibre13">new</b> ClassSymbol(<em class="calibre6">"T"</em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define class</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MethodSymbol m = <b class="calibre13">new</b> MethodSymbol(<em class="calibre6">"f"</em>, c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define method</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Type</b> intType = <b class="calibre13">new</b> BuiltInTypeSymbol(<em class="calibre6">"int"</em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define int type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">VariableSymbol v = <b class="calibre13">new</b> VariableSymbol(<em class="calibre6">"x"</em>, intType); <em class="calibre6">// define var x</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Those constructors pretty much tell us what we need to know for each
symbol. But, to be explicit, each of those symbols has at least the following
three key properties:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Name</em>:  
Symbols are usually identifiers like <code class="calibre21">x</code>, <code class="calibre21">f</code>,
and <code class="calibre21">T</code>, but they can be operators too. For example, in Ruby, we can
use operators like <code class="calibre21">+</code> as method names.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Category</em>: 
That is, what kind of thing the symbol
is. Is it a class, method, variable, label, and so on.  To validate
method call <code class="calibre21">f()</code>, for example, we need to know that <code class="calibre21">f</code> is a method,
not a variable or class.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Type</em>:  
To validate operation <code class="calibre21">x+y</code>, for example, we
need to know the types of <code class="calibre21">x</code> and <code class="calibre21">y</code>.  Dynamically typed languages
like Python track type information at run-time. Statically typed
languages like C++ and Java track type information at compile time.
The programmer usually has to explicitly identify each symbols
type (in some languages, the compiler infers it).</li></ul><p height="10" width="0" class="calibre5">We distinguish program entities via these three parameters.  For
example, function <code class="calibre21">f</code> that returns a string is obviously different
from a variable of type integer called <code class="calibre21">x</code>.  In a novel, we might have
an elf character (the category) called Sri (the name) that becomes a
soldier (the type).</p><p height="10" width="0" class="calibre5">A symbol table implements each symbol category with a separate class,
holding the name and type as properties. We can factor out those
shared properties into a common <code class="calibre21">Symbol</code> superclass:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Symbol {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> name; <em class="calibre6">// All symbols at least have a name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Type</b> type;&nbsp;&nbsp; <em class="calibre6">// Symbols have types</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> <code class="calibre21">VariableSymbol</code> is the simplest program entity category and
looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> VariableSymbol <b class="calibre13">extends</b> Symbol {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VariableSymbol(<b class="calibre13">String</b> name, <b class="calibre13">Type</b> type) { super(name, type); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets turn our attention now to user-defined types like classes and
<code class="calibre21">struct</code>s.  For consistency, lets represent user-defined types like
any other program symbol.  We can derive <code class="calibre21">BuiltInTypeSymbol</code> and <code class="calibre21">ClassSymbol</code> from <code class="calibre21">Symbol</code> (though they dont need the <code class="calibre21">type</code>
field).</p><p height="10" width="0" class="calibre5">To distinguish between user-defined types and other program symbols,
its a good idea to tag types with a 
<code class="calibre21">Type</code> interface. For example,
heres the class that represents built-in types like <code class="calibre21">int</code>
and <code class="calibre21">float</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> BuiltInTypeSymbol <b class="calibre13">extends</b> Symbol <b class="calibre13">implements</b> <b class="calibre13">Type</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> BuiltInTypeSymbol(<b class="calibre13">String</b> name) { super(name); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Theres not much to interface <code class="calibre21">Type</code> because were using it only as
a tag:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">interface</b> Type { <b class="calibre13">public</b> <b class="calibre13">String</b> getName(); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">I like to think of interfaces as roles that classes can play.  In this
case, symbols implementing <code class="calibre21">Type</code> can play the role of a type.  Here
is a typical (partial) class hierarchy showing the categories
subclassing <code class="calibre21">Symbol</code> and types implementing <code class="calibre21">Type</code>:</p><div class="calibre1"><img id="text/part0000_split_065.html.d24e15325" class="calibre2" src="data:image/gif;base64,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" alt="images/symtab/hier1.png"></div><p height="10" width="0" class="calibre5">Representing symbols in our symbol table is not too bad. Things  only 
get interesting  when we have to track those symbols and look
them up again.
</p>

</div></div>
<div id="text/part0000_split_066.html"><div class="calibre">

<h2 id="text/part0000_split_066.html.sec.symtab-scopes" class="calibre18">Grouping Symbols into Scopes</h2><p height="10" width="0" class="calibre5">A scope is a code region with a well-defined boundary that groups
symbol definitions (in a dictionary associated with that code region).
For example, class scopes group members; function scopes group
parameters and local variables.  Scope boundaries usually coincide
with begin and end tokens such as curly braces (sort of like the
hello and goodbye of a phone
conversation).  We call this <em class="calibre6">lexical scoping</em>
because the extent of a scope is lexically delimited. Perhaps a better
term is <em class="calibre6">static scoping</em> because we can track
scopes just by looking at the source code; that is, without executing
it. Heres a list of scope characteristics that often differ between
languages:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Static</em> vs. <em class="calibre6">dynamic scoping</em>: Most
languages have static scoping, but some (like classic LISP and
PostScript) have dynamic scoping. Think of dynamic scoping as allowing
methods to see the local variables of invoking methods.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Named scopes</em>: 
Many scopes, like classes and methods
have names, but global and local scopes dont.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Nesting</em>: 
Languages usually allow some form of scope
nesting. For example, nested code blocks enclosed in curly braces often
introduce new scopes.  C++ and Java allow nested classes.   Languages
typically limit nesting to certain combinations.  Python allows
function definitions within other functions, but Java does not.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Contents</em>: 
Some scopes allow declarations, some allow
statements,  and some allow both. C <code class="calibre21">struct</code>s only allow   declarations.
Pythons global space allows declarations and executable code.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Visibility</em>:The symbols in a scope might or might
not be visible to some other code section. The fields in a C <code class="calibre21">struct</code> are visible to any code section. The fields in a class have
visibility modifiers such as <code class="calibre21">public</code> and <code class="calibre21">private</code> that indicate
which code sections can reference them.  Local variables 
typically arent visible to other functions.</li></ul><p height="10" width="0" class="calibre5">To represent a scope, well use an interface so that we can tag
entities like functions and classes as scopes. For example, a function
is a kind of <code class="calibre21">Symbol</code> that also plays the role of
a scope.  Scopes have pointers to their enclosing scopes (well talk
about this more later) and can have names.  Scopes dont need to track
the code region from which we create them.  Instead, the AST for the
code regions point to their scopes. This makes sense because were
going to look up symbols in scopes according to what we find in the
AST nodes.</p><p height="10" width="0" class="calibre5">For now, we only care about the first three methods in interface
<code class="calibre21">Scope</code> (well learn about
<tt class="calibre21">resolve</tt> in the next section):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">interface</b> Scope {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> getScopeName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// do I have a name?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Scope getEnclosingScope();&nbsp;&nbsp; <em class="calibre6">// am I nested in another?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> define(Symbol sym);&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define sym in this scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol resolve(<b class="calibre13">String</b> name); <em class="calibre6">// look up name in scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To get the ball rolling, lets see what we can do with a single
<code class="calibre21">Scope</code> object.</p><h3 class="calibre23">Monolithic Scopes</h3><p height="10" width="0" class="calibre5">Early programming languages such as BASIC had a single global scope. Today, only simple languages like configuration files have a
single scope. For example, heres a property file:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">host=antlr.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # define properties in single, global scope</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">port=80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# a set can act as a symbol table</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">webmaster=parrt@antlr.org</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Within a scope, a symbol can only represent a single entity.  That
means that redefining a property either overwrites the previous value
or is an error. Tracking symbols for monolithic scope just means
maintaining a set of <code class="calibre21">Symbol</code> objects. As we
encounter definitions, we create symbols and add them to the
set. Later, well look them up again by name.  A dictionary that maps
symbol names to <code class="calibre21">Symbol</code> objects works best for
this.  Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a> defines the symbol
table wed need to handle languages with a single scope.
</p><h3 class="calibre23">Multiple and Nested Scopes</h3><p height="10" width="0" class="calibre5">Having multiple scopes lets us reuse the same name in different
code regions to identify different program entities.  For example,
variable name <code class="calibre21">x</code> in the following methods
refers to two different variables:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() { <b class="calibre13">int</b> x;&nbsp;&nbsp; printf(x); } <em class="calibre6">// this x lives in f's scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> g() { <b class="calibre13">float</b> x; printf(x); } <em class="calibre6">// this x lives in g's scope</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To avoid ambiguity, programming languages use context to figure out
which symbol were talking about. Context corresponds to the scope
surrounding the symbol and any enclosing scopes. Within the context of
method <tt class="calibre21">f</tt>, the <code class="calibre21">x</code>
argument of <tt class="calibre21">printf</tt> resolves to the
<code class="calibre21">int</code> local variable. In the context of
<tt class="calibre21">g</tt>, <code class="calibre21">x</code> resolves to
the <code class="calibre21">float</code> variable. At the close of each
method, the local variables go out of scope (become invisible).
</p><p height="10" width="0" class="calibre5">Programming languages also let us nest one scope within another.
Nesting a scope is like allowing someone to pop into your
office and ask a question while youre already in a meeting. We return
to the meeting after answering the question.  To track nested scopes,
we push and pop scopes onto a scope stack. As we encounter a new
scope, we push it on the scope stack. The top of the stack is called
the <em class="calibre6">current scope</em>.  As we exit a scope, we pop it
off the stack, revealing the previous scope as the current scope.</p><p height="10" width="0" class="calibre5">All symbol definitions occur within the current scope.  For example,
here is some C++ code commented with scope information: </p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define variable x in global scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp; <em class="calibre6">// define function f in global scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> y;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define variable y in local scope of f</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;{ <b class="calibre13">int</b> i; } <em class="calibre6">// define variable i in nested local scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;{ <b class="calibre13">int</b> j; } <em class="calibre6">// define variable j in another nested local scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">5&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> g() {&nbsp;&nbsp; <em class="calibre6">// define function g in global scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> i;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define variable i in local scope of g</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The numbered icons identify the various scopes.  The following diagram
shows what the scope stack looks like after the definition of each new
symbol. The stack grows and shrinks over time (growing upward) as
we push and pop scopes.</p><div class="calibre1"><img id="text/part0000_split_066.html.d24e15673" class="calibre22" src="data:image/gif;base64,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" alt="images/symtab/scopestack.png"></div><p height="10" width="0" class="calibre5">By popping a scope off the scope stack, were effectively throwing
it away.  In many cases, though, were going to need that scope later
to check sentences for correctness, generate output, and so on.  To
keep everything around, we want a data structure called a<em class="calibre6">scope tree</em> (a tree of
<code class="calibre21">Scope</code>s) that can function like a collection of
stacks. In Figure 13, <a href="#text/part0000_split_066.html.fig.scope-tree"><em class="calibre6">Scope tree for global, function, and local scopes</em></a>, we see the scope tree for the
previous C++ code.  Every path from a node to the scope tree root
represents a stack of scopes.  For example, node <span class="calibre45"></span> has implicit scope stack <span class="calibre45"></span> <span class="calibre45"></span> <span class="calibre45"></span>, and node <span class="calibre45"></span>
has implicit scope stack <span class="calibre45"></span><span class="calibre45"></span>. The levels of the tree correspond to
the scope nesting levels. As we move up a level in the tree, we move
out a level in the program scopes.  Instead of pushing a scope onto a
stack, were going to add a child to a scope tree.</p><div class="calibre1" id="text/part0000_split_066.html.fig.scope-tree"><img id="text/part0000_split_066.html.d24e15710" class="calibre30" src="data:image/gif;base64,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" alt="images/symtab/scopetree.png"><hr class="calibre17"><b class="calibre13">Figure 12. Scope tree for global, function, and local scopes</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The tree might look a little funny because the nodes point at their
parents instead of the reverse.  In practice, though, well look up
symbols by scanning upward toward the root (see the next
section).</p><p height="10" width="0" class="calibre5">Building a scope tree boils down to executing a sequence of these
operations: <code class="calibre21">push</code>,
<code class="calibre21">pop</code>, and <code class="calibre21">def</code>. All of
the patterns in this chapter and the next populate symbol tables using
these core abstract operations.</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><code class="calibre21">push</code>.  
At the start of a scope, push a new scope on the
scope stack.  This works even for complicated scopes like classes.
Because we are building scope trees, <code class="calibre21">push</code> is more like an add
child tree construction operation than a conventional stack push. To
make things more concrete, heres an implementation preview:<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// create new scope whose enclosing scope is the current scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentScope = <b class="calibre13">new</b> LocalScope(currentScope);&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// push new scope</em></code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1"></li><li height="6" class="calibre20"><span></span><code class="calibre21">pop</code>. 
At the end of a scope, pop the current scope off the stack,
revealing the previous scope as the current scope. <code class="calibre21">pop</code> moves the
current scope pointer up one level in the tree:<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentScope = currentScope.getEnclosingScope(); <em class="calibre6">// pop scope</em></code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1"></li><li height="6" class="calibre20"><span></span><code class="calibre21">def</code>. 
Define a symbol in the current scope.  Well always define
symbols like this:<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Symbol s = <em class="calibre6">some-new-symbol</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentScope.define(s); // define s in current scope</code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1"></li></ul><p height="10" width="0" class="calibre5">Lets look at the sequence of operations wed need a parser to
perform in order to build the scope tree in Figure 13, <a href="#text/part0000_split_066.html.fig.scope-tree"><em class="calibre6">Scope tree for global, function, and local scopes</em></a>. For now, dont worry about what triggers
these actions (the pattern implementations go over the details). The
most important thing is the order of the operations (for example, to
get variables into the right scope, their
<code class="calibre21">def</code>s have to appear in between the right
<code class="calibre21">push</code> and <code class="calibre21">pop</code> scope
operations):</p><ol class="calibre46"><li height="8" value="1" class="calibre20"><span></span><code class="calibre21">push</code> global scope <span class="calibre45"></span>.</li><li height="8" value="2" class="calibre20"><span></span><code class="calibre21">def</code> variable <code class="calibre21">x</code> in current scope, <span class="calibre45"></span>.</li><li height="8" value="3" class="calibre20"><span></span><code class="calibre21">def</code> method <code class="calibre21">f</code> in scope <span class="calibre45"></span> and <code class="calibre21">push</code> scope <span class="calibre45"></span>.</li><li height="8" value="4" class="calibre20"><span></span><code class="calibre21">def</code> variable <code class="calibre21">y</code>.</li><li height="8" value="5" class="calibre20"><span></span><code class="calibre21">push</code> local scope <span class="calibre45"></span>.</li><li height="8" value="6" class="calibre20"><span></span><code class="calibre21">def</code> variable <code class="calibre21">i</code>.</li><li height="8" value="7" class="calibre20"><span></span><code class="calibre21">pop</code>&nbsp;<span class="calibre45"></span> revealing <span class="calibre45"></span>.</li><li height="8" value="8" class="calibre20"><span></span><code class="calibre21">push</code> local scope <span class="calibre45"></span>.</li><li height="8" value="9" class="calibre20"><span></span><code class="calibre21">def</code> variable <code class="calibre21">j</code>.</li><li height="8" value="10" class="calibre20"><span></span><code class="calibre21">pop</code>&nbsp;<span class="calibre45"></span> revealing <span class="calibre45"></span>.</li><li height="8" value="11" class="calibre20"><span></span><code class="calibre21">pop</code> function <code class="calibre21">f</code> scope <span class="calibre45"></span> revealing
<span class="calibre45"></span>.</li><li height="8" value="12" class="calibre20"><span></span><code class="calibre21">def</code> method <code class="calibre21">g</code> in scope <span class="calibre45"></span> and <code class="calibre21">push</code> scope <span class="calibre45"></span>.</li><li height="8" value="13" class="calibre20"><span></span><code class="calibre21">def</code> variable <code class="calibre21">i</code>.</li><li height="8" value="14" class="calibre20"><span></span><code class="calibre21">pop</code> function <code class="calibre21">g</code> scope <span class="calibre45"></span> revealing <span class="calibre45"></span>.</li><li height="8" value="15" class="calibre20"><span></span><code class="calibre21">pop</code> global scope <span class="calibre45"></span>.</li></ol><p height="10" width="0" class="calibre5">In the next section, well see how scope trees make it easy to find
the symbols weve squirreled away.
</p>

</div></div>
<div id="text/part0000_split_067.html"><div class="calibre">

<h2 id="text/part0000_split_067.html.sec.symtab-resolving" class="calibre18">Resolving Symbols</h2><p height="10" width="0" class="calibre5">When we see a reference to symbol <code class="calibre21">x</code> in a program, our brain
unconsciously looks for the closest definition. 
In other words, our
brain tries to <em class="calibre6">resolve</em> (identify) which program entity it
refers to.  If weve only  got one scope, resolving a symbol is easy.
Either we find that symbol in that scopes <code class="calibre21">Symbol</code> dictionary, or we
dont. In code, that looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">myOnlyScope.resolve(<em class="calibre6">symbol-name</em>);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">resolve</tt> does nothing more than look
up <em class="calibre6">symbol-name</em> in the scopes dictionary.</p><p height="10" width="0" class="calibre5">When there is more than one scope, though, resolving a symbol
depends on the location of the symbol reference.  In other words, the
same symbol could refer to two different program entities depending on
where the symbol appears in the source code.  References in two
different scopes see two different scope stacks.  A references scope
stack is the set of scopes on the path to the root of the scope tree.
We call this stack the <em class="calibre6">semantic context</em>.</p><p height="10" width="0" class="calibre5">So, to resolve a symbol reference, we look for it in its semantic
context, starting with the current scope. If <tt class="calibre21">resolve</tt> doesnt find
the symbol in the current scope, it asks the enclosing scope if it can
find the symbol. <tt class="calibre21">resolve</tt> recursively walks toward the root of the
scope tree until it finds the symbol or runs out of scopes. The
algorithm looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Symbol resolve(<b class="calibre13">String</b> name) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = members.get(name);&nbsp;&nbsp; <em class="calibre6">// look in this scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s!=null ) <b class="calibre13">return</b> s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// return it if in this scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( enclosingScope != null ) { <em class="calibre6">// have an enclosing scope?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> enclosingScope.resolve(name); <em class="calibre6">// check enclosing scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null; <em class="calibre6">// not found in this scope or there's no scope above</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">enclosingScope</code> variable points to the scope above in the scope
tree (its a parent pointer). Dont let the recursion bother you. Its
just the most convenient way to express the algorithm. The recursion
in <tt class="calibre21">resolve</tt> is essentially equivalent to a loop walking up the <code class="calibre21">enclosingScope</code> chain.</p><p height="10" width="0" class="calibre5">Heres the best part about this algorithm and scope tree combination.
No matter how complicated our scope tree gets, we can always resolve
symbols with the same bit of code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentScope.resolve(<em class="calibre6">symbol-name</em>);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">enclosingScope</code> pointer tells <tt class="calibre21">resolve</tt> exactly where to look
next.  Rather than making a clever algorithm that implements all of
the lookup rules, we assemble a handy data structure that encodes
them.</p><p height="10" width="0" class="calibre5">Lets see how method <tt class="calibre21">resolve</tt> gracefully handles two important
features of nested scopes: we can see symbols in outer scopes, and we
can redefine symbols found in outer scopes. There is a little bit of
variability between languages, but lets see how <tt class="calibre21">resolve</tt> works on
some C++ code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define variable x in global scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define variable y in global space</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define function f in global scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">float</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// redefine x as local variable, hiding outer x</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;printf(<em class="calibre6">"%f"</em>, x); <em class="calibre6">// x resolves to f's local</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;printf(<em class="calibre6">"%d"</em>, y); <em class="calibre6">// y resolves to global</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;{<b class="calibre13">int</b> z;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// local scope nested within f's local scope //</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;printf(<em class="calibre6">"%d"</em>, z); <em class="calibre6">// z is no longer visible; static analysis ERROR!</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">There are three variable references in <code class="calibre21">f</code>,
all in <code class="calibre21">printf</code> calls.  The semantic context
for the <code class="calibre21">x</code>, <code class="calibre21">y</code>, and
<code class="calibre21">z</code> references in <code class="calibre21">f</code> is
<span class="calibre45"></span><span class="calibre45"></span>.  That means we should look up
all symbol references starting in scope <span class="calibre45"></span>.  To resolve
<code class="calibre21">x</code>, <tt class="calibre21">resolve</tt>
immediately finds it in <span class="calibre45"></span>.
<tt class="calibre21">resolve</tt> doesnt find
<code class="calibre21">y</code> in the current scope but does find it in
enclosing scope <span class="calibre45"></span>.  We
cant resolve <code class="calibre21">z</code> in the
<code class="calibre21">printf</code>, though, because
<code class="calibre21">z</code> is defined in <span class="calibre45"></span>. That scope is not in the
<code class="calibre21">z</code> references semantic
context. <tt class="calibre21">resolve</tt> returns null in this case,
signaling an error.</p><p height="10" width="0" class="calibre5">As you can see, the structure of the scope tree reduces the complexity
of symbol resolution to a simple walk up a tree (even when we tackle
class inheritance in Chapter 7, <a href="#text/part0000_split_071.html.chp.aggr-symtab"><em class="calibre6">Managing Symbol Tables for Data Aggregates</em></a>). Throughout the patterns that
follow, well refer to this abstract reference resolution operation as
<code class="calibre21">ref</code>. In total, that gives us four key abstract operations: <code class="calibre21">push</code>,
<code class="calibre21">pop</code>, and <code class="calibre21">def</code> to construct scope trees and <code class="calibre21">ref</code> to resolve
references in the scope tree.  Armed with these operations and a good
handle on symbol table management, were ready to tackle our first two
symbol table patterns. Heres a summary of when to apply the patterns:
</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This pattern applies
to any language that defines symbols all in one scope.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">If your language allows
multiple scopes or even nested scopes, youll need this pattern.
</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">As we progress through the symbol table and semantic analysis patterns
defined in the next few chapters, we should work with a common language
for continuity purposes.  Lets use a subset of C++ and call it
Cymbol.<a id="text/part0000_split_067.html.FNPTR-21" href="#text/part0000_split_070.html.FOOTNOTE-21">[21]</a> Well start
with just variable definition syntax and trivial expressions. Then,
well add functions, <code class="calibre21">struct</code>s, and finally classes.  To keep
things simple, well avoid pointers until absolutely necessary and
well disregard executable statements (theyre not involved in symbol
definition).</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_068.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_068.html.tip.monolithic-symtab" class="pagebreak2"><small class="calibre35">Pattern 16:</small>&nbsp;&nbsp;&nbsp;Symbol Table for Monolithic Scope</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern builds a symbol table for a language with a single,
flat scope.</em>
</p><p height="10" width="0" class="calibre5">This pattern is suitable for simple programming languages (without
functions), configuration files, small graphics languages, and other
small DSLs.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The primary goal when building a symbol table is to construct a
scope tree.  In this case, the scope tree is pretty boring since its
a single node (the global scope).  The following table indicates how
to build the single scope by responding to input constructs. We
technically dont need to push and pop scopes for this simple case, but
well do so for consistency with the other patterns.</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Upon</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Action(s)</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Start of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">GlobalScope</code>. <code class="calibre21">def</code>&nbsp;<code class="calibre21">BuiltInType</code> objects for any built-in types such as <code class="calibre21">int</code> and <code class="calibre21">float</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Declaration <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref x</code>s type (if any). <code class="calibre21">def</code>&nbsp;<code class="calibre21">x</code> in the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Reference <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref</code>&nbsp;<code class="calibre21">x</code> starting in the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">End of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code> the <code class="calibre21">GlobalScope</code>.</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">Lets apply those actions to the following Cymbol declarations:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/t.cymbol">symtab/monolithic/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> i = 9;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">float</b> j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> k = i+2;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Wed execute the following sequence: <code class="calibre21">push</code>
global scope, <code class="calibre21">def int</code>, <code class="calibre21">def
float</code>, <code class="calibre21">ref int</code>, <code class="calibre21">def
i</code>, <code class="calibre21">ref float</code>, <code class="calibre21">def
j</code>, <code class="calibre21">ref int</code>, <code class="calibre21">def
k</code>, <code class="calibre21">ref i</code>,
<code class="calibre21">pop</code> global scope.  The built-in type
definitions are part of symbol table initialization; the parser
doesnt trigger those actions because of an input statement. In simple
terms, were creating the global scope and then defining three
variables: <code class="calibre21">i</code>, <code class="calibre21">j</code>, and
<code class="calibre21">k</code>. To define a variable, we have to
look up its type.  We also have to look up variables referenced in
initialization expressions.</p><p height="10" width="0" class="calibre5">To populate our symbol table, we need objects to represent variables
and built-in types.  Well tag type symbols with interface <code class="calibre21">Type</code>
and then make our symbol table object play the role of a scope using
interface <code class="calibre21">Scope</code>.  The class inheritance and interface
implementation hierarchy looks like this:</p><div class="calibre1"><img id="text/part0000_split_068.html.d24e16511" class="calibre30" src="data:image/gif;base64,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" alt="images/symtab/monolithic-hier.png"></div><p height="10" width="0" class="calibre5">The next section provides a complete Cymbol parser and implementations
for these symbol table objects.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Because expressions in this version of Cymbol cannot reference
variables defined later in the file, we can define and properly
reference all symbols in a single pass. 
We only need a parser and a
few actions to demonstrate symbol table management.</p><p height="10" width="0" class="calibre5">For the Cymbol program shown earlier, we need to generate output that
convinces us weve properly managed symbols. So, lets try to generate
the following (which does not show the <code class="calibre21">def</code> operations for built-in types):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 1: ref int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 1: def i</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 2: ref float</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 2: def j</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: ref int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: ref to &lt;i:int&gt;&nbsp;&nbsp;// &lt;i:int&gt; means i has type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: def k</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals: {int=int, j=&lt;j:float&gt;, k=&lt;k:int&gt;, float=float, i=&lt;i:int&gt;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As we encounter variable definitions, well add them to the symbol
table and print a message. As we find variable and type references,
well resolve them and also print a message. Right before terminating,
well print out the symbols in the symbol tables only scope.
To get started, lets define symbols and then move on to tracking
those symbols.  Our generic <code class="calibre21">Symbol</code> object has a name and type
properties:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Symbol.java">symtab/monolithic/Symbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Symbol { <em class="calibre6">// A generic programming language symbol</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// All symbols at least have a name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol(<b class="calibre13">String</b> name) { this.name = name; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol(<b class="calibre13">String</b> name, <b class="calibre13">Type</b> type) {this(name); this.type = type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> getName() { <b class="calibre13">return</b> name; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( type!=null ) <b class="calibre13">return</b> <em class="calibre6">'&lt;'</em>+getName()+<em class="calibre6">":"</em>+type+<em class="calibre6">'&gt;'</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> getName();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This version of Cymbol has two kinds of symbols: variables and
built-in types:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/VariableSymbol.java">symtab/monolithic/VariableSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Represents a variable definition (name,type) in symbol table */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> VariableSymbol <b class="calibre13">extends</b> Symbol {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> VariableSymbol(<b class="calibre13">String</b> name, <b class="calibre13">Type</b> type) { super(name, type); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/BuiltInTypeSymbol.java">symtab/monolithic/BuiltInTypeSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** A symbol for built in types such int, float primitive types */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> BuiltInTypeSymbol <b class="calibre13">extends</b> Symbol <b class="calibre13">implements</b> <b class="calibre13">Type</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> BuiltInTypeSymbol(<b class="calibre13">String</b> name) { super(name); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now we need a dictionary to hold those symbols (its a single-node
tree or a scope stack of depth one). Lets put it in a
<code class="calibre21">SymbolTable</code> object. Because it holds the sole
dictionary (field <code class="calibre21">symbols</code>), we might as
well make <code class="calibre21">SymbolTable</code> itself represent the
<code class="calibre21">Scope</code>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/SymbolTable.java">symtab/monolithic/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">import</b> java.util.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> SymbolTable <b class="calibre13">implements</b> Scope { <em class="calibre6">// single-scope symtab</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>, Symbol&gt; symbols = <b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">String</b>, Symbol&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> SymbolTable() { initTypeSystem(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">void</b> initTypeSystem() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;define(<b class="calibre13">new</b> BuiltInTypeSymbol(<em class="calibre6">"int"</em>));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;define(<b class="calibre13">new</b> BuiltInTypeSymbol(<em class="calibre6">"float"</em>));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Satisfy Scope interface</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> getScopeName() { <b class="calibre13">return</b> <em class="calibre6">"global"</em>; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Scope getEnclosingScope() { <b class="calibre13">return</b> null; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> define(Symbol sym) { symbols.put(sym.name, sym); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol resolve(<b class="calibre13">String</b> name) { <b class="calibre13">return</b> symbols.get(name); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> toString() { <b class="calibre13">return</b> getScopeName()+<em class="calibre6">":"</em>+symbols; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At this point, weve got symbols and a symbol table. Lets give them
a workout by creating a parser for Cymbol.
<code class="calibre21">Cymbol.g</code> defines the Cymbol language, and were
going to insert actions that create symbols, sticks them in the symbol
table, and then resolves them.</p><p height="10" width="0" class="calibre5">The details of the grammar arent important.  The take-away is that
rules recognizing definitions create <code class="calibre21">Symbol</code>
objects and call <tt class="calibre21">define</tt>. Rules referencing
identifiers invoke <tt class="calibre21">resolve</tt> to look them up.
Keep in mind that actions execute according to location in the
grammar.  For example, actions at the end of an alternative execute
after the parser matches that construct.  Actions use terms like
<code class="calibre21">$ID</code> to access the token matched by an
<code class="calibre21">ID</code> token.</p><p height="10" width="0" class="calibre5">First, we need to add a parameter to the start symbol, <code class="calibre21">compilationUnit</code>, so that we can pass in a symbol table:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Cymbol.g">symtab/monolithic/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">grammar</b> Cymbol; <em class="calibre6">// my grammar is called Cymbol</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// define a SymbolTable field in generated parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@members</b> {SymbolTable symtab;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">compilationUnit[SymbolTable symtab] <em class="calibre6">// pass symbol table to start rule</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@init</b> {this.symtab = symtab;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// set the parser's field</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; varDeclaration+ <em class="calibre6">// recognize at least one variable declaration</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> <code class="calibre21">SymbolTable</code> defines two built-in types that we can look up during
variable definitions. Rule <code class="calibre21">type</code> looks up the type name and returns
it as a <code class="calibre21">Type</code> symbol.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Cymbol.g">symtab/monolithic/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">type <b class="calibre13">returns</b> [Type tsym]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@after</b> { <em class="calibre6">// $start is the first tree node matched by this rule</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$start.getLine()+<em class="calibre6">": ref "</em>+$tsym.getName());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'float'</em> {$tsym = (Type)symtab.resolve(<em class="calibre6">"float"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'int'</em>&nbsp;&nbsp; {$tsym = (Type)symtab.resolve(<em class="calibre6">"int"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, rule <code class="calibre21">varDeclaration</code> can create a <code class="calibre21">VariableSymbol</code> with
that <code class="calibre21">Type</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Cymbol.g">symtab/monolithic/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">varDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; type ID (<em class="calibre6">'='</em> expression)? <em class="calibre6">';'</em> <em class="calibre6">// E.g., "int i = 2;", "int i;"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": def "</em>+$ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol vs = new VariableSymbol($ID.text,$type.tsym);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symtab.define(vs);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Expression <code class="calibre21">$type.tsym</code> evaluates to the return value from invoking
rule <code class="calibre21">type</code>. </p><p height="10" width="0" class="calibre5">
And, finally, we have to resolve symbol references. 
The only place in the grammar where we reference variables is in declaration
initialization expressions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Cymbol.g">symtab/monolithic/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID <em class="calibre6">// reference variable in an expression</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": ref to "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symtab.resolve($ID.text));}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; INT&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'('</em> expression <em class="calibre6">')'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To exercise the symbol table management in our Cymbol grammar, we can
use the following test rig:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/monolithic/Test.java">symtab/monolithic/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CharStream input = null; <em class="calibre6">// read from filename or stdin</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( args.length&gt;0 ) input = <b class="calibre13">new</b> ANTLRFileStream(args[0]);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> input = <b class="calibre13">new</b> ANTLRInputStream(<b class="calibre13">System</b>.in);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CymbolLexer lex = <b class="calibre13">new</b> CymbolLexer(input);&nbsp;&nbsp;<em class="calibre6">// create lexer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTokenStream tokens = <b class="calibre13">new</b> CommonTokenStream(lex);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CymbolParser p = <b class="calibre13">new</b> CymbolParser(tokens); <em class="calibre6">// create parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">SymbolTable symtab = <b class="calibre13">new</b> SymbolTable();&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// create symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p.compilationUnit(symtab);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// launch parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"globals: "</em>+symtab.symbols);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Heres how to build the rig, run ANTLR on the <code class="calibre21">Cymbol.g</code> grammar, compile, and
run sample input <code class="calibre21">t.cymbol</code> into <code class="calibre21">Test</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 1: ref int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This pattern is a bare-bones symbol table manager. Although its
sufficient for simple DSLs, it mostly serves as a good learning tool
for building more realistic symbol tables.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">The next pattern, Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>, adds functions and nested scopes
to our Cymbol C++ subset.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_069.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_069.html.tip.nested-symtab" class="pagebreak2"><small class="calibre35">Pattern 17:</small>&nbsp;&nbsp;&nbsp;Symbol Table for Nested Scopes</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern tracks symbols and builds a scope tree for languages
with multiple, possibly nested scopes.</em>
</p><p height="10" width="0" class="calibre5">Programming language functions are a good example of nested
scopes. Each function has its own scope that is nested within a global
or class scope. Some languages even support nested function
definitions or multiple local scopes. Many DSLs have nested scopes as
well. The
DOT<a id="text/part0000_split_069.html.FNPTR-22" href="#text/part0000_split_070.html.FOOTNOTE-22">[22]</a>
graphics language, for example, has subgraphs within graphs. This
pattern handles them all gracefully.</p><h3 id="text/part0000_split_069.html.sec.nested-symtab-discussion" class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">To discuss nested scopes, lets add functions to our Cymbol C++
subset.  That means well need a function (method) <code class="calibre21">Symbol</code> and
scopes for globals, parameters, and local variables.  Lets take a
look at some sample input and identify the various scopes using
numbered icons.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/t.cymbol">symtab/nested/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> i = 9;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">float</b> f(<b class="calibre13">int</b> x, <b class="calibre13">float</b> y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">float</b> i;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{ <b class="calibre13">float</b> z = x+y; i = z; } </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">5&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{ <b class="calibre13">float</b> z = i+1; i = z; } </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> i;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">6&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> g()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">7&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;f(i,2);&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Well need two more <code class="calibre21">Symbol</code> subclasses to handle functions and local
scopes.  The following class inheritance and interface implementation
hierarchy identifies all the symbol table objects:</p><div class="calibre1"><img id="text/part0000_split_069.html.d24e17294" class="calibre47" src="data:image/gif;base64,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" alt="images/symtab/nested-hier.png"></div><p height="10" width="0" class="calibre5"> <code class="calibre21">MethodSymbol</code> is both a symbol and a
scope. Methods have two scopes actually: one for the parameters (the
<code class="calibre21">MethodSymbol</code> itself) and one for its local
variables (a <code class="calibre21">LocalScope</code> whose parent is the <code class="calibre21">MethodSymbol</code>).</p><p height="10" width="0" class="calibre5">Now that we know the class names of our symbol table objects, we
can make more explicit scope trees than we could before.  Previous
scope trees (such as Figure 13, <a href="#text/part0000_split_066.html.fig.scope-tree"><em class="calibre6">Scope tree for global, function, and local scopes</em></a>) only really
showed tree structure.  We can see the
scope tree for <code class="calibre21">t.cymbol</code>, mentioned earlier, in Figure 14, <a href="#text/part0000_split_069.html.fig.nested-symtab"><em class="calibre6">Scope tree for global variable and two functions</em></a>; it identifies some
key object properties.  The goal of this pattern is to construct such
scope trees.</p><div class="calibre1" id="text/part0000_split_069.html.fig.nested-symtab"><img id="text/part0000_split_069.html.d24e17321" class="calibre47" src="data:image/gif;base64,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" alt="images/symtab/nested-symtab.png"><hr class="calibre17"><b class="calibre13">Figure 13. Scope tree for global variable and two functions</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><hr class="calibre17"><div id="text/part0000_split_069.html.fig.nested-symtab-rules" class="calibre1"><b class="calibre13">Table 1. Rules for building a scope tree for nested scopes and populating it with symbols</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Upon</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Action(s)</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Start of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">GlobalScope</code>. <code class="calibre21">def</code>&nbsp;<code class="calibre21">BuiltInType</code> objects for <code class="calibre21">int</code>, <code class="calibre21">float</code>, <code class="calibre21">void</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable declaration <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref x</code>s type. <code class="calibre21">def</code>&nbsp;<code class="calibre21">x</code> in the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Method declaration <code class="calibre21">f</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref f</code>s return type. <code class="calibre21">def</code>&nbsp;<code class="calibre21">f</code> in
the current scope and <code class="calibre21">push</code> it as the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">{</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">LocalScope</code> as the new
current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">}</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code>, revealing previous scope as
current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">End of method</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code> the <code class="calibre21">MethodSymbol</code> scope (the parameters).</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Reference <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref</code>&nbsp;<code class="calibre21">x</code> starting in the current scope.  If not found, look in the immediately enclosing
scope (if any).</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">End of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code> the <code class="calibre21">GlobalScope</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5"> In Table 1, <a href="#text/part0000_split_069.html.fig.nested-symtab-rules"><em class="calibre6">Rules for building a scope tree for nested scopes and populating it with symbols</em></a>, we can see the rules laid out for building a scope
tree from nested scopes and resolving symbols in the correct semantic
context.  The sequence of actions for <code class="calibre21">t.cymbol</code> starts like this:
<code class="calibre21">push</code> global scope, <code class="calibre21">def int</code>, <code class="calibre21">def float</code>, <code class="calibre21">def void</code>, <code class="calibre21">ref int</code>, <code class="calibre21">def i</code>, <code class="calibre21">ref
float</code>, <code class="calibre21">def f</code>, <code class="calibre21">push f</code>, <code class="calibre21">ref int</code>, <code class="calibre21">def x</code>, <code class="calibre21">ref float</code>, <code class="calibre21">def y</code>,
push local scope of <code class="calibre21">f</code>, <code class="calibre21">ref float</code>, <code class="calibre21">def i</code>, and so on.

Notice that were not making a distinction between global variables,
parameters, and local variables in terms of symbol table logic; they
are all <code class="calibre21">VariableSymbol</code> objects. The only
difference between them is the scope in which we define them. For
example, we define the parameters for <code class="calibre21">f</code> by
executing <code class="calibre21">def</code> operations after pushing
<code class="calibre21">f</code>s method scope and before pushing its local
scope. </p><p height="10" width="0" class="calibre5">Now that weve got the big picture, lets see how to use these rules
in practice to manage a symbol table for nested scopes.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">For our particular implementation, were going to trigger scope
tree construction actions while walking an AST created from the input
source code. 
We could trigger actions directly in the parser as we did
in Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>, but working on an AST is
more flexible. In Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>, well need to
make multiple passes over the input so we might as well get used to
them now.</p><p height="10" width="0" class="calibre5">Starting from the sample implementation source code in the previous
pattern, we need to do the following to add functions and nested
scopes:</p><ol class="calibre46"><li height="8" value="1" class="calibre20"><span></span><em class="calibre6">Augment syntax to support functions.</em>  We need to
augment grammar <code class="calibre21">Cymbol.g</code> to support function definitions, function
calls, return statements, and nested code blocks.</li><li height="8" value="2" class="calibre20"><span></span><em class="calibre6">Build an AST.</em> We will use AST construction rules in
the parser grammar.</li><li height="8" value="3" class="calibre20"><span></span><em class="calibre6">Define new symbol table objects.</em>  To support scopes,
well need an abstract <code class="calibre21">BaseScope</code> and two concrete implementations: <code class="calibre21">GlobalScope</code> and <code class="calibre21">LocalScope</code>.  <code class="calibre21">BaseScope</code> implements
interface <code class="calibre21">Scope</code>. Finally, well need <code class="calibre21">MethodSymbol</code> that plays
double duty as a <code class="calibre21">Symbol</code> and a <code class="calibre21">Scope</code> (for parameters).</li><li height="8" value="4" class="calibre20"><span></span><em class="calibre6">Walk the AST to populate the symbol table and resolve
variable and method references.</em> Using tree pattern matching
rules, well trigger actions according to Table 1, <a href="#text/part0000_split_069.html.fig.nested-symtab-rules"><em class="calibre6">Rules for building a scope tree for nested scopes and populating it with symbols</em></a>.</li></ol><div class="calibre1" id="text/part0000_split_069.html.fig.nested-ast"><img id="text/part0000_split_069.html.d24e17607" class="calibre47" src="data:image/gif;base64,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" alt="images/symtab/nested-ast.png"><hr class="calibre17"><b class="calibre13">Figure 14. AST for function with nested scopes</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">In this pattern and Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>, well combine symbol definition
and resolution into a single tree walk. In Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>, well
separate them into two tree-walking phases to support forward
references. (Methods can call methods defined later in the
class.)</p><p height="10" width="0" class="calibre5">Before getting into all the gory details, lets assume for the
moment that weve got everything set up to build ASTs from source code.
Because all the magic happens with the AST, lets look at the AST
of a simple function and annotate it with action execution and scope
icons.  In Figure 15, <a href="#text/part0000_split_069.html.fig.nested-ast"><em class="calibre6">AST for function with nested scopes</em></a>, we can see where and when in
the AST we need to execute <code class="calibre21">push</code>,
<code class="calibre21">pop</code>, <code class="calibre21">def</code>, and
<code class="calibre21">ref</code> actions. (Actually, were ignoring
built-in type lookups to reduce clutter.)  Those actions appearing on
the left of an AST node trigger as we discover nodes (on the way down)
and those appearing on the right trigger as we finish nodes (on the
way up).  The dotted lines point from variable reference sites to
declaration sites in the AST (note that the <code class="calibre21">y</code>
reference has no corresponding definition).</p><p height="10" width="0" class="calibre5">To create a scope tree then, all we have to do is a depth-first walk
of the AST, executing actions in the pre- and/or postorder
position. We <code class="calibre21">push</code> as we descend and <code class="calibre21">pop</code> as we ascend. When we see
a symbol, we define or resolve it in the current scope.</p><p height="10" width="0" class="calibre5">On to our implementationthe  following sections summarize the
software in the source code directory for this pattern.</p><h4 class="calibre26">Adding Function Syntax and Building ASTs</h4><p height="10" width="0" class="calibre5">To add functions to Cymbol, well add rules <code class="calibre21">methodDeclaration</code> and
<code class="calibre21">formalParameters</code> to <code class="calibre21">Cymbol.g</code>.  
Beyond the syntax, we have to add
AST construction rules.  For example, here is the previous <code class="calibre21">varDeclaration</code> rule augmented with an AST construction rule:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/Cymbol.g">symtab/nested/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">varDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; type ID (<em class="calibre6">'='</em> expression)? <em class="calibre6">';'</em> -&gt; ^(VAR_DECL type ID expression?)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rule now yields <code class="calibre21">VAR_DECL</code>-rooted subtrees with a type,
an identifier, and an optional initialization expression as children.
Method declarations yield <code class="calibre21">METHOD_DECL</code>-rooted subtrees:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/Cymbol.g">symtab/nested/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">methodDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; type ID <em class="calibre6">'('</em> formalParameters? <em class="calibre6">')'</em> block</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(METHOD_DECL type ID formalParameters? block)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Parsing and AST construction are not the primary focus here, so lets
move on to building the scope tree.</p><h4 class="calibre26">Building the Scope Tree</h4><p height="10" width="0" class="calibre5">The rules we defined earlier for building scope trees (in Table 1, <a href="#text/part0000_split_069.html.fig.nested-symtab-rules"><em class="calibre6">Rules for building a scope tree for nested scopes and populating it with symbols</em></a>) are of the form upon an input construct <em class="calibre6">foo</em>, execute action <em class="calibre6">bar</em>. The most direct implementation is a
set of tree pattern-action pairs.  
For example, at the starting <code class="calibre21">{</code> of
a code block, we need to <code class="calibre21">push</code> a new scope. At the ending <code class="calibre21">}</code> of a
block, we need to <code class="calibre21">pop</code> that same scope off. The phrases at the
start and at the end are synonymous with on the way down and
on the way up the AST.  Here are the tree pattern matching rules
that handle pushing and popping local scopes:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/DefRef.g">symtab/nested/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">enterBlock&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; BLOCK {currentScope = new LocalScope(currentScope);}<em class="calibre6">// push scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">exitBlock&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; BLOCK</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"locals: "</em>+currentScope);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = currentScope.getEnclosingScope();&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// pop scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rules match the same <code class="calibre21">BLOCK</code> node but do different actions (<code class="calibre21">push</code>
vs. <code class="calibre21">pop</code>) depending on whether we are discovering or finishing
that node. We control which rules to execute on the way down vs. on
the way up by listing them in the special <code class="calibre21">topdown</code> or <code class="calibre21">bottomup</code> rules:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">topdown : enterBlock | enterMethod |  ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">bottomup : exitBlock | exitMethod |  ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To manage method scopes, we create a method symbol and <code class="calibre21">push</code> it on
the way down. On the way back up, we dont need to look inside the
method subtree, so we match just the <code class="calibre21">METHOD_DECL</code> root.  Here are the
rules that deal with method definition subtrees:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/DefRef.g">symtab/nested/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">enterMethod <em class="calibre6">// match method subtree with 0-or-more args</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(METHOD_DECL type ID .*)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": def method "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type retType = $type.tsym; <em class="calibre6">// rule type returns a Type symbol</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodSymbol ms = new MethodSymbol($ID.text,retType,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentScope);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope.define(ms); <em class="calibre6">// def method in globals</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = ms;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// set current scope to method scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">exitMethod&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; METHOD_DECL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"args: "</em>+currentScope);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = currentScope.getEnclosingScope();<em class="calibre6">// pop method scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You might be wondering where we create the local scopes for methods.
Rule <code class="calibre21">enterBlock</code> creates them automatically for us since method ASTs
contain <code class="calibre21">BLOCK</code> subtrees (see Figure 15, <a href="#text/part0000_split_069.html.fig.nested-ast"><em class="calibre6">AST for function with nested scopes</em></a>).</p><h4 class="calibre26">Populating the Symbol Table</h4><p height="10" width="0" class="calibre5">Now that weve got the proper scope tree structure, we just have to
fill the scopes with symbols as we walk the AST. 
Fortunately, all
definitions do the same thing: create the appropriate
<code class="calibre21">Symbol</code> and then call
<code class="calibre21">Scope</code>.<tt class="calibre21">define</tt>.</p><p height="10" width="0" class="calibre5">Here is
the rule to define any kind of variable:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/DefRef.g">symtab/nested/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">varDeclaration <em class="calibre6">// global, parameter, or local variable</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^((ARG_DECL|VAR_DECL) type ID .?)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": def "</em>+$ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol vs = new VariableSymbol($ID.text,$type.tsym);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope.define(vs);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Field <code class="calibre21">currentScope</code> is always set to the current scope. Our tree
pattern matcher always defines symbols within the current scope.</p><p height="10" width="0" class="calibre5">Lets do the opposite now and find those definitions in the scope
tree.</p><h4 class="calibre26">Resolving Variable and Method References</h4><p height="10" width="0" class="calibre5">In Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, well be looking up symbols all
the time to do type checking and so on. 
To give you a taste, here is a
rule that looks up all identifiers that appear in expressions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/DefRef.g">symtab/nested/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">idref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; {$start.hasAncestor(EXPR)}? ID</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = currentScope.resolve($ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": ref "</em>+s);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">hasAncestor</tt> predicate permits rule <code class="calibre21">idref</code> to match an <code class="calibre21">ID</code> only
when it sits somewhere under an <code class="calibre21">EXPR</code> node.</p><p height="10" width="0" class="calibre5">Lets give it the old smoke test.  The test rig in the source code
directory builds an AST from the source code and then walks the AST using
ANTLRs built-in <tt class="calibre21">downup</tt> strategy:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/nested/Test.java">symtab/nested/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTree t = (CommonTree)r.getTree(); <em class="calibre6">// get tree result from parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.setTokenStream(tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">SymbolTable symtab = <b class="calibre13">new</b> SymbolTable(); <em class="calibre6">// make global scope, types</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">DefRef def = <b class="calibre13">new</b> DefRef(nodes, symtab); <em class="calibre6">// use custom constructor</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">def.downup(t); <em class="calibre6">// trigger symtab actions upon certain subtrees</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"globals: "</em>+symtab.globals);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To build all this, run ANTLR on the grammars and compile:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g DefRef.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Here is what the output looks like when we run the test rig against
the Cymbol source code in Figure 15, <a href="#text/part0000_split_069.html.fig.nested-ast"><em class="calibre6">AST for function with nested scopes</em></a>:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t2.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 2: def method f</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 2: def x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 4: def i</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: def z</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: ref &lt;x:int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: ref null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// y is not defined, resolves to null</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: ref &lt;z:float&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: assign to &lt;i:float&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: [z]&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: [i]&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">args: method&lt;f:float&gt;:[&lt;x:int&gt;]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals: [int, float, void, f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern serves as the foundation for Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a> and Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.
</p>

</div></div>
<div id="text/part0000_split_070.html"><div class="calibre">

<h2 id="text/part0000_split_070.html.d24e18113" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">Now that youre comfortable with nested scopes, you could build
most of the symbol table infrastructure to track symbols for C. The
only involved concept we havent covered is the
<code class="calibre21">struct</code> data aggregate. Well remedy that in the
next chapter.</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_070.html.FOOTNOTE-21" href="#text/part0000_split_067.html.FNPTR-21">[21]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">Not to be confused with the Cymbal language
(registered trademark) in the AT&amp;T Daytona project; <a href="http://www.research.att.com/~daytona/">http://www.research.att.com/~daytona/</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_070.html.FOOTNOTE-22" href="#text/part0000_split_069.html.FNPTR-22">[22]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.graphviz.org">http://www.graphviz.org</a></p></dd></dl><div class="calibre3" id="text/part0000_split_070.html.calibre_pb_93"></div>

</div></div>
<div id="text/part0000_split_071.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_071.html.calibre_pb_94">&nbsp;</p><a id="text/part0000_split_071.html.toc-13"></a><h4 class="right2" id="text/part0000_split_071.html.chp.aggr-symtab">Chapter 7</h4>
</div></div>
<div id="text/part0000_split_072.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_072.html.calibre_pb_95">Managing Symbol Tables for Data Aggregates</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">In the previous chapter, we learned the basics about symbol table
management. We looked at defining symbols, grouping them into scopes,
and organizing those scopes into scope trees. Scope trees are
crucial because their structure encodes the rules for looking up
symbols.  Resolving a symbol means looking for it in the current scope
or any scope on the path to the root of the scope tree.</p><p height="10" width="0" class="calibre5">In this chapter, were going to learn about another kind of scope
called a 
<em class="calibre6">data aggregate scope</em>.  Like any other
scope, it contains symbols and has a place within the scope tree. The
difference is that code outside of a data aggregate scope can access
the members inside using an expression such as
<code class="calibre21">user.name</code>.  Were going to cover data
aggregate scopes for both non-object-oriented and object-oriented
languages:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>. 
This pattern tells us how
to define and access the fields of simple data aggregates such as C
<code class="calibre21">struct</code>s.</li><li height="6" class="calibre20"><span></span>Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.  
This pattern tells us how
to deal with data aggregates that have superclasses and that allow
function definitions as well as fields.</li></ul><p height="10" width="0" class="calibre5"><code class="calibre21">struct</code>s and classes are pretty similar in that
both are simultaneously <code class="calibre21">Symbol</code>s, user-defined
types, and scopes.  The biggest difference is that class
scopes have a superclass scope as well as the usual enclosing
scope. To resolve symbols, well need to modify our algorithm slightly
to chase the proper parent pointer in the scope tree. We also need
to make an extra pass over the AST to deal with forward references.</p><p height="10" width="0" class="calibre5">The reason were studying symbol tables so extensively is that they
are the bedrock of most language applications.  Almost every
nontrivial language application needs to resolve symbols to unique
program entities.  Even a simple report generator that prints out call
sites to a particular method cant do so without a proper symbol
table.  More complicated applications such as interpreters and
translators need to check a programs validity, which involves
comparing variable and method types (as well see in the next
chapter).  After this chapter, youll have all the tools you need to
build a symbol table for everything from simple data formats to
programming languages.</p><p height="10" width="0" class="calibre5">Before jumping into the patterns, though, lets walk through some
examples and discuss how class inheritance complicates our lives.  As
in the previous chapter, well use a subset of C++.  Even
though were fixated on one specific language, the patterns apply to
most programming languages in common use.</p>

</div></div>
<div id="text/part0000_split_073.html"><div class="calibre">

<h2 id="text/part0000_split_073.html.sec.struct-scope-trees" class="calibre18">Building Scope Trees for Structs</h2><p height="10" width="0" class="calibre5"><code class="calibre21">struct</code> scopes behave just like local scopes from
a scope tree construction point of view. 
They are just another node in
the scope tree.  That means well have
<code class="calibre21">StructSymbol</code> nodes as well as
<code class="calibre21">LocalScope</code>,
<code class="calibre21">MethodSymbol</code>, and
<code class="calibre21">GlobalScope</code> nodes.  The scope tree for the following
sample program appears in Figure 16, <a href="#text/part0000_split_073.html.fig.aggr-symtab"><em class="calibre6">Scope tree for nested data aggregates</em></a>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/aggr/t.cymbol">symtab/aggr/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">struct</b> A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> B { <b class="calibre13">int</b> y; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;B b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> C { <b class="calibre13">int</b> z; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;C c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">A a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">5&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">6&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">7&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> D {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> i;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;D d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;d.i = a.b.y;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_073.html.fig.aggr-symtab"><img id="text/part0000_split_073.html.d24e18298" class="calibre47" src="data:image/gif;base64,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" alt="images/symtab/aggr-symtab.png"><hr class="calibre17"><b class="calibre13">Figure 15. Scope tree for nested data aggregates</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">As before, the numbered icons identify scopes in the code with the
associated node in the scope tree.  As you can see, the scope tree
looks like any other tree weve seen so
far. <code class="calibre21">StructSymbol</code> nodes have symbol
dictionaries and enclosing scope (parent) pointers.</p><p height="10" width="0" class="calibre5">From within a <code class="calibre21">struct</code> scope, 
we resolve symbols
by scanning upward in the scope tree like any other nested scope.
Because <code class="calibre21">struct</code>s have no embedded executable
expressions, the only symbols we can look up are type names. For
example, the first field of <code class="calibre21">A</code> references type
<code class="calibre21">int</code>. We look for <code class="calibre21">int</code>
starting in scope <span class="calibre45"></span>.  Scope
<code class="calibre21">A</code> does not have it so we look to the
enclosing scope, global scope <span class="calibre45"></span>. We do the same thing for the
second field, <code class="calibre21">B b;</code>.  Since we define type
<code class="calibre21">B</code> right before that field declaration, we
find <code class="calibre21">B</code> in scope <code class="calibre21">A</code>
right away.</p><p height="10" width="0" class="calibre5">We also have to resolve symbols within <code class="calibre21">struct</code>
scopes from the outside. In other words, a language application might
have to figure out which field
<em class="calibre6">expr</em><code class="calibre21">.x</code> refers to. In the previous code, that would mean resolving expressions
<code class="calibre21">d.i</code> and <code class="calibre21">a.b.y</code> in
<code class="calibre21">f</code>. The general (recursive) rule for resolving
<em class="calibre6">expr</em><code class="calibre21">.x</code> is to determine the
type of <em class="calibre6">expr</em> and then look up
<code class="calibre21">x</code> in that scope.  Looking toward the root
from function <code class="calibre21">f</code>s local scope <span class="calibre45"></span>, the scope stack is <span class="calibre45"></span><span class="calibre45"></span><span class="calibre45"></span>. To resolve
<code class="calibre21">d.i</code>, we look up <code class="calibre21">d</code> in
that semantic context and find that <code class="calibre21">d</code> has
type scope <code class="calibre21">D</code>. <code class="calibre21">D</code> is
also the scope in which we resolve
<code class="calibre21">i</code>. Similarly, for
<code class="calibre21">a.b.y</code>, we look up <code class="calibre21">a</code>
and find its type to be <code class="calibre21">A</code>. Looking up
<code class="calibre21">b</code> in <code class="calibre21">A</code> yields
another scope: <code class="calibre21">B</code>. Finally, we look up field
<code class="calibre21">y</code> in <code class="calibre21">B</code>.</p><p height="10" width="0" class="calibre5">Theres only one complication with the 
member access operator. We
need to restrict member resolution so it  only looks  in a specific
(<code class="calibre21">struct</code>) scope.  Member access expressions are like
scope overrides. They say exactly in which scope to look for a
field.  Say we tried to resolve <code class="calibre21">d.a</code> from
within function <code class="calibre21">f</code>.
<code class="calibre21">D</code> has no <code class="calibre21">a</code> field, but
we shouldnt look into <code class="calibre21">D</code>s enclosing scope.
Instead, we should report no such field. If we let it
continue looking into <code class="calibre21">D</code>s enclosing scope
(<code class="calibre21">f</code>), <code class="calibre21">d.a</code> would
eventually resolve to global variable
<code class="calibre21">a</code>. Thats clearly not right.  So, as youll
see in Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>, we need two different
resolve methods: one for looking up isolated symbols like
<code class="calibre21">d</code> and another for resolving member access
expressions like <code class="calibre21">d.i</code>.
</p>

</div></div>
<div id="text/part0000_split_074.html"><div class="calibre">

<h2 id="text/part0000_split_074.html.sec.class-scope-trees" class="calibre18">Building Scope Trees for Classes</h2><p height="10" width="0" class="calibre5">Classes are like <code class="calibre21">struct</code>s in that they can inherit
members from another class (the superclass).  
That means classes have
two parent scopes: the usual enclosing scope (physical location) and a
superclass scope. To resolve symbols, sometimes well chase the
enclosing scope pointer, and sometimes well chase the superclass
pointer. Lets start by looking at the scope tree for the following Cymbol code (see Figure 17, <a href="#text/part0000_split_074.html.fig.class-symtab"><em class="calibre6">Scope tree for classes A and B</em></a>).</p><div class="calibre1" id="text/part0000_split_074.html.fig.class-symtab"><img id="text/part0000_split_074.html.d24e18551" class="calibre2" src="data:image/jpeg;base64,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" alt="images/symtab/class-symtab.png"><hr class="calibre17"><b class="calibre13">Figure 16. Scope tree for classes A and B</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/AB.cymbol">symtab/class/AB.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope&nbsp;&nbsp;&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21">class A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">void</b> foo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21"> { ; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">5&nbsp;</code></span><span><code class="calibre21">class B : public A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">6&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">void</b> foo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">7&nbsp;</code></span><span><code class="calibre21"> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp; <b class="calibre13">int</b> z = x + y;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The enclosing scope pointers point upward (as in Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>),
but the superclass pointers point horizontally. They point
horizontally because all (non-nested) classes live at the same scope level.
Because there are two pointers emanating from each <code class="calibre21">ClassSymbol</code> node,
classes actually conjure up multiple scope stacks instead of just one.
For example, the local scope of method <code class="calibre21">foo</code> in class <code class="calibre21">B</code> could use
scope stack <span class="calibre45"></span> <span class="calibre45"></span> <span class="calibre45"></span> <span class="calibre45"></span> <span class="calibre45"></span> or stack <span class="calibre45"></span> <span class="calibre45"></span> <span class="calibre45"></span><span class="calibre45"></span>.</p><p height="10" width="0" class="calibre5">The language definition dictates which stack to use. Per the usual
object-oriented language conventions, well use the first stack.  That
choice means we want to look up the inheritance chain before looking
in the global scope.  In Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>, well introduce method <tt class="calibre21">getParentScope</tt> to <code class="calibre21">Scope</code> that returns the appropriate scope
(enclosing or superclass). Method <tt class="calibre21">resolve</tt> will call <tt class="calibre21">getParentScope</tt> to figure out where to look next.</p><h3 class="calibre23">Resolving Member Access Expressions</h3><p height="10" width="0" class="calibre5">As with <code class="calibre21">struct</code>s, we also have to resolve member
access expressions differently than isolated symbol lookups.  If we dont find an isolated symbol in the surrounding class or its
superclass(es), we look it up in the global scope. When referring to
members from outside that class, though, we shouldnt see global
variables.  For example, <code class="calibre21">a.g</code> referenced in
<tt class="calibre21">main</tt> in the following should be illegal
because <code class="calibre21">g</code> is a global variable:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">int g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // global variable g</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class A {&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> int x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> void foo() { g = 1; } // can see global g</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">int main() {&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> A a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> a.x = 3; // no problem; x is the field of A</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> a.g = 3; // ERROR! Should not see global variable g</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">So, unadorned <code class="calibre21">g</code> in method <code class="calibre21">foo</code> of class <code class="calibre21">A</code> resolves OK, but <code class="calibre21">a.g</code>
makes no sense. To treat these two situations differently, we need to
add a <tt class="calibre21">resolveMember</tt> method to <code class="calibre21">ClassSymbol</code>.  Isolated symbol
references use <tt class="calibre21">resolve</tt> as before, but <code class="calibre21">a.g</code> must use <tt class="calibre21">resolveMember</tt> to look up <code class="calibre21">g</code> in <code class="calibre21">A</code>.</p><h3 class="calibre23">Dealing with Forward References</h3><p height="10" width="0" class="calibre5">Classes also allow <em class="calibre6">forward references</em>. A forward reference is
a reference to a method, type, or variable defined later in the
input file.</p><p height="10" width="0" class="calibre5">
For example, in the next code fragment, method <code class="calibre21">foo</code> references
field <code class="calibre21">x</code> that is defined after the method.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/forward.cymbol">symtab/class/forward.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class A {&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">void</b> foo() { x = 3; } <em class="calibre6">// forward reference to field x</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To handle these forward references, we could try to scan ahead looking
for future definitions, but theres an easier way. We can make two
passes over the input, one to define symbols and another to resolve
them. So, a definition pass would define <code class="calibre21">A</code>, <code class="calibre21">foo</code>, and <code class="calibre21">x</code>.  Then a
reference pass would scan the input again, finding <code class="calibre21">x</code> in <code class="calibre21">A</code>s member
dictionary (scope) without trouble. Well use a two-pass approach
(over an AST) in Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.</p><p height="10" width="0" class="calibre5">Unfortunately, the two pass approach introduces a problem. We dont
want to allow forward references outside of classes (at least
according to Cymbols semantics since its a C++ subset). In the
following code, we dont want the <code class="calibre21">x</code> and <code class="calibre21">y</code> references in method
<code class="calibre21">main</code> to see the definitions that appear after the assignment
statement.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/global-forward.cymbol">symtab/class/global-forward.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// globals&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> main() &nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> x = y; <em class="calibre6">// shouldn't see global x or local y; ERROR!</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To recognize illegal forward references, we can use a trick involving
token indexes.  If a symbol reference resolves to a local or global
symbol, the references token index must come after the definitions
token index (assuming were buffering up all tokens from the input string).
In this case, the <code class="calibre21">x</code> and <code class="calibre21">y</code> token references in <code class="calibre21">main</code>
appear <em class="calibre6">before</em> the <code class="calibre21">x</code> and <code class="calibre21">y</code> tokens in the variable
declarations. That means we have two illegal forward references, and we
should report an error.  If the definition and reference tokens are in
the proper order, all is well.
</p><p height="10" width="0" class="calibre5">At this point, weve got enough of the big picture to follow the
patterns in this chapter.  Heres a table that summarizes when to
apply them.</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Use
this pattern if you need to support data aggregates like C
<code class="calibre21">struct</code>s or Pascal <code class="calibre21">record</code>s or SQL
<code class="calibre21">table</code>s.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Use this
pattern to build symbol tables for object-oriented languages smacking
of Java or C++.
</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">OK, lets dig in and learn about tracking symbols and building
scope trees for data aggregates.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_075.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_075.html.tip.struct-symtab" class="pagebreak2"><small class="calibre35">Pattern 18:</small>&nbsp;&nbsp;&nbsp;Symbol Table for Data Aggregates</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern tracks symbols and builds a scope tree for data
aggregates such as Cs <code class="calibre21">struct</code>s.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">To manage <code class="calibre21">struct</code> scopes, well build a scope
tree and define symbols just like we did in Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>.  The only difference lies in symbol
resolution. Member access expressions like
<code class="calibre21">a.b</code> can see fields inside a
<code class="calibre21">struct</code>.</p><p height="10" width="0" class="calibre5">In <a href="#text/part0000_split_073.html.sec.struct-scope-trees"><em class="calibre6">Building Scope Trees for Structs</em></a>, we examined the scope tree for some sample
Cymbol <code class="calibre21">struct</code> definitions.  The goal of this pattern is to
describe the rules and mechanism for building that scope tree and
filling the nodes (scopes) with symbols.  To get started, we need a
new kind of scope tree node called <code class="calibre21">StructSymbol</code> to represent <code class="calibre21">struct</code>s.  Heres the complete symbol table class hierarchy for this
pattern:</p><div class="calibre1"><img id="text/part0000_split_075.html.d24e19007" class="calibre22" src="data:image/gif;base64,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" alt="images/symtab/aggr-hier.png"></div><p height="10" width="0" class="calibre5">Now that weve got two scoped symbols, its a good idea to factor out
their common functionality into <code class="calibre21">ScopedSymbol</code> and derive both <code class="calibre21">StructSymbol</code> and <code class="calibre21">MethodSymbol</code> from it.</p><hr class="calibre17"><div id="text/part0000_split_075.html.fig.struct-symtab" class="calibre1"><b class="calibre13">Table 2. Rules for building a scope tree for data aggregates,
populating it with symbols, and resolving symbols</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Upon</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Action(s)</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Start of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">GlobalScope</code>. <code class="calibre21">def</code>&nbsp;<code class="calibre21">BuiltInType</code> objects for <code class="calibre21">int</code>, <code class="calibre21">float</code>, <code class="calibre21">void</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable declaration <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref x</code>s
type. <code class="calibre21">def</code>&nbsp;<code class="calibre21">x</code> as a <code class="calibre21">VariableSymbol</code> object in
the current scope.  This works for globals, <code class="calibre21">struct</code> fields,
parameters, and locals.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">struct</code> declaration <code class="calibre21">S</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">def</code>&nbsp;<code class="calibre21">S</code> as
a <code class="calibre21">StructSymbol</code> object in 
the current scope and <code class="calibre21">push</code> it as the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Method declaration <code class="calibre21">f</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref f</code>s return
type. <code class="calibre21">def</code>&nbsp;<code class="calibre21">f</code> as a <code class="calibre21">MethodSymbol</code> object in
the current scope and <code class="calibre21">push</code> it as the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">{</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">LocalScope</code> as the new
current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">}</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code>, revealing the previous scope as
the current scope. This works for <code class="calibre21">struct</code>s, methods, and local scopes.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable reference <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref</code>&nbsp;<code class="calibre21">x</code>
starting in the current scope. If not found, look in the immediately enclosing
scope if any.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Member access <em class="calibre6">expr</em>.<code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Compute the type of
<em class="calibre6">expr</em> using the previous rule and this one recursively. Ref <code class="calibre21">x</code> only in that types scope, not in any enclosing scopes.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">End of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code> the <code class="calibre21">GlobalScope</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5">To build the scope tree using those objects and to resolve symbols,
follow the rules in Table 2, <a href="#text/part0000_split_075.html.fig.struct-symtab"><em class="calibre6">Rules for building a scope tree for data aggregates,
populating it with symbols, and resolving symbols</em></a>.  The rules
tell us exactly what to do at each significant input construct, but
there are a number of ways to implement the actions. In the next
section, were going to build an AST using an ANTLR grammar and then
walk it to define and resolve symbols. If you want, you can leave the
sample implementation until youre actually in the process of
implementing your own language.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">The implementation of Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a> provides most of the
implementation we need for this pattern, so we can use it as a
foundation.  
Here is a road map to add <code class="calibre21">struct</code>s to our Cymbol
language:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Add syntax and AST construction rules for struct definitions
and member access expressions.</em>  To focus on the symbol table
aspects, well assume that this part just works. Check out <code class="calibre21">Cymbol.g</code> in the source code directory for AST construction details. </li><li height="6" class="calibre20"><span></span><em class="calibre6">Define new symbol table objects.</em> We need to add <code class="calibre21">StructSymbol</code>. To do so, well refactor the class hierarchy,
introducing a <code class="calibre21">ScopedSymbol</code> base class. Well derive <code class="calibre21">MethodSymbol</code> from it as well.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Add pattern matching rules to define struct
scopes.</em> As we did for local and function scopes in Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>, well trigger <code class="calibre21">push</code> and <code class="calibre21">pop</code> scope operations for <code class="calibre21">struct</code> definitions.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Add pattern matching rules to resolve member access
expressions.</em></li></ul><p height="10" width="0" class="calibre5">Lets start with the symbol table objects. The main change to the
symbol table objects is the addition of <code class="calibre21">StructSymbol</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/aggr/StructSymbol.java">symtab/aggr/StructSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class StructSymbol extends ScopedSymbol implements Type, Scope {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, Symbol&gt; fields = new LinkedHashMap&lt;String, Symbol&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public StructSymbol(String name,Scope parent) {super(name, parent);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** For a.b, only look in fields to resolve b, not up scope tree */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public Symbol resolveMember(String name) { <b class="calibre13">return</b> fields.get(name); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public Map&lt;String, Symbol&gt; getMembers() { <b class="calibre13">return</b> fields; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public String toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <em class="calibre6">"struct "</em>+name+<em class="calibre6">":{"</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stripBrackets(fields.keySet().toString())+<em class="calibre6">"}"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">According to the scope tree construction rules, we create a <code class="calibre21">StructSymbol</code> for each <code class="calibre21">struct</code> we encounter. Were walking an AST to
trigger actions, so lets look at a sample AST.  The AST for the following Cymbol code appears in Figure 18, <a href="#text/part0000_split_075.html.fig.aggr-symtab-struct"><em class="calibre6">AST for struct and function definition</em></a>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/aggr/t2.cymbol">symtab/aggr/t2.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">struct</b> A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">float</b> y;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">void</b> f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;A a; <em class="calibre6">// define a new A struct called a</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a.x = 1;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_075.html.fig.aggr-symtab-struct"><img id="text/part0000_split_075.html.d24e19374" class="calibre47" src="data:image/gif;base64,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" alt="images/symtab/struct-ast.png"><hr class="calibre17"><b class="calibre13">Figure 17. AST for struct and function definition</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Upon seeing the <code class="calibre21">struct</code> node, we create a <code class="calibre21">StructSymbol</code> for <code class="calibre21">A</code>
and push it as the current scope. After processing the entire <code class="calibre21">struct</code>
subtree, we pop that scope off to reveal the global scope as the
current scope. Here are the relevant tree pattern rules from <code class="calibre21">DefRef.g</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/aggr/DefRef.g">symtab/aggr/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">enterStruct <em class="calibre6">// match as we discover struct nodes (on the way down)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: ^('struct' ID .+)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": def struct "</em>+$ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StructSymbol ss = new StructSymbol($ID.text, currentScope);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope.define(ss); <em class="calibre6">// def struct in current scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = ss;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// set current scope to struct scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">exitStruct <em class="calibre6">// match as we finish struct nodes (on the way up)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; 'struct' <em class="calibre6">// don't care about children, just trigger upon struct</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"fields: "</em>+currentScope);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = currentScope.getEnclosingScope();&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// pop scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To access members of a <code class="calibre21">struct</code> like
<code class="calibre21">a.x</code>, we trigger two
<code class="calibre21">ref</code> operations. The first
<code class="calibre21">ref</code> operation looks up
<code class="calibre21">a</code> to figure out what type it is. The second
<code class="calibre21">ref</code> then resolves <code class="calibre21">x</code>
within <code class="calibre21">a</code>s scope (upon seeing the
<code class="calibre21">.</code> node).
To match (possibly nested) member access expressions, we can use the
following recursive rule:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">member <em class="calibre6">// E.g., "a", "a.b", "a.b.c", and so on</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: ^(<em class="calibre6">'.'</em> member ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The problem is we cant just ask the pattern matcher to look for that
pattern because a plain <code class="calibre21">ID</code> node like <code class="calibre21">a</code> also matches. We dont
want this rule to match, say, the <code class="calibre21">ID</code> of a function definition.</p><p height="10" width="0" class="calibre5">To control expression tree walking, we need a tree grammar, not a tree
pattern matcher. But, we need tree pattern matching for other language
constructs.  We can combine the two approaches by using pattern
matching to find <code class="calibre21">EXPR</code> root nodes and assignments.  From there, we
can invoke tree grammar rule <code class="calibre21">member</code>. In this way, rule <code class="calibre21">member</code>
isnt triggered as part of the tree pattern matching (we wont put it
in the special <code class="calibre21">topdown</code> or <code class="calibre21">bottomup</code> rules).  Well learn more
about this in Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>.  Here is the <code class="calibre21">member</code> rule now
fleshed out with actions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/aggr/DefRef.g">symtab/aggr/DefRef.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">member returns [Type type] <em class="calibre6">// expr.x; E.g., "a", "a.b", "a.b.c", ...</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: ^('.' m=member ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StructSymbol scope=(StructSymbol)$m.type;<em class="calibre6">// get scope of expr</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = scope.resolveMember($ID.text);<em class="calibre6">// resolve ID in scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": ref "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $m.type.getName()+<em class="calibre6">"."</em>+$ID.text+<em class="calibre6">"="</em>+s);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s!=null ) $type = s.type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// return ID's type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// resolve, return type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = currentScope.resolve($ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+<em class="calibre6">": ref "</em>+$ID.text+<em class="calibre6">"="</em>+s);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s!=null ) $type = s.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">member</code>s primary function is to compute the type of member
access expressions. To do so, it needs to resolve all the symbols
within an expression. Given <em class="calibre6">expr</em>.<code class="calibre21">x</code>, <code class="calibre21">member</code> needs <em class="calibre6">expr</em>s type because it must look up <code class="calibre21">x</code> with the scope of <em class="calibre6">expr</em>.
Take a look at the action for the isolated <code class="calibre21">ID</code> node. It looks up the
symbol and returns its type.  If that <code class="calibre21">ID</code> is the child of a member
access subtree as in the AST for <code class="calibre21">a.b</code>, then well use <code class="calibre21">a</code>s type to
look up <code class="calibre21">b</code>.  The action for the <code class="calibre21">.</code> member access operator assumes
that the type for <code class="calibre21">a</code> is also a scope.  It then looks up <code class="calibre21">b</code> in that
scope. It returns the type of <code class="calibre21">b</code> in case <code class="calibre21">a.b</code> is part of a larger
expression such as <code class="calibre21">a.b.c</code>.</p><p height="10" width="0" class="calibre5">The test rig in the source code directory is the same as in Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>. It builds an AST from the source code and then walks the
AST using <code class="calibre21">DefRef</code>s <tt class="calibre21">downup</tt> strategy.  Building the test rig is,
again, just a matter of running ANTLR on the grammars and
compiling. Here is the output from the test rig when run against <code class="calibre21">t2.cymbol</code>:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g DefRef.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; t2.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 2: def struct A</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: def x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 4: def y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">fields: struct A:{x, y}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 7: def method f</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 9: def a</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 10: ref a=&lt;local.a:struct A:{x, y}&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 10: ref A.x=&lt;A.x:global.int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 10: assign to type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: [a]&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">args: &lt;global.f():global.void&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals: [int, float, void, A, f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now that we know how to handle data aggregates, were ready to
tackle classes. The scope trees for classes are a bit more complicated
than for <code class="calibre21">struct</code>s because we have to track class
inheritance.  Also, because of forward references, we need to split
apart the <code class="calibre21">DefRef.g</code> pattern matcher used in this
pattern.  Well do a definition pass over the AST and then a
resolution pass.</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern builds on Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>. Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a> extends
this pattern to support classes.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_076.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_076.html.tip.class-symtab" class="pagebreak2"><small class="calibre35">Pattern 19:</small>&nbsp;&nbsp;&nbsp;Symbol Table for Classes</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern tracks symbols and builds a scope tree for
non-nested classes with single inheritance.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Classes are data aggregates that allow method members and that can
inherit members from superclasses. Methods within classes can see
global variables in the object-oriented version of our Cymbol language
(since Cymbol is a subset of C++).  To support these language
semantics, we need to tweak the scope trees we used for <code class="calibre21">struct</code>s
in Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>. Well replace <code class="calibre21">StructSymbol</code> nodes with <code class="calibre21">ClassSymbol</code> nodes and have them point at their superclasses as well as
their enclosing scopes (recall Figure 17, <a href="#text/part0000_split_074.html.fig.class-symtab"><em class="calibre6">Scope tree for classes A and B</em></a>). All the symbol table objects this pattern needs appear in Figure 19, <a href="#text/part0000_split_076.html.fig.class-hier"><em class="calibre6">Class hierarchy for a symbol table managing classes</em></a>.</p><div class="calibre1" id="text/part0000_split_076.html.fig.class-hier"><img id="text/part0000_split_076.html.d24e19831" class="calibre22" src="data:image/gif;base64,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" alt="images/symtab/class-hier.png"><hr class="calibre17"><b class="calibre13">Figure 18. Class hierarchy for a symbol table managing classes</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Object-oriented languages like Cymbol also support forward
references to symbols defined later in the file. Rather than trying to
augment our single AST pass with code to see into the
future, this pattern uses a two-pass approach.  Well define
symbols in the first pass and resolve symbol references in the second
pass over the AST.</p><p height="10" width="0" class="calibre5">Unfortunately, separating the two phases introduces a data
communication issue.  To resolve symbol references, we need to know
the current scope but thats computed only in the definition
phase. So, we need to pass information from the definition to the
resolution phase. The logical place to stash information is in the AST
representation of the input. (Its much more efficient to walk an AST
multiple times than the original token stream.)</p><p height="10" width="0" class="calibre5">The definition phase 
tracks the current scope as usual and records
it in the associated AST nodes.  For example, a
<code class="calibre21">{</code> node records the associated
<code class="calibre21">LocalScope</code>. As we define symbols, we might as
well record the resulting <code class="calibre21">Symbol</code> objects in the
AST too. The resolution phase can then look in the tree for scope
information and symbol definitions. As we resolve symbol references,
well also shove that into the AST. Any future tree phases would most
likely use the symbol pointers for analysis or translation.</p><p height="10" width="0" class="calibre5">To make this clearer, lets carry the following small Cymbol method
through both phases to see what the AST and scope tree look like:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/t.cymbol">symtab/class/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// globals&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><b class="calibre13">int</b> main() &nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> x = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> In Figure 20, <a href="#text/part0000_split_076.html.fig.t-ast-sym"><em class="calibre6">AST and scope tree showing links for x after definition phase</em></a>, we can see the AST and scope tree after the definition
phase. To avoid cluttering the diagram, the diagram only shows
pointers to and from the AST for <code class="calibre21">x</code>s definition and reference.
During the definition phase, we create a <code class="calibre21">VariableSymbol</code> and make
the definitions <code class="calibre21">ID</code> node point at that symbol.  We also make a back
pointer from that symbol to the <code class="calibre21">ID</code> node using the <code class="calibre21">VariableSymbol</code>s <code class="calibre21">def</code> field.</p><div class="calibre1" id="text/part0000_split_076.html.fig.t-ast-sym"><img id="text/part0000_split_076.html.d24e19907" class="calibre2" src="data:image/gif;base64,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" alt="images/symtab/t-ast-sym.png"><hr class="calibre17"><b class="calibre13">Figure 19. AST and scope tree showing links for <code class="calibre21">x</code> after definition phase</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The definition phase also sets a <code class="calibre21">scope</code> field for some of the AST
nodes (shown via numbered icons to avoid cluttering the diagram with
more arrows).  Its crucial that we set the <code class="calibre21">scope</code> for the variable
definitions type node (<code class="calibre21">int</code>) and the <code class="calibre21">x</code> reference in the
assignment. The resolution phase needs the scope in order to resolve
those symbols.</p><p height="10" width="0" class="calibre5">The resolution phase now has everything it needs to properly resolve
all symbol references. 
During this phase, we update the <code class="calibre21">symbol</code>
field of two AST nodes and update the <code class="calibre21">type</code> field of the <code class="calibre21">VariableSymbol</code>, as shown in Figure 21, <a href="#text/part0000_split_076.html.fig.t-ast-sym-ref"><em class="calibre6">AST and scope tree showing links for x after resolution phase</em></a>. As we revisit <code class="calibre21">x</code>s
variable declaration subtree, we resolve its type and make that node
point at the <code class="calibre21">BuiltInTypeSymbol</code>. When we see the <code class="calibre21">x</code> reference in
the assignment, we resolve it and make that node point at the <code class="calibre21">VariableSymbol</code>.</p><div class="calibre1" id="text/part0000_split_076.html.fig.t-ast-sym-ref"><img id="text/part0000_split_076.html.d24e19964" class="calibre2" src="data:image/gif;base64,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" alt="images/symtab/t-ast-sym-ref.png"><hr class="calibre17"><b class="calibre13">Figure 20. AST and scope tree showing links for <code class="calibre21">x</code> after resolution phase</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">To support checks for illegal forward references, 
the <code class="calibre21">def</code> field of the
<code class="calibre21">VariableSymbol</code> is important.  At the
<code class="calibre21">x</code> reference in
<code class="calibre21">main</code>s assignment, we want to check the
relative position of <code class="calibre21">x</code>s definition. To get
<code class="calibre21">x</code>s position, we can follow the
<code class="calibre21">symbol</code> pointer into the symbol table from
the AST. Then, we can follow the <code class="calibre21">def</code>
pointer back into the AST to the definition for that symbol. In this
case, the definition for <code class="calibre21">x</code> comes before the
reference, so its OK.</p><p height="10" width="0" class="calibre5">Now that we know what the symbol table objects are, what the scope
trees look like, and how to deal with forward references, we can lay
out the rules for the definition and resolution passes.  See Table 3, <a href="#text/part0000_split_076.html.fig.class-symtab-def"><em class="calibre6">Definition phase rules for building a scope tree for classes and
populating it with symbols</em></a>, as well as Table 4, <a href="#text/part0000_split_076.html.fig.class-symtab-ref"><em class="calibre6">Resolution phase rules for updating the AST and symbol table for classes</em></a>.</p><hr class="calibre17"><div id="text/part0000_split_076.html.fig.class-symtab-def" class="calibre1"><b class="calibre13">Table 3. Definition phase rules for building a scope tree for classes and
populating it with symbols</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Upon</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Action(s)</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Start of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">GlobalScope</code>. <code class="calibre21">def</code>&nbsp;<code class="calibre21">BuiltInTypeSymbol</code> objects for <code class="calibre21">int</code>, <code class="calibre21">float</code>, <code class="calibre21">void</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Identifier reference <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Set <code class="calibre21">x</code>s scope
field to the current scope (the resolution phase needs it).</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable declaration <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">def</code>&nbsp;<code class="calibre21">x</code> as a
<code class="calibre21">VariableSymbol</code> object, <code class="calibre21">sym</code>, in the current scope.  This works for
globals, class fields, parameters, and locals (wow). Set <code class="calibre21">sym.def</code> to
<code class="calibre21">x</code>s <code class="calibre21">ID</code> AST node. Set that <code class="calibre21">ID</code> nodes <code class="calibre21">symbol</code> to
<code class="calibre21">sym</code>. Set the <code class="calibre21">scope</code> field of <code class="calibre21">x</code>s type AST node to the current
scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Class declaration <code class="calibre21">C</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">def</code>&nbsp;<code class="calibre21">C</code> as
a <code class="calibre21">ClassSymbol</code> object, <code class="calibre21">sym</code>, in the current scope and <code class="calibre21">push</code> it as
the current scope. Set <code class="calibre21">sym.def</code> to the class names <code class="calibre21">ID</code> AST
node.  Set that <code class="calibre21">ID</code> nodes <code class="calibre21">symbol</code> to <code class="calibre21">sym</code>. Set the <code class="calibre21">scope</code> 
field of <code class="calibre21">C</code>s superclass AST node to the current scope.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Method declaration <code class="calibre21">f</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">def</code>&nbsp;<code class="calibre21">f</code>
as a <code class="calibre21">MethodSymbol</code> object, <code class="calibre21">sym</code>, in the current scope and <code class="calibre21">push</code> it
as the current scope.  Set <code class="calibre21">sym.def</code> to the function names <code class="calibre21">ID</code> AST
node. Set that <code class="calibre21">ID</code> nodes <code class="calibre21">symbol</code> to <code class="calibre21">sym</code>. Set the <code class="calibre21">scope</code> 
field of <code class="calibre21">f</code>s return type AST node to the current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">{</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">push</code> a <code class="calibre21">LocalScope</code> as the new
current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">}</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code>, revealing previous scope as
current scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">End of file</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code> the <code class="calibre21">GlobalScope</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><hr class="calibre17"><div id="text/part0000_split_076.html.fig.class-symtab-ref" class="calibre1"><b class="calibre13">Table 4. Resolution phase rules for updating the AST and symbol table for classes</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Upon</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Action(s)</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable declaration <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Let <code class="calibre21">t</code> be the <code class="calibre21">ID</code>
node for <code class="calibre21">x</code>s type. <code class="calibre21">ref t</code>, yielding <code class="calibre21">sym</code>. Set <code class="calibre21">t.symbol</code> to <code class="calibre21">sym</code>.
Set <code class="calibre21">x.symbol.type</code> to <code class="calibre21">sym</code>; in other words, jump to the <code class="calibre21">VariableSymbol</code> for <code class="calibre21">x</code> via the AST nodes <code class="calibre21">symbol</code> field and then set
its <code class="calibre21">type</code> field to <code class="calibre21">sym</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Class declaration <code class="calibre21">C</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Let <code class="calibre21">t</code> be the <code class="calibre21">ID</code>
node for <code class="calibre21">C</code>s superclass. <code class="calibre21">ref t</code>, yielding <code class="calibre21">sym</code>. Set <code class="calibre21">t.symbol</code> to
<code class="calibre21">sym</code>.  Set <code class="calibre21">C</code>s <code class="calibre21">superclass</code> field to <code class="calibre21">sym</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Method declaration <code class="calibre21">f</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Let <code class="calibre21">t</code> be the <code class="calibre21">ID</code>
node for <code class="calibre21">f</code>s return type. <code class="calibre21">ref t</code>, yielding <code class="calibre21">sym</code>. Set <code class="calibre21">t.symbol</code> to
<code class="calibre21">sym</code>. Set the <code class="calibre21">type</code> field of the <code class="calibre21">MethodSymbol</code> for <code class="calibre21">f</code> to
<code class="calibre21">sym</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Variable reference <code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ref x</code>, yielding <code class="calibre21">sym</code>.
Set <code class="calibre21">x.symbol</code> to <code class="calibre21">sym</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">this</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Resolve to the surrounding class
scope. Set the <code class="calibre21">symbol</code> field of <code class="calibre21">this</code>s <code class="calibre21">ID</code> node to the
surrounding class scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Member access <em class="calibre6">expr</em>.<code class="calibre21">x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Resolve <em class="calibre6">expr</em> to a particular type symbol, <code class="calibre21">esym</code>, using these rules.  <code class="calibre21">ref x</code>
within <code class="calibre21">esym</code>s scope, yielding <code class="calibre21">sym</code>. Set <code class="calibre21">x.symbol</code> (<code class="calibre21">x</code>s <code class="calibre21">ID</code>
node) to <code class="calibre21">sym</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5">The actions in Table 4, <a href="#text/part0000_split_076.html.fig.class-symtab-ref"><em class="calibre6">Resolution phase rules for updating the AST and symbol table for classes</em></a>, perform a lot of abstract <code class="calibre21">ref</code>
operations, but the details of symbol resolution arent shown. Our
basic strategy remains the same as we saw in <a href="#text/part0000_split_067.html.sec.symtab-resolving"><em class="calibre6">Resolving Symbols</em></a>. We
look for the symbol in the current scopes dictionary. If found, we
return it. If not found, we recursively look upward in the scope
tree:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Symbol resolve(<b class="calibre13">String</b> name) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = members.get(name);&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// look in this scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s!=null ) <b class="calibre13">return</b> s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// return it if in this scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( getParentScope() != null ) { <em class="calibre6">// do we have a super or enclosing?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> getParentScope().resolve(name); <em class="calibre6">// check super/enclosing</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null; <em class="calibre6">// not found in this scope or above</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The only difference youll notice is that we call 
<tt class="calibre21">getParentScope</tt>, not <tt class="calibre21">getEnclosingScope</tt> as we did before.  <code class="calibre21">ClassSymbol</code> objects have two parent pointers, one for the superclass
and one for the enclosing scope.  Which one we follow on the way up
the scope tree depends on what kind of scope were looking at. <tt class="calibre21">getParentScope</tt> factors out this decision into the various kinds of
symbols that implement <code class="calibre21">Scope</code>. Here are the relevant methods in <code class="calibre21">Scope</code> that define upward pointers in the scope tree:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Scope.java">symtab/class/Scope.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Where to look next for symbols; superclass or enclosing scope */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Scope getParentScope();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Scope in which this scope defined. For global scope, it's null */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Scope getEnclosingScope();</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For all scopes except <code class="calibre21">ClassSymbol</code>, <tt class="calibre21">getParentScope</tt> returns the
enclosing scope.  <tt class="calibre21">getParentScope</tt> in classes returns the superclass
pointer, so we follow the superclass chain. If there is no superclass,
then we follow the enclosing scope chain like any other scope.</p><p height="10" width="0" class="calibre5">The addition of this little knob makes <tt class="calibre21">resolve</tt> work correctly
for all symbol references (types, classes, methods, and variables) in
the presence or absence of classes. In Table 5, <a href="#text/part0000_split_076.html.fig.class-symtab-resolve"><em class="calibre6">How <tt class="calibre21">resolve</tt> walks up the scope tree for classes</em></a>, we see how the algorithm walks up the scope tree according to reference
location. The behavior mirrors what weve come to expect in
object-oriented languages.</p><hr class="calibre17"><div id="text/part0000_split_076.html.fig.class-symtab-resolve" class="calibre1"><b class="calibre13">Table 5. How <tt class="calibre21">resolve</tt> walks up the scope tree for classes</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Symbol Reference</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Resolution Algorithm Scope Tree Walk</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">x</code> in method</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Look first in the enclosing
local scope(s), then into the method scope, and then into the enclosing
class scope.  If not found in the enclosing class, look up the class
hierarchy. If not found in the class hierarchy, look in the global
scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">x</code> in field definition initialization expression</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Look in the
surrounding class scope. If not found in that class, look up the class
hierarchy. If not found in the class hierarchy, look in the global
scope.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">x</code> in global scope</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Look in the surrounding
global scope.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5">Resolving member access expressions,
<em class="calibre6">expr</em><code class="calibre21">.x</code>, is almost the
same. The only difference is symbol resolution should stop looking at
the root of the class hierarchy. It shouldnt look in the global
scope. Here is the algorithm for resolving members:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Symbol resolveMember(String name) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = members.get(name);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( s!=null ) return s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;// if not here, check superclass chain only</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( superClass != null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return superClass.resolveMember(name);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;return null; // not found</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rules and resolution algorithms weve just gone through tell us
everything we need to know in order to build a symbol table for an
object-oriented language with single inheritance.  They also tell us
how to resolve symbols properly, taking into account the class
hierarchy and enclosing scope chains.</p><p height="10" width="0" class="calibre5">You can skip the following
implementation section if youre primarily interested in the
principles behind symbol table management.  Because the sample
implementation is complete, the discussion is a bit long.  When youre
ready to really dig into the details of building an object-oriented
language, though, you should read through it and examine the code in a
development tool.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">For our sample object-oriented Cymbol implementation, well use
Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a> as a foundation, so lets just talk
about how this implementation extends that one.  
The biggest
difference is that well make two passes over the AST per the pattern
discussion.  Heres our implementation road map:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Extend the Cymbol language grammar to allow class
definitions. Well also add the notion of a main method. These are
more or less straightforward grammar extensions. Well assume that
the grammar correctly builds ASTs for classes.</li><li height="6" class="calibre20"><span></span>Define a custom <code class="calibre21">CymbolAST</code> node that tracks <code class="calibre21">scope</code> and <code class="calibre21">symbol</code> pointers for each identifier node.</li><li height="6" class="calibre20"><span></span>Add field <code class="calibre21">def</code> (type <code class="calibre21">CymbolAST</code>) to <code class="calibre21">Symbol</code> that points
from the symbol table into the AST. <code class="calibre21">def</code> points at the <code class="calibre21">ID</code> node
associated with the <code class="calibre21">Symbol</code>.</li><li height="6" class="calibre20"><span></span>Add method <tt class="calibre21">getParentScope</tt> to <code class="calibre21">Scope</code>, and alter <tt class="calibre21">resolve</tt>
methods to use this instead of <tt class="calibre21">getEnclosingScope</tt>. We still need <tt class="calibre21">getEnclosingScope</tt> for <code class="calibre21">push</code> and <code class="calibre21">pop</code> operations, though.</li><li height="6" class="calibre20"><span></span>Replace <code class="calibre21">StructSymbol</code> with a suitable <code class="calibre21">ClassSymbol</code>.</li><li height="6" class="calibre20"><span></span>Break the single-pass <code class="calibre21">DefRef.g</code> into two passes, <code class="calibre21">Def.g</code> and <code class="calibre21">Ref.g</code>, that define symbols and resolve symbol references,
respectively. This is necessary to support forward references.</li></ul><p height="10" width="0" class="calibre5">Lets start by describing the new properties well need in the various
objects and then look at building scope trees and resolving symbols.</p><p height="10" width="0" class="calibre5">To hold bookkeeping fields for our two pass approach, we need a
specialized AST node.  Beyond the properties of the usual ANTLR <code class="calibre21">CommonTree</code> object, we need <code class="calibre21">scope</code> and <code class="calibre21">symbol</code> fields (<code class="calibre21">Test.java</code>
shows how to create a custom <code class="calibre21">TreeAdaptor</code> that tells ANTLR to build
<code class="calibre21">CymbolAST</code> nodes):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/CymbolAST.java">symtab/class/CymbolAST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> CymbolAST <b class="calibre13">extends</b> CommonTree {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Scope scope;&nbsp;&nbsp; <em class="calibre6">// set by Def.g; ID lives in which scope?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol symbol; <em class="calibre6">// set by Ref.g; point at def in symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> CymbolAST(Token t) { super(t); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We also need the symbol table objects to point back into the AST at
their definition <code class="calibre21">ID</code> nodes via <code class="calibre21">def</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Symbol.java">symtab/class/Symbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Symbol { <em class="calibre6">// A generic programming language symbol</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// All symbols at least have a name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Scope scope;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// All symbols know what scope contains them.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;CymbolAST def;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// points at ID node in tree</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To represent the Cymbol language class hierarchy, each <code class="calibre21">ClassSymbol</code>
needs a <code class="calibre21">superClass</code> field:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/ClassSymbol.java">symtab/class/ClassSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> ClassSymbol <b class="calibre13">extends</b> ScopedSymbol <b class="calibre13">implements</b> Scope, <b class="calibre13">Type</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** This is the superclass not enclosingScope field. We still record</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;the enclosing scope so we can push in and pop out of class defs.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol superClass;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** List of all fields and methods */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>,Symbol&gt; members=<b class="calibre13">new</b> <b class="calibre13">LinkedHashMap</b>&lt;<b class="calibre13">String</b>,Symbol&gt;();</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Per the pattern discussion, 
we need to define <tt class="calibre21">getParentScope</tt>. By
default, it just returns the enclosing scope:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/ScopedSymbol.java">symtab/class/ScopedSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Scope getParentScope() { <b class="calibre13">return</b> getEnclosingScope(); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For classes, the parent scope depends on whether it has a
superclass:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/ClassSymbol.java">symtab/class/ClassSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> Scope getParentScope() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( superClass==null ) <b class="calibre13">return</b> enclosingScope; <em class="calibre6">// globals</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> superClass; <em class="calibre6">// if not root object, return super</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">With this infrastructure in place, we can build the two tree phases that
define and resolve symbols.</p><h4 class="calibre26">Populating the Symbol Table in Phase 1</h4><p height="10" width="0" class="calibre5">The goal of our first tree-walking phase is to build a scope tree and
populate it with all classes, methods, and variables (globals, fields,
parameters, and locals).  
Lets put our definition tree phase
in <code class="calibre21">Def.g</code>.</p><p height="10" width="0" class="calibre5">As in the other patterns, we need both top-down and bottom-up actions
to track the current scope.  The source code identifies the scopes
with tokens such as nested curlies. We push and pop the current scope
according to these symbols. The current scope has nothing to do with
the class hierarchy. So, the scope <code class="calibre21">pop</code> action looks just like in the
other patterns:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentScope = currentScope.getEnclosingScope();&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// pop scope</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To execute actions upon symbol definitions, tree matcher <code class="calibre21">Def</code> has
patterns for classes, methods, and variables. Here is the rule to
match and define classes:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Def.g">symtab/class/Def.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">enterClass&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'class'</em> name=ID (^(EXTENDS sup=ID))? .)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <em class="calibre6">// def class but leave superclass blank until ref phase</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$name.getLine()+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">": def class "</em>+$name.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// record scope in AST for next pass</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( $sup!=null ) $sup.<b class="calibre13">scope</b> = currentScope;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol cs = new ClassSymbol($name.text,currentScope,null);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs.def = $name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// point from symbol table into AST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$name.symbol = cs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// point from AST into symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope.define(cs);&nbsp;&nbsp;<em class="calibre6">// def class in current scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentScope = cs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// set current scope to class scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This is analogous to the rule for matching and defining <code class="calibre21">struct</code>s but
performs two other important operations.  First, <code class="calibre21">enterClass</code> sets
the <code class="calibre21">scope</code> for the superclass identifier node (well use this scope
to look it up in the resolution phase).  Second, it doubly links the
class names <code class="calibre21">ID</code> AST node with the associated <code class="calibre21">ClassSymbol</code> object
(using AST field <code class="calibre21">symbol</code> and <code class="calibre21">ClassSymbol</code> field <code class="calibre21">def</code>). This
builds the dashed lines we see in Figure 20, <a href="#text/part0000_split_076.html.fig.t-ast-sym"><em class="calibre6">AST and scope tree showing links for x after definition phase</em></a>; these are for
the <code class="calibre21">x</code> child of <code class="calibre21">VAR_DECL</code>.  There are similar actions to set the
scope for method return types and variable types in <code class="calibre21">enterMethod</code> and
<code class="calibre21">varDeclaration</code>. Otherwise, those rules are the same as in Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>.</p><p height="10" width="0" class="calibre5">We also need to set the <code class="calibre21">scope</code> field for identifiers within
expressions so we can resolve them in the next phase.  We cant just
make a rule that matches identifiers, though. It would trigger the <code class="calibre21">scope</code> setting action at inappropriate times.  For example, if class
<code class="calibre21">B</code> derives from <code class="calibre21">A</code>, we want to look up superclass <code class="calibre21">A</code> starting in the
global scope rather than in class <code class="calibre21">B</code> itself. To limit our <code class="calibre21">scope</code>-setting rule to only those identifiers within expressions and
assignments, we can add a semantic predicate to the pattern:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Def.g">symtab/class/Def.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Set scope for any identifiers in expressions or assignments */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">atoms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@init</b> {CymbolAST t = (CymbolAST)input.LT(1);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;{t.hasAncestor(EXPR)||t.hasAncestor(ASSIGN)}? (<em class="calibre6">'this'</em>|ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {t.<b class="calibre13">scope</b> = currentScope;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The predicate ensures that rule <code class="calibre21">atoms</code> triggers only when the
identifier has an ancestor in the tree of <code class="calibre21">EXPR</code> or <code class="calibre21">ASSIGN</code>.</p><p height="10" width="0" class="calibre5">Now that weve built the scope tree and annotated the AST, we can
build the resolution phase.
</p><h4 class="calibre26">Resolving Symbol References in Phase 2</h4><p height="10" width="0" class="calibre5">The first goal of our second phase is to resolve all type references:
variable types, return types, and class superclasses. 
Once we know the
type, we need to update the associated symbol table objects. In other
words, upon <code class="calibre21">int x</code>, we need to resolve <code class="calibre21">int</code> to get its <code class="calibre21">BuiltInTypeSymbol</code>. Then we need set the <code class="calibre21">type</code> field of <code class="calibre21">x</code>s <code class="calibre21">VariableSymbol</code> to that <code class="calibre21">BuiltInTypeSymbol</code>. These are the dashed
lines pointing at the <code class="calibre21">int</code> symbol shown in Figure 21, <a href="#text/part0000_split_076.html.fig.t-ast-sym-ref"><em class="calibre6">AST and scope tree showing links for x after resolution phase</em></a>.</p><p height="10" width="0" class="calibre5">The second goal of our resolution phase is to resolve the identifiers
within expressions and on the left side of assignments.  To do this,
well use a full tree grammar for expressions rather than simple tree
pattern matching. As well see in Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>, we need
to control tree walking to compute expression types. </p><p height="10" width="0" class="calibre5">To stop the
pattern matcher at the root of an expression or assignment, we use the
following rules:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Ref.g">symtab/class/Ref.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assignment&nbsp;&nbsp;: ^( <em class="calibre6">'='</em> expr expr ) ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">resolveExpr : ^( EXPR expr ) ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rules <code class="calibre21">assignment</code> and
<code class="calibre21">resolveExpr</code> invoke <code class="calibre21">expr</code>, but the
tree pattern matcher does not try to match <code class="calibre21">expr</code>
against subtrees because we dont mention rule <code class="calibre21">expr</code>
in the <code class="calibre21">topdown</code> or <code class="calibre21">downup</code> rules.
Rule <code class="calibre21">expr</code> is a complete tree grammar rule
describing the syntax of an expression tree:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Ref.g">symtab/class/Ref.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Compute types for identifiers and member access.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;Ignore actions for others; we don't need for this pattern example.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; member {$type = $member.type;} <em class="calibre6">// E.g., "a.b"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(CALL expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(<em class="calibre6">'+'</em> expr expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; id&nbsp;&nbsp;&nbsp;&nbsp; {$type = $id.type;}&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// E.g., "a", "this"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; INT&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">expr</code> returns the type of the expression
subtree it matched.  We need expression types so that we can resolve
member access expressions. To look up <code class="calibre21">b</code> in
<code class="calibre21">a.b</code>, we need to know the type (class) of
<code class="calibre21">a</code>. </p><p height="10" width="0" class="calibre5">Here is the rule that handles member
access operations:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Ref.g">symtab/class/Ref.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">member <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'.'</em> m=expr ID) <em class="calibre6">// E.g., "a", "a.b", "a.b.c", ...</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol <b class="calibre13">scope</b> = (ClassSymbol)$m.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = <b class="calibre13">scope</b>.resolveMember($ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ID.symbol = s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<em class="calibre6">"line "</em>+$ID.getLine()+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">": resolve "</em>+$m.text+<em class="calibre6">"."</em>+$ID.text+<em class="calibre6">" to "</em>+s);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( s!=null ) $type = s.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Note that we use <tt class="calibre21">resolveMember</tt>, not the
generic <tt class="calibre21">resolve</tt>, because we only want to look
up member references in the class
hierarchy. <tt class="calibre21">resolve</tt> looks in the global scope
after the class hierarchy.</p><p height="10" width="0" class="calibre5">To handle isolated identifiers, we have to react to two different
patterns, as shown in the following rule (invoked from <code class="calibre21">expr</code>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Ref.g">symtab/class/Ref.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">id <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// do usual resolve(ID) then check for illegal forward references</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ID.symbol = SymbolTable.resolveID($ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( $ID.symbol!=null ) $type = $ID.symbol.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; t=<em class="calibre6">'this'</em>&nbsp;&nbsp;{$type = SymbolTable.getEnclosingClass($t.<b class="calibre13">scope</b>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For <code class="calibre21">ID</code> nodes, we resolve them as usual but then check for illegal
forward references. We can factor that code out of the grammar into
our <code class="calibre21">SymbolTable</code> class:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/SymbolTable.java">symtab/class/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> Symbol resolveID(CymbolAST idAST) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = idAST.scope.resolve(idAST.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(<em class="calibre6">"line "</em>+idAST.getLine()+<em class="calibre6">": resolve "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idAST.getText()+<em class="calibre6">" to "</em>+s);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s.def==null ) <b class="calibre13">return</b> s; <em class="calibre6">// must be predefined symbol</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// if resolves to local or global symbol, token index of definition</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// must be before token index of reference</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> idLocation = idAST.token.getTokenIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> defLocation = s.def.token.getTokenIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( idAST.scope <b class="calibre13">instanceof</b> BaseScope &amp;&amp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.scope <b class="calibre13">instanceof</b> BaseScope &amp;&amp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; idLocation &lt; defLocation )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.err.println(<em class="calibre6">"line "</em>+idAST.getLine()+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">": error: forward local var ref "</em>+idAST.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">id</code> also matches keyword
<code class="calibre21">this</code>, which refers to the current object. So,
its type is the surrounding class. Because the
<code class="calibre21">this</code> reference could be buried in a deeply
nested local scope, we need to look upward in the enclosing scope
chain until we find the class scope.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/SymbolTable.java">symtab/class/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** 'this' and 'super' need to know about enclosing class */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> ClassSymbol getEnclosingClass(Scope s) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( s!=null ) { <em class="calibre6">// walk upwards from s looking for a class</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s <b class="calibre13">instanceof</b> ClassSymbol ) <b class="calibre13">return</b> (ClassSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s.getParentScope();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">There are a few other details in <code class="calibre21">Ref.g</code>, but weve covered the
important points.
</p><p height="10" width="0" class="calibre5">Finally, lets give our symbol table manager a workout.  The test rig
builds an AST from the source code and then walks it using <code class="calibre21">Def</code>s and <code class="calibre21">Ref</code>s <tt class="calibre21">downup</tt> strategies:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/Test.java">symtab/class/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(cymbalAdaptor, t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.setTokenStream(tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">SymbolTable symtab = <b class="calibre13">new</b> SymbolTable(); <em class="calibre6">// init symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Def def = <b class="calibre13">new</b> Def(nodes, symtab);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// create Def phase</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">def.downup(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Do pass 1</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"globals: "</em>+symtab.globals);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.reset(); <em class="calibre6">// rewind AST node stream to root</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Ref</b> ref = <b class="calibre13">new</b> <b class="calibre13">Ref</b>(nodes);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// create Ref phase</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ref.downup(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Do pass 2</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets run the test rig on <code class="calibre21">inherit.cymbol</code> (the numbered icons
identify the various scopes):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/symtab/class/inherit.cymbol">symtab/class/inherit.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">1&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// start of global scope&nbsp;&nbsp;&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">2&nbsp;</code></span><span><code class="calibre21"><em class="calibre6">// implicit class Object { int hashCode() {...} }&nbsp;&nbsp;// </em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">3&nbsp;</code></span><span><code class="calibre21">class A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">4&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">void</b> foo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">5&nbsp;</code></span><span><code class="calibre21"> { ; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">6&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">void</b> bar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">7&nbsp;</code></span><span><code class="calibre21"> { ; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">8&nbsp;</code></span><span><code class="calibre21">class B : public A {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">int</b> y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">9&nbsp;</code></span><span><code class="calibre21"> <b class="calibre13">void</b> foo()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">10</code></span><span><code class="calibre21"> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp; this.x = this.y;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">&nbsp;&nbsp; bar(); <em class="calibre6">// invoke A::bar()</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21"> }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span class="calibre44"><code class="calibre21">&nbsp;&nbsp;&nbsp;</code></span><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The output we get is as follows:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g Def.g Ref.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test &lt; inherit.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: def class A</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: def x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 6: def method foo</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: []&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">args: A.foo()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 8: def method bar</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: []&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">args: A.bar()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">members: class A:{x, foo, bar}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 11: def class B</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 12: def y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 13: def method foo</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">locals: []&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">args: B.foo()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">members: class B:{y, foo}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals: [int, float, void, A, B]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 3: set A</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: set var type &lt;A.x:global.int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 6: set method type &lt;A.foo():global.void&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 8: set method type &lt;A.bar():global.void&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 11: set B super to A</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 12: set var type &lt;B.y:global.int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 13: set method type &lt;B.foo():global.void&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 15: resolve this.x to &lt;A.x:global.int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 15: resolve this.y to &lt;B.y:global.int&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 16: resolve bar to &lt;A.bar():global.void&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Notice how, for example, the fields in assignments like <code class="calibre21">this.x =
this.y</code> resolve correctly (to <code class="calibre21">A.x</code> and <code class="calibre21">B.y</code> because of inheritance).
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern extends and alters the source code from Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>.
</p>

</div></div>
<div id="text/part0000_split_077.html"><div class="calibre">

<h2 id="text/part0000_split_077.html.d24e21841" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">This completes a two-chapter sequence on building symbol tables for
the four basic language scoping patterns.  At this point, weve got
the necessary infrastructure to start asking questions about the
source code. In the next chapter, well figure out how to enforce
static typing rules for languages like C++, Java, and C#.</p><div class="calibre3" id="text/part0000_split_077.html.calibre_pb_101"></div>

</div></div>
<div id="text/part0000_split_078.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_078.html.calibre_pb_102">&nbsp;</p><a id="text/part0000_split_078.html.toc-14"></a><h4 class="right2" id="text/part0000_split_078.html.chp.semantics">Chapter 8</h4>
</div></div>
<div id="text/part0000_split_079.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_079.html.calibre_pb_103">Enforcing Static Typing Rules</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">We derive the meaning of a sentence from both its structure (syntax)
and the particular vocabulary symbols it uses. The structure says what
to do, and the symbols say what to do it to. For example, in phrase
<code class="calibre21">print x</code>, the syntax says to print a value, and 
the symbol <code class="calibre21">x</code> says which value to print.
Sometimes, though, we write code that make no sense even if the syntax
is correct.  Such programs violate a languages semantic rules.
</p><p height="10" width="0" class="calibre5">Languages typically have lots and lots of semantic rules. Some rules
are run-time constraints (<em class="calibre6">dynamic semantics</em>), and some are
compile-time constraints (<em class="calibre6">static semantics</em>). Dynamic semantic
rules enforce things like no division by zero and no array index
out of bounds.  Depending on the language, we can enforce some rules
statically such as no multiplication of incompatible types.</p><p height="10" width="0" class="calibre5">Where to draw the line between static and dynamic rules is up to the
language designer. For example, Python is <em class="calibre6">dynamically typed</em>,
which means that programmers do not specify the types of program
values (nor can the compiler infer every type). The Python interpreter
enforces all the semantic rules at run-time. C++ is the opposite
extreme. Anything goes at run-time, but C++ is <em class="calibre6">statically typed</em>. We have to specify the types of all program
values. Some languages enforce the same rule statically and then again
dynamically to guard against hostile programs.  For example, Java does
type checking at compile-time as well as at run-time.  Both statically
and dynamically typed languages are called <em class="calibre6">type safe</em> if they
disallow operations on incompatible types.</p><p height="10" width="0" class="calibre5">Because statically typed languages are so common, we are going to
devote an entire chapter to enforcing static type safety (those
readers interested only in implementing dynamically typed languages
such as Python and Ruby can skip this chapter).  Here are the patterns
well discuss:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>. 
To guarantee type safety, the first thing
weve got to do is compute the types of all expressions and expression
elements.  We assume that the operands of a binary arithmetic
operation have the same type. There is no automatic promotion of
arithmetic values.  Most languages do automatically promote arithmetic
values, but technically type computation and promotion are two
different operations. Thats why well look at them separately in this
pattern and the next.</li><li height="6" class="calibre20"><span></span>Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a>.  
This pattern demonstrates how to promote
operands to have the same or otherwise compatible types. For example, in the
expression <code class="calibre21">3+4.5</code>, we expect the language to automatically promote
integer <code class="calibre21">3</code> to a floating-point value.</li><li height="6" class="calibre20"><span></span>Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.  
Once we know the types of all expressions, we
can enforce type safety.  This amounts to checking for
operand-operator and assignment type compatibility.
</li><li height="6" class="calibre20"><span></span>Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a>.  
The notion of type compatibility is a little
bit looser in object-oriented languages. We have to deal with
polymorphic assignments.  We can, for example, assign a
<code class="calibre21">Manager</code> object reference (pointer) to an <code class="calibre21">Employee</code> reference: <code class="calibre21">e =
m;</code>. Polymorphic means that a reference can point at multiple types.
In contrast, assignments in non-object-oriented languages must be
between identical types.  This pattern explains how to check
for polymorphic type compatibility.</li></ul><p height="10" width="0" class="calibre5">Before jumping into the patterns, we need to agree on a specific
language that we can use as a common thread throughout this chapter.
Theres no way we can describe all possible semantic rules for all
languages, so well have to focus on a single language.  Using C as a
base is a good choice because its the progenitor of the
statically typed languages commonly in use today (C++, C#, and Java).
For continuity, well augment our Cymbol language from
Chapter 6, <a href="#text/part0000_split_063.html.chp.symtab"><em class="calibre6">Tracking and Identifying Program Symbols</em></a> (with some more operators to make it
interesting). </p><p height="10" width="0" class="calibre5">Cymbol has the following features (when in doubt,
assume C++ syntax and semantics):</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>There are <code class="calibre21">struct</code>, function, and variable declarations.</li><li height="6" class="calibre20"><span></span>The built-in types are <code class="calibre21">float</code>,
<code class="calibre21">int</code>, <code class="calibre21">char</code>,
<code class="calibre21">boolean</code>, and <code class="calibre21">void</code>. Along with
built-in type <code class="calibre21">boolean</code>, we have
<code class="calibre21">true</code> and <code class="calibre21">false</code>
values.</li><li height="6" class="calibre20"><span></span>There are no explicit pointers (except in Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a>),
but there are one-dimensional arrays: <code class="calibre21">int a[];</code>. Like C++, we can
initialize variables as we declare them: <code class="calibre21">int i = 3;</code>. Also like C++,
we can declare local variables anywhere within a function, not just at
the start like C.</li><li height="6" class="calibre20"><span></span>There are <code class="calibre21">if</code>, <code class="calibre21">return</code>, assignment, and function call
statements.</li><li height="6" class="calibre20"><span></span>The operators are <code class="calibre21">+</code>,
<code class="calibre21">-</code>, <code class="calibre21">*</code>,
<code class="calibre21">/</code>, <code class="calibre21">&lt;</code>,
<code class="calibre21">&gt;</code>, <code class="calibre21">&lt;=</code>,
<code class="calibre21">&gt;=</code>, <code class="calibre21">!=</code>,
<code class="calibre21">==</code>, <code class="calibre21">!</code>, and unary
<code class="calibre21">-</code>. Beyond the usual expression atoms like
integers and identifiers, we can use function calls, array references,
and struct/class member accesses.</li></ul><p height="10" width="0" class="calibre5">Were going to enforce a number of type safety rules. In a
nutshell, all operations and value assignments must have compatible
operands. In Figure 23, <a href="#text/part0000_split_082.html.fig.sem-rules"><em class="calibre6">The type compatibility rules Cymbol enforces</em></a>, we see the exact list of
semantic type rules. Furthermore, were going to check symbol
categories.  The type of expressions on the left of the
<code class="calibre21">.</code> member access operator must be of type
<code class="calibre21">struct</code>. Identifiers in function calls must be
functions. Identifiers in array references must be array symbols.</p><p height="10" width="0" class="calibre5">Now we just have to figure out how to implement those rules. All 
the patterns in this chapter follow the same general three-pass
strategy.  In fact, they all share the first two passes. In the first
pass, a Cymbol parser builds an AST. In the second pass, a tree walker
builds a scope tree and populates a symbol
table. Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a> is the third pass over
the AST and computes the type of each expression.
Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a> augments this third pass to
promote arithmetic values as necessary.  Well assume valid input
until Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.  In that pattern, well add type
checking to the third tree pass to enforce our semantic rules.</p><p height="10" width="0" class="calibre5">In practice, you might squeeze the second and third or the first and
second passes into a single pass for efficiency.  It might even be
possible to reduce this to a single pass that parses, defines symbols,
computes types, and checks type compatibility.  Unless run-time speed
is critical, though, consider breaking complicated language applications
down into as many bite-size chunks as possible.</p><p height="10" width="0" class="calibre5">Table 6, <a href="#text/part0000_split_079.html.table.summary-apply-patterns"><em class="calibre6">A Summary of when to apply the patterns</em></a> gives a quick summary of when to apply the patterns.</p><hr class="calibre17"><div id="text/part0000_split_079.html.table.summary-apply-patterns" class="calibre1"><b class="calibre13">Table 6. A Summary of when to apply the patterns</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This pattern is a
component of any type safety checker such as Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a> and Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a>.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Automatically promoting
types is also really just a component of a type checker. If your
language doesnt support automatic promotion (like ML), you dont need
this pattern.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Youll need this
pattern if youre parsing a non-object-oriented programming
language such as C.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Use this pattern if
youre dealing with an object-oriented language such as C++ or Java.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5">OK, lets get to it.  Dont worry if the process of computing and
checking types seems complicated. Well take it slowly, component by
component.  In fact, static type
analysis for C and its descendents is not too bad.  The following
patterns break the problem down into easy-to-digest pieces.</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_080.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_080.html.tip.type-computation" class="pagebreak2"><small class="calibre35">Pattern 20:</small>&nbsp;&nbsp;&nbsp;Computing Static Expression Types</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"><em class="calibre6">This pattern explains how to statically compute the type of
expressions in languages with explicit type declarations like
C.</em>
</p><p height="10" width="0" class="calibre5">Youll be able to extrapolate from this pattern everything youd need
to build a static type analyzer for C, C++, Java, or C#. Every
compiler for those languages implements an extended version of this
pattern. So do static bug analyzers such as FindBugs<a id="text/part0000_split_080.html.FNPTR-23" href="#text/part0000_split_084.html.FOOTNOTE-23">[23]</a> and Coverity.<a id="text/part0000_split_080.html.FNPTR-24" href="#text/part0000_split_084.html.FOOTNOTE-24">[24]</a></p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Type computation is an extremely broad topic.  To make things more
concrete, well focus on the type computation rules for Cymbol
itemized here:</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Subexpression</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Result Type</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">true</code>, <code class="calibre21">false</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">boolean</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Character literal</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">char</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Integer literal</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Floating-point literal</p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">float</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">id</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The declared type of the variable
identified by <em class="calibre6">id</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">!</code><em class="calibre6">expr</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">boolean</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">-</code><em class="calibre6">expr</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The result type is the same as
<em class="calibre6">expr</em>s type.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">expr</em><code class="calibre21">.</code><em class="calibre6">id</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The declared type of the
field identified by <em class="calibre6">id</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">a[</code><em class="calibre6">expr</em><code class="calibre21">]</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The declared array element
type. For example, <code class="calibre21">a[i]</code> has type <code class="calibre21">float</code> if <code class="calibre21">a</code> has declaration
<code class="calibre21">float a[]</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">f(</code><em class="calibre6">args</em><code class="calibre21">)</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The declared return type
of function <code class="calibre21">f</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">expr</em>&nbsp;<em class="calibre6">bop</em>&nbsp;<em class="calibre6">expr</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Since both operands have the same type, we can
simply choose the type of the left operand as a result type;
<em class="calibre6">bop</em> is in {<code class="calibre21">+</code>, <code class="calibre21">-</code>, <code class="calibre21">*</code>, <code class="calibre21">/</code>}.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">expr</em>&nbsp;<em class="calibre6">relop</em>&nbsp;<em class="calibre6">expr</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">boolean</code> where <em class="calibre6">relop</em> is in {<code class="calibre21">&lt;</code>,
<code class="calibre21">&gt;</code>, <code class="calibre21">&lt;=</code>, <code class="calibre21">&gt;=</code>}.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">expr</em>&nbsp;<em class="calibre6">eqop</em>&nbsp;<em class="calibre6">expr</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">boolean</code> where <em class="calibre6">eqop</em> is in {<code class="calibre21">!=</code>, <code class="calibre21">==</code>}.</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">Computing the type of an expression is a matter of computing the
type of all elements and the result type of all operations.</p><p height="10" width="0" class="calibre5">For
example, to compute the type of
<code class="calibre21">f(1)+4*a[i]+s.x</code>, we proceed as follows:</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Subexpression</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Result Type</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">1</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">f(1)</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">4</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">i</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">a[i]</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">4*a[i]</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">f(1)+4*a[i]</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">s</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">struct</code>&nbsp;<code class="calibre21">S</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">s.x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">f(1)+4*a[i]+s.x</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">int</code></p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">These computations are pretty dull because were assuming the
operands are all the same type.  Technically, we could stop
computing the type after encountering first operand:
<code class="calibre21">f(1)</code>. The entire expression result type has
to be integer because <code class="calibre21">f</code> returns an
integer.</p><p height="10" width="0" class="calibre5">In practice, though, two things can happen: we might need to
promote a simpler type like <code class="calibre21">char</code> to
<code class="calibre21">int</code> and sometimes programmers make mistakes
(operand types can be incompatible). This pattern just sets up the
proper action plan for the next two patterns. Well graft type
promotion and type checking onto this pattern later.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">The general strategy well use is to parse a Cymbol program into an
AST and then walk that tree twice. 
The first tree walk defines symbols,
and the second walk resolves symbols and computes expression
types. The first two passes come from Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>, so we can focus on the final type
resolution and computation tree walk.</p><p height="10" width="0" class="calibre5">Once we have an AST and a populated symbol table (courtesy of
<code class="calibre21">Cymbol.g</code> and <code class="calibre21">Def.g</code>), we can
describe the type computation rules as tree pattern-action pairs.  The
actions compute types and annotate the AST with them.  Using Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>, we could walk the tree looking for the
patterns.  We have to be careful, though, how we match expression
elements. For example, we have to consider isolated identifiers and
identifiers in array references differently. In ANTLR notation, that
means we cant simply make a tree pattern rule like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">id : ID {<em class="calibre6">action</em>} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To encode context information, we need Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> rather than a set of isolated tree
patterns. That said, we dont want to resort to a full tree grammar
because we  care only about expressions in this pattern.  To get the
best of both worlds, we can use Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a> to look for
<code class="calibre21">EXPR</code> root nodes and then invoke a type computation
rule to traverse the expression subtree:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">bottomup <em class="calibre6">// match subexpressions innermost to outermost</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; exprRoot <em class="calibre6">// only match the start of expressions (root EXPR)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">exprRoot <em class="calibre6">// invoke type computation rule after matching EXPR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(EXPR expr) {$EXPR.evalType = $expr.type;} <em class="calibre6">// annotate AST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This way we only have to specify the type computation rules and can
totally ignore the AST structure outside of expressions.</p><p height="10" width="0" class="calibre5">The meat of our implementation is rule <code class="calibre21">expr</code>,
which computes the subexpression types:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@after</b> { $start.evalType = $type; } <em class="calibre6">// do after any alternative</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'true'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$type = SymbolTable._boolean;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'false'</em>&nbsp;&nbsp;&nbsp;&nbsp; {$type = SymbolTable._boolean;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; CHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$type = SymbolTable._char;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$type = SymbolTable._int;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; FLOAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$type = SymbolTable._float;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID {VariableSymbol s=(VariableSymbol)$ID.<b class="calibre13">scope</b>.resolve($ID.text);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ID.symbol = s; $type = s.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(UNARY_MINUS a=expr)&nbsp;&nbsp; {$type=symtab.uminus($a.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(UNARY_NOT a=expr)&nbsp;&nbsp;&nbsp;&nbsp; {$type=symtab.unot($a.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; member&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$type = $member.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; arrayRef&nbsp;&nbsp;&nbsp;&nbsp;{$type = $arrayRef.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$type = $call.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; binaryOps&nbsp;&nbsp; {$type = $binaryOps.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The first few alternatives encode the type computation rules with
in-line actions for the literals and identifiers.  The
<code class="calibre21">$ID.scope.resolve($ID.text)</code> expression
deserves some explanation. <code class="calibre21">$ID.text</code> is the
text of the identifier that we need to look up with
<tt class="calibre21">resolve</tt>. <tt class="calibre21">resolve</tt>
needs the identifiers context (surrounding scope), which our
definition phase conveniently stashed as the <code class="calibre21">ID</code> AST
nodes <code class="calibre21">scope</code> field. Expression
<code class="calibre21">$start</code> refers to the first node matched by
enclosing rule <code class="calibre21">expr</code>.</p><p height="10" width="0" class="calibre5">The tree grammar handles the more complicated patterns via a few
small helper rules in <code class="calibre21">SymbolTable</code> such as <tt class="calibre21">uminus</tt> and <tt class="calibre21">unot</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/SymbolTable.java">semantics/types/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> uminus(CymbolAST a) { <b class="calibre13">return</b> a.evalType; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> unot(CymbolAST a)&nbsp;&nbsp; { <b class="calibre13">return</b> _boolean; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">expr</code> also annotates the root of the subexpression subtree
with the type it computes (via <code class="calibre21">$start.evalType = $type;</code>). Because a static type analyzer is normally
just a component of a larger language application, we need to store
type information somewhere rather than throwing it out.  Well store the
type in field <code class="calibre21">evalType</code> of a customized AST node, <code class="calibre21">CymbolAST</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/CymbolAST.java">semantics/types/CymbolAST.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> CymbolAST <b class="calibre13">extends</b> CommonTree {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Scope scope;&nbsp;&nbsp; <em class="calibre6">// set by Def.g; ID lives in which scope?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Symbol symbol; <em class="calibre6">// set by Types.g; point at def in symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Type</b> evalType; <em class="calibre6">// The type of an expression; set by Types.g</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Continuing on with the type computation rules, here is how to compute
the type of a member access operation:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">member <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'.'</em> expr ID)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// match expr.ID subtrees</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <em class="calibre6">// $expr.start is root of tree matched by expr rule</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$type = symtab.member($expr.start, $ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$start.evalType = $type; <em class="calibre6">// save computed type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Notice that the left side of the operation can be any expression
according to the grammar. This handles cases such as functions that
return <code class="calibre21">struct</code> values as in <code class="calibre21">f().fieldname</code>.  The <tt class="calibre21">member</tt> method
in the <code class="calibre21">SymbolTable</code> looks up the field within the scope of the
expression on the left side:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/SymbolTable.java">semantics/types/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> member(CymbolAST expr, CymbolAST field) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StructSymbol scope=(StructSymbol)expr.evalType; <em class="calibre6">// get scope of expr</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = scope.resolveMember(field.getText());<em class="calibre6">// resolve ID in scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;field.symbol = s;&nbsp;&nbsp;<em class="calibre6">// make AST point into symbol table</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> s.type;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// return ID's type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It retrieves the type of the expression via the <code class="calibre21">evalType</code> AST
field. <code class="calibre21">evalType</code> is set as a side effect of calling rule <code class="calibre21">expr</code> in <code class="calibre21">member</code> and must point at a <code class="calibre21">StructSymbol</code>.</p><p height="10" width="0" class="calibre5">The next rule computes types for array references. It also delegates
the type computation to <code class="calibre21">SymbolTable</code> (the actions for these rules
will get bigger in the following patterns; its a good idea to tuck
them out of the way as methods in another class):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">arrayRef <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(INDEX ID expr)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$type = symtab.arrayIndex($ID, $expr.start);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$start.evalType = $type; <em class="calibre6">// save computed type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The type of an array reference is just the element type of the array (the index isnt needed):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/SymbolTable.java">semantics/types/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> arrayIndex(CymbolAST id, CymbolAST index) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol vs = (VariableSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = vs;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> ((<b class="calibre13">ArrayType</b>)vs.type).elementType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Function calls consist of the function name and an optional list of
expressions for the arguments. The <code class="calibre21">call</code> rule collects all this
information and passes it to a helper in <code class="calibre21">SymbolTable</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">call <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@init</b> {List args = new ArrayList();}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(CALL ID ^(ELIST (expr {args.add($expr.start);})*))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$type = symtab.call($ID, args);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$start.evalType = $type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The type of a function call is the return type of the function (well
ignore the argument types until we do type promotion and type
checking):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/SymbolTable.java">semantics/types/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> call(CymbolAST id, <b class="calibre13">List</b> args) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;MethodSymbol ms = (MethodSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = ms;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> ms.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Finally, we come to the binary operators (binary in the sense that
they have two operands). It turns out that well ultimately need to
deal separately with the arithmetic, relational, and equality
operators. For consistency with future patterns, well trigger
different helper methods:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Types.g">semantics/types/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">binaryOps <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@after</b> { $start.evalType = $type; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(bop a=expr b=expr)&nbsp;&nbsp; {$type=symtab.bop($a.start, $b.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(relop a=expr b=expr) {$type=symtab.relop($a.start, $b.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ^(eqop a=expr b=expr)&nbsp;&nbsp;{$type=symtab.eqop($a.start, $b.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because we assume that the operand types of arithmetic operators are
identical, there is no computation to do.  We can just arbitrarily
pick the type of the left operand. The relational and the equality
operators always yield <code class="calibre21">boolean</code> types:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/SymbolTable.java">semantics/types/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> bop(CymbolAST a, CymbolAST b)&nbsp;&nbsp; { <b class="calibre13">return</b> a.evalType; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> relop(CymbolAST a, CymbolAST b) { <b class="calibre13">return</b> _boolean; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> eqop(CymbolAST a, CymbolAST b)&nbsp;&nbsp;{ <b class="calibre13">return</b> _boolean; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To put everything together, we need to build an AST and then perform
two tree walks:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Test.java">semantics/types/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// CREATE PARSER AND BUILD AST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CymbolLexer lex = <b class="calibre13">new</b> CymbolLexer(input);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">final</b> TokenRewriteStream tokens = <b class="calibre13">new</b> TokenRewriteStream(lex);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CymbolParser p = <b class="calibre13">new</b> CymbolParser(tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p.setTreeAdaptor(CymbolAdaptor);&nbsp;&nbsp;<em class="calibre6">// create CymbolAST nodes</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">RuleReturnScope r = p.compilationUnit();&nbsp;&nbsp; <em class="calibre6">// launch parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTree t = (CommonTree)r.getTree();&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// get tree result</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// CREATE TREE NODE STREAM FOR TREE PARSERS</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.setTokenStream(tokens);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// where to find tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.setTreeAdaptor(CymbolAdaptor);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">SymbolTable symtab = <b class="calibre13">new</b> SymbolTable();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// DEFINE SYMBOLS</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Def def = <b class="calibre13">new</b> Def(nodes, symtab); <em class="calibre6">// pass symtab to walker</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">def.downup(t); <em class="calibre6">// trigger define actions upon certain subtrees</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// RESOLVE SYMBOLS, COMPUTE EXPRESSION TYPES</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.reset();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Types</b> typeComp = <b class="calibre13">new</b> <b class="calibre13">Types</b>(nodes, symtab);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">typeComp.downup(t); <em class="calibre6">// trigger resolve/type computation actions</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After the tree walks, we have annotated all nodes within
expressions with two pointers.  <code class="calibre21">symbol</code>
points at its symbol definition in the symbol table, and
<code class="calibre21">evalType</code> points at the nodes computed
type. To print out our handiwork, we can use Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a> to trigger a method called
<tt class="calibre21">showTypes</tt> on each expression node. To get a
bottom-up, innermost to outermost traversal, we use a postorder
walk:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Test.java">semantics/types/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// WALK TREE TO DUMP SUBTREE TYPES</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TreeVisitor v = <b class="calibre13">new</b> TreeVisitor(<b class="calibre13">new</b> CommonTreeAdaptor());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TreeVisitorAction actions = <b class="calibre13">new</b> TreeVisitorAction() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Object</b> pre(<b class="calibre13">Object</b> t) { <b class="calibre13">return</b> t; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Object</b> post(<b class="calibre13">Object</b> t)&nbsp;&nbsp;{</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showTypes((CymbolAST)t, tokens);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> t;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">v.visit(t, actions); <em class="calibre6">// walk in postorder, showing types</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">showTypes</tt> just prints out subexpressions and their types for
nodes with non-null <code class="calibre21">evalType</code> fields:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/Test.java">semantics/types/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">static</b> <b class="calibre13">void</b> showTypes(CymbolAST t, TokenRewriteStream tokens) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( t.evalType!=null &amp;&amp; t.getType()!=CymbolParser.EXPR ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.printf(<em class="calibre6">"%-17s"</em>,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.toString(t.getTokenStartIndex(),</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.getTokenStopIndex()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> ts = t.evalType.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.printf(<em class="calibre6">" type %-8s</em>\n<em class="calibre6">"</em>, ts);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets run the following sample Cymbol file through our test rig:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/types/t.cymbol">semantics/types/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">struct</b> A {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> B { <b class="calibre13">int</b> y; };</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> B b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> i=0; <b class="calibre13">int</b> j=0;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> A a;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;a.x = 1+i*j;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;a.b.y = 2;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;boolean b = 3==a.x;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">if</b> ( i &lt; j ) f();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Heres how to build the test rig and run it on <code class="calibre21">t.cymbol</code> (its the
same for all patterns in this chapter):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g Def.g Types.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test t.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type struct A:{x, B, b}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a.x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i*j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1+i*j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type struct A:{x, B, b}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a.b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type struct B:{y}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a.b.y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type struct A:{x, B, b}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a.x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">3==a.x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type boolean</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type int</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i &lt; j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type boolean</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type void</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This pattern identifies the basic type computations for expression
elements and operations. Its fairly restrictive in that operand types
within a single operation must be identical such as integer plus
integer. Still, weve created the basic infrastructure needed to
support automatic promotion such as adding integers and floats. The
next pattern defines the rules for arithmetic type promotion and
provides a sample implementation. Its implementation builds upon the
source code in this pattern.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern uses Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a> to build a scope tree and
populate the symbol table.  It uses Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a> to print out type
information.  Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a>, Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>, and Pattern 23, <a href="#text/part0000_split_083.html.tip.type-safety-oo"><em class="calibre6">Enforcing Polymorphic Type Safety</em></a> build upon this pattern.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_081.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_081.html.tip.type-promotion" class="pagebreak2"><small class="calibre35">Pattern 21:</small>&nbsp;&nbsp;&nbsp;Automatic Type Promotion</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"><em class="calibre6">This pattern describes how to automatically and safely
promote arithmetic operand types.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The goal of automatic type promotion is to get all operands of a
single operation to be of the same type or compatible types.  Thats
just how computer CPU instructions want their operands.
Unfortunately, thats fairly inconvenient from a programming point of
view. We often want to use a variety of types within the same
operation such as <code class="calibre21">3+'0'</code>. Most programming languages would, for
example, interpret <code class="calibre21">3+'0'</code> as <code class="calibre21">3+(int)'0'</code>.  </p><p height="10" width="0" class="calibre5">A language application can convert between types at will as long as it
doesnt lose information. For example, we can convert 4 to 4.0 but
cant convert 4.5 to integer 4 without losing information. We call
such automatic conversion <em class="calibre6">promotion</em> because we can <em class="calibre6">widen</em>
types without problem but cant <em class="calibre6">narrow</em> them in general.</p><p height="10" width="0" class="calibre5">There is a simple formula that expresses the valid type-to-type
promotions. First, order and number the arithmetic types from
narrowest to widest.  Then, we can automatically promote type<sub class="calibre48">i</sub> to type<sub class="calibre48">j</sub> as
long as <em class="calibre6">i</em> &lt; <em class="calibre6">j</em>. In our C++ subset Cymbol language, the
ordered arithmetic type list is as follows: <code class="calibre21">char</code>, <code class="calibre21">int</code>, and <code class="calibre21">float</code>.
That means we can automatically convert <code class="calibre21">char</code> to <code class="calibre21">int</code> and <code class="calibre21">float</code> as well as <code class="calibre21">int</code> to <code class="calibre21">float</code>.</p><p height="10" width="0" class="calibre5">Compiler semantic analyzers use 
static type analyzers to figure out
which elements and subexpressions to promote. Typically, they modify
an intermediate representation tree to incorporate value promotion
nodes. Translators can usually get away with just annotating their
tree and checking for promotions later during code generation, which
is a lot easier than altering the tree.</p><p height="10" width="0" class="calibre5">Besides expressions, static type analyzers have to promote values in
assignments, return statements, arrayindex expressions, and function call 
arguments. For example, in <code class="calibre21">float f = 1;</code>, the programmer
shouldnt have to manually promote <code class="calibre21">1</code> to a floating-point value.
Similarly, in <code class="calibre21">a['z']</code>, wed expect a type
analyzer to promote <code class="calibre21">'z'</code> to an integer.</p><p height="10" width="0" class="calibre5">To implement arithmetic type promotion, we need two functions. The
first returns the result type given an operator and two operand types. The
second tells us whether we need to promote an operand for a particular
operator and destination type. </p><p height="10" width="0" class="calibre5">To compute operation result types, we need a function that takes two
operand types and an operator as parameters:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">resultType</code>(type<sub class="calibre48">1</sub>, <em class="calibre6">op</em>, type<sub class="calibre48">2</sub>)</p><p height="10" width="0" class="calibre5">For example, adding a character and an integer yields an integer:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">resultType</code>(<code class="calibre21">char</code>, "+", <code class="calibre21">int</code>) == <code class="calibre21">int</code></p><p height="10" width="0" class="calibre5">The operator is as important as the operand types. Comparing a <code class="calibre21">char</code> and an <code class="calibre21">int</code> yields a <code class="calibre21">boolean</code> not an <code class="calibre21">int</code>:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">resultType</code>(<code class="calibre21">char</code>, "&lt;", <code class="calibre21">int</code>) == <code class="calibre21">boolean</code></p><p height="10" width="0" class="calibre5">Comparing boolean operands for equality is OK but not for less-than
and the other relational operators:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">resultType</code>(<code class="calibre21">boolean</code>, "==", <code class="calibre21">boolean</code>) == <code class="calibre21">boolean</code></p><p height="10" width="0" class="calibre5"> <code class="calibre21">resultType</code>(<code class="calibre21">boolean</code>, "&lt;", <code class="calibre21">boolean</code>) == <code class="calibre21">void</code></p><p height="10" width="0" class="calibre5">A result type of <code class="calibre21">void</code> indicates the operation is illegal, which
well exploit in Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.</p><p height="10" width="0" class="calibre5">We need one more function.  The <code class="calibre21">resultType</code> function says what the
operation result type is but does not directly tell us whether we need to
promote either of the operands. For that, we need the following
function:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">promoteFromTo</code>(<em class="calibre6">type</em>, <em class="calibre6">op</em>, <em class="calibre6">destination-type</em>)</p><p height="10" width="0" class="calibre5">It tells us whether we need to promote an operand type to another type for a
given operator.  For example, we know from <code class="calibre21">resultType</code> that adding a
character and an integer yields an integer.  An operand type of <code class="calibre21">char</code> and a destination type of <code class="calibre21">int</code> for addition indicates we need
to promote the <code class="calibre21">char</code> to <code class="calibre21">int</code>:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">promoteFromTo</code>(<code class="calibre21">char</code>, "+", <code class="calibre21">int</code>) == <code class="calibre21">int</code></p><p height="10" width="0" class="calibre5">For the right operand, though, we dont need a promotion:</p><p height="10" width="0" class="calibre5"> <code class="calibre21">promoteFromTo</code>(<code class="calibre21">int</code>, "+", <code class="calibre21">int</code>) == <code class="calibre21">null</code></p><p height="10" width="0" class="calibre5">A promotion result of <code class="calibre21">null</code> means no promotion necessary not
invalid promotion.</p><p height="10" width="0" class="calibre5">Lets compute the result type and promote operands as necessary for
expression <code class="calibre21">'a'+3+4.2</code>. If we added type casts to make the promotions
explicit, wed write <code class="calibre21">(float)((int)'a'+3)+4.2</code>. (Our Cymbol C++ subset
doesnt have doubles, so well use <code class="calibre21">float</code>.)  To store the results of
functions <code class="calibre21">resultType</code> and <code class="calibre21">promoteFromTo</code>, we annotate the AST nodes:</p><div class="calibre1"><img id="text/part0000_split_081.html.d24e23726" class="calibre47" src="data:image/gif;base64,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" alt="images/semantics/char-int-AST.png"></div><p height="10" width="0" class="calibre5">Each node knows its evaluation type and promotion type (if any).  For
example, the node for <code class="calibre21">'a'</code> evaluates to <code class="calibre21">char</code> but promotes to <code class="calibre21">int</code> for the addition operation (its parent). The <code class="calibre21">3</code> node evaluates
to <code class="calibre21">int</code> and doesnt need a promotion. The result of the lower
addition operation is also <code class="calibre21">int</code> but needs a promotion to <code class="calibre21">float</code>.</p><p height="10" width="0" class="calibre5">The next section describes exactly how to implement functions
<code class="calibre21">resultType</code> and
<code class="calibre21">promoteFromTo</code> in Java and how to fold automatic type promotion into the
sample Cymbol implementation from Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">When confronted with this type promotion problem for the first
time, I wrote out all the type promotion cases with a series of
<code class="calibre21">if</code>-statements. It was slow and fragile.  
I finally figured out that assigning a type index would reduce that mess
to a few comparisons. Ultimately, I boiled everything down to a few
table lookups using operand types as indexes.  For each operator, I
made a table that told me how to map any two operand types to a result
type.  Aside from being extremely efficient, the tables make it
easy to see the valid operand types and promotions.</p><p height="10" width="0" class="calibre5">To implement Cymbols result type tables in Java, lets start with the type
indexes:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// arithmetic types defined in order from narrowest to widest</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tUSER = 0; <em class="calibre6">// user-defined type (struct)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tBOOLEAN = 1;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tCHAR = 2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tINT = 3;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tFLOAT = 4;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> tVOID = 5;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then we need to define the types.  For example, heres the built-in
type for <code class="calibre21">int</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> BuiltInTypeSymbol _int =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> BuiltInTypeSymbol(<em class="calibre6">"int"</em>, tINT);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">With those definitions in place, we can flesh out our result type
table for the arithmetic operators. (The type tables for equality and
relational operators are similar except every entry in the table is
<code class="calibre21">boolean</code>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Map t1 op t2 to result type (_void implies illegal) */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> arithmeticResultType = <b class="calibre13">new</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;&nbsp;boolean&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp; float,&nbsp;&nbsp; void */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*struct*/</em>&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*boolean*/</em> {_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*char*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _char,&nbsp;&nbsp;_int,&nbsp;&nbsp; _float,&nbsp;&nbsp;_void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*int*/</em>&nbsp;&nbsp;&nbsp;&nbsp; {_void, _void,&nbsp;&nbsp; _int,&nbsp;&nbsp; _int,&nbsp;&nbsp; _float,&nbsp;&nbsp;_void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*float*/</em>&nbsp;&nbsp; {_void, _void,&nbsp;&nbsp; _float, _float, _float,&nbsp;&nbsp;_void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*void*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To compute the result of an arithmetic operation on a character and
an integer, evaluate <code class="calibre21">arithmeticResultType[tCHAR][tINT]</code>. The result
type is <code class="calibre21">Type</code>&nbsp;<code class="calibre21">_int</code>.
The type promotion table works the same
way. <code class="calibre21">promoteFrom-</code><code class="calibre21">To[tCHAR][tINT]</code> gives <code class="calibre21">_int</code>, but
<code class="calibre21">promoteFromTo[tINT][tINT]</code> gives <code class="calibre21">null</code>.  Because of the
semantics of Cymbol, we can get away with a single promotion table. It
works not only for the operators but also for checking parameter
types, array index types, and so on. For example, <code class="calibre21">a['z']</code> needs to
promote <code class="calibre21">'z'</code> to an integer. Heres the table:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Indicate whether a type needs a promotion to a wider type.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;If not null, implies promotion required.&nbsp;&nbsp;Null does NOT imply</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;error--it implies no promotion.&nbsp;&nbsp;This works for</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;arithmetic, equality, and relational operators in Cymbol.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> promoteFromTo = <b class="calibre13">new</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;&nbsp;boolean&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp; float,&nbsp;&nbsp; void */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*struct*/</em>&nbsp;&nbsp;{null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null,&nbsp;&nbsp; null,&nbsp;&nbsp;&nbsp;&nbsp;null},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*boolean*/</em> {null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null,&nbsp;&nbsp; null,&nbsp;&nbsp;&nbsp;&nbsp;null},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*char*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; _int,&nbsp;&nbsp; _float,&nbsp;&nbsp;null},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*int*/</em>&nbsp;&nbsp;&nbsp;&nbsp; {null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null,&nbsp;&nbsp; _float,&nbsp;&nbsp;null},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*float*/</em>&nbsp;&nbsp; {null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*void*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{null,&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null,&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp; null}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets fold these type computation tables into the code we built for
Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>. The first thing we need to do is alter the
operator result type support methods in <code class="calibre21">SymbolTable</code>. For a
specified type table, the following method computes the result
type. It annotates the AST with operand promotion types as a side
effect.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> getResultType(<b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> typeTable, CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> ta = a.evalType.getTypeIndex(); <em class="calibre6">// type index of left operand</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tb = b.evalType.getTypeIndex(); <em class="calibre6">// type index of right operand</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> result = typeTable[ta][tb];&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// operation result type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// promote operand types to result type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a.promoteToType = promoteFromTo[ta][result];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;b.promoteToType = promoteFromTo[tb][result];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> result;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The three support methods called from rule <code class="calibre21">binaryOps</code> now call <tt class="calibre21">getResultType</tt> with the appropriate type table:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> bop(CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> getResultType(arithmeticResultType, a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> relop(CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> getResultType(relationalResultType, a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> eqop(CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> getResultType(equalityResultType, a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">arrayIndex</tt> is the same as before except we promote the index
to an integer if necessary:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> arrayIndex(CymbolAST id, CymbolAST index) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText()); <em class="calibre6">// resolve variable</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol vs = (VariableSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = vs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// annotate AST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> t = ((<b class="calibre13">ArrayType</b>)vs.type).elementType; <em class="calibre6">// get element type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> texpr = index.evalType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;index.promoteToType = promoteFromTo[texpr][tINT]; <em class="calibre6">// promote index?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> t;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For method calls, we have to promote argument expressions to the type
specified in the functions formal parameter list:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** For g('q',10), promote 'q' to int, 10 to float</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;Given int g(int x, float y) {...} */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> call(CymbolAST id, <b class="calibre13">List</b> args) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;MethodSymbol ms = (MethodSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = ms;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> i=0;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (Symbol a : ms.orderedArgs.values() ) { <em class="calibre6">// for each arg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CymbolAST argAST = (CymbolAST)args.get(i++);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// get argument expression type and expected type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> actualArgType = argAST.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> formalArgType = ((VariableSymbol)a).type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> targ = actualArgType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tformal = formalArgType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// do we need to promote argument type to defined type?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argAST.promoteToType = promoteFromTo[targ][tformal];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> ms.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We also need some rules in <code class="calibre21">Types.g</code> to handle variable
initialization, return statements, and assignment:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/Types.g">semantics/promote/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">decl:&nbsp;&nbsp; ^(VAR_DECL . ID (<b class="calibre13">init</b>=.)?) <em class="calibre6">// call declinit if we have init expr</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{if ( $<b class="calibre13">init</b>!=null &amp;&amp; $<b class="calibre13">init</b>.evalType!=null )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; symtab.declinit($ID, $<b class="calibre13">init</b>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ret :&nbsp;&nbsp; ^(<em class="calibre6">'return'</em> v=.) {symtab.ret((MethodSymbol)$start.symbol, $v);} ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assignment <em class="calibre6">// don't walk exprs, just examine types; '.' is wildcard</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'='</em> lhs=. rhs=.) {symtab.assign($lhs, $rhs);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Those rules delegate to helper methods in <code class="calibre21">SymbolTable</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/SymbolTable.java">semantics/promote/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> declinit(CymbolAST id, CymbolAST init) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> te = init.evalType.getTypeIndex(); <em class="calibre6">//promote expr to decl type?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tdecl = id.symbol.type.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;init.promoteToType = promoteFromTo[te][tdecl];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> ret(MethodSymbol ms, CymbolAST expr) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> retType = ms.type; <em class="calibre6">//promote return expr to function decl type?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> exprType = expr.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> texpr = exprType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tret = retType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;expr.promoteToType = promoteFromTo[texpr][tret];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> assign(CymbolAST lhs, CymbolAST rhs) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tlhs = lhs.evalType.getTypeIndex(); <em class="calibre6">// promote right to left?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> trhs = rhs.evalType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;rhs.promoteToType = promoteFromTo[trhs][tlhs];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At this point, weve augmented our tree walker to deal with both
expressions and statements that might need type promotions. Further,
weve annotated our ASTs with these results. To check our work, we
need to see those annotations. Rather than printing out the trees,
lets print the original source code back out augmented with type
casts as necessary.  Our goal is to read in a Cymbol file such as this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/t.cymbol">semantics/promote/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">float</b> a[];&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> d[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> c = 'z'+1;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// check variable init (no promote on int)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[0] = 4*'i'; <em class="calibre6">// promote char to int to float</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[1] = d[0];&nbsp;&nbsp;<em class="calibre6">// promote int element to float</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a['x'] = 1;&nbsp;&nbsp; <em class="calibre6">// check array index promotion</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;g('q',10);&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// arg promotion</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> g(<b class="calibre13">int</b> x, <b class="calibre13">float</b> y) { <b class="calibre13">return</b> 'k'; } <em class="calibre6">// promote 'k' to int</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">and print it back out with explicit casts:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">float</b> a[];&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> d[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> c = (<b class="calibre13">int</b>)'z'+1;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// check variable init (no promote on int)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[0] = (<b class="calibre13">float</b>)(4*(<b class="calibre13">int</b>)'i'); <em class="calibre6">// promote char to int to float</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[1] = (<b class="calibre13">float</b>)d[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// promote int element to float</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[(<b class="calibre13">int</b>)'x'] = (<b class="calibre13">float</b>)1;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// check array index promotion</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;g((<b class="calibre13">int</b>)'q',(<b class="calibre13">float</b>)10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// arg promotion</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> g(<b class="calibre13">int</b> x, <b class="calibre13">float</b> y) { <b class="calibre13">return</b> (<b class="calibre13">int</b>)'k'; } <em class="calibre6">// promote 'k' to int</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To tweak the original source code, we need a bit of magic.  There are
two approaches. One way involves walking the AST with a clever visitor
or tree grammar that knows how to map subtrees to output text.  Thats
a lot of work and cant easily reproduce the original formatting. Its
simpler to just to insert type casts directly into the original source
code text buffer at the right spot and then print it out.</p><p height="10" width="0" class="calibre5">The only
negative is efficiency. It takes a lot of data movement to insert a
string into the middle of the character buffer. For a large buffer and
lots of insertions, thats prohibitively expensive.</p><p height="10" width="0" class="calibre5">Theres a way to do this efficiently using ANTLRs
<code class="calibre21">TokenRewriteStream</code>. (Well see it again in
<a href="#text/part0000_split_131.html.sec.tweak-source"><em class="calibre6">Tweaking Source Code</em></a> and <a href="#text/part0000_split_132.html.sec.add-type"><em class="calibre6">Adding a New Type to Java</em></a>.) It records all the insertion commands and
then executes them as it prints the buffer back out.
Using Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>, the test rig invokes method
<tt class="calibre21">insertCast</tt> for every node with non-null
  <code class="calibre21">promoteToType</code>, as shown in the code in Figure 22, <a href="#text/part0000_split_081.html.code.Test.java"><em class="calibre6">Test.java using ANTLR;s TokenRewriteStream class</em></a>.</p><div class="calibre1" id="text/part0000_split_081.html.code.Test.java"><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/promote/Test.java">semantics/promote/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Insert a cast before tokens from which this node was created. */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">static</b> <b class="calibre13">void</b> insertCast(CymbolAST t, TokenRewriteStream tokens) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> cast = <em class="calibre6">"("</em>+t.promoteToType+<em class="calibre6">")"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> left =&nbsp;&nbsp;t.getTokenStartIndex(); <em class="calibre6">// location in token buffer</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> right = t.getTokenStopIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token tok = t.token;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// tok is node's token payload</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( tok.getType() == CymbolParser.EXPR ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tok = ((CymbolAST)t.getChild(0)).token;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( left==right ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tok.getType()==CymbolParser.INDEX ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tok.getType()==CymbolParser.CALL )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{ <em class="calibre6">// it's a single atom or a[i] or f(); don't use (...)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.insertBefore(left, cast);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> { <em class="calibre6">// need parens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> original = tokens.toString(left, right);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens.replace(left, right, cast+<em class="calibre6">"("</em>+original+<em class="calibre6">")"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><hr class="calibre17"><b class="calibre13">Figure 21. Test.java using ANTLR;s <code class="calibre21">TokenRewriteStream</code> class</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Except for error checking, we now have a static type analyzer!  In the
next pattern well add type checking and a few other semantic checks
because we cant assume valid input.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">Automatic arithmetic type promotion goes hand in hand with result type
computations, Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>.  Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a> builds upon
this pattern to emit error messages.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_082.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_082.html.tip.type-safety" class="pagebreak2"><small class="calibre35">Pattern 22:</small>&nbsp;&nbsp;&nbsp;Enforcing Static Type Safety</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"><em class="calibre6">This pattern statically detects incompatible types in
expressions and statements.</em>
</p><p height="10" width="0" class="calibre5">You can extrapolate from this pattern everything youd need to build a
type safety checker for any statically typed language with explicit
declarations like C.  Tools such as compilers that translate or
otherwise analyze a statically typed language need this pattern.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">A static type checker adds 
type compatibility checks to Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a> (which is, in turn, based upon Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a>).
Were going to enforce the type compatibility checks described in Figure 23, <a href="#text/part0000_split_082.html.fig.sem-rules"><em class="calibre6">The type compatibility rules Cymbol enforces</em></a>. </p><div class="calibre1" id="text/part0000_split_082.html.fig.sem-rules"><ol class="calibre46"><li height="8" value="1" class="calibre20"><span></span><code class="calibre21">if</code> conditionals must evaluate to a <code class="calibre21">boolean</code> value.</li><li height="8" value="2" class="calibre20"><span></span>Array reference indexes must be integers.</li><li height="8" value="3" class="calibre20"><span></span>The left and right sides of an assignment must have
compatible types.</li><li height="8" value="4" class="calibre20"><span></span>Function call arguments and formal function declarations must
have compatible types.</li><li height="8" value="5" class="calibre20"><span></span><code class="calibre21">return</code> expressions and function return types must be compatible.</li><li height="8" value="6" class="calibre20"><span></span>The two operands of a binary arithmetic operation must have
compatible types.</li><li height="8" value="7" class="calibre20"><span></span>The operand of unary operators must have an appropriate type.</li></ol><hr class="calibre17"><b class="calibre13">Figure 22. The type compatibility rules Cymbol enforces</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">In a nutshell, type compatibility means two things:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>An operation must be defined for the operand types its applied
to. <code class="calibre21">resultType</code>(operandtype<sub class="calibre48">1</sub>, <em class="calibre6">op</em>, operandtype<sub class="calibre48">2</sub>) != <code class="calibre21">void</code></li><li height="6" class="calibre20"><span></span>If were looking for a value of type <em class="calibre6">t</em>, the value
must be of type <em class="calibre6">t</em> or promotable to <em class="calibre6">t</em>.<br height="8" class="calibre1"><em class="calibre6">value-type</em>==<em class="calibre6">destination-type</em>
<code class="calibre21">||</code>
<em class="calibre6">value-promoted-type</em>==<em class="calibre6">destination-type</em>.<br height="8" class="calibre1">This
ensures that we dont copy data between incompatible types. We can
call this computation <code class="calibre21">canAssignTo</code>.</li></ul><p height="10" width="0" class="calibre5">While were at it, we might as well enforce the following symbol
category rules as well:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>In <code class="calibre21">x.y</code>, <code class="calibre21">x</code> must be a <code class="calibre21">struct</code>.</li><li height="6" class="calibre20"><span></span>In <code class="calibre21">f()</code>, <code class="calibre21">f</code> must be a function symbol.</li><li height="6" class="calibre20"><span></span>In <code class="calibre21">a[...]</code>, <code class="calibre21">a</code> must be an array symbol.</li></ul><p height="10" width="0" class="calibre5">To implement type safety, we need to add
<code class="calibre21">resultType</code> checks,
<code class="calibre21">canAssignTo</code> checks, or both. In the next
section, well add them to the helper methods of
<code class="calibre21">SymbolTable</code>.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Adding type checks to Pattern 21 is not
particularly difficult, but it requires widespread changes.  
To make it
easier to digest, well break the problem down into manageable
chunks. Lets start with the expression operators.</p><h4 class="calibre26">Checking Expression Operand Types</h4><p height="10" width="0" class="calibre5">To check for compatible operand types, all weve got to do is watch for
a <code class="calibre21">void</code> result type. The <tt class="calibre21">getResultType</tt> method is the same except
for the error check:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type getResultType(Type[][] typeTable, CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> ta = a.evalType.getTypeIndex(); <em class="calibre6">// type index of left operand</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tb = b.evalType.getTypeIndex(); <em class="calibre6">// type index of right operand</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Type result = typeTable[ta][tb];&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// operation result type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( result==_void ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(a)+<em class="calibre6">", "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text(b)+<em class="calibre6">" have incompatible types in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)a.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.promoteToType = promoteFromTo[ta][tb];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.promoteToType = promoteFromTo[tb][ta];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> result;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">text</tt> method computes the original source code from which we
created the subtree.  <tt class="calibre21">getResultType</tt> works for relational and
equality operators as well as the binary arithmetic operators like
plus and multiply. The only difference is that the result type of
relational and equality operators is always boolean:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type relop(CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;getResultType(relationalResultType, a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// even if the operands are incompatible, the type of</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// this operation must be boolean</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _boolean;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type eqop(CymbolAST a, CymbolAST b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;getResultType(equalityResultType, a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _boolean;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The unary operators explicitly check for particular types:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type uminus(CymbolAST a) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !(a.evalType==_int || a.evalType==_float) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(a)+<em class="calibre6">" must have int/float type in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)a.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _void;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> a.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type unot(CymbolAST a) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( a.evalType!=_boolean ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(a)+<em class="calibre6">" must have boolean type in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)a.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _boolean; <em class="calibre6">// even though wrong, assume result boolean</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> a.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For member access expressions, we only have to check that the left
operand evaluates to a <code class="calibre21">struct</code>.</p><p height="10" width="0" class="calibre5">Here is the check from <tt class="calibre21">member</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Type type = expr.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( type.getClass() != StructSymbol.class ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(expr)+<em class="calibre6">" must have struct type in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)expr.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _void;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Array indexing has two semantic hazards to check.  
We need to
verify that the identifier is in fact an array and that the index
expression is an integer or promotable to an integer:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type arrayIndex(CymbolAST id, CymbolAST index) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// annotate AST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s.getClass() != VariableSymbol.class || <em class="calibre6">// ensure it's an array</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.type.getClass() != ArrayType.class )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(id)+<em class="calibre6">" must be an array variable in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)id.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _void;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol vs = (VariableSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Type t = ((ArrayType)vs.type).elementType;&nbsp;&nbsp; <em class="calibre6">// get element type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> texpr = index.evalType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// promote the index expr if necessary to int</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;index.promoteToType = promoteFromTo[texpr][tINT];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !canAssignTo(index.evalType, _int, index.promoteToType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(index)+<em class="calibre6">" index must have integer type in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)id.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> t;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The 
<tt class="calibre21">canAssignTo</tt> method determines whether a value is compatible with a
destination type (based upon its evaluated type and promoted type if
needed):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public boolean canAssignTo(Type valueType,Type destType,Type promotion) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// either types are same or value was successfully promoted</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> valueType==destType || promotion==destType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This method is the key type compatibility checker. The following
sections use it a lot to analyze method calls and assignments.
</p><h4 class="calibre26">Checking Method Calls and Return Values</h4><p height="10" width="0" class="calibre5">Method calls have three semantic hazards. 
First, we have to check
that the identifier is a function name. Second, we have to check that the argument
expression types are compatible with the formally declared function
parameters:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Type call(CymbolAST id, List args) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Symbol s = id.scope.resolve(id.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( s.getClass() != MethodSymbol.class ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(id)+<em class="calibre6">" must be a function in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)id.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _void;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;MethodSymbol ms = (MethodSymbol)s;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;id.symbol = ms;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> i=0;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (Symbol a : ms.orderedArgs.values() ) { <em class="calibre6">// for each arg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CymbolAST argAST = (CymbolAST)args.get(i++);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// get argument expression type and expected type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type actualArgType = argAST.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type formalArgType = ((VariableSymbol)a).type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> targ = actualArgType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> tformal = formalArgType.getTypeIndex();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// do we need to promote argument type to defined type?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argAST.promoteToType = promoteFromTo[targ][tformal];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !canAssignTo(actualArgType, formalArgType,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argAST.promoteToType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(argAST)+<em class="calibre6">", argument "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.name+<em class="calibre6">":&lt;"</em>+a.type+<em class="calibre6">"&gt; of "</em>+ms.name+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">"() have incompatible types in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)id.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> ms.type;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Finally, we have to check that return expression types are
compatible with the declared function return type. Here is the check
from <tt class="calibre21">ret</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( !canAssignTo(exprType, retType, expr.promoteToType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(expr)+<em class="calibre6">", "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ms.name+<em class="calibre6">"():&lt;"</em>+ms.type+<em class="calibre6">"&gt; have incompatible types in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text((CymbolAST)expr.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Passing parameters and return statement values are implicit
assignments. Lets deal with explicit assignments next.
</p><h4 class="calibre26">Checking Assignments and Declaration Initializers</h4><p height="10" width="0" class="calibre5">To check assignments for type safety, we verify that the right-side
 expression is compatible with the type of the left  side
(were copying data from the right to the left). Heres the check from
<tt class="calibre21">assign</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( !canAssignTo(rhs.evalType, lhs.evalType, rhs.promoteToType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(lhs)+<em class="calibre6">", "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text(rhs)+<em class="calibre6">" have incompatible types in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)lhs.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Variable declarations with initialization expressions are also
assignments. We have to check that the initialization expression type
is compatible with the declaration type.  Heres the check from <tt class="calibre21">declinit</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( !canAssignTo(init.evalType, declID.symbol.type,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init.promoteToType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(declID)+<em class="calibre6">", "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(init)+<em class="calibre6">" have incompatible types in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text((CymbolAST)declID.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The only thing left to check is that <code class="calibre21">if</code>-conditionals are booleans.
</p><h4 class="calibre26">Checking That if-Conditionals Are Booleans</h4><p height="10" width="0" class="calibre5">To check <code class="calibre21">if</code>-conditionals, 
we need to add a rule to our tree pattern
matcher <code class="calibre21">Types.g</code> that triggers helper method 
<tt class="calibre21">ifstat</tt> upon
<code class="calibre21">if</code>-statement:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/Types.g">semantics/safety/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ifstat : ^('if' cond=. s=. e=.?) {symtab.ifstat($cond);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The helper method ensures that the type of the condition is boolean:
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public <b class="calibre13">void</b> ifstat(CymbolAST cond) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( cond.evalType != _boolean ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(<em class="calibre6">"if condition "</em>+text(cond)+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">" must have boolean type in "</em>+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text((CymbolAST)cond.getParent()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">With these changes, we get some nice error messages from the test
rig. For example, the following test file exercises the safety checks
for operand types, array indexes, conditionals, function call
arguments, and function return values.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/t.cymbol">semantics/safety/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">char</b> c = 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// &lt;char&gt; = &lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;boolean b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> a[];&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( 3 ) c='a';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// if ( &lt;int&gt; ) ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;c = 4+1.2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// &lt;char&gt; = &lt;float&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;b = !c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// !&lt;char&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> i = c &lt; b ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// &lt;char&gt; &lt; &lt;boolean&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i = -b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// -&lt;boolean&gt; (must be int/float) ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;g(9);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// g(&lt;int&gt;) but needs &lt;char&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a[true] = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// &lt;array&gt;[&lt;boolean&gt;] = &lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> g(<b class="calibre13">char</b> c) { <b class="calibre13">return</b> 9.2; } <em class="calibre6">// return &lt;float&gt; needs &lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp; ERROR</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">From <code class="calibre21">t.cymbol</code>, we get this output (its missing the output related
to the type of each subexpression):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test t.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;char&gt;, 4:&lt;int&gt; have incompatible types in char c = 4;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">if condition 3:&lt;int&gt; must have boolean type in if ( 3 ) c='a';</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;char&gt;, 4+1.2:&lt;float&gt; have incompatible types in c = 4+1.2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;char&gt; must have boolean type in !c</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;char&gt;, b:&lt;boolean&gt; have incompatible types in c &lt; b</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i:&lt;int&gt;, c &lt; b:&lt;boolean&gt; have incompatible types in int i = c &lt; b ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">b:&lt;boolean&gt; must have int/float type in -b</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i:&lt;int&gt;, -b:&lt;void&gt; have incompatible types in i = -b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">9:&lt;int&gt;, argument c:&lt;char&gt; of g() have incompatible types in g(9)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">true:&lt;boolean&gt; index must have integer type in a[true]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">9.2:&lt;float&gt;, g():&lt;int&gt; have incompatible types in return 9.2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Test file <code class="calibre21">u.cymbol</code> checks that we use <code class="calibre21">struct</code>s properly and
that we use function symbols in function calls:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/u.cymbol">semantics/safety/u.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">struct</b> A { <b class="calibre13">int</b> x; };</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">struct</b> B { <b class="calibre13">int</b> y; };</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> A a;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">struct</b> B b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;a = b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// &lt;struct A&gt; = &lt;struct B&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;<b class="calibre13">int</b> c = i.x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// &lt;int&gt;.x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;c = a + 3 + a[3]; <em class="calibre6">// &lt;struct&gt; + &lt;int&gt; + &lt;struct&gt;[]&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;c();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// &lt;int&gt;()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERROR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We get the following error messages:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test u.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a:&lt;struct A:{x}&gt;, b:&lt;struct B:{y}&gt; have incompatible types in a = b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">i:&lt;int&gt; must be have struct type in i.x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;int&gt;, i.x:&lt;void&gt; have incompatible types in int c = i.x;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a:&lt;struct A:{x}&gt;, 3:&lt;int&gt; have incompatible types in a + 3</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a must be an array variable in a[3]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a + 3:&lt;void&gt;, a[3]:&lt;void&gt; have incompatible types in a + 3 + a[3]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c:&lt;int&gt;, a + 3 + a[3]:&lt;void&gt; have incompatible types in c = a + 3 + a[3];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">c must be a function in c()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The source code for this pattern is a complete static type checker for
our C++ subset.  By breaking the problem down into type computation,
type promotion, and type checking, weve made things much easier to
understand and implement.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern requires Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a> and
Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a> before it can check for type
compatibility.  The next pattern alters Cymbol to have classes instead
of <code class="calibre21">struct</code>s and checks polymorphic pointer
assignments.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_083.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_083.html.tip.type-safety-oo" class="pagebreak2"><small class="calibre35">Pattern 23:</small>&nbsp;&nbsp;&nbsp;Enforcing Polymorphic Type Safety</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"><em class="calibre6">This pattern detects type incompatibilities in object pointer
assignments in object-oriented languages like C++.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Beyond the type checking done in Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>,
object-oriented languages have one more type hazard to worry about:
<em class="calibre6">polymorphic</em> object pointer assignment.
Polymorphism means that a pointer can refer to objects of multiple
types. In contrast, C pointer assignments have to be between exact
types.  The key difference then between this pattern and the previous
lies in the definition of type compatibility.  Lets take a look at a
C++ example that demonstrates what we need to handle:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Cat *pCat;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Bengal *pBengal; <em class="calibre6">// assume Bengal subclasses Cat</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">pCat = pCat;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// target types, Cat, are the same, assignment is ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">pCat = pBengal;&nbsp;&nbsp;<em class="calibre6">// Bengal must be a subclass of Cat</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Those assignments are OK, but <code class="calibre21">pBengal=pCat</code> is illegal because
<code class="calibre21">pCat</code> could be any kind of cat, not just a bengal. <code class="calibre21">pBengal=pTabby</code>
would also be illegal.</p><p height="10" width="0" class="calibre5">The semantic rule for polymorphic pointer assignment goes like this:
for any assignment <code class="calibre21">p=q</code>, ensure that <code class="calibre21">q</code>s target type is the same as
<code class="calibre21">p</code>s target type or that <code class="calibre21">q</code>s target type is a subclass of <code class="calibre21">p</code>s
target type. The target type is the type of element pointed at by
a pointer. This rule means that <code class="calibre21">q</code>s target type has to be a kind of
<code class="calibre21">p</code>s target type.</p><p height="10" width="0" class="calibre5">We can check compatibility in one of two ways. Lets assume
<code class="calibre21">P *p;</code> and <code class="calibre21">Q
*q</code>. Then, either we look for <code class="calibre21">Q</code>
at or below <code class="calibre21">P</code> in the class hierarchy or we
look for <code class="calibre21">P</code> at or above
<code class="calibre21">Q</code>.  Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a> builds
class hierarchy trees with children pointing at their parents. So,
lets ask <code class="calibre21">Q</code> if it has a
<code class="calibre21">P</code> ancestor in the class hierarchy.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Static vs. Dynamic Pointer Compatibility Checking</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Static analysis tools 
and compilers are notoriously picky about
pointer assignments.  C++ in particular has to be very careful because
anything goes at run-time. Bad pointer assignments can lead to
incorrect field accesses and even memory violations. In
dynamically typed languages like Python and Ruby, we dont even have
to check for pointer compatibility at run-time. If we were to make a
pointer assignment between incompatible types, the next member access
on that object would generate an error.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">Polymorphism is meaningless without pointers, so we need to add them to
the Cymbol language weve used throughout this chapter. (Weve ignored
pointers until now to keep things simple.)  To demonstrate type
checking in object pointer assignments, we need to extend Cymbol with
these constructs:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Classes with single inheritance (well remove <code class="calibre21">struct</code>s)</li><li height="6" class="calibre20"><span></span>Pointers to primitive and class types</li><li height="6" class="calibre20"><span></span>The <code class="calibre21">&amp;</code> address of operator</li><li height="6" class="calibre20"><span></span>The <code class="calibre21">*</code> pointer dereference operator</li><li height="6" class="calibre20"><span></span>The <code class="calibre21">-&gt;</code> member access through object pointer operator</li></ul><p height="10" width="0" class="calibre5">To simplify our lives, we can normalize array references to the
equivalent pointer arithmetic when building the AST
(<code class="calibre21">a[i]</code> becomes
<code class="calibre21">*(a+i)</code>). Well do the same for member access
through pointers (<code class="calibre21">p-&gt;x</code> becomes
<code class="calibre21">(*p).x</code>). This way, the definition and type
safety tree passes dont have to worry about the new syntax because
the AST only has  pointer arithmetic.</p><p height="10" width="0" class="calibre5">The next section extends the sample implementation from the
previous pattern to handle classes and object pointer semantic
rules.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">This section consists of two main chunks. 
The first
section details how to implement polymorphic type checking.  The
second shows how to support pointers in Cymbol. Adding pointers gets a
bit hairy, so you can skip it if youre only interested  in the type checking part.</p><h4 class="calibre26">Checking for Polymorphism Between Object Pointers</h4><p height="10" width="0" class="calibre5">Our implementation is an extension of Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a> with symbol table support for classes from
Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.  The primary modification is a
change in the definition of type compatibility in method
<tt class="calibre21">canAssignTo</tt>. The non-object-oriented version
checks for exact type matches:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/safety/SymbolTable.java">semantics/safety/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> valueType,<b class="calibre13">Type</b> destType,<b class="calibre13">Type</b> promotion) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// either types are same or value was successfully promoted</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> valueType==destType || promotion==destType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">whereas, for the object-oriented version, we need something looser.
Because of this looser definition and because we need pointer
support in Cymbol, its easier to delegate functionality to the
individual types:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/SymbolTable.java">semantics/oo/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> valueType,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b class="calibre13">Type</b> destType,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b class="calibre13">Type</b> promotion)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp; <em class="calibre6">// handle both arithmetic types, objects, and object pointers.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// either we can assign the value directly to the destination type or</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// it was promoted to the required destination type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> valueType.canAssignTo(destType) || promotion==destType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This means we need to add a new method to the <code class="calibre21">Type</code> interface for
consistency across type objects in our symbol table:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/Type.java">semantics/oo/Type.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> destType);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The built-in types like <code class="calibre21">int</code> require an exact type match in
assignments:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/BuiltInTypeSymbol.java">semantics/oo/BuiltInTypeSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> destType) { <b class="calibre13">return</b> this==destType; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The same is true for objects such as <code class="calibre21">Point</code> or <code class="calibre21">User</code>. We can only
assign <code class="calibre21">Point</code> objects to <code class="calibre21">Point</code> objects because we are copying an
entire object (not just a pointer):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/ClassSymbol.java">semantics/oo/ClassSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> destType) { <b class="calibre13">return</b> this==destType; }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">All of the fancy footwork for polymorphic type safety happens in 
<code class="calibre21">PointerType</code>s <tt class="calibre21">canAssignTo</tt> method.  Class <code class="calibre21">PointerType</code> represents
a pointer to a target type. For example, we can represent a pointer to
class <code class="calibre21">User</code> with <code class="calibre21">new PointerType(userClass)</code>, assuming <code class="calibre21">userClass</code>
points to the <code class="calibre21">ClassSymbol</code> for <code class="calibre21">User</code>. This is analogous to <code class="calibre21">ArrayType</code> in Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.</p><p height="10" width="0" class="calibre5">For pointers to built-in types, the target types must be identical.
Pointers to objects, on the other hand, only have to be related in the
class hierarchy. The following method answers whether we can copy a
pointer of one type to a destination type:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/PointerType.java">semantics/oo/PointerType.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Can we assign this type to destination type?&nbsp;&nbsp;destType must be</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;pointer and to same type unless object ptr.&nbsp;&nbsp;Then, we have to do a</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;polymorphic check. [Ha! This method is a perfect example of</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> *&nbsp;&nbsp;static typing getting in the way. Look at all those type casts!]</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6"> */</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> canAssignTo(<b class="calibre13">Type</b> destType) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// if not a pointer, return false</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !(destType <b class="calibre13">instanceof</b> PointerType) ) <b class="calibre13">return</b> false;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// What type is the target pointing at?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> destTargetType = ((PointerType)destType).targetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> srcTargetType = this.targetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// if this and target are object pointers, check polymorphism</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( destTargetType <b class="calibre13">instanceof</b> ClassSymbol &amp;&amp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.targetType <b class="calibre13">instanceof</b> ClassSymbol )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol thisClass&nbsp;&nbsp; = (ClassSymbol)srcTargetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol targetClass = (ClassSymbol)destTargetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// Finally!&nbsp;&nbsp;Here it is: the polymorphic type check :)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> thisClass.isInstanceof(targetClass);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// not comparing object pointers; types we point at must be the same</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// For example: int *p; int *q; p = q;</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> srcTargetType == destTargetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The type check for polymorphism asks whether <code class="calibre21">thisClass</code> is the same as <code class="calibre21">targetClass</code> or is a subclass of <code class="calibre21">targetClass</code> via <tt class="calibre21">isInstanceof</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/ClassSymbol.java">semantics/oo/ClassSymbol.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Return true if 'ancestor' is this class or above in hierarchy */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">boolean</b> isInstanceof(ClassSymbol ancestor) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ClassSymbol t = this;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( t!=null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( t == ancestor ) <b class="calibre13">return</b> true;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = t.superClass;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> false;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, lets see what happens if we run the following Cymbol assignments
through our test rig (which is identical to <code class="calibre21">Test.java</code> from the
previous pattern):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/t.cymbol">semantics/oo/t.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class A { <b class="calibre13">int</b> x; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// define class A</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class B : A { <b class="calibre13">int</b> y; };&nbsp;&nbsp; <em class="calibre6">// define class B subclass of A</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class C : A { <b class="calibre13">int</b> z; };&nbsp;&nbsp; <em class="calibre6">// define class C subclass of A</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f() {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;A a; A a2; B b; C c;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// define 4 object instances</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;a = a2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// a, a2 have same type A, so it's ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;a = b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// b's class is subclass of A but not ptr; NOT ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;b = a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// a's class is not below B so it's NOT ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;b = c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// b and c classes are siblings of A; not compatible</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;A *pA; B *pB; C *pC;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// define 3 object pointers</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;pA = pB;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// pB's points to B: B is a subclass of A so it's ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;pB = pA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// pA's points to class not below B so it's NOT ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;pB = pC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// pB and pC point to sibling classes of A; NOT ok</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Only the first object assignment and first pointer assignment are
valid. The polymorphic type checker emits errors for the rest:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g Def.g Types.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test t.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">a:&lt;class A:{x}&gt;, b:&lt;class B:{y}&gt; have incompatible types in a = b;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">b:&lt;class B:{y}&gt;, a:&lt;class A:{x}&gt; have incompatible types in b = a;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">b:&lt;class B:{y}&gt;, c:&lt;class C:{z}&gt; have incompatible types in b = c;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">pB:&lt;class B:{y}*&gt;, pA:&lt;class A:{x}*&gt; have incompatible types in pB = pA;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">pB:&lt;class B:{y}*&gt;, pC:&lt;class C:{z}*&gt; have incompatible types in pB = pC;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This completes the core of the material for this pattern. For
completeness, though, you can read about adding pointers to Cymbol in
the next section.  Programming languages have moved away from explicit
pointers (Java, C#, Ruby, and Python), but C and C++ arent going away
anytime soon.  If you need to implement a language with pointers, take
a look at the next section.  </p><h4 class="calibre26">Adding Pointers to Cymbol</h4><p height="10" width="0" class="calibre5">To support pointers, the first thing we need to do is add
some syntax to our language. The following rule adds <code class="calibre21">*</code> as a valid
prefix to a declarations identifier:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/Cymbol.g">semantics/oo/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">varDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; type ID (<em class="calibre6">'='</em> expression)? <em class="calibre6">';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(VAR_DECL type ID expression?)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; type ID <em class="calibre6">'[]'</em> (<em class="calibre6">'='</em> expression)? <em class="calibre6">';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(VAR_DECL ^(<em class="calibre6">'*'</em> type) ID expression?)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; type <em class="calibre6">'*'</em> ID (<em class="calibre6">'='</em> expression)? <em class="calibre6">';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(VAR_DECL ^(<em class="calibre6">'*'</em> type) ID expression?)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It also normalizes array declarations to be the same as pointer
declarations.  Within expressions, we simulate array reference <code class="calibre21">a[i]</code>
with the equivalent pointer arithmetic and dereference <code class="calibre21">*(a+i)</code>. We
also desugar member access operations such as <code class="calibre21">p-&gt;x</code> to <code class="calibre21">(*p).x</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/Cymbol.g">semantics/oo/Cymbol.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">postfixExpression</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; (primary-&gt;primary)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp; <em class="calibre6">'('</em> expressionList <em class="calibre6">')'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(CALL[<em class="calibre6">"CALL"</em>] $postfixExpression expressionList)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; r=<em class="calibre6">'['</em> expr <em class="calibre6">']'</em> <em class="calibre6">// convert a[i] to *(a+i)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(DEREF[$r,<em class="calibre6">"*"</em>] ^(ADD[<em class="calibre6">"+"</em>] $postfixExpression expr))</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'.'</em> ID</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(<em class="calibre6">'.'</em> $postfixExpression ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; r=<em class="calibre6">'-&gt;'</em> ID <em class="calibre6">// convert p-&gt;x to (*p).x</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; ^(MEMBER[$r] ^(DEREF $postfixExpression) ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)*&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After successfully building an AST, the symbol definition phase needs
the rules to handle class definitions from Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.</p><p height="10" width="0" class="calibre5">It also
replaces array support in rule <code class="calibre21">type</code> with pointer support:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/Def.g">semantics/oo/Def.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">type <b class="calibre13">returns</b> [Type type]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'*'</em> typeElement)&nbsp;&nbsp;{$type = new PointerType($typeElement.type);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; typeElement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$type = $typeElement.type;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In the symbol resolution and type computation phase, the <code class="calibre21">expr</code> rule
invokes a helper method when it sees a pointer dereference:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/Types.g">semantics/oo/Types.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">|&nbsp;&nbsp; ^(ADDR a=expr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$type=new PointerType($a.type);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">|&nbsp;&nbsp; ^(DEREF a=expr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$type=symtab.ptrDeref($a.start);}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The helper method returns the target type of the dereferenced
expression. For example, <code class="calibre21">*pInt</code> evaluates to <code class="calibre21">int</code> if <code class="calibre21">pInt</code> is a
pointer to an <code class="calibre21">int</code>.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/SymbolTable.java">semantics/oo/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">Type</b> ptrDeref(CymbolAST expr) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( !(expr.evalType <b class="calibre13">instanceof</b> PointerType) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.error(text(expr)+<em class="calibre6">" must be a pointer"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> _void;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> ((PointerType)expr.evalType).targetType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To support pointers in expressions, we need some small but pervasive
changes to our type result tables.  First, we need to introduce a new
type index <code class="calibre21">tPTR</code> and increase the dimensions of our type tables by
  one. For example, Figure 24, <a href="#text/part0000_split_083.html.code.SymbolTable.java"><em class="calibre6">The arithmetic result type table</em></a> is the arithmetic result type table:</p><div class="calibre1" id="text/part0000_split_083.html.code.SymbolTable.java"><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/SymbolTable.java">semantics/oo/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Map t1 op t2 to result type (_void implies illegal) */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> arithmeticResultType = <b class="calibre13">new</b> <b class="calibre13">Type</b><b class="calibre13">[]</b><b class="calibre13">[]</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;&nbsp;boolean&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp; float,&nbsp;&nbsp; void,&nbsp;&nbsp;ptr */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*struct*/</em>&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void, _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*boolean*/</em> {_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void, _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*char*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _char,&nbsp;&nbsp;_int,&nbsp;&nbsp; _float,&nbsp;&nbsp;_void, _ptr},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*int*/</em>&nbsp;&nbsp;&nbsp;&nbsp; {_void, _void,&nbsp;&nbsp; _int,&nbsp;&nbsp; _int,&nbsp;&nbsp; _float,&nbsp;&nbsp;_void, _ptr},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*float*/</em>&nbsp;&nbsp; {_void, _void,&nbsp;&nbsp; _float, _float, _float,&nbsp;&nbsp;_void, _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*void*/</em>&nbsp;&nbsp;&nbsp;&nbsp;{_void, _void,&nbsp;&nbsp; _void,&nbsp;&nbsp;_void,&nbsp;&nbsp;_void,&nbsp;&nbsp; _void, _void},</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/*ptr*/</em>&nbsp;&nbsp;&nbsp;&nbsp; {_void, _void,&nbsp;&nbsp; _ptr,&nbsp;&nbsp; _ptr,&nbsp;&nbsp; _void,&nbsp;&nbsp; _void, _void}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><hr class="calibre17"><b class="calibre13">Figure 23. The arithmetic result type table</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The table encodes the fact that we can add characters and integers to
pointers on either side of an arithmetic operator.  For example,
<code class="calibre21">arithmeticResultType[tINT][tPTR]</code> is a pointer. But, we cant add two
pointers together. <code class="calibre21">arithmeticResultType[tPTR][tPTR]</code> is invalid (<code class="calibre21">void</code>).  We use <code class="calibre21">_ptr</code> to represent a generic pointer, but we need exact
type results. The following addition to <tt class="calibre21">getResultType</tt> returns the
actual pointer type of the incoming pointer operand:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/semantics/oo/SymbolTable.java">semantics/oo/SymbolTable.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// check for pointer arithmetic; only one operand can be a ptr.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// if result and 'a' are ptrs, then result should be a's type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( result==_ptr &amp;&amp; ta==tPTR ) result = a.evalType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> <b class="calibre13">if</b> ( result==_ptr &amp;&amp; tb==tPTR ) result = b.evalType;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">There is one tricky entry in the <code class="calibre21">promoteFromTo</code> table for
pointers. We need to encode the fact that characters become integers
when added to pointers. In other words, we should interpret <code class="calibre21">'a'+p</code> as
<code class="calibre21">(int)'a'+p</code>.  There is no way to promote a pointer to a character, so
the table is not symmetric.  The entry for adding an integer to a
pointer is <code class="calibre21">null</code>, which means there is no need to promote the
integer.</p><p height="10" width="0" class="calibre5">The source code shows a few more details, but you see the important
elements here.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern is an object-oriented equivalent of Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.  It incorporates Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a> and Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a>.
</p>

</div></div>
<div id="text/part0000_split_084.html"><div class="calibre">

<h2 id="text/part0000_split_084.html.d24e26937" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">This pattern concludes our discussion of static type checking.  As a
learning tool, we broke down this problem into three pieces: type
computation, type promotion, and type checking. The third and fourth
patterns demonstrated type checking for non-object-oriented and
object-oriented languages. Once you understand the entire picture, you
would pick either Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a> or this pattern to implement your
own static type checker. The other patterns are components of the type
checkers.</p><p height="10" width="0" class="calibre5">So far, weve learned how to write code to recognize sentences,
construct AST intermediate representations, walk ASTs, populate symbol
tables, manage nested scopes, construct class hierarchies, and enforce
semantic type rules.  In short, weve learned how to read in programs
and check them for type safety. Now we need to figure out how to
execute them.  The next two parts catalog the most common patterns
for interpreting and translating programs.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_084.html.FOOTNOTE-23" href="#text/part0000_split_080.html.FNPTR-23">[23]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://findbugs.sourceforge.net">http://findbugs.sourceforge.net</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_084.html.FOOTNOTE-24" href="#text/part0000_split_080.html.FNPTR-24">[24]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://coverity.com/html/prevent-for-java.html">http://coverity.com/html/prevent-for-java.html</a></p></dd></dl><div class="calibre3" id="text/part0000_split_084.html.calibre_pb_109"></div>

</div></div>
<div id="text/part0000_split_085.html"><div class="calibre">

<div id="text/part0000_split_085.html.toc-15" style="height:0pt"></div><h1 class="part-title" id="text/part0000_split_085.html.d24e26951"><span class="calibre14">Part 3</span><br class="calibre4"><span class="calibre14">Building Interpreters</span></h1><div class="calibre3" id="text/part0000_split_085.html.calibre_pb_113"></div>

</div></div>
<div id="text/part0000_split_086.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_086.html.calibre_pb_114">&nbsp;</p><a id="text/part0000_split_086.html.toc-16"></a><h4 class="right2" id="text/part0000_split_086.html.chp.interp">Chapter 9</h4>
</div></div>
<div id="text/part0000_split_087.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_087.html.calibre_pb_115">Building High-Level Interpreters</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">Weve covered a lot of ground in the book so far and have reached
an important milestone.  
Were ready to start actually building
language applications.  In the previous two parts of this book, we
focused on patterns to verify the syntax of an input sentence and make
sure that it follows a set of semantic rules.  Now, its time to start
thinking about processing input sentences, not just validating
them. In this part of the book, were going to learn how to build
language interpreters (programs that execute other programs).</p><p height="10" width="0" class="calibre5">To execute a program not written in machine code, weve got to
interpret the program or translate it to the equivalent program in a
language that already runs on that machine.  Well leave translation
to Chapter 11, <a href="#text/part0000_split_105.html.chp.trans"><em class="calibre6">Translating Computer Languages</em></a> and Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>.  In the
meantime, were going to look at high-level and low-level interpreters
in this chapter and the next. High-level interpreters directly execute
source code instructions or the AST equivalent.  (Low-level
interpreters execute instructions
called <em class="calibre6">bytecodes</em> that are close to CPU machine
instructions.) Here are the two high-level interpreters well
discuss:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a>: 
This interpreter consists of a parser that
triggers interpreter action methods.</li><li height="6" class="calibre20"><span></span>Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a>:  
This pattern triggers action methods by walking
an AST created by the parser.</li></ul><p height="10" width="0" class="calibre5">These high-level patterns are best suited to building DSLs rather
than general-purpose programming languages.  Usually, simplicity and low implementation cost trump execution efficiency for
  DSLs.<a id="text/part0000_split_087.html.FNPTR-25" href="#text/part0000_split_093.html.FOOTNOTE-25">[25]</a>
Because it leads to simpler implementations, well also focus on
dynamically typed languages for these patterns. Our goal is the
minimal machinery needed to interpret a high-level language.</p><p height="10" width="0" class="calibre5">An interpreter simulates an idealized computer in software.  Such
computers have a processor, code memory, data memory, and (usually) a
stack. The processor pulls instructions from the code memory, decodes
them, and executes them. An instruction can read or write to the data
memory or onto the stack.  Function calls save return addresses so
they can return to the instruction following the function call.</p><p height="10" width="0" class="calibre5">There are three things to consider when building an interpreter: how
to store data, how and when to track symbols, and how to execute
instructions. Lets investigate them in that order before diving into
the patterns.</p>

</div></div>
<div id="text/part0000_split_088.html"><div class="calibre">

<h2 id="text/part0000_split_088.html.sec.interp-mem" class="calibre18">Designing High-Level Interpreter Memory Systems</h2><p height="10" width="0" class="calibre5">High-level interpreters store values according to variable names, not
memory addresses (like low-level interpreters and CPUs do). 
That means
weve got to represent memory with a dictionary mapping names to values.</p><p height="10" width="0" class="calibre5">There are three kinds of memory spaces to worry about for most
programming languages: 
global memory, function spaces (for parameters
and locals), and data aggregate instances (<code class="calibre21">struct</code>s or objects).
For simplicity, we can normalize all these spaces by treating them
as dictionaries. Even fields are really just variables stored within
an instances memory space. To store a value into a space, we map a
name to that value. A memory space is the run-time analog of a scope
from static analysis.</p><p height="10" width="0" class="calibre5">Interpreters have one global memory space but multiple function
spaces (assuming the language were interpreting has functions).  Each
function call creates a new space to hold parameters and local
variables. The interpreter keeps track of the function spaces by
pushing them onto the stack. Upon returning from a function, the
interpreter pops the top space off the stack.  This way, parameters
and local variables pop in and out of existence as we need them.</p><p height="10" width="0" class="calibre5">Lets look at the global and function memory spaces used by the
following C++ code snippet:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> x = 1;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> g(<b class="calibre13">int</b> x) { <b class="calibre13">int</b> z = 2; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f(<b class="calibre13">int</b> x) { <b class="calibre13">int</b> y = 1; g(2*x); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> main() { f(3); }</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_088.html.fig.interp-fgstack"><img id="text/part0000_split_088.html.d24e27080" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/fgstack.png"><hr class="calibre17"><b class="calibre13">Figure 24. Memory space stack after calling <tt class="calibre21">g</tt></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5"> In Figure 25, <a href="#text/part0000_split_088.html.fig.interp-fgstack"><em class="calibre6">Memory space stack after calling g</em></a>, we see what the function space
stack and global memory space of a C++ interpreter would look like
after executing the assignment to <code class="calibre21">z</code> in
<tt class="calibre21">g</tt>. As <tt class="calibre21">g</tt> returns, the
interpreter would pop that function space. Then itd pop the function
space for the call to <tt class="calibre21">f</tt> and finally the
function space for <tt class="calibre21">main</tt>.</p><p height="10" width="0" class="calibre5">Just as we can have multiple function memory spaces, we can create
multiple data aggregate instances. Those materialize in response to
<code class="calibre21">new</code> expressions (or the equivalent in the language were
interpreting).  We store references to those aggregates into a memory
space just like any other variable. The following C++ code creates two
<code class="calibre21">struct</code> instances and assigns them to local (pointer) variables.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">struct</b> A { <b class="calibre13">int</b> x; };</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> main() {&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;A *a = <b class="calibre13">new</b> A(); a-&gt;x = 1;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;A *b = <b class="calibre13">new</b> A(); b-&gt;x = 2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> In Figure 26, <a href="#text/part0000_split_088.html.fig.interp-structspace"><em class="calibre6">Two struct instances saved as local variables a and b</em></a>, we see the interpreters memory spaces right
before <tt class="calibre21">main</tt> returns. <tt class="calibre21">main</tt>s function space has two variables, <code class="calibre21">a</code> and <code class="calibre21">b</code>, each pointing to a separate <code class="calibre21">struct</code> memory space. To
implement assignment <code class="calibre21">a-&gt;x=1;</code>, the interpreter invokes something like
<code class="calibre21">a.put("x",1);</code> in its implementation language.</p><div class="calibre1" id="text/part0000_split_088.html.fig.interp-structspace"><img id="text/part0000_split_088.html.d24e27172" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/structspace.png"><hr class="calibre17"><b class="calibre13">Figure 25. Two struct instances saved as local variables <code class="calibre21">a</code> and <code class="calibre21">b</code></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">To handle 
class instances instead of <code class="calibre21">struct</code>s, the easiest thing
to do is to pack all fields (inherited or direct members) into a
single instance space. Inheritance is really just a glorified include
when it comes to fields.  So, even objects are just another memory
space.</p><p height="10" width="0" class="calibre5">Now weve got to consider which assignments are valid. Depending on the
language, assignment to an unknown variable could be an error (C++) or
could create a local variable (Python). Python can even create fields
at will by assigning values to fields.  Regardless of the interpreted
languages semantics, memory spaces have to know what kind of things
can go into them.  The easiest way to do this is to track the program
entity associated with a memory space.  For example, function spaces
point at their function definition symbols, and instances point at
their class definition symbols.  In the next section, well figure out
what kind of symbol tables we need for interpreters.
</p>

</div></div>
<div id="text/part0000_split_089.html"><div class="calibre">

<h2 id="text/part0000_split_089.html.sec.interp-symtab" class="calibre18">Tracking Symbols in High-Level Interpreters</h2><p height="10" width="0" class="calibre5">Given a variable reference <code class="calibre21">x</code> in a program, we need to figure out
which memory space it lives in so we can load or store its value. 
The interpreter figures this out by resolving <code class="calibre21">x</code> and asking
for its surrounding scope.  That scope tells the interpreter in what
kind of scope the variable belongs: global, function, or data
aggregate instance. Once the interpreter knows the kind of memory
space, it can pick the proper dictionary in physical memory.</p><p height="10" width="0" class="calibre5">If the symbol table says <code class="calibre21">x</code> is a global variable,  the interpreter loads it from the global space. If <code class="calibre21">x</code> resolves
to a local variable or parameter, the interpreter loads it from the
function space on the top of the function space stack.</p><p height="10" width="0" class="calibre5">If <code class="calibre21">x</code> is a field of a class, 
we know that
its really <code class="calibre21">this.x</code> (or whatever
<code class="calibre21">this</code> is called in the interpreted
language). The interpreter should load <code class="calibre21">this</code>
from the function space on the top of the function space stack and
then load <code class="calibre21">x</code> from the space
<code class="calibre21">this</code> points to.</p><p height="10" width="0" class="calibre5">Because symbol table management happens at run-time in an
interpreter, its easy to confuse resolving a variable with loading
its value.  Just keep in mind that resolving a variable means figuring
out which program entity it refers to.  We can do this without even
running the program for statically typed languages.  Loading a
variable, on the other hand, is purely a run-time operation.  We
resolve a variable to figure out the space in which its value
lives. For a single program entity, such as a local variable, there
can be multiple values (in different function spaces) at run-time.</p><p height="10" width="0" class="calibre5">Resolving variables at run-time is expensive, so many languages ask the
programmer to indicate each variables scope.  
For example, in Ruby we say
<code class="calibre21">$x</code> to mean <code class="calibre21">x</code> is a global variable, and we say <code class="calibre21">@x</code> to mean that <code class="calibre21">x</code> is a
field of an object. In Python, we say <code class="calibre21">self.x</code> to mean <code class="calibre21">x</code> is a field.</p><p height="10" width="0" class="calibre5">Because dynamically typed languages dont declare variables and their
types prior to usage, 
theres no point in populating a symbol table
with <code class="calibre21">VariableSymbol</code> objects. That doesnt mean, though, that we
can get away without symbol table management at run-time. Error
checking is one reason. We dont want to access undefined parameters
or fields. This means that, at the very least, we need some symbol
table objects to track formal parameter lists and field lists.</p><p height="10" width="0" class="calibre5">An interpreter might need to treat parameters and locals
differently. For example, in the following Python function, the
interpreter must distinguish between parameter <code class="calibre21">x</code> and local variable
<code class="calibre21">y</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">def</b> f(x):&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;x = 1 <em class="calibre6"># set parameter value to 1 (don't create local variable)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;y = 2 <em class="calibre6"># create a local variable called y and set to 2</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Without the formal parameter list in the function definition, Python
couldnt distinguish between locals and parameters.</p><p height="10" width="0" class="calibre5">Statically typed languages like C++ and Java really need scope trees,
so Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a> shows you how to build a full scope tree before
execution (even though it doesnt technically need it).</p><p height="10" width="0" class="calibre5">OK, its time to figure out how to execute instructions in an
interpreter now that we know what interpreter memory systems look
like.
</p>

</div></div>
<div id="text/part0000_split_090.html"><div class="calibre">

<h2 id="text/part0000_split_090.html.sec.interp-proc" class="calibre18">Processing Instructions</h2><p height="10" width="0" class="calibre5">The basic idea behind executing instructions is called the <em class="calibre6">fetch-decode-execute cycle</em>. 
First, we load an instruction from code memory. 
Then, we decode the instruction to find the operation and
operands. Finally, we execute the operation. Rinse and
repeat. Ultimately the interpreter runs out of instructions in the
main program, or it executes a halt instruction.</p><p height="10" width="0" class="calibre5">The nature of the processor depends on what the code looks like in
code memory.  At the one extreme lies Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a> where we
directly execute the text of the source code. At the other extreme,
just above machine code, lies the bytecode interpreters in Chapter 10, <a href="#text/part0000_split_094.html.chp.interp-bytecode"><em class="calibre6">Building Bytecode Interpreters</em></a>. Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a> is somewhere in between.  The more
highly we process the program before execution, the faster it will go
at run-time.</p><p height="10" width="0" class="calibre5">The processor for Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a> is a
parser augmented with actions that decode and execute instructions.
The processor for Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a> triggers actions
as it walks the tree with Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>. Regardless of
the pattern, interpreting a program is all about executing
a code snippet for each input instruction.</p><p height="10" width="0" class="calibre5">Heres a summary of the patterns suitability:</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This pattern works best
for small languages that are really just lists of instructions or
declarations. Its not super-efficient but has the fewest components to build.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"> Because this pattern
performs a preprocessing pass to build an AST and scope tree, it
supports forward references.  
Before execution, we can perform optimizations,
squirrel away information from analysis, or
do rewrites on the AST like <code class="calibre21">x</code> to <code class="calibre21">this.x</code>. This pattern is typically
faster than a source-level interpreter  because it doesnt waste time
reparsing input. We can
skip an entire subtree by moving a pointer instead of parsing over
it.</p></div></td></tr></tbody></table><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_091.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_091.html.tip.syntax-directed-interp" class="pagebreak2"><small class="calibre35">Pattern 24:</small>&nbsp;&nbsp;&nbsp;Syntax-Directed Interpreter</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern directly executes source code without building
an intermediate representation and without translating it to another
language.</em>
</p><p height="10" width="0" class="calibre5">The sample implementation for this pattern focuses on building a
syntax-directed interpreter for an SQL subset.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">A syntax-directed interpreter mimics what we do when we trace source
code manually. As we step through the code, we parse, validate, and
execute instructions.  Everything happens in the parser because a
syntax-directed interpreter doesnt create an AST or translate source
code to bytecodes or machine code. The interpreter directly feeds off
of syntax to execute statements.</p><p height="10" width="0" class="calibre5">The good news is that there are very few moving parts
in a syntax-directed interpreter. There are really only two key
components:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">The source code parser</em>: 
The parser recognizes input
construct and immediately triggers actions. In the
sample implementation for this pattern, that means triggering methods
like <tt class="calibre21">select</tt> and
<tt class="calibre21">createTable</tt>.</li><li height="6" class="calibre20"><span></span><em class="calibre6">The interpreter</em>: The interpreter maintains state and
houses instruction implementation methods.  Depending on the language,
the interpreter will have code memory (the input stream) and a global
memory space (to hold name-value pairs for variables).</li></ul><p height="10" width="0" class="calibre5">The bad news is that syntax-directed interpreters are only suitable 
to a narrow range of languages. They work best on small DSLs instead
of general-purpose programming languages. More specifically,
interpreting <code class="calibre21">if</code> statements, loops, functions, and
classes in syntax-directed interpreters is extremely awkward. (There
is a sample syntax-directed
implementation<a id="text/part0000_split_091.html.FNPTR-26" href="#text/part0000_split_093.html.FOOTNOTE-26">[26]</a>
of the Pie language from the next pattern on the ANTLR wiki.) </p><p height="10" width="0" class="calibre5">
    This
awkwardness comes from the fact that the interpreter would sometimes have
to parse statements without triggering interpreter actions.  For
example, when an interpreter sees a function definition, it shouldnt
execute the statements in the function body. It should only execute
the body  when another part of the program calls that function.</p><p height="10" width="0" class="calibre5">Use this pattern when your input language looks like a sequence of
instructions or simple declarative statements.  Examples include
graphics languages, network protocols, text-processing languages, job
control languages, and simple shell scripting languages.  This pattern
is not suitable for rule or constraint-based languages such as Prolog
or Object Constraint Language (OCL).  Those applications typically
need an internal representation of the rules or constraints. (This
pattern does not create a data structure from the input before
interpretation.)</p><p height="10" width="0" class="calibre5">Before looking at a sample implementation,
lets see how the parser
drives the interpreter. To interpret an input construct, the parser
triggers a method that implements the appropriate functionality.</p><p height="10" width="0" class="calibre5">This
means that the grammar (or hand-built parser) looks like a bunch of
match this, call that pairs. So, when we
see an assignment, we want to call an <tt class="calibre21">assign</tt>
or <tt class="calibre21">store</tt> method in the interpreter. In an
ANTLR grammar-based implementation, we might have rules like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assignment : ID <em class="calibre6">'='</em> expr {interp.assign($ID, $expr.value);} ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr <b class="calibre13">returns</b> [Object value] :  ; <em class="calibre6">// compute and return value</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Theres an implementation method for every statement and
expression operation.  For example, heres the algorithm to perform
an assignment:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void assign(String id, Object value) { // execute "id = value"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;MemorySpace targetSpace = <em class="calibre6">space-containing-id</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if <em class="calibre6">not-found-in-any-space</em> then targetSpace = currentSpace;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;targetSpace[id] = value;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After decoding the assignment statement and triggering an action, the
parser continues to the next statement. This is just like a
physical processor moving onto the next machine instruction. In the
next section, well fill in some details by implementing a subset of
SQL suitable for implementation with this pattern.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">SQL in its full glory is too complicated for this pattern, but we
can make a nice syntax-directed interpreter demo using an SQL subset. 
SQL is a DSL designed to define schemas, insert data, and
perform queries for a relational database.  To keep things simple,
lets avoid the complexity of a real database and build our own 
in-memory database. </p><p height="10" width="0" class="calibre5">
    We can represent tables as lists of rows and can
represent rows as lists of column values. This SQL subset could also
form the basis of a nice interface to
HBase.<a id="text/part0000_split_091.html.FNPTR-27" href="#text/part0000_split_093.html.FOOTNOTE-27">[27]</a><a id="text/part0000_split_091.html.FNPTR-28" href="#text/part0000_split_093.html.FOOTNOTE-28">[28]</a> (HBases goal is to host
massive tables in a cloud computing environment.)</p><p height="10" width="0" class="calibre5">Our SQL subset can define tables with dynamically typed columns,
query those tables, store values in global variables, and print
values. For example, heres a sample script:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/t.q">interp/syntax/t.q</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">create table users (primary key name, passwd);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert into users set name='parrt', passwd='foobar';</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert into users set name='tombu', passwd='spork';</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p = select passwd, name from users; // reverse column order</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The main program in <code class="calibre21">QInterp</code> opens the file
and passes it to the interpreter for execution. Heres the output we
get:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java QInterp t.q</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">foobar, parrt</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">spork, tombu&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Heres another script that demonstrates how to filter the
rows in a table:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/t4.q">interp/syntax/t4.q</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">create table users (primary key name, passwd, quota);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert into users set name='parrt', passwd='foobar', quota=99;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert into users set name='tombu', passwd='spork', quota=200;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert into users set name='sri', passwd='numnum', quota=200;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tombuQuota = select quota from users where name='tombu';</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print tombuQuota;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">names = select name from users where quota=tombuQuota;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print names; // print all names with same quota as tombu</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">And heres the output:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java QInterp t4.q</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tombu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">sri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">where</code> clause only allows  the equality
operator. If we need complex conditionals, this pattern wont work.
Conditionals have to execute as we scan through a table rather than as
we parse the <code class="calibre21">select</code> statement itself. The next
pattern would be much more suitable.</p><p height="10" width="0" class="calibre5">The implementation of our persistence layer is just Java code
(classes <code class="calibre21">Table</code>, <code class="calibre21">Row</code>,
<code class="calibre21">ResultSet</code>) that manipulates dictionaries and
lists. So, lets focus on the core of the interpreter: the SQL subset
grammar and the actions it triggers.
Each table has a name and a list of columns, where the first column
is the primary key:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Q.g">interp/syntax/Q.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'create'</em> <em class="calibre6">'table'</em> tbl=ID</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">'('</em> <em class="calibre6">'primary'</em> <em class="calibre6">'key'</em> key=ID (<em class="calibre6">','</em> columns+=ID)+ <em class="calibre6">')'</em> <em class="calibre6">';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{interp.createTable($tbl.text, $key.text, $columns);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After recognizing the pattern, the ANTLR-generated parser triggers
<tt class="calibre21">createTable</tt> in
<code class="calibre21">Interpreter</code> to create the new
<code class="calibre21">Table</code> and define the columns:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Interpreter.java">interp/syntax/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> createTable(<b class="calibre13">String</b> name,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> primaryKey,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;Token&gt; columns)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Table table = <b class="calibre13">new</b> Table(name, primaryKey);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (Token t : columns) table.addColumn(t.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;tables.put(name, table);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">Interpreter</code> class tracks the set of
tables and space for a global memory to hold variables:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Interpreter.java">interp/syntax/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>, <b class="calibre13">Object</b>&gt; globals = <b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">String</b>, <b class="calibre13">Object</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>, Table&gt; tables = <b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">String</b>, Table&gt;();</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Storing values in global memory is straightforward. After matching
the assignment, the grammar invokes an implementation method in the
interpreter:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Q.g">interp/syntax/Q.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign : ID <em class="calibre6">'='</em> expr <em class="calibre6">';'</em>&nbsp;&nbsp;{interp.store($ID.text, $expr.value);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The implementation method maps the variable name to that
value in a dictionary, like this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Interpreter.java">interp/syntax/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> store(<b class="calibre13">String</b> name, <b class="calibre13">Object</b> o) { globals.put(name, o); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To look up a variables value, we reverse the process and look up
the variable name in the dictionary.</p><p height="10" width="0" class="calibre5">To store values in a table rather than in the global memory space,
we use the <code class="calibre21">insert</code> statement.  After matching the
syntax, rule <code class="calibre21">insert</code> triggers
<tt class="calibre21">insertInto</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Q.g">interp/syntax/Q.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">insert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: <em class="calibre6">'insert'</em> <em class="calibre6">'into'</em> ID <em class="calibre6">'set'</em> setFields[interp.tables.get($ID.text)] <em class="calibre6">';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{interp.insertInto($ID.text, $setFields.row);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Before matching the field assignments, the rule creates a
<code class="calibre21">Table</code> and passes it to rule
<code class="calibre21">setFields</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Q.g">interp/syntax/Q.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">setFields[Table t] <b class="calibre13">returns</b> [Row row]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@init</b> { $row = new Row(t.columns); } <em class="calibre6">// set return value</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; set[$row] (<em class="calibre6">','</em> set[$row])*</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">set[Row row] <em class="calibre6">// pass in Row we're filling in</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID <em class="calibre6">'='</em> expr {row.set($ID.text, $expr.value);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After matching all the assignments, <code class="calibre21">setFields</code>
returns the <code class="calibre21">Row</code> it created. To get column
values, <code class="calibre21">setFields</code> invokes <code class="calibre21">expr</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/syntax/Q.g">interp/syntax/Q.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Match a simple value or do a query</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expr <b class="calibre13">returns</b> [Object value] <em class="calibre6">// access as $expr.value in other rules</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{$value = interp.load($ID.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; INT&nbsp;&nbsp;&nbsp;&nbsp; {$value = $INT.int;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; STRING&nbsp;&nbsp;{$value = $STRING.text;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; query&nbsp;&nbsp; {$value = $query.value;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">expr</code> not only matches the appropriate
syntax but also returns the computed value.  The last alternative lets us
store the <code class="calibre21">ResultSet</code> computed by a
<code class="calibre21">select</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tombuQuota = select quota from users where name='tombu';</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At this point, youve seen all the key pieces of a
syntax-directed interpreter. This type of interpreter is the simplest
possible because it does not construct any internal data structures
from the input. But, of course, this limits the kind of languages it
can handle. In the next pattern, were going to build an interpreter
for a much more complicated language.  To get more power, well build
an AST first and then walk it repeatedly to interpret input
programs.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern is analogous to Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>,
which emits output according to input syntax. Actions embedded within Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a> drive the interpreter.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_092.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_092.html.tip.tree-interp" class="pagebreak2"><small class="calibre35">Pattern 25:</small>&nbsp;&nbsp;&nbsp;Tree-Based Interpreter</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern executes programs by constructing an AST from
the source code and walking the tree.</em>
</p><p height="10" width="0" class="calibre5">This tree-based interpreter pattern builds a 
complete scope
tree before executing a program. That means it can support both 
statically typed languages like Java and dynamically typed languages
like Python. (It can resolve all symbols statically before execution.)</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">The previous pattern directly executed source code, without processing
it in any way. At the opposite extreme, a compiler translates source
code to machine code, which we can then run natively on the
processor.  Per the compiler application pipeline from Chapter 1, <a href="#text/part0000_split_014.html.chp.intro"><em class="calibre6">Language Applications Cracked Open</em></a>, a
compiler builds an intermediate representation and ultimately
generates optimized machine code from that IR.</p><p height="10" width="0" class="calibre5">A tree-based interpreter is like a compiler front end with an
interpreter grafted onto the end instead of a code generator.
Conceptually, this pattern isnt very different from Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a>.  The biggest difference is that we dont drive the
interpreter with the parser.  Instead, we build an AST with the parser
and then drive the interpreter with a tree visitor.</p><p height="10" width="0" class="calibre5">This structural change to the pipeline leads to a few advantages
over a syntax-directed interpreter:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>We can separate symbol definition from symbol resolution,
partitioning the tasks between parsing and execution.  This allows
forward references.</li><li height="6" class="calibre20"><span></span>Tree-based interpreters are more flexible because we can
do substitutions while building the AST if necessary. For a
statically typed language like Java, we could substitute the subtree
for <code class="calibre21">x</code> with a subtree for <code class="calibre21">this.x</code>. We could also rewrite the tree in a
separate tree pass before execution to perform optimizations and so
on.</li></ul><p height="10" width="0" class="calibre5">Building an interpreter for a language like Prolog or LISP is a lot
different from building one for Python or Java. To narrow the focus of
this pattern, we need to pick a particular languageone that is
similar to the language(s) youre likely to build. Since this high-level
interpreter works best for dynamically typed programming languages and
DSLs, well invent a Python-like dynamically typed language called
Pie.</p><h4 id="text/part0000_split_092.html.sec.pie" class="calibre26">Defining a Sample High-Level Language</h4><p height="10" width="0" class="calibre5">A Pie program consists 
of a series of function definitions,
<code class="calibre21">struct</code> definitions, and statements. Function
definitions specify the name and argument list as well as a sequence
of instructions followed by a period on a line by itself:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># define global variable x</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">def</b> f(y):&nbsp;&nbsp; <em class="calibre6"># define f in the global space</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;x = 2&nbsp;&nbsp; <em class="calibre6"># set global variable x</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;y = 3&nbsp;&nbsp; <em class="calibre6"># set parameter y</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;z = 4&nbsp;&nbsp; <em class="calibre6"># create local variable z</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># end of statement list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">f(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6"># call f with parameter y = 5</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The comments on the assignment statements specify the variable
creation semantics. If we dont see a previous definition in the
function scope or the global scope, we create a local variable.
Referencing a variable that doesnt exist is an error.</p><p height="10" width="0" class="calibre5">Pie has <code class="calibre21">return</code>, <code class="calibre21">print</code>, <code class="calibre21">if</code>, <code class="calibre21">while</code>, and call
statements. Expressions can have identifiers and the following
literals: characters, integers, and strings. The operators are <code class="calibre21">==</code>,
<code class="calibre21">&lt;</code>, <code class="calibre21">+</code>, <code class="calibre21">-</code>, <code class="calibre21">*</code>, <code class="calibre21">new</code> (create <code class="calibre21">struct</code> instance), and <code class="calibre21">.</code> (member
access).</p><p height="10" width="0" class="calibre5">Pie defines <code class="calibre21">struct</code>s in the global or function scopes using
C-like syntax but without the type specifiers. The following program
illustrates the struct definition and member access syntax:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">struct Point {x, y}&nbsp;&nbsp;<em class="calibre6"># define a struct symbol in global scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p = new Point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6"># create a new Point instance; store in global var</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p.x = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6"># set the fields of p</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p.y = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To resolve expression <code class="calibre21">p.x</code>, we resolve <code class="calibre21">p</code> and then look up <code class="calibre21">x</code>
within that memory space.  Pie makes sure that <code class="calibre21">x</code> and <code class="calibre21">y</code> exist as
fields in <code class="calibre21">p</code>s <code class="calibre21">struct</code> definition before allowing the assignment.</p><p height="10" width="0" class="calibre5">Before jumping into a sample implementation of Pie, lets take a
look at managing symbol tables in a tree-based interpreter and
executing code with a tree walker.</p><h4 class="calibre26">Managing Symbol Table</h4><p height="10" width="0" class="calibre5">This pattern doesnt define function and <code class="calibre21">struct</code>
symbols while it executes the input program.  
It does all that while parsing and
building the AST. During execution, it can resolve symbols using a
conventional scope tree built during the parse. Because were
resolving symbols after having defined them, this pattern allows
forward references. We can call a function defined later in the file,
for example.</p><p height="10" width="0" class="calibre5">Separating symbol table construction from execution significantly
simplifies the interpreter.  The parser deals with symbol scopes, and
the interpreter deals with memory spaces. Memory spaces dont do
double duty as scopes.  During execution, though, we still need scope
information to resolve symbols.</p><p height="10" width="0" class="calibre5">To carry scope information forward from the parser to the interpreter,
we can annotate the AST nodes.  Lets look at how a function call in a
Pie program carries through both phases.  A call to <tt class="calibre21">f</tt> results in a
<code class="calibre21">(CALL f)</code> subtree.  After creating the subtree, the parser sets the
<code class="calibre21">CALL</code> nodes <code class="calibre21">scope</code> field to the current scope (as we did in Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>). Then, during execution, the <tt class="calibre21">call</tt> action method can
call <code class="calibre21">resolve("f")</code> relative to that scope.</p><h4 class="calibre26">Executing Code with a Tree Visitor</h4><p height="10" width="0" class="calibre5">The interpreter uses Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a> to trigger
action methods as it walks the AST created by the parser.  
The visitor
dispatcher method triggers actions like
<tt class="calibre21">assign</tt>, <tt class="calibre21">ifstat</tt>, and
<tt class="calibre21">call</tt> upon seeing subtrees with
<code class="calibre21">=</code>, <code class="calibre21">if</code>, and
<code class="calibre21">CALL</code> root tokens. The dispatcher is a giant
<code class="calibre21">switch</code> statement, as youll see in the next
section.</p><p height="10" width="0" class="calibre5">The action methods take a single AST parameter and so must decode
instructions by walking the children. (In a syntax-directed
interpreter, the parser decodes instructions and passes the relevant
operands to the interpreter methods.)  Extracting information from
subtrees manually is tedious but straightforward. We also have to 
be sure that we send the visitor down the various subtree
children. Otherwise, the interpreter wont interpret the entire
program.</p><p height="10" width="0" class="calibre5">With all the generalities out of the way, lets implement our
first programming language interpreter.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">The first thing we need to do is build a grammar in
<code class="calibre21">Pie.g</code> that parses Pie code, constructs a scope
tree, and constructs an AST (Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>).  
Then, well
write methods in <code class="calibre21">Interpreter</code>
that implement the various Pie instructions and operations.
<code class="calibre21">Interpreter</code> also has the
<tt class="calibre21">exec</tt> dispatcher method for our visitor.</p><p height="10" width="0" class="calibre5">The nodes of the AST are of type <code class="calibre21">PieAST</code> and extend ANTLRs <code class="calibre21">CommonTree</code> with a <code class="calibre21">scope</code> field. <code class="calibre21">InterPie</code> has the code that tells
ANTLR to build <code class="calibre21">PieAST</code> nodes instead of <code class="calibre21">CommonTree</code> nodes.</p><p height="10" width="0" class="calibre5">The scope tree created by our parser consists of a variety of scope
objects per Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>. The scopes holds <code class="calibre21">VariableSymbol</code>
(for fields and parameters), <code class="calibre21">FunctionSymbol</code>, and <code class="calibre21">StructSymbol</code>
objects. Heres the complete symbol table class hierarchy for this
pattern:</p><div class="calibre1"><img id="text/part0000_split_092.html.d24e28351" class="calibre30" src="data:image/gif;base64,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" alt="images/interp/aggr-hier.png"></div><p height="10" width="0" class="calibre5">Technically, we dont need a full symbol table to execute Pie code.
A full symbol table and scope tree makes this implementation more
general, though. Some of you will want to build interpreters for
statically typed languages.</p><p height="10" width="0" class="calibre5">Other than the implementation methods and visitor dispatcher, our
<code class="calibre21">Interpreter</code> object houses a pointer to the AST
root (our code memory), the global memory, the function memory space
stack, and a pointer to the global scope:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">GlobalScope globalScope;&nbsp;&nbsp; <em class="calibre6">// global scope is filled by the parser</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MemorySpace globals = <b class="calibre13">new</b> MemorySpace(<em class="calibre6">"globals"</em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// global memory</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MemorySpace currentSpace = globals;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Stack</b>&lt;FunctionSpace&gt; stack = <b class="calibre13">new</b> <b class="calibre13">Stack</b>&lt;FunctionSpace&gt;();<em class="calibre6">// call stack</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PieAST root;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// the AST represents our code memory</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TokenRewriteStream tokens;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PieLexer lex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// lexer/parser are part of the processor</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PieParser parser;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because weve already seen parsing (Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>), AST construction (Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a>),
and scope tree construction before (Chapter 7, <a href="#text/part0000_split_071.html.chp.aggr-symtab"><em class="calibre6">Managing Symbol Tables for Data Aggregates</em></a>), we can focus on
fusing a visitor onto our implementation methods. The most important method is
the visitor dispatcher, <tt class="calibre21">exec</tt>. The goal of the dispatcher is to
invoke a method to handle each kind of subtree found in the tree. We
can implement that with a <code class="calibre21">switch</code> that looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** visitor dispatch according to node token type */</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public Object exec(PieAST t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;switch ( t.getType() ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.BLOCK : block(t); break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.ASSIGN : assign(t); break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.RETURN : ret(t); break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.PRINT : print(t); break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.IF : ifstat(t); break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.CALL : return call(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.NEW : return instance(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.ADD : return add(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.INT : return Integer.parseInt(t.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.DOT : return load(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PieParser.ID :&nbsp;&nbsp;return load(t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default : <em class="calibre6">error</em> // catch unhandled node types</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Handling a subtree means executing the appropriate interpreter
action and walking the subtree nodes. The combined visitor-action methods
take a single parameter: the root of the subtree it should
handle. Its up to the method to extract operands from the subtrees
children. For example, here is how to handle assignment subtrees:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> assign(PieAST t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;PieAST lhs = (PieAST)t.getChild(0);&nbsp;&nbsp; <em class="calibre6">// get operands</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;PieAST expr = (PieAST)t.getChild(1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b> value = exec(expr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// walk/evaluate expr</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( lhs.getType()==PieParser.DOT ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fieldassign(lhs, value); <em class="calibre6">// field ^('=' ^('.' a x) expr)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// var assign ^('=' a expr)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;MemorySpace space = getSpaceWithSymbol(lhs.getText());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( space==null ) space = currentSpace; <em class="calibre6">// create in current space</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;space.put(lhs.getText(), value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// store</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The left child of the <code class="calibre21">=</code> root will be
either a <code class="calibre21">ID</code> node or a member access expression with
a <code class="calibre21">.</code> root node. In either case, we need to
evaluate the expression on the right side of the assignment.  We
grab the second child (the expression) and evaluate it by recursively
calling <tt class="calibre21">exec</tt>.</p><p height="10" width="0" class="calibre5">The semantic rules for creating local variables are the same as in
Python. If a variable on the left of an assignment isnt in the
current function space or the global space, we create a new
variable. Heres how to figure out whether a variable already exists:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Return scope holding id's value; current func space or global. */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> MemorySpace getSpaceWithSymbol(<b class="calibre13">String</b> id) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> (stack.size()&gt;0 &amp;&amp; stack.peek().get(id)!=null) { <em class="calibre6">// in top stack?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> stack.peek();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( globals.get(id)!=null ) <b class="calibre13">return</b> globals;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// in globals?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// nowhere</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Assigning to a <code class="calibre21">struct</code> field is like assigning to
a variable in a <code class="calibre21">StructSpace</code> instead of
<code class="calibre21">FunctionSpace</code> or global
<code class="calibre21">MemorySpace</code>. The main difference is that we
want to ensure the field is defined instead of creating a new field.
Here is the core of <tt class="calibre21">fieldstore</tt> that stores to
<em class="calibre6">expr</em><code class="calibre21">.fieldname</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Object</b> a = load(<em class="calibre6">expr</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StructInstance struct = (StructInstance)a;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( struct.def.resolveMember(fieldname) == null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(<em class="calibre6">"can't assign; "</em>+struct.name+<em class="calibre6">" has no "</em>+fieldname+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">" field"</em>, f.token);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b>;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">struct.put(fieldname, value);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Finally, lets look at functions. To call a Pie
function, we make sure the function exists and then create a
<code class="calibre21">FunctionSpace</code> to hold parameter values:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">String</b> fname = t.getChild(0).getText();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">FunctionSymbol fs = (FunctionSymbol)t.scope.resolve(fname);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( fs==null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(<em class="calibre6">"no such function "</em>+fname, t.token);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">FunctionSpace fspace = <b class="calibre13">new</b> FunctionSpace(fs);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MemorySpace saveSpace = currentSpace;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentSpace = fspace;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Before storing parameters into that space, we have to make sure
that there is no mismatch in the number of parameters. The number of
actual parameters passed to the function has to be the same as in the
formal parameter list:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> argCount = t.getChildCount()-1;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// check for argument compatibility</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( fs.formalArgs==null &amp;&amp; argCount&gt;0 || <em class="calibre6">// args compatible?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; fs.formalArgs!=null &amp;&amp; fs.formalArgs.size()!=argCount ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;listener.error(<em class="calibre6">"function "</em>+fs.name+<em class="calibre6">" argument list mismatch"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, we assign the actual parameters to the formal parameter names
in the order given by the formal parameters:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> i = 0; <em class="calibre6">// define args according to order in formalArgs</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">for</b> (Symbol argS : fs.formalArgs.values()) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;VariableSymbol arg = (VariableSymbol)argS;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;PieAST ithArg = (PieAST)t.getChild(i+1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b> argValue = exec(ithArg);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fspace.put(arg.name, argValue);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At that point, were ready to execute the body of the target
function with <tt class="calibre21">exec</tt>. The
<code class="calibre21">FunctionSymbol</code> knows the AST for the functions
body (field <code class="calibre21">blockAST</code>).  To execute it,
though, weve got an issue. We have to get the <code class="calibre21">return</code> statement in the
called function to pop back out of our
implementations multiple method. The <code class="calibre21">return</code> statement should make
the interpreter return to the statement following the calling
statement. Clearly, though, we cant map <code class="calibre21">return</code> in
the interpreted language to <code class="calibre21">return</code> in our
implementation language:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void ret() { return; } // oops; improper return mechanism</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We need to unroll the <tt class="calibre21">ret</tt> and
<tt class="calibre21">exec</tt> implementation methods all the way back
to the <tt class="calibre21">call</tt> method. Thats exactly what
exceptions do. So, all weve got to do is wrap the execution of the
function body in a <code class="calibre21">try-catch</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/Interpreter.java">interp/tree/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Object</b> result = null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stack.push(fspace);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// PUSH new arg, local scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">try</b> { exec(fs.blockAST); } <em class="calibre6">// do the call</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">catch</b> (ReturnValue rv) { result = rv.value; } <em class="calibre6">// trap return value</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">stack.pop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// POP arg, locals</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">currentSpace = saveSpace;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">return</b> result;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">ret</tt> throws a
<code class="calibre21">ReturnValue</code> exception (or whatever you want to call
it).  If there is a return value, we can store it in the exception
object. This mechanism isnt slow if we share the same exception
object. Only creating exceptions is expensive; throwing them is no big
deal.  So, no matter how deep our implementations method call stack
is, <tt class="calibre21">ret</tt> will always get us back to the
statement following the function body execution.</p><p height="10" width="0" class="calibre5">Because we define all functions and <code class="calibre21">struct</code>s
during parsing, function calls and <code class="calibre21">new</code> operations
during execution can see any definition in the program. For example,
the following Pie code works with this pattern but not in the
syntax-directed interpreter because of forward references:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/forward.pie">interp/tree/forward.pie</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">print</b> f(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># references definition on next line</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">def</b> f(x) <b class="calibre13">return</b> 2*x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">print</b> new User&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># references definition on next line</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">struct User { name, password }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The interpreter sees the definitions with no problem:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java InterPie forward.pie</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{name=null, password=null}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Heres a program that tests the interpreters error handling:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/tree/structerrors.pie">interp/tree/structerrors.pie</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">struct User { name, password }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">u = new User&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">u.name = <em class="calibre6">"parrt"</em>&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6"># make u.name a string</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">u.name.y = <em class="calibre6">"parrt"</em>&nbsp;&nbsp;<em class="calibre6"># u.name is a string not a struct</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">u.x = 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># x isn't a field of User; can't write to it</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">print</b> u.x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6"># check for unknown field in expr as well</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The interpreter correctly identifies the three errors:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java InterPie structerrors.pie</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 4: u.name is not a struct in u.name.y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 5: can't assign; User instance has no x field</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">line 6: User instance has no x field</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern implements an interpreter for our dynamically typed Pie
language just like Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a>. It uses the following patterns:
Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>, Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>, and Pattern 18, <a href="#text/part0000_split_075.html.tip.struct-symtab"><em class="calibre6">Symbol Table for Data Aggregates</em></a>.
</p>

</div></div>
<div id="text/part0000_split_093.html"><div class="calibre">

<h2 id="text/part0000_split_093.html.d24e28965" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">This pattern concludes our chapter on high-level
interpreters. These interpreters are best suited to implementing DSLs
rather than general-purpose programming languages.  They are not too
hard to build and are very flexible. (We can add new instructions
without much trouble.) But, they are not particularly efficient at
run-time.  To squeeze memory resources down and to accelerate execution
speed, we need to process the input source code more.  In the next
chapter on bytecode interpreters, well do exactly that.  The upcoming
patterns are useful for making efficient DSL and general-purpose
language interpreters.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_093.html.FOOTNOTE-25" href="#text/part0000_split_087.html.FNPTR-25">[25]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://oai.cwi.nl/oai/asset/10893/10893D.pdf">http://oai.cwi.nl/oai/asset/10893/10893D.pdf</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_093.html.FOOTNOTE-26" href="#text/part0000_split_091.html.FNPTR-26">[26]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/ANTLR3/Pie">http://www.antlr.org/wiki/display/ANTLR3/Pie</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_093.html.FOOTNOTE-27" href="#text/part0000_split_091.html.FNPTR-27">[27]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://hbase.apache.org/">http://hbase.apache.org/</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_093.html.FOOTNOTE-28" href="#text/part0000_split_091.html.FNPTR-28">[28]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">Thanks
to Paul Ambrose for this idea.</p></dd></dl><div class="calibre3" id="text/part0000_split_093.html.calibre_pb_122"></div>

</div></div>
<div id="text/part0000_split_094.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_094.html.calibre_pb_123">&nbsp;</p><a id="text/part0000_split_094.html.toc-17"></a><h4 class="right2" id="text/part0000_split_094.html.chp.interp-bytecode">Chapter 10</h4>
</div></div>
<div id="text/part0000_split_095.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_095.html.calibre_pb_124">Building Bytecode Interpreters</h1><hr class="calibre17"><p height="10" width="0" class="calibre5"> In the previous chapter, we explored interpreters that operate on
high-level programs with little to no preprocessing before
execution.
Those interpreters are great for implementing DSLs because
they are the fastest path to getting a language up and running. Their
only drawback is run-time efficiency.  If we really care about
efficiency for a particular DSL or need to implement a more general
programming language, those interpreters arent appropriate.</p><p height="10" width="0" class="calibre5">In this chapter, well explore another category of interpreters
that is much more efficient.  Unfortunately, the efficiency comes at
the cost of a more complicated implementation.  In essence, we need a
tool that translates the high-level source code down into low-level
instructions called 
<em class="calibre6">bytecode instructions</em>
(instructions whose operation code fits in an 8-bit byte).  Then, we
can execute those bytecodes on an efficient interpreter called a 
<em class="calibre6">virtual machine</em><a id="text/part0000_split_095.html.FNPTR-29" href="#text/part0000_split_103.html.FOOTNOTE-29">[29]</a> (VM). (Were conjuring up an
imaginary machine.) Most of the currently popular languages are
VM-based (Java, JavaScript, C#, Python, Ruby 1.9).</p><p height="10" width="0" class="calibre5">The interpreter patterns in this chapter are real in the sense that
they resemble the core of most industrial-strength language
implementations.  In practice, the industrial-strength implementations
are a lot faster because theyre implemented in C or hand-tuned
machine code, not Java. Many of them even translate bytecode
instructions to native machine code on the fly. They also would have
many more instructions to deal with the complete set of arithmetic
operators, arrays, classes instead of <code class="calibre21">struct</code>s,
switches, and so on.  The sample implementations in this chapter dont
include those instructions for simplicity reasons, but wed implement
them in much the same way.</p><p height="10" width="0" class="calibre5">If were translating source code to low-level bytecodes, you might
ask why we dont compile all the way down to machine code and skip the
interpreter altogether. Raw machine code would be even more efficient.
Bytecode interpreters have a number of useful characteristics
including portability. (Machine code is specific to a CPU, whereas
bytecodes run on any computer with a compatible interpreter.) But, the
biggest reason we avoid generating machine code is that its pretty
hard.</p><p height="10" width="0" class="calibre5">CPU instructions have to be very simple so that we can implement them
easily and efficiently in hardware. The result is often an instruction
set that is quirky, irregular, and far removed from high-level source
code.  Bytecode interpreters, on the other hand, are specifically
designed to be easy to <em class="calibre6">target</em> (generate code for). At the same
time, instructions have to be low-level enough that we can interpret
them quickly.</p><p height="10" width="0" class="calibre5">In this chapter, were going to explore the instruction sets and
implementations for the two most common bytecode interpreter patterns,
starting with useful assembler pattern:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a>.  
To avoid having to program
our interpreters in binary, this pattern provides a general bytecode
assembler. It translates (assembles) human-readable bytecode assembly
code down to bytecode machine code.</li><li height="6" class="calibre20"><span></span>Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>. 
This pattern simulates a 
<em class="calibre6">stack machine</em>, a machine that holds all temporary
values such as operation results on an operand stack.  Stack-based
interpreters go back a long, long way. One of the most influential was
the UCSD
p-code<a id="text/part0000_split_095.html.FNPTR-30" href="#text/part0000_split_103.html.FOOTNOTE-30">[30]</a>
interpreter (partly because of its influence on James Goslings Java
interpreter).</li><li height="6" class="calibre20"><span></span>Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>. 
This pattern simulates a 
<em class="calibre6">register machine</em> very much like the underlying
hardware. Rather than pushing and popping operands from a stack, it
uses simulated general-purpose registers. (A 
<em class="calibre6">register</em> is a memory cell within a processor that
the processor can access much faster than going off-chip to the main
memory.)</li></ul><p height="10" width="0" class="calibre5">Rather than programming a bytecode interpreter by hand, we prefer
to program in a high-level language.  That means we need a bytecode
compiler that can translate it to bytecodes. Well focus on the
interpreters themselves here, though.  The next two chapters provide
the translation and generation background youd need to build a
bytecode compiler. Theres also a sample compiler on the ANTLR wiki
that generates an intermediate representation very similar to
bytecode.<a id="text/part0000_split_095.html.FNPTR-31" href="#text/part0000_split_103.html.FOOTNOTE-31">[31]</a></p><p height="10" width="0" class="calibre5">Before dissecting the guts of a bytecode interpreter, lets figure out
how to program these critters.</p>

</div></div>
<div id="text/part0000_split_096.html"><div class="calibre">

<h2 id="text/part0000_split_096.html.d24e29086" class="calibre18">Programming Bytecode Interpreters</h2><p height="10" width="0" class="calibre5">Programming a bytecode interpreter is very much like programming a
real processor. 
The biggest difference is that bytecode instruction
sets are much simpler and slightly higher-level. For example, we dont
have to worry about running out of registers in a register-based
interpreter. (We can assume there are an infinite number
of registers.)</p><p height="10" width="0" class="calibre5">Like the assembly language for a physical processor, each instruction
only does  a tiny amount of work. For example, it takes four
instructions to say <code class="calibre21">print 1+2</code> in the assembly
language syntax of Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iload r1, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; load int 1 into register one: r1 = 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iload r2, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; r2 = 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iadd r1, r2, r3&nbsp;&nbsp; ; r3 = r1 + r2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print r3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print value in r3</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">These instructions are similar to other register-based interpreters
such as Luas<a id="text/part0000_split_096.html.FNPTR-32" href="#text/part0000_split_103.html.FOOTNOTE-32">[32]</a> and the Dalvik
VMs.<a id="text/part0000_split_096.html.FNPTR-33" href="#text/part0000_split_103.html.FOOTNOTE-33">[33]</a> Operands and operation results
go into registers.</p><p height="10" width="0" class="calibre5">Stack code, on the other hand, works like the old HP calculators that
used 
Reverse Polish Notation<a id="text/part0000_split_096.html.FNPTR-34" href="#text/part0000_split_103.html.FOOTNOTE-34">[34]</a> (RPN).  We push operands onto a stack and then execute the
operation:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iconst 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; push int 1 onto operand stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iconst 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; push int 2 onto operand stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; pop and add top 2 elements on stack, push result</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; pop and print top value on stack</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The biggest difference between the two is that stack code doesnt have
to figure out which register to use for which value; instructions have
implicit operands (the top of the stack).</p><p height="10" width="0" class="calibre5">Notice that the arithmetic operation instructions are all typed. That
is, the instruction encodes the type of the operands. For example,
<code class="calibre21">iadd</code> is integer add, but we can define <code class="calibre21">fadd</code> (floating-point
add) or even <code class="calibre21">sadd</code> (string add).  The idea is that we want to
do as little thinking as possible at run-time.   Figuring out whether
to do an integer or floating-point add at run-time costs time. For
statically typed languages like Java, we can figure out the
appropriate type using the patterns in Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>.  We cant figure
out types in general for dynamically typed languages like Python, so wed
use generic bytecodes like <code class="calibre21">add</code> instead of <code class="calibre21">iadd</code>.</p><p height="10" width="0" class="calibre5">Bytecode interpreters do not execute these examples in assembly
language (text) form as weve written them.  The interpreter actually
needs those instructions in machine code.  Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a> reads
assembly programs and fills a byte array with bytecodes and operands.
For example, heres the byte array memory formats for an instruction
with no operands, one operand, and two operands:</p><div class="calibre1"><img id="text/part0000_split_096.html.d24e29178" class="calibre34" src="data:image/gif;base64,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" alt="images/interp/memory-layout.png"></div><p height="10" width="0" class="calibre5">Operands <em class="calibre6">a</em> and <em class="calibre6">b</em> are always 4-byte integers and stored
from high byte (<em class="calibre6">a</em><sub class="calibre48">3</sub>) to low byte (<em class="calibre6">a</em><sub class="calibre48">0</sub>) sequentially in memory. Here is a code
memory dump (in decimal) for the stack code snippet for <code class="calibre21">print 1+2</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp;19&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp;19&nbsp;&nbsp; 0&nbsp;&nbsp; 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0008:&nbsp;&nbsp; 0&nbsp;&nbsp; 2&nbsp;&nbsp; 1&nbsp;&nbsp;28</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Values 19, 1, and 28 are the bytecodes for instructions <code class="calibre21">iconst</code>,
<code class="calibre21">iadd</code>, and <code class="calibre21">print</code>, respectively.  Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a> also provides a<em class="calibre6">disassembler</em>, which converts machine code back to assembly
code. This is what the disassembled stack code looks like:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp; ICONST&nbsp;&nbsp; 1&nbsp;&nbsp; ; bytes = 19 0 0 0 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0005:&nbsp;&nbsp; ICONST&nbsp;&nbsp; 2&nbsp;&nbsp; ; bytes = 19 0 0 0 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0010:&nbsp;&nbsp; IADD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; bytes = 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0011:&nbsp;&nbsp; PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; bytes = 28</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">When debugging bytecode programs or even the bytecode interpreter
itself, an <em class="calibre6">instruction trace</em> is extremely useful. It shows
the relevant state of the interpreter as it encounters
instructions. Here is the instruction trace for our stack code example:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp; ICONST&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[ ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0005:&nbsp;&nbsp; ICONST&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[ 1 ]&nbsp;&nbsp;&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0010:&nbsp;&nbsp; IADD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[ 1 2 ]&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0011:&nbsp;&nbsp; PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=[ 3 ]&nbsp;&nbsp;&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The stack shows the state of the machine before the execution of the
instruction on that line. You can see the stack grow (to the right)
and shrink according to the instructions. (Well see what the call
stack is for when we discuss function calls in a moment.) The two
interpreter patterns in this chapter provide three command-line
options to access these features: <code class="calibre21">-dump</code>, <code class="calibre21">-dis</code>, and <code class="calibre21">-trace</code>.</p><p height="10" width="0" class="calibre5">With these examples in mind, lets get a little more formal. The
next section describes the general assembly language syntax well
use for our interpreters.
  
</p>

</div></div>
<div id="text/part0000_split_097.html"><div class="calibre">

<h2 id="text/part0000_split_097.html.d24e29275" class="calibre18">Defining an Assembly Language Syntax</h2><p height="10" width="0" class="calibre5">A bytecode assembly language program defines globals as well as a
sequence of functions and instructions:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.globals <em class="calibre6">number-of-global-variable-slots</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">function-definitions</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=<em class="calibre6">num-locals-or-registers</em>: ; begin exec here</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For each function, we define the name, how many parameters it has, and
how much local space it needs:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def <em class="calibre6">function-name</em>: args=<em class="calibre6">num-args</em>, locals=<em class="calibre6">num-locals-or-registers</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Execution begins in function <tt class="calibre21">main</tt> or at code address 0 if you
dont specify one. The instructions themselves have a bytecode and up to three
parameters:</p><p height="10" width="0" class="calibre5"> <em class="calibre6">op</em>&nbsp;operand<sub class="calibre48">1</sub>, operand<sub class="calibre48">2</sub>, , operand<sub class="calibre48">n</sub></p><p height="10" width="0" class="calibre5">Rather than hard-coding the instruction names (like <code class="calibre21">ret</code> and <code class="calibre21">store</code>),
the implementation provided below in Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a>, lets us specify them
with an array of instruction descriptors. That way, we can use the assembler for
both interpreter patterns in this chapter.
To label code 
memory addresses, use an identifier followed by a
colon. Instructions can refer to labels defined previously or below in
the assembly file. In the following code, <code class="calibre21">start</code> and
<code class="calibre21">done</code> are code labels used by branch instructions:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">start:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; start of the loop</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; check loop termination condition</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;brt done&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; br out if condition met (true)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;br start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; branch back to top of loop</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">done:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; end of the loop</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The only real difference between a register and a stack machine is in
the way we program them.  
We either load operands into registers or
push them onto the stack; the difference is as simple as
that. Syntactically, register code is a minor superset of stack code
because of its register operands. Their architecture and
implementations are almost identical as well.  The next section
describes general bytecode architecture, leaving register and stack
machine specifics to the individual patterns.
</p>

</div></div>
<div id="text/part0000_split_098.html"><div class="calibre">

<h2 id="text/part0000_split_098.html.d24e29409" class="calibre18">Bytecode Machine Architecture</h2><p height="10" width="0" class="calibre5">A bytecode interpreter simulates a computer with the following components:
</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Code memory</em>: 
This byte array holds a programs
bytecode instructions (bytecodes plus operands). Addresses are
integers.</li><li height="6" class="calibre20"><span></span><em class="calibre6">ip register</em>:
The instruction pointer is a
special-purpose register that points into code memory at the next
instruction to execute.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Global memory</em>: 
Global memory holds a fixed number
of slots for variables.  The memory slots
can point at <code class="calibre21">Integer</code>, <code class="calibre21">Float</code>, <code class="calibre21">String</code>, and <code class="calibre21">struct</code>
instances. Unlike the high-level interpreters from the previous chapter,
we access variables by integer address rather than name.</li><li height="6" class="calibre20"><span></span><em class="calibre6">CPU</em>: 
To execute instructions, the interpreter has a
simulated CPU that amounts to a loop around a giant <code class="calibre21">switch</code> on
bytecode statement. This is called the instruction <em class="calibre6">dispatcher</em>.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Constant pool</em>: 
Anything that we cant store as a
4-byte integer operand goes into the constant pool. This includes
strings, floating-point numbers, and function symbols.  Instructions
like <code class="calibre21">sconst</code> and <code class="calibre21">fconst</code> use an index into the constant pool instead
of the actual operand.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Function call stack</em>: 
The interpreter has a 
stack to hold function call return addresses as well as parameters and
local variables.</li><li height="6" class="calibre20"><span></span><em class="calibre6">fp register</em>:
A special-purpose register called the frame pointer that
points to the top of the function call stack.
<code class="calibre21">StackFrame</code> represents the information we need
to invoke functions.</li></ul><p height="10" width="0" class="calibre5">In addition to those elements, Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a> has the following:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Operand stack</em>:
 Rather than loading values into
registers, the interpreter pushes temporary values onto the operand
stack. All instruction operands are either in code memory or on the
stack.</li><li height="6" class="calibre20"><span></span><em class="calibre6">sp register</em>:
A special-purpose register called the stack pointer that
points to the top of the operand stack.</li></ul><p height="10" width="0" class="calibre5">Instead of an operand stack, Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a> register machine
has the following:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">An infinite and regular register set</em> per function
call.  Functions can access any element in the register array, whereas
a stack can only access elements   at the end. Our sample register machine
 implementation reserves register 0 to hold function return values.  </li></ul><p height="10" width="0" class="calibre5">Its worth zooming in on the processor and the constant pool. Then we
can look at how function calls work.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Instruction Set Design Affects Interpreter Speed</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">
      Even within the same kind of interpreter, theres considerable freedom
      in terms of what instructions we define. The first DSL I implemented
      was a language called Karel for controlling industrial robots (using
      Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>).  After defining a basic instruction set to
      support the high-level robot control instructions, I focused on a few
      specialized instructions to make the interpreter faster.</small></p></blockquote><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Oddly enough, <em class="calibre6">adding</em> instructions increased its speed
      dramatically. For example, I created a special <code class="calibre21">iconst0</code> instruction
      to get 0 onto the stack using a single byte in code memory (instead of
      the general-purpose integer load, <code class="calibre21">iconst</code>&nbsp;<em class="calibre6">n</em>).  The general
      instruction required 3 bytes (bytecode plus a 2-byte integer) in code
      memory vs. 1 byte for <code class="calibre21">iconst0</code>. Avoiding those memory fetches
      and operand decodes saved quite a bit.  I also squashed the four
      instructions necessary to increment a variable into a single <code class="calibre21">inc</code>
      instruction. Adding specialized instructions for common operations is
      the easiest way to speed up an interpreter.</small></p></blockquote></div><hr class="calibre17"></div><h3 class="calibre23">Bytecode Processors</h3><p height="10" width="0" class="calibre5">The processor is the heart of an interpreter and has a simple job: it
loops around a fetch-decode-execute mechanism. 
The processor fetches a
bytecode and then jumps to a code fragment that executes that
instruction:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void cpu() {&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;short bytecode = code[ip];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;while ( <em class="calibre6">bytecode-not-halt</em> &amp;&amp; ip &lt; code.length ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip++; //jump to next instruction or first byte of operand</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (bytecode) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">bytecode1</em> : <em class="calibre6">exec-bytecode1</em>; break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">bytecode2</em> : <em class="calibre6">exec-bytecode2</em>; break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">bytecodeN</em> : <em class="calibre6">exec-bytecodeN</em>; break;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytecode = code[ip];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The CPU stops when it hits a <code class="calibre21">halt</code> instruction or runs out of
instructions to execute at the end of the code memory.</p><p height="10" width="0" class="calibre5">The cases in the <code class="calibre21">switch</code> statement execute the code fragment
necessary to simulate the instructions.  For example, here is how we
execute the <code class="calibre21">br</code> instruction (branch to a new code memory address):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BR :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// branch to instruction's address operand</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;int addr = <em class="calibre6">convert-4-bytes-at-code[ip]-to-int</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip = addr; // jump</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If the instruction has an operand (which is always right next to the
bytecode), the code fragment pulls the operand from code memory and
bumps the instruction pointer by four bytes.  As another example, here
is the code to execute the stack-based <code class="calibre21">iconst</code> instruction (push an
integer constant onto the operand stack):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case ICONST :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;int word = <em class="calibre6">convert-4-bytes-at-code[ip]-to-int</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip += 4;&nbsp;&nbsp;// jump over integer constant operand in code memory</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">push-word-onto-operand-stack</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Some instructions take data not code address operands.  These
instructions can access globals, parameters, locals, and <code class="calibre21">struct</code>
instances. Well worry about parameters and locals in the specific
patterns. Now, lets see how instructions manipulate global memory
and data aggregates.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">gstore</code> instruction (for both interpreters) stores a value into
global memory. 
To implement that, we can treat the global memory space
as an array of objects:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals[<em class="calibre6">address</em>] = <em class="calibre6">value</em>;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">gload</code> instruction does the opposite. 
It loads a value from
global memory into a register or pushes it onto the operand stack.</p><p height="10" width="0" class="calibre5">The fields of a <code class="calibre21">struct</code> look just like a small memory space.  The
operands of the <code class="calibre21">fload</code> and <code class="calibre21">fstore</code> instructions are field indexes
into the structure. Given a value, a structure, and a field index, the
<code class="calibre21">fstore</code> instruction executes as follows:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">struct</em>.fields[<em class="calibre6">field-index</em>] = <em class="calibre6">value</em>;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We can get data values either from memory or from an instruction
operand. Some of these operands, though, wont fit in the 4-byte slot
following a bytecode.  Weve got to stick them in the constant pool.</p><h3 id="text/part0000_split_098.html.sec.constant-pool" class="calibre23">Storing Large Constants in the Constant Pool</h3><p height="10" width="0" class="calibre5">All instruction operands must be integers or convertible to
an integer. 
(Characters convert to an integer.) Strings obviously dont
fit in a 4-byte integer, so weve got to store them outside of code
memory. Bytecode interpreters store strings and other noninteger
constants in a <em class="calibre6">constant pool</em>. Instead of the actual object,
the instruction operand is an index into the constant pool.  The
constant pool is just an array of objects and is commonly used by
bytecode interpreters (like the Java VM). Besides strings, there are
two other items weve got to store in the constant pool: floating-point
numbers and function descriptors.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">float</code> type in Java is 32 bits and could fit in code memory no
problem. But, lets store floating-point operands in the constant pool like the Java VM does.  In Figure 27, <a href="#text/part0000_split_098.html.fig.constant-pool"><em class="calibre6">Bytecode operand and constant pool relationship</em></a>, we can see the relationship between (stack) bytecode instruction operands
and the constant pool for the following code snippet. The assembler
converts the <code class="calibre21">sconst</code> and <code class="calibre21">fconst</code> operands to indexes into the
constant pool.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">sconst "hi"&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">fconst 3.4&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">iconst 10&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">cconst 'c'&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_098.html.fig.constant-pool"><img id="text/part0000_split_098.html.d24e29799" class="calibre2" src="data:image/gif;base64,R0lGODlhSQFlAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAABJAWUAAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fQIMKHUq0qNGjSJMqXcq0qdOnLMeJg8pQ3LirWP9ZlarS6tSBW6mKLShOXLl06MqNs1j2YdmvbN9SXCevrrx47ciZe/funMp77tStFZgOnjtyYxObazevsbx3iOeqcyjunjq/F825W1eOort68Ni5izdPHTp27MyJM4fu3GBy59JOXd36NTp05L6WO3dAoLgD5Q4cGLfb3D918tpdRryOnjzBAseRy5343+7WB87xPtf557h2d/H+rXtHDx/icrfXEieXPbK42OXEkXsHr/M4+FOnF786mt1g+eWYcw51/9yXDoGw3YPYOfK409tE7pR2lTr0xINPOupk5w4876Rj1njvsHPOe+1wmE455awDT2jxHcDOO+64Vo477bgTWIntmEMXPPG8g0857MwjDzzQnWMaXEsBaM6SLtKIGmrttCPikuaUQw5XNr03TzzoTHVAaNqx06Ngp63jzjvrTJcOX+ygc48886xjjjr0tTPgOvi86A465shTzzvxFYhPjSEOWA6d8bCjVorvWIhePO4YB2Gca5UTT12X8uhcheTg41xj8IzzmTzOregYPen02dg89LRGDz3+rNbTGD0bzlMPnPNsWFeF63z33GBJvXUOOzza1eM6yOK54aWYwqNcfHLJ1Ck97cBVFnKfzpPOZ9maySqciZLKF6l+vvNmPRXSA886tsJzwFTl+CmkusSe2k5h9orZzoMSRdirdfAIKTA99fTYzqEwxlPwXgD0yA54ssK4DjuglViPOvfUw46K5akjJGnyYHipkHb1xSOBSImDzpkcKqcdb1ZOp9+SLw9LH4cwsvNuTOQEyY5BnorILjx+xpOOzwqrG6I5PJpzT4nwFBwkrefEExqp7gxWTmNtMkvrPejEI3aut9VF9L6eUfoPOXbVBeNdhp1TYqMVppipO6hlalj+1Ia9E2dz3EV4Tp9wPmZlO6/W9eI87fSoFDn3mOksOxkC65DTE0e5YWCmDdfSOB7/HB3Y78jTGYOsMj4OOsm9eFei4vBV2WjwOMdYyOJs2DjjA20Nz4jukFpPOgX6TbCH4wQsJNqTsnMlOvNwWBc+99BNj5gFx1O33NqDdtqltyq8JZzqNFelO/TwVviQB2i2ajznrHOrPPggORRx61y6p/0VmYVPo2ILTMzacpL3NOhK40gHPUpnunHcY0uwwsfq8IKONflJHvOBx3xgpb3kqAsd33EWaaolEN8pqHS2Sod0lHcx4jArOfyK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" alt="images/interp/constant-pool.png"><hr class="calibre17"><b class="calibre13">Figure 26. Bytecode operand and constant pool relationship</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The last kind of object youll see in the constant pool is a <code class="calibre21">FunctionSymbol</code>.  The <code class="calibre21">call</code> instruction needs to know how many
parameters and local variables each function needs.  It looks at the
constant pool entry for the function to get this information.  In Figure 28, <a href="#text/part0000_split_098.html.fig.constant-pool-func"><em class="calibre6">Function symbols in constant pool</em></a>, we can see how the assembler converts the <code class="calibre21">call</code> operand
to an index into the constant pool for the following program:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;sconst "hi" ; start by getting parameter onto operand stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call f()&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def f: args=1, locals=0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;load 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; get 1st parameter</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; print</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return no value</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_098.html.fig.constant-pool-func"><img id="text/part0000_split_098.html.d24e29832" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/constant-pool-func.png"><hr class="calibre17"><b class="calibre13">Figure 27. Function symbols in constant pool</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Function calls involve more than the constant pool. They also use the
call stack (and, for the stack-based interpreter, the operand stack),
as well see in the next section.
</p><h3 id="text/part0000_split_098.html.sec.func-calls" class="calibre23">Calling Functions</h3><p height="10" width="0" class="calibre5">The mechanism for calling a function and returning is the same for
both Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a> and Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>.  
The only difference
lies in how they handle parameters, locals, and return values. Well
leave the details of how those temporary values work to the individual
interpreter patterns. In this section, well focus on the general
mechanism for calling and returning from a function. Lets start 
with a simple program that has two functions:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=0 ; void main()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call f()&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def f: args=0, locals=0&nbsp;&nbsp;&nbsp;&nbsp;; void f()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call g()&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def g: args=0, locals=0&nbsp;&nbsp;&nbsp;&nbsp;; void g()</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The main program calls <tt class="calibre21">f</tt>, which calls
<tt class="calibre21">g</tt>.  Right before <tt class="calibre21">g</tt>
returns, the interpreter has pushed three
<code class="calibre21">StackFrame</code> objects onto the call stack. A<em class="calibre6">stack frame</em> is an object that tracks information
about a function call. For both interpreters, stack frames store
parameters, local variables, and the return address. </p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Comparing Interpreter Speed</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Out of curiosity, I compared the speed of the two bytecode
      interpreters in this chapter. 
      For a simple count to 100 million
      loop, I found that hand-optimized register code was about twice as
      fast as stack code (5.9 seconds vs. 12). The stack machine is still a
      substantial 4.5 times faster than Pattern 25, <a href="#text/part0000_split_092.html.tip.tree-interp"><em class="calibre6">Tree-Based Interpreter</em></a>, which clocks in at a pokey 54 seconds.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">In Figure 29, <a href="#text/part0000_split_098.html.fig.call-stack"><em class="calibre6">Function call stack right before ret in g</em></a>, we can see the call stack with the fields of the
stack frames filled in. (The <code class="calibre21">locals</code> array is
called <code class="calibre21">registers</code> in a register machine.)  The
frames point at the appropriate function symbol held in the constant
pool.  The first stack frame is from the implicit call to
<tt class="calibre21">main</tt> from the interpreter. The other two
frames are for the explicit calls to <tt class="calibre21">f</tt> and
<tt class="calibre21">g</tt>.</p><div class="calibre1" id="text/part0000_split_098.html.fig.call-stack"><img id="text/part0000_split_098.html.d24e29964" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/call-stack.png"><hr class="calibre17"><b class="calibre13">Figure 28. Function call stack right before <code class="calibre21">ret</code> in <tt class="calibre21">g</tt></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The easiest way to see whats going on is to look at the instruction
trace because it shows how the stacks grow and shrink for each
instruction:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp;&nbsp; #1; f()@6&nbsp;&nbsp; stack=[]&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0006:&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp;&nbsp; #2; g()@12&nbsp;&nbsp;stack=[]&nbsp;&nbsp;calls=[ main f ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0012:&nbsp;&nbsp; RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[]&nbsp;&nbsp;calls=[ main f g ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0011:&nbsp;&nbsp; RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[]&nbsp;&nbsp;calls=[ main f ]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The stacks grow to the right and indicate the state before each
instruction executes. After each <code class="calibre21">call</code> instruction, the call stack
grows by one stack frame.  The call stack shrinks by one at each <code class="calibre21">ret</code>
instruction.</p><p height="10" width="0" class="calibre5">At this point, we know what bytecode programs look like and how
bytecode interpreters represent them in simulated code memory and in a
constant pool. We also looked at interpreter architecture to see how
interpreters execute instructions. This material, along with the
patterns that follow, is enough to help you build a bytecode
interpreter for a DSL. Unfortunately, a lot more is going on in a
general-purpose programming language interpreter than what weve
discussed here. (These bytecode interpreters rely heavily on the Java
VM.) The next section gives you a taste of whats involved in building
a more general and more efficient interpreter.
</p>

</div></div>
<div id="text/part0000_split_099.html"><div class="calibre">

<h2 id="text/part0000_split_099.html.d24e30009" class="calibre18">Where to Go from Here</h2><p height="10" width="0" class="calibre5">In this chapter, we had to completely ignore garbage collection,
executing code from more than one source file (linking), classes,
libraries, and debuggers. But, wed need all of that to build an
interpreter for a general-purpose programming language.  The best way
to figure out how all that works is to dig into the source for an
existing interpreter.  Interpreter source code is available for just
about every common language, both dynamically typed and
statically typed.  You can also read the literature on the Smalltalk
and Self interpreters as well as garbage collection and dynamic method
dispatch.  A good paper to read on register-based bytecode machines
is <a href="#text/part0000_split_135.html.d2381e235"><em class="calibre6">The Implementation of Lua 5.0</em>&nbsp;[IdC05]</a>.</p><p height="10" width="0" class="calibre5">One of the things youll discover quickly when reading source code or
building your own interpreter is that making an interpreter go really
fast is not that easy.  Every CPU clock cycle and memory access
counts. For that reason, Java is not the best implementation language
since we have no control over the underlying hardware (but I
didnt want to switch to C++ on you in the middle of the book). In
fact, the core of most fast interpreters is some hand-tuned assembly
code. Knowledge of computer architecture, such as cache memory and CPU
pipelines, is essential.</p><p height="10" width="0" class="calibre5">In January 2009, I spoke with Dan Bornstein, the guy who designed
the 
Dalvik<a id="text/part0000_split_099.html.FNPTR-35" href="#text/part0000_split_103.html.FOOTNOTE-35">[35]</a>
VM (a register-based VM that runs Java programs on Googles Android
mobile platform, though with a different bytecode). He described the
amazing gymnastics he and the VM team went through to squeeze every
last drop of efficiency out of the phones
ARM<a id="text/part0000_split_099.html.FNPTR-36" href="#text/part0000_split_103.html.FOOTNOTE-36">[36]</a> CPU, and
flash memory. (Flash memory is much slower than dynamic memory
but doesnt get amnesia when you lose power.)  Aside from being slow,
there isnt much flash memory on the phone device.  The Dalvik VM
tries to share data structures and compress them whenever
possible.</p><p height="10" width="0" class="calibre5">On average, the Dalvik VM uses a bit more code memory than the Java
VMs stack-based instruction set for a given method. But, as Bornstein
explains, the trade-off is totally worth it.  The Dalvik VM executes
many fewer instructions to achieve the same result. (It can reuse
registers to avoid unnecessary operand stack pushes and pops.) Because
of the overhead to execute each instruction, fewer instructions translates to
much less overhead and higher performance.</p><p height="10" width="0" class="calibre5">The Dalvik VM implementation details are beyond the scope of this
intermediate-level book, but you can learn more by looking at the
Dalvik VM source code. (You can also learn some of the underlying
principles by doing a web search for <em class="calibre6">threaded interpreter</em>.)</p><p height="10" width="0" class="calibre5">Lets finish up this introductory material with a summary of when to
use our bytecode patterns:
</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Both bytecode interpreters need this
unless we want to program in raw binary machine code.
</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">A stack machine is more
or less the traditional bytecode interpreter. 
Some people prefer
a stack over registers purely for style reasons. Its suitable for
efficiently executing DSLs and general purpose programming languages.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Register machines can often execute high-level programs faster than stack
machines. 
Generating register code is as easy as
generating stack code, but the generated code could be bigger and
slower. To attain their full potential, either the compiler or the
interpreter has to massage code blocks to reuse registers and do other
optimizations.</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5">Get your spelunking gear on. Its time to explore bytecode interpreter
patterns.</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_100.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_100.html.tip.bytecode-asm" class="pagebreak2"><small class="calibre35">Pattern 26:</small>&nbsp;&nbsp;&nbsp;Bytecode Assembler</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern translates a text-based human-readable assembly
language program into binary bytecode instructions.</em>
</p><p height="10" width="0" class="calibre5">The assembly language instruction set accepted by this pattern is
reprogrammable (it isnt fixed) and handles both stack-based and
register-based instructions.</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Bytecode interpreters feed off low-level byte arrays full of
bytecodes (operation codes that fit into a byte) and integer operands.
Generating raw bytecodes from a bytecode compiler is an extra burden
on an already complex compiler. Its easier to generate text-based
assembly code and then have an assembler convert that to machine code.
In other words, rather than generating bytes 14, 0, 0, 0, 0, and 21,
its easier to generate the following equivalent (stack machine)
assembly code that prints hi:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">sconst "hi"&nbsp;&nbsp;&nbsp;&nbsp; ; push a string constant onto the stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; print the object on the top of the stack</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">From a text-based assembly program, an assembler yields the following
four key elements:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Global data space size</em>: 
How many variable slots to reserve in global memory.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Code memory</em>: 
This byte array contains the instruction
stream derived from the assembly program. It contains bytecodes
and any instruction operands.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Main program address</em>: 
The code memory address at
which the interpreter should start executing the program.  This is the
address associated with the <tt class="calibre21">main</tt>
function, or address zero if its not specified.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Constant pool</em>: 
This table keeps noninteger operands
out of code memory. It tracks strings, floating-point numbers, and
function descriptors. Instruction operands can refer to constant
pool elements via an integer index (see <a href="#text/part0000_split_098.html.sec.constant-pool"><em class="calibre6">Storing Large Constants in the Constant Pool</em></a>).</li></ul><p height="10" width="0" class="calibre5">Were going to start our discussion by looking at the basic
architecture of an assembler and how to generate machine code from
assembly code. Then, well look at how to fill the constant pool with
operands that dont fit in code memory.  Finally, well look at
assembly code symbol table management.  At that point, well be ready
to tackle a sample implementation.</p><h4 class="calibre26">Generating Bytecodes into Code Memory</h4><p height="10" width="0" class="calibre5">The basic idea behind an assembler is to trigger appropriate action
methods upon seeing the various input constructs. 
(Later, well
recognize this as Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>.)</p><p height="10" width="0" class="calibre5">Here are some of the methods in the assemblers interface:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void gen(Token instrToken) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void gen(Token instrToken, Token operandToken) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void defineFunction(Token idToken, int nargs, int nlocals) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void defineLabel(Token idToken) {;}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We clearly need a parser to read in the text assembly code, but that
parser shouldnt directly implement the assembler functionality. It
should contain the minimal actions necessary to call the code
generation and symbol table management methods.  We can isolate the
method implementations in a subclass. (This is a generically useful
pattern whereby we separate functionality from language syntax.) For
example, heres a grammar rule that handles instructions with two
operands:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">instr2 : ID operand ',' operand {gen(<em class="calibre6">instr-name</em>,<em class="calibre6">opnd1</em>,<em class="calibre6">opnd2</em>);}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">operand</code> rule would match the various kind of operands such as
labels, registers, functions, integers, and so on. The action invokes
the <tt class="calibre21">gen</tt> method with information obtained while parsing the
instruction.</p><p height="10" width="0" class="calibre5">As the assembler reads instructions, it writes bytecodes and operands
to a <code class="calibre21">code</code> array.  To keep its place, it moves along an <code class="calibre21">ip</code>
(instruction pointer). <code class="calibre21">ip</code> is always the next write address.  For
instructions with no arguments, the assembler writes a single byte to
the code array and bumps <code class="calibre21">ip</code> by one.  Instructions with one argument
are 5 bytes long, 1 for the bytecode and 4 bytes for the
operand. We write the bytecode and the operand, bumping <code class="calibre21">ip</code> by 5
bytes as we go.
All bytecode operands are 4-byte integers, so weve got to do something
fancy with nonintegers, as well see next.</p><h4 id="text/part0000_split_100.html.sec.fill-pool" class="calibre26">Filling the Constant Pool</h4><p height="10" width="0" class="calibre5">As we saw in <a href="#text/part0000_split_098.html.sec.constant-pool"><em class="calibre6">Storing Large Constants in the Constant Pool</em></a>, any operand we cant store or convert to an
integer goes into the constant pool.  
The operand is then an index
into the constant pool. We can store characters as integers, but we
have to store strings, floats, and function symbols in the constant
pool. (Well look at function symbols in the next section.) Here is the
algorithm for writing bytecode operands:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">switch ( <em class="calibre6">kind-of-operand</em> ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">int-or-char</em>&nbsp;&nbsp;&nbsp;&nbsp; : v = <em class="calibre6">int-value</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">float-or-string</em> : v = <em class="calibre6">get-constant-pool-index</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">func-ref</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: v = <em class="calibre6">get-constant-pool-index</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">label</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : v = <em class="calibre6">label-address</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;case <em class="calibre6">register</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: v = <em class="calibre6">register-number</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">write-v-to-code-memory</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To compute a constant pool index, this code returns the index of an
existing pool entry or adds the object to the pool (and
returns the new index):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">int <em class="calibre6">get-constant-pool-index</em>(Object o) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( <em class="calibre6">constant-pool-contains-o</em> ) return <em class="calibre6">its-index</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else { <em class="calibre6">add-to-pool</em>; return <em class="calibre6">index-of-o</em>; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Every reference to the same floating-point number or string results in
the same constant pool index.  In that sense, the constant pool is
like a flat scope (Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>) for operand values.  That
scope also contains function symbols for use as operands of the
function <code class="calibre21">call</code> instruction.</p><h4 class="calibre26">Tracking and Referencing Functions</h4><p height="10" width="0" class="calibre5">Bytecode interpreters dont know anything about symbols.  
For speed
reasons, they only deal  with code addresses, data addresses, and
constant pool indexes.  Bytecode assembly language, on the other hand,
knows about two kinds of symbols: functions and code labels. Both live
in their own private Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>.  Well look at functions
here and then check out code labels in the next section.</p><p height="10" width="0" class="calibre5">Function information from the assembly code must survive the assembly
process. Bytecode interpreters need function parameter and local
variable information at run-time. We can tuck this information into the
constant pool along with the strings and floats. That means adding a
<code class="calibre21">FunctionSymbol</code> using the <em class="calibre6">get-constant-pool-index</em> algorithm
from the previous section.  The assembler stores the constant pool
index as the operand for the <code class="calibre21">call</code> instruction. At execution time,
the interpreter finds the functions code start address by looking in
the constant pool using that index. Heres the algorithm for defining
a function:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void defineFunction(Token idToken, int args, int locals) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fs = <em class="calibre6">new-FunctionSymbol-based-upon-args</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( <em class="calibre6">function-referred-to-before-definition</em> )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">replace-element-in-constant-pool-with-fs-at-same-index</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else <em class="calibre6">save-fs-into-constant-pool</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If the assembly program refers to a function before its defined, the
algorithm adds a dummy <code class="calibre21">FunctionSymbol</code> and fills in the details
later when it sees the definition. Assembly language code labels work almost the same way, as well see
next.</p><h4 class="calibre26">Handling Labels and Forward References</h4><p height="10" width="0" class="calibre5">To jump around an assembly language program, branch instructions use
code label operands.  
A code label is just a symbol that marks a
location in code memory and saves the programmer from having to
manually compute addresses. During execution, though, the interpreter
expects branch operands to be integers, not symbols.</p><p height="10" width="0" class="calibre5">In a sense, the assembler needs to erase labels
during translation to bytecodes by converting label operands to code
addresses. After assembling the program, the assembler can toss out
the scope of labels.  If a branch instruction refers to a label
defined earlier in the program, the assembler can just look it up in
the label scope (Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>). </p><p height="10" width="0" class="calibre5">But, forward references are a bit trickier to handle.  If a label is
not yet defined, we have to remember the branch instruction operand
address. Later, when we see the label definition, we can update that
operand to have the correct value (thats called <em class="calibre6">backpatching</em>).  Lets see how this works by looking at two forward
references in the following assembly program:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br end ; tracks operand code addr 1 in forward ref list</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br end ; adds addr 6 to forward ref list of "end"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">end:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; label address is 10</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At the first <code class="calibre21">br</code> instruction, we create a <code class="calibre21">LabelSymbol</code> and add it
to the label scope.  The operand address is the second byte in code
memory (address 1).  We set flag <code class="calibre21">isForwardRef</code> to true and <code class="calibre21">isDefined</code> to false in the symbol.  We do the same thing at the second
<code class="calibre21">br</code> except that we add address 6 to the list of operands to resolve
later. At the label definition, we resolve forward references by
walking the list of forward references for that symbol to patch <code class="calibre21">br</code>
operands. The disassembly shows the patched forward code labels:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp; BR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;; patched operand points at "end"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0005:&nbsp;&nbsp; BR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;; patched operand points at "end"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0010:&nbsp;&nbsp; HALT&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After reading the entire program, the assembler makes sure that
all forward references have an associated definition.</p><p height="10" width="0" class="calibre5">In summary, an assembler consists of a parser that triggers code
generation and symbol table management actions. All of the work happens
in a subclass of the parser that implements methods such as <tt class="calibre21">gen</tt> and
<tt class="calibre21">defineFunction</tt>. In the next section, well look at a sample
implementation to tease out the remaining details.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">To complete our discussion of bytecode assemblers, lets build an
assembler that we can use for the two bytecode interpreter patterns
that follow. 
We need to build an assembly language grammar in <code class="calibre21">Assembler.g</code>, create a flexible instruction definition mechanism, and
implement the code generation and symbol table management functions in
<code class="calibre21">BytecodeAssembler</code>.</p><p height="10" width="0" class="calibre5">Lets start with the goal: filling in the code memory and
constant pool, which we can represent as fields in our main class:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/BytecodeAssembler.java">interp/asm/BytecodeAssembler.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> BytecodeAssembler <b class="calibre13">extends</b> AssemblerParser {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">final</b> <b class="calibre13">int</b> INITIAL_CODE_SIZE = 1024;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>,<b class="calibre13">Integer</b>&gt; instructionOpcodeMapping =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">String</b>,<b class="calibre13">Integer</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">Map</b>&lt;<b class="calibre13">String</b>, LabelSymbol&gt; labels = <em class="calibre6">// label scope</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> <b class="calibre13">HashMap</b>&lt;<b class="calibre13">String</b>, LabelSymbol&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">/** All float and string literals have unique int index in constant</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;pool. We put FunctionSymbols in here too. */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">List</b>&lt;<b class="calibre13">Object</b>&gt; constPool = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">Object</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">int</b> ip = 0; <em class="calibre6">// Instruction pointer; used to fill code[]</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">byte</b><b class="calibre13">[]</b> code = <b class="calibre13">new</b> <b class="calibre13">byte</b>[INITIAL_CODE_SIZE]; <em class="calibre6">// code memory</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> <b class="calibre13">int</b> dataSize; <em class="calibre6">// set via .globals</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">protected</b> FunctionSymbol mainFunction;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To use the assembler, we create a lexer and parser and then call the
start rule (<code class="calibre21">program</code>) as weve done throughout the book:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">AssemblerLexer assemblerLexer =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;new AssemblerLexer(new ANTLRInputStream(input));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTokenStream tokens = new CommonTokenStream(assemblerLexer);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BytecodeAssembler asm = new BytecodeAssembler(tokens, <em class="calibre6">instructions</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">asm.program(); // start parsing at program rule</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The only difference here is that we create a subclass of <code class="calibre21">AssemblerParser</code> (from <code class="calibre21">Assembler.g</code>) called <code class="calibre21">BytecodeAssembler</code>
that houses our implementation functions.</p><p height="10" width="0" class="calibre5">One of the key rules in the grammar is <code class="calibre21">instr</code>, which recognizes
instructions and calls the code generation methods:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/Assembler.g">interp/asm/Assembler.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">instr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID NEWLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {gen($ID);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID operand NEWLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {gen($ID,$operand.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID a=operand <em class="calibre6">','</em> b=operand NEWLINE {gen($ID,$a.start,$b.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID a=operand <em class="calibre6">','</em> b=operand <em class="calibre6">','</em> c=operand NEWLINE</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{gen($ID,$a.start,$b.start,$c.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It calls the appropriate version of <tt class="calibre21">gen</tt> according to the number of
operands.  Expressions such as <code class="calibre21">$operand.start</code> evaluate to the
starting token matched by rule <code class="calibre21">operand</code>.  Heres the code to
generate an instruction that has no operands:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/BytecodeAssembler.java">interp/asm/BytecodeAssembler.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> <b class="calibre13">void</b> gen(Token instrToken) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> instrName = instrToken.getText();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Integer</b> opcodeI = instructionOpcodeMapping.get(instrName);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( opcodeI==null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.err.println(<em class="calibre6">"line "</em>+instrToken.getLine()+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">": Unknown instruction: "</em>+instrName);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> opcode = opcodeI.intValue();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacity(ip+1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;code[ip++] = (<b class="calibre13">byte</b>)(opcode&amp;0xFF);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The assembler learns about the instruction set from field <code class="calibre21">instructionOpcodeMapping</code>. That dictionary maps instruction names to
integer bytecodes. If you look in the <code class="calibre21">BytecodeDefinition</code> classes
in the interpreter patterns, youll see the instruction
definitions. To get this generic assembler to compile, we can define a
fake set of instruction descriptors:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/BytecodeDefinition.java">interp/asm/BytecodeDefinition.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> Instruction<b class="calibre13">[]</b> instructions = <b class="calibre13">new</b> Instruction<b class="calibre13">[]</b> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;null, <em class="calibre6">// &lt;INVALID&gt;</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> Instruction(<em class="calibre6">"iadd"</em>,REG,REG,REG), <em class="calibre6">// index is the opcode</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This <code class="calibre21">Instruction</code> array is what we pass into the assembler constructor:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BytecodeAssembler asm = new BytecodeAssembler(tokens, <em class="calibre6">instructions</em>);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For instruction operands, the assembler writes 32-bit values to the
code memory using <tt class="calibre21">genOperand</tt> in <code class="calibre21">BytecodeAssembler</code>.  To write
32-bit integers into a byte array, the assembler breaks them up
into bytes using <tt class="calibre21">writeInt</tt>. It writes them highest to lowest byte,
sequentially in memory.</p><p height="10" width="0" class="calibre5">There are two assembly language instructions that dont result in code
memory elements. First is the global memory definition instruction
<code class="calibre21">.globals</code>, which we can recognize with the following rule:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/Assembler.g">interp/asm/Assembler.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">globals : NEWLINE* <em class="calibre6">'.globals'</em> INT NEWLINE {defineDataSize($INT.int);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Second is the function declaration instruction:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/asm/Assembler.g">interp/asm/Assembler.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">functionDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;: <em class="calibre6">'.def'</em> name=ID <em class="calibre6">':'</em> <em class="calibre6">'args'</em> <em class="calibre6">'='</em> a=INT <em class="calibre6">','</em> <em class="calibre6">'locals'</em> <em class="calibre6">'='</em> n=INT NEWLINE</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{defineFunction($name, $a.int, $n.int);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Without an actual instruction set definition, this assembler cant
really do anything. So, well leave building and testing it
to the interpreter patterns that use it.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5"> Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a> and Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a> use this assembler to
read in assembly programs.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_101.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_101.html.tip.stack-bytecode" class="pagebreak2"><small class="calibre35">Pattern 27:</small>&nbsp;&nbsp;&nbsp;Stack-Based Bytecode Interpreter</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern executes bytecode instructions that store
temporary values on an operand stack.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">A stack-based bytecode interpreter simulates a hardware processor with
no general-purpose registers. That means that bytecode instructions
must use an operand stack to hold temporary values.  Temporary
values include arithmetic operands, parameters, and return
values. Because the introductory material for this chapter explained
general bytecode interpreter architecture, we can focus on the details
specific to stack machines.</p><p height="10" width="0" class="calibre5">Lets look at the operand stack first, since its the key
identifying feature. Any time we want to load a value from memory or
compute a result, we push the result onto the operand stack. For
efficiency, well use a simple object array with a special-purpose
register called <em class="calibre6">sp</em> to indicate the top of stack. To
push a value, we increment <em class="calibre6">sp</em> and store the
value:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">operands[++sp] = <em class="calibre6">value</em>;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For example, heres how to push a value from global memory:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">operands[++sp] = globals[<em class="calibre6">address</em>];</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To pop a value, we do the opposite by decrementing <em class="calibre6">sp</em>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Object value = operands[sp--]; // pop, sp-- decrements sp after index</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In Table 7, <a href="#text/part0000_split_101.html.fig.arith-stack-instr"><em class="calibre6">Stack-based arithmetic bytecode instructions</em></a>, and Table 8, <a href="#text/part0000_split_101.html.fig.stack-instr"><em class="calibre6">Stack-based general bytecode instructions</em></a>, we can see a sample instruction set for a stack
machine. (The sample code in the source directory implements this
instruction set.) Just about all of those instructions expect values
on the operand stack.  The instruction set is pretty minimal but good
enough for demonstration purposes. In reality, wed need at least a
few more instructions to handle the other arithmetic operators.
Function calls also make heavy use of the operand stack for parameters
and local variables so we need to investigate them in detail.</p><hr class="calibre17"><div id="text/part0000_split_101.html.fig.arith-stack-instr" class="calibre1"><b class="calibre13">Table 7. Stack-based arithmetic bytecode instructions</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Instruction</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Description</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">iadd</code>, <code class="calibre21">isub</code>, <code class="calibre21">imul</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Arithmetic operators
for integers. Pop two operands, perform operation, and push result
back on stack.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">fadd</code>, <code class="calibre21">fsub</code>, <code class="calibre21">fmul</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Arithmetic operators
for floating-point.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ilt</code>, <code class="calibre21">ieq</code>, <code class="calibre21">flt</code>, <code class="calibre21">feq</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Equality operators
for integers and floating-point. Pop two operands, perform operation, and push result
back on stack.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">itof</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Convert top of stack integer to
floating-point.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">cconst</code>&nbsp;<em class="calibre6">n</em>, <code class="calibre21">iconst</code>&nbsp;<em class="calibre6">n</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Push character or integer constant operand onto the
operand stack. <code class="calibre21">operands[++sp]=</code><em class="calibre6">n</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">sconst</code>&nbsp;<em class="calibre6">s</em>, <code class="calibre21">fconst</code>&nbsp;<em class="calibre6">f</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Push constant string <em class="calibre6">s</em> or floating-point
number <em class="calibre6">f</em> from the constant pool onto the operand stack. <code class="calibre21">operands[++sp]=constPool[</code><em class="calibre6">index-of-s-or-f</em><code class="calibre21">]</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><hr class="calibre17"><div id="text/part0000_split_101.html.fig.stack-instr" class="calibre1"><b class="calibre13">Table 8. Stack-based general bytecode instructions</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Instruction</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Description</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">call</code>&nbsp;<em class="calibre6">f</em><code class="calibre21">()</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Call function <em class="calibre6">f</em>
(via <em class="calibre6">f</em>s constant pool entry). Push new stack frame onto call 
stack, move parameters from operand stack to stack frame, and branch
to function start address.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ret</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Return from function call. Any return
value is on the operand stack. Pop the top stack frame off and return
to return address stored in that stack frame.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">br</code>&nbsp;<em class="calibre6">a</em>, <code class="calibre21">brt</code>&nbsp;<em class="calibre6">a</em>, <code class="calibre21">brf</code>&nbsp;<em class="calibre6">a</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Branch to <em class="calibre6">a</em> always, if <code class="calibre21">operands[sp]</code> is true, or
is false.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">gload</code>&nbsp;<em class="calibre6">a</em>, <code class="calibre21">gstore</code>&nbsp;<em class="calibre6">a</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">operands[++sp]=globals[</code><em class="calibre6">a</em><code class="calibre21">]</code>, <code class="calibre21">globals[</code><em class="calibre6">a</em><code class="calibre21">]=operands[sp--]</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">load</code>&nbsp;<em class="calibre6">i</em>, <code class="calibre21">store</code>&nbsp;<em class="calibre6">i</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">operands[++sp]=calls[fp].locals[</code><em class="calibre6">i</em><code class="calibre21">]</code>  where <code class="calibre21">fp</code> is the frame pointer and <em class="calibre6">i</em> is the local value index, <code class="calibre21">calls[fp].locals[</code><em class="calibre6">i</em><code class="calibre21">]=operands[sp--]</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">fload</code>&nbsp;<em class="calibre6">i</em>,
<code class="calibre21">fstore</code>&nbsp;<em class="calibre6">i</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Pop
<code class="calibre21">struct</code> address <em class="calibre6">s</em> off the
operand stack then do
<code class="calibre21">operands[++sp]=</code><em class="calibre6">s</em><code class="calibre21">.fields[</code><em class="calibre6">i</em><code class="calibre21">]</code>
where <em class="calibre6">i</em> is the field index from 0,
<em class="calibre6">s</em><code class="calibre21">.fields[</code><em class="calibre6">i</em><code class="calibre21">]=operands[sp--]</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">print</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Pop from the operand stack and
print to standard output.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">struct</code>&nbsp;<em class="calibre6">n</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Create a <code class="calibre21">struct</code> with
<em class="calibre6">n</em> fields slots and push it onto the operand stack.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">null</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Push a null pointer onto
the operand stack.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">pop</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Throw away the top of the operand stack.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">halt</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Halt program execution.</p></div></td></tr></tbody></table><hr class="calibre17"><h4 class="calibre26">Passing Function Parameters</h4><p height="10" width="0" class="calibre5">The <code class="calibre21">call</code> instruction expects parameters to be on the operand stack,
which is where we compute all expression values. 
When <code class="calibre21">call</code> pushes a
stack frame, the frame constructor creates space for the parameters
and local variables.  Both parameters and locals go into a single <code class="calibre21">locals</code> object array field, parameters first.  <code class="calibre21">call</code> knows how much
space to create because of the <code class="calibre21">FunctionSymbol</code> in the constant
pool.  Before transferring control to the functions starting
address, <code class="calibre21">call</code> moves the parameters from the operand stack into the
stack frame:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void call(int functionConstPoolIndex) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;FunctionSymbol fs = constPool[functionConstPoolIndex];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StackFrame f = new StackFrame(fs, <em class="calibre6">return-address</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;calls[++fp] = f;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;for (int a=<em class="calibre6">num-args</em>-1; a&gt;=0; a--) f.locals[a]=operands[sp--];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip = fs.address; // jump to the start address</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets see how this works when we call a function with two parameters
and one local variable:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; print f(10,20)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iconst 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; push first argument</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iconst 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; push second argument</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call f()&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; print return value</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def f: args=2, locals=1&nbsp;&nbsp;&nbsp;&nbsp;; int f(int x, int y)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; x is at locals[] index 0, y at 1, and z at 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; int z = x + y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;load 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; push first argument x</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;load 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; push second argument y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;store 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; store into local z</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; return z&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;load 2&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">In the graphic below, we can see the stack frame zoomed in for the call to
<tt class="calibre21">f</tt> from <tt class="calibre21">main</tt>. The call needs three slots to hold parameters and
locals. Parameters come first and locals come next, so the local variables
index is 2.</p><div class="calibre1"><img id="text/part0000_split_101.html.d24e31495" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/call-stack-locals.png"></div><p height="10" width="0" class="calibre5">The trace shows that, right before the call to
<tt class="calibre21">f</tt>, the operand stack has two parameters:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0010:&nbsp;&nbsp; CALL&nbsp;&nbsp;&nbsp;&nbsp; #0 ; f()@17&nbsp;&nbsp; stack=[ 10 20 ]&nbsp;&nbsp; calls=[ main ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0017:&nbsp;&nbsp; LOAD&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=[ ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calls=[ main f ]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">After the <code class="calibre21">call</code>, the parameters are in the stack frames <code class="calibre21">locals</code>
space, not the operand stack.  The function can manipulate locals and
parameters with <code class="calibre21">load</code> and <code class="calibre21">store</code>.  <code class="calibre21">load</code>, for example, pulls a
value from the <code class="calibre21">locals</code> field and pushes it onto the operand stack:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">operands[++sp] = calls[fp].locals[<em class="calibre6">address-operand</em>];</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">When the function is done, it executes a <code class="calibre21">ret</code> instruction to
return. <code class="calibre21">ret</code> doesnt have to clean up the stack because <code class="calibre21">call</code>
removes parameters at the start of the function. It only has to pop a
stack frame off the call stack and jump to the return address found
in that frame:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StackFrame fr = calls[fp--];&nbsp;&nbsp;&nbsp;&nbsp;// pop stack frame</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ip = fr.returnAddress;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// branch to ret addr</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To return a value, a function pushes a value onto the operand stack
and then executes the <code class="calibre21">ret</code> instruction.
</p><h4 class="calibre26">Returning Function Values</h4><p height="10" width="0" class="calibre5">After executing a function call, the calling code expects any return
value to be on the operand stack.  
Heres a trace until after the
call to <tt class="calibre21">f</tt>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0033:&nbsp;&nbsp; LOAD&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=[ ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calls=[ main f ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0038:&nbsp;&nbsp; RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[ 30 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls=[ main f ]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0015:&nbsp;&nbsp; PRINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack=[ 30 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls=[ main ]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">ret</code> instructions pops the stack frame for <tt class="calibre21">f</tt> off the call
stack and jumps to the return address (15) in <tt class="calibre21">main</tt>. </p><p height="10" width="0" class="calibre5">If a function returns a value that the calling code does not use, the
calling code must pop that value off the operand stack anyway. For
example, the following program throws away the value returned
from <tt class="calibre21">f</tt>. 
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call f()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; assume f() has return value</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; drop top of stack</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now that we know how to use the operand stack, its time to look at
the implementation details for a stack-based interpreter.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">The bulk of our bytecode interpreter lives in <code class="calibre21">Interpreter</code>. 
Other than that, well need a few support classes: <code class="calibre21">StackFrame</code>, <code class="calibre21">BytecodeDefinition</code>, and <code class="calibre21">StructSpace</code> (holds the fields of a <code class="calibre21">struct</code>). Well use Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a> to assemble programs before
execution. (<code class="calibre21">BytecodeDefinition</code> defines the instruction set.) The
assembler pattern also provides a suitable <code class="calibre21">FunctionSymbol</code> that
well need for our constant pool.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">Interpreter</code> contains the processor (in <tt class="calibre21">cpu</tt>) that we
discussed in the introductory material and the fields that represent
our simulated memory, stacks, and special-purpose registers:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> ip;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// instruction pointer register</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">byte</b><b class="calibre13">[]</b> code;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// byte-addressable code memory.</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> codeSize;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Object</b><b class="calibre13">[]</b> globals;&nbsp;&nbsp; <em class="calibre6">// global variable space</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> <b class="calibre13">Object</b><b class="calibre13">[]</b> constPool;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Operand stack, grows upwards */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Object</b><b class="calibre13">[]</b> operands = <b class="calibre13">new</b> <b class="calibre13">Object</b>[DEFAULT_OPERAND_STACK_SIZE];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> sp = -1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// stack pointer register</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Stack of stack frames, grows upwards */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StackFrame<b class="calibre13">[]</b> calls = <b class="calibre13">new</b> StackFrame[DEFAULT_CALL_STACK_SIZE];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> fp = -1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// frame pointer register</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">FunctionSymbol mainFunction;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <tt class="calibre21">main</tt> method creates an <code class="calibre21">Interpreter</code> object, loads and
assembles the bytecode program, and then executes starting at the
<code class="calibre21">main</code> function:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Interpreter interpreter = <b class="calibre13">new</b> Interpreter();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">load(interpreter, input);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interpreter.trace = trace;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interpreter.exec();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( disassemble ) interpreter.disassemble();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( dump) interpreter.coredump();</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Loading and assembling the input program is a matter of creating
an assembler and calling the <code class="calibre21">program</code> rule. After it returns, we can
ask the assembler for the code memory and any other goodies we need:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">AssemblerLexer assemblerLexer =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> AssemblerLexer(<b class="calibre13">new</b> ANTLRInputStream(input));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTokenStream tokens = <b class="calibre13">new</b> CommonTokenStream(assemblerLexer);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BytecodeAssembler assembler =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> BytecodeAssembler(tokens, BytecodeDefinition.instructions);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assembler.program();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.code = assembler.getMachineCode();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.codeSize = assembler.getCodeMemorySize();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.constPool = assembler.getConstantPool();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.mainFunction = assembler.getMainFunction();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.globals = <b class="calibre13">new</b> <b class="calibre13">Object</b>[assembler.getDataSize()];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">interp.disasm = <b class="calibre13">new</b> DisAssembler(interp.code,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interp.codeSize,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interp.constPool);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To begin execution, the interpreter calls the bytecode
programs <code class="calibre21">main</code> method and invokes <tt class="calibre21">cpu</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> exec() <b class="calibre13">throws</b> Exception {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// SIMULATE "call main()"; set up stack as if we'd called main()</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( mainFunction==null ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainFunction = <b class="calibre13">new</b> FunctionSymbol(<em class="calibre6">"main"</em>, 0, 0, 0);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StackFrame f = <b class="calibre13">new</b> StackFrame(mainFunction, -1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;calls[++fp] = f;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip = mainFunction.address;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;cpu();&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, lets start looking at some instructions. (Interestingly, the
fragments look very much like the code wed write in a hardware
description language such as Verilog.)<a id="text/part0000_split_101.html.FNPTR-37" href="#text/part0000_split_103.html.FOOTNOTE-37">[37]</a> Heres the implementation of
the integer add instruction (a <code class="calibre21">case</code> of the <code class="calibre21">switch</code> in <tt class="calibre21">cpu</tt>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">case</b> BytecodeDefinition.INSTR_IADD :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;a = (<b class="calibre13">Integer</b>)operands[sp-1]; <em class="calibre6">// 1st opnd 1 below top</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;b = (<b class="calibre13">Integer</b>)operands[sp];&nbsp;&nbsp; <em class="calibre6">// 2nd opnd at top of stack</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;sp -= 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// pop both operands</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;operands[++sp] = a + b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// push result</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The floating-point version is the same except that we treat the top two
operands on the stack as floats:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">case</b> BytecodeDefinition.INSTR_FADD :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;e = (<b class="calibre13">Float</b>)operands[sp-1];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;f = (<b class="calibre13">Float</b>)operands[sp];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;sp -= 2;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;operands[++sp] = e + f;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">call</code> instructions operand is an index
into the constant pool for the target function. It calls support
method <tt class="calibre21">getIntOperand</tt> to pull a 4-byte integer
out of the code memory at location <em class="calibre6">ip</em> and then
delegates functionality to the <tt class="calibre21">call</tt> method
we saw earlier in this pattern:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/Interpreter.java">interp/stack/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">case</b> BytecodeDefinition.INSTR_CALL :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> funcIndexInConstPool = getIntOperand();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call(funcIndexInConstPool);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> <code class="calibre21">call</code> pushes a stack frame that holds the return address and space for
parameters and locals (in a single field, <code class="calibre21">locals</code>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/StackFrame.java">interp/stack/StackFrame.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> StackFrame {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;FunctionSymbol sym; <em class="calibre6">// associated with which function?</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> returnAddress;&nbsp;&nbsp;<em class="calibre6">// the instruction following the call</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b><b class="calibre13">[]</b> locals;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// holds parameters and local variables</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> StackFrame(FunctionSymbol sym, <b class="calibre13">int</b> returnAddress) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sym = sym;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.returnAddress = returnAddress;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locals = <b class="calibre13">new</b> <b class="calibre13">Object</b>[sym.nargs+sym.nlocals];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, that should give you a taste of the relevant implementation
details. Lets get this to build.  All weve got to do is run ANTLR on
the assembler grammar file and compile the Java code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Assembler.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets try this on an sample program that stores a value into
two global variables and prints one of them:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/stack/t.pcode">interp/stack/t.pcode</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; int x,y&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.globals 2&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; x = 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iconst 9</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gstore 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; y = x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gload 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gstore 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; print y&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gload 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To run <code class="calibre21">t.pcode</code> into <code class="calibre21">Interpreter</code> and dump out all the
relevant memory spaces, we can use option <code class="calibre21">-dump</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Interpreter -dump t.pcode</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Constant pool:</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000: FunctionSymbol{name='main', args=0, locals=0, address=0}</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Data memory:&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000: 9 &lt;Integer&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0001: 9 &lt;Integer&gt;</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Code memory:&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000:&nbsp;&nbsp;18&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 9&nbsp;&nbsp;25&nbsp;&nbsp; 0&nbsp;&nbsp; 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0008:&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;22&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp;25</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0016:&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp;22&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0024:&nbsp;&nbsp; 1&nbsp;&nbsp;27&nbsp;&nbsp;31</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Looking at the code memory, only 7 out of the 27 bytes are
bytecodesthe rest are operands. The first step in making this
pattern more efficient would be to create a denser instruction set
(loading and decoding those operands repeatedly gets expensive).  For
example, we could define instructions that used 2-byte operands
instead of 4-byte operands (or even 1-byte operands). Most of the
time, addresses and constants fit in one or two bytes.</p><p height="10" width="0" class="calibre5">The biggest speed impediment for a stack-based interpreter, though, is
the extra work involved in constantly flogging the operand
stack. In the next pattern, well look at a bytecode interpreter that
avoids a lot of unnecessary traffic to and from memory by using
registers.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern reuses Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a> and is much like Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_102.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_102.html.tip.reg-bytecode" class="pagebreak2"><small class="calibre35">Pattern 28:</small>&nbsp;&nbsp;&nbsp;Register-Based Bytecode Interpreter</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern executes bytecode instructions that store
function parameters, local variables, and temporary values in
simulated registers.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">A register-based bytecode interpreter is identical to a stack-based
interpreter except for the instruction set and where it keeps local
variables, parameters, return values, and any temporary values.  The
instructions use registers instead of an operand stack. Our simulated
machine gives each stack frame an infinite set of
registers.</p><hr class="calibre17"><div id="text/part0000_split_102.html.fig.arith-reg-instr" class="calibre1"><b class="calibre13">Table 9. Register-based arithmetic bytecode instructions</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Instruction</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Description</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">iadd</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub>
        <br class="calibre1"><code class="calibre21">isub</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub>
        <br class="calibre1"><code class="calibre21">imul</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Arithmetic operators for integers. <em class="calibre6">r</em><sub class="calibre48">k</sub>=<em class="calibre6">r</em><sub class="calibre48">i</sub>&nbsp;<em class="calibre6">op</em>&nbsp;<em class="calibre6">r</em><sub class="calibre48">j</sub></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">fadd</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub> 
        <br class="calibre1"><code class="calibre21">fsub</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub> 
        <br class="calibre1"><code class="calibre21">fmul</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Arithmetic operators for floating-point numbers. <em class="calibre6">r</em><sub class="calibre48">k</sub>=<em class="calibre6">r</em><sub class="calibre48">i</sub>&nbsp;<em class="calibre6">op</em>&nbsp;<em class="calibre6">r</em><sub class="calibre48">j</sub></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ilt</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub>
        <br class="calibre1"><code class="calibre21">ieq</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub>
        <br class="calibre1"><code class="calibre21">flt</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub>
        <br class="calibre1"><code class="calibre21">feq</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">r</em><sub class="calibre48">k</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Equality operators 
            for integers and floating-point: less-than and equal. Save boolean
            result in <em class="calibre6">r</em><sub class="calibre48">k</sub>. <em class="calibre6">r</em><sub class="calibre48">k</sub>=<em class="calibre6">r</em><sub class="calibre48">i</sub>&nbsp;<em class="calibre6">op</em>&nbsp;<em class="calibre6">r</em><sub class="calibre48">j</sub></p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">itof</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Convert integer in <em class="calibre6">r</em><sub class="calibre48">i</sub> to
          floating-point and save in <em class="calibre6">r</em><sub class="calibre48">j</sub>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">cconst</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">c</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Load character into <em class="calibre6">r</em><sub class="calibre48">i</sub>. <em class="calibre6">r</em><sub class="calibre48">i</sub>=<em class="calibre6">c</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">iconst</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">n</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Load integer into <em class="calibre6">r</em><sub class="calibre48">i</sub>. <em class="calibre6">r</em><sub class="calibre48">i</sub>=<em class="calibre6">n</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">sconst</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">s</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Load string into <em class="calibre6">r</em><sub class="calibre48">i</sub>. <em class="calibre6">r</em><sub class="calibre48">i</sub>=<code class="calibre21">constPool[</code><em class="calibre6">index-of-s</em><code class="calibre21">]</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">fconst</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">f</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Load floating-point value into <em class="calibre6">r</em><sub class="calibre48">i</sub>. <em class="calibre6">r</em><sub class="calibre48">i</sub>=<code class="calibre21">constPool[</code><em class="calibre6">index-of-f</em><code class="calibre21">]</code>.</p></div></td></tr></tbody></table><hr class="calibre17"><p height="10" width="0" class="calibre5">Lets reserve the first element of the register array to hold return
 values. (This is just one possible strategy.) The parameters and locals are then at index 1 and greater:</p><div class="calibre1"><img id="text/part0000_split_102.html.d24e32601" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/register-file.png"></div><p height="10" width="0" class="calibre5">That image shows the registers for a function definition with
<em class="calibre6">p</em> parameters and <em class="calibre6">t</em> locals and temporaries (<em class="calibre6">n=1+p+t</em>):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def foo: args=p, locals=t</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As you can see in the sample instruction set for this pattern (Table 9, <a href="#text/part0000_split_102.html.fig.arith-reg-instr"><em class="calibre6">Register-based arithmetic bytecode instructions</em></a>, and see Table 10, <a href="#text/part0000_split_102.html.fig.reg-instr"><em class="calibre6">Register-based general bytecode instructions</em></a>), all the instructions manipulate
registers. (The sample code in the source directory implements this
instruction set.)  To get the ball rolling, well look at how basic
instructions and data aggregate instructions use registers. Then,
well explore function calls in detail. Its important to understand
exactly how the <code class="calibre21">call</code> and <code class="calibre21">ret</code> instructions shuffle registers around
between stack frames on the call stack. Otherwise, youll find it hard
to read the sample implementation.</p><hr class="calibre17"><div id="text/part0000_split_102.html.fig.reg-instr" class="calibre1"><b class="calibre13">Table 10. Register-based general bytecode instructions</b></div><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Instruction</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Description</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">call</code>&nbsp;<em class="calibre6">f</em><code class="calibre21">()</code>, <em class="calibre6">r</em><sub class="calibre48">i</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Call function <em class="calibre6">f</em> (via <em class="calibre6">f</em>s constant
        pool entry). For <em class="calibre6">n</em> parameters, registers <em class="calibre6">r</em><sub class="calibre48">i</sub>..<em class="calibre6">r</em><sub class="calibre48">i+n-1</sub>
        contain the parameter values.  Use <em class="calibre6">r</em><sub class="calibre48">0</sub>
        if there are no parameters. Push new stack frame onto call stack, and
        move parameters from previous stack frame to this stack frame. Branch
        to function start address.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">ret</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Return from function call. Any return
        value is in <em class="calibre6">r</em><sub class="calibre48">0</sub>. Pop the top stack
        frame off, and return to the return address stored in that stack frame.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">br</code>&nbsp;<em class="calibre6">a</em>
        <br class="calibre1"><code class="calibre21">brt</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">a</em>
        <br class="calibre1"><code class="calibre21">brf</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>,
        <em class="calibre6">a</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Branch to <em class="calibre6">a</em> always, if <em class="calibre6">r</em><sub class="calibre48">i</sub> is true, or <em class="calibre6">r</em><sub class="calibre48">i</sub> is false.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">gload</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">a</em>
        <br class="calibre1"><code class="calibre21">gstore</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">a</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">r</em><sub class="calibre48">i</sub>=<code class="calibre21">globals[</code><em class="calibre6">a</em><code class="calibre21">]</code> and <code class="calibre21">globals[</code><em class="calibre6">a</em><code class="calibre21">]</code>=<em class="calibre6">r</em><sub class="calibre48">i</sub>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">fload</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">n</em>
        <br class="calibre1"><code class="calibre21">fstore</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub>, <em class="calibre6">n</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">r</em><sub class="calibre48">i</sub>=<em class="calibre6">r</em><sub class="calibre48">j</sub><code class="calibre21">[</code><em class="calibre6">n</em><code class="calibre21">]</code> and <em class="calibre6">r</em><sub class="calibre48">j</sub><code class="calibre21">[</code><em class="calibre6">n</em><code class="calibre21">]</code>=<em class="calibre6">r</em><sub class="calibre48">i</sub>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">move</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">r</em><sub class="calibre48">j</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">r</em><sub class="calibre48">j</sub>=<em class="calibre6">r</em><sub class="calibre48">i</sub>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">print</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Print <em class="calibre6">r</em><sub class="calibre48">i</sub>
        to standard output.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">struct</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub>, <em class="calibre6">n</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">r</em><sub class="calibre48">i</sub>=new <code class="calibre21">struct</code> with
        <em class="calibre6">n</em> field slots.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">null</code>&nbsp;<em class="calibre6">r</em><sub class="calibre48">i</sub></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">r</em><sub class="calibre48">i</sub>=<code class="calibre21">null</code>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">halt</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Halt program execution.</p></div></td></tr></tbody></table><hr class="calibre17"><h4 class="calibre26">Implementing Basic Instructions</h4><p height="10" width="0" class="calibre5">To access a register, an instruction has to know where the current
registers are. 
The current registers are in the stack frame on the top
of the call stack, <code class="calibre21">calls[fp]</code>. So, we can define a shortcut to the
current registers like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Object r[] = calls[fp].registers; // shorthand for "current registers"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, instructions like <code class="calibre21">iconst</code> (integer load) can save values into
the <code class="calibre21">r</code> shortcut array (this code snippet lives in our fetch execute
loop <tt class="calibre21">cpu</tt>):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BytecodeDefinition.INSTR_ICONST : // E.g., iconst r1, 99</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i = <em class="calibre6">get-register-number-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;v = <em class="calibre6">get-integer-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;r[i] = v;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Once we pull the register number and integer value operands from the
code memory, the <code class="calibre21">iconst</code> instruction stores the value into the
appropriate register. </p><p height="10" width="0" class="calibre5">The <code class="calibre21">iadd</code> integer add mechanism is pretty similar. Once we know the
three register numbers, we can access their values, cast them to
integers, perform the operation, and store the result in a register:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BytecodeDefinition.INSTR_IADD : // E.g., iadd r1, r2, r3</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i = <em class="calibre6">get-register-number-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;j = <em class="calibre6">get-register-number-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;k = <em class="calibre6">get-register-number-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;r[k] = r[i] + r[j];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, now that we know how to access registers, lets look at accessing
the fields of a data aggregate.
</p><h4 class="calibre26">Creating and Accessing Data Aggregates</h4><p height="10" width="0" class="calibre5">To create a data aggregate, the <code class="calibre21">struct</code> instruction needs a target
register and how many fields to create:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BytecodeDefinition.INSTR_STRUCT :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i = <em class="calibre6">get-register-number-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;int nfields = <em class="calibre6">get-integer-operand</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;r[i] = new StructSpace(nfields); // save struct in r[i]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">A <code class="calibre21">StructSpace</code> object has a <code class="calibre21">fields</code> array that we can access
with the <code class="calibre21">fload</code> and <code class="calibre21">fstore</code> instructions. Both instructions
take two register operands and one integer operand. The first register
is the target of the load or the value to write. The second register
is the base address of the data aggregate. The integer is the field
index. For example, here is the mechanism for loading a field:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BytecodeDefinition.INSTR_FLOAD :&nbsp;&nbsp; // E.g., fload r1, r2, 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;i = <em class="calibre6">get-register-number-operand</em>;&nbsp;&nbsp;// r[i] is target register</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;j = <em class="calibre6">get-register-number-operand</em>;&nbsp;&nbsp;// r[j] is the struct</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fieldIndex = <em class="calibre6">get-integer-operand</em>; // which field?</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;r[i] = r[j].fields[fieldIndex];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">All the instructions weve seen so far only deal  with the registers
in a single stack frame. To perform a function call, though, we have
to copy registers between frames (since all nonglobal variables and
all temporary values live in registers).
</p><h4 class="calibre26">Passing Data During Function Calls</h4><p height="10" width="0" class="calibre5">The mechanism for passing parameters to functions and returning values
is a bit tricky.  
Lets see how it works by looking at the
relationship between a sample program and its call stack.  Take a look
at the flow of control in the following program. It goes from <tt class="calibre21">main</tt>
to <tt class="calibre21">f</tt> to <tt class="calibre21">g</tt>.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=1 ; void main() { print f(10); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iconst r1, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; put 10 into r1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call f(), r1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; call f, argument is in r1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;print r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print return value</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def f: args=1, locals=3&nbsp;&nbsp;&nbsp;&nbsp;; int f(int x) { return g(2*x, 30); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iconst r2,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get int 2 into 1st non-arg register</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;imul r1,r2,r3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; mult arg by 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iconst r4,30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; get int 30 into a reg</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;call g(), r3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; leave result in r0; args=[r3,r4]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return value in r0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def g: args=2, locals=0&nbsp;&nbsp;&nbsp;&nbsp;; int g(int x, int y) { return x+y; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;iadd r1, r2, r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return x+y</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; return value in r0</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> In Figure 30, <a href="#text/part0000_split_102.html.fig.reg-call-stack"><em class="calibre6">Register transfers and state of call stack at ret in g</em></a>, we can see the state of the call stack at the <code class="calibre21">ret</code>
instruction in <tt class="calibre21">g</tt>. If we ignore the registers, it looks like the
general stack frame shown in the introductory material (see Figure 29, <a href="#text/part0000_split_098.html.fig.call-stack"><em class="calibre6">Function call stack right before ret in g</em></a>). The first stack frame on the call stack is for the
simulated call to <tt class="calibre21">main</tt> from the interpreter.  The next stack frame
is for the call to <tt class="calibre21">f</tt>. The top of the call stack is the stack frame
for the call to <tt class="calibre21">g</tt>.</p><div class="calibre1" id="text/part0000_split_102.html.fig.reg-call-stack"><img id="text/part0000_split_102.html.d24e33219" class="calibre2" src="data:image/gif;base64,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" alt="images/interp/reg-call-stack.png"><hr class="calibre17"><b class="calibre13">Figure 29. Register transfers and state of call stack at <code class="calibre21">ret</code> in <tt class="calibre21">g</tt></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">The dashed arrows indicate register copying. The downward arrows
indicate parameter passing, and the upward arrows indicate values
returning to the invoking function.  The call to <tt class="calibre21">f</tt> has one
parameter, which is stored in <code class="calibre21">r[1]</code> (courtesy of <tt class="calibre21">main</tt>s first
<code class="calibre21">iconst</code> instruction). The <code class="calibre21">call</code> to <tt class="calibre21">f</tt> copies <code class="calibre21">r[1]</code> in <tt class="calibre21">main</tt>s
stack frame to <code class="calibre21">r[1]</code> in <tt class="calibre21">f</tt>s stack frame. The <code class="calibre21">r[1]</code> in <tt class="calibre21">main</tt>s
stack frame is a temporary value (since it has no parameters), whereas
<code class="calibre21">r[1]</code> is a parameter in <tt class="calibre21">f</tt>s stack frame.</p><p height="10" width="0" class="calibre5">The execution trace illustrates how the registers for the various
stack frames change over time (the <code class="calibre21">|</code> character separates <code class="calibre21">r[0]</code> from
the parameters and the parameters from the locals in the register
array):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0000: ICONST&nbsp;&nbsp;r1, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.registers=[?||?]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calls=[main]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0009: CALL&nbsp;&nbsp;&nbsp;&nbsp;#1:f(), r1&nbsp;&nbsp;main.registers=[?||10]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls=[main]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0024: ICONST&nbsp;&nbsp;r2, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.registers=[?|10|? ? ?]&nbsp;&nbsp;&nbsp;&nbsp;calls=[main f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0033: IMUL&nbsp;&nbsp;&nbsp;&nbsp;r1, r2, r3&nbsp;&nbsp;f.registers=[?|10|2 ? ?]&nbsp;&nbsp;&nbsp;&nbsp;calls=[main f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0046: ICONST&nbsp;&nbsp;r4, 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.registers=[?|10|2 20 ?]&nbsp;&nbsp; calls=[main f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0055: CALL&nbsp;&nbsp;&nbsp;&nbsp;#2:g(), r3&nbsp;&nbsp;f.registers=[?|10|2 20 30]&nbsp;&nbsp;calls=[main f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0065: IADD&nbsp;&nbsp;&nbsp;&nbsp;r1, r2, r0&nbsp;&nbsp;g.registers=[?|20 30]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calls=[main f g]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0078: RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.registers=[50|20 30]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls=[main f g]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0064: RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.registers=[50|10|2 20 30] calls=[main f]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">0018: PRINT&nbsp;&nbsp;r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main.registers=[50||10]&nbsp;&nbsp;&nbsp;&nbsp; calls=[main]</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As <tt class="calibre21">g</tt> hits the <code class="calibre21">ret</code> at code address 78, it moves its <code class="calibre21">r[0]</code>, <code class="calibre21">50</code>,
to <tt class="calibre21">f</tt>s <code class="calibre21">r[0]</code>.  When the call to <tt class="calibre21">f</tt> returns, it moves <code class="calibre21">r[0]</code> to
<tt class="calibre21">main</tt>s <code class="calibre21">r[0]</code>. The <code class="calibre21">print</code> instruction in <tt class="calibre21">main</tt> can then print
out its <code class="calibre21">r[0]</code>.</p><p height="10" width="0" class="calibre5">The operands of the <code class="calibre21">call</code> instruction are a little weird, so its
worth exploring them in more detail. Once weve done that, well be
ready to look at our sample implementation.
</p><h4 class="calibre26">Decoding the  call  Instruction Operands</h4><p height="10" width="0" class="calibre5">The <code class="calibre21">call</code> instruction knows how many parameters to pass because its
first operand refers to a <code class="calibre21">FunctionSymbol</code> sitting in the constant pool. 
The second operand is a register number and tells the
instruction where the parameters are. That register number indicates
which register holds the first parameter.  Any other parameters live
in the next contiguous registers. An operand of <code class="calibre21">r0</code> indicates there
are no parameters.</p><p height="10" width="0" class="calibre5">Since <tt class="calibre21">f</tt> has one parameter, the <code class="calibre21">call</code> in <tt class="calibre21">main</tt> knows to copy just
<code class="calibre21">r[1]</code> to the parameter register in the stack frame it creates. <tt class="calibre21">g</tt>
takes two parameters that live that <code class="calibre21">r[1]</code> and <code class="calibre21">r[2]</code> in its stack
frame. <tt class="calibre21">f</tt> computes the first parameter to <tt class="calibre21">g</tt> in <code class="calibre21">r[3]</code> and the
second in <code class="calibre21">r[4]</code>. Thats why, in Figure 30, <a href="#text/part0000_split_102.html.fig.reg-call-stack"><em class="calibre6">Register transfers and state of call stack at ret in g</em></a>, we see interframe
dashed lines from <code class="calibre21">r[3]</code> to <code class="calibre21">r[1]</code> and from <code class="calibre21">r[4]</code> to <code class="calibre21">r[2]</code>. The
following algorithm fills in the rest of the details for the <code class="calibre21">call</code>
instruction:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void call(int functionConstPoolIndex, int baseRegisterIndex) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;FunctionSymbol fs = constPool[functionConstPoolIndex];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StackFrame f = new StackFrame(fs, <em class="calibre6">return-address</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StackFrame callingFrame = calls[fp];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;calls[++fp] = f; // push new stack frame</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;// copy arguments from calling stack frame to new stack frame</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;for (int a=0; a&lt;<em class="calibre6">num-args</em>; a++) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.registers[a+1] = callingFrame.registers[baseRegisterIndex+a];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip = fs.address; // jump to the start address</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The details of the <code class="calibre21">ret</code> instruction are much simpler. <code class="calibre21">ret</code> just
copies <code class="calibre21">r[0]</code> of the current frame to <code class="calibre21">r[0]</code> in the calling frame and
pops off the current stack frame:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">case BytecodeDefinition.INSTR_RET :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StackFrame f = calls[fp--]; // pop stack frame</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;calls[fp].registers[0] = f.registers[0]; // copy r0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ip = f.returnAddress;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // jump back to calling instruction</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At this point, weve hit the highlights of how to implement register
machine instructions. In the next section, well take a quick peek at
a sample implementation.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Register machines are nearly identical to stack machines.  
In fact,
the implementation for this pattern differs from Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>
in only two spots. First, the <code class="calibre21">locals</code> field in <code class="calibre21">StackFrame</code> is now
called <code class="calibre21">registers</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/reg/StackFrame.java">interp/reg/StackFrame.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Allocate space for registers; 1 extra for r0 reserved reg</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">registers = <b class="calibre13">new</b> <b class="calibre13">Object</b>[sym.nargs+sym.nlocals+1];</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Second, the <code class="calibre21">switch</code> statement inside <tt class="calibre21">cpu</tt> has implementations for the
register-based instructions rather than stack-based instructions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/reg/Interpreter.java">interp/reg/Interpreter.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> <b class="calibre13">void</b> cpu() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">int</b> i=0, j=0, k=0, addr=0, fieldIndex=0;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">short</b> opcode = code[ip];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> (opcode!= BytecodeDefinition.INSTR_HALT &amp;&amp; ip &lt; codeSize) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( trace ) trace();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip++; <em class="calibre6">//jump to next instruction or first byte of operand</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b> r<b class="calibre13">[]</b> = calls[fp].registers; <em class="calibre6">// shortcut to current registers</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">switch</b> (opcode) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">case</b> BytecodeDefinition.INSTR_IADD :</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = getRegOperand();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = getRegOperand();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = getRegOperand();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r[k] = ((<b class="calibre13">Integer</b>)r[i])+((<b class="calibre13">Integer</b>)r[j]);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">break</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// ...</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Although the instruction sets for the stack-based and register-based
machines look very different, were able to reuse Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a>
verbatim for both. For example, heres a sample register-based
assembly program the assembler readily translates to bytecodes:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/interp/reg/t.rcode">interp/reg/t.rcode</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; int x,y&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.globals 2&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.def main: args=0, locals=3</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; x = 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iconst r1, 9</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gstore r1, 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; y = x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gload r2, 0</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gstore r2, 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">; print y&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gload r3, 1</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print r3</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halt&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To build and execute that file, we run ANTLR on the assembler grammar
file, compile all the Java code, and run <code class="calibre21">t.rcode</code> into <code class="calibre21">Interpreter</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Assembler.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Interpreter t.rcode</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This implementation isnt the fastest in town (compared to
Suns Java VM in pure interpreter mode, <code class="calibre21">-Xint</code>). My design goals
for this book were simplicity and readability rather than bytecode
execution speed and memory efficiency.  That said, it wouldnt be that
hard to get this interpreter to perform within a factor of two or
three of Suns interpreter.  Basically, we just need to introduce a few dense
instructions for common operations. For example, pushing zero on the
stack is extremely common; we can represent that with a single-byte
<code class="calibre21">iload0</code> instruction instead of the general <code class="calibre21">iload</code> instruction that
takes 5 bytes (including the 4-byte operand).
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern uses Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a> to read in bytecode assembly
language programs.  The source code for this pattern is remarkably
similar to that of Pattern 27, <a href="#text/part0000_split_101.html.tip.stack-bytecode"><em class="calibre6">Stack-Based Bytecode Interpreter</em></a>.
</p>

</div></div>
<div id="text/part0000_split_103.html"><div class="calibre">

<h2 id="text/part0000_split_103.html.d24e33745" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">Building an interpreter is one way to implement a language, but we
can also build a translator from the new language to an existing
language. In the next chapter, were going to look at code generation,
the final stage of a source-to-source translator.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-29" href="#text/part0000_split_095.html.FNPTR-29">[29]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">These machines are to
be distinguished from the virtual machines that run one operating
system inside another.</p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-30" href="#text/part0000_split_095.html.FNPTR-30">[30]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://en.wikipedia.org/wiki/UCSD_Pascal">http://en.wikipedia.org/wiki/UCSD_Pascal</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-31" href="#text/part0000_split_095.html.FNPTR-31">[31]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/ANTLR3/LLVM">http://www.antlr.org/wiki/display/ANTLR3/LLVM</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-32" href="#text/part0000_split_096.html.FNPTR-32">[32]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.tecgraf.puc-rio.br/~lhf/ftp/doc/jucs05.pdf">http://www.tecgraf.puc-rio.br/~lhf/ftp/doc/jucs05.pdf</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-33" href="#text/part0000_split_096.html.FNPTR-33">[33]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://source.android.com">http://source.android.com</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-34" href="#text/part0000_split_096.html.FNPTR-34">[34]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://h41111.www4.hp.com/calculators/uk/en/articles/rpn.html">http://h41111.www4.hp.com/calculators/uk/en/articles/rpn.html</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-35" href="#text/part0000_split_099.html.FNPTR-35">[35]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://source.android.com">http://source.android.com</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-36" href="#text/part0000_split_099.html.FNPTR-36">[36]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.arm.com">http://www.arm.com</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_103.html.FOOTNOTE-37" href="#text/part0000_split_101.html.FNPTR-37">[37]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://en.wikipedia.org/wiki/Verilog">http://en.wikipedia.org/wiki/Verilog</a></p></dd></dl><div class="calibre3" id="text/part0000_split_103.html.calibre_pb_133"></div>

</div></div>
<div id="text/part0000_split_104.html"><div class="calibre">

<div id="text/part0000_split_104.html.toc-18" style="height:0pt"></div><h1 class="part-title" id="text/part0000_split_104.html.d24e33757"><span class="calibre14">Part 4</span><br class="calibre4"><span class="calibre14">Translating and Generating Languages</span></h1><div class="calibre3" id="text/part0000_split_104.html.calibre_pb_137"></div>

</div></div>
<div id="text/part0000_split_105.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_105.html.calibre_pb_138">&nbsp;</p><a id="text/part0000_split_105.html.toc-19"></a><h4 class="right2" id="text/part0000_split_105.html.chp.trans">Chapter 11</h4>
</div></div>
<div id="text/part0000_split_106.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_106.html.calibre_pb_139">Translating Computer Languages</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">So far, weve focused on reading in programs and other structured
text in this book. Previously, we built input
models (usually ASTs) of the input and then analyzed or even executed
that input by scanning the model.  In this next part of the book,
were going to reverse the process and build text-to-text translators
and generators that emit structured text. Translators let us implement
new DSLs and programming languages quickly by translating them to
existing languages. For example, the first C++ implementation
(<code class="calibre21">cfront</code>) translated C++ to C. Translators are
also heavily used for migrating legacy code and data formats.

</p><p height="10" width="0" class="calibre5">A translator is a program that maps input constructs to output
constructs. Sometimes we can do this purely with syntax. For example,
translating a scalar multiply like <code class="calibre21">a x b</code> in a
mathematics DSL to <code class="calibre21">a*b</code> in Java doesnt
require semantic information.  If that DSL has matrices (2D arrays),
though, we need to alter the translation based on type
information. For example, to translate matrix multiply <code class="calibre21">A x
B</code>, we need to generate a nested <code class="calibre21">for</code> loop in
Java. Things can get really tricky when we need lots of semantic
information spread across an entire project. For example, doing a
static field move from one class to another forces a refactoring
engine to find all uses of it.</p><p height="10" width="0" class="calibre5">Translators vary in difficulty depending on a number of factors
including the relative order of input and output constructs, the
presence of forward references, whether we need to preserve comments
and formatting, sheer input file size, and so
on.<a id="text/part0000_split_106.html.FNPTR-38" href="#text/part0000_split_114.html.FOOTNOTE-38">[38]</a>
But, regardless of the translation strategy, we need to keep an
important design principle in mind.</p><p height="10" width="0" class="calibre5"><em class="calibre6">Translation involves fully understanding each input phrase,
picking an appropriate output construct, and filling it with elements
from the input model</em>. Trying to cleverly replace input symbols
with output symbols rarely works well. You end up with what we call a
<em class="calibre6">literal translation</em> in a natural
language.<a id="text/part0000_split_106.html.FNPTR-39" href="#text/part0000_split_114.html.FOOTNOTE-39">[39]</a> For example, <em class="calibre6">faire un canard</em> in
French means literally to make a duck. The real
translation, though, is to hit a wrong note.</p><p height="10" width="0" class="calibre5">In a computer translator, to understand a phrase means
to syntactically and semantically analyze it.  We usually have to create
an input model like an AST because we cant always do semantic
analysis properly as we parse.  As we did in Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, we have
to create symbol tables and compute expression types from the input
model. According to the needs of the task at hand, we compute
everything we need to know about the input and then make a decision
about mapping an input phrase to an output phrase.</p><p height="10" width="0" class="calibre5">Translation is a huge topic, and we can  devote only one chapter to
it, so were going to focus on overall strategies and a few
of the most common patterns:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>: 
This translator consists of a parser (or
grammar) with embedded actions that immediately generate output. The
key distinguishing feature is that syntax-directed translators dont
build an internal representation. They have to do
everything in one pass.</li><li height="6" class="calibre20"><span></span>Pattern 30, <a href="#text/part0000_split_112.html.tip.rule-based"><em class="calibre6">Rule-Based Translator</em></a>: 
Rule-based translators use the DSL of a
particular rule engine to specify a set of this goes to that
translation rules. Combined with a grammar describing the input
syntax, a rule engine can automatically perform translations.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Model-driven translation</em>:
There are lots of
variations within the model-driven translator strategy, but they all
have one thing in common: an internal representation of the
input. From the input model, a translator can emit output directly,
build up strings, build up templates (documents with holes in them
where we can stick values), or build up specialized output objects
(Pattern 31, <a href="#text/part0000_split_113.html.tip.gen-obj"><em class="calibre6">Target-Specific Generator Classes</em></a>). Depending on the complexity of the translation, the
translator might need multiple passes over the input model before the
generation phase.</li></ul><p height="10" width="0" class="calibre5">Because most industrial translators use the model-driven approach,
well spend most of our time talking about mapping input to output
models. Then, as part of the patterns, were going to implement a
<code class="calibre21">make</code> build tool, a wiki to HTML translator,
and a simple SQL <code class="calibre21">CREATE TABLE</code> statement
generator.  Lets get the ball rolling by looking at the simplest
possible translator design.</p>

</div></div>
<div id="text/part0000_split_107.html"><div class="calibre">

<h2 id="text/part0000_split_107.html.d24e33864" class="calibre18">Syntax-Directed Translation</h2><p height="10" width="0" class="calibre5"> A syntax-directed translator reads input and immediately emits output
as it goes. 
 In the following image, we see the one-stage
application pipeline. Even though it has few moving parts, we can use
this for a surprising number of DSLs.</p><div class="calibre1"><img id="text/part0000_split_107.html.d24e33876" class="calibre24" src="data:image/jpeg;base64,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" alt="images/trans/syntax-directed.png"></div><p height="10" width="0" class="calibre5">Syntax-directed translators consist of a grammar (or equivalent
hand-built parser) and output actions. For example, here is a rule
that translates a scalar multiply, such as <code class="calibre21">a x b</code>, to Java:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">mult : a=ID <em class="calibre6">'x'</em> b=ID {System.out.println($a.text+<em class="calibre6">"*"</em>+$b.text);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Because syntax-directed translators make only one pass through the
input, they cant deal with forward references.  For example, we needed
multiple passes in Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a> to handle forward references to
methods and fields. They also cant perform very sophisticated
translations because their application pipeline is only one stage deep. It
has no opportunity to analyze an input model, which is typically
required for complex translations.</p><p height="10" width="0" class="calibre5">Syntax-directed translators also break down when the order of input
and output constructs differs significantly. For example, imagine a
translation that negates a list of integers and spits them out in
reverse order. A syntax-directed translator would negate the first
number and immediately spit it out. Without buffering up the negated
integers, we cant deal with radically different input and output
orders.</p><p height="10" width="0" class="calibre5">Building a syntax-directed translator means writing a lot of
informal code by hand.  To understand what such a translator
implements, weve got to imagine the emergent behavior of all those
actions.  Well explore the details in Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>.  Lets move on to DSLs designed to
make translation easier and less <em class="calibre6">ad hoc</em>.
</p>

</div></div>
<div id="text/part0000_split_108.html"><div class="calibre">

<h2 id="text/part0000_split_108.html.d24e33912" class="calibre18">Rule-Based Translation</h2><p height="10" width="0" class="calibre5">To build a translator, we have to define an input-to-output mapping (a
set of this goes to that rules) no matter what translator
architecture we use. 
Instead of coding them with a general-purpose
programming language, we can use a translation DSL. There are a number
of excellent rule-based systems available such as ASF+SDF,<a id="text/part0000_split_108.html.FNPTR-40" href="#text/part0000_split_114.html.FOOTNOTE-40">[40]</a> Stratego/XT,<a id="text/part0000_split_108.html.FNPTR-41" href="#text/part0000_split_114.html.FOOTNOTE-41">[41]</a> and TXL.<a id="text/part0000_split_108.html.FNPTR-42" href="#text/part0000_split_114.html.FOOTNOTE-42">[42]</a> The ANTLR
  project also has a simple rule engine called ANTLRMorph.<a id="text/part0000_split_108.html.FNPTR-43" href="#text/part0000_split_114.html.FOOTNOTE-43">[43]</a></p><p height="10" width="0" class="calibre5">To use these engines, we feed them an input language grammar and a set
of translation rules, as shown in the following image. From the
grammar, the engine builds a parse tree from the input and then
applies the rules to get the output.  As we saw in <a href="#text/part0000_split_057.html.sec.tree-pattern-descr"><em class="calibre6">Decoupling Tree Traversal from Pattern Matching</em></a>, a rule-based approach has a number of
advantages. We get to focus on the input constructs (subtrees) we care
about, and we dont have to specify tree-walking details.</p><div class="calibre1"><img id="text/part0000_split_108.html.d24e33947" class="calibre24" src="data:image/jpeg;base64,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" alt="images/trans/rule-based.png"></div><p height="10" width="0" class="calibre5">To demonstrate the rule-based approach with a simple translation DSL,
lets look at an <code class="calibre21">awk</code> script that extracts class names by
looking for the <code class="calibre21">class</code> keyword:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/^public\ class/ {print $3} # In "public class foo", foo is 3rd element</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/^class/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {print $2} # In "class foo", foo is 2nd element</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> <code class="calibre21">awk</code> scripts are a series of patterns (regular expressions in
<code class="calibre21">/.../</code>) and actions (in <code class="calibre21">{...}</code>). <code class="calibre21">awk</code> walks an input file line
by line, executing actions associated with patterns that match the
current line. </p><p height="10" width="0" class="calibre5">Notice that we dont have to specify an entire Java grammar to make
this work.  Of course, this is a simple transformation. In general, we
need complete syntactic and semantic analysis like any other
translation approach.  Still, its amazing what we can build with just
a few pattern-action rules.  For example, were going to build a
wiki-to-HTML translator in Pattern 30, <a href="#text/part0000_split_112.html.tip.rule-based"><em class="calibre6">Rule-Based Translator</em></a>.</p><p height="10" width="0" class="calibre5">All of these tools allow multiple translation and information-gathering passes using different sets of rules. For example, its
extremely common to have a symbol definition pass and then a symbol
resolution pass. We might also need a type computation pass. All of
this has to happen before we can apply the translation rules.</p><p height="10" width="0" class="calibre5">Rule-based systems are particularly good at legacy code conversions
because we want the translated code to be natural.  For example, If we
see a nested loop implementation for a matrix multiply in Java, we
want to recognize that pattern and convert it to a simple
<code class="calibre21">A x B</code> in a mathematics DSL (not another
nested loop). Rule-based systems let us just lay out all the
input-output transformations we want. We can add new ones easily as we
think of them.</p><p height="10" width="0" class="calibre5">I took advantage of this fact when writing this book. The publisher
has an excellent proprietary DSL for writing books, but to reduce the
strain on my hands, I designed a really terse DSL and built a
translator from my language to their internal format. As I write this
book, I think of new timesaving commands and add them to my list of
translation rules.</p><p height="10" width="0" class="calibre5">This all sounds great. These rule engines let us say
<em class="calibre6">what</em> to do, not <em class="calibre6">how</em> to do it. They are
powerful, implementation-language independent, expressive, formal, and
beautiful.  It might surprise you, then, that these pure rule-based
translation systems dont enjoy widespread usage in industry.</p><p height="10" width="0" class="calibre5">From what I can tell, developers have a number of objections. These
systems tend to be complex beasts. With a large number of translation
rules, translations can be slow (though we might not care). Some also
find the rule engines functional programming style too different from
the imperative programming style theyre used to. The rule engines
themselves are black boxes, which can make it hard to understand
whats gone wrong in a translation. Some of these systems were also
designed to be the center of the universe, making them tricky to
integrate into applications.</p><p height="10" width="0" class="calibre5">If you need sophisticated pattern matching that integrates well
with Java, take a look at
Tom<a id="text/part0000_split_108.html.FNPTR-44" href="#text/part0000_split_114.html.FOOTNOTE-44">[44]</a> (Tom
also supports C, Python, C++, and C#) and the
Scala<a id="text/part0000_split_108.html.FNPTR-45" href="#text/part0000_split_114.html.FOOTNOTE-45">[45]</a>
programming language (which looks like Java + ML).</p><p height="10" width="0" class="calibre5">Next were going to look at the translator architecture used most
often in industry.  Its a hybrid approach that glues together
components from different formal tools.  As youd expect, as we reduce
the level of abstraction, weve got more work to do. In compensation, we
get to work with simpler tools and use familiar programming
languages. We also get greater control over efficiency.
</p>

</div></div>
<div id="text/part0000_split_109.html"><div class="calibre">

<h2 id="text/part0000_split_109.html.d24e34025" class="calibre18">Model-Driven Translation</h2><p height="10" width="0" class="calibre5">In a model-driven translator, everything centers around an input model
created by the parser.  
In its simplest form, a model-driven
translator creates an AST input model and then walks it to generate
output with print statements.<a id="text/part0000_split_109.html.FNPTR-46" href="#text/part0000_split_114.html.FOOTNOTE-46">[46]</a> The only difference between this and a
syntax-directed translator is that we generate text while walking a
tree instead of while parsing a token stream.</p><p height="10" width="0" class="calibre5">The advantage of creating an AST first is that we can do semantic
analysis before generating output.  Most of the time, well need to
annotate the AST with symbol and type information before generating
output.   In Figure 31, <a href="#text/part0000_split_109.html.fig.model-driven-bigpic"><em class="calibre6">Model-driven translator</em></a>, we can see the overall
architecture.  From a software engineering point of view, its also
nice to keep output-language specific actions out of the parser.
Sequestering them in a separate tree walker lets us reuse the parser
for other tasks.</p><div class="calibre1" id="text/part0000_split_109.html.fig.model-driven-bigpic"><img id="text/part0000_split_109.html.d24e34055" class="calibre24" src="data:image/jpeg;base64,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" alt="images/trans/model-driven.png"><hr class="calibre17"><b class="calibre13">Figure 30. Model-driven translator</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Once weve got an AST, we can also restructure it as part of the
translation, as shown in Figure 32, <a href="#text/part0000_split_109.html.fig.tree-rewriter-bigpic"><em class="calibre6">Model-driven translator with tree rewriting</em></a>.  The role of tree
rewriting in translator design is a pretty big topic and too much to
go into here. Unless you have a lot of experience building
translators, Id avoid rewriting the tree unless youre doing some
simple optimizations like we did in Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>.  The
majority of (noncompiler) translators skip tree rewriting and go
directly to output generation.
</p><div class="calibre1" id="text/part0000_split_109.html.fig.tree-rewriter-bigpic"><img id="text/part0000_split_109.html.d24e34070" class="calibre22" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABiAZADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACqupajZ6XbfaNQuYraAusYeVgoLMQFH1JIFWq5bxjb6Heat4at9dkfz/tplsYOSksyIT8wxg4GSM96ALyeI4H8TPogstSE6ruNwbVvs/3d3+s6e31pLDxJb3viG60hLPUo5rcEtNLaskLYx91zwev864b4vaBaa14m8KRym9DPNI915E0qA2scbOynaQMk7QO9eb3/jzxroGl6FBp93lJ447lYJLPmKB5CqRlmyXIVcseoyOaAPoHRPElvq+p31jDZ6lBJaEhpLm1aON8MR8jHhunbtTdB8T2+tJfPBY6nbi0+99qtGiL9fuZ+907e1eLap498c21n9rjv7eJL+2a4ijubEoLQNOViXfgjcUBOX4rB1n4i+MrCGfUYGuRez20UUcz2gUERxmR/wB2cqHJlQcA5CnGKAPoXR/FVtqukXuoRWOqQx2oJaO4tGjkfC5+RTy34d6LPxVbXXhy51lLHVUhgJBgktGWdsY+7H1PWvD7nxz4yi1bVwdXktVmXda5svOBmjijAt41xwXZyxPoM16p8KdQ8Ua3Z32qeKXS3V52ggsEgCCPYdrPu6tlg2O1AG5/wlVt/wAIz/bf2HVPI3bfs/2RvP8Avbf9X19/pzReeKra18OW2svY6q8E5AEEdozTrnP3o+o6V0FFAHP6x4qttK0iy1CWx1SaO6AKx29o0kiZXPzqOV/HvTte8T2+ipYtPZancC7+6LW0aUp0+/j7vXv71vUUAYet+JLfSNTsbGay1KeS7ICyW1q0kaZYD52HC9e/ai/8SW9l4gtdIez1KSa4AKzRWrPCuc/eccDp/KqXiLx94b8PXZtdT1ELcj70UUbysv1Cg4/Gsn/hbvg//n/uv/AGb/4mgDo38SW6eJ10M2epGdl3faBasbcfLu/1nT/69Ft4kt7jxJPoq2epLPECTO9qywHAB4k6Hr/Ouc/4W74P/wCf+6/8AZv/AImj/hb3g7/n/uf/AABm/wDiaAOj0rxJb6lrd7pkVnqUUtrndLPatHE+Dj5HPDUmg+JrfWbm+hgstTga0OGa6tWiV+SPkJ+907e1c5/wt7wd/wA/9z/4BTf/ABNH/C3vB3/P/c/+AU3/AMTQB0OheKbbWLG+uobHVIEtBlkubRonfgn5AfvdO1Jpniq21DQbvVo7HVYobbduhmtGSZ8AH5UPLda5/wD4W94O/wCghc/+AU3/AMTR/wALe8Hf9BC5/wDAKb/4mgDoIfFNtL4Zl1sWOqLBGSDA1ownOGA4j6nr+VE3im2i8Mxa2bHVGgkIAgW0YzjLEcx9R0/Ko/DXjfw94lnMGkaiktztL+Q6tHJtGMnawBxyOfeukoA5/U/FVtp+g2mrSWOqyw3O3bDDaM8yZBPzIOV6Uuu+KbbR7GxuprHVJ0uxlUtrRpXTgH5wPu9e9b9FAGFr3ia30a5sYZ7LU52uzhWtbVpVTkD5yPu9e/vS6r4kt9N1uy0yWz1KWW6xtlgtWkiTJx87jha3KKAMO58SW9v4kg0VrPUmnlAInS1ZoBkE8ydB0/lQniS3fxO2hiz1ITqu77QbVhbn5d3+s6f/AF63KKAMOw8SW974gutISz1KOa3BLTS2rJC2Mfdc8Hr/ADo0TxJb6vqd9Yw2WpQSWhIaS5tWjjfDEfIx4bp27VuUUAYOg+J7fWkvmgstTtxafeF1aNEX6/cz97p29qbo/iq21XSL3UIrHVIY7UEtHcWjRyPhc/Ip5b8O9dBRQBz9n4qtrrw5c6yljqqQQEgwSWjLO2Mfdj6nrR/wlVt/wjP9t/YdU8jdt+z/AGRvP+9t/wBX19/pzXQUUAc/eeKra18OW2svY6q8E5AEEdozTrnP3o+o6Uax4qttK0iy1CWx1SaO6AKx29o0kiZXPzqOV/HvXQUUAYOveJ7fRUsWnstTuBd/dFraNKU6ffx93r396drfiS30jU7GxmstSnkuyAsltatJGmWA+dhwvXv2rcooAw7/AMSW9l4gtdIez1KSa4AKzRWrPCuc/eccDp/KtKz1Gzvbi6gtLmKaa0fy50RsmNsZww7cGrVczaQaLafEG+a3Z49cvbCOW4jAOx4kdlVzxjdkkeuKAOmooooAKKKKACiiigAooooAKKKKACuZ8UT6JF4h8MJq8LyahJdSDTmUEhJPLO4nnj5c101cz4o1HS7PxD4Yt9RsvtF5d3UkdnLgHyHEZJbn1UEcUAdNRRRQAUUUUAFFFFABRRRQAUHoaKD0NAHIeBCRL4nx/wBBq4/9BjqKz+IWiXniD+yoWvCTJJCl40BFq8kYJdVk6EjB/I1J4F/1nijHX+2rj/0COvMtT+EWvX0dyItV03TZZ4mW6Fk0wj1B2cEtKh+VOAfuA8mgD2JvEmirBDM2s6eIZiRE5uU2uR1AOecUh8RaU0UEi6rY+VO/lxN9oXEjf3VOeT7V45afAsGK4F/eWkjThPlCFliJnDyFcgcmNQoOBnnNVdS+CusTagph1LShYJdm6ityjp5YM29kAVehAUdRjFAHr+o+L/D+nQzy3mtWKLAypKBMGZGZtoBAyepxS6T4o0rVRCLe8jSWdnWGGVwskoQkFlXOSvB5FeWz/By4hFm1jc6XvjhjW4EsbDz5RMZWcsBnrtx9KueB/hlqGgapay6nd6XqEEEy3IuGic3O5UKiNSeFQFmbjrnpQB640hHQmomc+pppamE+tAHlXx2lmg/sq9tJpILyzt7q4t5UYgpIrQYOAeRycg8GvS/hzrd1r3hmG41LyzfRSSQTPEu1XZJGTcB2ztzjtmvMfjyf9Ctv+vG7/wDQoK7r4N/8itP/ANf11/6PkoA7uiiszxPqTaN4c1TU441leztpJ1jY4DFVJwT+FAGnRXDWtl44ntopX8RaMjSIHKrpbEDIzjPmc1L/AGd42/6GXSP/AAVN/wDHaAO0oriGsfGw/wCZk0g/9wpv/jtNNn42H/Mx6R/4Km/+O0AdzRXCG18bD/mY9H/8Fbf/AB2o2h8cAHb4h0cntnS2/wDjlAHf0V578NPiPB4o1LU9A1BFt/EWlSPFcJGD5UwRtpkjJ7ZI4PIr0KgAooooAKKKKACiiigArnfP0j/hYJg8mT+3f7MD+bj5fs/mkbc567snpXRVzv2/Tv8AhYJ0/wCxH+1f7ME/2vA/1PmkeX6/eyaAOiooooAKKKKACiiigDi/jOzL8MPEBRmU+QBlWIPLr3FSWvw98KPbQs2iWpJRSfven1qL40/8kv8AEH/XFf8A0Na6RtRtbC108XcwjNwyQRZBO5yOBx9KAMX/AIV34T/6Adp/49/jWZ4m+HPhY+HtSMWkRRSLbyMjwu6OrBSQQQc9a7zzExncuPrUV5d29naTXN3NHDbxKXkkc4VQOpNAHz/8F/iLHott4a0LWtet9Ut9UgjSF2nDXNjckcwTL12k/dY8joe1ex+JtXi0/X/DVpJpou3v7l4knP8Ay7ERlt3Q9cY7da4744aVoyfDa+1G1sLBZfOtpkuY4UVuZkO4MBnp3q14s+J+n6Zqei21hdWF1BeTPHcyrOD5ChMhuDjk8c1UYSl8KuJyS3Z6WDRXimh/FHUfs0E2q2KzRyLuMtmeR9UP9DXoHhzxrpWt7VtLuN5D1jJ2uPqp5ror4OtQ+OOnfoYUcVSrfBIw9I13xZrk2pPYXGi28FveTWypLayO21GwCSJACT9K0wfGnfUtAH/bjL/8drg7jU7vSfhf431LS53t7yG+u3ilQAsp81eRn61x2u+IfH0GlLJo1z4hubfzJHtriezKzTYSM7XULnbuLbegIBz2rlOg9wUeMm66poI/7cJf/jtK48XqOdX0HP8A2D5f/jteManq/j6HRrXUhqWui6ubuYtZJbYVUXbsVSFOCcnhuD6jFb3w51jxrfeNr0eJHuUsispe1ktyI4CHxGFfpyPTOfagD0E3Hi3LBdX0Biv3gLCXI+v73ijw74g1k+MJNE1p7C4VrJbqOW1heIqd5UghmbPSvG/hrca1bfFTVbnUNLvI4dWaUyyPHKqWzB2Kpk8PkAYboAcV3V/rdpo/xOjnvLiGBTpQAMjhcnzW9aaTbshNpasb8UPG2v6Jr+p2el3MqQxLpvlpb2ySy/vpnWTaGGCSFGAa6H4SeIdW10+Ik1Zr0x2V6IIBqFslvcqPLViHRPlxk8EdRXn0Hi2DU7w6nrOgWl80skeJ7dz5gWJ2MWVJw20nIxjrzXovhTxP4bvtTvbywaGPU70J9p3ZSSTYuFyp9BxkV01sFXoazjp3MKOLo1tIS1LPhCcW6+K5WDFU1i5YhRkkBIzwK8f0P4neMNc8Qy6fbzRQRXcsX2eY2Yf7LGWZmLKOuEXBBOQ1ew+CWBl8TEf9Bu4/9AjrF0b4reG7+PF7cPp1yZmhWKeNsOwkMfyMBhucZx0yM1ynQeXTfFvxZBcaQs5R4VCrdgWex5lIZt4U8j5duMYGeKfo/jjxRoulXmk3F00SaXHHcyX8lt5zkTIGjg2nqxdm5PQDmvU9Y+JOj6fdwoJY5rdpxBLOJNvkHMgZmBHRTGRx1qv4T8T+GGi8R3ekoLSxtHS6vLuYOnmtIhYsQ/zcADHbkYoA8zf4iePLOfTraSex1CcpHcSGC3BW4DscxrjqFVTll6H2r1v4d3es6h4ah1LX7hZJ74+fFCsHlm3jOdqH+8cYOaxk+LHhwS332l7m3htpVjV3gfdICgcts25VVB5J+tSJ8UfDmLpp5p4kguntg3kO24KFJl4HCYYcn1oA7on0phOKa0gxkd+RUTNnrQB5b8eHzZ22P+fK7/8AQoK774M/8ipL/wBftz/6Pkrzz46t/odt6fYrv/0KCpNB8ZnQfCKW+mXNm2pPqkq+TK2fkM8hJIHI4wc1pSpSqyUILVkVKkacXKXQyp/iV4rktYpBdaq5Gjy3pOmabDNiVZ5UDSBhwm1F6V6xrV5c6h8F7y9vihurjQ2mlKfdLNBkkfnXB+GfE+h6Q4F5oMensbc2rTW+6WIxFmYr6gFmY9D1611+rajpEvwp1q20J4fsMOlzxwrC+4IojOF6k8VdbDVaDtUjYiliKdZXpyubfifWT4e8AX2rKN0lpYeag65bYAv6kV5BpvxT8SaLf3Eetpe6sgtrcCCaxWzlFzKCwC7c5j2q5JIzwK9l1GGwuPDRXWI0lsFtklmR84Koobn8s153rfif4b6ppVn4g1e3D22rjcJ5I3VswnYA2DlSPMxx6msDYhb432UH9nrfaRNbyXSxu0fm7mjV0cgnjuyBR6lhWP4h+LviBrOBrDQl02dpJkQXFwsgnaPClenA8xlGR1INd9NZeBjI8rroga0WDefNUeSsZzDnngAnI+tZXij/AIQnSrSCLUNLS5g+yTXkKwIZAYxKrttOepdlPvQBgW/xnllM0CeHp5541EURSbAuJxIsZUZHALE4PPSvV7OWeS0ge8hWC4ZQZIlfeEbuN3fHrXA+ELTwXqmoXw07QGsdSspo5pobyBo5Y2JLK4BJGCcnjjNd48mTz60AeA/CRiPj94tKnH767/8AR6V738TtYvdC8H3N/pkix3ST26KxQMAHnRG4Psxr53+Gt5DZfHDxfPcSpFGsl2SzsAP9eld/qXjyXVpdQtb6wstV0T7UQgjkKuQjKyH0bBGeMdK6KGFq4i/s1exjWxFOjb2jtcbY+OvEz+LdFtzLqxt7zW57KT7Rp8K2TxK8gAjlUb9wCDr1INdHdaJp2u/E7xCmrWy3KRQWvlh2b5Mq+cYPGcCnaH4i8Kaxb2mnyQRwtDc/aobafMbpNuLbl55O4seCetX9DZbn4l+KXTp5Fnj/AL5esp05U3yzVmaQnGa5ou6Jf+EC8Lg8aRB+LP8A/FVKngPwwBltGtcfV/8A4qvHPEHjTxZeeKNRt/DV7fvqNpNdO9lDse1W1QBEK4yWfLFjznK4qVZfiHcabdSDVtcVIbWW4tx5XlyTSFkSNSWBOMlmwQOKgo9ck8F+Fl4XRLQ/99f/ABVcz468O6LpXh2W90zTobW9hnt2jmiLhkPnoOOfQmuo0Z9WW0C629k0wCgG1D88DO7d3znpxWD8TrhY/B14zsFVZbcknoAJ0OaAPTrKQyWkLucsygk1mxXsT+MLiy+xATRWMc32vHLK0jjy+nbbnr3ryzVPiRfwaxBbaGbG8s47VXkRn5LZxgMOn0Naeg/FiCbV2tdXt20yDyUKSTnhpSxDLuHGANpzx1rreBrqCqct0zljjaLm6fNqjV+LdpFqd/4O0278xrK71YJPGkjJvUROcEqQeoFWR8KPCGP+QdN/4GTf/FVU8cX0N9rvgGWB1dG1fIZTkEeS/evRQQMDPWuQ6jhf+FT+EP8AoHTf+Bk3/wAVSP8ACbwgyFf7PuBkYyLyYH/0Ku1ury2tBEbq4hhEriOPzHC72PRRnqT6VMCD0IoA+ZvDPi5vhvquvq+uLdaLZavNaS6LeXW65htxjbNBuO5sZOVPUDjmvpDStQtdV022v9PnS4s7mMSxSochlIyDWbcaN4c1W+ufP07SLy8QgT74I5JFyMjdkZGR61z/AMEQI/AFvAnEMF1dQxIOiIszhVHsBQBP8af+SX+IP+uK/wDoa1Q+K3hrVvE/hbSbbQiguIbhJnLSbPlEbDr9SKv/ABp/5Jf4g/64r/6GtdfZEfY4Of8Almv8qAPm3X/hrquma9oVlaaN/aGmTwgyWYvWRDcLbbXdnzx82D744rY1z4d+MtR0waHNb21xZ8zSXj3vMrmzSHYVPON65ya+gMj1oyPWgDyT4tWMlp8A3sJoFtZY4LSB4lYMEIkRSAR1rzDXPDeu6FNZW0EdvdQsTG8qw48pQvDN9ele0fHrB+GOo/8AXa2/9HpV3xfoupXOr6CNKiRrB7hxqJbbkRbDtxnn72OldOHxlXDX9k7XOevhaeIt7RXsfO1nqklzFGIIpJpiBlIlyAfr0FdNoXhTUNauonvX+xoGBUw8zDns/wDCfcZr2K28F2sb5SFFXOcBQBXQ2GjW9oF2qMg13185rVNKa5V97OOhlNKm+aWrPItLu/8AhHfg74puRDHfvZ3lziO8HmiXEij5/wC8T/OtJPi3Zxie3v8AStSsb21tZLme2cruRY1Ruxxhg4Io8PW+k6n4c8R6Rq0sJtbjVLtJYmnCEr5gPrkdKrXnw/8ABN1apBOQ4VnYudSO+TeAGDNuywwqjB44ryG76s9RKxR074qz3FyV+xS3jXIZbO2tlCzSMJHHJJxgIuSaUePtUk8EeGNYMNutxqc7xyxlTtQBZDwM8H5B+tabeC/CBgWJDHHtIZHjvtroQxbKsGyDkn8Dir8fhvwyuj6dpYe3+xae5e3T7WMqSGByc5PDHrSA5X4aeO9X8Sata2eoNazpcacb1jBbSQeQQyjbljhwc9V6Vm/Eawu73x7ALVog8em5PmLuBBkP+Fem2GlaFZvpT29xAh0y3a1tR9rGFibGVPPzfdHX0rONnbah8UAsckUq/wBkrko4bB85vStaNadGanB6ozq0o1YuE9meJ2mqySxhFjaScZBjhUnkH9K6HSvDWo67In2sJawdem+UfQ9B9ea9oj8FWqykpCignJ2qBk1v2OhW9qvCjOPSvTrZzWmrU1y/izzqOU0oO89TjvhXaHTdK1uzM085i1i5Xzbh98jfLHyx7muevfhLp0iKLzXL8xwSO+nh9ii0lkk8wlePny3Y113hA7bjxMB/0G7j/wBAjrxrVtD8a6hqWrrPBrU0Ed9FcqWnKgkT5GwZ2sFj7qBjuM15Dbbuz1ErKyO7f4SaXPY/Zr/Ub+5DsXldtqtIxaRieBxzKfyFaFj4EtrfRNY0zV9WutR/teOKB5Z9qMojTagQD0GD+Fcc9v410vSre3t11261HUraB5Lg3Adbe4W4Yy7sn5QY9o44NYM+heMbtLOaa38RjUrWctcStfLsa4KuokhXsoynPTHakM67WPg7b6wZJdU8Q6jc3U2RPK0UeHUxiMYXGAQFGD16+tM1L4PWV8zl9a1Ab929SiMvKqCVBHyn5Ac9e1ZWj2vjbW2gi1VtbsrdEiVt04QyyR28m4nH8LTbM+vFc0bT4i/2Ncm5OuyL5iGSMZDNMFbdjD7ihbbypA46YoA+hoQ0UEaO5kdVClyMFiB1pGb1rC8KalPeaaIL23uYb2zWOC4M2Dvl8tSxVh97BOM+tbJPrQB5d8dfnsIF6Zsbsf8Aj0FcVJb3em6ZFetLbm0N1Jb5KYYBZGXJP/Aa7P44H/Q7f/ryu/8A0KCur+HOhwav4PcTxrIBeXPDKCP9e9deDxk8LK8dnuu5y4rCwxMbS3Wx5JbXV3eNtsLaWY9NxG1fzNbkvg24PhrW9RvLqWCSOwmYR2ZMYbCHhz1Ye3Fe1WXhC3icMYx+VL460+G0+H/iPYoz/Z1x/wCizXTiM2rVk4rRGGHyyjRfNuyn4z0e58S+CW0e0ultReRQxzyEHPk/KXC46MRwDXmetfBm7mWaz07V0OlrI89st7ukkWRvLLBiBjaTH29a7zx/q2oaN4Ce90iWGG8WOBUklQsqg4BPAOOO5GB3ryLR/FvjPUdbtmg1SaGfURbwhZrEFAo80O6jp1VeRwcivLPRNuD4MXX9oy3F1d6a6NcecQFkPmK0wkZSp4AwCB1zx0rtPHvhB/EdxEbWaC3gSwnsvLII4kdCMY6ABCPxrgYfiRr11ZWlvLctZXMUUceqXbWO5bWRp3UttxzhVUegzmqWk+N9Y0zWdSu9X1Waa0lClS1kyqf9Gcxsq4yuXC/XNAHpvhbwlF4a8Sa7eWDKun6gsJSFnZ3R1BDEs2Tg8cZrpy/IrwN/HPjltGkvmuI4ke7S13PaKogHlbyxJHO48dMV6/4Vvry/8OaZdamiJezQq8qoCBuPcA8jPXFAHgvhO0kvPi94xWFlWRXvCNwyOZVFWhfy2889pNh7mGVoykCE5x7dqvfCeMTfHPxahGQXuv8A0ele9TeDbV7l5FhQMx+YhQCfr616OCzCWFTVrpnBi8BDEtNuzPDtO0XU9bYRyQpbQH+KVfMf8F6D869G+F2nf2H4l8S2az3E+yG0w9w+9uQ/GfT0Fehad4dt7UD5AK5WzCwfEjxSq8DyLP8A9BessTjq2J0m9Oxrh8HSw/wLU5bUfiV4Y8O+IdUhtdElVkkkjuL22iVFllRdxXOOeflz03GodW+MEFnPLaSaLexXqxsxWSaMhHEZfDEHHAxn0JxXSXPgfw9cXd7cS2TM942+VTK2zduDEqucKSVGcdcVWuvhx4Xu7y7uptPJluy7S7ZmCkuu1iBnAyK4zqMS3+KIt9IgutX0e5RijpJLFKmx54497xoCckfw7umeKs/EqS41H4b3Mk1pJZTXKwgwTMGaMtKmAxXjPNaw+G/hZpZZG03c0pBIMrEKQQcqM/KSVGcde9XfiRAr+D7n/rvbD/yPHTjJxakugpJSVmeGXU02jX5tr3yFLRiRTEhBbnpjvVqxj1TWJfItLFkiIBM1yuEIPoOpr3p/BtndCC4aCNpdgAcqCQPrUmleGri38RTh4k/sr7JGYm4z529t/v8Ad2e1ezLO6vIlFa9X/wAA8lZPS5229Ox5bpHhNvD3iPwZM95cSvPq3MWdsK/uX+6nY+9dZ8SPB3iPXPFRu9LVjlLZbK+F4Yhp+1yZsx5+feCOQD6VteP7dLfxD4DVBj/icf8AtF69BBGBzXk1as60nObu2epTpxpx5YKyPn298BeLL610wanpSMukfZVQ/b1ZpxHLM8jj04dcA81Q8MeCPGEKaLrWkadPb2qW8Ly6fNqWXupTE6tNljhPvL8p59uK+ksj1oyPWsyzyz4NeDNT8K3+pzatZJHNeWtpuuFufN3SJHiRSOv3snPetf4K/wDIkf8Ab9ef+j3rvMj1rg/gr/yJH/b9ef8Ao96AOq8S6La+ItCvNJ1Ayi1uk2OYn2sBkHg9jkViL4LdVCr4n8SgAYA+2L/8RXW0UAcn/wAIbJ/0NHiX/wADF/8AiKP+ENk/6GjxL/4GL/8AEV1lFAHE6n8PLbVbQ2mqa74hu7RmV3hlvF2uVYMM4QHqBWv4gtdam1vw/JpNwsVhDcO2oIWAMkewhQODn5sHtW/XO+JNM1W917w5c6beGCzs7l5L2IOV85DGQFwOuGIPNAHRUUUUAc9qXgrw3qV01ze6Lp8k78tIbdMsfUnHJqr/AMK78J/9AHT/APwHT/CurooA5X/hXnhP/oA6f/4Dp/hR/wAK98Kf9ALTv/AdP8K6qigDlv8AhX/hX/oBad/4Dp/hV/R/C+i6NcGbS9OtrSQjBMMapn64HNbVFABQehooPQ0AcD4TP+leJh/1Grj/ANAjrhtQ+MUVlql3af2O9womMNq0VwB5pEoiO4lcAZORgnjrzXWaFqVnY6h4lhvLy2t5jrE7hJplRipSPBwTnB9azD4c8CC/a98nRjcmUzbzcocOTkkDdgc849aAMef4sSw2kk8ugSiKzydQdLlSIQJzD8gx85yM9uKzdW+LF6sGlyWmlRQR6jPC9vJLcK2+2aUxsXH8DcZrtWsvCJiuoydIMdyczKZ0If5y/PP94k/WqCaD4GiW6WODRQtzIssg89CCynIx83AB5wOM0Acqfi7cXVxbxWulLHuuoi26bO63bf0JA+b5O2Rz1ro/A3j9PF0WomLT57N7eAXMZkJIeNg23qBzxyBke9Fv4a8B27FoYNHU5B5uVPQ5HVugPar2i2vhXQkuV0mTS7Zbg/vdtyp3D05bgcngcCgDzq7+IniFIp5klYeTBZSAJpyvATKql/Nl3ZjGTxgGvZg5KqTjJAPHSuc+zeFxZXNmJNLFtcokc0f2hMOqDCg89gK0hq2looA1GxAAwB9pT/GgDgPjcc2dv/15XX/oUFemfBX/AJFB/wDr8uf/AEe9eUfGS/tLy2hW1uredksrosIpVcrloeuDxXq3wU/5E9/+vy5/9HPQB39ZHjDT59V8J6zp9ptNzdWcsMYc4G5kIGT2GTWvRQB873fxvtdHmbTdX0dbC/tcQzW9zfBXVlGOR5ZGDjIOeQRVY/H7R/8An2tf/Bh/9rr6C1HR9P1Eg3tpDMw7sgJ/OqX/AAieif8AQOt/+/Y/woA8Gb4+aOf+Xa1/8GH/ANrph+PWjn/l2tf/AAP/APtde+f8Inon/QOt/wDv2P8ACj/hE9E/6B1v/wB+x/hQB8/t8eNIP/Lta/8Agf8A/a6QfHbSCR/o9qOepv8A/wC119A/8Inon/QOt/8Av2P8KP8AhE9E/wCgdb/9+x/hQB81/AueK/8Ai/rOo21xb3EV5HNNmFiwUtLGxXkAnGcZwAcHFfWFZlnoOm2Uiva2scTA5BRQP5Vp0AFclr3gmHU9Xn1O01XVNNu50RJjaTBVkCZ25BU8jNdbRQBwf/CAXX/Q2+If/AhP/iKUeAbof8zb4h/8CE/+Iru6KAOGHgS7H/M2+If/AAIT/wCIptx8P5LqNYrzxLrlzAHSQwyzqUYqwYZAUZGQK7uigCO3j8mBI87toAz61lRpqg8XzOxJ0ZrFAg3D5Zw7buOvKlefatmsH+z9S/4Tg6j9qP8AZH9niD7PvOPO8wnft6fdwM0AR+MvC0XiaGxBvruwubG4FzBcWpAdGwR3BB4JrF/4QXVv+h78R/nD/wDEV3lFAHB/8ILq3/Q9+I/zh/8AiKP+EF1b/oe/Ef5w/wDxFd5RQBwf/CC6t/0PfiP84f8A4iui8H+HrfwvoMOl2s086Rs7tLOQXdmYsxOPUk1tUUAFFFFABRRRQAVzfibRZ9S8QeGr2G+FtHp1080kRYjzwYyu3rzgnPNdJXP+LPDUXiCTSZxcy2l5pl4l3BPGASMcMhB4wykg0AdBRXOS3XigeKlgi03TW8P5G66NywnHHPyYx196LW68UN4olgudN01NABPl3KXLGYjHGUxgc+9AHR0Vzmj3XiiXXrqLVtN02DSF3eRPDcs8r8/LuUgAce9N8P3fiua5vhrumaZbQIp+zNb3TSGQ543AqMcYoA6WiuY0K88WzWWoNrelaXbXSJm0S3umkWRsHhyVG0ZxSaZeeLpNBv5dR0rSodXT/j1giu2aKT/eYrkflQB1FFcvBeeLj4Ynmm0rS110PiO2W7YwsuRyX25BxntRLeeLh4Xjmi0rSm14yYe2N0whCZ6h9uc9O1AHUUVy+pXni5PD9lLp+laVLrDH/SYJbtliQc/dfbk9u1Lrl54ti07Tn0bS9LuLx1/0uOe6ZEjOB9whTu5zQBz/AMWPhxB4t8nVLCK0GvWsZjiNzEjxyoSMq+5T0AODjg15hJ8MdaRiDomkjnulv/8AGK9w1+78Vwy2A0PS9MuY3UG6NxdNGY24yFwp3DrTtau/FMWtWkekaZptxpjBftE09yySIc/NtUAg8e9AHhJ+GWtf9AbSP++YP/jFH/Csda/6A2kf98wf/GK93vbrxQnieGGz03TZNBO3zLmS5ZZhx82Exg/nQt14o/4SpoG03TR4fzxdC5bz8Y/uYx196APB/wDhWGtf9AfSP++YP/jFJ/wq/Wv+gPpH/fMH/wAYr3nTrrxQ/iW4h1DTdNi0MFvJuIrlmmb+7lMYGfrSaFd+KZtUvE1rTNMtrBQ32eW3uWkdznjcpAxxQB4P/wAKv1r/AKA+kf8AfMH/AMYpp+F2t/8AQI0j/vmD/wCMV7v4fu/Fky3/APbul6XbMiE2ot7ppPMbnAbKjaOlJo154ul0jUJNX0rS4NRRf9EigumeOQ4/jYqCvNAHiUfw88SrZtZfYLAWUjKZYYXhh80Bg20usG4AkDODXtHwx0e60Tw2LW+CiZpZJm2Z2gu7OVGeoG7Ge+Klsbzxc/hu7mvNK0uPW1b/AEe3jumaFxx959uR37UC88Xf8IuZzpWlf2/5mBbfa28nZnrv25zjtigDqKK5e7vPFy+Graa10rSn1xnxNbvdsIVXnkPtyT07UaveeLYtG0+TStK0ufU3/wCPuGa6ZI4+P4GC5bn2oA6iiuY1+78WQw6edD0vS7mV1zdi4umjEbccJhTuHWna9d+KodQsk0TTNMubNlH2mS4umjdDnkKADnigDpaK5zVLrxRH4itodN03TZtFbb51xLcssq/3sIBg4+tE114oHipYItN01vD+RuujcsJxxz8mMdfegDo6K5y1uvFDeKJYLnTdNTQAT5dylyxmIxxlMYHPvRo914ol166i1bTdNg0hd3kTw3LPK/Py7lIAHHvQB0dFc14fu/Fc1zfDXdM0y2gRT9ma3umkMhzxuBUY4xTdCvPFs1lqDa3pWl210iZtEt7ppFkbB4clRtGcUAdPRXL6ZeeLpNBv5dR0rSodXT/j1giu2aKT/eYrkflRBeeLj4Ynmm0rS110PiO2W7YwsuRyX25BxntQB1FFcvLeeLh4Xjmi0rSm14yYe2N0whCZ6h9uc9O1GpXni5PD9lLp+laVLrDH/SYJbtliQc/dfbk9u1AHUUVzGuXni2LTtOfRtL0u4vHX/S457pkSM4H3CFO7nNLr934rhlsBoel6ZcxuoN0bi6aMxtxkLhTuHWgDpq5/+yJv+E8Or/bB9n/s4Wv2XJzu8wtvxnHQ4qPWrvxTFrVpHpGmabPpjBftE09yySIc/NtUAg8e9T6b4dS08Varr0t1LcXN7HFAiOAFt4kz8i/ViST/AIUAbtFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/2Q==" alt="images/trans/tree-rewriter.png"><hr class="calibre17"><b class="calibre13">Figure 31. Model-driven translator with tree rewriting</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">From the AST input model, were going to learn how to derive an
appropriate output model instead of immediately generating
output. Simple print statements fall flat when the input and output
phrase orders dont line up. We really need to buffer up the
translated phrases and arrange them later in the proper order.  As we
walk the input model, well match subtrees and create output objects
to represent translated phrases (as summarized by Figure 33, <a href="#text/part0000_split_109.html.fig.build-model-generator"><em class="calibre6">Generator for model-driven translators</em></a>).</p><div class="calibre1" id="text/part0000_split_109.html.fig.build-model-generator"><img id="text/part0000_split_109.html.d24e34078" class="calibre24" src="data:image/jpeg;base64,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" alt="images/trans/build-output-model.png"><hr class="calibre17"><b class="calibre13">Figure 32. Generator for model-driven translators</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">These output objects can be mindless strings,
templates, or custom-built objects.  The key is organizing them into a
proper output model.</p><p height="10" width="0" class="calibre5">The structure of an output model is always a nested arrangement of
output objects. For example, in Figure 34, <a href="#text/part0000_split_109.html.fig.nested-output-model"><em class="calibre6">Nested output model for Java file</em></a>, we see a
hypothetical output model for a specific Java program. The overall <code class="calibre21">File</code> object embeds <code class="calibre21">Class</code> objects, which embed <code class="calibre21">Field</code> and <code class="calibre21">Method</code> objects, and so on. For large Java programs, this data
structure can be deeply nested.</p><div class="calibre1" id="text/part0000_split_109.html.fig.nested-output-model"><img id="text/part0000_split_109.html.d24e34100" class="calibre37" src="data:image/gif;base64,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" alt="images/trans/nested-output-model.png"><hr class="calibre17"><b class="calibre13">Figure 33. Nested output model for Java file</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Personally, I like to think of these nested structures as trees.   In Figure 35, <a href="#text/part0000_split_109.html.fig.hier-output-model"><em class="calibre6">Hierarchy view of nested output model for Java file</em></a>, we see the equivalent tree structure, which should
look familiar. Its a syntax (parse) tree. As we learned in Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>, a syntax tree represents the underlying syntactic structure
of a phrase.  My point is that using a hierarchy of output objects to
represent the output makes sense because its equivalent to a syntax
tree.</p><div class="calibre1" id="text/part0000_split_109.html.fig.hier-output-model"><img id="text/part0000_split_109.html.d24e34111" class="calibre37" src="data:image/gif;base64,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" alt="images/trans/hier-output-model.png"><hr class="calibre17"><b class="calibre13">Figure 34. Hierarchy view of nested output model for Java file</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">In this section, were going to learn about the different kinds of
output objects and why we need to create those objects in the first
place. After that, well dig into the mechanics of constructing output
model hierarchies.</p><h3 id="text/part0000_split_109.html.sec.creating-gen-obj" class="calibre23">Creating Target-Specific Generator Classes</h3><p height="10" width="0" class="calibre5">Because were programmers, we tend to write classes to solve problems.
For example, to generate SQL <code class="calibre21">CREATE TABLE</code> statements, it seems like
a good idea to design a <code class="calibre21">Table</code> class (see Pattern 31, <a href="#text/part0000_split_113.html.tip.gen-obj"><em class="calibre6">Target-Specific Generator Classes</em></a>). We can
then render it to text by calling its <tt class="calibre21">toString</tt> method.  This
approach works and feels very comfortable.</p><p height="10" width="0" class="calibre5">The problem is that its often a huge pain to create such output data
structures manually. Its easier just to emit the output directly
while walking the input model.  For example, lets say we want to
generate the Java bytecodes for a hello world <tt class="calibre21">main</tt> method.  To
create a bytecode output model for <tt class="calibre21">main</tt>, we can use 
the Byte Code Engineering Library (BCEL).  
Here is the sample code from the BCEL
manual<a id="text/part0000_split_109.html.FNPTR-47" href="#text/part0000_split_114.html.FOOTNOTE-47">[47]</a> to create the
method definition object:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MethodGen mg =</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> MethodGen(ACC_STATIC | ACC_PUBLIC, <em class="calibre6">// access flags</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b>.VOID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// return type</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> <b class="calibre13">Type</b><b class="calibre13">[]</b> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// argument types</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> <b class="calibre13">ArrayType</b>(<b class="calibre13">Type</b>.STRING, 1) },</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">new</b> <b class="calibre13">String</b><b class="calibre13">[]</b> { <em class="calibre6">"argv"</em> }, <em class="calibre6">// arg names</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">"main"</em>, <em class="calibre6">"HelloWorld"</em>,&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// method, class</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">an InstructionList</em>, <em class="calibre6">a ConstantPoolGen</em>);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">That seems like a lot of work just to define a method. All of these
constructor calls really add up quickly to a very large code
generator.  Rather than using these target-specific generator classes,
its easier to use a few print statements to generate a method definition
in a bytecode DSL.  For example, using the
Jasmin<a id="text/part0000_split_109.html.FNPTR-48" href="#text/part0000_split_114.html.FOOTNOTE-48">[48]</a>
bytecode assembler, heres what <tt class="calibre21">main</tt> looks
like:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.method public static main([Ljava/lang/String;)V</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">.end method&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This is much more clear.  Of course, we have to learn a tiny bit of
syntax, but thats easier than learning the vagaries of a library such
as BCEL.  The only strange bits are the <code class="calibre21">[Ljava/lang/String;</code> and <code class="calibre21">V</code>
strings, which are Java type encodings<a id="text/part0000_split_109.html.FNPTR-49" href="#text/part0000_split_114.html.FOOTNOTE-49">[49]</a>
representing an array of <code class="calibre21">String</code> objects and <code class="calibre21">void</code>,
respectively.</p><p height="10" width="0" class="calibre5">Aside from being a hassle, its usually not worth the development and
run-time cost to create a data structure when the input model itself is
close enough to be workable.  If we have an AST subtree, for example,
that represents the <tt class="calibre21">main</tt> method, theres no point in writing a
class like <code class="calibre21">MethodGen</code>. Heres a sample AST (Pattern 11, <a href="#text/part0000_split_050.html.tip.hetero"><em class="calibre6">Irregular Heterogeneous AST</em></a>) node for a
method definition:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">class</b> MethodNode <b class="calibre13">extends</b> StatNode {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> name;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Type</b> returnType;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">String</b>&gt; modifiers; <em class="calibre6">// public, static, final, ...</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;ArgNode&gt; args;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;BlockNode body;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">From that, we can directly generate the Jasmin code, letting Jasmin do
all of the work to emit the <code class="calibre21">.class</code> file:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> gen(MethodNode m) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// method node visitor</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">".method "</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">print m.modifiers</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(m.name+<em class="calibre6">"("</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (ArgNode a : m.args) gen(a); <em class="calibre6">// visit the arguments</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.print(<em class="calibre6">")"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">println m.returnType</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;gen(m.body);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// visit the method body</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(<em class="calibre6">".end method"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This principle also applies when we are generating high-level source
code, not bytecodes. For example, rather than building up objects that
represent Java program phrases such as <code class="calibre21">WhileStatement</code> and <code class="calibre21">AssignStatement</code>, we can just spit out Java code by walking the
AST. Here is how we could generate code for Java assignments using
Pattern 13, <a href="#text/part0000_split_059.html.tip.visitor"><em class="calibre6">External Tree Visitor</em></a>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">class</b> AssignNode <b class="calibre13">extends</b> ExprNode { <b class="calibre13">String</b> id; ExprNode valueExpr; }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> gen(AssignNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(n.id+<em class="calibre6">"="</em>); <em class="calibre6">// emit left-hand-side and '='</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;gen(n.valueExpr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// walk right-hand-side expression</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">System</b>.out.println(<em class="calibre6">";"</em>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// emit final ';'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, so we can save some work by generating text on the fly while
walking a suitable input model instead of creating an output model.
The bad news is that print statements dont always work.
</p><h3 class="calibre23">Print Statements Are Easy but Inflexible</h3><p height="10" width="0" class="calibre5">Visitors that directly emit text with print statements work fine as
long as the order of input and output constructs is very similar.  
The
order in which we visit input model nodes has to match the order  in
which we need to generate output. </p><p height="10" width="0" class="calibre5">This turns out to be pretty restrictive.  Take Java to C translation,
for example.  Because C doesnt allow forward references, we need to
generate a list of function declarations at the top of the output C
file:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">extern</b> <b class="calibre13">int</b> f(<b class="calibre13">float</b> y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// f declaration</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">extern</b> <b class="calibre13">void</b> g();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// g declaration</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> f(<b class="calibre13">float</b> y) { g(); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// f definition; forward reference to g()</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> g() {  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// g definition</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Without the <code class="calibre21">extern</code> declaration of <tt class="calibre21">g</tt>, a C compiler would
complain about the call to <tt class="calibre21">g</tt> inside <tt class="calibre21">f</tt>.  So, for each function,
we need to emit both a declaration and a definition. Our first  attempt
might look like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> gen(MethodNode m) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">compute and emit extern C declaration</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">translate Java body and emit C function</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Unfortunately, this wont work. The output  would  interleave the
declarations and definitions:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">extern</b> <b class="calibre13">int</b> f(<b class="calibre13">float</b> y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// f declaration</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">int</b> f(<b class="calibre13">float</b> y) { g(); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// f definition; forward reference to g()</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">extern</b> <b class="calibre13">void</b> g();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// g declaration; TOO LATE!</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> g() {  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// g definition</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Oops. We need all the declarations first. Somehow, we have to
separate when we translate phrases from when we spit them out.
</p><h3 id="text/part0000_split_109.html.sec.decoupling-input-output" class="calibre23">Decoupling Input Model Traversal from Output Order</h3><p height="10" width="0" class="calibre5">There are two ways to solve input-output ordering mismatches.  
First,
we can walk the tree twice, once for declarations and again for
definitions using two visitor methods:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> genDecl(MethodNode m) {<em class="calibre6">compute and emit extern C declaration</em>}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> genDef(MethodNode m)&nbsp;&nbsp;{<em class="calibre6">translate Java body and emit C function</em>}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This works but is inefficient because we have to walk the (potentially
very large) tree twice. This is an 
<em class="calibre6">output-driven</em> approach
because it pulls information from the input model according to the
output order.</p><p height="10" width="0" class="calibre5">The second choice is to walk the input model a single time, collecting
the declarations and definitions in lists instead of directly emitting
text:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> gen(MethodNode m) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">compute and add extern C declaration to a list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">translate Java body and add C function to a list</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Once weve got those two lists, we can emit the proper C file by
printing the lists one after the other.
This <em class="calibre6">input-driven</em> approach lets us decouple the
input and output order, albeit at the cost of buffering up the various
output pieces.  Its totally worth it, though. One of the most
important lessons Ive learned over the years is that
<em class="calibre6">we should compute information and translate phrases when its
convenient and efficient to do so, not when the output order demands
it</em>.</p><p height="10" width="0" class="calibre5">Lets see what the input-driven approach looks like. Instead of
printing on the fly, well create strings.  Heres a visitor method
that returns a string representing an assignment:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">String</b> gen(AssignNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> e = gen(n.valueExpr);&nbsp;&nbsp;<em class="calibre6">// walk right-hand-side expression</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> n.id + <em class="calibre6">"="</em> + e + <em class="calibre6">";"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Or, instead of writing the AST visitor manually, we could use Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign <b class="calibre13">returns</b> [String s]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'='</em> ID e=expression) {$s = $ID.text + <em class="calibre6">"="</em> + $e.s + <em class="calibre6">";"</em>;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">expression <b class="calibre13">returns</b> [String s] :  ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The point is that weve created the same text as we did in the
previous section. We just arent emitting it as we compute it.
Whoever calls method <tt class="calibre21">gen</tt> or rule <code class="calibre21">assign</code> can decide what to do
with the translated text.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Chess Analogy for Input- vs. Output-Driven Generation</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Setting up a chessboard involves putting the chess pieces in specific
locations on the board.  
We can think of the jumble of chess pieces as
the input model (an unsorted list of pieces). The output is a 2x8
matrix, assuming were  setting up only one players side.  The
output-driven approach marches through the output matrix
position by position. At each spot, it scans through the input model
looking for the right piece.  In contrast, the input-driven approach
simply places pieces in the right spot as it encounters them:</small></p></blockquote><div class="calibre1"><img id="text/part0000_split_109.html.d24e34851" class="calibre37" src="data:image/gif;base64,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" alt="images/trans/chess.png"></div><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">The dashed lines signify the output-driven generator searching for the
right piece.</small></p></blockquote></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">Lets review what weve learned so far. We know that the translation
process is about creating an input model, enriching it with semantic
information, and then creating an appropriate output model.
Target-specific generator classes are familiar and well-structured, but
building them is a lot of work, and theyre often a hassle to
use. Visitors that generate text directly are much more
convenient. Unfortunately, print statements lock the order of the
output elements to the input model traversal order.  Besides,
computing output strings in a general-purpose programming language
aint exactly pretty.</p><p height="10" width="0" class="calibre5">All is not lost, though. We can use templates, which are the best of
both worlds. A template is a text document with holes that we can
fill in.  Templates are specialized generator objects that support a
DSL designed for generating structured text. Well
explore templates in great detail in the next chapter.</p><p height="10" width="0" class="calibre5">In the meantime, lets finish off our discussion of the translation
process. We need to learn some of the engineering details involved in
creating output models.</p>

</div></div>
<div id="text/part0000_split_110.html"><div class="calibre">

<h2 id="text/part0000_split_110.html.d24e34860" class="calibre18">Constructing a Nested Output Model</h2><p height="10" width="0" class="calibre5">To build a translator, we need to look at the mechanics of matching an
input construct and creating the right output object. 
Then, we have to
figure out how to organize all those translated pieces into a
nested hierarchy.</p><h3 class="calibre23">Creating Output Objects from Input Phrase Components</h3><p height="10" width="0" class="calibre5">
    
    
    Translating an individual input phrase means creating the appropriate
output model object and injecting it with elements from the input
phrase.  
Heres what the assignment node example from the previous section
looks like using an AST visitor and a target-specific generator
object:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Statement</b> gen(AssignNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Expression</b> e = gen(n.valueExpr); <em class="calibre6">// walk right-hand-side expression</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> AssignmentStatement(n.id, e);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Notice that were not specifying the actual output literals. That
would hard-code the translation. It would also make our translator hard
to read because wed be mixing the syntax of two languages (that of
the implementation language and that of the output language).  When
using such explicit generator classes, the pipe between input and
output model is usually the constructor arguments.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Whetting Your Appetite for Templates</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">As a teaser for the next chapter,
      heres how wed use a template and
      an ANTLR tree grammar to map input patterns to output constructs:</small></p></blockquote><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;^('=' ID e=expression) -&gt; assign(id={$ID.text}, e={$e.st}) ;</code></span></div></td></tr></tbody></table></div><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">The rule matches an input assignment tree and creates an instance of
      the template called <code class="calibre21">assign</code>. The <code class="calibre21">assign</code> template definition might
      look like this:</small></p></blockquote><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign(id, e) ::= "&lt;id&gt; = &lt;e&gt;;"</code></span></div></td></tr></tbody></table></div><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">The names inside angle brackets are the holes we can fill in.
      Templates are like generator classes except that we only use  a single
      class called <code class="calibre21">StringTemplate</code>.</small></p></blockquote><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">For mapping <code class="calibre21">a x b</code> to the appropriate output constructs, we could use
      the following tree grammar rule with template constructors and a
      predicate:</small></p></blockquote><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// Match scalar a x b and matrix A x B multiplies in a math DSL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// Assume each node knows its result type. Each</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// rule also implicitly returns a template output model object.</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">mult:&nbsp;&nbsp; ^('x' a=expression b=expression)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; {<em class="calibre6">subexpressions have matrix types</em>}?</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrixMult(a={$a.st}, b={$b.st})</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; scalarMult(a={$a.st}, b={$b.st})</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">Mapping an assignment subtree to an assignment output object is
reasonably clear, so lets try something a little harder: translating
scalar and matrix multiplication. The syntax is the same for both, but
semantically, they are very different.  So, our translation method has
to test the type of these subexpressions in order to create the proper
output object.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Match scalar a x b and matrix A x B multiplies for a math DSL</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Assume nodes contain result types. match ^('x' expression expression)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Expression</b> gen(MultiplyNode n) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Expression</b> a = gen(n.left);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Expression</b> b = gen(n.right);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( <em class="calibre6">subexpressions have matrix types</em> )</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> MatrixMultiply(a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> ScalarMultiply(a, b);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <em class="calibre6">subexpressions have matrix types</em> conditional would test
the subexpression types stored in the AST nodes like we did in Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>.</p><p height="10" width="0" class="calibre5">To move things around locally within a phrase, all we have to do is
change some parameters. For example, we can change the order of scalar
multiplication operands by swapping the order of constructor
parameters: <code class="calibre21">ScalarMultiply(b, a)</code>. To send a translated phrase to a
radically different spot in the output, though, we need to figure out
how to organize the overall output model.
</p><h3 class="calibre23">Organizing Translated Phrases into a Nested Model</h3><p height="10" width="0" class="calibre5">To create an output model, we have to build up a nested data structure
composed of output objects. 
(For the purposes of this discussion,
well continue using specialized generator objects.) Lets start with
the easiest case where the input and output element orders match up.</p><p height="10" width="0" class="calibre5">Lets say weve got a Java method AST input model and want to create a
C# output model. Using a visitor, we could have all the methods
return an output object. An invoking visitor method would incorporate
the  return value into its own output object. For example, given a <code class="calibre21">MethodNode</code>, the following visitor method returns a  <code class="calibre21">Method</code>
object representing a C# method.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Method</b> gen(MethodNode m) { <b class="calibre13">return</b> <b class="calibre13">new</b> <b class="calibre13">Method</b>(m.id, gen(m.bodyBlock)); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This visitor method injects the name and translated body returned from
<code class="calibre21">gen(m.bodyBlock)</code> into the <code class="calibre21">Method</code> instance. The following visitor
method handles the body translation:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Block gen(BlockNode b) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">Statement</b>&gt; stats = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">Statement</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (StatementNode s : b.stats) stats.add( gen(s) );</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> Block(stats);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It queues up the translated statements and injects them into the <code class="calibre21">Block</code> return value. Among the statement subtree visitor methods, wed
have something like the following to translate assignments:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">AssignStatement gen(AssignNode a) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> <b class="calibre13">new</b> AssignStatement(a.id, gen(a.expr));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now lets deal with the situation where the output element order
differs from the input order. As we saw in <a href="#text/part0000_split_109.html.sec.decoupling-input-output"><em class="calibre6">Decoupling Input Model Traversal from Output Order</em></a>, translating Java to C code requires that we
generate a declaration for each function definition. Most important,
those declarations must appear before all the function definitions.
To translate a Java class to C, we need to generate the following
strict sequence.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">#include &lt;stdio.h&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">struct</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// has all fields extracted from Java class</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">declarations</em>&nbsp;&nbsp;// function declarations from Java methods</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">definitions</em>&nbsp;&nbsp; // function definitions from Java methods</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_110.html.fig.c-output-model"><img id="text/part0000_split_110.html.d24e35204" class="calibre22" src="data:image/gif;base64,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" alt="images/trans/c-output-model.png"><hr class="calibre17"><b class="calibre13">Figure 35. Assembling a C file model using Java AST visitor</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5"> The output model
is shown graphically in Figure 36, <a href="#text/part0000_split_110.html.fig.c-output-model"><em class="calibre6">Assembling a C file model using Java AST visitor</em></a>, which also shows how visitor methods would fill
the model.  One of the key elements of the code fragment is the
global <code class="calibre21">cfile</code> variable.  In
general, translators need to track a few locations in the output
model. These locations are typically things such as the current file
object, the current class object, or the current method object. Its
like remembering where the refrigerator and spice cabinets are in
your kitchen.  They tell you where to put things and effectively
organize your kitchen.</p><p height="10" width="0" class="calibre5">The visitor method for <code class="calibre21">ClassNode</code>s indirectly triggers the other
two visitor methods for field and method nodes. Those methods need to
inject data into the model starting at the root (the outermost output
object). The visitor methods dont bother returning output objects
because they can directly inject elements. (In my experience, youll
have some visitor methods that return output objects and some that
dont.)</p><p height="10" width="0" class="calibre5">When the visitor finishes walking the input model, we can generate
code by calling <tt class="calibre21">toString</tt> on the
root, <code class="calibre21">cfile</code>. That, in turn, renders its
embedded objects with <tt class="calibre21">toString</tt>, and so on,
recursing down the output object hierarchy. And with
that <tt class="calibre21">toString</tt> call, we finish the story of
how we translate text using the model-driven approach.
</p><p height="10" width="0" class="calibre5">At this point, youre familiar with the three translation
strategies. Youve also learned a lot about the model-driven
approach. We learned that print statements arent always powerful
enough but that they are much easier to use than writing specific
output classes. In the next chapter, well see that templates are
often a good compromise between the two. They let us construct the
nested output models we need without having to define a new class for
every output construct. Before we get there, though, lets formally
define the patterns weve talk about in this chapter:
</p><table class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Pattern</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">When to Apply</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This pattern is the simplest mechanism because
it uses print statements to generate output rather than creating an
output model.  
Use this pattern if you can get away with it. In other words,
if you dont need information appearing later in the input,
syntax-directed translation works.  These translators also cannot
generate output in a radically different order from the
input.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 30, <a href="#text/part0000_split_112.html.tip.rule-based"><em class="calibre6">Rule-Based Translator</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Rule-based systems are elegant but often difficult to
learn. 
They are also black boxes, which can make it difficult to
debug translators. At the very least, it makes some programmers
uncomfortable.  In the hands of programmers with very strong
theoretical backgrounds, these systems often prove extremely
powerful.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5">Pattern 31, <a href="#text/part0000_split_113.html.tip.gen-obj"><em class="calibre6">Target-Specific Generator Classes</em></a></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">This pattern represents the final output model for a model-driven
translator. 
Each output language construct corresponds to a specific
class. The fields of an output object track any embedded output
objects.
</p></div></td></tr></tbody></table><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_111.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_111.html.tip.syntax-directed" class="pagebreak2"><small class="calibre35">Pattern 29:</small>&nbsp;&nbsp;&nbsp;Syntax-Directed Translator</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern generates text using a grammar, or equivalent
hand-built parser, embedded with actions.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Syntax-directed translators are little more than grammars salted with
actions (code snippets).  They dont build internal models and then
walk them to generate output.</p><p height="10" width="0" class="calibre5">Putting actions directly in a grammar sometimes makes the grammar
difficult to read. It also locks the grammar into a single bit of
translator functionality. Its often a good idea to disentangle
actions from the grammar by following what we did in Pattern 26, <a href="#text/part0000_split_100.html.tip.bytecode-asm"><em class="calibre6">Bytecode Assembler</em></a>
(another example of a syntax-directed translator).  The assembler
grammar defined placeholder methods that describe the translator
functionality:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void gen(Token instrToken) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void gen(Token instrToken, Token operandToken) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">protected void defineFunction(Token idToken, int nargs, int nlocals) {;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, the actions in the grammar invoked these methods to trigger
translation:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">instr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ID NEWLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {gen($ID);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID operand NEWLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {gen($ID,$operand.start);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To implement the translation, we created a subclass that defined the
concrete methods:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** Subclass the AssemblerParser to actually implement the necessary</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> *&nbsp;&nbsp;symbol table management and code generation functions. */</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class BytecodeAssembler extends AssemblerParser {}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we wanted to make it easier to change the behavior of the
translator on the fly, we could pass in a strategy object. Wed move
the placeholder methods into an interface such as <code class="calibre21">AssemblerBehavior</code>. The actions would then look like this:
<code class="calibre21">behavior.gen($ID)</code> instead of just <code class="calibre21">gen($ID)</code>. Wed pass <code class="calibre21">behavior</code> in from the object using the assembler. In the next section,
well follow this approach for our sample implementation.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Lets now implement a <code class="calibre21">make</code>-like build dependency DSL that translates
input like the following to an equivalent Java program:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">target-file</em> : <em class="calibre6">dependencies</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">action(s) that create target-file</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For example, here are some rules from the sample <code class="calibre21">makefile</code> included
in the source directory:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">t.o : t.c&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc -c -o t.o t.c</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">go: t.o u.o&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc -o go t.o u.o</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo done</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Our goal is to generate <code class="calibre21">makefile.java</code> from file <code class="calibre21">makefile</code>. The
entire process looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># build translator tool</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Maker makefile&nbsp;&nbsp;</b><em class="calibre6"># translate makefile to makefile.java</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac makefile.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Once weve got an executable version of <code class="calibre21">makefile</code>, we can ask it to
build the targets. By asking it to make target <code class="calibre21">go</code>, it has to first
build the <code class="calibre21">t.o</code> and <code class="calibre21">u.o</code> dependencies. Then it can create the <code class="calibre21">go</code>
file:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java makefile go&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># build target "go"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(t.o): gcc -c -o t.o t.c</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(u.o): gcc -c -o u.o u.c</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(go): gcc -o go t.o u.o</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(go): echo done</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">done&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we run the same target again, it gives no output because <code class="calibre21">go</code> now
exists and is newer than its dependencies:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java makefile go&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># nothing to do now</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java makefile clean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b><em class="calibre6"># wipe out all files</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(clean): rm t.o u.o go</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java makefile clean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b><em class="calibre6"># oops, files are already cleaned up</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(clean): rm t.o u.o go</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rm: t.o: No such file or directory</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rm: u.o: No such file or directory</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rm: go: No such file or directory</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java makefile go&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b><em class="calibre6"># build again</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">build(t.o): gcc -c -o t.o t.c</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As you can see, <code class="calibre21">makefile</code> collects and emits any standard output
and standard error from the actions (processes) it executes.</p><h4 class="calibre26">Building Support Code and Defining the Translation</h4><p height="10" width="0" class="calibre5">There are two key components to implementing this DSL: the translator
itself and the run-time support. 
Before we can figure out how to build
the translator component, we need to create the run-time support and
manually translate a make file to Java code.</p><p height="10" width="0" class="calibre5">Lets create an object to represent a make target, with all of its
dependencies and actions:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/Target.java">trans/make/Target.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Target {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> name;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">String</b>&gt; actions = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">String</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">String</b>&gt; dependencies = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">String</b>&gt;();</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then we need a dictionary that maps target names to <code class="calibre21">Target</code> objects
and a <tt class="calibre21">build</tt> method to build a particular target. Lets stick all of
this in <code class="calibre21">MakeSupport</code>. The details of walking the dependency list
and checking file system timestamps arent important here. We can
assume the support code just works.</p><p height="10" width="0" class="calibre5">Now, lets figure out the translation. We can get away with a
syntax-directed translator because we can generate appropriate Java
code as we read the build instructions.  Lets start by mapping a
sample target to Java code.</p><p height="10" width="0" class="calibre5">Given the <code class="calibre21">t.o</code> target rule, we need to
generate something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">target = new Target("t.o");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">target.addDependency("t.c");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">target.addAction("gcc -c -o t.o t.c");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">targets.put("t.o", target);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We also need to wrap that in a method within a class like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.io.IOException;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class <em class="calibre6">makefile-name</em> extends MakeSupport {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public <em class="calibre6">makefile-name</em>() throws IOException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target target = null;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">code-for-targets</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The name of the class is the same as the input file, such as <code class="calibre21">makefile</code>.  Also in that class, we need to make a <tt class="calibre21">main</tt> that creates
an instance of the generated object. Then, we can ask it to build
a target specified on the command line:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">makefile m = new makefile();&nbsp;&nbsp;// create Target dictionary</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">int r = m.build(args[0]);&nbsp;&nbsp;&nbsp;&nbsp; // build the target</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">System.exit(r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exit with code from target build</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">So, thats what the translation looks like. Now we have to build a
grammar that automates it by triggering code generation actions.
</p><h4 class="calibre26">Building the Translator</h4><p height="10" width="0" class="calibre5">With some foresight, we can spec out the list of actions to trigger
and put them into an interface:
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/MakeGenerator.java">trans/make/MakeGenerator.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">interface</b> MakeGenerator {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> start();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> finish();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> target(<b class="calibre13">String</b> t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> dependency(<b class="calibre13">String</b> d);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> action(<b class="calibre13">String</b> a);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">void</b> endTarget(<b class="calibre13">String</b> t);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This means we have to pass a <code class="calibre21">MakeGenerator</code> object into the
ANTLR-generated parser:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/Make.g">trans/make/Make.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@members</b> {&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MakeGenerator gen;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> MakeParser(TokenStream input, MakeGenerator gen) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;super(input);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;this.gen = gen;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets write a grammar for our <code class="calibre21">make</code>-like
DSL. A make file looks like a series of rules:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/Make.g">trans/make/Make.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; {gen.start();} rule+ {gen.finish();}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To generate the header and trailer of the Java class, we trigger <tt class="calibre21">start</tt> and <tt class="calibre21">finish</tt> methods.</p><p height="10" width="0" class="calibre5">Each rule has a target file name, an optional list of file
dependencies, and at least one action:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/Make.g">trans/make/Make.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; target=ITEM <em class="calibre6">':'</em>&nbsp;&nbsp;&nbsp;&nbsp; {gen.target($target.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i=ITEM {gen.dependency($i.text);})* <em class="calibre6">'\n'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ACTION {gen.action($ACTION.text);})+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{gen.endTarget($target.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'\n'</em> <em class="calibre6">// ignore blank lines</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Once we match the target name, we trigger <tt class="calibre21">target</tt>. Then, we trigger
<tt class="calibre21">dependency</tt> for each file dependency and <tt class="calibre21">action</tt> for each action
we find. The <tt class="calibre21">endTarget</tt> trigger gives us the hook to generate the <tt class="calibre21">put</tt> to the <code class="calibre21">targets</code> dictionary.</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Building an Interpreted Version</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Some of you might be wondering how we could interpret rather than
      translate a <code class="calibre21">makefile</code>. 
      The idea would be to create a dictionary full
      of <code class="calibre21">Target</code> objects as an internal model.  Wed need grammar actions to
      create <code class="calibre21">Target</code> objects and set dependencies and actions:</small></p></blockquote><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rule:&nbsp;&nbsp; target=ITEM <em class="calibre6">':'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Target t = new Target($target.text);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i=ITEM {t.addDependency($i.text);})* <em class="calibre6">'\n'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ACTION {t.addAction($ACTION.text);})+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{targets.put(t.name, t);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'\n'</em> <em class="calibre6">// ignore blank lines</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div></div><hr class="calibre17"></div><p height="10" width="0" class="calibre5">The code generation implementations are messy (without templates) but
straightforward. For example, here is what we generate upon the <tt class="calibre21">start</tt> trigger:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/JavaGenerator.java">trans/make/JavaGenerator.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> start() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;out.println(</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">"import java.io.IOException;</em>\n<em class="calibre6">"</em> +</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">"class "</em>+makefile+<em class="calibre6">" extends MakeSupport {</em>\n<em class="calibre6">"</em> +</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">"&nbsp;&nbsp;&nbsp;&nbsp;public "</em>+makefile+<em class="calibre6">"() throws IOException {</em>\n<em class="calibre6">"</em> +</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target target = null;</em>\n<em class="calibre6">"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The majority of the methods are much smaller. Heres how we respond
to <tt class="calibre21">target</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/JavaGenerator.java">trans/make/JavaGenerator.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">void</b> target(<b class="calibre13">String</b> t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;t = t.trim();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;out.println(<em class="calibre6">"</em>\t<em class="calibre6">target = new Target(</em>\"<em class="calibre6">"</em>+t+<em class="calibre6">"</em>\"<em class="calibre6">);"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The translator <tt class="calibre21">main</tt> program lives in <code class="calibre21">Maker</code>. It creates the
ANTLR-generated parser and lexer as usual but passes in a <code class="calibre21">JavaGenerator</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/make/Maker.java">trans/make/Maker.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">JavaGenerator gen = <b class="calibre13">new</b> JavaGenerator(makefileName);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">MakeParser p = <b class="calibre13">new</b> MakeParser(tokens, gen);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">try</b> { p.rules(); } <em class="calibre6">// parse, triggering code generation actions</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Other than support code, thats all there is to it.  Our parser
directly generates Java code that implements a make DSL. We compile
it and run it like any other Java program.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern is sort of a degenerate version of a model-driven
translator. We can think of the tokens as the input model and the
generated text as the output model.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_112.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_112.html.tip.rule-based" class="pagebreak2"><small class="calibre35">Pattern 30:</small>&nbsp;&nbsp;&nbsp;Rule-Based Translator</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">A rule-based translator expresses a translation with a set
of <em class="calibre6">x</em> becomes <em class="calibre6">y</em> rules, written in the DSL of a
pattern-matching engine.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">To use a rule-based system, we have to feed it two things: a grammar
that describes input sentences and a set of translation rules.  The
reason we need the grammar is to get a Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>.  The
parse tree concretely defines what the various phrases and subphrases
are.  Thats how they can avoid applying transformations inside comments
in the input stream, for example.  Although it looks like were doing
text-to-text transformations, the underlying engine is actually doing
tree rewrites.</p><p height="10" width="0" class="calibre5">For complicated translators, we need to build a lot of ancillary data
structures beyond trees such as symbol tables and control-flow graphs
(that tell us which statements can get to other statements). We can do
all of that and then have the engine execute our transformation rules
based upon these data structures.</p><p height="10" width="0" class="calibre5">In practice, I use rule-based translators when I dont have or dont
need a full grammar. Most of the time Im extracting or translating
just some of the input phrases.  To work without a full grammar
describing the entire input, the elements have to be easy to identify
lexically (with special characters) or with a simple grammatical
structure. For example, the ANTLR website has an example fuzzy Java
parser that extracts class, method, variable definitions, and method
call sites.<a id="text/part0000_split_112.html.FNPTR-50" href="#text/part0000_split_114.html.FOOTNOTE-50">[50]</a></p><p height="10" width="0" class="calibre5">Since weve already looked at tree transformations, lets see what we
can do with a set of lexical rules.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">Lets translate the syntax of a simple wiki to HTML. 
This is actually
sort of tricky, which you might not expect. Translating <code class="calibre21">*foo*</code> to
<code class="calibre21">&lt;b&gt;foo&lt;/b&gt;</code> doesnt seem that hard. But, bullet lists and tables take
some thought.</p><h4 class="calibre26">Defining a Wiki Syntax</h4><p height="10" width="0" class="calibre5"> 
    
    Lets start by defining some wiki syntax in the following table; then well look 
    at a sample translation.</p><table id="text/part0000_split_112.html.fig.wiki-lang" class="calibre7"><tbody><tr class="calibre15"><th class="calibre42"><b class="calibre13"><p class="calibre5">Syntax</p></b></th><th class="calibre42"><b class="calibre13"><p class="calibre5">Description</p></b></th></tr></tbody><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><em class="calibre6">first-line-of-file</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">The first line of
text in the file is the title of the page.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">*</code><em class="calibre6">text</em><code class="calibre21">*</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Bold <em class="calibre6">text</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">_</code><em class="calibre6">text</em><code class="calibre21">_</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Italics <em class="calibre6">text</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">@</code><em class="calibre6">url</em><code class="calibre21">@</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Link to <em class="calibre6">url</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">@</code><em class="calibre6">url</em><code class="calibre21">|</code><em class="calibre6">text</em><code class="calibre21">@</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">Link to <em class="calibre6">url</em>
and make the link text be <em class="calibre6">text</em>.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">###</code>&nbsp;<em class="calibre6">title</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">&lt;h1&gt;</code> header.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">##</code>&nbsp;<em class="calibre6">title</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">&lt;h2&gt;</code> header.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">#</code>&nbsp;<em class="calibre6">title</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">&lt;h3&gt;</code> header.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">*</code>&nbsp;<em class="calibre6">item</em></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">A <code class="calibre21">&lt;ul&gt;</code> bullet list
item. The <code class="calibre21">*</code> must start at the left edge.</p></div></td></tr><tr class="calibre9"><td class="calibre11"><div class="calibre1"><p class="calibre5"><code class="calibre21">[</code><em class="calibre6">rows</em><code class="calibre21">]</code></p></div></td><td class="calibre11"><div class="calibre1"><p class="calibre5">A table full of rows,
separated by <code class="calibre21">--</code> on a line by itself. Separate columns with <code class="calibre21">|</code>.</p></div></td></tr></tbody></table><p height="10" width="0" class="calibre5"> File <code class="calibre21">t.wiki</code> in the source directory
exercises the various wiki features.  With a little help from a CSS
file, our translator generates HTML that renders like the image in
Figure 37, <a href="#text/part0000_split_112.html.fig.wiki-html"><em class="calibre6">HTML translated from t.wiki</em></a>.</p><div class="calibre1" id="text/part0000_split_112.html.fig.wiki-html"><img id="text/part0000_split_112.html.d24e36338" class="calibre2" src="data:image/jpeg;base64,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" alt="images/trans/wiki-html.png"><hr class="calibre17"><b class="calibre13">Figure 36. HTML translated from <code class="calibre21">t.wiki</code></b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5">Our translator treats the first line of text as the title of the page.
Within the file, we need to put a blank line before paragraphs, bullet
lists, sections, and tables. Heres a sample bullet list:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">* E pluribus unum</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">* Emeritus&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">* Ergo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">A blank line terminates the list. Tables live inside square
brackets. The <code class="calibre21">--</code> row separator has to be on a line by itself to make it
more obvious. <code class="calibre21">|</code> is the column separator. Heres a sample table:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">row 1 col 1 | row 1 col 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">row 2 col 1 | row 2 col 2</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You can take a look at the <code class="calibre21">t.wiki</code> file to see a nested table and
examples of italics elements, and so on.  Any text other than the wiki
syntax should pass through unchanged. Thats one of the benefits of
this method. We dont have to specify the syntax of the entire file,
just the parts we care about.</p><p height="10" width="0" class="calibre5">This isnt the most sophisticated wiki in the world, but its
complicated enough to give the rule-based approach a workout. This
example is highly ANTLR-specific, but any rule-based solution will
have to deal with the DSL and details of a particular tool.
</p><h4 class="calibre26">Defining the Translation Rules and Main Program</h4><p height="10" width="0" class="calibre5">Our implementation consists of only two files: a grammar full of
lexical rules and a main program that sets things up. Heres the core
of the main program:
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/WikiToHTML.java">trans/wiki/WikiToHTML.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">header(out);&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Wiki lex = <b class="calibre13">new</b> Wiki(<b class="calibre13">new</b> ANTLRReaderStream(fr), out);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">try</b> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Token t = lex.nextToken();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">while</b> ( t.getType() != Token.EOF ) t=lex.nextToken();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">finally</b> { fr.close(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">trailer(out);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Since this is still a lexer, 
we need to loop around a call to <tt class="calibre21">nextToken</tt>. This forces the lexer to consume all the input.  Before and
after this loop, we call <tt class="calibre21">header</tt> and <tt class="calibre21">trailer</tt> to spit out the HTML
file header and trailer.
The grammar will be an ANTLR <code class="calibre21">lexer</code> grammar with option <code class="calibre21">filter</code>
turned on. This tells ANTLR to try the rules in order.  So, if an
input chunk matches more than one rule, it will match to the first
rule.  As a catchall, weve got an <code class="calibre21">ELSE</code> rule at the end that copies
the input character to the output:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">ELSE:&nbsp;&nbsp; c=. {out.print((char)$c);} ; <em class="calibre6">// match any char and emit</em></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Theres a number of interesting things going on in this
grammar:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span>Were using semantic predicates to turn rules on and off depending
on the line number or character position within a line. Syntax
<code class="calibre21">{</code><em class="calibre6">expr</em><code class="calibre21">}?</code> is a semantic predicate that provides extra
information about the viability of a rule. Since ANTLR  uses
semantic predicates only if syntax alone is insufficient, we need to use a
special version of a semantic predicate: <code class="calibre21">{</code><em class="calibre6">expr</em><code class="calibre21">}?=&gt;</code>. The
extra <code class="calibre21">=&gt;</code> forces ANTLR to always test the predicate when choosing
viable rules.</li><li height="6" class="calibre20"><span></span>We need to keep some state information like were in a
bullet list.</li><li height="6" class="calibre20"><span></span>We use recursion (in a lexer) to allow nested tables.  Rule
<code class="calibre21">TABLE</code> calls <code class="calibre21">ROW</code>, which calls
<code class="calibre21">COL</code>, which matches a bunch of
<code class="calibre21">TABLE_CONTENT</code>. Rule
<code class="calibre21">TABLE_CONTENT</code> matches everything up until the end
of a column. Within that text, it looks for nested tables and bold or
italics items.</li></ul><p height="10" width="0" class="calibre5">Our first rule matches the title by matching a single line of text as
long as it occurs on the first line of the file:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TITLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; {getLine()==1}?=&gt; TAIL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{out.println(<em class="calibre6">"&lt;title&gt;"</em>+$TAIL.text+<em class="calibre6">"&lt;/title&gt;"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Rule <code class="calibre21">TAIL</code> is a helper (<code class="calibre21">fragment</code>) rule that matches any
character other than a newline:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">fragment</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TAIL : ~<em class="calibre6">'\n'</em>+ ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">ANTLR tries only the nonfragment rules when looking for a
match. Normal (nonfragment) rules have to call fragment rules
explicitly.  <code class="calibre21">TAIL</code> is in a separate rule because its convenient to
say <code class="calibre21">$TAIL.text</code> in <code class="calibre21">TITLE</code>.</p><p height="10" width="0" class="calibre5">Since both the bold and bullet list items start with <code class="calibre21">*</code>, we have to
distinguish them.  According to our syntax, bullet list items have to
start at the left edge. So, rule <code class="calibre21">BOLD</code> is only applicable  when its
not on the left edge:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BOLD:&nbsp;&nbsp; {getCharPositionInLine()&gt;0}?=&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">'*'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{out.print(<em class="calibre6">"&lt;b&gt;"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c=~<em class="calibre6">'*'</em> {out.print((char)$c);})+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">'*'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{out.print(<em class="calibre6">"&lt;/b&gt;"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This rule matches <code class="calibre21">*</code> followed by any non-<code class="calibre21">*</code> characters followed by a
terminating <code class="calibre21">*</code> character. As it matches characters, it spits them to
the output stream.</p><p height="10" width="0" class="calibre5">Many of our wiki constructs have to appear after a blank line (bullet
lists, sections, tables, and regular paragraphs):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">BLANK_LINE&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'\n\n'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {out.println(<em class="calibre6">"\n"</em>); closeList(); }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp; UL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; SECTION</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; TABLE</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">/* paragraph */</em>&nbsp;&nbsp;{out.println(<em class="calibre6">"&lt;p&gt;"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The call to <tt class="calibre21">closeList</tt> makes sure that any
prior lists have their terminating <code class="calibre21">&lt;/ul&gt;</code>
tag.  We can easily generate the starting
<code class="calibre21">&lt;ul&gt;</code> tag when we match the first bullet
list item after a blank line.  Rule <code class="calibre21">BLANK_LINE</code>
invokes <code class="calibre21">UL</code> after matching
<code class="calibre21">\n\n</code>.  Heres <code class="calibre21">UL</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">fragment</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">UL: <em class="calibre6">'* '</em> {out.print(<em class="calibre6">"&lt;ul&gt;\n&lt;li&gt;"</em>); context.push(<em class="calibre6">"ul"</em>);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rules track context using a <code class="calibre21">context</code> stack.  We only need to
worry about bullet list context, but we could add numbered lists and
so on. When the stack is empty, were not in a special context.
A blank line after a bullet list item terminates the list. At that blank
line, then, we need to check for unterminated lists, which is the reason for the call
to <tt class="calibre21">closeList</tt> in <code class="calibre21">BLANK_LINE</code>. That method pops the top context and
ends that element by emitting the proper HTML tag:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Stack&lt;String&gt; context = new Stack&lt;String&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void closeList() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( context.size()==0 ) return;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;String list = context.pop();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;out.println(<em class="calibre6">"&lt;/"</em>+list+<em class="calibre6">"&gt;"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The bullet items beyond the first one can emit <code class="calibre21">&lt;li&gt;</code> tags without
worrying about context:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">LI: {getCharPositionInLine()==0}?=&gt;<em class="calibre6">'* '</em>&nbsp;&nbsp;{out.print(<em class="calibre6">"&lt;li&gt;"</em>);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now lets figure out how nested tables work. We need recursive rules,
which ANTLR fortunately supports even among lexical rules. The
overall table structure looks like this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">fragment</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'['</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {out.print(<em class="calibre6">"&lt;table border=1&gt;\n"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROW (<em class="calibre6">'\n--\n'</em> ROW)* <em class="calibre6">'\n'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">']'</em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {out.print(<em class="calibre6">"\n&lt;/table&gt;"</em>);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Eventually, <code class="calibre21">TABLE</code> invokes <code class="calibre21">TABLE_CONTENT</code>, which can include
another (nested) table.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">fragment</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">TABLE_CONTENT</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; TABLE</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; BOLD&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ITALICS</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; {!upcomingEndOfCol()}?=&gt; c=. {out.print((char)$c);}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The last alternative matches anything not matched by the other
alternatives.  The predicate <code class="calibre21">!upcomingEndOfCol()</code> ensures that we
match characters only until we see the end of a column or table
coming. <tt class="calibre21">upcomingEndOfCol</tt> manually checks up to three characters
ahead to make sure we dont consume too much in <code class="calibre21">TABLE_CONTENT</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/wiki/Wiki.g">trans/wiki/Wiki.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">boolean upcomingEndOfCol() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;return input.LA(1)==<em class="calibre6">'|'</em> ||</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (input.LA(1)==<em class="calibre6">'\n'</em>&amp;&amp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(input.LA(2)==<em class="calibre6">'-'</em>&amp;&amp;input.LA(3)==<em class="calibre6">'-'</em>)||input.LA(2)==<em class="calibre6">']'</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This sample implementation illustrates what a rule-based system
looks like, but its nowhere near as sophisticated as the rule engines
we mentioned in the introductory material for this chapter. That said,
this lexical filter mechanism is easier to learn and still very
useful.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">This pattern lets us specify only those patterns we care about, just
like we did with trees in Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>. Most rule-based
translation engines internally use Pattern 8, <a href="#text/part0000_split_047.html.tip.parse-tree"><em class="calibre6">Parse Tree</em></a>. The sample
implementation for this pattern uses an <em class="calibre6">LL(k)</em> version of Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>.
</p><hr height="18" class="calibre17">
</div></div>
<div id="text/part0000_split_113.html"><div class="calibre">

<h1 height="0" id="text/part0000_split_113.html.tip.gen-obj" class="pagebreak2"><small class="calibre35">Pattern 31:</small>&nbsp;&nbsp;&nbsp;Target-Specific Generator Classes</h1><hr class="calibre17"><h3 class="calibre23">Purpose</h3><p height="10" width="0" class="calibre5"> <em class="calibre6">This pattern describes a class library whose sole purpose is
to represent and generate output constructs in a particular
language.</em>
</p><h3 class="calibre23">Discussion</h3><p height="10" width="0" class="calibre5">Rather than use print statements to generate programs or data,
generator classes let us insulate application code from the exact
syntax of an output language.  In that sense, they are similar to
templates. The difference is, were defining a special class for each
output element, whereas, with templates, we use a single <code class="calibre21">StringTemplate</code> class.  In both cases, the objects hold the data
necessary to generate the associated output constructs. The only
(minor) advantage to using specialized generator classes is that we
can name the data fields.</p><p height="10" width="0" class="calibre5">Each generator class has a method, usually <tt class="calibre21">toString</tt>, that renders
the object to text in the right format. The typical generator class
look something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class <em class="calibre6">OutputConstruct</em> {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">field1</em>&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">field2</em>&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">fieldN</em>&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public <em class="calibre6">OutputConstruct</em>(<em class="calibre6">field args</em>) { <em class="calibre6">set fields</em> }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public String toString() { <em class="calibre6">compute string from fields</em> }</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Lets think about generating HTML. We could build a library with
classes such as <code class="calibre21">Document</code>, <code class="calibre21">Head</code>, <code class="calibre21">Title</code>, <code class="calibre21">Table</code>, <code class="calibre21">ListItem</code>, and so on. <code class="calibre21">Title</code> instances would hold a <code class="calibre21">title</code> string,
for example.  Its <tt class="calibre21">toString</tt> method would emit <code class="calibre21">&lt;title&gt;</code><em class="calibre6">a-title</em><code class="calibre21">&lt;/title&gt;</code>.</p><p height="10" width="0" class="calibre5">Its reasonable to make generator classes handle slight differences in
the output language, such as different versions of HTML. But,
its best not to think of these generator classes as generating
radically different output according to some parameter.  These classes
are part of the output model. Their job is simply to emit text in the
right format, not perform a translation.</p><h3 class="calibre23">Implementation</h3><p height="10" width="0" class="calibre5">To demonstrate generator classes, lets build <code class="calibre21">Table</code> and <code class="calibre21">Column</code>
classes to represent SQL table creation statements. 
An SQL table needs
to know the table name and the list of columns:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class Table {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;String name; // SQL table name</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Column&gt; columns = new ArrayList&lt;Column&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public String toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer buf = new StringBuffer();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append("CREATE TABLE "+ name+" (\n");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Column c : columns) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( i&gt;0 ) buf.append(",\n");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append("&nbsp;&nbsp;&nbsp;&nbsp;"); // indent a bit</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(c);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.append(");\n");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return buf.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For each column, we need to know its name, its type, and the list of
attributes like <code class="calibre21">NOT NULL</code> and <code class="calibre21">UNIQUE</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class Column {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;String name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SQL column name</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;String type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SQL column type</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; attrs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SQL column attributes</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public String toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer attrBuf = new StringBuffer();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i = 0;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (String a : attrs) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( i&gt;0 ) attrBuf.append(", ");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attrBuf.append(a);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name+" "+type+" "+attrBuf.toString();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To use these classes, we create a <code class="calibre21">Table</code> and then <code class="calibre21">Column</code>
instances for each column and fill in their fields.  To generate text,
wed print the result of calling <tt class="calibre21">toString</tt> on the <code class="calibre21">Table</code> instance.</p><p height="10" width="0" class="calibre5">Instead of creating strings in <tt class="calibre21">toString</tt>, we could use templates. In
that case, though, we might as well avoid the special generator
classes and just use templates all by themselves.
</p><h3 class="calibre23">Related Patterns</h3><p height="10" width="0" class="calibre5">These generator classes are sort of like hard-coded templates.
</p>

</div></div>
<div id="text/part0000_split_114.html"><div class="calibre">

<h2 id="text/part0000_split_114.html.d24e37146" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">This chapter gives you the big picture on computer language
translation. In the next chapter, were going to drill down further into
the model-driven approach. Well learn how to use templates to
generate a number of DSLs and programming languages.  The examples feed
off of a variety of input models to create template-based output
models.</p><p height="10" width="0" class="calibre5">Before we move on, let me highlight the two important lessons from
this chapter. First, to properly translate an input phrase, we cant
just cleverly replace input symbols with output symbols. We have to
fully understand the input syntactically and semantically and then
pick the proper output construct. Second, when using the model-driven
approach, we need to decouple input model traversal order from the
order dictated by the output language. This input-driven approach lets
us compute information and translate phrases when its convenient and
efficient to do so.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-38" href="#text/part0000_split_106.html.FNPTR-38">[38]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/pages/viewpage.action?pageId=1773">http://www.antlr.org/wiki/pages/viewpage.action?pageId=1773</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-39" href="#text/part0000_split_106.html.FNPTR-39">[39]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">Ill never forget trying to learn French by
reading comic books. It took me forever to figure out why the cartoons
had Bread! Bread! stamped all over them during action
scenes. It turns out that <em class="calibre6">Pain!  Pain!</em>
sounds like Bang!  Bang! and is the way to say it in
French.</p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-40" href="#text/part0000_split_108.html.FNPTR-40">[40]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.meta-environment.org">http://www.meta-environment.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-41" href="#text/part0000_split_108.html.FNPTR-41">[41]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://strategoxt.org">http://strategoxt.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-42" href="#text/part0000_split_108.html.FNPTR-42">[42]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.txl.ca">http://www.txl.ca</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-43" href="#text/part0000_split_108.html.FNPTR-43">[43]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/Morph/Home">http://www.antlr.org/wiki/display/Morph/Home</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-44" href="#text/part0000_split_108.html.FNPTR-44">[44]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://tom.loria.fr">http://tom.loria.fr</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-45" href="#text/part0000_split_108.html.FNPTR-45">[45]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-46" href="#text/part0000_split_109.html.FNPTR-46">[46]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5">The figures in this section
use the more general term <em class="calibre6">intermediate representation</em> (IR), instead of
AST.</p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-47" href="#text/part0000_split_109.html.FNPTR-47">[47]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://jakarta.apache.org/bcel/manual.html">http://jakarta.apache.org/bcel/manual.html</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-48" href="#text/part0000_split_109.html.FNPTR-48">[48]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://jasmin.sourceforge.net">http://jasmin.sourceforge.net</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-49" href="#text/part0000_split_109.html.FNPTR-49">[49]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1169">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1169</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_114.html.FOOTNOTE-50" href="#text/part0000_split_112.html.FNPTR-50">[50]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/download/examples-v3.tar.gz">http://www.antlr.org/download/examples-v3.tar.gz</a></p></dd></dl><div class="calibre3" id="text/part0000_split_114.html.calibre_pb_148"></div>

</div></div>
<div id="text/part0000_split_115.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_115.html.calibre_pb_149">&nbsp;</p><a id="text/part0000_split_115.html.toc-20"></a><h4 class="right2" id="text/part0000_split_115.html.chp.gen">Chapter 12</h4>
</div></div>
<div id="text/part0000_split_116.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_116.html.calibre_pb_150">Generating DSLs with Templates</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">Unlike the other chapters in this book, this chapter doesnt have
any patterns. 
Instead, were going to learn by example.  Were at the
point where we need to look at some bigger problems and start
applying the patterns weve learned. In this chapter, were going to
build a number of template-driven generators to demonstrate the
model-driven strategy from the previous chapter.
Well see how language patterns apply to some interesting problems.
The implementations are up to you, but Ill get you started by laying
out the basic application architectures.</p><p height="10" width="0" class="calibre5"> Were going to use a template engine called
StringTemplate<a id="text/part0000_split_116.html.FNPTR-51" href="#text/part0000_split_124.html.FOOTNOTE-51">[51]</a>
(ST) throughout this chapter. There are lots of other template engines
(such as Velocity, XText, Rubys RGEN, and Microsoft T4), but only ST
strictly enforces <em class="calibre6">model-view
separation.</em><a id="text/part0000_split_116.html.FNPTR-52" href="#text/part0000_split_124.html.FOOTNOTE-52">[52]</a>
In a nutshell, that means we keep all  the logic in code and all the output text in the templates. By doing so, we can reuse templates
with different generators and generate different languages from a
single model.</p><p height="10" width="0" class="calibre5">Though well use ST in these examples to generate output, this
chapter is really about using template engines in general to generate
structured text. Remember, when learning to fly, theres no getting
around picking an airplane. Later, you can transfer these techniques
to another template engine. Here are the examples were going to build with ST:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Webpage link visualizer</em>: 
From a list of links between pages, this example generates DOT graphics files for 
Graphviz.<a id="text/part0000_split_116.html.FNPTR-53" href="#text/part0000_split_124.html.FOOTNOTE-53">[53]</a> Well 
create a simple input model, then
walk the model to create a nested tree of templates. It demonstrates
the principle of walking an input model to create
templates.</li><li height="6" class="calibre20"><span></span><em class="calibre6">AST visualizer</em>: 
This example walks ASTs to generate
DOT descriptions. It demonstrates that we can reuse templates
with a completely different input model (an AST this time).  While
walking the AST, though, it doesnt match any subtrees. It just
generates DOT code to show ASTs visually.</li><li height="6" class="calibre20"><span></span><em class="calibre6">C code generator</em>: 
Well generate Cymbol code from
a Cymbol AST using Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>. The example
matches subtrees and maps them to appropriate templates. Its the kind
of generator we really need to perform a translation. Well encode
this goes to that transformation rules in a general-purpose programming language.</li><li height="6" class="calibre20"><span></span><em class="calibre6">SQL schema generator</em>:
Using Javas reflection API
as an input model, this example generates SQL <code class="calibre21">CREATE
TABLE</code> statements. The SQL describes a schema suitable to
store simple Java objects. Well get familiar with a key ST principle:
applying a template to a list of data elements (ST doesnt have a
<code class="calibre21">foreach</code> loop).</li><li height="6" class="calibre20"><span></span><em class="calibre6">Combined SQL and Java code generator</em>:  
This final
example puts a lot of things together and explains how to build a
retargetable code generator. The sample code can generate both the SQL
schema from the previous example and the associated Java serialization
methods. The generator uses the same input model but different
templates to create different output hierarchies.</li></ul><p height="10" width="0" class="calibre5">Before diving into the examples, we should build a trivial code
generator to get familiar with the ST engine.</p>

</div></div>
<div id="text/part0000_split_117.html"><div class="calibre">

<h2 id="text/part0000_split_117.html.sec.ST-getting-started" class="calibre18">Getting Started with StringTemplate</h2><p height="10" width="0" class="calibre5">ST templates are chunks of text and expressions enclosed in angle
brackets: 
<code class="calibre21">&lt;</code><em class="calibre6">expression</em><code class="calibre21">&gt;</code>. (You can also tell it to use
<code class="calibre21">$</code><em class="calibre6">expression</em><code class="calibre21">$</code>.) ST ignores everything outside the
expressions, treating it as just text to spit out.  ST is a
lightweight library (not a tool or server) with two key classes: <code class="calibre21">StringTemplate</code> and <code class="calibre21">StringTemplateGroup</code>. We can create <code class="calibre21">StringTemplate</code> objects using a string literal in code or load them
from a template group file using <code class="calibre21">StringTemplateGroup</code>.</p><p height="10" width="0" class="calibre5">The basic idea behind constructing output is that we create a template
and inject it with <em class="calibre6">attributes</em> (any Java object).  The
expressions within a template feed on these attributes to compute
text values. We create nested template hierarchies by injecting
templates as attributes into other templates.</p><p height="10" width="0" class="calibre5">To try out ST, the first thing we have to do is make sure that Java
can see the ST library. For your convenience, the main code directory
includes an uber-JAR called <code class="calibre21">antlr-3.2.jar</code> that
contains ST as well as all the ANTLR stuff. Otherwise, you can
download
ST<a id="text/part0000_split_117.html.FNPTR-54" href="#text/part0000_split_124.html.FOOTNOTE-54">[54]</a>
and its dependent library ANTLR
v2.7.7.<a id="text/part0000_split_117.html.FNPTR-55" href="#text/part0000_split_124.html.FOOTNOTE-55">[55]</a>
(Its currently written in an older version of ANTLR than the v3 were
using in the rest of the book.)  Its a good idea to add these JARs to
your <code class="calibre21">CLASSPATH</code> environment variable.</p><p height="10" width="0" class="calibre5">Heres a simple example that generates an assignment statement (see
the <code class="calibre21">code/trans/intro</code> directory):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import org.antlr.stringtemplate.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import org.antlr.stringtemplate.language.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">String assign = "&lt;left&gt; = &lt;right&gt;;";</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplate st = new StringTemplate(assign,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AngleBracketTemplateLexer.class);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">st.setAttribute("left", "x");&nbsp;&nbsp; // attribute left is a string</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">st.setAttribute("right", 99);&nbsp;&nbsp; // attribute right is an integer</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">String output = st.toString();&nbsp;&nbsp;// render template to text</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">System.out.println(output);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Creating a template is as simple as passing a string to the <code class="calibre21">StringTemplate</code> constructor. In this case, were also making sure that
ST uses angle brackets for expression delimiters. Once weve got a
template, we can inject <code class="calibre21">left</code> and <code class="calibre21">right</code> attributes and ask ST to
evaluate the template by calling <tt class="calibre21">toString</tt>.</p><p height="10" width="0" class="calibre5">To try this example, jump into the right directory, compile <code class="calibre21">Test.java</code>, and run <code class="calibre21">Test</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">cd root-code-dir/trans/intro</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">ls</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Test.java&nbsp;&nbsp;antlr-2.7.7.jar&nbsp;&nbsp;stringtemplate-3.2.jar</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac -cp ".:antlr-2.7.7.jar:stringtemplate-3.2.jar" Test.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java -cp ".:antlr-2.7.7.jar:stringtemplate-3.2.jar" Test</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x = 99;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If you have the JARs in your <code class="calibre21">CLASSPATH</code>, you dont need the <code class="calibre21">-cp</code>
option.</p><p height="10" width="0" class="calibre5">Now that weve got some idea of what a template looks like and how to
execute it, lets take a look at STs four fundamental operations:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Attribute references such as &lt;user&gt;</em>:
ST evaluates
this expression by looking up <code class="calibre21">user</code> in the attribute dictionary for
this template and calling its <tt class="calibre21">toString</tt> method. If the attribute has
multiple values (an array, <code class="calibre21">List</code>, <code class="calibre21">Map</code>, and so on), ST calls <tt class="calibre21">toString</tt> on each value.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Template references</em>:  
Referencing another template
acts like an <code class="calibre21">#include</code> or macro expansion. It embeds the referenced
template within the surrounding template, adding another level to the
template hierarchy. When generating Java code, we might factor out a
bunch of <code class="calibre21">import</code> statements into a separate template called <code class="calibre21">imports</code>. In the main Java file template, for example, we could include
the imports with expression <code class="calibre21">&lt;imports()&gt;</code>.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Conditional includes</em>: 
ST can conditionally include
subtemplates based upon the presence or absence of an attribute.
For example, the following conditional emits one of two strings
depending on whether attribute <code class="calibre21">retValue</code> exists (its non-null
in the attribute dictionary):<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;if(retValue)&gt;return &lt;retValue&gt;;&lt;else&gt;return;&lt;endif&gt;</code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1">The one special case is that ST tests the value of <code class="calibre21">Boolean</code>
objects, not their presence or absence.<br height="8" class="calibre1"></li><li height="6" class="calibre20"><span></span><em class="calibre6">Template application</em>:  
Instead of a <code class="calibre21">foreach</code> loop,
ST applies (maps) templates to multivalued attributes. For example,
<code class="calibre21">&lt;strings:def()&gt;</code> applies template <code class="calibre21">def</code> to the list of elements in
attribute <code class="calibre21">strings</code>. The colon is the apply operator. ST
automatically creates an instance of <code class="calibre21">def</code> for each element in
attribute <code class="calibre21">strings</code>, passes in <code class="calibre21">strings[</code><em class="calibre6">i</em><code class="calibre21">]</code>, and renders the
template to text.<br height="8" class="calibre1">Sometimes its easier to in-line a template. If we have a list of
function names, for example, we can generate a call to each one of
them with the following expression:<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;names:{n | &lt;n&gt;();}&gt; // parameter n iterates through names</code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1">If <code class="calibre21">names</code> contains <code class="calibre21">f</code> and <code class="calibre21">g</code>, the expression evaluates to
<code class="calibre21">f();g();</code>.<br height="8" class="calibre1"></li></ul><p height="10" width="0" class="calibre5">As well see in the examples, building an overall template means
building a template tree.  The overall template contains subtemplates
that themselves contain subsubtemplates, and so on.
Lets say we wanted to generate a C code file. Wed build the overall
template from a list of function templates.  Wed build the function
templates from statement templates. Wed build those statement
templates from expression templates.</p><p height="10" width="0" class="calibre5">A template hierarchy is the dual of a parse tree. We want to create an
unparse tree, you might say.  
A parse tree has rules as internal
nodes and tokens as leaves.  A nested template tree has templates for
internal nodes and attributes as leaves.  Once weve got the tree, we
can convert it to text with a recursive walk.  Calling <tt class="calibre21">toString</tt> on the root template triggers a call to <tt class="calibre21">toString</tt> on each
child template, and so on, until it reaches the attribute leaves.</p><p height="10" width="0" class="calibre5">ST has some interesting features and characteristics that distinguish
it in many ways from other template engines. Lets take a quick look
at them.
</p>

</div></div>
<div id="text/part0000_split_118.html"><div class="calibre">

<h2 id="text/part0000_split_118.html.d24e37613" class="calibre18">Characterizing StringTemplate</h2><p height="10" width="0" class="calibre5">ST is a <em class="calibre6">dynamically typed</em>, <em class="calibre6">pure functional</em> language
with <em class="calibre6">dynamic scoping</em> and <em class="calibre6">lazy evaluation</em>.  
Those
fancy terms highlight some important characteristics, so lets define
them:</p><ul height="10" class="calibre19"><li height="6" class="calibre20"><span></span><em class="calibre6">Dynamically typed</em>: 
ST uses <tt class="calibre21">toString</tt> to convert
attributes to string values. Since all Java objects answer this
method, ST works with any Java object. Also, if you ask for property
<code class="calibre21">b</code> of attribute <code class="calibre21">a</code> (with <code class="calibre21">a.b</code>), its up to you to make sure
attribute <code class="calibre21">a</code> has that property at run-time.  Python and Ruby
programmers  should feel very much at home.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Pure functional</em>:
All expressions are side-effect free. Theres no direct way for ST to alter data values or data
structures that we pass in.  (Well, you could code a <tt class="calibre21">toString</tt> method
to erase the hard drive, but theres no way ST can prevent that.) The
end result is that ST is free to evaluate template expressions in any
order it wants.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Dynamic scoping</em>: 
In most programming languages, if
function <tt class="calibre21">f</tt>
calls <tt class="calibre21">g</tt>, <tt class="calibre21">g</tt> cannot
see the local variables of <tt class="calibre21">f</tt>. Most languages
are <em class="calibre6">statically</em> scoped.  For a DSL such as ST,
though, dynamic scoping makes more sense. Imagine an
overall <code class="calibre21">file</code> template that contains a number of
embedded <code class="calibre21">method</code> templates. Dynamic scoping means
that <code class="calibre21">method</code> can reference <code class="calibre21">file</code>s
attributes, such as the <code class="calibre21">filename</code>
attribute.</li><li height="6" class="calibre20"><span></span><em class="calibre6">Lazy evaluation</em>:  
Lazy evaluation means two
things. First, ST only evaluates the expressions that it has to. This
is just like the familiar <code class="calibre21">if</code> statement where the <code class="calibre21">then</code> clause
 executes only if the condition is true. Second, lazy evaluation allows
us to defer execution until all attributes and embedded templates are
available. This is like building up a string in Python before
execution using <code class="calibre21">eval</code>. We can reference any variable we want in the
strings without fear Python will prematurely evaluate them. All we
have to do is make sure that theyre defined before we call <tt class="calibre21">eval</tt>.
Heres a sample Python session:<div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">&gt;&gt;</em></b><b class="calibre13">&gt; e = 'x'+'*'+'10' </b><em class="calibre6"># ref x before it's defined</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">&gt;&gt;</em></b><b class="calibre13">&gt; x=3 </b><em class="calibre6"># must define x before evaluating expression "x*10"</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">&gt;&gt;</em></b><b class="calibre13">&gt; print eval(e)</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><br height="8" class="calibre1">Lazy evaluation in templates means we can construct our template tree
and inject attributes in any order we want without fear of premature
evaluation. We just have to make sure we set all attribute values before
calling <tt class="calibre21">toString</tt> on the root template. Some of the
templates in <a href="#text/part0000_split_123.html.sec.gen-java"><em class="calibre6">Building Retargetable Translators</em></a> rely on lazy evaluation.<br height="8" class="calibre1"></li></ul><p height="10" width="0" class="calibre5">All right, now that we know a little bit about ST, well focus on
building examples for the rest of the chapter.
</p>

</div></div>
<div id="text/part0000_split_119.html"><div class="calibre">

<h2 id="text/part0000_split_119.html.d24e37820" class="calibre18">Generating Templates from a Simple Input Model</h2><p height="10" width="0" class="calibre5">There are many cases where we have an internal data structure, 
such as a tree or network graph, that wed like to visualize for
documentation or debugging purposes. This is a perfect opportunity to
flex our code generation muscles. We can generate graphical
descriptions using the DOT DSL of Graphviz, an open source graph
visualization tool.</p><p height="10" width="0" class="calibre5">As an example application, lets visualize the link interconnections
between web pages.  Itll teach us the basics of creating output
templates from an input model. From a list of <code class="calibre21">Link</code> objects, well
generate a series of <em class="calibre6">from</em><code class="calibre21">-&gt;</code><em class="calibre6">to</em> edge definitions in a DOT
file surrounded by some bookkeeping definitions.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">digraph testgraph {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; node [shape=plaintext, fontsize=12, fontname="Courier", height=.1];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; ranksep=.3;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; edge [arrowsize=.5]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; "index.html" -&gt; "login.html"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; "index.html" -&gt; "about.html"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You can ignore the <code class="calibre21">node</code>, <code class="calibre21">ranksep</code>, and <code class="calibre21">edge</code> definitions if you
want.  They only affect how big the elements of the graph are. The key
to this example is how we generate output, not exactly what were
generating. For convenience, lets create a <code class="calibre21">LinkViz</code> class whose <tt class="calibre21">toString</tt>
method uses ST to generate a proper DOT file. Then we can add a series
of page links and print out the DOT:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/GenDOT.java">trans/web/GenDOT.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">LinkViz viz = <b class="calibre13">new</b> LinkViz();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"index.html"</em>, <em class="calibre6">"login.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"index.html"</em>, <em class="calibre6">"about.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"login.html"</em>, <em class="calibre6">"error.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"about.html"</em>, <em class="calibre6">"news.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"index.html"</em>, <em class="calibre6">"news.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"logout.html"</em>, <em class="calibre6">"index.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">viz.addLink(<em class="calibre6">"index.html"</em>, <em class="calibre6">"logout.html"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(viz.toString());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5"> In Figure 38, <a href="#text/part0000_split_119.html.fig.webviz"><em class="calibre6">Web viz</em></a>, we see the graph we get after running the generated DOT
output through Graphviz.  <code class="calibre21">LinkViz</code> is just a list of <code class="calibre21">Link</code> objects:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/LinkViz.java">trans/web/LinkViz.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">List</b>&lt;Link&gt; links = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;Link&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">static</b> <b class="calibre13">class</b> Link {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> from;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> to;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> Link(<b class="calibre13">String</b> from, <b class="calibre13">String</b> to) {this.from = from; this.to = to;}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><div class="calibre1" id="text/part0000_split_119.html.fig.webviz"><img id="text/part0000_split_119.html.d24e38029" class="calibre37" src="data:image/gif;base64,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" alt="images/gen/web.png"><hr class="calibre17"><b class="calibre13">Figure 37. Web viz</b><hr class="calibre17"></div><p class="calibre1" style="margin:0pt; border:0pt; height:1em">&nbsp;</p><p height="10" width="0" class="calibre5"><code class="calibre21">LinkViz</code>s <tt class="calibre21">toString</tt> method walks these links to create <code class="calibre21">edge</code> templates and embeds them within the overall <code class="calibre21">file</code> template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/LinkViz.java">trans/web/LinkViz.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">String</b> toString() {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate fileST = templates.getInstanceOf(<em class="calibre6">"file"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fileST.setAttribute(<em class="calibre6">"gname"</em>, <em class="calibre6">"testgraph"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (Link x : links) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate edgeST = templates.getInstanceOf(<em class="calibre6">"edge"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgeST.setAttribute(<em class="calibre6">"from"</em>, x.from);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgeST.setAttribute(<em class="calibre6">"to"</em>,&nbsp;&nbsp; x.to);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileST.setAttribute(<em class="calibre6">"edges"</em>, edgeST);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> fileST.toString(); <em class="calibre6">// render (eval) template to text</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To inject an attribute value, we use <tt class="calibre21">setAttribute</tt> with a name-value
pair.  Calling <tt class="calibre21">setAttribute</tt> more than once with the same attribute
name, such as <code class="calibre21">edges</code>, builds up a listit doesnt replace
the previous value (that method should really be called <tt class="calibre21">addAttribute</tt>). 
Before we can execute <tt class="calibre21">toString</tt>, we have to load our
template library from a group file. Our constructor can handle this
for us:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/LinkViz.java">trans/web/LinkViz.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> LinkViz() <b class="calibre13">throws</b> IOException {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">FileReader</b> fr = <b class="calibre13">new</b> <b class="calibre13">FileReader</b>(<em class="calibre6">"DOT.stg"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;templates = <b class="calibre13">new</b> StringTemplateGroup(fr);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fr.close();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Moving on to the templates now, lets look at the overall <code class="calibre21">file</code>
template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/DOT.stg">trans/web/DOT.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">file(gname,edges) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">digraph &lt;gname&gt; {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; node [shape=plaintext, fontsize=12, fontname="Courier", height=.1];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; ranksep=.3;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; edge [arrowsize=.5]</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; &lt;edges; separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It accepts two attributes: a graph name and a list of <code class="calibre21">edge</code> templates. The first ST expression, <code class="calibre21">&lt;gname&gt;</code>, references the
<code class="calibre21">gname</code> attribute. It evaluates to the attribute we sent in via <tt class="calibre21">setAttribute</tt>.  The <code class="calibre21">&lt;edges; separator="\n"&gt;</code> expression
spits out the results from calling <tt class="calibre21">toString</tt> on each element of
<code class="calibre21">edges</code>. The <code class="calibre21">separator</code> option says to put a newline in between the
edges so we get each one on its own line.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">edge</code> template also has two attribute parameters that we inject
from <code class="calibre21">LinkViz</code>s <tt class="calibre21">toString</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/web/DOT.stg">trans/web/DOT.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">edge(from,to) ::= &lt;&lt;"&lt;from&gt;" -&gt; "&lt;to&gt;"&gt;&gt;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This code generator, then, is just a small input model, a bit of code
to walk that data structure, and two templates. We create templates
and inject attributes as we walk (the input-driven approach). We dont
evaluate or emit anything until weve created the entire template
tree.</p><p height="10" width="0" class="calibre5">You might be wondering why we go through the trouble of using
templates for this simple generation problem. We could fairly easily
generate the appropriate output with print statements or by building
up a string buffer. Print statements arent the best solution because
we might want to include the DOT output in another data structure.
Piecing together a string buffer isnt the most flexible solution
either, as we saw in the previous chapter. It totally cements the output
fragments into our input models Java code.</p><p height="10" width="0" class="calibre5">In the next section, well see that we can reuse templates for a
totally different application using a different input model.
</p>

</div></div>
<div id="text/part0000_split_120.html"><div class="calibre">

<h2 id="text/part0000_split_120.html.sec.ast-dot" class="calibre18">Reusing Templates  with a Different Input Model</h2><p height="10" width="0" class="calibre5">Weve done a lot with ASTs in this book, and its nice to see them
visually.  
Rather than build all the tree diagrams in this book by
hand, for example, I used an AST walker to generate DOT scripts. The
templates I used are similar to those from the previous
section. Because they arent tied to the web link model, we can reuse
them to build an AST visualizer in this section.</p><p height="10" width="0" class="calibre5">For simplicity, lets assume our trees follow Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>.  Given a tree
like <code class="calibre21">(VAR int x (+ 3 3))</code>, we want to generate DOT that gives us a
visualization like the tree on the top of the next page.</p><div class="calibre1"><img id="text/part0000_split_120.html.d24e38302" class="calibre49" src="data:image/gif;base64,R0lGODlh0ABvAOcAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwMDcwKbK8P/w1P/isf/Ujv/Ga/+4SP+qJf+qANySALl6AJZiAHNKAFAyAP/j1P/Hsf+rjv+Pa/9zSP9XJf9VANxJALk9AJYxAHMlAFAZAP/U1P+xsf+Ojv9ra/9ISP8lJf4AANwAALkAAJYAAHMAAFAAAP/U4/+xx/+Oq/9rj/9Ic/8lV/8AVdwASbkAPZYAMXMAJVAAGf/U8P+x4v+O1P9rxv9IuP8lqv8AqtwAkrkAepYAYnMASlAAMv/U//+x//+O//9r//9I//8l//4A/twA3LkAuZYAlnMAc1AAUPDU/+Kx/9SO/8Zr/7hI/6ol/6oA/5IA3HoAuWIAlkoAczIAUOPU/8ex/6uO/49r/3NI/1cl/1UA/0kA3D0AuTEAliUAcxkAUNTU/7Gx/46O/2tr/0hI/yUl/wAA/gAA3AAAuQAAlgAAcwAAUNTj/7HH/46r/2uP/0hz/yVX/wBV/wBJ3AA9uQAxlgAlcwAZUNTw/7Hi/47U/2vG/0i4/yWq/wCq/wCS3AB6uQBilgBKcwAyUNT//7H//47//2v//0j//yX//wD+/gDc3AC5uQCWlgBzcwBQUNT/8LH/4o7/1Gv/xkj/uCX/qgD/qgDckgC5egCWYgBzSgBQMtT/47H/x47/q2v/j0j/cyX/VwD/VQDcSQC5PQCWMQBzJQBQGdT/1LH/sY7/jmv/a0j/SCX/JQD+AADcAAC5AACWAABzAABQAOP/1Mf/sav/jo//a3P/SFf/JVX/AEncAD25ADGWACVzABlQAPD/1OL/sdT/jsb/a7j/SKr/Jar/AJLcAHq5AGKWAEpzADJQAP//1P//sf//jv//a///SP//Jf7+ANzcALm5AJaWAHNzAFBQAPLy8ubm5tra2s7OzsLCwra2tqqqqp6enpKSkoaGhnp6em5ubmJiYlZWVkpKSj4+PjIyMiYmJhoaGg4ODv/78KCgpICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAAAAP8ALAAAAADQAG8AAAj+AP8JHEiwoMGDCBMqXMiwocOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqFChOHbtz4sale/lvnMt25ASWW8dunTp04lYKHUrUoLh074C2bGfu31F37oD+I8cuKrp0MItq3YryaM5/B84NPFpO3ddzYv+VYzeOq9u3H8Whayru3IGB5NCNQ1dO4Ll1ds9JhUu4sMW95MxldXr1gLp7bc+1w9dOXVDDmDM/TFcOXdqa69KJxtcXLVizmlOrPnhOdF+n59jltHnOprq25tZ9Xc1bszh86vBCPSCOnLrQ7eChA53ucu/nhcc5jyndaUzql2NC3869u/fv4MP+ix9Pvrz58+jTnxTnfCR79errsrsLUdyB3Q5t4sMPf/zaeO80BRE57txjD0TjrBNPgW31Fx45SMWzn0QEDvZQXe/Iw1R7Dj43zjkZtvMahVFRZBM88KDWYW/irCXPO7VVVCGHF5KDz4sxrpiaTPHEc9tFFV5UlzsamkOjjlxhKA875RwZ0YwY8SjhiEhuJY45REbVIEZBZtSiOvEo52SVKCUYZjpbZgSlRva1s+BnZKYkF4rrNNlRlxyNcw888TAZJ0oHuLOghRyt2dFOKP74p0jl4HMmf4WWGJJkg465aEUyoeinSIbGdc87fVJ5qUV1uekOfSPhyamCKUI6KkT+jYZ5j6WREioSloOm+WpDEIIqG0qduocOPEXSumtN52RpJ7CSlglmq8ciVJybMBrrUXHvoLlSOe3gqOuxUqqY0l7dvvOrSh8SueGu5DQJYrFClQNPPQDUQ086Q50oz37tWoteOUTyCeO3ZbYDwMH0wLktOz3GI09wZI7TDr0AwCOqUOfQW487BMvJDj0Hx4Pqii2BfHA7XJEDT73LbYXOPAcD8I6r6p0DMz3w4DMyUS3VIw/NKkHoDsz1tNMxeui84w5ncJHTTnNv7cUwxzqOU87RRVVXWDkXR+v112CHLfbYZJdt9tloo4t12v2po/BB5ADNtndXG9WeXXN7VI7+3JyKtttO6NyTjlSBuqOOOjsbZltQV/GtmmdC6dkOqgdkK5g6fWH5NNOpteTO1T6trdk4xumldUr3CKiWomgFZdpz5hyneneKAWeX6B/xNVA5+DpVDnH/QP7cTjr7i1nc6qQTt/Ea/V7Z3mD9Ks49qF3FNTnMC1UXaQmK2909b5d0VDtQTR69WOKsI6Ja6RynV2qNQp2OO4t1d07X4rP3HkvZTaf/avv7X94GSMACGvCACEygAhc4t/0x0DwtgdiFHIO/B3JFHfJYh0TO0SfcWVAl6FiQBwsCpnVk74MjMQc8PkeR9MkDaijUCjne8Y4KNkRi8ghfDMskKB0O6B3+Ftuh9tghj3to5ADwmJkQ5ZSOh50wIRw02hJPgg4NjbAhR4mHCadIkgMAyIYtXMcLn8hFhxCohiDBoQ/LeBg3Ja5QQAQjGyMiDiLOKoULctwcsdhEDZYkilfc40FC2A4ySmR6WjTkHpGIxvUoqHeCjEg5gDg7k0gsHi2LZH6Ss0ZOgaqSmjSKOf4DyZWY4005CmVByhEPetBji0QJoc9KqUqnrMNktFzJOeRxsHco8oHjWFm9cqmSXR5MHm+M5DlARg98BPIjMuFlPdjxSwVKbJbVZBOIABCPZ35wKZ1cidOkWEuneFN8ciynOtfJzna6850KpA55xnG6BMqnTtln1Arx3qfActzvL8nszYdGmbx8vuo96TPid67zj9gY9KCx0Y14yMGTcLLtSviQ6INmYtG5yaSjqrkSDBHonHQo1Dv7s9FDF2WfwAAGPOQITPtW+ieRqgMf9esOOagXOnj69KdAPUhAAAA7AAAA" alt="images/gen/ast.png"></div><p height="10" width="0" class="calibre5">We need to generate DOT with the usual list of edges. But in this
case, we have to define the nodes before we reference them in the edge
list.  DOT needs different tree nodes to have unique names. Since we
have two <code class="calibre21">3</code> nodes in the tree, DOT wants us to
give them different node names. The output looks like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node4 [label="+"];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node5 [label="3"];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node6 [label="3"];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node4 -&gt; node5</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node4 -&gt; node6</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Weve already seen the templates, so we can focus on the
differences. We need to add a line to the <code class="calibre21">file</code> template:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">file(gname,nodes,edges) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">digraph &lt;gname&gt; {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodes; separator="\n"&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;! new !&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;edges; separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">That extra expression spits out all the nodes separated by a newline,
just as it does for edges. (Comments appear in between <code class="calibre21">&lt;!...!&gt;</code>.)
The other thing we need is a <code class="calibre21">node</code> template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast/DOT.stg">trans/ast/DOT.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">node(name,text) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;name&gt; [label="&lt;text&gt;"];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Our visualizer object will inject a unique name for each node so we
can associate it with the tree node text strings:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast/ASTViz.java">trans/ast/ASTViz.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> StringTemplate getNodeST(Tree t) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate nodeST = templates.getInstanceOf(<em class="calibre6">"node"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">String</b> uniqueName = <em class="calibre6">"node"</em>+counter++; <em class="calibre6">// use counter for unique name</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;nodeST.setAttribute(<em class="calibre6">"name"</em>, uniqueName);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;nodeST.setAttribute(<em class="calibre6">"text"</em>, t.payload);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> nodeST;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Like we did in the previous section, well use a visualizer object
whose <tt class="calibre21">toString</tt> method creates a <code class="calibre21">file</code> template and renders it to
text. The only problem is that our input model is a tree. We dont have a 
convenient list of <code class="calibre21">Link</code> objects.  We have two choices.  We can
walk the tree and create a list of links as we did in the previous
example.  Or, we can walk the tree, creating <code class="calibre21">edge</code> template
instances as we go. If we stuff them into the <code class="calibre21">file</code> templates <code class="calibre21">edges</code> attribute, ST automatically makes a list for us. </p><p height="10" width="0" class="calibre5">
Heres the code to do a recursive depth-first walk:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast/ASTViz.java">trans/ast/ASTViz.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">/** Fill fileST with nodes and edges; return subtree root's ST */</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> StringTemplate walk(Tree tree, StringTemplate fileST) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate parentST = getNodeST(tree);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;fileST.setAttribute(<em class="calibre6">"nodes"</em>, parentST); <em class="calibre6">// define subtree root</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( tree.getChildCount()==0 ) <b class="calibre13">return</b> parentST;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// for each child, create nodes/edges and inject into fileST</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (Tree child : tree.children) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate childST = walk(child, fileST);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b> from = parentST.getAttribute(<em class="calibre6">"name"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">Object</b> to&nbsp;&nbsp; = childST.getAttribute(<em class="calibre6">"name"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate edgeST = getEdgeST(from, to);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileST.setAttribute(<em class="calibre6">"edges"</em>, edgeST);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> parentST;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It starts out by creating a <code class="calibre21">node</code> template for the current node and
inserts it into the overall <code class="calibre21">file</code> template. Then, it recursively walks
that nodes children (if any).  <tt class="calibre21">walk</tt> returns the <code class="calibre21">node</code> template
it creates for parameter <code class="calibre21">tree</code>. </p><p height="10" width="0" class="calibre5">To create <code class="calibre21">edge</code> templates from
parent to child, we have to know the childs unique name. To get its
name, we call <tt class="calibre21">getAttribute</tt>.  We can set and read template
attributes all the way up until we render the templates to text. Once
<tt class="calibre21">walk</tt> creates the <code class="calibre21">edge</code> template, it embeds it within the <code class="calibre21">file</code>
template by injecting it via <tt class="calibre21">setAttribute</tt>.</p><p height="10" width="0" class="calibre5">This example generates DOT visualizations for any AST, regardless of
its structure. It cant generate something different depending on a
subtrees structure or contents. For translation purposes, though, we
need to distinguish between subtrees such as variable declarations and
assignment statements.  The next section demonstrates how to
construct different templates for different subtrees and assemble them
together into a template tree.
</p>

</div></div>
<div id="text/part0000_split_121.html"><div class="calibre">

<h2 id="text/part0000_split_121.html.sec.tree-grammar-templates" class="calibre18">Using a Tree Grammar to Create Templates</h2><p height="10" width="0" class="calibre5">A surprising number of translators spit out the same language that
they read in.  
There are lots of useful things we can do such as
refactoring, reformatting, instrumenting, or simplifying source
code. In this section, were going to build a translator that reads in
some Cymbol code (the C++ subset from Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>) and spits it
back out in more or less the same shape.  For example, heres a sample
Cymbol file:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/s.cymbol">trans/ast-st/s.cymbol</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">void</b> f(<b class="calibre13">int</b> a[], <b class="calibre13">int</b> x) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( x&gt;0 ) <b class="calibre13">return</b>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> x = 10;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[3] = 2;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We want to read that in and send it back out using our translator
program:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test s.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void f(int *a, int x) { // "int a[]" becomes "int *a"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if ( (x &gt; 0) ) return ;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;else x = 10;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">&nbsp;&nbsp;&nbsp;&nbsp;a[3]</em></b><b class="calibre13"> = 2;</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The translator were going to build epitomizes the most common
architecture. It has three core components: a parser grammar (<code class="calibre21">Cymbol.g</code>) that builds the AST, a tree grammar (<code class="calibre21">Gen.g</code>) that
constructs the template output model, and the actual templates
themselves (<code class="calibre21">Cymbol.stg</code>).</p><p height="10" width="0" class="calibre5">Each rule in the tree grammar yields a template representing a single
translated phrase.  The tree traversal builds up the template
hierarchy by embedding the templates returned from one rule in the
template result of another.  So, the input model traversal dictates
the structure of the output model. The templates just say what the
output looks like. </p><p height="10" width="0" class="calibre5">This approach makes it pretty easy to adapt a generator to another
application.  The tree grammar only cares   about the name and
attributes of the templates.  It doesnt depend on whats inside the
templates.  To change the output language, then, all we have to do is
swap out one group of templates for another.  A lot of compilers use
this approach to generate machine code for lots of different
processors. (They use a tree grammar to map IR expression subtrees to
assembly code patterns.)</p><p height="10" width="0" class="calibre5">For radically different output languages, though, sometimes we need
a totally different hierarchy rather than just different text in the
templates. In <a href="#text/part0000_split_123.html.sec.gen-java"><em class="calibre6">Building Retargetable Translators</em></a>, well move control of
the hierarchy into the templates.</p><p height="10" width="0" class="calibre5">Since we already know how to build ASTs, were going to focus on the
generator component in this section.  That means exploring the tree
grammar and the templates. So that we dont get overwhelmed right away by
the full tree grammar, lets start with something simple.</p><h3 class="calibre23">Comparing Visitors and Tree Grammars</h3><p height="10" width="0" class="calibre5">To make it easier to understand how tree grammar rules construct
templates, lets compare them to visitor methods. 
Heres a tree
grammar rule that matches an assignment subtree and returns an <code class="calibre21">assign</code> template:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign : ^(<em class="calibre6">'='</em> ID e=expression) -&gt; assign(a={$ID.text}, b={$e.st})</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The template argument list is the interface between the grammar and
the template. It injects attributes into the <code class="calibre21">assign</code> template:
<code class="calibre21">a={$ID.text}</code> sets attribute <code class="calibre21">a</code> to the identifiers text, and
<code class="calibre21">b={$e.st}</code> sets attribute <code class="calibre21">b</code> to the template returned from the
call to rule <code class="calibre21">expression</code>. The template itself looks like this:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">assign(a,b) ::= "&lt;a&gt; = &lt;b&gt;;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we were building this by hand, wed make a visitor method that
looks something like the following (assuming ANTLRs
homogeneous <code class="calibre21">CommonTree</code> nodes):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplate genAssign(CommonTree n) { // match ^('=' ID expression)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;CommonTree idAST = (CommonTree)n.getChild(0);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;String id = idAST.getText();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;CommonTree exprAST = (CommonTree)n.getChild(1);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate exprST = gen( exprAST );</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate st = templates.getInstanceOf("assign");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;st.setAttribute("a", id);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;st.setAttribute("b", exprST);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;return st;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As you can see, building the visitor manually is a lot more work
and a lot more verbose. With this comparison in mind, lets go through
the full Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a> now.  Its our first big
one.</p><h3 class="calibre23">Creating Templates with a Tree Grammar</h3><p height="10" width="0" class="calibre5">Our tree grammar uses two important options. The
<code class="calibre21">tokenVocab</code> options says which parser grammar
created our trees, and the <code class="calibre21">output</code> option
indicates that we want to build a template hierarchy:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">tree</b> <b class="calibre13">grammar</b> Gen;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">options</b> {&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;tokenVocab = Cymbol;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;ASTLabelType = CommonTree;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;output = template;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As we move into the rules now, notice that there are no output
literals in the tree grammar. Everything dealing with the output
language is encapsulated in the templates. Conversely, theres no
model logic in the templates. This model-view separation is the
linchpin supporting retargetable code generators.</p><p height="10" width="0" class="calibre5">OK, lets start with the highest-level rule,
<code class="calibre21">compilationUnit</code>, which matches all the various
declarations:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">compilationUnit</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ( d+=classDeclaration | d+=methodDeclaration | d+=varDeclaration )+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; file(defs={$d})</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The rule collects a list of the templates returned by the declaration
rules using the <code class="calibre21">+=</code> list label operator. When using the
<code class="calibre21">output=template</code> option, each rule returns an <code class="calibre21">st</code> property.  The
<code class="calibre21">-&gt;</code> operator indicates which template to
create for that rule. ANTLR looks for templates in
the <code class="calibre21">String-</code><code class="calibre21">TemplateGroup</code> that we pass into the
generated tree walker via <tt class="calibre21">setTemplateLib</tt>.</p><p height="10" width="0" class="calibre5">The rule injects data into the template via the attribute
assignments in the template argument list. In this case, it sets
attribute <code class="calibre21">defs</code> to the list we collect
while matching the trees for this rule.</p><p height="10" width="0" class="calibre5">Aside from matching multiple elements, its common for grammars
to match optional items. For example, to match a class definition, we
might have to match a superclass.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">classDeclaration</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; ^(<em class="calibre6">'class'</em> name=ID (^(<em class="calibre6">':'</em> sup=ID))? m+=classMember+)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; class(name={$name.text}, sup={$sup.text}, members={$m})</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We can attach a label, <code class="calibre21">sup</code>, to the optional element and refer to
it in the template argument list.  Label reference <code class="calibre21">$sup</code> is <code class="calibre21">null</code>
when the rule doesnt match a superclass. ANTLR automatically prevents
<code class="calibre21">null</code> pointer exceptions when we reference known
properties such as <code class="calibre21">$sup.text</code>.</p><p height="10" width="0" class="calibre5">Sometimes a rule does nothing but invoke another rule. Or, it needs to
create a template from a single node. The <code class="calibre21">type</code> rule demonstrates
both of these situations:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">type:&nbsp;&nbsp; primitiveType&nbsp;&nbsp; -&gt; {$primitiveType.st}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; {%{$ID.text}}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The first alternative says to match rule <code class="calibre21">primitiveType</code> and return
its template. The <code class="calibre21">-&gt; {...}</code> syntax returns the template specified by
the arbitrary expression in the curly braces. The second alternative
matches an <code class="calibre21">ID</code> node and then creates a template again using the <code class="calibre21">-&gt;
{...}</code> arbitrary expression notation. In this case, it creates a
template using a shorthand available to any ANTLR action. ANTLR
translates <code class="calibre21">%{x}</code> to something like <code class="calibre21">new StringTemplate(x)</code>. The
overall expression, <code class="calibre21">{%{$ID.text}}</code>, then creates a template from
the <code class="calibre21">ID</code> nodes text.</p><p height="10" width="0" class="calibre5">That shorthand is also useful when you have a whole list of single
node alternatives as we do in rule <code class="calibre21">primitiveType</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">primitiveType</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@after</b> {$st = %{$text};}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; <em class="calibre6">'float'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'int'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'char'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'boolean'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; <em class="calibre6">'void'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The <code class="calibre21">@after</code> action sets the return template property <code class="calibre21">st</code> to the text
matched for the rule. That way, we dont need a <code class="calibre21">-&gt;</code> template
action on each alternative.</p><p height="10" width="0" class="calibre5">Theres one final complication we should look at before turning to the
templates.  The following <code class="calibre21">op</code> rule  matches any of the binary
operators including the <code class="calibre21">&lt;</code> and <code class="calibre21">&lt;=</code> relational operators:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Gen.g">trans/ast-st/Gen.g</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">op&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// Text of operator is $start.getText(); $start is root token for op</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">@after</b> {$st = %operator(o={$start.getText()});}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; bop | relop | eqop</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As in <code class="calibre21">primitiveType</code>, we use the <code class="calibre21">@after</code> action to set the return
template. But, in this case, we cant use <code class="calibre21">%{$text}</code> to create the
return template from the single node it matches. There are two
problems.</p><p height="10" width="0" class="calibre5">First, we have an issue related to the <code class="calibre21">&lt;</code> template
expression delimiter characters. If we try to create template with
<code class="calibre21">new StringTemplate("&lt;=")</code>, StringTemplate wont like it because <code class="calibre21">&lt;</code>
starts a template expression. We need to create a template with a
single hole into which we can inject the operator string.  Thats why
we need the <code class="calibre21">operator</code> template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">operator(o) ::= "&lt;o&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The second problem is that we need to create a template from the text
of the operator node alone. In a tree grammar, <code class="calibre21">$text</code> evaluates to
the input text from which the parser built the entire subtree. This is
normally what you want.</p><p height="10" width="0" class="calibre5">For example, if youre in a rule that matches
a <code class="calibre21">while</code> statement, you want <code class="calibre21">$text</code> to mean the entire original
<code class="calibre21">while</code> statement, not just the five characters <code class="calibre21">while</code>. Here,
though, we dont want the original text for the expression since we
might be translating it to something else. In other words, if we have
input <code class="calibre21">3+4</code>, the parser creates a tree that looks like <code class="calibre21">^(+ 3 4)</code>. If
we asked for <code class="calibre21">$text</code> in <code class="calibre21">op</code>, wed get <code class="calibre21">3+4</code>, not <code class="calibre21">+</code>. Thats why we
create the template using <code class="calibre21">$start.getText()</code> instead of <code class="calibre21">$text</code>.</p><p height="10" width="0" class="calibre5">Theres nothing else to point out in the tree grammar. The other rules
dont introduce anything new, so lets move on to the templates now.</p><h3 class="calibre23">Defining Cymbol Templates</h3><p height="10" width="0" class="calibre5">At the top level, our Cymbol output file looks like a list of
definitions. We can emit them with a newline separator using template
<code class="calibre21">file</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">file(defs) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;defs; separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The class definition template has to deal with optional superclasses:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class(name, sup, members) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class &lt;name&gt; &lt;if(sup)&gt;: &lt;sup&gt;&lt;endif&gt; {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;members&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The ST expression <code class="calibre21">&lt;if(sup)&gt;: &lt;sup&gt;&lt;endif&gt;</code> says to emit the
superclass if it exists and prefix it with the :  character
sequence.
In the method definition template, we use the familiar <code class="calibre21">separator</code>
option on the argument list so that the arguments come out with a comma
separator:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">method(name, retType, args, block) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;retType&gt; &lt;name&gt;(&lt;args; separator=", "&gt;) &lt;block&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The method body comes in as a <code class="calibre21">block</code> template (because tree grammar
rule <code class="calibre21">methodDeclaration</code> calls rule <code class="calibre21">block</code>, which returns a <code class="calibre21">block</code>
template):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">block(stats) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;stats; separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Since the parser strips the curly braces, we have to manually put them
back in. This is sometimes overly cautious for the <code class="calibre21">if</code> statement, but
its necessary to ensure we group all statements associated with a
block. As you can see in rule <code class="calibre21">if</code>, there arent any curly braces
around the <code class="calibre21">stat1</code> and <code class="calibre21">stat2</code> statement attributes:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">if(cond, stat1, stat2) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">if ( &lt;cond&gt; ) &lt;stat1&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;if(stat2)&gt;else &lt;stat2&gt;&lt;endif&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The next template of interest is <code class="calibre21">call</code>. It doesnt use anything
fancier than what weve seen so far, but we need to look at how its
attribute list interacts with an invoking template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">call(name, args) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;name&gt;(&lt;args; separator=", "&gt;)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This template handles method calls inside expressions as well as
method calls as statements. The only thing we need for a method call
statement is a semicolon at the end:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">callstat(name, args) ::= "&lt;call(...)&gt;;" // call() inherits name,args</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Having template <code class="calibre21">callstat</code> reuse
<code class="calibre21">call</code> makes sense. The only strange thing is the
ellipsis <code class="calibre21">...</code> in the argument
list. That means we want <code class="calibre21">callstat</code>s attributes to
flow through automatically to <code class="calibre21">call</code> when we invoke
it. In general, when template <em class="calibre6">x</em> calls
template <em class="calibre6">y</em>, the formal arguments of
<em class="calibre6">y</em> hide any <em class="calibre6">x</em> arguments of the
same name because the formal parameters force you to define values. This
prevents surprises and makes it easy to ensure any parameter value is
empty unless you specifically set it for that template.

Here are a few more rules where its easier to have parameters passed
through rather than manually passing them down:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Cymbol.stg">trans/ast-st/Cymbol.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">decl(name, type, init, ptr) ::=</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"&lt;type&gt; &lt;if(ptr)&gt;*&lt;endif&gt;&lt;name&gt;&lt;if(init)&gt; = &lt;init&gt;&lt;endif&gt;"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">var(name, type, init, ptr) ::= "&lt;decl(...)&gt;;"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">arg(name, type, init, ptr) ::= "&lt;decl(...)&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Templates <code class="calibre21">var</code> and <code class="calibre21">arg</code> embed <code class="calibre21">decl</code> and use the ellipsis to pass
through the attributes of the same name.</p><p height="10" width="0" class="calibre5">The rest of the templates are reasonably straightforward or similar to
those weve already seen.</p><h3 class="calibre23">Exercising the Translator</h3><p height="10" width="0" class="calibre5">Lets put together a test rig now so that we can try our
translator:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/ast-st/Test.java">trans/ast-st/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// LOAD TEMPLATES (via classpath)</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">FileReader</b> fr = <b class="calibre13">new</b> <b class="calibre13">FileReader</b>(<em class="calibre6">"Cymbol.stg"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplateGroup templates = <b class="calibre13">new</b> StringTemplateGroup(fr);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">fr.close();&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">//&nbsp;&nbsp;CREATE TREE NODE STREAM FOR TREE PARSERS</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CommonTreeNodeStream nodes = <b class="calibre13">new</b> CommonTreeNodeStream(tree);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">nodes.setTokenStream(tokens);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// where to find tokens</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Gen gen = <b class="calibre13">new</b> Gen(nodes);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">gen.setTemplateLib(templates);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Gen.compilationUnit_return ret = gen.compilationUnit();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(ret.getTemplate());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">As usual, we start by loading a group of templates, <code class="calibre21">Cymbol.stg</code>,
using a <code class="calibre21">StringTemplateGroup</code>.  Then, using the AST (variable <code class="calibre21">tree</code>) returned from the parser, we create the tree parser. In order
for it to create templates, we have to tell it about the group we
loaded via <tt class="calibre21">setTemplateLib</tt>. The template we get back from <code class="calibre21">compilationUnit</code> is the root of the template tree, which we can print.</p><p height="10" width="0" class="calibre5">Heres how we build the software:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java org.antlr.Tool Cymbol.g Gen.g</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">a warning you can ignore from ANTLR</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac *.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test s.cymbol</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">void f(int *a, int x) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">At this point, weve created templates by traversing some fairly
simple input models. We started out walking a list of links and then
moved on to ASTs. We didnt even have to worry about symbol table and
type information in the ASTs.  Further, although there were lots of
templates to look at in this example, they werent very big.  To learn
how to build more complicated translators, we need to look at some
bigger and more complicated templates.  In the next two examples,
well get the chance. Were going to generate the SQL and Java code
necessary to build an object-relational database mapping tool. Well
use Javas reflection API as an input model, which is essentially a
symbol table thats available at run-time.
</p>

</div></div>
<div id="text/part0000_split_122.html"><div class="calibre">

<h2 id="text/part0000_split_122.html.sec.ooschema" class="calibre18">Applying Templates to Lists of Data</h2><p height="10" width="0" class="calibre5">Building an object-relational database mapping is an excellent use of code
generation.  
In this section, were going to build one component of
such a mapping by generating SQL schemas from Java class definitions.
To keep things simple, well restrict ourselves to fields whose Java
types maps easily to SQL types (such as integers, strings, floats,
doubles, and <code class="calibre21">Date</code> objects).</p><p height="10" width="0" class="calibre5">To build this generator, were going to use Javas reflection API as
an input model and create a nested template hierarchy as we did in the
previous section. This application is going to require some new skills,
though.  We have to get comfortable sifting and filtering the input
model and then applying templates to that data. Since ST is a
high-level DSL, it doesnt have a <code class="calibre21">foreach</code> or any other looping
construct.  We apply or map templates to multivalued
attributes, as we saw in <a href="#text/part0000_split_117.html.sec.ST-getting-started"><em class="calibre6">Getting Started with StringTemplate</em></a>.</p><p height="10" width="0" class="calibre5">Well attack this problem in three stages. First, well figure
out how to represent Java objects using table rows and columns. Then,
well filter the input model to get lists of array and nonarray
fields. Finally, well use those lists in the templates to create the
appropriate SQL table definitions.</p><h3 class="calibre23">Representing Objects in a Relational Database</h3><p height="10" width="0" class="calibre5">The basic idea in an object-to-relational database mapping is to
translate classes to tables and fields to columns in the corresponding table. 
Objects then map to rows in tables.  For example, lets say we
want to serialize objects of the following type:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/Person.java">trans/sql/Person.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">class</b> Person {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> name;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// single-valued fields:</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b> SSN;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Date</b> birthDay;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">int</b> age;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">String</b><b class="calibre13">[]</b> roles;&nbsp;&nbsp;<em class="calibre6">// multi-valued fields:</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">public</b> <b class="calibre13">Date</b><b class="calibre13">[]</b> vacation;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The single-valued fields become columns in a
<code class="calibre21">Person</code> database table. The multivalued array
fields, though, dont map directly to columns. That means we have to
create a subordinate table for these fields. The rows in a subordinate
table store the multiple values of an array field from the
object. Each row has a <em class="calibre6">foreign key</em> that indicates
the owner from the main table. In the following diagram, we can see 
how subordinate tables for the <code class="calibre21">roles</code> and
<code class="calibre21">vacation</code> fields point back into the main
table for <code class="calibre21">Person</code>. </p><div class="calibre1"><img id="text/part0000_split_122.html.d24e39575" class="calibre30" src="data:image/gif;base64,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" alt="images/gen/db.png"></div><p height="10" width="0" class="calibre5">The
<code class="calibre21">Person_ID</code> fields are the foreign keys.
Looking at the tables, we can piece together that
<code class="calibre21">Ter</code>s <code class="calibre21">Person</code> object
has two roles (<code class="calibre21">mgr</code> and
<code class="calibre21">coder</code>) and no vacation. (Theres no entry in
table <code class="calibre21">Person_vacation</code> for column
<code class="calibre21">Person_ID</code>==1.) To create our schema, we need to generate some SQL. First, we need a
table to hold the single-valued fields:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE Person (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;name TEXT,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;SSN TEXT,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;birthDay DATETIME,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;age INTEGER</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Then, we need a new table for each multivalued field. For example,
here is the subordinate table that handles array field <code class="calibre21">roles</code>:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE Person_roles (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;roles TEXT,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;Person_ID INTEGER NOT NULL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Knowing the details of SQL is not really important here. Were
focusing on how to generate this SQL. Lets get started with our
generator by looking at how we extract data from the model and
inject it into the templates.
</p><h3 class="calibre23">Extracting Data from the Input Model</h3><p height="10" width="0" class="calibre5">To trigger the schema generation, our test rig program creates an
instance of <code class="calibre21">GenSchema</code> and then invokes <tt class="calibre21">genSchema</tt> with <code class="calibre21">Person</code>s class definition object.
</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/GenSchema.java">trans/sql/GenSchema.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">GenSchema gen = <b class="calibre13">new</b> GenSchema();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplate schemaST = gen.genSchema(Person.class);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(schemaST.toString());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">According to the schema from the last section, we need to deal with
array and nonarray fields differently. This means that we need to extract
data by walking the model:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/GenSchema.java">trans/sql/GenSchema.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">protected</b> <b class="calibre13">void</b> filterFields(<b class="calibre13">Class</b> c, <b class="calibre13">List</b>&lt;<b class="calibre13">Field</b>&gt; fields,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">Field</b>&gt; arrayFields)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">for</b> (<b class="calibre13">Field</b> f : c.getFields()) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> (f.getType().isArray()) arrayFields.add(f);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">else</b> fields.add(f);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Given a <code class="calibre21">Class</code> object, <tt class="calibre21">filterFields</tt> fills two data structures
according to the kinds of fields in the class definition object.
Notice that were following the input-driven approach here. We walk
the input model once collecting data. The output-driven approach would
force two complete walks of the input model, once to get the nonarray
fields and then again to get the array fields.</p><p height="10" width="0" class="calibre5">Once we have the data we need, we can stuff it into the
overall <code class="calibre21">objectTables</code> template via method <tt class="calibre21">genSchema</tt>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/GenSchema.java">trans/sql/GenSchema.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> StringTemplate genSchema(<b class="calibre13">Class</b> c) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">Field</b>&gt; fields = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">Field</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">List</b>&lt;<b class="calibre13">Field</b>&gt; arrayFields = <b class="calibre13">new</b> <b class="calibre13">ArrayList</b>&lt;<b class="calibre13">Field</b>&gt;();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;filterFields(c, fields, arrayFields);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;StringTemplate classST = templates.getInstanceOf(<em class="calibre6">"objectTables"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;classST.setAttribute(<em class="calibre6">"class"</em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;classST.setAttribute(<em class="calibre6">"fields"</em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fields);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;classST.setAttribute(<em class="calibre6">"arrayFields"</em>, arrayFields);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> classST;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">So, thats how all the attributes arrive at the templates. Now,
lets see how those templates use the attributes.
</p><div class="calibre1" height="15"><hr class="calibre17"><h3 class="calibre39">Java Objects Know Their Type</h3><hr class="calibre17"><div class="calibre1"><blockquote class="calibre40"><p height="8" class="calibre5"><small class="calibre41">Before we can generate SQL, we have to figure out how to get
information about an object at run-time such as a <code class="calibre21">Person</code>. We could
build a parser for Java and extract the list of fields from <code class="calibre21">Person.java</code>, but thats a lot of work. Instead, lets ask Java
itself. Through the 
reflection API, Java gives us access to its symbol
table at run-time. There are two key classes we need: <code class="calibre21">Class</code> and
<code class="calibre21">Field</code>.  Yep, there is a class called <code class="calibre21">Class</code>. Each <code class="calibre21">Class</code>
instance contains information about a single class, including the list
of fields. <code class="calibre21">Field</code> knows, among other things, its name and type (a
<code class="calibre21">Class</code> instance). If that field is an array, <tt class="calibre21">getComponentType</tt>
returns the array element type. We can test whether a type is
an array using <tt class="calibre21">isArray</tt>. These reflection objects are similar to our
<code class="calibre21">ClassSymbol</code> and <code class="calibre21">VariableSymbol</code> classes from Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a>.</small></p></blockquote></div><hr class="calibre17"></div><h3 class="calibre23">Generating SQL with Templates</h3><p height="10" width="0" class="calibre5">Once the main program injects the data into the
overall <code class="calibre21">objectTables</code> template, its job is done.
That root template directly or indirectly creates every other template
in our template hierarchy output model.  It begins by creating the
primary table that holds the single-valued fields and then includes a
subordinate table for multivalue fields:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL.stg">trans/sql/SQL.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">objectTables(class, fields, arrayFields) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE &lt;class.simpleName&gt; (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;fields:columnForSingleValuedField(); separator=",\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;arrayFields:tableForMultiValuedField()&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Template expression <code class="calibre21">&lt;class.simpleName&gt;</code> calls <tt class="calibre21">getSimpleName</tt> on the
incoming <code class="calibre21">Class</code> object. The simple name does not include any
surrounding package name. For example, the fully qualified name of <code class="calibre21">Date</code> is <code class="calibre21">java.util.Date</code>, but the simple name is just <code class="calibre21">Date</code>. </p><p height="10" width="0" class="calibre5">To emit the columns, we apply the <code class="calibre21">columnForSingleValuedField</code>
template to each <code class="calibre21">Field</code> object in the list of single-valued fields:
<code class="calibre21">&lt;fields:columnForSingle-</code><code class="calibre21">ValuedField()&gt;</code>.  That expression creates and
embeds a new template instance for each <code class="calibre21">Field</code> in <code class="calibre21">fields</code>.
Finally, the <code class="calibre21">objectTables</code> template includes subordinate tables by
walking over the <code class="calibre21">arrayFields</code>. This time, though, it applies
template <code class="calibre21">tableForMultiValuedField</code> to each field. Before we get to
that template, lets look at single-valued fields.</p><p height="10" width="0" class="calibre5">To emit a column, template <code class="calibre21">columnForSingleValuedField</code> includes
template <code class="calibre21">column</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL.stg">trans/sql/SQL.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">columnForSingleValuedField(f)::="&lt;column(name=f.name, javaType=f.type)&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we didnt need to translate Java to SQL types, <code class="calibre21">column</code>
would look something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">column(name,javaType) ::= "&lt;name&gt; &lt;javaType&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To generate correct SQL, we need to map <code class="calibre21">int</code> to <code class="calibre21">INTEGER</code>
and <code class="calibre21">String</code> to <code class="calibre21">TEXT</code>, for example.  To sequester all output
literals in the templates instead of the input model and Java code, we
can specify the mapping in ST:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL.stg">trans/sql/SQL.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">javaToSQLTypeMap ::= [</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"int":"INTEGER",&nbsp;&nbsp;&nbsp;&nbsp;// "int" maps to "INTEGER"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"String":"TEXT",</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"float":"DOUBLE",</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"double":"DOUBLE",</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;"Date":"DATETIME",</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;default : key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If not found, yield key; don't map</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We can access this map as if the key were a property of the map. For
example, <code class="calibre21">&lt;javaToSQLTypeMap.int&gt;</code> evaluates to string <code class="calibre21">INTEGER</code>. The
<code class="calibre21">int</code> is taken as the key to look up in the map. In our case, we
need to look up a Java types name, not a constant. Parentheses around
an expression in ST evaluates the expression to a string. We can then
ask ST to look up that string.  <code class="calibre21">&lt;</code><em class="calibre6">m</em><code class="calibre21">.(</code><em class="calibre6">x</em><code class="calibre21">)&gt;</code> means to
evaluate <em class="calibre6">x</em> to a string and then use that as the key to look up in
map <em class="calibre6">m</em>. So, the <code class="calibre21">column</code> template has the rather complicated-looking ST expression for the type:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL.stg">trans/sql/SQL.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">column(name,javaType)::="&lt;name&gt; &lt;javaToSQLTypeMap.(javaType.simpleName)&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, we have the main table; now we have to generate the subordinate
tables that hold our multivalued fields.  For each array field of the
class, we need to apply template <code class="calibre21">tableForMultiValuedField</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL.stg">trans/sql/SQL.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">tableForMultiValuedField(f) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE &lt;class.simpleName&gt;_&lt;f.name&gt; (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;column(name=f.name, javaType=f.type.componentType)&gt;,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;class.simpleName&gt;_ID INTEGER NOT NULL</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">);&lt;\n&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Each subordinate table has three columns: a unique identifier
(<code class="calibre21">ID</code>), a column for the array field, and a
foreign key. Since we have template <code class="calibre21">column</code> handy, we can reuse it
by passing in the appropriate values.</p><p height="10" width="0" class="calibre5">To test it,  we can run the main program in <code class="calibre21">GenSchema</code> to see
what it generates:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java GenSchema</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE Person (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;name TEXT,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Now that we can generate a schema, lets walk the reflection API
again to generate Java code that reads and writes objects in the database.
</p>

</div></div>
<div id="text/part0000_split_123.html"><div class="calibre">

<h2 id="text/part0000_split_123.html.sec.gen-java" class="calibre18">Building Retargetable Translators</h2><p height="10" width="0" class="calibre5">If we can easily make a translator generate different output, we say
that its <em class="calibre6">retargetable</em>.  
As we mentioned in <a href="#text/part0000_split_121.html.sec.tree-grammar-templates"><em class="calibre6">Using a Tree Grammar to Create Templates</em></a>, altering or swapping in new templates is one
way to do this.  The template hierarchy stays the same, just the
contents of those templates change.  This retargeting approach is
really useful if you need to generate different SQL to suit different
database vendors, for example. (Alas, we often do.)</p><p height="10" width="0" class="calibre5">In this section, were going to learn another retargeting strategy
that changes the output language by changing the template hierarchy.
The interesting thing is that we assemble different hierarchies using
the templates themselves, not using Java code.  As before, all we have
to do is switch template groups to switch targets. The difference here
is that we dont have to change a tree grammar to create a different
output model structure. With either strategy, retargetable code
generators consist of a collection of templates and some code that
traverses the input model to compute attributes.</p><p height="10" width="0" class="calibre5">To illustrate the approach, were going to build a translator that can
generate both the SQL from the previous section and some Java object
serializer and deserializer methods. As we go along, well learn some
advanced ST features such as dynamic scoping, lazy evaluation, and
attribute renderers (that give ST special instructions about
converting objects to text).  If you can get through the majority of
this example, youll be ready to tackle most translation problems that
come your way.</p><p height="10" width="0" class="calibre5">Lets start by looking at the code we need to generate.</p><h3 class="calibre23">Generating Java Code</h3><p height="10" width="0" class="calibre5">We already know what SQL we need to generate, so lets work on the
Java code output.  
(Warning: this section contains a lot of
Java-specific code that talks to the database.) We want to generate
<code class="calibre21">PersonSerializer.java</code> from the sample
<code class="calibre21">Person</code> class from the previous section.  For
example, heres the method we need that saves the nonarray fields of
the object into the primary table:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">class PersonSerializer {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;public static void savePerson(Connection con, Person o)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws SQLException</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreparedStatement prep = con.prepareStatement(</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INSERT into Person SET ID=?, "+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "name=?, SSN=?, birthDay=?, age=?;");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int Person_ID = ID++;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prep.setInt(1, Person_ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prep.setString(1+1, o.name);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prep.setString(2+1, o.SSN);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prep.setDate(3+1, new java.sql.Date(o.birthDay.getTime()));</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prep.setInt(4+1, o.age);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save_Person_roles(con, o.roles, Person_ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save_Person_vacation(con, o.vacation, Person_ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (prep.executeUpdate () != 1) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("couldn't save "+o);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Given a database connection and a <code class="calibre21">Person</code> object to store, <tt class="calibre21">savePerson</tt> writes the fields out to the main
<code class="calibre21">Person</code> table. Then, well need some helper
methods like the following to save the array fields in subordinate tables:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">static void save_Person_roles(Connection con,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[] roles,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int Person_ID)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;throws SQLException {  }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">You can take a look at the details in <code class="calibre21">PersonSerializer.java</code>.  Since
loading objects doesnt introduce any new generation concepts, well
focus on saving objects.</p><p height="10" width="0" class="calibre5">Now that we have a goal in mind, lets extract data from the input
model and inject it into the overall root template.</p><h3 class="calibre23">Injecting Data into the Root Template</h3><p height="10" width="0" class="calibre5">To build a retargetable code generator, we need a common interface to
the templates.  
Just like any library, we need to publish the
templates and attributes available to our generator. In our case,
well reference a common template called <code class="calibre21">output</code>, which then
accesses the target-specific templates within. Heres what they look
like in both the SQL and Java templates:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/SQL2.stg">trans/sql/SQL2.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** Common interface to templates for this target "*/</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">output(class, fields, arrayFields, nonPrimitiveTypes) ::=</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> "&lt;objectTables()&gt;" // objectTables defines no args; no need for ... arg</code></span></div></td></tr></tbody></table></div><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">output(class, fields, arrayFields, nonPrimitiveTypes) ::=</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> "&lt;serializerClass()&gt;" // no need for ... "pass through" parameter</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To make a common interface, the list of attributes has to be the
same even if that target doesnt need every attribute. For example,
the SQL target doesnt need
the <code class="calibre21">nonPrimitiveTypes</code> attribute. (To
generate Java code, we need a list of nonprimitive types so we can
generate some <code class="calibre21">import</code> statements.) The easiest thing
to do is to compute all possible attributes so we dont have to worry
about which target were generating on a particular run.  Or, if the
computations are expensive, we can limit ourselves to computing
attributes needed by a particular target (passing
in <code class="calibre21">null</code> instead).</p><p height="10" width="0" class="calibre5">Lets put our retargetable generator in <code class="calibre21">DBGen.java</code>.  The main
program decides which target to generate based on the command-line
argument (<code class="calibre21">-java</code> or <code class="calibre21">-sql</code>):</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/DBGen.java">trans/sql/DBGen.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">if</b> ( args[0].equals(<em class="calibre6">"-sql"</em>) ) groupFile = <em class="calibre6">"SQL2.stg"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> <b class="calibre13">if</b> ( args[0].equals(<em class="calibre6">"-java"</em>) ) groupFile = <em class="calibre6">"persist.stg"</em>;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">else</b> {<b class="calibre13">System</b>.err.println(<em class="calibre6">"java DBGen [-sql|-java]"</em>); <b class="calibre13">return</b>;}</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To switch targets, we simply change template group files. Once we have
the group file, we can load those templates into memory and then call
a generic <tt class="calibre21">gen</tt> method to build the template hierarchy from our
sample <code class="calibre21">Person</code> class.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/DBGen.java">trans/sql/DBGen.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// LOAD TEMPLATES</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">FileReader</b> fr = <b class="calibre13">new</b> <b class="calibre13">FileReader</b>(groupFile);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplateGroup templates = <b class="calibre13">new</b> StringTemplateGroup(fr);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">fr.close();&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">templates.registerRenderer(<b class="calibre13">Class</b>.class, <b class="calibre13">new</b> TypeRenderer());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// GEN OUTPUT</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplate output = gen(templates, Person.class);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(output.toString());</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">(Well look at the <tt class="calibre21">registerRenderer</tt> method in the next
section.)</p><p height="10" width="0" class="calibre5">The <tt class="calibre21">gen</tt> method computes the set of attributes with <tt class="calibre21">filterFields</tt>
and injects them into the <code class="calibre21">output</code> common root template:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/DBGen.java">trans/sql/DBGen.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">filterFields(c, fields, arrayFields, nonPrimitiveTypes);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">StringTemplate classST = templates.getInstanceOf(<em class="calibre6">"output"</em>);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">classST.setAttribute(<em class="calibre6">"class"</em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">classST.setAttribute(<em class="calibre6">"fields"</em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fields);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">classST.setAttribute(<em class="calibre6">"arrayFields"</em>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrayFields);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">classST.setAttribute(<em class="calibre6">"nonPrimitiveTypes"</em>, nonPrimitiveTypes);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Method <tt class="calibre21">filterFields</tt> is the same as before
except that it computes the extra
<code class="calibre21">nonPrimitiveTypes</code> set of fields.  So, all
we need is this little bit of (shared) Java code to drive both
targets.</p><p height="10" width="0" class="calibre5">Before we get to the templates, though, we need to look at how ST
supports different renderings of the same data value.</p><h3 class="calibre23">Altering How ST Renders Attributes</h3><p height="10" width="0" class="calibre5">ST (deliberately) has almost no built-in functionality to
manipulate the attributes we inject.  
To maintain proper separation of
concerns, we dont want the templates to become part of the
program. And, if theyre modifying data, theyre part of the program.
In practice, though, we sometimes do need to alter data to suit the
display requirements of the output language. In this case, we need to
capitalize some words.</p><p height="10" width="0" class="calibre5">The main program in <code class="calibre21">DBGen</code> calls <tt class="calibre21">registerRenderer</tt> and passes in
an instance of <code class="calibre21">TypeRenderer</code>. Our goal is to override STs default
behavior for rendering attributes to text. Without instructions to the
contrary, ST calls <tt class="calibre21">toString</tt> on objects to render them to text. But,
before doing that, ST checks to see whether theres an <em class="calibre6">attribute
renderer</em> registered for that type of object.  A renderer has two
versions of <tt class="calibre21">toString</tt>, one to convert an object to text and one to
convert an object to text with a specific format.</p><p height="10" width="0" class="calibre5">For example, from type <code class="calibre21">int</code>, we need to generate a call to <tt class="calibre21">setInt</tt>,
which means we need to capitalize type names. The second version lets
us alter the conversion with a parameter specified in a template:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">set&lt;type; format="capitalized"&gt;(<em class="calibre6">args</em>);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The renderer gives us a way to hook in a snippet of formatting code
for a particular type (in this case, <code class="calibre21">Class</code>)
without forcing ST to support arbitrary code. Allowing arbitrary code
allows model-view entanglement.  ST passes the
<code class="calibre21">format</code> option to the following method:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/TypeRenderer.java">trans/sql/TypeRenderer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">String</b> toString(<b class="calibre13">Object</b> o, <b class="calibre13">String</b> formatName) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">if</b> ( formatName.equals(<em class="calibre6">"capitalized"</em>) ) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> capitalize(((<b class="calibre13">Class</b>)o).getSimpleName());</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;<b class="calibre13">return</b> toString(o);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">While were at it, we might as well make our lives a little bit easier.
Were going to reference the <code class="calibre21">simpleName</code> property of <code class="calibre21">Class</code> objects a
lot. So, instead of having to say <code class="calibre21">&lt;class.simpleName&gt;</code>, lets make it just
<code class="calibre21">&lt;class&gt;</code>.  Because of the renderer weve registered, ST  renders
that as the simple name for the class via the following method.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/TypeRenderer.java">trans/sql/TypeRenderer.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">public</b> <b class="calibre13">String</b> toString(<b class="calibre13">Object</b> o) { <b class="calibre13">return</b> ((<b class="calibre13">Class</b>)o).getSimpleName(); }</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">OK, weve built everything except for the templates. Our Java code
creates an overall template and injects all the data we need. Now its
time to figure out how to create the template hierarchy for the
serializer and deserializer methods.</p><h3 class="calibre23">Constructing the Template Hierarchy</h3><p height="10" width="0" class="calibre5">At this point, weve seen quite a few templates, some with fairly
complicated attribute expressions. 
So, lets focus on the new and
interesting bits in template group file
<code class="calibre21">persist.stg</code>: dynamic scoping of attributes,
implicit use of attribute renderers, and lazy evaluation.</p><p height="10" width="0" class="calibre5">First, lets see how dynamic scoping makes it easy to share
attributes between templates.  The main
program, <code class="calibre21">DBGen</code>, creates a single instance of
template <code class="calibre21">output</code>. That interface
template then has to invoke all the other templates necessary to
create the proper template hierarchy. </p><p height="10" width="0" class="calibre5">For
example, <code class="calibre21">output</code> immediately
invokes <code class="calibre21">serializerClass</code> but without
parameters. <code class="calibre21">serializerClass</code> can automatically see
the attributes of any invoking template (a template higher up in the
template hierarchy). So, <code class="calibre21">serializerClass</code> can see
attributes <code class="calibre21">class</code>, <code class="calibre21">fields</code>, <code class="calibre21">arrayFields</code>,
and <code class="calibre21">nonPrimitiveTypes</code> without us having
to pass them down manually.  (If <code class="calibre21">serializerClass</code>
defined those attributes as formal parameters, though, wed need to
use the pass-through
ellipsis, calling <code class="calibre21">serializerClass(...)</code>
in <code class="calibre21">output</code>.)

For deeply nested templates, dynamic scoping is very convenient. Note
that the attributes of <code class="calibre21">output</code> are not global
variables.  Only templates that <code class="calibre21">output</code> invokes can
see its attributes. Heres the start of
template <code class="calibre21">serializerClass</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** Inherit class, fields, arrayFields, nonPrimitiveTypes</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> *&nbsp;&nbsp;from output template that invokes me. */</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">serializerClass() ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// This file automatically generated by "java DBGen -java"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;imports()&gt;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class &lt;class&gt;Serializer { &lt;! class inherited from above !&gt;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Just so those comments are clear, the <code class="calibre21">/**...*/</code> comment is an ST
comment outside a template definition. The <code class="calibre21">//...</code> is literal text
that goes in the output. The <code class="calibre21">&lt;!</code><code class="calibre21">!&gt;</code> comment is an ST comment inside
the template that doesnt appear in the output.</p><p height="10" width="0" class="calibre5">Dynamic scoping works no matter how deep the template hierarchy.
Notice that <code class="calibre21">serializerClass</code> invokes <code class="calibre21">imports</code>, which uses <code class="calibre21">output</code>s <code class="calibre21">nonPrimitiveTypes</code> attribute to generate imports:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">/** Inherit attribute 'class' from serializerClass */</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">imports() ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;nonPrimitiveTypes:{t | import &lt;t.name&gt;;&lt;\n&gt;}&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.util.ArrayList; &lt;! used by support code !&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.util.List;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.sql.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The templates in <code class="calibre21">persist.stg</code> make much more sense when youre
familiar with STs dynamic scoping. </p><p height="10" width="0" class="calibre5">Now, lets take a look at the <code class="calibre21">saveObjectMethod</code> template, which
implicitly uses our <code class="calibre21">TypeRenderer</code> attribute renderer. ST renders
attribute expression <code class="calibre21">&lt;class&gt;</code> using the renderers <tt class="calibre21">toString</tt>, not
<code class="calibre21">Class</code> <tt class="calibre21">toString</tt>, for example. This template also uses the
<code class="calibre21">format</code> option and so ST invokes the renderers other <tt class="calibre21">toString</tt>
method.</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">saveObjectMethod() ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public static void save&lt;class; format="capitalized"&gt;(Connection con,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person o)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp; throws SQLException</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;PreparedStatement prep = con.prepareStatement(</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INSERT into &lt;class&gt; SET ID=?, "+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;fields:{f | &lt;f.name&gt;=?}; separator=", "&gt;;");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;int &lt;class&gt;_ID = ID++;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;prep.setInt(1, &lt;class&gt;_ID);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;fields:saveField(); separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;arrayFields:saveArrayField(); separator="\n"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;if (prep.executeUpdate () != 1) {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("couldn't save "+o);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If theres one really complicated part of this example, its the lazy
evaluation. As with SQL generation, we have to worry about conversion
between Java and SQL types.  To save objects in the database, we have
to generate code to set the elements of a <code class="calibre21">PreparedStatement</code> (which is
like a built-in SQL template language that uses question marks as the
holes). For injecting strings into the <code class="calibre21">PreparedStatement</code>, we
can call <tt class="calibre21">setString</tt> and pass in the appropriate string:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PreparedStatement prep = con.prepareStatement(</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp; "INSERT into Person SET ID=?, name=?, SSN=?, birthDay=?, age=?;");</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">prep.setString(3, o.SSN);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">For <code class="calibre21">Date</code> objects, though, we need to convert them to SQL dates
like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">prep.setDate(4, new java.sql.Date(o.birthDay.getTime()));</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We can encode this switch on type string mapping with an ST map:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">javaToSQLValueMap ::= [</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Date":"new java.sql.Date(&lt;value&gt;.getTime())",</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default : "&lt;value&gt;"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">It has the same form as the <code class="calibre21">int</code> to <code class="calibre21">INTEGER</code> conversion we saw in
the SQL example, but these map values are templates, not mindless
strings.  As you can see, they reference attribute <code class="calibre21">value</code> even
though theres no obvious definition for it.  Fortunately, thats no
big deal because of lazy evaluation.  Templates that look up values in
this map will define attribute <code class="calibre21">value</code>. Once ST embeds the map result
into the calling template, <code class="calibre21">value</code> will magically become visible. For
example, heres a template that references the map:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">fieldValue(type, value="o") ::= "&lt;javaToSQLValueMap.(type.simpleName)&gt;"</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The assignment in the parameter list is a default parameter value
assignment (like C++ default parameters).  Attribute <code class="calibre21">value</code> is
string <code class="calibre21">o</code> if nobody sets it explicitly. This template hides all the complicated map lookup from the other
templates.  First, it evaluates <code class="calibre21">type.simpleName</code> to get a string like
<code class="calibre21">int</code> or <code class="calibre21">Date</code> and then looks it up in the map. If its a <code class="calibre21">Date</code>, the
map returns the <code class="calibre21">java.sql.Date</code> instance creator template. If its
anything else, the map returns a template that evaluates to attribute
<code class="calibre21">value</code> (the <code class="calibre21">default</code> case).  So, template <code class="calibre21">fieldValue</code> returns
either the <code class="calibre21">value</code> we pass in or that value wrapped in a <code class="calibre21">new</code>
expression.</p><p height="10" width="0" class="calibre5">We can then use this template to save fields in both <code class="calibre21">saveObjectMethod</code> and <code class="calibre21">saveForeignObjectMethod</code> via <code class="calibre21">saveField</code>:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/persist.stg">trans/sql/persist.stg</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">saveField(f) ::= &lt;&lt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">prep.set&lt;f.type; format="capitalized"&gt;(&lt;i&gt;+1,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&lt;fieldValue(type=f.type, value={o.&lt;f.name&gt;})&gt;);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">This template passes attribute <code class="calibre21">value</code> as an anonymous template
<code class="calibre21">{o.</code><code class="calibre21">&lt;f.name&gt;}</code>. Because of lazy evaluation, ST doesnt evaluate that
template until template <code class="calibre21">fieldValue</code> references it. Because of
dynamic scoping, <code class="calibre21">fieldValue</code> can see <code class="calibre21">saveField</code>s <code class="calibre21">f</code> attribute
because <code class="calibre21">saveField</code> calls that template. <code class="calibre21">fieldValue</code> doesnt
explicitly reference <code class="calibre21">f</code>, but <code class="calibre21">{o.&lt;f.name&gt;}</code> does, and its evaluated
inside <code class="calibre21">fieldValue</code>.</p><p height="10" width="0" class="calibre5">The <code class="calibre21">&lt;i&gt;+1</code> attribute expression computes the prepared statement
hole to fill.  Attribute <code class="calibre21">i</code> iterates from 1, but we need indexes
starting at 2. (<code class="calibre21">ID</code> is index 1.)  Since theres
no way in ST to add values, we can use the generated Java code to
compute the proper index.</p><p height="10" width="0" class="calibre5">OK, now that we have the templates to go with the code generator
Java code, lets give the generator a try.
</p><h3 class="calibre23">Testing Code Generation</h3><p height="10" width="0" class="calibre5">First, lets have our generator spit out an SQL schema. Using command-line option <code class="calibre21">-sql</code> gets us the SQL for <code class="calibre21">Person</code>.</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java DBGen -sql</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">CREATE TABLE Person (</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;ID INTEGER NOT NULL UNIQUE PRIMARY KEY,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;name TEXT,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Using <code class="calibre21">-java</code> gets us the Java code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java DBGen -java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">// This file automatically generated by "java DBGen -java"</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.util.Date;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.lang.String;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.util.ArrayList;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.util.List;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">import java.sql.*;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">public class PersonSerializer {</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Ultimately, we need to shove that Java code into a file and compile:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java DBGen -java &gt; PersonSerializer.java</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">javac PersonSerializer.java</b></code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If youre curious, you can continue on into the next section to see
the generated code serialize and deserialize a <code class="calibre21">Person</code> with a MySQL
database.</p><h3 class="calibre23">Testing Object Serialization</h3><p height="10" width="0" class="calibre5">To verify that the code we generate is valid, we have to compile it,
but we should also see whether it communicates properly with a database. 
<code class="calibre21">Test.java</code> in the source code directory creates a <code class="calibre21">Person</code> object,
serializes it to a MySQL database, reads it back in, and prints it
out. You dont need to go through this section if youre interested only
in the translation mechanism. Its here just for
completeness.  The following code is the core of the test rig:</p><div height="12" class="calibre1"><div background="gray" height="8" class="calibre1"><span class="calibre33"><span><a href="http://media.pragprog.com/titles/tpdsl/code/trans/sql/Test.java">trans/sql/Test.java</a></span></span></div><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// CREATE PERSON AND SERIALIZE</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PersonSerializer.init(con);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">GregorianCalendar</b> cal = <b class="calibre13">new</b> <b class="calibre13">GregorianCalendar</b>(2000,10,5);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Person p = <b class="calibre13">new</b> Person(<em class="calibre6">"ter"</em>,<em class="calibre6">"555-11-2222"</em>,cal.getTime(), 9);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">p.roles = <b class="calibre13">new</b> <b class="calibre13">String</b><b class="calibre13">[]</b> {<em class="calibre6">"ceo"</em>, <em class="calibre6">"janitor"</em>};</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">PersonSerializer.savePerson(con, p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em class="calibre6">// SAVE Person TO DB</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><em class="calibre6">// READ PERSON BACK IN</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">String</b> q=<em class="calibre6">"SELECT * FROM Person WHERE ID=1"</em>; <em class="calibre6">// GET FIRST Person</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">Statement</b> stat = con.createStatement();</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">ResultSet</b> rs = stat.executeQuery(q);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rs.next();&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Person back = PersonSerializer.nextPerson(con, rs);</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13">System</b>.out.println(<em class="calibre6">"read back: "</em>+back);</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To get this to execute, we need to download the MySQL Connector/J
5.1<a id="text/part0000_split_123.html.FNPTR-56" href="#text/part0000_split_124.html.FOOTNOTE-56">[56]</a> JDBC
database driver and get the <code class="calibre21">mysql-connector-java-5.1.8-bin.jar</code> file
from that distribution into our <code class="calibre21">CLASSPATH</code> environment
variable. Once were set up, we can invoke the test rig using a particular
server, user, password, and database (via command-line arguments):</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">java Test sql.cs.usfca.edu parrt parrt parrt</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">read back: Person{name='ter', SSN='555-11-2222', birthDay=2000-11-05,</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"> age=9, roles=[ceo, janitor], vacation=[]}</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The test rig connects to my (private) MySQL instance at
<code class="calibre21">sql.cs.usfca.edu</code>. After the program executes, we find data in the
main and subordinate tables:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">mysql&gt;</em></b><b class="calibre13"> select * from Person;</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+------+-------------+---------------------+------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">| ID | name | SSN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | birthDay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| age&nbsp;&nbsp;|</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+------+-------------+---------------------+------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">|&nbsp;&nbsp;1 | ter&nbsp;&nbsp;| 555-11-2222 | 2000-11-05 00:00:00 |&nbsp;&nbsp;&nbsp;&nbsp;9 |</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+------+-------------+---------------------+------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">1 row in set (0.00 sec)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6"></em></b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">mysql&gt;</em></b><b class="calibre13"> select * from Person_roles;</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+---------+-----------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">| ID | roles&nbsp;&nbsp; | Person_ID |</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+---------+-----------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">| 19 | ceo&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">| 20 | janitor |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 |</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">+----+---------+-----------+</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">2 rows in set (0.00 sec)</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6"></em></b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">mysql&gt;</em></b><b class="calibre13"> select * from Person_vacation;</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Empty set (0.00 sec)</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Since the <code class="calibre21">Person</code> object had no vacation elements, the
corresponding subordinate table has no data.
</p>

</div></div>
<div id="text/part0000_split_124.html"><div class="calibre">

<h2 id="text/part0000_split_124.html.d24e41628" class="calibre18">Up Next</h2><p height="10" width="0" class="calibre5">With the conclusion of this example, we have the skills necessary to
build all sorts of generators.  The primary lesson is that generators
consist of a collection of templates and some code to traverse the
model. The traversal code trawls for data, creates and combines
templates, injects them with attributes, and builds up a template
tree.  Sometimes the input model traversal code is responsible for the
entire template hierarchy, sometimes the templates do all the work,
and sometimes they share this responsibility.  In the end, we call <tt class="calibre21">toString</tt> on the template tree root to generate text.</p><p height="10" width="0" class="calibre5">Were nearing the end of our adventure. Weve learned a lot about
language implementation by exploring and applying the common language
design patterns.  We know how to build readers, interpreters,
generators, and translators. In the next chapter, were going to lay
out a number of sample projects to help you continue learning on
your own.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-51" href="#text/part0000_split_116.html.FNPTR-51">[51]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-52" href="#text/part0000_split_116.html.FNPTR-52">[52]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf">http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-53" href="#text/part0000_split_116.html.FNPTR-53">[53]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.graphviz.org">http://www.graphviz.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-54" href="#text/part0000_split_117.html.FNPTR-54">[54]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.stringtemplate.org/download.html">http://www.stringtemplate.org/download.html</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-55" href="#text/part0000_split_117.html.FNPTR-55">[55]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr2.org/download/antlr-2.7.7.jar">http://www.antlr2.org/download/antlr-2.7.7.jar</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_124.html.FOOTNOTE-56" href="#text/part0000_split_123.html.FNPTR-56">[56]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://dev.mysql.com/downloads/connector/j/5.1.html">http://dev.mysql.com/downloads/connector/j/5.1.html</a></p></dd></dl><div class="calibre3" id="text/part0000_split_124.html.calibre_pb_159"></div>

</div></div>
<div id="text/part0000_split_125.html"><div class="calibre">

<p class="pagebreak" style="margin:0pt; border:0pt; height:1em" id="text/part0000_split_125.html.calibre_pb_160">&nbsp;</p><a id="text/part0000_split_125.html.toc-21"></a><h4 class="right2" id="text/part0000_split_125.html.chp.tasks">Chapter 13</h4>
</div></div>
<div id="text/part0000_split_126.html"><div class="calibre">

<h1 class="right" id="text/part0000_split_126.html.calibre_pb_161">Putting It All Together</h1><hr class="calibre17"><p height="10" width="0" class="calibre5">We began this book by looking at the different kinds of language
applications and then cracking a few of them open to see what their
pipelines looked like. We then spent the majority of this book going
through the common language design patterns and their
implementations. In the previous chapter, we looked at a few larger
examples (generating DSLs). In this final chapter, were going to walk
through some sample applications and outline the strategies and
language pattern ingredients youd need to implement them.
</p><p height="10" width="0" class="calibre5">Now that youve gone through all the patterns in this book, youre
ready to venture out on your own. My intention in this last chapter is
to inspire you and to expose you to a variety of language
applications. Youll have to build these projects yourself, but
Ill give you a nudge in the right direction by pointing you to some
appropriate patterns.</p><p height="10" width="0" class="calibre5">Lets start with a DSL from biology and then look at progressively
more complicated applications.</p>

</div></div>
<div id="text/part0000_split_127.html"><div class="calibre">

<h2 id="text/part0000_split_127.html.d24e41671" class="calibre18">Finding Patterns in Protein Structures</h2><p height="10" width="0" class="calibre5">To get you thinking about nontraditional uses of
languages, lets break out of our normal programming world. 
You might
be surprised how many biologists (and other scientists) use parsers
for pattern recognition and analysis.  For example, there are DSLs for
describing DNA/RNA sequences, chemical molecules, molecular formulas
(such as H<sub class="calibre48">2</sub>O), and so on.  Just as with language examples from our
world, scientists want to trigger actions upon recognizing various
structures.</p><p height="10" width="0" class="calibre5">As an example, lets look at a DSL that molecular biologists use to
describe RNA sequences. RNA sequences are chains of nucleotide units:
Adenine (A), Cytosine (C), Guanine (G), or Uracil (U).  You can think
of those letters as the language vocabulary or token set. We can break
up the chains into tokens with Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>. Lets pick
one linguistic structure within RNA sequences.  In <a href="#text/part0000_split_135.html.d2381e330"><em class="calibre6">The Language of Genes</em>&nbsp;[Sea02]</a>, Searls says that
a folded RNA secondary structure entails pairing
between nucleotide bases. For example, in sequence
<code class="calibre21">GAUC</code>, <code class="calibre21">G</code> creates a
dependency for a <code class="calibre21">C</code> down the line, and an
<code class="calibre21">A</code> creates a dependency for a future
<code class="calibre21">U</code>.</p><p height="10" width="0" class="calibre5">Say we wanted to look at a sequence of nucleotide bases and
determine whether it was a folded RNA secondary
structure. It turns out that this notion of dependence between
bases is exactly like matching parentheses and square brackets in a
programming language. We built something similar in the implementation
section of Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>.  Assuming only the
<code class="calibre21">G</code>-<code class="calibre21">C</code> and
<code class="calibre21">A</code>-<code class="calibre21">U</code> dependencies, we
could use the following grammar to match RNA sequences:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">rna : <em class="calibre6">'G'</em> rna <em class="calibre6">'C'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;| <em class="calibre6">'A'</em> rna <em class="calibre6">'U'</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em class="calibre6">// allow an empty RNA sequence</em></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">If we needed to process sequences instead of just detecting them,
we could either add actions to the grammar or build an AST (Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a>).</p><p height="10" width="0" class="calibre5">Directly processing pairs as we see them follows
Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a>.  If we created an AST, we could
walk it (Chapter 5, <a href="#text/part0000_split_052.html.chp.walking"><em class="calibre6">Walking and Rewriting Trees</em></a>) one or more times to extract
information.</p><p height="10" width="0" class="calibre5">This parsing application is fairly simple, so lets move on to an
application with a more complicated language.
</p>

</div></div>
<div id="text/part0000_split_128.html"><div class="calibre">

<h2 id="text/part0000_split_128.html.d24e41773" class="calibre18">Using a Script to Build 3D Scenes</h2><p height="10" width="0" class="calibre5">Lets say we wanted to build an English-like scripting language to
draw 3D scenes. The language might look something like this:
</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">x = Cube&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">y = Sphere&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">y.radius = 20</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">draw x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">draw y to the left of x and behind x</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">The fastest way to get this running is probably with Pattern 24, <a href="#text/part0000_split_091.html.tip.syntax-directed-interp"><em class="calibre6">Syntax-Directed Interpreter</em></a>.  Most likely we wouldnt care about speed. Issuing
commands is a lot faster than rendering objects in 3D, so parsing and
interpreting would not be the bottleneck. The interpreter would need
Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> and Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> or Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>. To go beyond recognition, wed need to add
actions to the parser that respond to the different kinds of
statements.</p><p height="10" width="0" class="calibre5">Further, our interpreter needs run-time support. In this case, we could
use a hash table to represent global memory. For example, in response
to assignment statement <code class="calibre21">x=Cube</code>, wed create an internal
representation of a cube and map <code class="calibre21">x</code> to that object in the hash
table. Statement <code class="calibre21">draw x</code> would then look up <code class="calibre21">x</code> in the global memory
to find which object to draw. Note the similarity with defining and
resolving symbols from Pattern 16, <a href="#text/part0000_split_068.html.tip.monolithic-symtab"><em class="calibre6">Symbol Table for Monolithic Scope</em></a>.</p><p height="10" width="0" class="calibre5">Instead of building custom parsers for custom languages, some
programmers lean heavily on XML as a universal format. Well take a look
at parsing and extracting information from XML in the next
section.
</p>

</div></div>
<div id="text/part0000_split_129.html"><div class="calibre">

<h2 id="text/part0000_split_129.html.d24e41840" class="calibre18">Processing XML</h2><p height="10" width="0" class="calibre5">The minute my students hear the term XML, they reach for a full XML parser.  
But, when were facing a small lizard, theres no point in
reaching for a dinosaur-crushing asteroid.  XML parsers are big and
slow, and if they build a tree in memory, they cant handle files
bigger than the computers memory or infinite streams from sockets.
Remember that we can view even complicated files like English text in
multiple ways: as sequences of characters, words, or sentences. If we
can get away with inspecting tokens instead of sentences, weve got a
much easier problem to solve.</p><p height="10" width="0" class="calibre5">Lets say we needed a list of all <code class="calibre21">target</code>
tags from some XML file. <code class="calibre21">grep</code> makes
short work of that without writing any code:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21"><b class="calibre13"><em class="calibre6">$ </em></b><b class="calibre13">grep '&lt;target' config.xml</b></code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;target name="init"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&lt;target name="war" depends="clean, compile"&gt;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">A tiny bit of code (or <code class="calibre21">awk</code> and
<code class="calibre21">sed</code>) would clean that up into a simple list
of target names. (Were assuming here that each
<code class="calibre21">target</code> tag is on a line by itself.) This
strategy follows Pattern 29, <a href="#text/part0000_split_111.html.tip.syntax-directed"><em class="calibre6">Syntax-Directed Translator</em></a> where we
recognize constructs and immediately process or emit output, which is
how a full <em class="calibre6">Simple API for XML</em> (SAX) XML parser
works. A SAX parser avoids creating a large tree in memory by
triggering callbacks when it recognizes certain input nodes.</p><p height="10" width="0" class="calibre5">Sometimes solving the opposite of the problem at hand simplifies our
task significantly.  Take the problem of extracting all nontag text
from an HTML file, which is useful if youre building a search engine
or something similar.  We could parse the HTML file into a tree and
then print out all the leaf nodes.  Building a Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a> in memory
follows the <em class="calibre6">Document Object Model</em> (DOM) XML strategy.
Theres an easier way, though.</p><p height="10" width="0" class="calibre5">Recognizing the text between tags is tough because it really has
no syntax.  On the other hand, recognizing tags is straightforward
because we can just look for anything in between angle brackets (using
Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>). Strip away the tags, and were left with
the text.</p><p height="10" width="0" class="calibre5">Once were recognizing tags, we can extract lots of information
without having to really parse the XML. Lets say we want to extract
all <code class="calibre21">rect</code> tags from a file in the SVG graphics format. Since the
<code class="calibre21">rect</code> has a number of attributes like <code class="calibre21">x</code> and <code class="calibre21">y</code>, it might spill
over multiple lines. We need a real XML tag lexer, but we can scan the
list of tags looking for <code class="calibre21">rect</code> with a simple loop, not a parser. This
approach is analogous to Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a> because we focus on
just the pattern of interest. ANTLR users will recognize this
approach as <code class="calibre21">filter</code> mode for lexer grammars.</p><p height="10" width="0" class="calibre5">Lets take this one step further to verify that an XML document is
well formed.  We can solve this with a stack and a loop around get
next token as we just did to extract <code class="calibre21">rect</code> tags. When we see an
open tag, we push it onto the stack.  When we see a close tag, we pop
a tag from the top of the stack and check that it goes with the
current close tag. <code class="calibre21">&lt;/book&gt;</code> must match a previous <code class="calibre21">&lt;book&gt;</code>.</p><p height="10" width="0" class="calibre5">Many applications come with XML configuration files these days.  In
the next section, well look at a configuration DSL we can use instead.
</p>

</div></div>
<div id="text/part0000_split_130.html"><div class="calibre">

<h2 id="text/part0000_split_130.html.d24e41953" class="calibre18">Reading Generic Configuration Files</h2><p height="10" width="0" class="calibre5">We use configuration files to set initial parameters and create
initial data structures for applications. 
That means humans have to
read and write those files. The problem is that XML is a generic data
format, not a specialized DSL for initializing applications. Being
good DSL-o-philes, we can do a lot better than XML for this niche.</p><p height="10" width="0" class="calibre5">What we want is a simple C-like notation that lets us build a list of
objects with properties such as strings, ints, lists, and references
to other configuration objects. Heres a simple example:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">Site jguru {&nbsp;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port = 80;</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;answers = "www.jguru.com";</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aliases = ["jguru.com", "www.magelang.com"];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">To begin, we need Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> and Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a> to recognize
the various structures. Rather than build a tree or some other
intermediate representation, we want to turn configuration files into
object instances. For example, in this case, we want to create an
object of type <code class="calibre21">Site</code> and set its three fields: <code class="calibre21">port</code>, <code class="calibre21">answers</code>,
and <code class="calibre21">aliases</code>. We need to use Java reflection to do this just as we
did in Chapter 12, <a href="#text/part0000_split_115.html.chp.gen"><em class="calibre6">Generating DSLs with Templates</em></a>. The difference is that were going to convert text to
objects using reflection rather than the other way around.</p><p height="10" width="0" class="calibre5">Beyond the syntax, we need to add actions into the grammar to build
the list of configured objects. To keep the grammar clean, though,
its a good idea to move all the new instance and set object
property functionality into a separate class. The actions then just
trigger the appropriate method call in our support code. You can see
an entire implementation on the ANTLR
wiki.<a id="text/part0000_split_130.html.FNPTR-57" href="#text/part0000_split_134.html.FOOTNOTE-57">[57]</a></p><p height="10" width="0" class="calibre5">Instead of just converting  input sentences into internal data
structures, lets look at translating input to output with some slight
modifications.
</p>

</div></div>
<div id="text/part0000_split_131.html"><div class="calibre">

<h2 id="text/part0000_split_131.html.sec.tweak-source" class="calibre18">Tweaking Source Code</h2><p height="10" width="0" class="calibre5">Lets say we want to tweak some source code, perhaps deleting the
method bodies of all methods within a particular class file. We also
dont want to mess up the formatting of the file.
</p><p height="10" width="0" class="calibre5">First, lets see whether we can get away with using simple tools like <code class="calibre21">awk</code> or <code class="calibre21">sed</code>. Unfortunately, these tools arent so good at matching
patterns across lines and the starting <code class="calibre21">{</code> and ending <code class="calibre21">}</code> are most
likely on different lines. Worse, its hard to distinguish between the
curlies of a method and the curlies of a class body or a statement
block. We need context information because those curlies mean
different things depending on the surrounding text. The minute we say
context, we know that purely lexical tools and Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> arent
powerful enough. We just cant scan the input symbols for curly
braces. </p><p height="10" width="0" class="calibre5">That means we need a parser for the input language. Depending on the
language and depending on how we write the grammar or parser, we will
need Pattern 3, <a href="#text/part0000_split_028.html.tip.recursive-descent"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Parser</em></a>, Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, or Pattern 5, <a href="#text/part0000_split_036.html.tip.backtracker"><em class="calibre6">Backtracking Parser</em></a>.  Naturally, we need Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a> to feed one of these parsers.</p><p height="10" width="0" class="calibre5">To actually modify the source code, we need to record the token or
character index of the method body curly braces.  Once weve got that,
weve got two choices.  One way is to strip that text region from the
file. Or, we can print out all tokens (including whitespace tokens) as
they come in unless they are in a method body region. ANTLR has a
particularly handy and efficient
class, <code class="calibre21">TokenRewriteStream</code>, for
editing the token
stream. (Pattern 21, <a href="#text/part0000_split_081.html.tip.type-promotion"><em class="calibre6">Automatic Type Promotion</em></a> has sample code that
uses this class.) The grammar and associated editing action might look
like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">methodBody : a=<em class="calibre6">'{'</em> statement+ b=<em class="calibre6">'}'</em> {<b class="calibre13">tokens</b>.delete($a,$b);} ;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">We might have a more difficult problem, though.  If we want to
strip the method body only if no one else calls it (dead code elimination),
we need to examine all code in the project looking for references.  We
need to resolve every method call, <code class="calibre21">f()</code> and
<code class="calibre21">o.f()</code>, to compute class-method pairs. Once we
have the set of all invoked methods, we can invert that to get the
list of dead methods. As we scan for method bodies,
then, we can delete any method in that set. Well need the symbol
table management from Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a> and the type
inference algorithms from Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a> to resolve
method calls.</p><p height="10" width="0" class="calibre5">Although deleting bits of text is a form of translation, its more
common to translate an input construct to an output construct instead
of deleting it.  In the next example, well look at reducing
(translating) an augmented version of Java down to pure Java.
</p>

</div></div>
<div id="text/part0000_split_132.html"><div class="calibre">

<h2 id="text/part0000_split_132.html.sec.add-type" class="calibre18">Adding a New Type to Java</h2><p height="10" width="0" class="calibre5">Java doesnt have a built-in vector math type (<code class="calibre21">java.util.Vector</code> is
not meant for mathematics and isnt a built-in type). 
Lets say we
wanted to add type <code class="calibre21">vec</code> so that we can do things like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">vec x = [1, 2, 3];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">vec y = [2, 9, 10];</code></span></div></td></tr></tbody></table><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">vec z = x * y;</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">First, we need a strategy to execute this code. The easiest thing to
do is to translate this down to raw Java.  That means we have to
figure out a mapping from input to output. Most of the input is pure
Java, so we can just leave that stuff alone.  The best way to change a
few things and leave everything else alone is to edit the token
stream (<code class="calibre21">TokenRewriteStream</code> if youre using ANTLR). We know the
start and stop tokens (<code class="calibre21">[</code> and <code class="calibre21">]</code>), so we can replace everything in
between yielding something like this:</p><div height="12" class="calibre1"><table class="calibre7"><tbody class="calibre8"><tr class="calibre9"><td class="calibre11"><div width="0" height="0" class="codewrap"><span><code class="calibre21">vec x = new vec (new int[] {1, 2, 3});</code></span></div></td></tr></tbody></table></div><p height="10" width="0" class="calibre5">Replacing the vector multiplication is a little trickier. We need Pattern 19, <a href="#text/part0000_split_076.html.tip.class-symtab"><em class="calibre6">Symbol Table for Classes</em></a> and Pattern 20, <a href="#text/part0000_split_080.html.tip.type-computation"><em class="calibre6">Computing Static Expression Types</em></a> to differentiate simple scalar
multiplication from vector multiplication.  To support all that
machinery, we need to build an AST (Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a>).  Once weve computed all
the types, we need to walk the AST with Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>,
looking for multiplication subtrees that result in a <code class="calibre21">vec</code>. To
figure out the complete text for the multiplication expression, the
parser needs to store token index information into the AST. The tree
pattern matcher can then replace the appropriate token region with a
method call. For example, <code class="calibre21">x*y</code> would become <code class="calibre21">vec.mult(x,y)</code>.</p><p height="10" width="0" class="calibre5">To get started, grab an existing Java grammar, and add <code class="calibre21">'vec'</code> to the
<code class="calibre21">type</code> rule in the parser grammar. Also add <code class="calibre21">[...]</code>  notation to <code class="calibre21">primaryExpression</code> or some other low-level expression rule. Dont
forget to add a subclass of <code class="calibre21">BuiltInTypeSymbol</code> called <code class="calibre21">vec</code> for
use with the symbol table and type computations.</p><p height="10" width="0" class="calibre5">In the next section, were going to look at another translation
task, one thats unusual because it changes the whitespace, not the
input symbols.
</p>

</div></div>
<div id="text/part0000_split_133.html"><div class="calibre">

<h2 id="text/part0000_split_133.html.d24e42229" class="calibre18">Pretty Printing Source Code</h2><p height="10" width="0" class="calibre5">Building a pretty printer even for a specific language is
surprisingly difficult.  
Its even harder to build a general pretty
printing engine.  For an interesting research framework, take a look
at the pretty printing language called BOX described by Merijn de
Jonge in <a href="#text/part0000_split_135.html.d2381e63"><em class="calibre6">Pretty-Printing for Software
Reengineering</em>&nbsp;[De 02]</a>.  General pretty printers require some
serious voodoo, and language-specific pretty printers tend to be messy
<em class="calibre6">ad hoc</em> code blobs. Lets see whether we can design a more
formal language-specific pretty printer as a compromise.</p><p height="10" width="0" class="calibre5">We can make the problem dramatically easier if we relax it a little
bit. Most pretty printers consider the right column a do not
exceed hard limit.  They must wrap everything before that
edge. But, thats not what programmers do. We step over that right
column occasionally to get a better-looking bit of code.  Programmers
have a few templates in their head for each language construct. For
example, I personally use a few versions of varying width for the <code class="calibre21">if</code>
statement. As I get closer and closer to the right edge, I use a
narrower and narrower template to write out the code.</p><p height="10" width="0" class="calibre5">By mimicking what programmers do naturally, we can whip up a decent
pretty printer. The basic idea is to create an AST from the input as
usual and then walk the tree bottom-up to create a pretty output
template for each node.  In a template group file, we can create one
or more templates for each kind of node using special template names:
<em class="calibre6">name</em><code class="calibre21">_</code><em class="calibre6">i</em>. The larger the value of <em class="calibre6">i</em>, the narrower the
template. So, for example, we could make two different templates,
<code class="calibre21">if_1</code> and <code class="calibre21">if_2</code>, to express a single-line and multiline version of
an <code class="calibre21">if</code>.</p><p height="10" width="0" class="calibre5">The key to solving this pretty-printing problem lies in how we
choose the templates.  Were going to shuffle through the different
template versions looking for one that plays nicely with the other
templates we choose. To format a particular
node, <code class="calibre21">n</code>, in the AST, we
format <code class="calibre21">n</code>s children and then choose a
template for <code class="calibre21">n</code>.  If the template
for <code class="calibre21">n</code> yields a line that blows past the
right column, we reformat the entire subtree at and
below <code class="calibre21">n</code>. To reformat a subtree, we look
for a narrower and narrower template
for <code class="calibre21">n</code> until either we  find one that fits
or we run out of templates for that construct. If the template
for <code class="calibre21">n</code> is still too wide, we
reformat <code class="calibre21">n</code>s children and use the
narrowest template we have for <code class="calibre21">n</code>
itself. It might still be too wide, but its the best we can do. By
accepting a few of these right column border violations, we end up
with a much simpler pretty printer.</p><p height="10" width="0" class="calibre5">In the next section, were going to step it up a notch and figure
out how to build a compiler that translates source code down to machine
code.
</p>

</div></div>
<div id="text/part0000_split_134.html"><div class="calibre">

<h2 id="text/part0000_split_134.html.d24e42333" class="calibre18">Compiling to Machine Code</h2><p height="10" width="0" class="calibre5">Although few people build compilers for full programming
languages, you might find yourself in a position where you need
maximum run-time performance.  
For example, you might have a scripting
or small programming language that executes on a small device like a
phone. Because of battery life issues, phone processors run slowly
compared to desktops. It might make sense to translate your language
all the way down to the machine code to wrench the most speed from the
slow CPU.</p><p height="10" width="0" class="calibre5">In <a href="#text/part0000_split_018.html.sec.c-compiler"><em class="calibre6">C Compiler</em></a>, we looked at the typical compiler application
pipeline. There are many stages and a whole lot of tricky stuff going
on.  In a nutshell, we need patterns and techniques from Chapter 2, <a href="#text/part0000_split_020.html.chp.parsing"><em class="calibre6">Basic Parsing Patterns</em></a>,
Chapter 4, <a href="#text/part0000_split_041.html.chp.IR"><em class="calibre6">Building Intermediate Form Trees</em></a>, Chapter 3, <a href="#text/part0000_split_031.html.chp.advanced-parsing"><em class="calibre6">Enhanced Parsing Patterns</em></a>, Chapter 7, <a href="#text/part0000_split_071.html.chp.aggr-symtab"><em class="calibre6">Managing Symbol Tables for Data Aggregates</em></a>, Chapter 8, <a href="#text/part0000_split_078.html.chp.semantics"><em class="calibre6">Enforcing Static Typing Rules</em></a>, and
Chapter 11, <a href="#text/part0000_split_105.html.chp.trans"><em class="calibre6">Translating Computer Languages</em></a>. But, thats not all.</p><p height="10" width="0" class="calibre5">To make things more concrete, lets compile a C subset down to machine
code. Weve covered everything except optimization and machine code
generation (the back end) in this book. For example, we could use
the following patterns to build the front end: Pattern 2, <a href="#text/part0000_split_027.html.tip.lexer"><em class="calibre6"><em class="calibre6">LL(1)</em> Recursive-Descent Lexer</em></a>, Pattern 4, <a href="#text/part0000_split_029.html.tip.fixed-lookahead-parser"><em class="calibre6"><em class="calibre6">LL(k)</em> Recursive-Descent Parser</em></a>, Pattern 9, <a href="#text/part0000_split_048.html.tip.homo"><em class="calibre6">Homogeneous AST</em></a>, Pattern 15, <a href="#text/part0000_split_061.html.tip.tree-pattern-matcher"><em class="calibre6">Tree Pattern Matcher</em></a>, Pattern 17, <a href="#text/part0000_split_069.html.tip.nested-symtab"><em class="calibre6">Symbol Table for Nested Scopes</em></a>, Pattern 22, <a href="#text/part0000_split_082.html.tip.type-safety"><em class="calibre6">Enforcing Static Type Safety</em></a>. That gets us to the point where weve
verified the syntactic and semantic validity of the
input. Unfortunately, optimizing and generating machine code from an
AST (or any other intermediate representation) is really hard.</p><p height="10" width="0" class="calibre5">Low
Level Virtual Machine<a id="text/part0000_split_134.html.FNPTR-58" href="#text/part0000_split_134.html.FOOTNOTE-58">[58]</a>  (LLVM) to the rescue. LLVM is a compiler
infrastructure and, quite simply, one of the finest pieces of
open source software available. Among other things, LLVM provides a
virtual instruction set thats reminiscent of the instructions for
Pattern 28, <a href="#text/part0000_split_102.html.tip.reg-bytecode"><em class="calibre6">Register-Based Bytecode Interpreter</em></a>.  From this intermediate
representation, LLVM can generate highly optimized machine code for
any of several processors (such as x86, ARM, MIPS, and SPARC). That is
great news because we can generate that intermediate representation
from an AST using Pattern 14, <a href="#text/part0000_split_060.html.tip.tree-grammar"><em class="calibre6">Tree Grammar</em></a>. So, to build a
compiler, we combine the patterns mentioned earlier and then let LLVM do
all of the heavy lifting.  Please see my sample
implementation<a id="text/part0000_split_134.html.FNPTR-59" href="#text/part0000_split_134.html.FOOTNOTE-59">[59]</a>
for more details. You can also think of this front end as a bytecode
compiler suitable for use with the interpreters in Chapter 10, <a href="#text/part0000_split_094.html.chp.interp-bytecode"><em class="calibre6">Building Bytecode Interpreters</em></a>.
</p><p height="10" width="0" class="calibre5">Well, weve reached the end of a long road. Youve just gotten a
huge dose of language implementation technology.  As you can see from
the sample implementations in this book, being a language implementer
means becoming familiar with lots of language tools. If you choose to
use ANTLR and StringTemplate, I encourage you to join us on the
friendly support
lists.<a id="text/part0000_split_134.html.FNPTR-60" href="#text/part0000_split_134.html.FOOTNOTE-60">[60]</a>
  <a id="text/part0000_split_134.html.FNPTR-61" href="#text/part0000_split_134.html.FOOTNOTE-61">[61]</a>
There are a lot of nice people who can help you solve tricky language
problems.</p><p height="10" width="0" class="calibre5">The patterns in this book and these sample applications will get
you started building your own language applications. Youre well on your way to
being a solid language implementer.  I encourage you to share ideas
with other developers on this books
forum.<a id="text/part0000_split_134.html.FNPTR-62" href="#text/part0000_split_134.html.FOOTNOTE-62">[62]</a> If
you develop a nice grammar or application youd like to share, please
feel free to add it to the grammar
list<a id="text/part0000_split_134.html.FNPTR-63" href="#text/part0000_split_134.html.FOOTNOTE-63">[63]</a>
or
showcase<a id="text/part0000_split_134.html.FNPTR-64" href="#text/part0000_split_134.html.FOOTNOTE-64">[64]</a>
on <a href="http://antlr.org">http://antlr.org</a>.
</p>

<h4 class="calibre26">Footnotes</h4>
<dl class="calibre27">
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-57" href="#text/part0000_split_130.html.FNPTR-57">[57]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/ANTLR3/Fig+-+Generic+configuration+language+interpreter">http://www.antlr.org/wiki/display/ANTLR3/Fig+-+Generic+configuration+language+interpreter</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-58" href="#text/part0000_split_134.html.FNPTR-58">[58]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.llvm.org">http://www.llvm.org</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-59" href="#text/part0000_split_134.html.FNPTR-59">[59]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/wiki/display/ANTLR3/LLVM">http://www.antlr.org/wiki/display/ANTLR3/LLVM</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-60" href="#text/part0000_split_134.html.FNPTR-60">[60]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/mailman/listinfo/antlr-interest">http://www.antlr.org/mailman/listinfo/antlr-interest</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-61" href="#text/part0000_split_134.html.FNPTR-61">[61]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/mailman/listinfo/stringtemplate-interest">http://www.antlr.org/mailman/listinfo/stringtemplate-interest</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-62" href="#text/part0000_split_134.html.FNPTR-62">[62]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://forums.pragprog.com/forums/110">http://forums.pragprog.com/forums/110</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-63" href="#text/part0000_split_134.html.FNPTR-63">[63]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/grammar/list">http://www.antlr.org/grammar/list</a></p></dd>
<dt class="calibre28"><a id="text/part0000_split_134.html.FOOTNOTE-64" href="#text/part0000_split_134.html.FNPTR-64">[64]</a></dt><dd class="calibre29"><p height="10" width="0" class="calibre5"><a href="http://www.antlr.org/showcase/list">http://www.antlr.org/showcase/list</a></p></dd></dl><div class="calibre3" id="text/part0000_split_134.html.calibre_pb_170"></div>

</div></div>
<div id="text/part0000_split_135.html"><div class="calibre">

<div id="text/part0000_split_135.html.chp.bibliography" style="height:0pt"></div><div id="text/part0000_split_135.html.toc-22" style="height:0pt"></div><h1 class="right" id="text/part0000_split_135.html.calibre_pb_172">Bibliography</h1><hr class="calibre17"><dl class="calibre27"><dt id="text/part0000_split_135.html.d2381e2" class="calibre1">[ALSU06]</dt><dd class="calibre29">Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. <em class="calibre6">Compilers: Principles, Techniques, andTools </em>. Addison-Wesley Longman, Reading, MA, Second, 2006.</dd><dt id="text/part0000_split_135.html.d2381e63" class="calibre1">[De 02]</dt><dd class="calibre29">Merijn De Jonge. Pretty-Printing for Software Reengineering. <em class="calibre6">International Conference on Software Maintenance (ICSM 2002)</em>. :550--559, 2002.</dd><dt id="text/part0000_split_135.html.d2381e97" class="calibre1">[For02]</dt><dd class="calibre29">Bryan Ford. Packrat parsing: simple, powerful, lazy, linear time, functional pearl. <em class="calibre6">ICFP 02: Proceedings of the Seventh ACM SIGPLAN International Conference on Functional Programming</em>. :36--47, 2002.</dd><dt id="text/part0000_split_135.html.d2381e137" class="calibre1">[For04]</dt><dd class="calibre29">Bryan Ford. Parsing expression grammars: a recognition-based syntactic foundation. <em class="calibre6">POPL 04: Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>. :111--122, 2004.</dd><dt id="text/part0000_split_135.html.d2381e177" class="calibre1">[GHJV95]</dt><dd class="calibre29">Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. <em class="calibre6">Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley, Reading, MA, 1995.</dd><dt id="text/part0000_split_135.html.d2381e235" class="calibre1">[IdC05]</dt><dd class="calibre29">R. Ierusalimschy, L.H. de Figueiredo, and W. Celes. The Implementation of Lua 5.0. <em class="calibre6">Journal of Universal Computer Science</em>. 11[7]:1159--1176, 2005.</dd><dt id="text/part0000_split_135.html.d2381e296" class="calibre1">[Par07]</dt><dd class="calibre29">Terence Parr. <em class="calibre6">The Definitive ANTLR Reference: Building Domain-Specific Languages</em>. The Pragmatic Bookshelf, Raleigh, NC and Dallas, TX, 2007.</dd><dt id="text/part0000_split_135.html.d2381e330" class="calibre1">[Sea02]</dt><dd class="calibre29">David B. Searls. The language of genes. <em class="calibre6">Nature</em>. 420[6912]:211--217, 2002, November.</dd></dl><div class="calibre3" id="text/part0000_split_135.html.calibre_pb_173"></div>

</div></div>
<div id="text/part0000_split_136.html"><div class="calibre">

<div id="text/part0000_split_136.html.toc-adpage" style="height:0pt"></div><h2 class="calibre18" id="text/part0000_split_136.html.calibre_pb_175">About Pragmatic Bookshelf</h2><p width="0" height="10" class="calibre5">The Pragmatic Programmers is an agile publishing company. Were here because we want to improve the lives of developers.
    We do this by creating timely, practical titles, written by programmers for programmers.
    Our ebooks do not contain any Digital Restrictions Management, and have <em class="calibre6">always</em> been DRM-free.</p><p width="0" height="10" class="calibre5">We pioneered the beta book concept, where you can purchase and read a book while its still being written, and provide feedback to the author to help make a better book for everyone.
    </p><p width="0" height="10" class="calibre5">Free resources for all purchasers include source code downloads (if applicable), errata and discussion forums,
      all available on the book's home page at <a href="http://pragprog.com">pragprog.com</a>.</p><p width="0" height="10" class="calibre5">Were here to make your life easier.</p><div class="calibre3" id="text/part0000_split_136.html.calibre_pb_176"></div>

</div></div>
<div id="text/part0000_split_137.html"><div class="calibre">

<h2 class="calibre18" id="text/part0000_split_137.html.calibre_pb_177">New Book Announcements</h2><p width="0" height="10" class="calibre5">Want to keep up on our latest titles and announcements, and occasional special offers?
    Just create an account on <a href="http://pragprog.com">pragprog.com</a> (email address and password is all it takes) and select the checkbox to receive newsletters.
    You can also follow us on twitter @pragprog.</p><div class="calibre3" id="text/part0000_split_137.html.calibre_pb_178"></div>

</div></div>
<div id="text/part0000_split_138.html"><div class="calibre">

<h2 class="calibre18" id="text/part0000_split_138.html.calibre_pb_179">About Ebook Formats</h2><p width="0" height="10" class="calibre5">If you buy directly from our website at <a href="http://pragprog.com">pragprog.com</a>, you get ebooks in all available formats for one price.
      You can have your ebook emailed directly to your Kindle,
    and you can synch your ebooks amongst all your devices (including iPhone/iPad, Android, laptops, etc.) via Dropbox,
    including free updates for the life of the edition. And of course, you can always come back and re-download your books when needed.</p><p width="0" height="10" class="calibre5">Ebooks bought from the Amazon Kindle store are subject to Amazon's polices.</p><p width="0" height="10" class="calibre5">Limitations in Amazon's file format may cause ebooks to display differently on different devices. For more information, please see our FAQ at <a href="http://pragprog.com/frequently-asked-questions/ebooks">pragprog.com/frequently-asked-questions/ebooks</a>.</p><p width="0" height="10" class="calibre5">To learn more about this book and access the free resources, go to <a href="http://pragprog.com">pragprog.com</a> and search on the title to get to the book's homepage.</p><p width="0" height="10" class="calibre5">Thanks for your continued support, </p><div class="calibre1"></div><div class="calibre1">Andy Hunt</div><div class="calibre1"></div><div class="calibre1">Dave Thomas</div><div class="calibre1">The Pragmatic Programmers</div>
</div></div>
</body><script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</html>