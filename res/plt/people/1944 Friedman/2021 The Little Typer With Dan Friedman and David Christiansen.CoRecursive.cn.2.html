<!DOCTYPE html><html lang="zh-CN" style="" class="translated-ltr"><!--
 Page saved with SingleFile 
 url: https://corecursive.com/023-little-typer-and-pie-language/ 
 saved date: Sat Apr 05 2025 18:56:56 GMT+0800 (China Standard Time)
--><head>
<meta name="dc.identifier" content="res/c509d87cea7df6ee64564a5bd73d7eba69a609d2">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" title="核心递归" type="application/rss+xml" href="https://corecursive.com/feed"><title>2021 The Little Typer With Dan Friedman and David Christiansen.CoRecursive.cn</title><link rel="canonical" href="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="website">
<meta property="og:title" content="The Little Typer - CoRecursive Podcast">
<meta property="og:url" content="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:site_name" content="CoRecursive Podcast">
<meta name="generator" content="jekyll 4.2.0"><meta name="description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]"><meta name="author" content="Adam Gordon Bell">
<meta property="og:description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]">
<meta property="og:url" content="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:section" content="Cloud Computing"><meta property="og:tag" content="Functional ProgrammingHaskell"><meta name="twitter:creator" content="@corecursive">
<meta name="twitter:site" content="@corecursive">
<meta name="twitter:label1" content="Written by">
<meta name="twitter:data1" content="Adam Gordon Bell">
<meta name="twitter:label2" content="Est. reading time">
<meta name="twitter:data2" content="5 minutes">
<meta name="twitter:title" content="The Little Typer - CoRecursive Podcast">
<meta name="twitter:description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://corecursive.com/assets/images/023/action.png">
<meta property="og:image" content="https://corecursive.com/assets/images/023/action.png">
<script type="application/ld+json">{"@type":"WebSite","url":"https://corecursive.com","image":{"alt":"og-image","url":"https://corecursive.com/assets/images/023/action.png","@type":"imageObject"},"author":{"@type":"Person","name":"Adam Gordon Bell"},"description":"You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... [&hellip;]","name":"CoRecursive Podcast","headline":"The Little Typer","@context":"https://schema.org","datePublished":"2018-12-01 00:00:00 +0000"}</script>
<link rel="shortlink" href="https://corecursive.com/">
<meta name="theme-color" content="#ffffff">
<style>/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */@media (prefers-reduced-motion:reduce){}@keyframes fa-beat{0%,90%{transform:scale(1)}45%{transform:scale(var(--fa-beat-scale,1.25))}}@keyframes fa-bounce{0%{transform:scale(1,1) translateY(0)}10%{transform:scale(var(--fa-bounce-start-scale-x,1.1),var(--fa-bounce-start-scale-y,0.9)) translateY(0)}30%{transform:scale(var(--fa-bounce-jump-scale-x,0.9),var(--fa-bounce-jump-scale-y,1.1)) translateY(var(--fa-bounce-height,-0.5em))}50%{transform:scale(var(--fa-bounce-land-scale-x,1.05),var(--fa-bounce-land-scale-y,0.95)) translateY(0)}57%{transform:scale(1,1) translateY(var(--fa-bounce-rebound,-0.125em))}64%{transform:scale(1,1) translateY(0)}100%{transform:scale(1,1) translateY(0)}}@keyframes fa-fade{50%{opacity:var(--fa-fade-opacity,0.4)}}@keyframes fa-beat-fade{0%,100%{opacity:var(--fa-beat-fade-opacity,0.4);transform:scale(1)}50%{opacity:1;transform:scale(var(--fa-beat-fade-scale,1.125))}}@keyframes fa-flip{50%{transform:rotate3d(var(--fa-flip-x,0),var(--fa-flip-y,1),var(--fa-flip-z,0),var(--fa-flip-angle,-180deg))}}@keyframes fa-shake{0%{transform:rotate(-15deg)}4%{transform:rotate(15deg)}8%,24%{transform:rotate(-18deg)}12%,28%{transform:rotate(18deg)}16%{transform:rotate(-22deg)}20%{transform:rotate(22deg)}32%{transform:rotate(-12deg)}36%{transform:rotate(12deg)}40%,100%{transform:rotate(0deg)}}@keyframes fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-classic:"Font Awesome 6 Free";--fa-font-regular:normal 400 1em/1"Font Awesome 6 Free"}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-classic:"Font Awesome 6 Free";--fa-font-solid:normal 900 1em/1"Font Awesome 6 Free"}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-brands:"Font Awesome 6 Brands";--fa-font-brands:normal 400 1em/1"Font Awesome 6 Brands"}body{line-height:1.5}body *{font-family:"Source Sans Pro",sans-serif;box-sizing:border-box}html,body,div,span{margin:0;padding:0;border:0;font-size:100%}::after,::before{box-sizing:border-box}.post-text p{margin-bottom:25px;color:#000;font-size:18px}.container{margin-left:auto;margin-right:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1180px}}@media (width:800px){.container{display:block;margin:0 auto}}strong{font-weight:700;margin-right:5px}.wrapper{grid-template-rows:auto 1fr auto;display:grid}@media screen and (min-width:768px){}@media (min-width:768px){}@media only screen and (max-width:991px){}@media (min-width:768px){}@media screen and (min-width:768px){}h2.single-post-title{font-family:"Source Sans Pro",Georgia,sans-serif;font-size:40px;color:#333;font-weight:700;letter-spacing:0.24px;line-height:34px;margin-bottom:30px;margin-top:0}@media (min-width:600px){}@media (min-width:375px){}@media (min-width:425px){}@media (min-width:991px){}@media (min-width:1200px){}::placeholder{color:#999;padding-left:5px}@media (min-width:1024px){}@media (min-width:1024px){}@keyframes a{to{transform:rotate(1turn)}}@keyframes a{to{transform:rotate(1turn)}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes a{to{transform:rotate(1turn)}}@keyframes a{to{transform:rotate(1turn)}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@media only screen and (max-width:991px){body{overflow-x:hidden!important}}@media only screen and (max-width:767px){}@media only screen and (max-width:479px){.wrapper,body{overflow-x:hidden!important}}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}@media only screen and (max-width:991px){}@media only screen and (max-width:1023px){}@media (max-width:1023px){}@media (min-width:425px){}@media screen and (min-width:999px){}@media screen and (min-width:999px){}@media (min-width:768px){}@media (max-width:1023px){}@media (min-width:600px){}@media (min-width:768px){}@media (min-width:1024px){}@media (min-width:375px) and (max-width:767px){}@media (min-width:600px){}@media (min-width:425px){}@media (min-width:768px){}.podcast_body{padding:20px 9px}@media (min-width:1024px){.podcast_body{grid-column:2/3;grid-row:1/8}}@media only screen and (max-width:1026px){}@media screen and (min-width:768px){}@media screen and (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:1024px){}@media (min-width:1024px){}.transcript{padding:15px 0 50px}.transcript h2{font-weight:700;font-size:36px;line-height:1.2}@media (min-width:1024px){}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}</style>
<style>@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><style>.VIpgJd-ZVi9od-ORHb-OEVmcd{left:0;top:0;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6B90DA;margin:0;box-shadow:0 0 8px 1px #999}.VIpgJd-ZVi9od-xl07Ob-OEVmcd{z-index:10000002;border:none;position:fixed;box-shadow:0 3px 8px 2px #999}.VIpgJd-ZVi9od-SmfZ-OEVmcd{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#FFF;border-left:1px solid #D5D5D5;border-top:1px solid #9B9B9B;border-bottom:1px solid #E8E8E8;border-right:1px solid #D5D5D5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline}.goog-te-gadget .goog-te-combo{margin:4px 0}.VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-l4eHX-hSRGPd:link,.VIpgJd-ZVi9od-l4eHX-hSRGPd:visited,.VIpgJd-ZVi9od-l4eHX-hSRGPd:hover,.VIpgJd-ZVi9od-l4eHX-hSRGPd:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-TvD9Pc-hSRGPd{display:block;margin:0 10px}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd{padding-top:2px;padding-left:4px}.goog-te-combo,.VIpgJd-ZVi9od-ORHb *,.VIpgJd-ZVi9od-SmfZ *,.VIpgJd-ZVi9od-xl07Ob *,.VIpgJd-ZVi9od-vH1Gmf *,.VIpgJd-ZVi9od-l9xktf *{font-family:arial;font-size:10pt}.VIpgJd-ZVi9od-ORHb{margin:0;background-color:#E4EFFB;overflow:hidden}.VIpgJd-ZVi9od-ORHb img{border:none}.VIpgJd-ZVi9od-ORHb-bN97Pc{color:#000}.VIpgJd-ZVi9od-ORHb-bN97Pc img{vertical-align:middle}.VIpgJd-ZVi9od-ORHb-Tswv1b{color:#666;vertical-align:top;margin-top:0;font-size:7pt}.VIpgJd-ZVi9od-ORHb-KE6vqe{width:8px}.VIpgJd-ZVi9od-LgbsSe{border-color:#E7E7E7;border-style:none solid solid none;border-width:0 1px 1px 0}.VIpgJd-ZVi9od-LgbsSe div{border-color:#CCC #999 #999 #CCC;border-right:1px solid #999;border-style:solid;border-width:1px;height:20px}.VIpgJd-ZVi9od-LgbsSe button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.VIpgJd-ZVi9od-LgbsSe button:active{background:none repeat scroll 0 0#CCC}.VIpgJd-ZVi9od-SmfZ{margin:0;background-color:#FFF;white-space:nowrap}.VIpgJd-ZVi9od-SmfZ-hSRGPd{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-SmfZ-hSRGPd img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.VIpgJd-ZVi9od-SmfZ-hSRGPd span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-te-float-top .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-top-width:0}.goog-te-float-bottom .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-bottom-width:0}.VIpgJd-ZVi9od-xl07Ob-lTBxed{text-decoration:none;color:#00C;white-space:nowrap;margin-left:4px;margin-right:4px}.VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:underline}.VIpgJd-ZVi9od-xl07Ob-lTBxed img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed{color:#000}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:none}.VIpgJd-ZVi9od-xl07Ob{background-color:#FFF;text-decoration:none;border:2px solid #C3D9FF;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-xl07Ob-ibnC6b{padding:3px;text-decoration:none}.VIpgJd-ZVi9od-xl07Ob-ibnC6b,.VIpgJd-ZVi9od-xl07Ob-ibnC6b:link{color:#00C;background:#FFF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:visited{color:#551A8B}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:hover{background:#C3D9FF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:active{color:#00C}.VIpgJd-ZVi9od-vH1Gmf{background-color:#FFF;text-decoration:none;border:1px solid #6B90DA;overflow:hidden;padding:4px}.VIpgJd-ZVi9od-vH1Gmf-KrhPNb{width:16px}.VIpgJd-ZVi9od-vH1Gmf-hgDUwe{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div{padding:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b .uDEFge{display:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .uDEFge{display:auto}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .fmcmS{padding-left:4px;padding-right:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd{text-decoration:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:active div{color:#00C;background:#FFF}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:hover div{color:#FFF;background:#36C}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:hover div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:active div{color:#000;font-weight:bold}.VIpgJd-ZVi9od-l9xktf{background-color:#FFF;overflow:hidden;padding:8px;border:none;border-radius:10px}.VIpgJd-ZVi9od-l9xktf-OEVmcd{background-color:#FFF;border:1px solid #6B90DA;box-shadow:0 3px 8px 2px #999;border-radius:8px}.VIpgJd-ZVi9od-l9xktf img{border:none}.VIpgJd-ZVi9od-l9xktf-fmcmS{margin-top:6px}.VIpgJd-ZVi9od-l9xktf-VgwJlc{margin-top:6px;white-space:nowrap}.VIpgJd-ZVi9od-l9xktf-VgwJlc *{vertical-align:middle}.VIpgJd-ZVi9od-l9xktf-VgwJlc .DUGJie{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc .TdyTDe{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc span{color:#00C;text-decoration:underline;cursor:pointer;margin:0 4px}.VIpgJd-ZVi9od-l9xktf-I9GLp{margin:6px 0 0}.VIpgJd-ZVi9od-l9xktf-I9GLp form{margin:0}.VIpgJd-ZVi9od-l9xktf-I9GLp form textarea{margin-bottom:4px;width:100%}.VIpgJd-ZVi9od-l9xktf-yePe5c{margin:6px 0 4px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf{z-index:1000;position:fixed;-webkit-transition-delay:.6s;transition-delay:.6s;left:-1000px;top:-1000px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf-ti6hGc{-webkit-transition-delay:0s;transition-delay:0s;left:-14px;top:-14px}.VIpgJd-ZVi9od-aZ2wEe-OiiCO{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#FFF url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAG+UlEQVR4Ae2YVXfbWBCAtc/L8H+WocztYpmflrfccGKIU2ZmZuY2jLbMDjNvw693dkbOKIrWcpR18JzNOV987dL3SXMlpdJE+fr/CwDeWHqgY+6inb2e+Tv7hJ55OwaY288cJiPMbA3r97a+hUijjbpYvLdz/oJdfYKJNWBhWtsMRBptBt7s7HVr5WMNmGnvfIRIo426IEkjeUKVNxkwy4F/319F7yLSaKIuWHTkApCkujmINJqoCxYd/vgwOnnC3vkYkUYTdWFe3nwAj9G4jBBLG8tHHx9iJjI7qXoeIo0W6kIvbCTPAXMz+kDLHEeY2VrS+2Dl/g5wuspFVVWDaG5pFa2tYVpaWlSam5sVmpqaItLY2EjQWq6urp+GSIy6GI48oZdntPLMtYceEQxVoQAJ//cAprKyZgYiERIvjKWNR2eoo88kn66C3DxZVFXXk3DMAfX1jU5EIiRezDUhvvhAnzj5ohvkik5oauuAZsRd2Qmn8LPF+yLLz0KW7WmHzCynkOWAqG9ojDWAkQiJF0biTPL1HtHY2gGvOyJDv7btYk/EAOIqjlFhkUcEAiGSGvkAkjSC5F+/HpCtbOiEx65OuF3QBaGa8Gf0uvJQb0T5mfaBMXJ7AqK0tIzEWJ4xko8hAOf8p/196pFv/7sDjj3r1l42aQ177vfA0v2R5Tlgaf8YuVx+EQiGRHl5OQmOYADJRODk824+8sqs66/32rk3OvrM1QfhMfL7g3QWKIJEhj0+DQ0NhERIvDAKoA1L8k14FubtHCzPmJGfgSSdwjHKpTHyi1CoVJSVqRGxB7CYHhKngNxAJ+jFjTb0g+KuiAFLduMYZdIY+USwP4BYtc0Ka5MywIR8bAEkbSbgibNLL8+oY+Tz0RiFA1Zus8DK7VYgsRELYEntCM3dyc84YWy3elT2PRzYK1dyuv4lP92GWPtg3tZnsPgPCyzbhNJbrQi+bmOssDohA9Yk7kAyGOUzjXzkABbWc0KziekmxvIq6WGOPBn4fSnXelieUeSJmSk18OPvFli6MRywYmuaGrACA1Zut6GwQyMfY8AP+wYuo214GT3ytFvMyhgsn3KjR7S2h39PTVMXzM/oZfEwNgYjkCsP3DhGbmWMtJu5oqJCIf34BSXizrMs/fgYB5CQEQlXB9/IKuhG5uyEm3gj81Z2qp/T70m40mMozwGJeDXKyXUJ2e0XwWBoUIDb6xOr4+ywJj4dyvC9gfzwAjiisYVEI0NnwHare0h5YvGudojLOAVLN1hg56mLwAHELnxPG3rniYtQWVlJouYCeByiQeN0/Fk3uMo7lU3d3NYJHjwD5zO7YemBXmFGnphm7YVTNwrFsg1WWLbZCpm5+Yr8q9wCsQr3AJ2BIqcsKKCqqoqFYwuYEYXp9gHMyBOJJyvBcfginoU0+CVtN5TIsvjVskfZzEcu3wIaJwrgiPr6+ugBM4xFTYkzRuIsz/y0sx1evioWG6wHYfmWNFiXkA4rUH6D4wCU4khxgHGELiAWaWJaP2bkp/Zz5b5bPH2ZJ5Zv4cupDYqdsjJOHECvHFBdXc0RxgHGwsbieqLLMzRGVZC06wzeE9JwL6TBcryp7Tp5CTiA0QbU1NREDjCWNCHN2MJoxA3kEUsvzLE0wPe/psKqzTa4cOeRWBfvgBUYsePkRYowDKitrSUkQuKFeWljccaMPDElrRd+2HAY7j58pTxiv8wpEGtxLyzfhhEnLsCwAowFzYsTU/vRiBvKE38dCEB2jkt9xM7MKxTrEhzKOO04rpwJbQARQ4DNmKk6hpL/hgJw/QNejV71P2IHwndljChQIujZyH7sHHAAYRgww9brMpY0L05MsfaKSOIMyzOX78mioFAe9Iid1R9x/ModOgP6MSIkQuLFbEv77FikWVxLJPkpOigmQXk2Un7g1z/cMdEDmKnx1fOmpr72TbV0Ci1ThuCbtH/zNTIltRO0fKPj65QOhR8czco+cMm0D8q0AfwaPWC02JL4NO6zuTfhUx2fzLmh8umcm7A5+Qnk5eMZcA8+A8S4BsTZn3/0xYI7oOXz+YPZnvoCcvNcorjEK/wBZRMz4x9ArP3jRcuXi+7DF3oW3od420vIL5BFEcp7PPyzQdQAjiAkgr6NKkmOrA0UoMLy9hco7xTFxR4cHR/9lyOOTwivQqVGAczYBjgcDz7QihNx1uc482F5WfYJnz+ARz8YLYAZ+wBizW8vWlg+3vYcZ75EFBW5FXmvz49HP3oArzmgtLxCRiSCvo06ybacP5Qjj/I5ucWiEG9aTqdHkff7owfwe23Aq+yS+YhE0LdRJw7HKM7yGDKz8kVOTpEoKCgRThddNt0KHg/GeL3C5/NxEEFrbSD9Xu+jpzkLEInhxWRl8gf8A1/5iBrINb9BAAAAAElFTkSuQmCC)50% 50%no-repeat;-webkit-transition:all .6s ease-in-out;transition:all .6s ease-in-out;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}.VIpgJd-ZVi9od-aZ2wEe-OiiCO-ti6hGc{-webkit-transform:scale(.5);transform:scale(.5);opacity:1}.VIpgJd-ZVi9od-aZ2wEe{margin:2px 0 0 2px;-webkit-animation:spinner-rotator 1.4s linear infinite;animation:spinner-rotator 1.4s linear infinite}@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}.VIpgJd-ZVi9od-aZ2wEe-Jt5cK{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285F4;-webkit-transform-origin:center;transform-origin:center;-webkit-animation:spinner-dash 1.4s ease-in-out infinite;animation:spinner-dash 1.4s ease-in-out infinite}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb html,.VIpgJd-yAWNEb-L7lbkb body,.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb h1,.VIpgJd-yAWNEb-L7lbkb h2,.VIpgJd-yAWNEb-L7lbkb h3,.VIpgJd-yAWNEb-L7lbkb h4,.VIpgJd-yAWNEb-L7lbkb h5,.VIpgJd-yAWNEb-L7lbkb h6,.VIpgJd-yAWNEb-L7lbkb p,.VIpgJd-yAWNEb-L7lbkb a,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul,.VIpgJd-yAWNEb-L7lbkb li,.VIpgJd-yAWNEb-L7lbkb table,.VIpgJd-yAWNEb-L7lbkb form,.VIpgJd-yAWNEb-L7lbkb tbody,.VIpgJd-yAWNEb-L7lbkb tr,.VIpgJd-yAWNEb-L7lbkb td{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul{list-style:none}.VIpgJd-yAWNEb-L7lbkb table{border-collapse:collapse;border-spacing:0}.VIpgJd-yAWNEb-L7lbkb caption,.VIpgJd-yAWNEb-L7lbkb th,.VIpgJd-yAWNEb-L7lbkb td{text-align:left;font-weight:normal}.VIpgJd-yAWNEb-L7lbkb input::-moz-focus-inner{border:0}div>.VIpgJd-yAWNEb-L7lbkb{padding:10px 14px}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS,.VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-r4nke{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TvD9Pc-LgbsSe{display:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-l4eHX{float:left;margin:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-PLDbbf{display:inline-block}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf{display:none;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-H9tDt{margin-top:20px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-LK5yu{float:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-qwU8Me{float:right}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-cGMI2b{min-height:15px;position:relative;height:1%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-jOfkMb-Ne3sFf{background:-webkit-linear-gradient(top,#29910d 0,#20af0e 100%);background:-webkit-gradient(linear,left top,left bottom,from(#29910d),to(#20af0e));background:linear-gradient(top,#29910d 0,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0 2px 2px #1e6609;-moz-box-shadow:inset 0 2px 2px #1e6609;-webkit-box-shadow:inset 0 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-hSRGPd{color:#15c;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}.VIpgJd-yAWNEb-L7lbkb>textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}.VIpgJd-yAWNEb-L7lbkb textarea:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);border:1px solid #4d90fe;outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-IbE0S{margin-right:10px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp{min-height:25px;vertical-align:middle;padding-top:8px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp{margin-bottom:5px;margin-bottom:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);border-radius:2px;-webkit-transition:all .218s;transition:all .218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0s;transition:all 0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe{outline:none;border:1px solid #4d90fe;z-index:4!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.gk6SMd{background-color:#eee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eee,#e0e0e0);background-image:linear-gradient(top,#eee,#e0e0e0);box-shadow:inset 0 1px 2px rgba(0,0,0,.1);border:1px solid #ccc;color:#333}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-moz-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{border-color:#3079ed}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-mrxPge{color:#999;font-family:arial,sans-serif}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-W0vJo-fmcmS{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0 5px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-u0pjoe-fmcmS{color:#800;display:none;font-size:9pt}.VIpgJd-yAWNEb-VIpgJd-fmcmS-sn54Q{background-color:#c9d7f1;box-shadow:2px 2px 4px #99a;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-xl07Ob{background:#fff;border:1px solid #ddd;box-shadow:0 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb{cursor:pointer;padding:2px 5px 5px;margin-right:0;border-style:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb:hover{background:#ddd}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb h1{font-size:100%;font-weight:bold;margin:4px 0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb strong{color:#345aad}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:right;position:absolute;right:0;left:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-j7LFlb-SIsrTd .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:left;position:absolute;left:0;right:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-fmcmS,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{color:#222}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{color:white;position:absolute!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#c9d7f1;border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-DyVDA{background-color:transparent;border:1px solid #4d90fe;border-radius:0;-webkit-border-radius:0;-moz-border-radius:0;margin:-2px;padding:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-LzX3ef{border-left:2px solid red;margin-left:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-YIAiIb{border-right:2px solid red;margin-right:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf{padding:2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);outline:none;border:1px solid #4d90fe}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-sFeBqf{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-SIsrTd{position:absolute;top:10px;right:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c,.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd .VIpgJd-yAWNEb-hvhgNd-IuizWc{text-align:right;margin:0 36px 0 0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-UTujCb{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 .VIpgJd-yAWNEb-SIsrTd{left:5px;right:auto}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}sentinel{}</style><meta name="referrer" content="no-referrer"><link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACUlBMVEUAAADwrU5Ci8rwrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU5Ci8pCi8pCi8rwrU7wrU7wrU7wrU7wrU5Ci8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8rwrU5Ci8r///8DFUmGAAAAw3RSTlMAAAAEKGus2fL8/diqaSYDNpbf+92SMgIZiOnnghYJATTB/rwvLnM/19Fcx6350ppwcZzU+virv8RaGF7Ih/QVjvY16HIFlCoXKcUhJQFbWTyp05HhexvWnZz9z2MQ8HT6vE0IsEP1pgQK54oUUMLBt/GgMwJ/+LZGBqnLkMxcDd2bS21rbDEV91sFsx/S0x60HQuFjofeKZie+fx0/iNw1a7zrINub4TgyCYvaiiy+60RdnEP9tGBHFeXxuLu7cWVVRpunw/LAAAAAWJLR0TFYwsrdwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+QLFggTAVtY6toAAAInSURBVDjLbZL3XxNBEMVvJogYQVTQEBWjIJbYFTXEhgULR6wYNYoiWGKNBYmIBcUoRgEVATWiYqPYe6+5P8yd3eTuNh/fT7vzvrfzZm8VJSawJPVJ7pvSz5rSPzVtQDoosiB94KDBGdGYMjKHDLWZEYAs+7CopOEjsgFgpAOEP2p0TjRB1twxkDfWAtwfN16v5xjkBOfESZSFfR/zJ0+ZOs3pnD5jZr7Yz4rO5kDWHHGmqyCbWoLNPXeeVSAEgG0+Xy+wLwSIZ3YXLjKAxUu4v7TINBcUFeqAbRnPZpd8WO7SgaRMWrlWSP7KYjYOGyiVAWl0f/lO6o+olniQgLxVq0kFa1jqtXTAOjcdgLi+dIMXUf4LGwnY5BDAZs23ZWuZjGwjYDvEAU0r31FRaUaSdzLt4hEFoGm793gZgP69JMVCckjAvv0HCDh4KBAIHDZ3E8CRo8eqyMfjHE4EqoMnangC9J8koNZsI546feZsLCCqdQScU7DqfP0FplD9RUTvpXh+xJCP+Q2XFQxf4cm04FXzcKg2UrGpWQeuXZf8G2KgFtSBm5WS31pOxbZ2A6i+1Wz0V2/foVrkLhqA1tEYUv00Svje/QcdvNRZRhfCgIcCibQ9evzkaVdnt0/se3pRAMGKWu0/6nkmbqzmuYovXkYS7VevS0Qm9IRZ3zdvu2W/7t176Vmgp72rqSHufvj4qdeT8LAY8vnL12/ff/ws/fX7z1/D/gfSTU83FbhV5gAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0xMS0yMlQwODoxOTowMSswMTowMJTWI/4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMTEtMjJUMDg6MTk6MDErMDE6MDDli5tCAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC"><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
 <div id="book-container">
 <div class="wrapper" style="transform:none">
 
 
 
 <div style="position:relative">
 
 <div class="podcast_body">
 <h2 class="single-post-title">
 抄本
 </h2><h2 class="single-post-title">
 Transcript
 </h2>
 <i>注意：本播客旨在供大家聆听。如果您有时间，我们强烈建议您收听音频，因为音频中包含了页面未提及的重点。</i>
 <div class="post-text transcript">
 <h2 id="introduction"><strong>介绍</strong></h2><h2><strong>Introduction</strong></h2>
<p><strong>Adam：</strong>
欢迎收听 Code Recursive，我们将在这里为您带来与软件开发领域思想领袖的对话。我是 Adam，主持人。</p><p><strong>Adam:</strong>
Welcome to Code Recursive, where we bring you discussions with thought leaders in the world of software development. I am Adam, your host.</p>
<p><strong>大卫：</strong>
嘿，丹，为什么不允许你使用递归？</p><p><strong>David:</strong>
Hey Dan, why aren’t you allowed to use recursion?</p>
<p><strong>丹：</strong>
因为你不允许使用递归。</p><p><strong>Dan:</strong>
Because you’re not allowed to use recursion.</p>
<p><strong>大卫：</strong>
是的，但是为什么不呢？</p><p><strong>David:</strong>
Yeah, but why not?</p>
<p><strong>丹：</strong>
因为你不被允许这样做。</p><p><strong>Dan:</strong>
Because you’re not allowed to.</p>
<p><strong>大卫：</strong>
所以如果你想让你的程序与证明相对应，那么直接使用实际递归（其中某物引用自身）就对应于循环推理。</p><p><strong>David:</strong>
So if you want your programs to correspond to proofs, then direct uses of actual recursion where something refers to itself corresponds to circular reasoning.</p>
<p><strong>Adam：</strong>
你可以编写更正确的软件，甚至可以进行严格的数学证明。之前的嘉宾，例如 Edward Brady 和 Stephanie Weirich，已经讨论过依赖类型系统可以实现的一些激动人心的功能。Miles Saben 说：“[听不清 00:01:00] 未来肯定是这样的。” 这次采访将帮助我们为这样的未来做好准备。</p><p><strong>Adam:</strong>
You can write more correct software and even rigorous mathematical proofs. Previous guests like Edward Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do. Miles Saben said, “[inaudible 00:01:00] surely the future.” This interview is going to get us ready for that future.</p>
<p>Dan Freeman 以他的系列丛书而闻名，包括《Little Schemer》、《Little Prover》、《Little MLer》等等。这些书备受推崇。亚马逊书评里有这样一段关于《Little Schemer》的评价：“《Little Schemer》教会了我们一件非常难教的事情，一件每个专业程序员都应该知道的事情，而且它做得非常好。” 他的最新著作名为《Little Typer》，全是关于类型，特别是依赖类型的。Dan 的合著者是 David [Christiansen 00:01:43]，Idris 是播客 [Type Siri 00:01:49] 的撰稿人和主持人。坦白说，这超出了我的理解范围。</p><p>Dan Freeman is famous for his little series of books, including the Little Schemer, the Little Prover, Little MLer, and so on. These books are held in high regard. Here’s a quote about the Little Schemer from Amazon book review, Little Schemer teaches one thing, a thing that is very difficult to teach a thing that every professional programmers should know and it does it really well. So his latest book is called the Little Typer and it’s all about types, specifically dependent types. Dan’s co-author is David [Christiansen 00:01:43] and Idris contributor and host of a podcast about [Type Siri 00:01:49]. That is frankly way over my head.</p>
<p>他们将一起教我们如何运用现有的编程技能来开发严谨的数学证明。也请继续关注本期节目的结尾，我会简要介绍我是如何学习《技巧与诀窍》这本书的。如果您还没有订阅本期播客，建议您订阅，这样新的节目将自动推送给您。此外，我还为本期播客创建了一个 Slack 频道。如果您想讨论本期节目或其他节目，或者只是想与其他听众聊天，可以加入 Slack 频道。您可以在网站上找到链接。丹和大卫，欢迎收听本期播客。</p><p>Together they’re going to teach us how the programming skills we already have, can be used to develop rigorous mathematical proofs. Also stay tuned to the end of the episode, and I’ll give a little brief overview of how I worked through the book, Tips and Tricks. If you haven’t subscribed to this podcast yet, I recommend you do so, so that new episodes will be delivered automatically to you. Also, I’ve set up a Slack channel for the podcast. If you want to chat about this episode or any episodes, or just chat with fellow listeners, you can join the Slack channel. You will find the link on the website. So Dan and David, welcome to the podcast.</p>
<h2 id="what-are-dependent-types"><strong>什么是依赖类型？</strong></h2><h2><strong>What Are Dependent Types?</strong></h2>
<p><strong>大卫：</strong>
感谢您的邀请。</p><p><strong>David:</strong>
Thanks for having us on.</p>
<p><strong>丹：</strong>
非常感谢。</p><p><strong>Dan:</strong>
Appreciate it.</p>
<p><strong>Adam：</strong>
我有一本你们写的书《Little Typer》，里面全是关于依赖类型的。所以我想先问你们，什么是依赖类型？</p><p><strong>Adam:</strong>
I have this book that you guys wrote the Little Typer, all about dependent types. So I thought I would start off by asking you guys so, what are dependent types?</p>
<p><strong>David：</strong>
依赖类型是指能够包含普通程序的类型。在像 [Haskell 00:03:09] 这样的语言中，我们可能有一个 A 的类型列表，其中 A 可以是任何旧类型。但在依赖类型语言中，除了类型之外，还可以包含其他类型。例如，你可能会说 nAs 列表，其中 n 是列表中元素的数量，然后你的类型系统突然需要了解数字以及对数字进行算术运算的含义。例如，如果存在两个这样的列表，那么你将能够在类型中看到输出的长度是输入长度的总和之类的信息。</p><p><strong>David:</strong>
So dependent types are types that are able to contain ordinary programs. So we might in a language like [Haskell 00:03:09] or something, you might have a type list of A where A could be any old type, but in a dependently type language, you could also have things other than types there. So you might say like the list of nAs, where n is the number of things in the list, and then your type system, all of a sudden needs to know about numbers and what it means to do arithmetic on numbers. So for example, a pending two of these lists, then you’ll be able to see in the type that the length of the output is the sum of the lengths of the inputs and that sort of thing.</p>
<p><strong>亚当：</strong>
这有什么用处？</p><p><strong>Adam:</strong>
Why is that useful?</p>
<p><strong>David：</strong>
所以，考虑到它作为例子出现的频率，它并没有你想象的那么有用，只是因为它是一个很好的例子。但依赖类型很有用，因为它们允许你编写非常精确的类型，这些类型比你原本能够表达的更能说明你的程序。</p><p><strong>David:</strong>
So that one is less useful than you might think given how often it comes up as an example, just because it’s such a good example. But dependent types are useful because they allow you to write very precise types that say a lot more about your program than you’d otherwise be able to say.</p>
<p><strong>Dan：</strong>
是的，我认为这是最重要的一点。像 [inaudible 00:04:10] 或 Idriss 这样的语言拥有更多类型，但正是更多类型赋予了你这种能力，以及其背后的工业级优势。我们正在努力使这本书相对通俗易懂，让你能够体会到编写依赖类型程序的意义。</p><p><strong>Dan:</strong>
Yeah, that one is I think the more important point. And languages like [inaudible 00:04:10], or Idriss have more types, but it’s just more types that gives you this capability, plus industrial strengths underneath it. We’re trying very hard to make this book be something that’s relatively easy to understand, to get the feel for what it means to be writing programs with dependent types.</p>
<p><strong>David：</strong>
依赖类型不仅仅是简单地写下一个非常精确的类型。这样做很好，因为你可以从编程语言实现和编写程序中获得更多帮助。而且，你还可以在此基础上创建非常好的交互式环境。类型系统的另一种用途是作为数学运算的逻辑，而依赖类型系统是一种非常丰富的表达逻辑，可以让你讨论各种不同的事情。所以，你也可以去做一些感觉很像编写程序的事情，但实际上你已经证明了一个定理，我认为这真的很有趣。</p><p><strong>David:</strong>
And dependent types are also about more than just writing down a very precise type. Doing that as nice, because you can get more help from your programming language implementation and writing your program. And you can make really nice interactive environments on top of that. The other way that you can use a type system is as a logic for doing mathematics, and a dependent type system is a very rich expressive logic that lets you talk about all sorts of different things. So you can also go and do something that feels very much like writing a program, but you’ve actually proved a theorem, which I think is really fun.</p>
<p><strong>丹：</strong>
是的。这真是太酷了。反正我心里毫无疑问……你只要有一个特定类型的程序，如果把这种类型看作一个定理，那么这个程序就被认为是证明。我太喜欢这个比喻了，太喜欢了。</p><p><strong>Dan:</strong>
Yeah. That is the coolest part. There’s no question in my mind anyway that you can… You just have a program of a certain type and that if that type is thought of as a theorem, then that program is thought of as the proof. And I just love that metaphor. Just love it.</p>
<h2 id="dependent-types-or-no-types-at-all"><strong>依赖类型或根本没有类型</strong></h2><h2><strong>Dependent Types or No Types at All</strong></h2>
<p><strong>亚当：</strong>
丹，你之前的很多书都是关于 Scheme 的，我猜它不是一种以类型系统而闻名的语言，我想是的。</p><p><strong>Adam:</strong>
And Dan a lot of your previous books are about scheme, which I guess it’s not a language known for its type system, I guess so.</p>
<p><strong>Dan：</strong>
确实如此。不过 Racket 确实有一个类型系统，也就是所谓的“发生类型”。事实上，我们使用了 Racket 中的很多类型来实现我们的系统。</p><p><strong>Dan:</strong>
That’s certainly true. Although Racket does have a type system. This is something called occurrence types. And in fact, we used a lot of the types that are in Racket in order to implement our system.</p>
<p><strong>亚当：</strong>
那么你总体上是支持型还是依赖型？</p><p><strong>Adam:</strong>
So are you pro types in general or just dependent types?</p>
<p><strong>Dan：</strong>
到目前为止，我只支持依赖类型。我只是喜欢这个想法：你只需编写一个类型并证明它正确即可。我认为这很棒，因为类型语言比更传统的语言要广泛得多。而且我认为……我仍然不是它的忠实拥趸。部分原因是我想用类型编写的程序根本无法实现。事实上，有些已发表的论文指出，你无法编写我所说的反射。有些已发表的论文指出，你不能使用 [听不清 00:07:03] 类型来证明你想要证明的属性。这就是我喜欢依赖类型的原因之一，因为似乎没有一个大框架可以限制它，说你不能这样做或那样做。</p><p><strong>Dan:</strong>
I am so far only in the dependent types camp. I just like the idea that you can just write a type and prove it correct. I think that’s fabulous, because the language of types is much broader than the language that are used in more conventional languages. And I think that’s… I’m still not a big fan. I’m partially because of the programs that I wanted to write with types, it was impossible. In fact, there’s published papers on the fact that you can’t write what I call reflection. There are published papers that say you can’t use [inaudible 00:07:03] types to prove properties that you want to prove. And that’s one of the reasons why I like dependent types, because there doesn’t seem to be a big circle you can draw around it that says you can’t do this and stuff like that.</p>
<p><strong>亚当：</strong>
所以你认为非依赖类型具有限制性，而依赖类型具有赋权性，是这样吗？</p><p><strong>Adam:</strong>
So you think that non-dependent types are limiting, but dependent types are empowering, is that the idea?</p>
<p><strong>丹：</strong>
我就是这么想的。我不能代表大卫说话。</p><p><strong>Dan:</strong>
That’s how I feel. I can’t speak for David.</p>
<p><strong>David：</strong>
他的话确实不能代表我。我喜欢用各种不同的方式编程，而且我喜欢各种编程语言，这些编程语言要么没有时间只使用一种大的类型（取决于你属于哪个哲学阵营），要么像我工作时读了很多 Haskell 的语言，我觉得这很有趣，而且我也使用依赖类型。我喜欢各种编程方式。</p><p><strong>David:</strong>
He indeed is not speaking for me there. I like programming lots of different ways and I have fun in languages, which either don’t have time to just have one big type depending on which philosophical camp you’re in or those like I read a lot of Haskell at work and I think that’s a lot of fun and I do dependent types as well. I like lots of ways to program.</p>
<p><strong>Adam：</strong>
我也喜欢类型。我发现依赖类型我还不太清楚它们是怎么运作的，不过我正在研究你的书。希望到最后，一切都能弄清楚。</p><p><strong>Adam:</strong>
I like types also. Dependent types I find I’m not quite sure how they work yet, but I’m working through your books. So hopefully by the end, it’s all going to make sense.</p>
<p><strong>大卫：</strong>
我希望如此。</p><p><strong>David:</strong>
I hope so.</p>
<p><strong>亚当：</strong>
那么在书中你介绍了你为这本书创建的语言饼图。</p><p><strong>Adam:</strong>
So in the book you introduce this language pie that you created for the book.</p>
<p><strong>丹：</strong>
是的。具体来说，</p><p><strong>Dan:</strong>
Yes. Specifically,</p>
<p><strong>亚当：</strong>
这背后的意图是什么？</p><p><strong>Adam:</strong>
What’s the intent behind that?</p>
<p><strong>大卫：</strong>
所以我们认为我们需要为这本书创建自己的语言，而不是使用像 Coq、[听不清 00:08:32]、Idriss 或其中之一这样现成的成熟语言，是因为这些语言投入了大量精力来自动化所有可能繁琐、困难或需要理解的部分，并且为了完成工作，你不会被迫在稍后才面对系统的内部运作。</p><p><strong>David:</strong>
So the reason why we thought we needed to make our own language for this book, rather than using sort of an off the shelf well-developed language like Coq, or [inaudible 00:08:32], Idriss, or one of those was that those languages put a lot of effort into automating a way, all of the sort of parts that can be tedious or difficult or require understanding, and in the interest of getting work done, you’re not sort of forced to confront the inner workings of the system until later on.</p>
<p>我们认为，提供一种非常精简的语言会更容易，让人们……[听不清 00:09:03] 更容易，我的意思是，实际上更难。这样你就能更容易地通过努力学习来学习。此外，它还让我们有一个实现。我们最初希望将该语言的完整实现作为本书的最后一章。不幸的是，我们没能把它做得足够小。所以我们有很多关于如何实现它的描述。此外，我还编写了一个在线教程。</p><p>And we thought that it’s going to be easier to give a very minimal language that people… And [inaudible 00:09:03] easier, I mean, actually more difficult. Easier for you to learn things by having to work hard at it. And additionally, it let us have an implementation. We had initially hoped to have the entire implementation of the language be the last chapter of the book. Unfortunately, we didn’t manage to get it quite small enough. So we have quite a lot of description of how you would implement it. And then there’s an online tutorial I wrote as well.</p>
<p><strong>亚当：</strong>
哦，真的吗？</p><p><strong>Adam:</strong>
Oh, is it really?</p>
<p><strong>大卫：</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>亚当：</strong>
语言是如何被创造出来的？</p><p><strong>Adam:</strong>
About how the language was created?</p>
<p><strong>David：</strong>
如果你想自己写一个，并且想了解源代码，这个教程有多久了？该语言的源代码是免费提供的，任何人都可以下载、修改和破解它，只要他们愿意。目前至少有一种变体方言已经存在，我希望将来会有更多。</p><p><strong>David:</strong>
How old is it the tutorial, if you want to make your own and if you want to understand the source code. The source code of the language is freely available, anyone can download it and modify it and hack on it if they want, there’s at least one variant dialect already in the wild, and I hope that there’ll be a lot more in the future.</p>
<p><strong>亚当：</strong>
有趣的是，因为我确实看过 GitHub 仓库，它不是很大。</p><p><strong>Adam:</strong>
The interesting thing is, because I did look at the GitHub repo, it’s not very big.</p>
<p><strong>大卫：</strong>
谢谢。</p><p><strong>David:</strong>
Thank you.</p>
<p><strong>丹：</strong>
好吧，无论如何都要感谢大卫。</p><p><strong>Dan:</strong>
Well, thank David by all means.</p>
<p><strong>大卫：</strong>
我们都致力于此。</p><p><strong>David:</strong>
We both worked on it.</p>
<p><strong>丹：</strong>
我知道。</p><p><strong>Dan:</strong>
I know.</p>
<p><strong>David：</strong> 
Dan 对代码的简洁性和精简性有着非常严格的标准，这在项目开发中非常有用。所以，上面的实际实现中大约有一半的代码是交互式用户界面之类的东西，对吧？它包含一些尚未公开的部分，但我希望将来能更多地公开，以便实现一些功能，比如在演讲时，可以在幻灯片中添加可编辑的 Pie 代码，这样你就可以在观众面前编辑代码，并观察类型检查器的响应。它还有一个 [DrRacket 00:10:38] 插件，这样你就可以将鼠标悬停在表达式上，查看它们的类型等等。系统的实际核心已经尽可能地精简了。嗯，有些部分比较复杂，因为处理图形用户界面需要更多的代码。</p><p><strong>David:</strong>
Dan has very exacting standards for simplicity and smallness of code that are very useful when working on a project. So, the actual implementation up there is also about half of that code is sort of interactive user interface kind of stuff, right? So it includes some parts that are not really exposed undocumented yet, but that I hope to make more public in the future for doing things like having editable Pie code inside of a slide if you’re doing a talk somewhere, so you can sort of edit code in front of people and watch the type checker respond. And it has plugin for [DrRacket 00:10:38] so that you can put the mouse over expressions and see what their types are and those sorts of things. And the actual core of the system is as small as we could possibly make it. Well, some of those things are a little hairier, just because dealing with graphical user interfaces requires just a more code.</p>
<p><strong>亚当：</strong>
这种语言的实现是用 Racket 编写的，为了使用它，我下载了 DrRacket，并在开头放了 Lang Pie，就是这样。</p><p><strong>Adam:</strong>
And this language is, so the implementation is written in racket and to use it, I downloaded DrRacket and I put like Lang Pie at the beginning, and that was about it.</p>
<p><strong>丹：</strong>
嗯（肯定）。没错。</p><p><strong>Dan:</strong>
Mm-hmm (affirmative). That’s right.</p>
<p><strong>David：</strong>
 Racket 的开发者都有教育背景。所以他们非常积极地致力于简化设置，方便在多台机器上操作等等。</p><p><strong>David:</strong>
The racket developers have a background in education. So they’re very motivated to make things simple to set up and easy to work on multiple machines and that sorts of thing.</p>
<p><strong>亚当：</strong>
我发现这些语言有趣的一点是，它们使用的词语不是类型注释，而是声明，那么语言中使用的措辞背后有什么原因吗？</p><p><strong>Adam:</strong>
One thing I found interesting about the languages is just the words it uses for things like instead of having a type annotation, you have a claim, was there reasons behind the verbiage used in the language?</p>
<p><strong>丹：</strong>
是的。我的意思是——</p><p><strong>Dan:</strong>
Yeah. I mean-</p>
<p><strong>大卫：</strong>
是的。我想我们已经实施了……丹，你觉得怎么样？10到12次就扔掉了？是的。</p><p><strong>David:</strong>
So, yeah. I think we’ve implemented this thing about… What do you say Dan? 10 to 12 times and thrown them away? Yeah.</p>
<p><strong>Dan：</strong> 
……四五个，七个，我不知道具体数字有多大，但我们最初只有一个表达式，可以同时表达类型和程序。后来它变得越来越笨拙，我们最终坐下来讨论这个问题，把它改成了两个不同的表达式。我不认为声明是一种类型注解，而更像是我们试图得到一个好的表达式，能够代表我们想要证明的[听不清 00:12:39]。</p><p><strong>Dan:</strong>
… four or five, seven, I don’t know some ridiculous large number, but we originally had one expression that captured both the type and the program. And it was getting clumsy and we finally sat down and chatted about that and we changed it to be with two different things. I don’t think of a claim kind of as a type annotation, but more like we’re trying to get a good expression that represents what the [inaudible 00:12:39] we want to prove so to speak.</p>
<p><strong>David：</strong>
所以，声明是……对于那些还没读过这本书或用过 Pie 的人来说。在 Pie 中，如果你想做一个顶级定义，你首先要做的是使用关键字 claim，然后依次输入声明、名称和类型，之后定义、名称以及应该具有该类型的表达式。所以，最初我们有一种引入定义的方式，就是把类型和程序放在一起，但这在书中篇幅过长。事实证明，如果我们能把两者分开，对写作会更好。</p><p><strong>David:</strong>
So claim is… For those listening to this who haven’t read the book or worked with Pie. In Pie, if you want to do a top level definition, the first thing you do is you use the keyword claim, and then you put claim and then the name and then the type, and then later you define and then the name and then some expression which should have that type. And so initially we had one way of introducing a definition where you put down the type and the program together, and it just got to be too big in the book. And it turned out to be better for the writing, if we could separate the two from each other.</p>
<p><strong>丹：</strong>
这些小书里的小盒子可能是一个相当大的挑战。</p><p><strong>Dan:</strong>
These little boxes can be quite a challenge that are in the little books.</p>
<h2 id="on-the-little-book-format"><strong>关于“小书”格式</strong></h2><h2><strong>On ‘The Little’ Book Format</strong></h2>
<p><strong>亚当：</strong>
是的，我敢打赌。这实际上是我第一次读……我买了《小打字员》和《小计划员》，一直在练习。所以这是我第一次接触这种模式。我觉得它超级有趣。那么它是怎么做到的呢……对于不熟悉的人来说，它有点像一种对话模式，你可以来回交谈，以一种非常反复的方式学习知识。那么这种结构是从哪里来的呢？</p><p><strong>Adam:</strong>
Yeah, I bet. So, this is actually the first time that I’ve read… I bought both the Little Typer and the Little Schemer and I was working through them. So this is my first introduction to that format. And I thought it was super fun. So where does this like… So for people who aren’t familiar it has kind of a dialogue format where you’re talking back and forth and learning about things in a very iterative fashion. So where does that structure come from?</p>
<p><strong>丹：</strong>
嗯，我在获得博士学位之前曾是公共政策教授，当时我在林登·贝恩斯·约翰逊公共事务学院教学生。有一天，学生们[听不清 00:14:14]问：“我们可以一起做点什么吗？”我说：“当然可以。” 我租了一间屋子，我们工作了整整一周，从房间的一端走到另一端，写出了《细语》（Little Whisper）。房间里有一块黑板，人们随声附和着各种内容。比如，我真的记不清我们什么时候决定把食物放进去，但肯定是房间里的某个人做的。可能是我。我可能记不清了。我们写这本书是在1973年，出版是在1974年。而且都是在IBM Selectric上完成的。还有很多其他的故事与此有关，但我还是留到以后再说吧，毕竟在当时，这的确是一项艰巨的任务。我甚至没有输入它，而是其他人在 IBM Selectric 中输入的。</p><p><strong>Dan:</strong>
Well, I used to be a professor of public policy before I got my doctorate, and I was teaching the students at the Lyndon Baines Johnson School of Public Affairs. And one day the students [inaudible 00:14:14], “Can we do something together on this?” And I said, “Sure.” And I grabbed a room and we worked for a solid week and we wrote the Little Whisper by walking from one end of the room to the other, where there was a blackboard and people were chiming in with different things. For example, I really can’t remember when we decided to put in the food, but it certainly was by somebody in the room. It may have been me. I couldn’t possibly remember it. It was 1973 when we wrote it and 74 when it came out. And it was all done on an IBM Selectric. And there’s a lot of other stories that go with that, but I’ll save that for something a little more interesting, but yeah, it was quite a task back then. I didn’t even type it someone else typed it in the IBM Selectric.</p>
<p><strong>亚当：</strong>
我喜欢，就像它让我对……有了很好的理解。说实话，我发现有些部分……我正在读这本书。我在第151页做了个标记，但我又往前翻了一点。我直接跳到前面去了，尽管书上说不要这么做。</p><p><strong>Adam:</strong>
I like the, like it gave me a good sense for… To be honest, I found some parts… I’m working through the book. So I have a book mark here on page 151, but I’ve scanned through a little bit further. I’ve jumped ahead a little bit, even though the book said not to.</p>
<p><strong>大卫：</strong>
别那样做。</p><p><strong>David:</strong>
Don’t do that.</p>
<p><strong>丹：</strong> 
[交谈 00:15:32]。[听不清 00:15:34]，你不会想这么做的。</p><p><strong>Dan:</strong>
[crosstalk 00:15:32]. [inaudible 00:15:34], you don’t want to do that.</p>
<p><strong>亚当：</strong>
所以我觉得这本书有时挺有挑战性的，但这种反复的阅读节奏让阅读保持了节奏。所以，我觉得即使我读起来很吃力，至少也只是在很小的片段里挣扎。</p><p><strong>Adam:</strong>
So I found the book to be a challenge at times, but I found that this back and forthnes it keeps the pace going. So, I felt like even though I was struggling that at least I was struggling in very small chunks.</p>
<p><strong>丹：</strong>
确实如此。实际上，我有时会建议，如果你觉得自己还没完全理解，就应该回去再读一遍那一章。</p><p><strong>Dan:</strong>
It does. I actually sometimes suggest that if you don’t feel you’ve got 100% of it, you should really go back and read that chapter over again.</p>
<p><strong>亚当：</strong>
我回去了。</p><p><strong>Adam:</strong>
I have gone back.</p>
<p><strong>丹：</strong>
确实如此，这本书的字数很少，多读几遍也没什么坏处，甚至可以边读边做些笔记。</p><p><strong>Dan:</strong>
It is definitely, there are very few words in the book and there’s no harm in rereading it, and maybe even taking some notes as you’re going along.</p>
<p><strong>亚当：</strong>
所以之前我说过，这个断言是一种类型，而丹说，不，它是一种证明。这或许触及了问题的核心，不是吗？</p><p><strong>Adam:</strong>
So earlier I said something like that the claim was a type and Dan said, no, it’s a proof. And that maybe gets at the heart of the matter, doesn’t it?</p>
<p><strong>丹：</strong>
不，这是一个定理。</p><p><strong>Dan:</strong>
No, it’s a theorem.</p>
<p><strong>亚当：</strong>
哦，这是一个定理。</p><p><strong>Adam:</strong>
Oh, it’s a theorem.</p>
<p><strong>大卫：</strong>
除非你证明它，否则它就不是一个定理。</p><p><strong>David:</strong>
It’s not a theorem until you prove it.</p>
<p><strong>丹：</strong>
对。但是它[听不清 00:16:31]。</p><p><strong>Dan:</strong>
Right. But it’s [inaudible 00:16:31].</p>
<p><strong>大卫：</strong>
这只是一个声明。我理解[听不清 00:16:35]这些事情。这是一种职业[交谈 00:16:37]。</p><p><strong>David:</strong>
It’s a statement. I get [inaudible 00:16:35] about these things. It’s a occupational [crosstalk 00:16:37].</p>
<p><strong>丹：</strong>
没关系。</p><p><strong>Dan:</strong>
It’s fine.</p>
<p><strong>大卫：</strong>
所以我们确实有一种在 Pie 中进行类型注释的方法，那就是称为的表达式，我们称之为的原因是因为我们认为如果 Idris 和 Common Lisp 都将其类型 [听不清 00:16:56] 运算符称为，那么我们就很团结了。</p><p><strong>David:</strong>
So we do have a way of doing type annotations in Pie, which is that expression called the and the reason we called it the was because we figured if Idris and Common Lisp both call their type [inaudible 00:16:56] operator, the, then we’re in good company.</p>
<p><strong>亚当：</strong>
好的，很好。</p><p><strong>Adam:</strong>
Okay, nice.</p>
<p><strong>David：</strong>
是的，所以我想这就是我们进行类型注解的方式。也许这就是为什么你之前反对它被称为类型注解的原因，Dan，我不知道？</p><p><strong>David:</strong>
Yeah, so I guess that’s how we do our type annotations. Maybe that’s why you were objecting to it being called type annotation before Dan, I don’t know?</p>
<p><strong>丹：</strong>
是的，绝对如此。我想如果我们要讨论这个问题，就应该先谈谈我们现有的资源。</p><p><strong>Dan:</strong>
Yes, absolutely. I figured if we’re going to talk about it we should talk about what we have.</p>
<h2 id="curry-howard"><strong>库里-霍华德</strong></h2><h2><strong>Curry-Howard</strong></h2>
<p><strong>亚当：</strong>
所以，我猜类型和定理之间的对应关系是……</p><p><strong>Adam:</strong>
So, the correspondence between types and theorems, I guess, is a…</p>
<p><strong>丹：</strong>
你现在谈论的是 Curry–Howard 同构吗？</p><p><strong>Dan:</strong>
Curry–Howard isomorphism, you’re talking about now?</p>
<p><strong>亚当：</strong>
是的，但我希望你们中的一个人能够详细说明一下，因为我什么都不知道，而我这里有一些专家。</p><p><strong>Adam:</strong>
I am, but I was hoping to get one of you to maybe expand on it because I know nothing, and I have some experts here.</p>
<p><strong>大卫：</strong>
我怀疑你知道一些事情。</p><p><strong>David:</strong>
I suspect you know some things.</p>
<p><strong>Dan：</strong>
但基本上，在比喻中，它是两个名称和一个概念。所以定理和类型基本上是一个名称，程序和证明是一个概念。当然，它是程序的证明，类型的证明，或者……抱歉，是类型的定理或程序的证明。所以你同时拥有它们，正如我所说，这被称为 Curry Howard 同构，你可以从中获得很多好处。</p><p><strong>Dan:</strong>
But basically in the metaphor, it’s two names and one concept. So theorem and type is basically one name, and program and proof are one concept. And of course it’s the proof of the program, the proof of the type or the… Sorry, proof of the theorem or program of the type. So you have both of them, and as I said, that’s called the Curry Howard isomorphism where you can get a lot of mileage out of this.</p>
<p><strong>亚当：</strong>
我想，我从这本书中学到的有趣的事情是，我为编写软件而开发的一些技能可以通过这种同构转化为数学。</p><p><strong>Adam:</strong>
The interesting thing that I’m learning from this book, I guess, is that some of my skills that I’ve developed for writing software, I guess, can translate via this isomorphism to do math, I guess.</p>
<p><strong>Dan：</strong>
是的。真正的数学。这是我第一次看到真正的数学，没有那么多花哨的装饰。它非常直接，非常简单，我们假设你曾经使用过 Scheme、Racket、Lisp 或任何带括号的语言，并且对递归非常熟悉。我相信你已经读到这里，发现递归的舒适性是必要的，但我就不多说了。</p><p><strong>Dan:</strong>
Yeah. Real math. It’s the first time I’d ever seen real math that didn’t come with an awful lot of bells and whistles. This is very direct, very simple, and our assumption is that you’ve had some experience with using a language like scheme or racket or Lisp or any of the parenthesized guys, and you’re very comfortable with recursion. And I’m sure you’ve read that far where you discovered the comfort with recursion it’s necessary, but I won’t go into any more details than that.</p>
<p><strong>大卫：</strong>
就柯里-霍华德规则而言，我认为丹，有很多人忽略了其中很重要的一点，而我没听到你说。柯里-霍华德规则对应关系实际上就是柯里和霍华德都观察到的现象：不仅直觉逻辑中的语句可以直接映射到类型，直觉逻辑中的证明可以直接映射到[听不清 00:19:47] 微积分中的程序，而且[听不清 00:19:52] 微积分中的规范化表达式也对应于切割消去，也就是说……所以我们在逻辑学中得出的最重要的结论之一是，任何使用切割规则（允许你做出局部假设的规则）编写的证明，都可以简化为不使用切割规则的证明，但仍然证明了同一件事。事实证明，规范化证明的过程与规范化程序的过程相同。所以，我们不仅知道每个证明都对应一个程序，而且写出证明并将其推导为最直接的形式也相当于运行程序直到完成。这是非常重要的一点。</p><p><strong>David:</strong>
So as far as Curry–Howard goes, I think there’s something important Dan that a lot of people gloss over and that I didn’t hear you say. So Curry–Howard correspondence is really sort of Curry and Howard both observed this, that not only do statements written in intuitionistic logic map directly to types and proofs written intuitionistic logic map directly to programs in the [inaudible 00:19:47] calculus, but also that normalizing expressions in [inaudible 00:19:52] calculus corresponds to cut elimination, which is to say that… So one of the most important results we have in logic is that any proof written using the cut rule, which is the rule that allows you to sort of make local assumptions, can be simplified to approve that doesn’t use the cut rule, but that still proves the same thing. And it turns out that that process of normalizing proofs is the same process of normalizing programs. So not only do we have that every proof corresponds to a program, but also that writing our proofs out and pushing them down into the most direct form corresponds to running our programs until they’re done. And that’s a very important aspect of it.</p>
<p><strong>丹：</strong>
是的。说实话，我觉得你讲得比我好多了，不过还是那两个我在课堂上摆放的盒子。</p><p><strong>Dan:</strong>
Yeah. I think that you’ve covered it a lot better than I did truthfully, but it’s still the two boxes I put up in my class.</p>
<p><strong>大卫：</strong>
是的，是两个盒子，但又不仅仅是两个盒子。它们[交谈 00:20:52] 的方式也相同，我认为这才是真正酷的地方。我们之间也有类似的对应关系，比如你最近在节目中采访了菲尔·怀尔德，他也针对其他很多逻辑谈到了这一点。所以我认为任何对此真正感兴趣的人都应该去听听那次采访。所以，我们有一种更有趣的直觉逻辑版本，你可以讨论个体，它能提供依赖类型，因为你不仅可以拥有 A 和 B 类型的语句，还可以拥有关于某个对象的谓词。</p><p><strong>David:</strong>
Yeah, it’s the two boxes, but it’s more than just the two boxes. It’s also that they [crosstalk 00:20:52] the same way, which I think is what’s really cool about that. And we have similar correspondences, like so you had Phil Wilder on your show recently, and he talked quite a lot about this for a lot of other logics as well. And so I think anyone who’s really interested in this should go listen to that interview. So, we have that sort of a more interesting version of intuitionistic logic where you can talk about individuals that gives you dependent types, because you’re able to have statements that aren’t just sort of A and B, but also predicates about some object.</p>
<p>比如，你可以说这两个数字相等，或者如果……是的，两个数字相等，这是一个很好的例子。你必须能够讨论单个数字，或者你可以说，对于所有数字 N 和 M，将 N 加到 M 等于将 M 加到 N 上。诸如此类的说法，比如对于所有存在，以及你所说的具有个体意义的事物，实际上就是通过添加依赖类型来实现的。但如果你想获得其他逻辑，你也可以弄清楚如何将它们作为程序运行。我认为这真的非常非常酷。</p><p>Like you could say the two numbers are equal or that if… Yeah, two numbers are equal, that’s a good example. You have to be able to talk about the individual numbers or you can say things like for all the numbers N and M adding N to M is equal to adding M to N. And these sorts of things saying, like for all and exists and having individual things you’re talking about, that’s really what you get from adding dependent types to the mix. But if you want to get other logics, you can also figure out how to run those as programs. And that’s really, really cool I think.</p>
<h2 id="normalization"><strong>正常化</strong></h2><h2><strong>Normalization</strong></h2>
<p><strong>亚当：</strong>
您提到了规范化，书中让我感兴趣的一点是，规范化的概念，我想知道您是否可以举例说明它是什么，以及它与评估有何关系？</p><p><strong>Adam:</strong>
You mentioned normalization and something that was interesting to me in the book was, well, this concept of normalization, I wonder if you could describe what it is and with an example and how it relates to evaluation?</p>
<p><strong>David：</strong>
所以，当你在像 Pie 这样的语言中使用类型时，这些类型不仅仅是对表达式进行某种分类，比如说这个是数字，这个是数字列表，或者这个是函数（你传入一个数字，它会返回一个数字列表）。它们还会告诉你它们描述的哪些东西与它们描述的哪些东西相同。所以你知道五加八和 13 是同一个自然数。你还知道，将包含一、二、三的列表颠倒过来，得到包含四、五、六的列表，和包含一、二、三、四、五、六的列表是一样的。你可以把这些彼此相同的事物组看作是桶。</p><p><strong>David:</strong>
So when you have types in a language like Pie, the types don’t just sort of classify expressions saying this one is a number or this one is a list of numbers, or this one is a function where you give it a number and it gives you back a list of numbers. They also tell you which of the things they describe are the same as which other things they describe. So you know that five plus eight is the same natural number as 13. And you know that upending the list containing one, two, three to the list containing four, five, six is the same as the list containing one, two, three, four, five, six. You can look at these sort of groups of things that are the same as each other, as sort of being buckets.</p>
<p>你把所有的数字列表放进不同的桶里，然后把它们分开，这样每个数字就和与之相同的数字归为一类。然后，对于每个桶，我们都有一个最简单、最直接的代表，可以从中挑选出来，并且有一种方法可以找到这个代表，无论桶里有什么。这就是我们所说的范式。也就是说，我们从每个相同的事物集合中挑选一个代表。因为我们有办法找到桶里任何事物的代表，所以我们可以通过找到它们的范式来判断两个事物是否在同一个桶里。事实证明，挑选这些范式的一个好方法是进行所有的计算，直到全部完成。</p><p>And you take all of your lists of numbers and you put them into the buckets, divide them up, such that each one is grouped with the ones that it is the same as, and then for each of these buckets, we have sort of a simplest, most direct representative that we can pick out of that bucket and a way to find that representative given anything in there. And that’s what we call the normal form. So it’s sort of, we pick one representative from each collection of things that are the same as each other. And because we have a way of finding that representative for anything in the bucket, we can tell whether two things are in the same bucket by finding their normal forms. And it turns out that a good way to pick those normal forums is to do all your computation until it’s all done.</p>
<p>虽然 Pie 中的某些类型有一些额外的规则，而不仅仅是程序运行的规则。例如，X 的 lambda F 与单独的 F 函数相同。因此，为了找到函数的范式，我们必须将它们包装在尽可能多的 lambda 表达式中，直到找到为止。Unit 类型在 Pie 中被称为“平凡”，因为它对应于一种平凡理论或平凡陈述，并且很容易证明，因为它只有一个构造子，所以我们可以直接说，嗯，所有类型都一样，无论它是否是那个构造子，因为最终它会是。</p><p>Although some of the types in Pie, they have some additional rules that are more than just running the program. So for example lambda F of X is the same function as just F on its own. So in order to find the normal forms of functions, we have to sort of wrap them in a maximum number of lambdas until they get figured out. And the unit type, which we call a trivial in Pie, because it corresponds to sort of a trivial theory or a trivial statement that’s really easy to prove, since it’s only got one constructor, then we just go ahead and say, well, everything, and it’s the same as everything else, whether or not it’s that constructor, because eventually it would be.</p>
<p>所以，要找到 unit 类型函数的正常形式，你只需要使用 unit 构造函数之类的东西。但大多数类型，你只需要运行程序直到它完成，就能得到正常形式。但运行程序直到它完成，也包括进入 lambda 表达式的底层并运行它们，这让它变得非常有趣。</p><p>And so to find the normal form of something with the unit type you just take the unit constructor and those sorts of things, but most types, you just run the program until it’s done, and then you have the normal form. But running the program till it’s done, also includes like going in and underneath lambdas and running those, which makes it extra fun.</p>
<p><strong>丹：</strong>
我以为你会跳过这八个，但我想你没有。</p><p><strong>Dan:</strong>
I thought you were going to skip the eight along, but I guess you didn’t.</p>
<p><strong>大卫：</strong>
丹说是八个，就是把所有最大数量的 lambda 表达式放在函数周围，对于那些不了解的人来说。实际上，我们之所以把所有这些 [听不清 00:25:23] 都放进去，是因为印第安纳大学很好心，让我们在一群学生身上测试了我们书的草稿。但我们甚至不需要通过 IRB 审查。我想……</p><p><strong>David:</strong>
So Dan says eight along, that’s that process of putting all of the maximum number of lambdas around the functions for those not in the know. And actually the reason why we put in all of these [inaudible 00:25:23] was that at Indiana University, they were kind enough to let us test out a draft of our book on a class of students. But we didn’t even have to go through an IRB for that. I think-</p>
<p><strong>丹：</strong>
但是还有 [听不清 00:25:37] 要做额外的事情。</p><p><strong>Dan:</strong>
But there [inaudible 00:25:37] to do additional.</p>
<p><strong>David：</strong> 
……当然。但在那个学期，我们发现了一些事情，比如其中之一就是，给学生一个他们的程序应该通过的测试套件，对学生来说更友好。而让这些测试更容易运行的一个方法是，如果你有很多规则，这些规则会告诉你，特别是函数规则，它规定你必须把所有的lambda放在外面才能找到范式。单元规则，它规定它们都是一样的，空类型的规则，它规定它们也都是一样的，因为你无论如何都找不到一个。这样做让我们实际上能够编写出更简单的测试套件，让他们的程序通过测试，因为计算机花了更多时间使它们彼此相同，而人类花了更少的时间，这总是一件好事。</p><p><strong>David:</strong>
… sure. But during that semester, we discovered certain things like one of them is that it’s much friendlier to students to give them a test suite that their program should pass. And one way to make it much easier to run these tests is if you have a lot of those rules that tell you, like in particular, the rule for the function, which says you have to put all the lambdas on the outside to find the normal form. The rule for a unit, which says they’re all the same and the rule for the empty type, which says they’re all the same too, because you’re never going to get one anyway. Doing that allowed us to actually write much simpler test suites that we could give them to have their programs pass because the computer does more work making things be the same as each other, and the human does less work, which is always a good thing.</p>
<p><strong>Adam：</strong>
我想回到原点。所以在我……之前，我在写这本书的时候，遇到了瓶颈。然后我就去 GitHub 搜索了 Pie 类型的文件。然后我找到了一个可能上过你提到的这门课程的人，以及他们的练习。看到这些真的帮了我大忙，所以感谢 Jacob Adley 写下这些，他的练习帮助我理解了……</p><p><strong>Adam:</strong>
I want to get back to the sameness. So at some point in my… Before we do that, while I was working through this book, I got stuck at some point. And then so I went into GitHub and I searched for files with the Pie type as the extension. And then I found somebody, I guess, who probably took this course, you’re talking about and their exercises. And actually it helped me out a lot to to see this so thank you to who wrote this down here, Jacob Adley whose exercises helped me understand the like-</p>
<p><strong>丹：</strong>
雅各布是谁？</p><p><strong>Dan:</strong>
Jacob who?</p>
<p><strong>亚当：</strong> 
……阿德利。</p><p><strong>Adam:</strong>
… Adley.</p>
<p><strong>丹：</strong>
我不认识这个人。不过还是谢谢你。</p><p><strong>Dan:</strong>
I don’t know this person. But thank you.</p>
<p><strong>大卫：</strong>
雅各布，如果你确实上过我们的课而我们却忘记了你，我感到非常抱歉。</p><p><strong>David:</strong>
Jacob, if you did take our class and we’ve forgotten you, I’m very sorry.</p>
<p><strong>亚当：</strong>
关于规范化点，我先确认一下我理解，举一个简单的例子，加二等于二加四，你说四是规范形式，但四也是这个语句的求值。所以这里面有某种……某种性质以一种我不熟悉的方式与求值联系在一起，我想，因为……</p><p><strong>Adam:</strong>
So on the normalization points to make sure I understand, in a simple example, where you could have plus two, two and four, and you’re saying four is the normal form, but the four is also an evaluation of this statement. So there’s some sort of… Somehow a quality has been linked to evaluation in a way I’m not familiar with, I guess, because…</p>
<p><strong>David：</strong>
所以我认为，当你编写逻辑并希望能够讨论程序时，你有两种方法可以做到。其中一种方法是，你可以把程序计算的所有方式都写下来，然后告诉编写证明的人，你现在可以演示这些程序是如何给出正确答案的，你可以坐下来说：“好吧，现在我要使用这条规则。然后我要在这里做一个β归约。我要在这里按照加法的定义重写。我要展开乘法的定义，看看它实际上是一个循环，在这里做了一堆加法运算。然后我要在这里进行归约。” 或者，你可以设计你的逻辑，让一切都自动遵循计算，然后让计算机完成所有这些工作。</p><p><strong>David:</strong>
So I think that when you’re making a logic and you want to be able to talk about programs, you have sort of two ways you can do it. One of them is you can write up all the ways that programs compute and then say to the person writing the proof, you get to now demonstrate how these programs give you the right answer by sitting down and saying, “Well, now I’m going to use this rule. Then I’m going to do a beta reduction here. I’m going to rewrite by the definition of plus right here. I’m going to unfold the definition of times to see that it’s actually a loop that does a bunch of pluses over here. And then I’m going to reduce here.” Or you can rig up your logic so that everything automatically respects computation and then have the computer do all of that work.</p>
<p>类型理论的奇妙之处之一，也是我们能够[听不清 00:28:38] 为之奋斗的，就是能够提出这种判断结构，或者说能够提出一种整合逻辑的方法，让计算在后台自然发生，无需人工逐一执行所有步骤。正因如此，类型理论中的“同一性”概念或许至关重要。当人们第一次……我记得当我第一次学习它的时候，至少我的想法是，好吧，让我们想想……我认为重要的是我们有哪些类型，以及哪些程序拥有这些类型。</p><p>And one of the wonderful things about type theory that we can think [inaudible 00:28:38] to live for is coming up with this judgemental structure or coming up with this way of putting the logic together, where the computation is something that can just happen in the background without a human having to go apply all the steps one at a time. And that’s why the notion of sameness in the type theory is probably the most important thing. When people are first… I know when I first learned it, at least I had this idea like, well, let’s see… I thought the important thing was what types do we have and what programs have those types.</p>
<p>但事实上，更重要的是思考哪些程序与其他程序相同，以及为什么会这样。另一部分则与此无关。这是因为它让你知道计算何时发生。它让你知道计算机何时会完成工作，何时不会完成工作，所以你必须自己完成工作等等。</p><p>But in fact, it’s much more important to think about which programs are the same as which other programs and why that is the case. And the other part just kind of falls out from that. And that’s because it allows you to know when computation is going to happen. And it allows you to know when the computer is going to do the work and when the computer is not going to do the work so you have to do the work yourself and that sort of thing.</p>
<p><strong>亚当：</strong>
是的，我觉得我还没完全理解。这挺有意思的。还有相似之处，就像我之前用二加二的例子描述的那样，但实际上，这种相似性适用于整个函数。</p><p><strong>Adam:</strong>
Yeah, I don’t think I’ve fully wrapped my head around it. It’s interesting. Also the sameness, like I described this example with two plus two, but actually the sameness applies to whole functions.</p>
<p><strong>丹：</strong>
是的，一切，嗯哼（肯定）。</p><p><strong>Dan:</strong>
Yeah, everything, mm-hmm (affirmative).</p>
<p><strong>David：</strong>
可以这样想：假设你正在编写一个类型检查器，它至少要回答两个问题。其中一个问题是，如何找到这个表达式的类型？但它也必须能够回答这个问题：两种类型在什么时候是同一类型，对吗？因为我可能期望一种类型，但得到的却是另一种类型，那么如何比较这两种类型呢？对于像简单输入 [听不清 00:30:21] 微积分这样的程序，比较它们的方法就是对它们进行递归，检查结构是否相同。但是，当你的类型包含程序时，检查类型的相同性也意味着检查程序的相同性。</p><p><strong>David:</strong>
So one way to think about it is that when you’re… Let’s say you’re writing a type checker, the type checker has got to sort of answer two questions at least. And one of those questions is how do I find the type for this expression? But it also has to be able to answer the question, when are two types the same type, right? Because I may expect one type and I get that the expression has some other type, how do I compare those two types? And for something like simply typing [inaudible 00:30:21] calculus, the way you compare them is just recur over them and check that the structure is identical. But when your types get to contain programs, then checking for sameness of types means checking for sameness of programs as well.</p>
<p><strong>亚当：</strong>
啊，我明白了。是啊。所以你必须这么做，必须这么做。</p><p><strong>Adam:</strong>
Ah, I see now. Yeah. So you have to, that has to be.</p>
<p><strong>David：</strong>
假设我写了一个函数，它需要……我需要将四块蛋糕作为参数传递给它。假设我有一个表示蛋糕块的类型。所以我会传递巧克力块、彩虹块、双倍巧克力块和四倍巧克力块给它。</p><p><strong>David:</strong>
Say I write a function and it needs to… As its argument, I need to pass it four pieces of cake. Let’s say I’ve got a type that represents pieces of cake. So I pass it like chocolate and I pass it rainbow and I pass it double chocolate and I pass it quadruple chocolate.</p>
<p><strong>亚当：</strong>
我喜欢你对食物的一致性，保留了所有关于食物的例子。</p><p><strong>Adam:</strong>
I like your consistency of food, keeping all the examples on food.</p>
<p><strong>大卫：</strong>
但实际上我最终还是放弃了……我想这就是我想要做的，但我的蛋糕来自两个不同的地方。所以我的两块蛋糕有两个来源，一个是巧克力蛋糕和彩虹蛋糕，另一个是双倍巧克力蛋糕和四倍巧克力蛋糕。</p><p><strong>David:</strong>
But then I actually what I ended up passing… So I think that’s what I want to do, but my cakes are coming from two different places. So I’ve got one source of two pieces of cake, which is my chocolate and my rainbow, and I’ve got another source of two pieces of cake, which is my double chocolate and quadruple chocolate.</p>
<p>所以我要调用一个函数来将这些列表附加到一起，这样我得到的结果是包含二加二的结果。但是我的函数需要四块蛋糕。当我们看着它时，我们会想，当然它们是同一类型，因为二加二等于四，但是类型检查器需要以能够理解的方式构建，这意味着逻辑或类型系统本身需要以这样的方式构建：二加二和四是同一事物。有些系统需要我坐下来手动证明二加二和四是相同的，然后才能将把这些列表放在一起的结果传递给我的函数。但在这个系统中我们不需要这样做，因为二加二和四彼此相同，用户无需做任何工作。</p><p>And so I’m going to call a function that will append to these, which gives me something that has two plus two pieces of cake in it. But my function needs four pieces of cake. And when we look at that, we think, well, of course those are the same type because two plus two is the same as four, but the the type checker needs to be built in a way that it can understand that, which means that the logic or the type system itself needs to be built in such a way that two plus two and four are the same thing. And there’s some systems out there where I’d have to sit down and sort of manually prove that two plus two and four are the same before I could pass that result of putting those lists together into my function. But in this system we don’t have to, because two plus two and four are just the same as each other, without any work needing to be done by the user.</p>
<p><strong>亚当：</strong>
在 Pie 中，有一种叫做证据的东西，这有关系吗？</p><p><strong>Adam:</strong>
And in Pie you have something called evidence, is this related?</p>
<p><strong>大卫：</strong>
所以证据是——</p><p><strong>David:</strong>
So evidence is-</p>
<p><strong>丹：</strong>
证据是一个程序。</p><p><strong>Dan:</strong>
Evidence is a program.</p>
<p><strong>大卫：</strong> 
……是的。证据就是某件事为真的原因。我们是从直觉逻辑研究者的角度来写这本书的。如果我们采用这种逻辑，那么并非一切都是真或假。有些事情我们还不知道是真是假。有一些悬而未决的问题，我们只是……它们既不是真的，也不是假的，直到有人通过提供证据证明它们是真的或假的，才能确定它们是真的或假的。希望不要同时提供它们为真和假的证据，因为那样的话，有人就犯了一个真正的大错误。</p><p><strong>David:</strong>
… yeah. Evidence is the reason why a thing is true. We wrote the book from the perspective of someone doing intuitionistic logic. And if we’re doing that style of logic, then it’s not the case that everything is true or false. There are some things that we don’t yet know whether are true or false. There are open problems about which we just… They’re not true and they’re not false until somebody proves that they’re true or false by providing evidence that they are true or evidence that they are false. And hopefully not both evidence that they are true and evidence that they’re false because then somebody’s made a real big mistake.</p>
<p><strong>丹：</strong>
是的，我想说。</p><p><strong>Dan:</strong>
Yes, I’d say.</p>
<p><strong>亚当：</strong>
所以我想，这是我的错，因为我可能误解了证据，所以我跳过了前面的内容。</p><p><strong>Adam:</strong>
So I guess see, this is my fault for skipping ahead because I might’ve misunderstood the evidence.</p>
<p><strong>丹：</strong>
特别是第八章，你必须仔细阅读。</p><p><strong>Dan:</strong>
Especially in chapter eight, you got to read that one really carefully.</p>
<p><strong>大卫：</strong>
所以，当我们在类型理论中定义均匀的含义时，我们通过说什么算作均匀的证据来做到这一点。</p><p><strong>David:</strong>
So, when we define what it means to be even in type theory, we do that by saying what counts as evidence of evenness.</p>
<p><strong>亚当：</strong>
好的。</p><p><strong>Adam:</strong>
Okay.</p>
<p><strong>大卫：</strong>
所以，要说明什么算作偶数的证据，一种说法是，如果我们能把一个数直接切成两半而没有任何剩余，那么它就是偶数。换句话说——</p><p><strong>David:</strong>
And so one way to say what counts as evidence of evenness is to say, well, a number is even if we can cut it directly in half without anything leftover. In other words-</p>
<p><strong>丹：</strong>
没有面包屑。</p><p><strong>Dan:</strong>
No crumbs.</p>
<p><strong>大卫：</strong> 
……是的。假设我们想提供四是偶数的证据，那么这个证据就是数字二，因为二翻倍得到四。如果我们想要108是偶数的证据，那么这个证据就是数字54，还有一些证据表明54翻倍得到108，这正是我们想要的。而我们没有一是偶数的证据，因为没有任何数字翻倍得到一。所以，定义一个新概念或新谓词的方式……谓词是一个带有漏洞的陈述，你可以用一个对象来填充它，从而得到一个完整的陈述。我们定义谓词的方式是，通过精确地陈述什么算作该陈述的证据来实现。</p><p><strong>David:</strong>
… yeah. Let’s say we want to provide evidence that four is even, well, that evidence is the number two because doubling two gets us four. And if we want evidence that 108 is even, that evidence is the number 54, along with some evidence that doubling 54 it gets us 108, which is what we wanted. And we don’t have evidence that one is even because there isn’t any number that doubling it gives you one. So the way you define a new concept or a new predicate… Predicate is a statement with a hole in it that you fill out with an object to get a complete statement. The way we define that is we do it precisely by stating what counts as evidence for that statement.</p>
<h2 id="on-writing-proofs"><strong>关于写证明</strong></h2><h2><strong>On Writing Proofs</strong></h2>
<p><strong>亚当：</strong>
如果我是……也许我应该把这本书读完。</p><p><strong>Adam:</strong>
If I were… Maybe I should just finish reading the book.</p>
<p><strong>丹：</strong>
你可以给我们回电话。</p><p><strong>Dan:</strong>
You can call us back.</p>
<p><strong>亚当：</strong>
我非常喜欢这本书，它拓展了我的思维。我觉得它很有挑战性。这就是我的总结。</p><p><strong>Adam:</strong>
I’m really enjoying the book, it’s stretching my mind. I’m finding it a challenge. That’s my summary of it.</p>
<p><strong>丹：</strong>
这绝对是一个挑战。</p><p><strong>Dan:</strong>
It’s definitely a challenge.</p>
<p><strong>大卫：</strong>
我听得非常动听。</p><p><strong>David:</strong>
Music to my ears.</p>
<p><strong>亚当：</strong>
那么，如果我想写出一些东西，证明二的平方根是有理数的，这可以在 Pie 中完成吗？</p><p><strong>Adam:</strong>
So, if I were to want to write out something, a proof that the square root of two is rational, is that something that can be done in Pie?</p>
<p><strong>大卫：</strong>
这得费点劲，不过我……所以我还没做过，所以不想答应。我想——</p><p><strong>David:</strong>
It would take a fair bit of effort, but I… So I don’t want to say yes cause I haven’t done it. I think-</p>
<p><strong>丹：</strong>
我也没有。</p><p><strong>Dan:</strong>
Nor have I.</p>
<p><strong>David：</strong> 
……我认为原则上你或许可以做到。但当你开始处理更复杂的事情时，我认为最好使用一个能为你完成更多工作的系统。所以我会使用……在这种情况下，我会停止使用 Pie，而是用 Coq 或 [听不清 00:35:42] 或 Idris 或类似的系统来编写。我们在书中试图帮助人们更多地理解依赖类型背后的哲学思想或潜在思想，而不是提供一个实用工具。虽然理论上，我认为你或许可以做到这一点。如果你做不到，我们可以稍微修改一下语言，让你能够做到。</p><p><strong>David:</strong>
… I think that in principle you could probably do it. But when you start getting to more complicated things then I think it would be better to use a system that does more of the work for you. So I would use… This is where I would stop using Pie and I would go write it in Coq or [inaudible 00:35:42] or Idris or one of these systems. We are trying in our book to help people get more sort of the philosophical ideas or the underlying ideas behind dependent types rather than to give you a practical tool. Although in theory, I think you can do this probably. And if you can’t, then we could change the language a little bit and make it so you could.</p>
<p><strong>Dan：</strong>
是的。我希望人们能够理解这个实现，然后说：“哦，我希望在语言里有流之类的东西。”或者其他我们没有的类型。然后他们会突然说：“哦，现在我明白了。我之所以要用类型，是因为我理解了系统其他部分的内部工作原理。”然后他们就能扩展他们对 Pie 的定义，并希望他们能与其他人分享。</p><p><strong>Dan:</strong>
Yeah. I’m hoping that people will pick up the implementation and say, “Oh, I’d like to have streams in language or something.” Or other other types that we don’t have. And all of a sudden they will say, “Oh, now I’ve got it. I got to types because I understand how the rest of the system works in terms of the internals.” And then they would be able to enlarge their definition of Pie and hopefully they would share that with others.</p>
<p><strong>大卫：</strong>
但是是的，这种事情可以用 Pie 之类的语言来完成。</p><p><strong>David:</strong>
But yes, that is the kind of thing that could be done in languages like Pie.</p>
<p><strong>亚当：</strong>
这里的意图……我的意思是，对吧？这么说来，我的理解是，它的目的是呈现一种非常精简的语言，以便人们能够理解其核心？</p><p><strong>Adam:</strong>
And the intent here… I mean, isn’t that right? So if I understand the intent is to present a very small language so the people can understand this core?</p>
<p><strong>大卫：</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>丹：</strong>
嗯哼（肯定）。当然。</p><p><strong>Dan:</strong>
Mm-hmm (affirmative). Absolutely.</p>
<p><strong>David：</strong> 
Pie 的核心与 Coq、[听不清 00:37:01] 或 Idris 等语言的核心非常相似。两者之间有一个非常重要的区别，那就是 Pie 内置了一组固定的数据类型，这些数据类型是出厂时就安装好的。如果需要更多数据类型，则必须自行扩展。而其他语言则允许扩展数据类型。我们没有添加这个功能，或者说我们曾经添加过，但我又把它删除了，因为我们希望实现简洁易懂。除此之外，它们基本上是同一种系统。</p><p><strong>David:</strong>
And the core of Pie looks very much like the core of something like Coq, [inaudible 00:37:01] or Idris. The sort of one really important difference, which is that Pie comes with a fixed collection of data types sort of installed in the factory. And if you want more, you have to open it up and add your own. Whereas those other languages allow you to extend the collection of data types. And we didn’t add that feature or we did add it actually at one point and I ripped it out again because we wanted the implementation to be small and understandable. But other than that, it’s basically the same kind of system.</p>
<p><strong>亚当：</strong>
我想知道其中一个词的定义，比如 [听不清 00:37:37]，我不知道你如何发音这些词。</p><p><strong>Adam:</strong>
I wanted to find out what the definition of one of these like [inaudible 00:37:37], I don’t know how you pronounce these things.</p>
<p><strong>丹：</strong>
那就足够了。</p><p><strong>Dan:</strong>
That’s good enough.</p>
<p><strong>亚当：</strong>
我本来想找个前奏，但是没有——</p><p><strong>Adam:</strong>
And I was looking for like a prelude, but there’s no-</p>
<p><strong>David：</strong>
它是语言内置的。有点像 Haskell，如果你想查找 if，但 if 并没有在任何地方定义。</p><p><strong>David:</strong>
It’s built into the language. Kind of like in Haskell, if you want to go find if, if isn’t really defined anywhere.</p>
<p><strong>亚当：</strong> 
……是的。</p><p><strong>Adam:</strong>
… yeah.</p>
<p><strong>Dan：</strong>
但这并非100%准确。在附录B中，你可以阅读推理规则，它描述了具体的实现。这样你就可以获得更多参考资料，了解正在发生的事情。</p><p><strong>Dan:</strong>
But that’s not 100% accurate. In appendix B you can read the inference rules, which describe the implementation. So that gives you a little bit more material to stare at, give you a sense of what is going on.</p>
<p><strong>大卫：</strong>
但 [听不清 00:38:16] 并不是那种你可以坐下来定义自己版本的东西。你可以定义一个像 [听不清 00:38:23] 一样工作的函数，只不过它会稍微有点噪音，因为它需要更多参数。</p><p><strong>David:</strong>
But it’s not the case the [inaudible 00:38:16] is the kind of thing that you could sit down and define your own version of. You can define a function that works just like [inaudible 00:38:23], except it’ll be a little bit noisier because it will need more arguments.</p>
<p><strong>丹：</strong>
确实如此。</p><p><strong>Dan:</strong>
That’s true.</p>
<p><strong>David：</strong>
我们在 Pie 中真正努力做到的一件事就是让它编写的程序简短，尽管它的实现非常简单，而且很多像 Pie 这样的小核心类型理论最终在编写程序时会变得非常冗长，但是当你必须将它们放在比平常小的纸张的一半大小时，冗长的程序编写方式是行不通的。</p><p><strong>David:</strong>
And one thing we really tried to work hard to do with Pie was make it so that programs in it were short, even though the implementation was very simple and lots of these little core type theories like Pie end up being very verbose to write programs in, but being verbose to write programs in isn’t going to work when you have to fit them in half of a piece of smaller than usual paper.</p>
<p><strong>亚当：</strong>
这是好事还是坏事？限制因素是……</p><p><strong>Adam:</strong>
Is that a good thing or a bad thing, are the constraints-</p>
<p><strong>David：</strong>
我认为这些约束在这里很有用。它促成了一种内置功能的语言，其实现使用了一种名为双向类型检查的技术。我认为对这种技术以及这些实现的工作原理感兴趣的人可以阅读我制作的教程。它利用了这一点，避免了用户需要写下太多内容，同时又不需要任何统一性，而统一性正是依赖类型的实现变得复杂的原因之一。</p><p><strong>David:</strong>
I think that the constraints were useful here. What it led to was a language which had some built-in things where the implementation uses a technique called bi-directional type checking, which I think people interested in and how these implementations work can go read my tutorial that I’ve made. And it uses that to avoid having the user have to write quite as much stuff down while at the same time not needing any unification, which is one of the spots where implementations of dependent types can get complicated.</p>
<p><strong>Adam：</strong> 
……所以我认为现在我们理解了这门语言的语境。我不会用它写一个 Web 服务器。这只是一个用来教我们了解类型系统及其工作原理的工具。</p><p><strong>Adam:</strong>
… so I think now we understand the context of the language. I’m not going to write a web server in this. This is a tool to teach us about this type system and how it works.</p>
<p><strong>大卫：</strong>
并教你如何思考这些类型的系统，希望这能让你学完后更容易学习工业强度的系统。</p><p><strong>David:</strong>
And to teach you about the way to think about these sorts of types systems, which will hopefully make it easier to learn the industrial strength ones when you’re done.</p>
<p><strong>丹：</strong>
是的。任何能够完全体现我们目标的东西。我们希望学生们能够真正地学习并理解它，然后他们才能继续学习工业设计。</p><p><strong>Dan:</strong>
Yeah. Anything that characterizes our goal completely. We want students to really work through it and understand it, and then they can move on to the industrial ones.</p>
<p><strong>亚当：</strong>
在采访菲利普·怀尔德之后，我想知道，如果类型和值是同一件事，那么对于依赖类型，我们是否似乎重新引入了不可判定性？</p><p><strong>Adam:</strong>
After my interview with the Phillip Wilder, I was wondering about with dependent types it seems like have we reintroduced undecidability, if types and values are the same thing?</p>
<p><strong>大卫：</strong>
那么当您说不可判定性时，您是指类型检查的不可判定性吗？</p><p><strong>David:</strong>
So when you say undecidability, do you mean undecidability of type checking?</p>
<p><strong>亚当：</strong>
我的问题可能不连贯，这完全有可能。</p><p><strong>Adam:</strong>
My question may not be coherent, which is perfectly possible.</p>
<p><strong>大卫：</strong>
没关系。我们一起解决吧。</p><p><strong>David:</strong>
That’s okay. Let’s work it out.</p>
<p><strong>亚当：</strong>
菲尔给我讲了这个故事，讲的是存在悖论，而消除这些悖论的一种方法就是消除自我反思。</p><p><strong>Adam:</strong>
Phil was telling me this story about there was paradoxes and one way to remove these paradoxes was to remove self reflexitivity.</p>
<p><strong>丹：</strong>
我们一直保持一致。所以这不会发生[交谈 00:40:58]。</p><p><strong>Dan:</strong>
We are consistent. So that doesn’t come [crosstalk 00:40:58].</p>
<p><strong>大卫：</strong>
嗯，丹，我应该说我们没有证据证明我们的语言完全没有悖论——</p><p><strong>David:</strong>
Well, Dan, I should say we do not have a proof that our language is completely without paradox-</p>
<p><strong>丹：</strong>
确实如此。不过——</p><p><strong>Dan:</strong>
That is true. Although-</p>
<p><strong>David：</strong> 
……所有为了避免这种情况而采取的标准措施，我非常确定。我赌了一大笔钱，至少这个想法如果是模块化的，可能还会留下一个bug。</p><p><strong>David:</strong>
… all the standard things that one does to avoid it, and I’m pretty sure. I bet a decent amount of money that at least the idea is if modular, maybe there’s a bug left.</p>
<p><strong>丹：</strong> 
……哦，那可能是，那肯定是错误，但那是一个模块化的。</p><p><strong>Dan:</strong>
… oh, that could be, it definitely be bugs, but a modular that.</p>
<p><strong>大卫：</strong>
对。所以类型论的起源可以追溯到这个悖论：存在一个集合，它包含所有不包含自身的集合。而且——</p><p><strong>David:</strong>
Right. So the origin of type theory goes back to this paradox of having a set that contains all sets that do not contain themselves. And-</p>
<p><strong>丹：</strong>
也称为悖论的[听不清 00:41:35]。</p><p><strong>Dan:</strong>
Also know as the [inaudible 00:41:35] of paradox.</p>
<p><strong>大卫：</strong>
是的。</p><p><strong>David:</strong>
Yes.</p>
<p><strong>丹：</strong>
作者：[伯特兰·罗素 00:41:38]。</p><p><strong>Dan:</strong>
By [Bertrand Russell 00:41:38].</p>
<p><strong>大卫：</strong>
是的，罗素悖论。罗素类型理论解决这个问题的方法是：每个集合都不能随意引用任何事物，它只能引用比它小的事物。因此，零型集合只能引用普通事物，而不能引用其他集合。一型集合可以引用零型集合和普通事物，或者引用[听不清 00:42:07]。二型集合可以包含一型集合、零型集合等等。这样一来，这个悖论就消失了，因为问这个集合是否包含自身这个问题甚至毫无意义。</p><p><strong>David:</strong>
Yeah, Russell’s paradox. And so the way that Russell’s type theory gets around this is by saying that every set doesn’t get to refer to things willy nilly, it gets to refer to sort of things that are smaller than it. So in a set of sort of type zero only gets to refer to ordinary things and not to other sets. A set of type one gets to refer to sets of type zero and ordinary things or refer to [inaudible 00:42:07]. A set of type two, gets to contain sets of type one, sets of type zero and so forth. And then this paradox goes away because it doesn’t even make sense to ask the question of whether the set contains itself.</p>
<p><strong>亚当：</strong>
那么，我想我的问题是，如果我们说在这个世界上类型不能指代自己吗？</p><p><strong>Adam:</strong>
So then, I guess my question is, if we’re saying like can’t types refer to themselves in this world or?</p>
<p><strong>大卫：</strong>
实际上，不，这是个非常好的问题。所以，在[听不清 00:42:36] 提出的依赖类型理论的第一个版本中，确实存在一个类型，它可以对所有类型进行分类，或者描述所有类型，包括它自己。然后[听不清 00:42:47] 出现了，他基于一个早期的系统（该系统具有类似的特征）证明了这一点，并证明了它与自身不一致。</p><p><strong>David:</strong>
No, actually, and that’s a very good question. So in the very first version of dependent type theory that [inaudible 00:42:36] cooked up, you actually did have a type which classified all the types or described all of the types including itself. And [inaudible 00:42:47] came along and showed that based on an earlier system he made, which had a feature like that, that he showed to be inconsistent.</p>
<p>他证明了 [Martin Lives 00:42:58] 早期的系统也正是由于这个原因而不一致。所以我们在 Pie 中所做的就是，我们有一个类型可以描述大多数其他类型，但不能描述自身，也不能描述包含自身的类型。所以我们有这个类型 U，它是全集，而自然数类型 Nat 是全集的一部分。Adam，Adams 的类型在全集内，Nat 的列表在全集内，但 U 本身不在。</p><p>He showed that [Martin Lives 00:42:58] earlier system was also inconsistent for exactly that very reason. So what we do in Pie is we have a type that describes most other types, but not itself, and also not types that contain itself. So we have this type U, which is the universe and Nat the type of natural numbers is part of the universe. Adam, the type of Adams is in the universe, list of Nat is in the universe, but U itself is not.</p>
<p>而且也不是 U 列表，也不是以 U 为参数或返回 U 的函数之类的。哦，我们只有这一种宇宙类型，因为这就是我们在 Little Typer 中教授课程所需要的全部内容。我之前提到的工业强度系统，它们都有无限多种宇宙类型，每种类型都讨论比它小的宇宙。所以，你有宇宙零，它讨论像 Nat 这样的东西，宇宙一，它讨论像宇宙零和 Nat 这样的东西，等等。我们在 Pie 的早期版本中就有这些。然后，我们用学生的所有家庭作业和书中的所有代码做了一个小测试，我们发现没有人真正使用过多于一个宇宙的东西。所以我们干脆把剩下的删掉了。</p><p>And neither is list of U or functions that take U as an argument, or return U and these sorts of things. Oh, and we just have this one universe type because that’s all we need in order to teach the lessons in the Little Typer. The industrial strength systems that I was talking about earlier, they all have infinitely many universe types where each of them talks about the ones that are smaller than itself. So you have universe zero, which talks about things like Nat, universe one, which talks about things like universe zero and Nat, and so on and so forth. And we had that an early version of Pie. And then we ran a little test with all of the homework assignments from our students and with all of the code in the book, and we found out that nobody ever actually used anything more than one universe. So we just rip the rest out.</p>
<p><strong>丹：</strong>
还有一种民间传说定理，那就是你永远不需要超过五级的宇宙。</p><p><strong>Dan:</strong>
There’s also a sort of a folklore theorem that you never need more than five levels of universes.</p>
<p><strong>大卫：</strong>
是的。哦，有人说他们已经检查了几乎所有的证明[听不清 00:44:30]，这是类型理论的另一种实现，它非常独特，与其他许多证明截​​然不同。他们[听不清 00:44:36]曾经使用过五个或七个宇宙之类的东西。所以，也许无限多也太多了，我不确定。它本身就很简单。</p><p><strong>David:</strong>
Yeah. Oh, someone was saying that they’d gone and checked sort of every proof [inaudible 00:44:30], which is another implementation of type theory, which is sort of very unique and very different than many of the other ones. They [inaudible 00:44:36] ever use like five or seven universes or something like that. So maybe infinitely many is too many, I’m not sure. It has a nice simplicity to it.</p>
<h2 id="on-recursion"><strong>关于递归</strong></h2><h2><strong>On Recursion</strong></h2>
<p><strong>亚当：</strong>
我想，我发现 Pie 语言中比较有挑战性的一点就是递归比我习惯的要复杂一些，是吗……</p><p><strong>Adam:</strong>
One thing that I found challenging, I guess, in this Pie language is just recursion is a bit more involved than I’m used to, is that…</p>
<p><strong>丹：</strong>
你不能使用递归。[听不清 00:45:04]。</p><p><strong>Dan:</strong>
You’re not allowed to use recursion. [inaudible 00:45:04].</p>
<p><strong>大卫：</strong>
嘿，丹，为什么不允许你使用递归？</p><p><strong>David:</strong>
Hey Dan, why aren’t you allowed to use recursion?</p>
<p><strong>丹：</strong>
因为你不允许使用递归。</p><p><strong>Dan:</strong>
Because you’re not allowed to use recursion.</p>
<p><strong>大卫：</strong>
是啊。但为什么不呢？</p><p><strong>David:</strong>
Yeah. But why not?</p>
<p><strong>丹：</strong>
因为你不被允许这样做。</p><p><strong>Dan:</strong>
Because you’re not allowed to.</p>
<p><strong>大卫：</strong>
所以，如果你想让你的程序与证明相对应，那么直接使用实际递归（其中某物引用自身）就对应于循环推理。</p><p><strong>David:</strong>
So, if you want your programs to correspond to proofs, then direct uses of actual recursion where something refers to itself corresponds to circular reasoning.</p>
<p><strong>丹：</strong>
这还不够好。嗯，顺便说一句，这对我来说最令人震惊的是，居然还有绕过递归的方法。绝对没有任何“如果……而且……”之类的借口。</p><p><strong>Dan:</strong>
And that’s not good enough. Well, that’s the biggest shock for me, incidentally, that there has to be a way around recursion. Absolutely all the time there’s no, if ands or buts about it.</p>
<p><strong>亚当：</strong>
所以它最终看起来像递归，但你必须这样做，你只是在计算一个自然数。</p><p><strong>Adam:</strong>
So it ends up looking like recursion, but you just have to, you’re just working down a natural number.</p>
<p><strong>Dan：</strong>
是的。工业级递归库的特点之一是它们允许递归，但通常只允许使用模式语言的特殊递归。但我们选择不这样做，因为我们真的希望人们认真思考那些被移除的东西……我们移除了递归，所以你必须深入研究细节。</p><p><strong>Dan:</strong>
Yeah. One of the things about the industrial strength ones is that they allow recursion, but only special kinds of recursion usually using a pattern language. But we opted out of that because we really wanted people to think hard about things that took away… We have taken away recursion so that you really have to get into the nitty gritty details.</p>
<p><strong>David：</strong>
我认为，为了让这次讨论更加合理，我们应该澄清一些事情。当我们掌握了编程语言 [Piedmont 00:46:22] 的概念后，递归这个术语就具有非常具体的含义，它意味着你定义或编写的内容能够直接引用自身。因此，为了在 Coq、[inaudible 00:46:43] 或 Idriss 之类的语言中做到这一点，语言的实现中会进行检查。它确保每次递归调用函数时，每次函数调用自身时，都是基于较小的输入。然后，它确保所有输入的大小都是有限的。因此，如果你走下有限数量的台阶，你最终会到达底部，然后就没问题了，因为在底部你会发现一些不能自我证明或不能引用自身的东西。</p><p><strong>David:</strong>
And I think that in order for this discussion to make perfect sense, there’s something that we should probably clarify. So when we’ve got our programming language [Piedmont 00:46:22] hat on, then the term recursion has a very specific meaning, which is that it means that something that you’re defining or something that you’re writing is able to refer to itself directly. And so in order to do that in something like Coq or [inaudible 00:46:43] or Idriss, then there’s a check that happens in the implementation of the language. And it makes sure that every time you’re calling a function recursively, every time it’s invoking itself, it’s doing so on a smaller input. And then it makes sure that all the inputs are finite in size. And thus, if you were going down a finite number of steps, you’ll eventually hit the bottom and then it’s okay, because at the bottom you’ll have something that isn’t self justifying or that isn’t a reference to itself.</p>
<p><strong>Dan：</strong> 
1974年的时候，我当时教递归的时候，就靠这个。我当时觉得递归真的很酷。现在我完全用不上它了。</p><p><strong>Dan:</strong>
Back in ‘74, that was the driving force I used for teaching recursion. I actually thought recursion was really cool. Now I can’t use it.</p>
<p><strong>David：</strong>
所以在这些语言中确实有递归，但它必须经过某些检查以确保递归可以执行。它总是安全的，因为自引用的问题，比如自引用论证，就像我刚才和 Dan 讨论的那个，只有当程序陷入无限循环，除了给你的房间供暖之外什么也不做时，才会出现问题。所以，循环论证对应于一个什么也不做的无限循环。</p><p><strong>David:</strong>
So in those languages you do have recursion, but it has to be recursion that lives up to certain checks to make sure that it’s okay to do. That it’s always going to be safe because the problem of self reference, like a self-referential argument, like the one I had with Dan just a moment ago is only a problem when the program falls into an infinite loop that sits there doing nothing except heating up your room. So a circular argument corresponds to an infinite loop that does nothing.</p>
<p>如果你排除那些什么都不做的无限循环，你也就排除了循环论证。在 Pie 中，为了做到这一点，我能说什么呢？为了使实现更简单，而且我认为更重要的是，为了使语言的定义与依赖类型的一些文献以及一些实现更紧密地对应，所以我们在 Pie 中使用的递归风格是 [Lean 00:48:31] 中使用的风格，我一直没有提到这一点，因为 Lean 也是一个很棒的系统，是微软研究院的另一种依赖类型语言。</p><p>And if you rule out those infinite loops that do nothing, you’re also ruling out the circular arguments. And in Pie in order to make this, what can I say? In order to make the implementation simpler and also, which I think is even more important, in order to make the definition of the language correspond more closely to some of the literature that you have on dependent types and also to some of the implementations, so the style of recursion that we have in Pie is the style used in [Lean 00:48:31], which I’ve been really remiss in not mentioning because Lean is also a great system, another dependently type language from Microsoft Research.</p>
<p>这种表述方式很棒，它内置了一些递归方法，每种有限数据类型至少有一种。这很棒，因为你可以用非常简单的规则来描述递归何时可接受。所以在允许递归的语言中，你总是会……因为无法判断一个任意程序是否会陷入无限循环，什么都不做，所以你只能得到保守的近似值。而这些保守的近似值，为了让你编写更有用的程序，会随着时间的推移变得越来越复杂，比如“哦，我们可以允许这个，我们可以允许这个，我们可以允许这个。”你必须非常小心地确保它完全正确，同时仍然有用。而带有消除器的版本，比如我们在Pie中使用的，以及他们在Lean中使用的，以及幕后使用的警句，这很棒，因为它……规则规定，什么时候可以接受具有递归行为的事物，这些规则非常非常简单。</p><p>And this way of formulating things is nice, where you have a few built-in ways of doing recursion, at least one for each finite data type. It’s wonderful because you’re able to have very simple rules that describe when the recursion is acceptable. So in languages that allow recursion, you’re always going to have… Because it’s impossible to tell whether an arbitrary program falls into an infinite loop spinning they’re doing nothing, you instead get conservative approximations. And those conservative approximations in order to allow you to write more useful programs, get more and more complicated over time like, “Oh, we can allow this, we can allow this, we can allow this.” And you have to be very careful to get it exactly right, and still be useful. Whereas the version with the eliminators, like we use in Pie and like they use Lean and like epigram used behind the scenes, that’s nice because it’s… The rule saying like, when is something that has a recursive behavior acceptable are very, very simple.</p>
<p><strong>Dan：</strong>
你还没有提到致命函数，但我认为它与这一点很相关。David，你能再详细说说吗？</p><p><strong>Dan:</strong>
You haven’t mentioned yet about fatality functions that I think is relevant in this point. Do you want to say a little bit more about that, David?</p>
<p><strong>David：</strong>
当然。是的。所以函数就是，我们有定义域和值域。如果定义域中的每个元素都与值域中的一个元素恰好配对，那么它就是一个函数；如果所有元素都与值域中的一个元素配对，那么它就是一个全函数。函数不会说“不”，它不会一直原地打转，你给它的每一个输入，它都会返回一个输出。</p><p><strong>David:</strong>
Sure. Yeah. So function it’s, we’ve got the domain and we’ve got the range. And it’s a function, if every element of the domain is paired up with exactly one element of the range and it’s a total function if all of them are, every single thing. The function doesn’t get to say, nope, it doesn’t get to sit there spinning its wheels, but every input you give it, it’ll always give you back an output.</p>
<p>因为我们处理的是程序，所以我们希望在有限的时间内得到输出。而有限的时间并不能提供强有力的保证。我的意思是，你可以用像Pie这样的语言轻松编写一个程序，让它一直到你老了才能给出答案，甚至可能要到你的曾曾曾孙辈都老了才能给出答案。</p><p>And because we’re dealing with programs, we want to get back that output in finite time. And finite time isn’t a very strong guarantee. I mean, you can easily in a language like Pie, you can write a program that will take until you’re old and gray to give back an answer, if not until your great, great, great grandchildren are old and gray.</p>
<p><strong>丹：</strong>
我的意思是，毕竟我们的书中确实有 [Ackerman 00:50:42]。</p><p><strong>Dan:</strong>
I mean, after all, we do have [Ackerman 00:50:42] in the book.</p>
<p><strong>大卫：</strong>
是的。你可以编写非常非常慢的程序，运行时间非常长，即使是用[听不清 00:50:49] 语言。但重要的是，程序和证明之间的这种对应关系是经过修改的真理。我们没有任何旧程序和任何旧证明之间的对应关系。我们有的是完全函数式程序和直觉主义证明之间的对应关系，其他逻辑也存在这种对应关系，但传统的 Curry Howard 对应关系是……直觉主义证明是那些不使用非建设性推理证明的证明。</p><p><strong>David:</strong>
Yeah. You can write very, very slow programs that take a very long time, even in a [inaudible 00:50:49] language. But the important thing is that this correspondence between programs and proofs is a truth with modification. We don’t have a correspondence between any old program and any old proof. What we have is a correspondence between total functional programs and intuitionistic proofs, and then other logics also have these correspondences, but the sort of the traditional Curry Howard correspondence is… Intuitionistic proofs are those that don’t make use of non-constructive reasoning proofs.</p>
<p>所以我们可以......我们不能利用排中律，这让我们......我们不能使用双重否定消元法，从非，非 A 到仅仅是 A 之类的东西，因为它们对应于在 [听不清 00:51:50] 微积分中不能直接表示的东西。</p><p>So we can have… We’re not able to make use of the principle of the excluded middle, which lets us… We’re not allowed to make use of double negation elimination, where you go from not, not A, to just A, things like that, because those correspond to things that aren’t sort of directly representable in [inaudible 00:51:50] calculus.</p>
<p>这是一个非常漫长而深刻的问题。你可以通过在语言中添加类似延续之类的东西来获得很多这样的原则，这真的很有趣，但就我们这里的目的而言，我们需要将函数的全量放在一边，因为如果……嗯，一个函数可能在几个方面不完全。一种情况是，对于某些输入，它可能只是说：“不，我不会在这里被定义。”在这种情况下，我们的证明就行不通了，因为函数是我们证明“所有”语句的方式，对吧？所以我们可以说，对于所有偶数，在这个数上加一会得到一个奇数。这将是一个函数，你给它一个数，你给它这个数是偶数的证据，它会给你返回一个大于这个数的数是奇数的证据。</p><p>And this is a really long, deep thing. And you can get a lot of those principles by adding things like continuations to your language, which is really fun, but for purposes of what we’re doing here we need to have the total functions on the one side because if… Well, a function may not be total in a couple of ways. One is that it might for certain inputs just say, “Nah, I’m not going to be defined here.” And in that case then our proof doesn’t work because functions are the way we prove for all statement, right? So we might say like for all even numbers, adding one to that number it gets you an odd number. That’ll be a function where you give it a number, you give it evidence the number is even, and it gives you back evidence that one greater than that number was odd.</p>
<p>如果因为某种原因，它对 24 不起作用，那我们就有问题了。所以它必须涵盖所有可能的输入。但如果对 24 的情况，它只是在那里不停地循环，说：“嘿，如果我要检查 25 是否为奇数，我得先检查 24 是否为偶数。” 那么这同样是一个不令人满意的证明。我会说它不是一个证明。</p><p>And if it just like didn’t work for 24, for some reason, then we’d have a problem. So it’s got to cover all the possible inputs. But also if the case for 24, just sort of sat there spinning its loop by saying, well, “Hey, if I’m going to check whether 25 is odd I’m going to do that by checking whether 24 is even again first.” Then that would also be an unsatisfactory proof. I’d say it wouldn’t be a proof.</p>
<p><strong>丹：</strong>
根本不是。</p><p><strong>Dan:</strong>
Simply wouldn’t be.</p>
<p><strong>大卫：</strong>
这不算证据。是的。所以，为了让我们所有的程序都能对应Pie中的证明，我们确保你只能编写全函数。这些消去形式，比如你之前提到的[听不清 00:53:14]，可以确保你覆盖了所有可能的Nat，并且你执行的任何递归都以这样的方式控制：递归调用都发生在一个较小的数字上。</p><p><strong>David:</strong>
It wouldn’t be evidence. Yeah. So in order for all of our programs to correspond to proofs in Pie, we make sure that you can only write total functions. And these elimination forms like the [inaudible 00:53:14] that you were talking about earlier, those allow you to make sure both that you’re covering all the possible Nats and that any recursion you do is controlled in such a way that recursive calls are all happening on one smaller number.</p>
<p><strong>丹：</strong>
如果我们允许递归。</p><p><strong>Dan:</strong>
If we allowed recursions.</p>
<p><strong>大卫：</strong>
是的。嗯，我的意思是，这种行为是递归的，对吧？</p><p><strong>David:</strong>
Yes. Well, I mean the behavior acts recursive, right?</p>
<p><strong>丹：</strong>
是的。</p><p><strong>Dan:</strong>
Yeah.</p>
<p><strong>Adam：</strong>
我觉得它像递归，因为，我不知道……我每天都用 Scala 编程，我不习惯写直接递归，也就是调用自己，我习惯用折叠之类的，参数也差不多。对吧？你最终会给它一个自然数，然后你需要给它一个返回下一个类型的函数，我想，我正在努力记住。</p><p><strong>Adam:</strong>
To me it feels like recursion because like, I don’t know… I’m programming in Scala day-to-day and I don’t tend to write like direct recursion where I’m calling myself, I tend to use like a fold or something and the arguments are similar. Right? You end up giving it a natural number and you need to give it a function that returns the next type, I think, I’m trying to remember.</p>
<p><strong>大卫：</strong>
那么，让我们看一下列表，因为我们正在讨论折叠，而大多数人更习惯于用列表而不是数字来思考折叠。</p><p><strong>David:</strong>
So for, in that, or let’s take in the list because we’re talking about folds and most people are more used to thinking about folds in terms of lists rather than in terms of numbers.</p>
<p><strong>亚当：</strong>
嗯哼（肯定）。</p><p><strong>Adam:</strong>
Mm-hmm (affirmative).</p>
<p><strong>大卫：</strong>
虽然底层的想法本质上是一样的。所以，当你在列表上折叠的时候——</p><p><strong>David:</strong>
Although the underlying idea is essentially the same idea. So, when you’re doing a fold on a list-</p>
<p><strong>丹：</strong>
那是 R 型折叠，还是 L 型折叠？</p><p><strong>Dan:</strong>
Is that a folder R, or a fold L?</p>
<p><strong>大卫：</strong> 
……我们来选择 R。</p><p><strong>David:</strong>
… let’s go for R here.</p>
<p><strong>丹：</strong>
好的。我也是这么想的。</p><p><strong>Dan:</strong>
Okay. That’s what I thought.</p>
<p><strong>大卫：</strong>
我会尽量把它们弄直，因为我总是把它们弄乱。但我通常的思维方式是，比如，我到底想用左折叠还是右折叠，我总是会先试一个，如果不行，就用另一个，或者我会做一些小测试来确定是哪一个，因为我的大脑不太会记住这些。但是，是的，当我们使用这个鲁莽操作符（也就是我们说的，非独立类型的折叠）时，我们会给它一个值，当列表为空时返回。</p><p><strong>David:</strong>
And I will try to keep them straight because I always mess them up. But my usual way of thinking, like, do I want to use fold L or fold R here is I’ll always sort of like I’ll try one, if it doesn’t work, I’ll do the other one, or I’ll do some sort of little test to make sure which one it is because my brain just isn’t wired to remember those. But yeah, when we’re doing using this reckless operator, which we have, which is the non independently typed fold, then we give it a value to return when the list is the empty list.</p>
<p>我们给它传入一个参数，它接受一个列表的头部、一个列表的尾部以及对列表剩余部分进行折叠的结果，并返回一个新的输出。然后，通过每一步执行这些操作，我们就可以一直执行到右边……最终，它会执行这个步骤、执行这个步骤、执行这个步骤，直到遇到空列表的起始条件。依赖类型版本会接受一个额外的参数，我们称之为动机（motive），或者我们不这么称呼它，它就是这么叫的。</p><p>We give it something that takes the head of a list and the tail of a list and the result of doing the fold over the rest of the list and gives us back a new output. And then by doing those at each step, we get down to the right… Finally it’ll do the step, do the step, do the step until it hits the base case for the empty list. The dependently typed version of that takes one additional argument, which is what we call the motive, or we don’t call it, that’s what it’s called.</p>
<p><strong>丹：</strong>
嗯，这个 [交谈 00:55:27] 你现在谈论的是感应，对吗？</p><p><strong>Dan:</strong>
Well, this [crosstalk 00:55:27] you’re talking about induction now, right?</p>
<p><strong>大卫：</strong>
是的。</p><p><strong>David:</strong>
Yes.</p>
<p><strong>丹：</strong>
好的。</p><p><strong>Dan:</strong>
Okay.</p>
<p><strong>David：</strong>
依赖类型折叠就是归纳推理。动机解释了你正在重复执行的列表的类型，这意味着每一步的类型可能会略有不同。例如，如果我们想要检查……如果我们想要写一个证明，将空列表翻转到任何旧列表都会返回相同的列表，那么动机就是 lambda-xs，翻转，空列表 Xs 等于 Xs。然后，当我们对起始条件执行此操作时，我们将动机应用于空列表，以确定起始条件的类型，也就是空列表，依赖空列表等于空列表。然后，对于下一步骤，我们将它应用于一种未知列表，找出其余递归结果的类型，然后将它应用于将额外元素粘贴到该结果上，以获得我们需要的结果的类型，最终我们得到结果。</p><p><strong>David:</strong>
And so dependently typed fold is induction. The motive explains what the type is for in terms of the list that you’re reoccurring over, which means that the type at each step could be a little bit different. So for instance if we wanted to check… If we wanted to write a proof that upending the empty list to any old list gives you back that same list, then the motive is going to be lambda-xs, upend, empty list Xs is equal to Xs. And then when we do that for the base case, we then apply the motive to the empty list to figure out what the type of the base case is, which is going to be the empty list, depend empty list is equal to empty list. And then for the step we’re going to apply it to one sort of unknown list to find out the type of the result of the rest of the recursion, and then apply it to sticking the extra element onto that, to get the type for the result that we need, and we get that back.</p>
<p>这样，通过在每一步中组合这些，你就能得到结果类型和你现在正在查看的列表之间的关系，并得到适当的维护。所以，这个递归运算符和典型的折叠 R 之间的真正区别在于，它需要更多的参数，或者需要另一个参数，也就是列表的尾部。通常情况下，你不会把这个参数包含在内。但把它放在这里会让事情变得更容易，你也可以从这个函数中得到另一个参数。</p><p>And so then by combining these at each step, you get the relationship between the resulting type and the list that you’re looking at right now is maintained appropriately. And so the real difference between this recursion operator and the typical fold R, is that it takes a couple more arguments or it takes another argument, which is sort of the tail of the list. You’re not usually having that one included as you go. But putting it here makes life easier and you can get the other one out of this one as well.</p>
<p><strong>亚当：</strong>
我真的很喜欢这本书。</p><p><strong>Adam:</strong>
So I really liked the book.</p>
<p><strong>大卫：</strong>
谢谢。</p><p><strong>David:</strong>
Thanks.</p>
<p><strong>亚当：</strong>
我会继续努力。我已经找到了……我会坚持下去的。我会努力尝试。</p><p><strong>Adam:</strong>
I’m going to keep working on it. I have found… I’m going to make it through it. I’m going to try.</p>
<p><strong>大卫：</strong>
我希望如此。</p><p><strong>David:</strong>
I hope so.</p>
<p><strong>丹：</strong>
你可以提一下它有多少页，这样人们就能明白你说的“我会读完它”是什么意思了。</p><p><strong>Dan:</strong>
You might mention how many pages it is so that people understand what you mean when you say I’m going to make it through it.</p>
<p><strong>亚当：</strong>
我有点夸张了。不过我确实买了《Little Schemer》和《Little Typer》，而且《Little Typer》好像比《Little Schemer》长一倍，不过附录好像也不少。</p><p><strong>Adam:</strong>
I’m exaggerating here. But I did get the Little Schemer and Little Typer, and I think the Little Typer is twice as long, but I think there’s a lot of appendix.</p>
<p><strong>大卫：</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>丹：</strong>
是的，数量相当多。</p><p><strong>Dan:</strong>
Yeah, there’s a fair amount.</p>
<p><strong>David：</strong>
是的，我们想把源代码（也就是 Pie）放在书的后面，这样人们就能更容易理解和操作这个实现。但就像你不会把 Scheme 编译器放在 Scheme 书的后面一样，它太大了。所以我们尝试了退而求其次的做法，即给出语言的数学描述，然后再配上一些解释如何解读数学公式的文字，因为这样最终会比代码简洁得多。</p><p><strong>David:</strong>
Yeah, we wanted to include the source code, the Pie in the back of the book so that people could have an easier time understanding and playing with the implementation. But just like you don’t put the scheme compiler in the back of the scheme book, it was too big. So we tried to do the next best thing, which was give a mathematical description of the language and then some text explaining how to read the math, because that ends up being a lot shorter than the code.</p>
<p><strong>丹：</strong>
对于那些想知道该语言到底包含什么内容的人来说，附录 B 可能非常有用。</p><p><strong>Dan:</strong>
And probably be for the people who want to know just exactly what’s in the language that appendix B is pretty useful.</p>
<p><strong>大卫：</strong>
如果你有正确的背景，否则我们会尽力解释，以便你能够弄清楚。</p><p><strong>David:</strong>
If you have the right background and otherwise we did our best explaining it so that you could figure it out.</p>
<p><strong>丹：</strong>
不过我们尽量在那部分提供背景信息。希望我们做得还算比较接近。</p><p><strong>Dan:</strong>
But we try to give you the background as well in that section. So hopefully we came pretty close.</p>
<p><strong>亚当：</strong>
是的。书的背面有一段很有意思的内容，上面写着你们尝试做一些不实用也不严谨的事情，但却很美。你们这是什么意思呢？</p><p><strong>Adam:</strong>
Yeah. And there’s something interesting on the back of the book here where it says that you were trying to do something not practical or rigorous, but beautiful. What did you guys mean by that?</p>
<p><strong>丹：</strong>
嗯，伊德里斯等还有其他系统，我们一直提到的那些，它们都很实用。</p><p><strong>Dan:</strong>
Well, there are these other systems Idriss, et cetera, the ones we keep mentioning and they are practical.</p>
<p><strong>戴维：</strong>
修改后的方案也是如此。它们适用于合适的人群和合适的情况。希望有一天，它们能惠及更多人群和更多情况。</p><p><strong>David:</strong>
That is also a truth with modifications. They are practical for the right kinds of people in the right kinds of situations. And hopefully someday they will be practical for more people in more situations.</p>
<p><strong>丹：</strong>
是的。</p><p><strong>Dan:</strong>
Yes.</p>
<p><strong>大卫：</strong>
我这么说只是因为我经常[听不清 00:59:00]在伊德里斯[听不清 00:59:01]上。如果有一群人跑来跟我说：“伟大的丹·弗里德曼说过，这很实用，但我很难用它编写一个全新的网页浏览器和操作系统。”</p><p><strong>David:</strong>
I’m just saying this because I [inaudible 00:59:00] on the Idriss [inaudible 00:59:01] a lot. And if a bunch of people show up and start saying, “The great Dan Friedman said, this was practical, but I’m having a difficult time writing a brand new web browser and writing an operating system in it.”</p>
<p><strong>丹：</strong>
嗯，当然有这个。</p><p><strong>Dan:</strong>
Well, there is that, of course.</p>
<p><strong>David：</strong>
我们在更多领域正在走向实用化，但它们仍然是研究软件。</p><p><strong>David:</strong>
We are moving toward practicality in more domains, but they are still research software.</p>
<p><strong>Dan：</strong>
对，这是肯定的。但我们没有尝试这么做。我们试图让你大致了解依赖类型带来的兴奋点。如果可以的话，我想讲一个小故事。我刚和 Carl Eastlund 合著了一本名为《Little Prover》的书，就把它寄给了我的朋友 Adam [Faulser 00:59:51]，他一收到就给我发了一封电子邮件，问我：“你的下一本书会讲什么呢？下一本小书？”我说：“嗯，我看到很多人对依赖类型很感兴趣。” 他说：“别动。” “你说‘别动’是什么意思？” 所以我心想：“如果我想喝杯水，我怎么也拿不到呢？” 于是他给我和 David 都写了一封信，介绍我们认识，那天下午我们就决定写这本书了。这是一个很棒的小故事。如果我们不提 Adam 的参与，我会感到很不舒服。</p><p><strong>Dan:</strong>
Right. That’s for sure. But we didn’t try that. We tried to make it so that you would understand pretty much what the excitement is about with respect to the dependent types. I like to tell a little story if I may, when I had just finished a book called Little Prover with Carl Eastlund, I sent it to my friend, Adam [Faulser 00:59:51], and I got an email from him as soon as he got it and he said, “So what’s your next book going to be about, next little book?” And I said, “Well, I’ve seen an awful lot of excitement about dependent types.” And he said, “Don’t move.” “What do you mean don’t move?” So I’m thinking to myself, “If I want a glass of water, I can’t get it or something?” So he sent me a letter and to David at the same time introducing us and that afternoon we decided to write the book. So that was a nice little story. And I would be uncomfortable if we did not mention Adam’s involvement,</p>
<p><strong>大卫：</strong>
他应该得到应有的赞誉。所以不应该受到指责，这取决于你如何[交谈 01:00:49]。</p><p><strong>David:</strong>
He deserves the credit that accrues. So not the blame, depending on how you [crosstalk 01:00:49].</p>
<p><strong>Dan：</strong> 
[相声01:00:48]都怪。</p><p><strong>Dan:</strong>
[crosstalk 01:00:48] the blame.</p>
<p><strong>大卫：</strong>
是的。我认识亚当是因为我当时在[Galois 01:00:54]实习，我现在就在那里工作。他当时也在那里工作，所以我们就这么认识的。</p><p><strong>David:</strong>
Yeah. So I knew Adam because I was an intern at the time at [Galois 01:00:54], which is where I’m working right now. And he worked there at the time, and so we met each other that way.</p>
<p><strong>亚当：</strong>
丹，你现在转变了观念吗？就像你一开始提到的，这些类型可能不是你喜欢的？</p><p><strong>Adam:</strong>
Dan are you a convert now, like you mentioned at the beginning types maybe not your favorite?</p>
<p><strong>Dan：</strong>
嗯，我通常会从问题的结构角度来思考，但有时问题的结构对 Henley Milner 来说并不那么友好。我不在乎，只要读我书的人能理解我们想表达的意思，无论我们想出什么技巧。有时类型是很好的选择，有时则不然。就这么简单。我们只有这么多页。我们只有这么多页，所以程序的大小只能是一定的。只要语言能够尽可能清晰地表达正在发生的事情，那么我认为没有必要。我就是这么想的。当有必要的时候，比如在 Matthias Felleisen 的《Little MLer》中，当然是做这件事的好时机。</p><p><strong>Dan:</strong>
Well, I usually think in terms of the structure of the problem, and sometimes the structure of the problem is not as friendly with Henley Milner. And I don’t care as long as the people who are reading the books that I’m writing can understand what we’re trying to say with whatever tricks we come up with. Sometimes the types are perfectly good choice, but sometimes they aren’t. It’s just that simple. We only have so many pages. We only have so many that the size of programs can only be certain size. And as long as the language is communicating as clearly as possible what’s going on, then I don’t think it’s necessary. That’s how I feel. When it is necessary, like in the Little MLer with Matthias Felleisen, sure that’s a good time to do it.</p>
<p>即使在《Little Java》中，我们也最终使用了一些类型模式。但总的来说，对我来说，问题背后的理念才是最重要的。如果我的某本小册子的合著者认为不需要类型，而我也认为不需要类型，那么我认为我们可以传达相同的概念。如果你要用类型语言编写程序，这应该相对容易，因为我们在思考如何解释这些理念时，非常清楚类型的重要性。</p><p>And even in Little Java, a few patterns we ended up using types. But by and large it’s the ideas behind the problem that mattered to me the most. And if my co-author on one of the little books doesn’t see any need for the types, and I don’t see any need for the types, then I think we can get the same concepts across. And then if you’re going to be writing a program in a type language, it should be relatively easy because we are very conscious of the types as we’re thinking about how we’re explaining the ideas.</p>
<p><strong>David：</strong>
并不是所有类型都需要机器检查。</p><p><strong>David:</strong>
Not all types need to be checked by machine.</p>
<p><strong>丹：</strong>
你这样改写得很好。我喜欢大卫的说法。</p><p><strong>Dan:</strong>
That’s a good way to rephrase it. I like that David.</p>
<p><strong>大卫：</strong>
我从马蒂亚斯那里偷来的。</p><p><strong>David:</strong>
I stole that from Matthias.</p>
<p><strong>丹：</strong>
哦，好的。</p><p><strong>Dan:</strong>
Oh, okay.</p>
<p><strong>亚当：</strong>
好的，各位。非常感谢你们抽出时间。这本书很棒。我推荐大家去看看。</p><p><strong>Adam:</strong>
All right guys. Well, thank you so much for your time. The book’s great. I recommend people check it out.</p>
<p><strong>大卫：</strong>
非常感谢您邀请我们来到这里，也非常感谢您付出这么多努力来阅读这本书。</p><p><strong>David:</strong>
And thank you very much for having us on here and also for putting in so much effort to read through the book.</p>
<p><strong>丹：</strong>
好吧，继续努力吧。你会没事的。</p><p><strong>Dan:</strong>
Well, just keep trying. You’ll be fine.</p>
<p><strong>大卫：</strong>
如果可以的话——</p><p><strong>David:</strong>
If I may-</p>
<p><strong>丹：</strong>
只要记住我所说的第八章，仔细阅读即可。</p><p><strong>Dan:</strong>
Just remember what I said about chapter eight, read it very carefully.</p>
<p><strong>大卫：</strong> 
……如果我可以插入一个小插头的话。</p><p><strong>David:</strong>
… and if I may insert one little plug.</p>
<p><strong>亚当：</strong>
哦，是的。</p><p><strong>Adam:</strong>
Oh yeah.</p>
<p><strong>David：</strong>
我最近在 Strange Loop 做了一次演讲，演示了 Pie 以及书中使用的语言和我们的讲解风格。如果你想稍微预览一下它的工作原理，可以去 YouTube 上找找。我知道 40 美元对很多人来说都是一大笔钱。如果你不确定是否要花这笔钱买这本书，可以去图书馆，也可以去 YouTube 上看看，也许能帮你做出更明智的决定。</p><p><strong>David:</strong>
I had a talk at Strange Loop recently where we had a demo of Pie and the language used in the book and sort of our explanatory style. So if you want to get a little preview of how things work, then you can go find that it’s on YouTube. Because I know $40 is a lot of money for a lot of people, and if you aren’t sure whether or not you want to invest that in the book, there’s libraries, but also you can go on YouTube and check that out and maybe it’ll make you sort of be able to make a more informed decision.</p>
<p><strong>Adam：</strong>
好的。采访就是这样。我要感谢在推特上推广Wade [Waldron 01:03:55] 上一集节目的众多朋友，尤其是[Decode 01:03:57] Maverick，他在六条推文中提到了这档节目，大部分都是西班牙语，但我认为他的评价都不错。我最近还参加了在旧金山举行的Scale By the Bay会议和[听不清 01:04:12]函数式编程培训。我想说，这两个活动都非常棒。Scale By the Bay的演讲非常精彩，有点让人应接不暇，但就会议而言，我认为这是件好事。会议结束后，我参加了[听不清 01:04:29]培训，感觉很棒。我在第九集节目中采访过他，并参加了为期四天的培训，这是一次很棒的经历。</p><p><strong>Adam:</strong>
All right. That was the interview. I’d like to thank the many people who promoted the last episode with Wade [Waldron 01:03:55] on Twitter, especially [Decode 01:03:57] Maverick who has mentioned the show in a half a dozen tweets, most of which are in Spanish, but I’m going to assume that he’s saying nice things. I was also recently at the Scale By the Bay conference in San Francisco and the [inaudible 01:04:12] functional programming training. Let me just say that both were amazing. There were so many interesting talks at Scale By the Bay. It was a bit of an overload, which when it comes to conference is I think is really a good thing. Then I followed the conference by doing the [inaudible 01:04:29] training, which was great. I interviewed him back in episode nine and taking a four day training session with him was a great experience.</p>
<h2 id="using-the-pie-language"><strong>使用饼图语言</strong></h2><h2><strong>Using the Pie Language</strong></h2>
<p>这有点累，实际上我还没有完成所有提供的练习，但我学到了很多东西，我会向任何想要学习函数式编程，特别是使用 scalp 的人推荐这个培训。好的，使用 Pie 语言。Little Typer 使用这种定制的语言，正如所讨论的，叫做 Pie。这是我对这本书的学习概述。首先，你需要下载 DrRacket，然后安装 Pie 语言。然后 [听不清 01:05:14] 在文件顶部，你只需要像磅线一样输入 Pie，很简单。在你学习这本书的过程中，我的第一个建议是深入而有条理地阅读。所以这本书是一种双列对话格式，你在阅读时要做的就是试着猜出右列中的答案。</p><p>It was a bit exhausting and actually I still haven’t completed all of the provided exercises, but I learned a lot and I would recommend the training to anyone who wants to learn about functional programming especially using scalp. All right, using the Pie Language. So the Little Typer uses this custom built language as was discussed called Pie. So here is my overview for working through the book. First of all, you want to download DrRacket and then install the Pie Language. And then [inaudible 01:05:14] top of your file you just have to put like a pound line Pie, easy enough. As you’re working through the book, my first tip is to read deeply and methodically. So the book is kind of a two column dialogue format and what you want to do as you read it is try to guess the answer that’s in the right column as you go through.</p>
<p>如果你找不到答案，没关系，但一定要理解答案。我的意思是，如果你不明白答案，我经常做的就是继续读这本书，很快答案就会越来越清楚，或者越来越模糊。如果还是不清楚，就回头再读。正如作者所说，建议重读章节。这本书的语气很像对话，但我认为内容很密集。另一件事就是运行代码。当你阅读这本书时，你会发现一些代码片段以实心框的形式显示……它们被框在实心框里。你需要把所有这些代码都输入到 DrRacket 中。你可以用小写字母代替希腊字母，比如 Lambda 和 Pie。</p><p>And if you can’t get the answer, that’s fine, but make sure that you understand the answer. And I mean, if you can’t understand the answer, what I often did was just progress a little bit more through the book and either it will get more clear or less clear very quickly. And if it’s less clear, then you should backtrack. And as you heard from the authors, rereading chapters is recommended. The book it has a very conversational tone, but I would say it’s dense. So the other thing is running the code. So as you work through the book, there are snippets of code that are in a solid… They’re outlined in a solid box. So you want to type all those in to DrRacket. You can use lowercase words in place of the Greek letters like Lambda and Pie.</p>
<p>然后，我发现仅仅玩代码就很有帮助。我尝试通过 [听不清 01:06:27] 来了解我们定义的内容，并尝试编写自己的变体，确保它能够编译并运行。我还发现，用我更熟悉的语言编写类型也很有用，就像声明上方的评论中提到的那样。还有一个名为 check same 的函数，它可以用来测试函数调用的结果是否……函数调用的结果是否具有某个值。我发现这对于忘记直觉非常有用。我会从书中输入一个函数。然后我会尝试在 [听不清 01:07:04] 中运行它，并传入一些参数。为了巩固这些知识，我会在 [听不清 01:07:11] 中输入 check same，这个调用是否等于这个结果。好的。这些就是我的技巧。感谢您收听播客到这里。如果您喜欢，请传播出去，告诉您的朋友。</p><p>And then what I found helpful with just playing with the code. So trying to run things through the [inaudible 01:06:27] to get a feel about what we were defining and try and write my own variations on it and making sure that it compiled and that I could run it. I also found it useful to write up the types in a language I was more familiar with in the comments above the claim. There is also a function called check same, that is useful for testing if the results of a function call have the… If the result of a function call have a certain value. So I found that quite useful for forgetting my intuition. I would type out a function from the book. I would then try running it in the [inaudible 01:07:04] with some arguments and then to solidify that knowledge, I would put in a check same this [inaudible 01:07:11] call equals this result. All right. So those are my tips. Thank you for listening to the podcast this far. If you enjoyed it, spread the word, tell your friends.</p>
 
 </div>
 </div>
 
 </div>
 
 
</div>
</div>

<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
