<!DOCTYPE html><html lang="en" style=""><!--
 Page saved with SingleFile 
 url: https://corecursive.com/023-little-typer-and-pie-language/ 
 saved date: Sat Apr 05 2025 18:56:56 GMT+0800 (China Standard Time)
--><head>
<meta name="dc.identifier" content="res/2a414400cb8f60ce02316d224738b782e9333185">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" title="Corecursive" type="application/rss+xml" href="https://corecursive.com/feed">
<title>2021 The Little Typer With Dan Friedman and David Christiansen.CoRecursive</title>
<link rel="canonical" href="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="website">
<meta property="og:title" content="The Little Typer - CoRecursive Podcast">
<meta property="og:url" content="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:site_name" content="CoRecursive Podcast">
<meta name="generator" content="jekyll 4.2.0"><meta name="description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]"><meta name="author" content="Adam Gordon Bell">
<meta property="og:description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]">
<meta property="og:url" content="https://corecursive.com/023-little-typer-and-pie-language/">
<meta property="og:section" content="Cloud Computing"><meta property="og:tag" content="Functional ProgrammingHaskell"><meta name="twitter:creator" content="@corecursive">
<meta name="twitter:site" content="@corecursive">
<meta name="twitter:label1" content="Written by">
<meta name="twitter:data1" content="Adam Gordon Bell">
<meta name="twitter:label2" content="Est. reading time">
<meta name="twitter:data2" content="5 minutes">
<meta name="twitter:title" content="The Little Typer - CoRecursive Podcast">
<meta name="twitter:description" content="You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... […]">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://corecursive.com/assets/images/023/action.png">
<meta property="og:image" content="https://corecursive.com/assets/images/023/action.png">
<script type="application/ld+json">{"@type":"WebSite","url":"https://corecursive.com","image":{"alt":"og-image","url":"https://corecursive.com/assets/images/023/action.png","@type":"imageObject"},"author":{"@type":"Person","name":"Adam Gordon Bell"},"description":"You can write more correct software and even rigorous mathematical proofs. Prepare for some mind stretching.Previous guests like Edwin Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do Miles Sabin said dependent types are surely the future. This interview is to get us ready for the future.Daniel P. Friedman is famous for... [&hellip;]","name":"CoRecursive Podcast","headline":"The Little Typer","@context":"https://schema.org","datePublished":"2018-12-01 00:00:00 +0000"}</script>
<link rel="shortlink" href="https://corecursive.com/">
<meta name="theme-color" content="#ffffff">
<style>/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */@media (prefers-reduced-motion:reduce){}@keyframes fa-beat{0%,90%{transform:scale(1)}45%{transform:scale(var(--fa-beat-scale,1.25))}}@keyframes fa-bounce{0%{transform:scale(1,1) translateY(0)}10%{transform:scale(var(--fa-bounce-start-scale-x,1.1),var(--fa-bounce-start-scale-y,0.9)) translateY(0)}30%{transform:scale(var(--fa-bounce-jump-scale-x,0.9),var(--fa-bounce-jump-scale-y,1.1)) translateY(var(--fa-bounce-height,-0.5em))}50%{transform:scale(var(--fa-bounce-land-scale-x,1.05),var(--fa-bounce-land-scale-y,0.95)) translateY(0)}57%{transform:scale(1,1) translateY(var(--fa-bounce-rebound,-0.125em))}64%{transform:scale(1,1) translateY(0)}100%{transform:scale(1,1) translateY(0)}}@keyframes fa-fade{50%{opacity:var(--fa-fade-opacity,0.4)}}@keyframes fa-beat-fade{0%,100%{opacity:var(--fa-beat-fade-opacity,0.4);transform:scale(1)}50%{opacity:1;transform:scale(var(--fa-beat-fade-scale,1.125))}}@keyframes fa-flip{50%{transform:rotate3d(var(--fa-flip-x,0),var(--fa-flip-y,1),var(--fa-flip-z,0),var(--fa-flip-angle,-180deg))}}@keyframes fa-shake{0%{transform:rotate(-15deg)}4%{transform:rotate(15deg)}8%,24%{transform:rotate(-18deg)}12%,28%{transform:rotate(18deg)}16%{transform:rotate(-22deg)}20%{transform:rotate(22deg)}32%{transform:rotate(-12deg)}36%{transform:rotate(12deg)}40%,100%{transform:rotate(0deg)}}@keyframes fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-classic:"Font Awesome 6 Free";--fa-font-regular:normal 400 1em/1"Font Awesome 6 Free"}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-classic:"Font Awesome 6 Free";--fa-font-solid:normal 900 1em/1"Font Awesome 6 Free"}/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */:root,:host{--fa-style-family-brands:"Font Awesome 6 Brands";--fa-font-brands:normal 400 1em/1"Font Awesome 6 Brands"}body{line-height:1.5}body *{font-family:"Source Sans Pro",sans-serif;box-sizing:border-box}html,body,div,span{margin:0;padding:0;border:0;font-size:100%}::after,::before{box-sizing:border-box}.post-text p{margin-bottom:25px;color:#000;font-size:18px}.container{margin-left:auto;margin-right:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1180px}}@media (width:800px){.container{display:block;margin:0 auto}}strong{font-weight:700;margin-right:5px}.wrapper{grid-template-rows:auto 1fr auto;display:grid}@media screen and (min-width:768px){}@media (min-width:768px){}@media only screen and (max-width:991px){}@media (min-width:768px){}@media screen and (min-width:768px){}h2.single-post-title{font-family:"Source Sans Pro",Georgia,sans-serif;font-size:40px;color:#333;font-weight:700;letter-spacing:0.24px;line-height:34px;margin-bottom:30px;margin-top:0}@media (min-width:600px){}@media (min-width:375px){}@media (min-width:425px){}@media (min-width:991px){}@media (min-width:1200px){}::placeholder{color:#999;padding-left:5px}@media (min-width:1024px){}@media (min-width:1024px){}@keyframes a{to{transform:rotate(1turn)}}@keyframes a{to{transform:rotate(1turn)}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes a{to{transform:rotate(1turn)}}@keyframes a{to{transform:rotate(1turn)}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@keyframes b{0%{background-position:0 0}to{background-position:30px 0}}@media only screen and (max-width:991px){body{overflow-x:hidden!important}}@media only screen and (max-width:767px){}@media only screen and (max-width:479px){.wrapper,body{overflow-x:hidden!important}}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}@media only screen and (max-width:991px){}@media only screen and (max-width:1023px){}@media (max-width:1023px){}@media (min-width:425px){}@media screen and (min-width:999px){}@media screen and (min-width:999px){}@media (min-width:768px){}@media (max-width:1023px){}@media (min-width:600px){}@media (min-width:768px){}@media (min-width:1024px){}@media (min-width:375px) and (max-width:767px){}@media (min-width:600px){}@media (min-width:425px){}@media (min-width:768px){}.podcast_body{padding:20px 9px}@media (min-width:1024px){.podcast_body{grid-column:2/3;grid-row:1/8}}@media only screen and (max-width:1026px){}@media screen and (min-width:768px){}@media screen and (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:1024px){}@media (min-width:1024px){}.transcript{padding:15px 0 50px}.transcript h2{font-weight:700;font-size:36px;line-height:1.2}@media (min-width:1024px){}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}@keyframes formkit-bouncedelay-formkit-form-data-uid-99a50e1950-{0%,80%,100%{transform:scale(0);transform:scale(0);transform:scale(0)}40%{transform:scale(1);transform:scale(1);transform:scale(1)}}</style>
<style>@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><meta name="referrer" content="no-referrer"><link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACUlBMVEUAAADwrU5Ci8rwrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU7wrU5Ci8pCi8pCi8rwrU7wrU7wrU7wrU7wrU5Ci8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8rwrU7wrU5Ci8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8pCi8rwrU5Ci8r///8DFUmGAAAAw3RSTlMAAAAEKGus2fL8/diqaSYDNpbf+92SMgIZiOnnghYJATTB/rwvLnM/19Fcx6350ppwcZzU+virv8RaGF7Ih/QVjvY16HIFlCoXKcUhJQFbWTyp05HhexvWnZz9z2MQ8HT6vE0IsEP1pgQK54oUUMLBt/GgMwJ/+LZGBqnLkMxcDd2bS21rbDEV91sFsx/S0x60HQuFjofeKZie+fx0/iNw1a7zrINub4TgyCYvaiiy+60RdnEP9tGBHFeXxuLu7cWVVRpunw/LAAAAAWJLR0TFYwsrdwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+QLFggTAVtY6toAAAInSURBVDjLbZL3XxNBEMVvJogYQVTQEBWjIJbYFTXEhgULR6wYNYoiWGKNBYmIBcUoRgEVATWiYqPYe6+5P8yd3eTuNh/fT7vzvrfzZm8VJSawJPVJ7pvSz5rSPzVtQDoosiB94KDBGdGYMjKHDLWZEYAs+7CopOEjsgFgpAOEP2p0TjRB1twxkDfWAtwfN16v5xjkBOfESZSFfR/zJ0+ZOs3pnD5jZr7Yz4rO5kDWHHGmqyCbWoLNPXeeVSAEgG0+Xy+wLwSIZ3YXLjKAxUu4v7TINBcUFeqAbRnPZpd8WO7SgaRMWrlWSP7KYjYOGyiVAWl0f/lO6o+olniQgLxVq0kFa1jqtXTAOjcdgLi+dIMXUf4LGwnY5BDAZs23ZWuZjGwjYDvEAU0r31FRaUaSdzLt4hEFoGm793gZgP69JMVCckjAvv0HCDh4KBAIHDZ3E8CRo8eqyMfjHE4EqoMnangC9J8koNZsI546feZsLCCqdQScU7DqfP0FplD9RUTvpXh+xJCP+Q2XFQxf4cm04FXzcKg2UrGpWQeuXZf8G2KgFtSBm5WS31pOxbZ2A6i+1Wz0V2/foVrkLhqA1tEYUv00Svje/QcdvNRZRhfCgIcCibQ9evzkaVdnt0/se3pRAMGKWu0/6nkmbqzmuYovXkYS7VevS0Qm9IRZ3zdvu2W/7t176Vmgp72rqSHufvj4qdeT8LAY8vnL12/ff/ws/fX7z1/D/gfSTU83FbhV5gAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0xMS0yMlQwODoxOTowMSswMTowMJTWI/4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMTEtMjJUMDg6MTk6MDErMDE6MDDli5tCAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head><body>
    <div id="book-container">

        <div class="wrapper" style="transform:none">
 
 
 
 <div style="position:relative">
 
 <div class="podcast_body">
 <h2 class="single-post-title">
 抄本
 </h2><h2 class="single-post-title">
 Transcript
 </h2>
 2021 The Little Typer With Dan Friedman and David Christiansen.CoRecursive
 <div class="post-text transcript">
 <h2 id="introduction"><strong>导言</strong></h2><h2><strong>Introduction</strong></h2>
<p><strong>亚当:</strong>
欢迎来到Code Recursive,在这里我们为您带来与软件开发界思想领袖的讨论。我是亚当,你的主人。</p><p><strong>Adam:</strong>
Welcome to Code Recursive, where we bring you discussions with thought leaders in the world of software development. I am Adam, your host.</p>
<p><strong>大卫:</strong>
嘿,丹,为什么你不允许使用递归?</p><p><strong>David:</strong>
Hey Dan, why aren’t you allowed to use recursion?</p>
<p><strong>丹:</strong>
因为你不允许使用递归。</p><p><strong>Dan:</strong>
Because you’re not allowed to use recursion.</p>
<p><strong>大卫:</strong>
是啊,但为什么不呢?</p><p><strong>David:</strong>
Yeah, but why not?</p>
<p><strong>丹:</strong>
因为你不允许。</p><p><strong>Dan:</strong>
Because you’re not allowed to.</p>
<p><strong>大卫:</strong>
因此,如果您希望您的程序与证明相对应,那么直接使用实际递归,其中某些内容本身与循环推理相对应。</p><p><strong>David:</strong>
So if you want your programs to correspond to proofs, then direct uses of actual recursion where something refers to itself corresponds to circular reasoning.</p>
<p><strong>亚当:</strong>
你可以写更正确的软件,甚至严格的数学证明。爱德华·布雷迪(Edward Brady)和斯蒂芬妮·威里希(Stephanie Weirich)等前嘉宾都讨论过依赖型系统可以做的一些令人兴奋的事情。迈尔斯·萨本说:“[听不清00:01:00]肯定是未来。这次采访将让我们为这一未来做好准备。</p><p><strong>Adam:</strong>
You can write more correct software and even rigorous mathematical proofs. Previous guests like Edward Brady and Stephanie Weirich have discussed some of the exciting things a dependent type system can do. Miles Saben said, “[inaudible 00:01:00] surely the future.” This interview is going to get us ready for that future.</p>
<p>丹·弗里曼(Dan Freeman)以他的小系列书籍而闻名,包括《小策划者》、《小修士》、《小传》等等。这些书受到高度重视。以下是亚马逊书评中关于Little Schemer的一句话,Little Schemer教了一件事,一件很难教一件每个专业程序员都应该知道的事情,而且它做得很好。因此,他的最新著作被称为《小打字机》,它都是关于类型的,特别是依赖类型。Dan的合著者是David [Christiansen 00:01:43]和Idris的撰稿人和关于[Type Siri 00:01:49]的播客主持人。坦率地说,这是在我的头上。</p><p>Dan Freeman is famous for his little series of books, including the Little Schemer, the Little Prover, Little MLer, and so on. These books are held in high regard. Here’s a quote about the Little Schemer from Amazon book review, Little Schemer teaches one thing, a thing that is very difficult to teach a thing that every professional programmers should know and it does it really well. So his latest book is called the Little Typer and it’s all about types, specifically dependent types. Dan’s co-author is David [Christiansen 00:01:43] and Idris contributor and host of a podcast about [Type Siri 00:01:49]. That is frankly way over my head.</p>
<p>他们将一起教我们如何已经拥有的编程技能,可以用来开发严格的数学证明。也请继续关注这一集的结尾,我会简要介绍一下我是如何通过这本书工作的,提示和技巧。如果你还没有订阅这个播客,我建议你这样做,这样新的剧集就会自动发送给你。此外,我还为播客设置了一个Slack频道。如果你想聊一聊这一集或任何剧集,或者只是与其他听众聊天,你可以加入Slack频道。你会发现网站上的链接。所以丹和大卫,欢迎来到播客。</p><p>Together they’re going to teach us how the programming skills we already have, can be used to develop rigorous mathematical proofs. Also stay tuned to the end of the episode, and I’ll give a little brief overview of how I worked through the book, Tips and Tricks. If you haven’t subscribed to this podcast yet, I recommend you do so, so that new episodes will be delivered automatically to you. Also, I’ve set up a Slack channel for the podcast. If you want to chat about this episode or any episodes, or just chat with fellow listeners, you can join the Slack channel. You will find the link on the website. So Dan and David, welcome to the podcast.</p>
<h2 id="what-are-dependent-types"><strong>依赖类型是什么?</strong></h2><h2><strong>What Are Dependent Types?</strong></h2>
<p><strong>大卫:</strong>
谢谢你有我们。</p><p><strong>David:</strong>
Thanks for having us on.</p>
<p><strong>丹:</strong>
欣赏它。</p><p><strong>Dan:</strong>
Appreciate it.</p>
<p><strong>亚当:</strong>
我有这本书,你们写了小打字机,所有关于依赖类型。所以我想我会先问你们,什么是依赖类型?</p><p><strong>Adam:</strong>
I have this book that you guys wrote the Little Typer, all about dependent types. So I thought I would start off by asking you guys so, what are dependent types?</p>
<p><strong>大卫:</strong>
因此,依赖类型是能够包含普通程序的类型。因此,我们可能使用像[Haskell 00:03:09]之类的语言或其他语言,您可能有一个A类型列表,其中A可以是任何旧类型,但在依赖类型的语言中,您也可以在那里拥有类型以外的东西。因此,您可能会说nA的列表,其中n是列表中的数,然后是您的类型系统,突然之间需要了解数字以及对数字进行算术意味着什么。例如,其中一个挂起的两个列表,然后你就可以在类型中看到输出的长度是输入长度的和那种东西的总和。</p><p><strong>David:</strong>
So dependent types are types that are able to contain ordinary programs. So we might in a language like [Haskell 00:03:09] or something, you might have a type list of A where A could be any old type, but in a dependently type language, you could also have things other than types there. So you might say like the list of nAs, where n is the number of things in the list, and then your type system, all of a sudden needs to know about numbers and what it means to do arithmetic on numbers. So for example, a pending two of these lists, then you’ll be able to see in the type that the length of the output is the sum of the lengths of the inputs and that sort of thing.</p>
<p><strong>亚当:</strong>
为什么这有用?</p><p><strong>Adam:</strong>
Why is that useful?</p>
<p><strong>大卫:</strong>
因此,考虑到它作为一个例子的频率,它的频率不如你想象的那么有用,只是因为它是一个很好的例子。但是依赖类型是有用的,因为它们允许你编写非常精确的类型,这些类型比你能够说的更多关于你的程序。</p><p><strong>David:</strong>
So that one is less useful than you might think given how often it comes up as an example, just because it’s such a good example. But dependent types are useful because they allow you to write very precise types that say a lot more about your program than you’d otherwise be able to say.</p>
<p><strong>丹:</strong>
是的,我认为更重要的一点。像[听不见的00:04:10]或Idriss这样的语言有更多的类型,但只是更多的类型为您提供了这种能力,以及它下面的工业优势。我们非常努力地让这本书成为相对容易理解的东西,感受编写依赖类型的程序意味着什么。</p><p><strong>Dan:</strong>
Yeah, that one is I think the more important point. And languages like [inaudible 00:04:10], or Idriss have more types, but it’s just more types that gives you this capability, plus industrial strengths underneath it. We’re trying very hard to make this book be something that’s relatively easy to understand, to get the feel for what it means to be writing programs with dependent types.</p>
<p><strong>大卫:</strong>
依赖类型也不仅仅是写下一个非常精确的类型。这样做很好,因为你可以从编程语言实现和编写程序中获得更多帮助。你可以在上面制作非常好的互动环境。另一种使用类型系统的方式是作为数学的逻辑,而依赖类型系统是一个非常丰富的表达逻辑,可以让你谈论各种不同的事情。所以你也可以去做一些感觉很像写程序的事情,但你实际上已经证明了一个定理,我认为这很有趣。</p><p><strong>David:</strong>
And dependent types are also about more than just writing down a very precise type. Doing that as nice, because you can get more help from your programming language implementation and writing your program. And you can make really nice interactive environments on top of that. The other way that you can use a type system is as a logic for doing mathematics, and a dependent type system is a very rich expressive logic that lets you talk about all sorts of different things. So you can also go and do something that feels very much like writing a program, but you’ve actually proved a theorem, which I think is really fun.</p>
<p><strong>丹:</strong>
是的。这是最酷的部分。毫无疑问,无论如何,你都可以......你只是有一个某种类型的程序,如果该类型被认为是一个定理,那么该程序被认为是证明。我喜欢这个比喻。只是爱它。</p><p><strong>Dan:</strong>
Yeah. That is the coolest part. There’s no question in my mind anyway that you can… You just have a program of a certain type and that if that type is thought of as a theorem, then that program is thought of as the proof. And I just love that metaphor. Just love it.</p>
<h2 id="dependent-types-or-no-types-at-all"><strong>依赖类型或无类型</strong></h2><h2><strong>Dependent Types or No Types at All</strong></h2>
<p><strong>亚当:</strong>
丹你以前的很多书都是关于方案的,我想这不是一种以类型系统而闻名的语言,我想是的。</p><p><strong>Adam:</strong>
And Dan a lot of your previous books are about scheme, which I guess it’s not a language known for its type system, I guess so.</p>
<p><strong>丹:</strong>
这当然是真的。虽然Racket有一个类型系统。这就是所谓的“发生类型”。事实上,我们使用了很多在Racket中的类型来实现我们的系统。</p><p><strong>Dan:</strong>
That’s certainly true. Although Racket does have a type system. This is something called occurrence types. And in fact, we used a lot of the types that are in Racket in order to implement our system.</p>
<p><strong>亚当:</strong>
那么,你是一般类型还是只是依赖类型?</p><p><strong>Adam:</strong>
So are you pro types in general or just dependent types?</p>
<p><strong>丹:</strong>
到目前为止,我只在依赖型营地。我只是喜欢这样的想法,你可以写一个类型并证明它是正确的。我认为这很棒,因为类型的语言比在更传统的语言中使用的语言要广泛得多。我认为这是......我仍然不是一个大粉丝。我部分是因为我想用类型编写的程序,这是不可能的。事实上,有发表的论文,你不能写我所谓的反思。有发表的论文说你不能使用[听不见的00:07:03]类型来证明你想要证明的属性。这就是为什么我喜欢依赖类型的原因之一,因为似乎没有一个大圈子,你可以画出一个大圆圈,说你不能这样做,诸如此类。</p><p><strong>Dan:</strong>
I am so far only in the dependent types camp. I just like the idea that you can just write a type and prove it correct. I think that’s fabulous, because the language of types is much broader than the language that are used in more conventional languages. And I think that’s… I’m still not a big fan. I’m partially because of the programs that I wanted to write with types, it was impossible. In fact, there’s published papers on the fact that you can’t write what I call reflection. There are published papers that say you can’t use [inaudible 00:07:03] types to prove properties that you want to prove. And that’s one of the reasons why I like dependent types, because there doesn’t seem to be a big circle you can draw around it that says you can’t do this and stuff like that.</p>
<p><strong>亚当:</strong>
所以你认为非依赖类型是限制,但依赖类型是授权的,是这个想法吗?</p><p><strong>Adam:</strong>
So you think that non-dependent types are limiting, but dependent types are empowering, is that the idea?</p>
<p><strong>丹:</strong>
这就是我的感受。我不能为大卫说话。</p><p><strong>Dan:</strong>
That’s how I feel. I can’t speak for David.</p>
<p><strong>大卫:</strong>
他确实不在那里替我说话。我喜欢编程很多不同的方式,我在语言方面玩得很开心,这些语言要么没有时间只有一个大类型,这取决于你在哪个哲学阵营,或者那些像我在工作中读了很多Haskell的人,我认为这很有趣,我也依赖类型。我喜欢很多编程方式。</p><p><strong>David:</strong>
He indeed is not speaking for me there. I like programming lots of different ways and I have fun in languages, which either don’t have time to just have one big type depending on which philosophical camp you’re in or those like I read a lot of Haskell at work and I think that’s a lot of fun and I do dependent types as well. I like lots of ways to program.</p>
<p><strong>亚当:</strong>
我也喜欢类型。依赖类型我发现我还不太确定它们是如何工作的,但我正在浏览你的书。所以希望到最后,这一切都有意义。</p><p><strong>Adam:</strong>
I like types also. Dependent types I find I’m not quite sure how they work yet, but I’m working through your books. So hopefully by the end, it’s all going to make sense.</p>
<p><strong>大卫:</strong>
我希望如此。</p><p><strong>David:</strong>
I hope so.</p>
<p><strong>亚当:</strong>
因此,在书中,您介绍了您为本书创建的这种语言馅饼。</p><p><strong>Adam:</strong>
So in the book you introduce this language pie that you created for the book.</p>
<p><strong>丹:</strong>
是的。具体地说,</p><p><strong>Dan:</strong>
Yes. Specifically,</p>
<p><strong>亚当:</strong>
这背后的意图是什么?</p><p><strong>Adam:</strong>
What’s the intent behind that?</p>
<p><strong>大卫:</strong>
因此,我们认为我们需要为这本书制作自己的语言,而不是使用像CORC这样现成的发达语言,或者[听不见的00:08:32],Idriss,或者其中之一,这些语言在自动化方面投入了大量精力,所有那些可能繁琐或困难或需要理解的部分,为了完成工作,你后来才被迫工作。</p><p><strong>David:</strong>
So the reason why we thought we needed to make our own language for this book, rather than using sort of an off the shelf well-developed language like CORC, or [inaudible 00:08:32], Idriss, or one of those was that those languages put a lot of effort into automating a way, all of the sort of parts that can be tedious or difficult or require understanding, and in the interest of getting work done, you’re not sort of forced to confront the inner workings of the system until later on.</p>
<p>我们认为,给人们提供一种非常少的语言会更容易......而且[听不见的00:09:03]更容易,我的意思是,实际上更困难。更容易让你通过努力工作来学习东西。此外,它让我们有一个实施。我们最初希望整个语言的实现是本书的最后一章。不幸的是,我们没能得到它足够小。因此,我们有很多关于如何实现它的描述。还有一个在线教程我写的。</p><p>And we thought that it’s going to be easier to give a very minimal language that people… And [inaudible 00:09:03] easier, I mean, actually more difficult. Easier for you to learn things by having to work hard at it. And additionally, it let us have an implementation. We had initially hoped to have the entire implementation of the language be the last chapter of the book. Unfortunately, we didn’t manage to get it quite small enough. So we have quite a lot of description of how you would implement it. And then there’s an online tutorial I wrote as well.</p>
<p><strong>亚当:</strong>
真的是吗?</p><p><strong>Adam:</strong>
Oh, is it really?</p>
<p><strong>大卫:</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>亚当:</strong>
语言是如何创建的?</p><p><strong>Adam:</strong>
About how the language was created?</p>
<p><strong>大卫:</strong>
教程是多老的,如果你想自己做,如果你想理解源代码。语言的源代码是免费提供的,任何人都可以下载它,修改它,如果他们愿意,破解它,至少有一种变体方言已经在野外,我希望将来会有更多。</p><p><strong>David:</strong>
How old is it the tutorial, if you want to make your own and if you want to understand the source code. The source code of the language is freely available, anyone can download it and modify it and hack on it if they want, there’s at least one variant dialect already in the wild, and I hope that there’ll be a lot more in the future.</p>
<p><strong>亚当:</strong>
有趣的是,因为我确实看了GitHub仓库,它不是很大。</p><p><strong>Adam:</strong>
The interesting thing is, because I did look at the GitHub repo, it’s not very big.</p>
<p><strong>大卫:</strong>
谢谢。</p><p><strong>David:</strong>
Thank you.</p>
<p><strong>丹:</strong>
感谢大卫的一切手段。</p><p><strong>Dan:</strong>
Well, thank David by all means.</p>
<p><strong>大卫:</strong>
我们俩都为此工作。</p><p><strong>David:</strong>
We both worked on it.</p>
<p><strong>丹:</strong>
我知道。</p><p><strong>Dan:</strong>
I know.</p>
<p><strong>大卫:</strong>
Dan对代码的简单性和小性有非常严格的标准,在处理项目时非常有用。所以,实际实现也大约一半的代码是交互式用户界面之类的东西,对吗?因此,它包括一些尚未真正暴露的未记录的部分,但我希望你将来能公开一些事情,比如如果你在某个地方做演讲,比如在幻灯片中有可编辑的Pie代码,这样你就可以在人们面前编辑代码并观看类型检查器的响应。它有插件[DrRacket 00:10:38],这样你就可以把鼠标放在表达式上,看看它们的类型是什么,以及那些东西。系统的实际核心尽可能小。嗯,其中一些事情有点毛茸茸的,只是因为处理图形用户界面只需要更多的代码。</p><p><strong>David:</strong>
Dan has very exacting standards for simplicity and smallness of code that are very useful when working on a project. So, the actual implementation up there is also about half of that code is sort of interactive user interface kind of stuff, right? So it includes some parts that are not really exposed undocumented yet, but that I hope to make more public in the future for doing things like having editable Pie code inside of a slide if you’re doing a talk somewhere, so you can sort of edit code in front of people and watch the type checker respond. And it has plugin for [DrRacket 00:10:38] so that you can put the mouse over expressions and see what their types are and those sorts of things. And the actual core of the system is as small as we could possibly make it. Well, some of those things are a little hairier, just because dealing with graphical user interfaces requires just a more code.</p>
<p><strong>亚当:</strong>
这种语言是,所以实现是用球拍编写的,为了使用它,我下载了DrRacket,我一开始就像Lang Pie一样,这就是它。</p><p><strong>Adam:</strong>
And this language is, so the implementation is written in racket and to use it, I downloaded DrRacket and I put like Lang Pie at the beginning, and that was about it.</p>
<p><strong>丹:</strong>
MM-hmm(肯定)。没错。</p><p><strong>Dan:</strong>
Mm-hmm (affirmative). That’s right.</p>
<p><strong>大卫:</strong>
球拍开发商有教育背景。因此,他们非常有动力使事情易于设置,并且易于在多台机器和此类设备上工作。</p><p><strong>David:</strong>
The racket developers have a background in education. So they’re very motivated to make things simple to set up and easy to work on multiple machines and that sorts of thing.</p>
<p><strong>亚当:</strong>
我发现关于语言的一件有趣的事情是,它只用于诸如此类的单词,而不是具有类型注释,您声称,语言中使用的措辞背后是否有原因?</p><p><strong>Adam:</strong>
One thing I found interesting about the languages is just the words it uses for things like instead of having a type annotation, you have a claim, was there reasons behind the verbiage used in the language?</p>
<p><strong>丹:</strong>
是的。我的意思是——</p><p><strong>Dan:</strong>
Yeah. I mean-</p>
<p><strong>大卫:</strong>
所以,是的。我想我们已经实现了这个东西......你说丹什么?10到12次,把它们扔掉。是的。</p><p><strong>David:</strong>
So, yeah. I think we’ve implemented this thing about… What do you say Dan? 10 to 12 times and thrown them away? Yeah.</p>
<p><strong>丹:</strong>
四、五、七、我不知道一些荒谬的大数字,但我们最初有一个表达式,既捕获了类型,也捕获了程序。它变得笨拙,我们终于坐下来聊了聊,我们把它改成了两件不同的事情。我不认为这种说法是一种类型注释,但更像是我们试图得到一个很好的表达,代表我们想要证明的[听不清的00:12:39]。</p><p><strong>Dan:</strong>
… four or five, seven, I don’t know some ridiculous large number, but we originally had one expression that captured both the type and the program. And it was getting clumsy and we finally sat down and chatted about that and we changed it to be with two different things. I don’t think of a claim kind of as a type annotation, but more like we’re trying to get a good expression that represents what the [inaudible 00:12:39] we want to prove so to speak.</p>
<p><strong>大卫:</strong>
所以声称是......对于那些没有读过这本书或与Pie合作的人。在派中,如果你想做一个顶级定义,你做的第一件事就是使用关键字声明,然后你把声明,然后是名称,然后是类型,然后你定义,然后定义名称,然后是一些应该有该类型的表达式。因此,最初我们有一种方法可以引入一个定义,您将类型和程序放在一起,并且在书中太大了。事实证明,如果我们能把两者分开,对写作来说更好。</p><p><strong>David:</strong>
So claim is… For those listening to this who haven’t read the book or worked with Pie. In Pie, if you want to do a top level definition, the first thing you do is you use the keyword claim, and then you put claim and then the name and then the type, and then later you define and then the name and then some expression which should have that type. And so initially we had one way of introducing a definition where you put down the type and the program together, and it just got to be too big in the book. And it turned out to be better for the writing, if we could separate the two from each other.</p>
<p><strong>丹:</strong>
这些小盒子可能是一个相当大的挑战,在小书。</p><p><strong>Dan:</strong>
These little boxes can be quite a challenge that are in the little books.</p>
<h2 id="on-the-little-book-format"><strong>关于“The Little”的书籍格式</strong></h2><h2><strong>On ‘The Little’ Book Format</strong></h2>
<p><strong>亚当:</strong>
是的,我打赌。所以,这实际上是我第一次阅读......我买了Little Typer和Little Schemer,我正在通过它们工作。这是我第一次介绍这种格式。我以为这很有趣。所以,这在哪里......所以对于那些不熟悉的人来说,它有一种对话形式,你来回交谈,以非常迭代的方式学习事物。那么,这种结构从何而来呢?</p><p><strong>Adam:</strong>
Yeah, I bet. So, this is actually the first time that I’ve read… I bought both the Little Typer and the Little Schemer and I was working through them. So this is my first introduction to that format. And I thought it was super fun. So where does this like… So for people who aren’t familiar it has kind of a dialogue format where you’re talking back and forth and learning about things in a very iterative fashion. So where does that structure come from?</p>
<p><strong>丹:</strong>
嗯,在获得博士学位之前,我曾经是公共政策教授,我在林登·贝恩斯·约翰逊公共事务学院教学生。有一天,学生们(听不见00:14:14),“我们能一起做点什么吗?”我说:“当然。我抓起一个房间,我们工作了一个星期,我们写了小耳语,从房间的一端走到另一端,那里有一块黑板,人们正在用不同的东西鸣叫。例如,我真的不记得我们什么时候决定放食物,但它肯定是房间里有人。可能是我。我不可能记住它。那是1973年,我们写了它,74岁出版时。这一切都在IBM Selectric上完成。还有很多其他的故事,但我会把它保存起来,因为更有趣,但是,是的,当时这是一项相当艰巨的任务。我甚至没有在IBM Selectric中输入其他人。</p><p><strong>Dan:</strong>
Well, I used to be a professor of public policy before I got my doctorate, and I was teaching the students at the Lyndon Baines Johnson School of Public Affairs. And one day the students [inaudible 00:14:14], “Can we do something together on this?” And I said, “Sure.” And I grabbed a room and we worked for a solid week and we wrote the Little Whisper by walking from one end of the room to the other, where there was a blackboard and people were chiming in with different things. For example, I really can’t remember when we decided to put in the food, but it certainly was by somebody in the room. It may have been me. I couldn’t possibly remember it. It was 1973 when we wrote it and 74 when it came out. And it was all done on an IBM Selectric. And there’s a lot of other stories that go with that, but I’ll save that for something a little more interesting, but yeah, it was quite a task back then. I didn’t even type it someone else typed it in the IBM Selectric.</p>
<p><strong>亚当:</strong>
我喜欢那个,就像它给了我一个很好的感觉......说实话,我找到了一些部分......我正在写这本书。所以我在第151页上有一个书签,但我已经扫描了一点。我跳了一点,尽管书上说不。</p><p><strong>Adam:</strong>
I like the, like it gave me a good sense for… To be honest, I found some parts… I’m working through the book. So I have a book mark here on page 151, but I’ve scanned through a little bit further. I’ve jumped ahead a little bit, even though the book said not to.</p>
<p><strong>大卫:</strong>
不要这样做。</p><p><strong>David:</strong>
Don’t do that.</p>
<p><strong>丹:</strong>
[crosstalk 00:15:32] [听不清00:15:34],你不想这样做。</p><p><strong>Dan:</strong>
[crosstalk 00:15:32]. [inaudible 00:15:34], you don’t want to do that.</p>
<p><strong>亚当:</strong>
所以我发现这本书有时是一个挑战,但我发现这个来回回它保持了节奏。所以,我觉得即使我在挣扎,至少我在很小的块上挣扎。</p><p><strong>Adam:</strong>
So I found the book to be a challenge at times, but I found that this back and forthnes it keeps the pace going. So, I felt like even though I was struggling that at least I was struggling in very small chunks.</p>
<p><strong>丹:</strong>
它做到了。我实际上有时建议,如果你觉得你没有100%的,你真的应该回去再读一遍那一章。</p><p><strong>Dan:</strong>
It does. I actually sometimes suggest that if you don’t feel you’ve got 100% of it, you should really go back and read that chapter over again.</p>
<p><strong>亚当:</strong>
我回去了。</p><p><strong>Adam:</strong>
I have gone back.</p>
<p><strong>丹:</strong>
这绝对是,书中的单词很少,重读它没有坏处,甚至可能在你前进的时候做一些笔记。</p><p><strong>Dan:</strong>
It is definitely, there are very few words in the book and there’s no harm in rereading it, and maybe even taking some notes as you’re going along.</p>
<p><strong>亚当:</strong>
所以早些时候我说过这样的说法,这种说法是一种类型,丹说,不,这是一个证据。也许这是事情的核心,不是吗?</p><p><strong>Adam:</strong>
So earlier I said something like that the claim was a type and Dan said, no, it’s a proof. And that maybe gets at the heart of the matter, doesn’t it?</p>
<p><strong>丹:</strong>
不,这是一个定理。</p><p><strong>Dan:</strong>
No, it’s a theorem.</p>
<p><strong>亚当:</strong>
这是一个定理。</p><p><strong>Adam:</strong>
Oh, it’s a theorem.</p>
<p><strong>大卫:</strong>
这不是一个定理,直到你证明它。</p><p><strong>David:</strong>
It’s not a theorem until you prove it.</p>
<p><strong>丹:</strong>
正确。但它是[听不见的00:16:31]。</p><p><strong>Dan:</strong>
Right. But it’s [inaudible 00:16:31].</p>
<p><strong>大卫:</strong>
这是一个声明。我得到[听不清的00:16:35]关于这些事情。这是一个职业[crosstalk 00:16:37]。</p><p><strong>David:</strong>
It’s a statement. I get [inaudible 00:16:35] about these things. It’s a occupational [crosstalk 00:16:37].</p>
<p><strong>丹:</strong>
很好。</p><p><strong>Dan:</strong>
It’s fine.</p>
<p><strong>大卫:</strong>
因此,我们确实有一种在Pie中进行类型注释的方法,即称为该表达式,我们称之为原因,因为我们认为如果Idris和Common Lisp都称他们的类型为[听不见的00:16:56]运算符,那么我们就处于良好的状态。</p><p><strong>David:</strong>
So we do have a way of doing type annotations in Pie, which is that expression called the and the reason we called it the was because we figured if Idris and Common Lisp both call their type [inaudible 00:16:56] operator, the, then we’re in good company.</p>
<p><strong>亚当:</strong>
好,漂亮。</p><p><strong>Adam:</strong>
Okay, nice.</p>
<p><strong>大卫:</strong>
是的,所以我想这就是我们做类型注释的方式。也许这就是为什么你反对它被称为类型注释之前丹,我不知道?</p><p><strong>David:</strong>
Yeah, so I guess that’s how we do our type annotations. Maybe that’s why you were objecting to it being called type annotation before Dan, I don’t know?</p>
<p><strong>丹:</strong>
是的,绝对的。我想如果我们要谈论它,我们应该谈论我们所拥有的。</p><p><strong>Dan:</strong>
Yes, absolutely. I figured if we’re going to talk about it we should talk about what we have.</p>
<h2 id="curry-howard"><strong>库里-霍华德</strong></h2><h2><strong>Curry-Howard</strong></h2>
<p><strong>亚当:</strong>
所以,类型和定理之间的对应,我想,是一个...</p><p><strong>Adam:</strong>
So, the correspondence between types and theorems, I guess, is a…</p>
<p><strong>丹:</strong>
库里-霍华德异构,你现在说的是吗?</p><p><strong>Dan:</strong>
Curry–Howard isomorphism, you’re talking about now?</p>
<p><strong>亚当:</strong>
我是,但我希望得到你们中的一个,也许可以扩展它,因为我一无所知,我这里有一些专家。</p><p><strong>Adam:</strong>
I am, but I was hoping to get one of you to maybe expand on it because I know nothing, and I have some experts here.</p>
<p><strong>大卫:</strong>
我怀疑你知道一些事情。</p><p><strong>David:</strong>
I suspect you know some things.</p>
<p><strong>丹:</strong>
但基本上在隐喻中,它是两个名字和一个概念。所以定理和类型基本上是一个名字,程序和证明是一个概念。当然,这是程序的证明,类型或...对不起,该类型的定理或程序的证明。所以你有他们两个,正如我所说,这叫做咖喱霍华德同构,你可以从中获得很多里程。</p><p><strong>Dan:</strong>
But basically in the metaphor, it’s two names and one concept. So theorem and type is basically one name, and program and proof are one concept. And of course it’s the proof of the program, the proof of the type or the… Sorry, proof of the theorem or program of the type. So you have both of them, and as I said, that’s called the Curry Howard isomorphism where you can get a lot of mileage out of this.</p>
<p><strong>亚当:</strong>
我想,我从这本书中学到的有趣的事情是,我为编写软件而开发的一些技能,我想,可以通过这种同构来翻译,做数学。</p><p><strong>Adam:</strong>
The interesting thing that I’m learning from this book, I guess, is that some of my skills that I’ve developed for writing software, I guess, can translate via this isomorphism to do math, I guess.</p>
<p><strong>丹:</strong>
是的。真正的数学。这是我第一次看到真正的数学,没有带来很多钟声和口哨声。这非常直接,非常简单,我们的假设是,你有一些使用语言的经验,如方案或球拍或Lisp或任何括号的家伙,你对递归很舒服。我相信你已经读过那么远,你发现了递归的舒适性是必要的,但我不会再讨论更多的细节。</p><p><strong>Dan:</strong>
Yeah. Real math. It’s the first time I’d ever seen real math that didn’t come with an awful lot of bells and whistles. This is very direct, very simple, and our assumption is that you’ve had some experience with using a language like scheme or racket or Lisp or any of the parenthesized guys, and you’re very comfortable with recursion. And I’m sure you’ve read that far where you discovered the comfort with recursion it’s necessary, but I won’t go into any more details than that.</p>
<p><strong>大卫:</strong>
所以就库里-霍华德而言,我认为有一些重要的丹,很多人都掩盖了,我没有听到你说。因此,Curry-Howard 对应关系实际上是 Curry 和 Howard 都观察到了这一点,不仅用直觉主义逻辑图编写的语句直接用于类型和证明,并证明直接到 [听不清的 00:19:47] 微积分中的程序,而且,在 [听不清的 00:19:52] 微积分中的正态化表达是否对应于 cut 消除,也就是说 . . . . 因此,我们在逻辑上最重要的结果之一是,任何方法都允许使用事实证明,规范化证明的过程是程序的正态化过程。因此,我们不仅拥有每个证明对应于一个程序,而且将我们的证明写出来并将其推入最直接的形式对应于运行我们的程序,直到它们完成。这是它非常重要的一个方面。</p><p><strong>David:</strong>
So as far as Curry–Howard goes, I think there’s something important Dan that a lot of people gloss over and that I didn’t hear you say. So Curry–Howard correspondence is really sort of Curry and Howard both observed this, that not only do statements written in intuitionistic logic map directly to types and proofs written intuitionistic logic map directly to programs in the [inaudible 00:19:47] calculus, but also that normalizing expressions in [inaudible 00:19:52] calculus corresponds to cut elimination, which is to say that… So one of the most important results we have in logic is that any proof written using the cut rule, which is the rule that allows you to sort of make local assumptions, can be simplified to approve that doesn’t use the cut rule, but that still proves the same thing. And it turns out that that process of normalizing proofs is the same process of normalizing programs. So not only do we have that every proof corresponds to a program, but also that writing our proofs out and pushing them down into the most direct form corresponds to running our programs until they’re done. And that’s a very important aspect of it.</p>
<p><strong>丹:</strong>
是的。我认为你覆盖它比我说实话,但它仍然是我在课堂上放的两个盒子。</p><p><strong>Dan:</strong>
Yeah. I think that you’ve covered it a lot better than I did truthfully, but it’s still the two boxes I put up in my class.</p>
<p><strong>大卫:</strong>
是的,这是两个盒子,但不仅仅是两个盒子。也是他们[crosstalk 00:20:52]以同样的方式,我认为这是真正酷的。我们有类似的信件,就像你最近在你的节目中有菲尔·怀尔德一样,他也谈了很多关于这个的很多其他逻辑。所以我认为任何真正对此感兴趣的人都应该听那次采访。所以,我们有一种更有趣的直觉逻辑版本,你可以谈论给你依赖类型的个体,因为你能够有不仅仅是A和B的陈述,还有关于某个对象的谓词。</p><p><strong>David:</strong>
Yeah, it’s the two boxes, but it’s more than just the two boxes. It’s also that they [crosstalk 00:20:52] the same way, which I think is what’s really cool about that. And we have similar correspondences, like so you had Phil Wilder on your show recently, and he talked quite a lot about this for a lot of other logics as well. And so I think anyone who’s really interested in this should go listen to that interview. So, we have that sort of a more interesting version of intuitionistic logic where you can talk about individuals that gives you dependent types, because you’re able to have statements that aren’t just sort of A and B, but also predicates about some object.</p>
<p>就像你可以说两个数字是相等的,或者如果......是的,两个数字是相等的,这是一个很好的例子。你必须能够谈论单个数字,或者你可以说所有数字N和M添加N等于将M添加到N。和这些东西说,像所有和存在,有个别的事情,你谈论,这真的是你从添加依赖类型到混合。但是,如果你想获得其他逻辑,你也可以弄清楚如何将这些逻辑作为程序运行。这真的,真的很酷,我想。</p><p>Like you could say the two numbers are equal or that if… Yeah, two numbers are equal, that’s a good example. You have to be able to talk about the individual numbers or you can say things like for all the numbers N and M adding N to M is equal to adding M to N. And these sorts of things saying, like for all and exists and having individual things you’re talking about, that’s really what you get from adding dependent types to the mix. But if you want to get other logics, you can also figure out how to run those as programs. And that’s really, really cool I think.</p>
<h2 id="normalization"><strong>规范化</strong></h2><h2><strong>Normalization</strong></h2>
<p><strong>亚当:</strong>
你在书中提到了正常化,我在书中有趣的事情是,好吧,这种正常化的概念,我想知道你是否可以用一个例子来描述它是什么,以及它与评估的关系?</p><p><strong>Adam:</strong>
You mentioned normalization and something that was interesting to me in the book was, well, this concept of normalization, I wonder if you could describe what it is and with an example and how it relates to evaluation?</p>
<p><strong>大卫:</strong>
因此,当你有像Pie这样的语言的类型时,类型不仅仅是对表达式进行分类,说这个是一个数字或这个数字列表,或者这个是一个函数,你给它一个数字,它给你一个数字列表。他们还告诉你,他们描述的哪些东西和他们描述的其他事物是一样的。所以你知道五加八和是和13一样的自然数。你知道,将包含一,二,三包含四,五,六的列表与包含一,二,三,四,五,六的列表相同。你可以看看这些彼此相同的东西,就像水桶一样。</p><p><strong>David:</strong>
So when you have types in a language like Pie, the types don’t just sort of classify expressions saying this one is a number or this one is a list of numbers, or this one is a function where you give it a number and it gives you back a list of numbers. They also tell you which of the things they describe are the same as which other things they describe. So you know that five plus eight is the same natural number as 13. And you know that upending the list containing one, two, three to the list containing four, five, six is the same as the list containing one, two, three, four, five, six. You can look at these sort of groups of things that are the same as each other, as sort of being buckets.</p>
<p>你把所有的数字列表,你把它们放进桶里,把它们分开,这样每个数字都和它们一样的,然后对于每个桶,我们有一个最简单的,最直接的代表,我们可以从那个桶中挑选出来,一种找到那个代表的方法。这就是我们所说的正常形式。所以,我们从每个集合中选择一个代表,这些东西彼此相同。因为我们有办法找到桶中任何东西的代表,我们可以通过找到它们的正常形式来判断两件事是否在同一个桶里。事实证明,选择这些普通论坛的一个好方法是完成所有计算,直到全部完成。</p><p>And you take all of your lists of numbers and you put them into the buckets, divide them up, such that each one is grouped with the ones that it is the same as, and then for each of these buckets, we have sort of a simplest, most direct representative that we can pick out of that bucket and a way to find that representative given anything in there. And that’s what we call the normal form. So it’s sort of, we pick one representative from each collection of things that are the same as each other. And because we have a way of finding that representative for anything in the bucket, we can tell whether two things are in the same bucket by finding their normal forms. And it turns out that a good way to pick those normal forums is to do all your computation until it’s all done.</p>
<p>虽然Pie中的一些类型,但它们有一些额外的规则,而不仅仅是运行程序。因此,例如 x 的 lambda F 本身与 F 的函数相同。因此,为了找到正常形式的函数,我们必须将它们包裹在最大数量的lambda中,直到它们被弄清楚。和单位类型,我们称之为Pie的琐碎,因为它对应于一种琐碎的理论或一个很容易证明的琐碎陈述,因为它只有一个构造函数,然后我们只是继续说,好吧,一切,它和其他一切一样,不管它是否是那个构造器,因为最终它会是。</p><p>Although some of the types in Pie, they have some additional rules that are more than just running the program. So for example lambda F of X is the same function as just F on its own. So in order to find the normal forms of functions, we have to sort of wrap them in a maximum number of lambdas until they get figured out. And the unit type, which we call a trivial in Pie, because it corresponds to sort of a trivial theory or a trivial statement that’s really easy to prove, since it’s only got one constructor, then we just go ahead and say, well, everything, and it’s the same as everything else, whether or not it’s that constructor, because eventually it would be.</p>
<p>因此,要找到使用单元类型的正常形式,您只需将单元构造函数和这些东西,但大多数类型,您只需运行程序直到完成,然后您具有正常形式。但是运行程序直到它完成,还包括进入和下面的lambdas和运行那些,这使得它更有趣。</p><p>And so to find the normal form of something with the unit type you just take the unit constructor and those sorts of things, but most types, you just run the program until it’s done, and then you have the normal form. But running the program till it’s done, also includes like going in and underneath lambdas and running those, which makes it extra fun.</p>
<p><strong>丹:</strong>
我以为你会跳过八,但我猜你没有。</p><p><strong>Dan:</strong>
I thought you were going to skip the eight along, but I guess you didn’t.</p>
<p><strong>大卫:</strong>
所以丹说八个,这是把所有最大数量的lambdas放在那些不知道的人的功能上的过程。实际上,我们把所有这些[听不清的00:25:23]的原因是,在印第安纳大学,他们很友好,让我们测试出一本关于一类学生的书的草稿。但我们甚至不必为此经历IRB。我想——</p><p><strong>David:</strong>
So Dan says eight along, that’s that process of putting all of the maximum number of lambdas around the functions for those not in the know. And actually the reason why we put in all of these [inaudible 00:25:23] was that at Indiana University, they were kind enough to let us test out a draft of our book on a class of students. But we didn’t even have to go through an IRB for that. I think-</p>
<p><strong>丹:</strong>
但有[听不清的00:25:37]做额外的。</p><p><strong>Dan:</strong>
But there [inaudible 00:25:37] to do additional.</p>
<p><strong>大卫:</strong>
......肯定。但在那个学期,我们发现像其中之一这样的某些事情是,给学生一个他们的程序应该通过的测试套件是更友好的。让运行这些测试更容易的一种方法是,如果你有很多规则告诉你,特别是函数的规则,它说你必须把所有的lambdas放在外面才能找到正常的形式。一个单位的规则,它说它们都是一样的,空类型的规则,它说它们也是一样的,因为你无论如何都不会得到一个。这样做使我们能够实际编写更简单的测试套件,我们可以给他们让他们的程序通过,因为计算机做更多的工作,使事情彼此相同,而人类做的工作更少,这总是件好事。</p><p><strong>David:</strong>
… sure. But during that semester, we discovered certain things like one of them is that it’s much friendlier to students to give them a test suite that their program should pass. And one way to make it much easier to run these tests is if you have a lot of those rules that tell you, like in particular, the rule for the function, which says you have to put all the lambdas on the outside to find the normal form. The rule for a unit, which says they’re all the same and the rule for the empty type, which says they’re all the same too, because you’re never going to get one anyway. Doing that allowed us to actually write much simpler test suites that we could give them to have their programs pass because the computer does more work making things be the same as each other, and the human does less work, which is always a good thing.</p>
<p><strong>亚当:</strong>
我想回到同一。所以在我的某个时候......在我们这样做之前,当我在写这本书的时候,我在某个时候被卡住了。然后我进入GitHub,我搜索了以Pie类型作为扩展名的文件。然后我找到了一个人,我想,谁可能参加了这门课程,你正在谈论和他们的练习。事实上,看到这个对我帮助很大,所以谢谢你在这里写下这篇文章的人,雅各布·阿德利,他的练习帮助我理解了这样的事情。</p><p><strong>Adam:</strong>
I want to get back to the sameness. So at some point in my… Before we do that, while I was working through this book, I got stuck at some point. And then so I went into GitHub and I searched for files with the Pie type as the extension. And then I found somebody, I guess, who probably took this course, you’re talking about and their exercises. And actually it helped me out a lot to to see this so thank you to who wrote this down here, Jacob Adley whose exercises helped me understand the like-</p>
<p><strong>丹:</strong>
雅各布谁?</p><p><strong>Dan:</strong>
Jacob who?</p>
<p><strong>亚当:</strong>
......阿德利。</p><p><strong>Adam:</strong>
… Adley.</p>
<p><strong>丹:</strong>
我不认识这个人。但谢谢你。</p><p><strong>Dan:</strong>
I don’t know this person. But thank you.</p>
<p><strong>大卫:</strong>
雅各布,如果你确实参加了我们的课,我们忘记了你,我很抱歉。</p><p><strong>David:</strong>
Jacob, if you did take our class and we’ve forgotten you, I’m very sorry.</p>
<p><strong>亚当:</strong>
因此,在规范化点上,以确保我理解,在一个简单的例子中,你可以加上两个,两个和四个,你说四个是正常形式,但四个也是对这个陈述的评估。所以有某种......不知何故,一种品质以我不熟悉的方式与评估联系在一起,我猜,因为...</p><p><strong>Adam:</strong>
So on the normalization points to make sure I understand, in a simple example, where you could have plus two, two and four, and you’re saying four is the normal form, but the four is also an evaluation of this statement. So there’s some sort of… Somehow a quality has been linked to evaluation in a way I’m not familiar with, I guess, because…</p>
<p><strong>大卫:</strong>
所以我认为,当你在做一个逻辑,你希望能够谈论程序,你有两种方法可以做到这一点。其中之一是,你可以写出程序计算的所有方式,然后对写证明的人说,你现在可以演示这些程序如何给你正确的答案,坐下来说,“好吧,现在我要用这个规则。然后我要在这里做beta减少。我将在这里重写plus的定义。我要展开时间的定义,看看它实际上是一个循环,在这里做一堆优点。然后我要减少这里”。或者,您可以调整逻辑,使所有内容都自动尊重计算,然后让计算机完成所有这些工作。</p><p><strong>David:</strong>
So I think that when you’re making a logic and you want to be able to talk about programs, you have sort of two ways you can do it. One of them is you can write up all the ways that programs compute and then say to the person writing the proof, you get to now demonstrate how these programs give you the right answer by sitting down and saying, “Well, now I’m going to use this rule. Then I’m going to do a beta reduction here. I’m going to rewrite by the definition of plus right here. I’m going to unfold the definition of times to see that it’s actually a loop that does a bunch of pluses over here. And then I’m going to reduce here.” Or you can rig up your logic so that everything automatically respects computation and then have the computer do all of that work.</p>
<p>关于类型理论的奇妙之处之一,我们可以认为[听不清的00:28:38]生活是提出这种判断结构或提出这种将逻辑放在一起的方式,其中计算是可以在后台发生的事情,而人类不必一次应用所有步骤。这就是为什么类型理论中的相同性概念可能是最重要的。当人们第一次知道时......我知道当我第一次学习它时,至少我有这个想法,好吧,让我们看看......我认为重要的是我们拥有哪些类型,哪些程序具有这些类型。</p><p>And one of the wonderful things about type theory that we can think [inaudible 00:28:38] to live for is coming up with this judgemental structure or coming up with this way of putting the logic together, where the computation is something that can just happen in the background without a human having to go apply all the steps one at a time. And that’s why the notion of sameness in the type theory is probably the most important thing. When people are first… I know when I first learned it, at least I had this idea like, well, let’s see… I thought the important thing was what types do we have and what programs have those types.</p>
<p>但事实上,考虑哪些程序与其他程序相同以及为什么会这样更重要。另一部分只是从中消失。这是因为它可以让你知道计算何时会发生。它可以让你知道计算机何时会完成工作,什么时候计算机不做工作,所以你必须自己做工作之类的事情。</p><p>But in fact, it’s much more important to think about which programs are the same as which other programs and why that is the case. And the other part just kind of falls out from that. And that’s because it allows you to know when computation is going to happen. And it allows you to know when the computer is going to do the work and when the computer is not going to do the work so you have to do the work yourself and that sort of thing.</p>
<p><strong>亚当:</strong>
是啊,我不认为我已经完全缠绕着我的头。很有趣。也是相同性,就像我用两个加两个来描述这个例子,但实际上相同性适用于整个函数。</p><p><strong>Adam:</strong>
Yeah, I don’t think I’ve fully wrapped my head around it. It’s interesting. Also the sameness, like I described this example with two plus two, but actually the sameness applies to whole functions.</p>
<p><strong>丹:</strong>
是的,一切,mm-hmm(肯定)。</p><p><strong>Dan:</strong>
Yeah, everything, mm-hmm (affirmative).</p>
<p><strong>大卫:</strong>
因此,思考的一种方式是,当你在的时候......假设你正在编写一个类型检查器,类型检查器至少要回答两个问题。其中一个问题是,我如何找到这个表达式的类型?但它也必须能够回答这个问题,什么时候两种类型是同一类型,对吗?因为我可能期望一种类型,而我得到表达式具有其他类型,我如何比较这两种类型?对于像简单地打字[听不见的00:30:21]微积分,你比较它们的方式只是重复它们,并检查结构是否相同。但是,当您的类型得到包含程序时,然后检查类型的相同性意味着检查程序的相同性。</p><p><strong>David:</strong>
So one way to think about it is that when you’re… Let’s say you’re writing a type checker, the type checker has got to sort of answer two questions at least. And one of those questions is how do I find the type for this expression? But it also has to be able to answer the question, when are two types the same type, right? Because I may expect one type and I get that the expression has some other type, how do I compare those two types? And for something like simply typing [inaudible 00:30:21] calculus, the way you compare them is just recur over them and check that the structure is identical. But when your types get to contain programs, then checking for sameness of types means checking for sameness of programs as well.</p>
<p><strong>亚当:</strong>
啊,我现在看到了。是的。所以你必须,这必须。</p><p><strong>Adam:</strong>
Ah, I see now. Yeah. So you have to, that has to be.</p>
<p><strong>大卫:</strong>
假设我写一个函数,它需要......作为它的论点,我需要通过它四块蛋糕。假设我有一个代表蛋糕片的类型。所以我像巧克力一样通过它,我通过彩虹,我通过双巧克力,我通过它四块巧克力。</p><p><strong>David:</strong>
Say I write a function and it needs to… As its argument, I need to pass it four pieces of cake. Let’s say I’ve got a type that represents pieces of cake. So I pass it like chocolate and I pass it rainbow and I pass it double chocolate and I pass it quadruple chocolate.</p>
<p><strong>亚当:</strong>
我喜欢你食物的一致性,把所有的例子都放在食物上。</p><p><strong>Adam:</strong>
I like your consistency of food, keeping all the examples on food.</p>
<p><strong>大卫:</strong>
但后来我实际上最终通过了......所以我想这就是我想做的,但我的蛋糕来自两个不同的地方。所以我有两个蛋糕的来源,这是我的巧克力和彩虹,我还有两块蛋糕的另一个来源,这是我的双巧克力和四块巧克力。</p><p><strong>David:</strong>
But then I actually what I ended up passing… So I think that’s what I want to do, but my cakes are coming from two different places. So I’ve got one source of two pieces of cake, which is my chocolate and my rainbow, and I’ve got another source of two pieces of cake, which is my double chocolate and quadruple chocolate.</p>
<p>所以我要调用一个功能,将附加到这些,这给了我一些东西,里面有两两块蛋糕。但我的功能需要四块蛋糕。当我们看到这一点时,我们认为,当然,这些类型是相同的,因为二加二与四相同,但类型检查器需要以它可以理解的方式构建,这意味着逻辑或类型系统本身需要构建,二加二和四是同一件事。有一些系统,我必须坐下来手动证明二加二和四是相同的,然后我才能将这些列表放在一起的结果传递到我的功能中。但在这个系统中,我们不必这样做,因为二加二和四彼此只是相同,不需要用户做任何工作。</p><p>And so I’m going to call a function that will append to these, which gives me something that has two plus two pieces of cake in it. But my function needs four pieces of cake. And when we look at that, we think, well, of course those are the same type because two plus two is the same as four, but the the type checker needs to be built in a way that it can understand that, which means that the logic or the type system itself needs to be built in such a way that two plus two and four are the same thing. And there’s some systems out there where I’d have to sit down and sort of manually prove that two plus two and four are the same before I could pass that result of putting those lists together into my function. But in this system we don’t have to, because two plus two and four are just the same as each other, without any work needing to be done by the user.</p>
<p><strong>亚当:</strong>
在馅饼里,你有一种叫做证据的东西,这有关系吗?</p><p><strong>Adam:</strong>
And in Pie you have something called evidence, is this related?</p>
<p><strong>大卫:</strong>
证据是——</p><p><strong>David:</strong>
So evidence is-</p>
<p><strong>丹:</strong>
证据是一个纲领。</p><p><strong>Dan:</strong>
Evidence is a program.</p>
<p><strong>大卫:</strong>
......是的。证据是为什么一件事是真的。我们从做直觉逻辑的人的角度写这本书。如果我们正在做这种逻辑风格,那么并非所有事情都是真或假的。有些事情,我们还不知道是真还是假。有一些悬而未决的问题,我们只是......它们不是真的,在有人通过提供真实或证明它们是假的证据来证明它们是真或假的之前,它们不是假的。希望不是既证明它们是真的,也不证明它们是假的,因为那时有人犯了一个真正的大错误。</p><p><strong>David:</strong>
… yeah. Evidence is the reason why a thing is true. We wrote the book from the perspective of someone doing intuitionistic logic. And if we’re doing that style of logic, then it’s not the case that everything is true or false. There are some things that we don’t yet know whether are true or false. There are open problems about which we just… They’re not true and they’re not false until somebody proves that they’re true or false by providing evidence that they are true or evidence that they are false. And hopefully not both evidence that they are true and evidence that they’re false because then somebody’s made a real big mistake.</p>
<p><strong>丹:</strong>
是的,我会说。</p><p><strong>Dan:</strong>
Yes, I’d say.</p>
<p><strong>亚当:</strong>
所以我想,这是我跳过的错,因为我可能误解了证据。</p><p><strong>Adam:</strong>
So I guess see, this is my fault for skipping ahead because I might’ve misunderstood the evidence.</p>
<p><strong>丹:</strong>
特别是在第八章中,你必须仔细阅读。</p><p><strong>Dan:</strong>
Especially in chapter eight, you got to read that one really carefully.</p>
<p><strong>大卫:</strong>
因此,当我们定义在类型理论中意味着什么时,我们通过说出什么是均匀的证据来做到这一点。</p><p><strong>David:</strong>
So, when we define what it means to be even in type theory, we do that by saying what counts as evidence of evenness.</p>
<p><strong>亚当:</strong>
好的。</p><p><strong>Adam:</strong>
Okay.</p>
<p><strong>大卫:</strong>
因此,说什么是均匀证据的一种方法是说,好吧,一个数字是,即使我们可以直接把它切成两半,没有任何剩余。换言之——</p><p><strong>David:</strong>
And so one way to say what counts as evidence of evenness is to say, well, a number is even if we can cut it directly in half without anything leftover. In other words-</p>
<p><strong>丹:</strong>
没有面包屑。</p><p><strong>Dan:</strong>
No crumbs.</p>
<p><strong>大卫:</strong>
......是的。假设我们想提供四个甚至的证据,嗯,证据是第二,因为加倍两个让我们得到四个。如果我们想要108个证据,那就是数字54,以及一些证据表明,它让我们得到108,这就是我们想要的。我们没有证据表明一个是,因为没有任何数字,它给你一个。因此,您定义新概念或新谓词的方式......Predicate是一个带有孔的语句,您用对象填写以获取完整语句。我们定义它的方式是,我们准确地说明什么算作该陈述的证据。</p><p><strong>David:</strong>
… yeah. Let’s say we want to provide evidence that four is even, well, that evidence is the number two because doubling two gets us four. And if we want evidence that 108 is even, that evidence is the number 54, along with some evidence that doubling 54 it gets us 108, which is what we wanted. And we don’t have evidence that one is even because there isn’t any number that doubling it gives you one. So the way you define a new concept or a new predicate… Predicate is a statement with a hole in it that you fill out with an object to get a complete statement. The way we define that is we do it precisely by stating what counts as evidence for that statement.</p>
<h2 id="on-writing-proofs"><strong>关于写作证明</strong></h2><h2><strong>On Writing Proofs</strong></h2>
<p><strong>亚当:</strong>
如果我是......也许我应该读完这本书。</p><p><strong>Adam:</strong>
If I were… Maybe I should just finish reading the book.</p>
<p><strong>丹:</strong>
你可以给我们回电话。</p><p><strong>Dan:</strong>
You can call us back.</p>
<p><strong>亚当:</strong>
我真的很享受这本书,它正在伸展我的思想。我发现这是一个挑战。这是我对此的总结。</p><p><strong>Adam:</strong>
I’m really enjoying the book, it’s stretching my mind. I’m finding it a challenge. That’s my summary of it.</p>
<p><strong>丹:</strong>
这绝对是一个挑战。</p><p><strong>Dan:</strong>
It’s definitely a challenge.</p>
<p><strong>大卫:</strong>
音乐到我的耳朵。</p><p><strong>David:</strong>
Music to my ears.</p>
<p><strong>亚当:</strong>
所以,如果我想写一些东西,证明两个的平方根是理性的,这是可以在馅饼里做的事情吗?</p><p><strong>Adam:</strong>
So, if I were to want to write out something, a proof that the square root of two is rational, is that something that can be done in Pie?</p>
<p><strong>大卫:</strong>
这需要相当多的努力,但我......所以我不想说是的,因为我没有这样做。我想——</p><p><strong>David:</strong>
It would take a fair bit of effort, but I… So I don’t want to say yes cause I haven’t done it. I think-</p>
<p><strong>丹:</strong>
我也没有。</p><p><strong>Dan:</strong>
Nor have I.</p>
<p><strong>大卫:</strong>
我认为原则上你可以这样做。但是,当你开始处理更复杂的事情时,我认为最好使用一个为你做更多工作的系统。所以我会使用...这是我停止使用Pie的地方,我会用CORC或[听不见的00:35:42]或Idris或其中一个系统来写。我们试图在书中帮助人们获得更多的哲学思想或依赖类型背后的潜在想法,而不是给你一个实用的工具。虽然从理论上讲,我认为你大概可以做到这一点。如果你不能,那么我们可以稍微改变一下语言,这样你就可以了。</p><p><strong>David:</strong>
… I think that in principle you could probably do it. But when you start getting to more complicated things then I think it would be better to use a system that does more of the work for you. So I would use… This is where I would stop using Pie and I would go write it in CORC or [inaudible 00:35:42] or Idris or one of these systems. We are trying in our book to help people get more sort of the philosophical ideas or the underlying ideas behind dependent types rather than to give you a practical tool. Although in theory, I think you can do this probably. And if you can’t, then we could change the language a little bit and make it so you could.</p>
<p><strong>丹:</strong>
是的。我希望人们能够接受实现并说:“哦,我想在语言或其他东西上有流。或其他我们没有的类型。突然,他们会说,“哦,现在我明白了。我得到了类型,因为我了解系统的其余部分在内部方面是如何工作的。然后他们能够扩大他们对Pie的定义,希望他们能与他人分享。</p><p><strong>Dan:</strong>
Yeah. I’m hoping that people will pick up the implementation and say, “Oh, I’d like to have streams in language or something.” Or other other types that we don’t have. And all of a sudden they will say, “Oh, now I’ve got it. I got to types because I understand how the rest of the system works in terms of the internals.” And then they would be able to enlarge their definition of Pie and hopefully they would share that with others.</p>
<p><strong>大卫:</strong>
但是,是的,这是可以用像Pie这样的语言做的。</p><p><strong>David:</strong>
But yes, that is the kind of thing that could be done in languages like Pie.</p>
<p><strong>亚当:</strong>
和这里的意图...我的意思是,这不对吗?所以,如果我明白的意图是提出一个非常小的语言,这样人们就可以理解这个核心?</p><p><strong>Adam:</strong>
And the intent here… I mean, isn’t that right? So if I understand the intent is to present a very small language so the people can understand this core?</p>
<p><strong>大卫:</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>丹:</strong>
MM-hmm(肯定)。绝对。</p><p><strong>Dan:</strong>
Mm-hmm (affirmative). Absolutely.</p>
<p><strong>大卫:</strong>
馅饼的核心看起来很像CORC,[听不见的00:37:01]或Idris的核心。一种非常重要的区别,那就是Pie附带了在工厂中安装的固定数据类型的集合。如果你想要更多,你必须打开它并添加你自己的。而其他语言则允许您扩展数据类型的集合。我们没有添加该功能,或者我们确实在某个时候添加了它,我再次将其撕掉,因为我们希望实现是小的和可理解的。但除此之外,它基本上是相同的系统。</p><p><strong>David:</strong>
And the core of Pie looks very much like the core of something like CORC, [inaudible 00:37:01] or Idris. The sort of one really important difference, which is that Pie comes with a fixed collection of data types sort of installed in the factory. And if you want more, you have to open it up and add your own. Whereas those other languages allow you to extend the collection of data types. And we didn’t add that feature or we did add it actually at one point and I ripped it out again because we wanted the implementation to be small and understandable. But other than that, it’s basically the same kind of system.</p>
<p><strong>亚当:</strong>
我想找出其中一个的定义,如[听不见的00:37:37],我不知道你如何发音这些东西。</p><p><strong>Adam:</strong>
I wanted to find out what the definition of one of these like [inaudible 00:37:37], I don’t know how you pronounce these things.</p>
<p><strong>丹:</strong>
这已经足够好了。</p><p><strong>Dan:</strong>
That’s good enough.</p>
<p><strong>亚当:</strong>
我正在寻找像前奏,但没有——</p><p><strong>Adam:</strong>
And I was looking for like a prelude, but there’s no-</p>
<p><strong>大卫:</strong>
它内置于语言中。有点像在Haskell,如果你想去找,如果没有真正定义任何地方。</p><p><strong>David:</strong>
It’s built into the language. Kind of like in Haskell, if you want to go find if, if isn’t really defined anywhere.</p>
<p><strong>亚当:</strong>
......是的。</p><p><strong>Adam:</strong>
… yeah.</p>
<p><strong>丹:</strong>
但这并不是100%准确。在附录B中,您可以阅读描述实现的推理规则。所以这给了你更多的材料来盯着看,让你了解发生了什么。</p><p><strong>Dan:</strong>
But that’s not 100% accurate. In appendix B you can read the inference rules, which describe the implementation. So that gives you a little bit more material to stare at, give you a sense of what is going on.</p>
<p><strong>大卫:</strong>
但事实并非如此[听不见的00:38:16]是那种你可以坐下来定义你自己的版本。你可以定义一个像[听不见的00:38:23]一样工作的函数,除了它会有点吵,因为它需要更多的参数。</p><p><strong>David:</strong>
But it’s not the case the [inaudible 00:38:16] is the kind of thing that you could sit down and define your own version of. You can define a function that works just like [inaudible 00:38:23], except it’ll be a little bit noisier because it will need more arguments.</p>
<p><strong>丹:</strong>
这是真的。</p><p><strong>Dan:</strong>
That’s true.</p>
<p><strong>大卫:</strong>
我们真正努力与Pie一起努力做的一件事是让它中的程序很短,即使实现非常简单,很多像Pie这样的小核心类型理论最终都非常冗长地编写程序,但是当你必须将它们放在比平时小的一半纸上时,用冗长来写程序是行不通的。</p><p><strong>David:</strong>
And one thing we really tried to work hard to do with Pie was make it so that programs in it were short, even though the implementation was very simple and lots of these little core type theories like Pie end up being very verbose to write programs in, but being verbose to write programs in isn’t going to work when you have to fit them in half of a piece of smaller than usual paper.</p>
<p><strong>亚当:</strong>
是好事还是坏事,是约束——</p><p><strong>Adam:</strong>
Is that a good thing or a bad thing, are the constraints-</p>
<p><strong>大卫:</strong>
我认为,这些限制在这里是有用的。它导致的是一种语言,它有一些内置的东西,其中实现使用一种称为双向类型检查的技术,我认为对此感兴趣的人以及这些实现如何工作可以阅读我所做的教程。它使用它来避免用户必须写下尽可能多的东西,同时不需要任何统一,这是依赖类型的实现可能变得复杂的地方之一。</p><p><strong>David:</strong>
I think that the constraints were useful here. What it led to was a language which had some built-in things where the implementation uses a technique called bi-directional type checking, which I think people interested in and how these implementations work can go read my tutorial that I’ve made. And it uses that to avoid having the user have to write quite as much stuff down while at the same time not needing any unification, which is one of the spots where implementations of dependent types can get complicated.</p>
<p><strong>亚当:</strong>
...所以我认为现在我们理解了语言的上下文。我不会写一个Web服务器。这是一个工具,教我们关于这个类型系统和它是如何工作的。</p><p><strong>Adam:</strong>
… so I think now we understand the context of the language. I’m not going to write a web server in this. This is a tool to teach us about this type system and how it works.</p>
<p><strong>大卫:</strong>
并教你如何思考这些类型的系统,这有望使学习工业强度系统更容易,当你完成。</p><p><strong>David:</strong>
And to teach you about the way to think about these sorts of types systems, which will hopefully make it easier to learn the industrial strength ones when you’re done.</p>
<p><strong>丹:</strong>
是的。任何完全符合我们目标的东西。我们希望学生真正通过它并理解它,然后他们可以转移到工业。</p><p><strong>Dan:</strong>
Yeah. Anything that characterizes our goal completely. We want students to really work through it and understand it, and then they can move on to the industrial ones.</p>
<p><strong>亚当:</strong>
在采访了菲利普·怀尔德之后,我想知道依赖类型,我们似乎重新引入了不可决定性,如果类型和值是一回事?</p><p><strong>Adam:</strong>
After my interview with the Phillip Wilder, I was wondering about with dependent types it seems like have we reintroduced undecidability, if types and values are the same thing?</p>
<p><strong>大卫:</strong>
所以当你说不可沉淀性时,你的意思是类型检查的不可判定性吗?</p><p><strong>David:</strong>
So when you say undecidability, do you mean undecidability of type checking?</p>
<p><strong>亚当:</strong>
我的问题可能不连贯,这是完全可能的。</p><p><strong>Adam:</strong>
My question may not be coherent, which is perfectly possible.</p>
<p><strong>大卫:</strong>
没事。让我们把它工作出来。</p><p><strong>David:</strong>
That’s okay. Let’s work it out.</p>
<p><strong>亚当:</strong>
菲尔告诉我这个故事有悖论,消除这些悖论的一种方法是消除自我反射。</p><p><strong>Adam:</strong>
Phil was telling me this story about there was paradoxes and one way to remove these paradoxes was to remove self reflexitivity.</p>
<p><strong>丹:</strong>
我们始终如一。所以这不会来[crosstalk 00:40:58]。</p><p><strong>Dan:</strong>
We are consistent. So that doesn’t come [crosstalk 00:40:58].</p>
<p><strong>大卫:</strong>
好,丹,我应该说我们没有证据证明我们的语言完全没有悖论。</p><p><strong>David:</strong>
Well, Dan, I should say we do not have a proof that our language is completely without paradox-</p>
<p><strong>丹:</strong>
确实如此。虽然——</p><p><strong>Dan:</strong>
That is true. Although-</p>
<p><strong>大卫:</strong>
......一个人做的所有标准事情都避免了它,我很确定。我敢打赌,至少这个想法是模块化的,也许还剩下一个bug。</p><p><strong>David:</strong>
… all the standard things that one does to avoid it, and I’m pretty sure. I bet a decent amount of money that at least the idea is if modular, maybe there’s a bug left.</p>
<p><strong>丹:</strong>
. . . 哦,那可能是,它肯定是错误,但一个模块化的。</p><p><strong>Dan:</strong>
… oh, that could be, it definitely be bugs, but a modular that.</p>
<p><strong>大卫:</strong>
正确。因此,类型理论的起源可以追溯到这个悖论,即有一个包含所有不包含它们的集合的集合。和-</p><p><strong>David:</strong>
Right. So the origin of type theory goes back to this paradox of having a set that contains all sets that do not contain themselves. And-</p>
<p><strong>丹:</strong>
也称为[听不见的00:41:35]的悖论。</p><p><strong>Dan:</strong>
Also know as the [inaudible 00:41:35] of paradox.</p>
<p><strong>大卫:</strong>
是的。</p><p><strong>David:</strong>
Yes.</p>
<p><strong>丹:</strong>
作者[Bertrand Russell 00:41:38]</p><p><strong>Dan:</strong>
By [Bertrand Russell 00:41:38].</p>
<p><strong>大卫:</strong>
罗素的悖论。因此,罗素的类型理论绕过这一点的方式是说,每集都不能随意地引用事物,它指的是比它小的东西。因此,在某种类型零中,只能引用普通事物,而不是其他集合。一组类型1可以引用零型和普通事物的集合,或者指[听不见的00:42:07]。一组类型二,得到包含一组类型为一,类型为零等。然后这个悖论消失了,因为问这个集合是否包含本身的问题甚至没有意义。</p><p><strong>David:</strong>
Yeah, Russell’s paradox. And so the way that Russell’s type theory gets around this is by saying that every set doesn’t get to refer to things willy nilly, it gets to refer to sort of things that are smaller than it. So in a set of sort of type zero only gets to refer to ordinary things and not to other sets. A set of type one gets to refer to sets of type zero and ordinary things or refer to [inaudible 00:42:07]. A set of type two, gets to contain sets of type one, sets of type zero and so forth. And then this paradox goes away because it doesn’t even make sense to ask the question of whether the set contains itself.</p>
<p><strong>亚当:</strong>
所以,我想我的问题是,如果我们说不像类型不能在这个世界上提到自己,或者?</p><p><strong>Adam:</strong>
So then, I guess my question is, if we’re saying like can’t types refer to themselves in this world or?</p>
<p><strong>大卫:</strong>
不,事实上,这是一个很好的问题。因此,在[听不清的00:42:36]煮熟的依赖类型理论的第一个版本中,你实际上确实有一个类型分类或描述所有类型的类型,包括本身。并且[听不清的00:42:47]出现了,并表明基于他早期的系统,它具有这样的特征,他表现出不一致。</p><p><strong>David:</strong>
No, actually, and that’s a very good question. So in the very first version of dependent type theory that [inaudible 00:42:36] cooked up, you actually did have a type which classified all the types or described all of the types including itself. And [inaudible 00:42:47] came along and showed that based on an earlier system he made, which had a feature like that, that he showed to be inconsistent.</p>
<p>他表明[Martin Lives 00:42:58]早期的系统也因为这个原因而不一致。因此,我们在Pie中所做的是,我们有一个类型,它描述了大多数其他类型,但不是本身,也不是包含自身的类型。所以我们有这种类型的U,这是宇宙,Nat的自然数类型是宇宙的一部分。亚当,亚当斯的类型在宇宙中,纳特的列表在宇宙中,但你本身不是。</p><p>He showed that [Martin Lives 00:42:58] earlier system was also inconsistent for exactly that very reason. So what we do in Pie is we have a type that describes most other types, but not itself, and also not types that contain itself. So we have this type U, which is the universe and Nat the type of natural numbers is part of the universe. Adam, the type of Adams is in the universe, list of Nat is in the universe, but U itself is not.</p>
<p>也不是U的列表或函数,把你当作一个参数,或者返回U和这些东西。哦,我们只有这种宇宙类型,因为这就是我们在小打字机中教授课程所需要的。我之前谈论的工业强度系统,它们都有无限多的宇宙类型,其中每个宇宙类型都谈论那些比自己小的宇宙。所以你有宇宙零,它谈论像Nat,宇宙一号,谈论像宇宙零和Nat之类的东西,等等。我们有一个早期版本的馅饼。然后我们用我们学生的所有家庭作业和书中的所有代码进行了一点测试,我们发现没有人真正使用过一个宇宙。我们只是把剩下的撕掉。</p><p>And neither is list of U or functions that take U as an argument, or return U and these sorts of things. Oh, and we just have this one universe type because that’s all we need in order to teach the lessons in the Little Typer. The industrial strength systems that I was talking about earlier, they all have infinitely many universe types where each of them talks about the ones that are smaller than itself. So you have universe zero, which talks about things like Nat, universe one, which talks about things like universe zero and Nat, and so on and so forth. And we had that an early version of Pie. And then we ran a little test with all of the homework assignments from our students and with all of the code in the book, and we found out that nobody ever actually used anything more than one universe. So we just rip the rest out.</p>
<p><strong>丹:</strong>
还有一种民间传说定理,你永远不需要超过五个层次的宇宙。</p><p><strong>Dan:</strong>
There’s also a sort of a folklore theorem that you never need more than five levels of universes.</p>
<p><strong>大卫:</strong>
是的。哦,有人说他们已经去检查了每一个证明[听不见的00:44:30],这是类型理论的另一个实现,这有点非常独特,非常不同于许多其他。他们[听不清的00:44:36]曾经使用过像五七个宇宙或类似的东西。也许无限多是太多,我不确定。它有一个不错的简单性。</p><p><strong>David:</strong>
Yeah. Oh, someone was saying that they’d gone and checked sort of every proof [inaudible 00:44:30], which is another implementation of type theory, which is sort of very unique and very different than many of the other ones. They [inaudible 00:44:36] ever use like five or seven universes or something like that. So maybe infinitely many is too many, I’m not sure. It has a nice simplicity to it.</p>
<h2 id="on-recursion"><strong>关于 Recursion</strong></h2><h2><strong>On Recursion</strong></h2>
<p><strong>亚当:</strong>
有一件事我觉得很有挑战性,我想,在这种派语言中,只是递归比我习惯的要多一点,那就是...</p><p><strong>Adam:</strong>
One thing that I found challenging, I guess, in this Pie language is just recursion is a bit more involved than I’m used to, is that…</p>
<p><strong>丹:</strong>
不允许使用递归。 [听不见 00:45:04]。</p><p><strong>Dan:</strong>
You’re not allowed to use recursion. [inaudible 00:45:04].</p>
<p><strong>大卫:</strong>
嘿,丹,为什么你不允许使用递归?</p><p><strong>David:</strong>
Hey Dan, why aren’t you allowed to use recursion?</p>
<p><strong>丹:</strong>
因为你不允许使用递归。</p><p><strong>Dan:</strong>
Because you’re not allowed to use recursion.</p>
<p><strong>大卫:</strong>
是的。但为什么不呢?</p><p><strong>David:</strong>
Yeah. But why not?</p>
<p><strong>丹:</strong>
因为你不允许。</p><p><strong>Dan:</strong>
Because you’re not allowed to.</p>
<p><strong>大卫:</strong>
因此,如果您希望您的程序与证明相对应,那么直接使用实际递归,其中某些内容本身与循环推理相对应。</p><p><strong>David:</strong>
So, if you want your programs to correspond to proofs, then direct uses of actual recursion where something refers to itself corresponds to circular reasoning.</p>
<p><strong>丹:</strong>
这还不够好。嗯,这对我来说是最大的冲击,顺便说一句,必须有办法绕过递归。绝对所有的时间都没有,如果和但是关于它。</p><p><strong>Dan:</strong>
And that’s not good enough. Well, that’s the biggest shock for me, incidentally, that there has to be a way around recursion. Absolutely all the time there’s no, if ands or buts about it.</p>
<p><strong>亚当:</strong>
所以它最终看起来像递归,但你只需要,你只是在计算一个自然数字。</p><p><strong>Adam:</strong>
So it ends up looking like recursion, but you just have to, you’re just working down a natural number.</p>
<p><strong>丹:</strong>
是的。关于工业强度的一件事是,它们允许递归,但只有特殊类型的递归通常使用模式语言。但是我们选择退出,因为我们真的希望人们认真思考带走的事情......我们已经消除了递归,所以你真的必须进入细节细节。</p><p><strong>Dan:</strong>
Yeah. One of the things about the industrial strength ones is that they allow recursion, but only special kinds of recursion usually using a pattern language. But we opted out of that because we really wanted people to think hard about things that took away… We have taken away recursion so that you really have to get into the nitty gritty details.</p>
<p><strong>大卫:</strong>
我认为,为了让这次讨论完全合理,我们可能应该澄清一些事情。因此,当我们有编程语言[Piedmont 00:46:22]帽子时,术语递归有一个非常具体的含义,这意味着你正在定义的东西或你正在编写的东西能够直接引用自己。因此,为了在CORC或[听不见的00:46:43]或Idriss之类的东西中做到这一点,那么在语言的实现中会发生检查。它确保每次你递归地调用一个函数,每次它调用自己,它都是在一个较小的输入上这样做的。然后它确保所有输入的大小都是有限的。因此,如果你走的步骤有限,你最终会触底,然后没关系,因为在底部,你会有一些不自我证明的东西,或者不是对自己的参考。</p><p><strong>David:</strong>
And I think that in order for this discussion to make perfect sense, there’s something that we should probably clarify. So when we’ve got our programming language [Piedmont 00:46:22] hat on, then the term recursion has a very specific meaning, which is that it means that something that you’re defining or something that you’re writing is able to refer to itself directly. And so in order to do that in something like CORC or [inaudible 00:46:43] or Idriss, then there’s a check that happens in the implementation of the language. And it makes sure that every time you’re calling a function recursively, every time it’s invoking itself, it’s doing so on a smaller input. And then it makes sure that all the inputs are finite in size. And thus, if you were going down a finite number of steps, you’ll eventually hit the bottom and then it’s okay, because at the bottom you’ll have something that isn’t self justifying or that isn’t a reference to itself.</p>
<p><strong>丹:</strong>
回到74年,那是我用来教递归的驱动力。事实上,我认为递归真的很酷。现在我不能使用它。</p><p><strong>Dan:</strong>
Back in ‘74, that was the driving force I used for teaching recursion. I actually thought recursion was really cool. Now I can’t use it.</p>
<p><strong>大卫:</strong>
因此,在这些语言中,您确实有递归,但必须进行递归,才能完成某些检查,以确保可以执行。它总是安全的,因为自我参考的问题,就像一个自我参照的论点,就像我刚才和丹在一起的那个,只有当程序陷入一个无限循环时,它才是一个问题,除了加热你的房间。因此,一个循环论证对应于一个无所事事的无限循环。</p><p><strong>David:</strong>
So in those languages you do have recursion, but it has to be recursion that lives up to certain checks to make sure that it’s okay to do. That it’s always going to be safe because the problem of self reference, like a self-referential argument, like the one I had with Dan just a moment ago is only a problem when the program falls into an infinite loop that sits there doing nothing except heating up your room. So a circular argument corresponds to an infinite loop that does nothing.</p>
<p>如果你排除那些什么都不做的无限循环,你也排除了循环论证。和馅饼为了做这个,我能说什么?为了使实现更简单,而且,我认为更重要的是,为了使语言的定义更紧密地对应于你对依赖类型的一些文献,以及一些实现,所以我们在Pie中的递归风格是[精益00:48:31]中使用的风格,我在不提及中确实错过了,因为Lean也是一个伟大的系统,另一个依赖型的研究。</p><p>And if you rule out those infinite loops that do nothing, you’re also ruling out the circular arguments. And in Pie in order to make this, what can I say? In order to make the implementation simpler and also, which I think is even more important, in order to make the definition of the language correspond more closely to some of the literature that you have on dependent types and also to some of the implementations, so the style of recursion that we have in Pie is the style used in [Lean 00:48:31], which I’ve been really remiss in not mentioning because Lean is also a great system, another dependently type language from Microsoft Research.</p>
<p>这种制定事物的方式很好,你有一些内置的递归方式,每种有限数据类型至少一种。这很棒,因为你能够有非常简单的规则来描述何时递归是可以接受的。因此,在允许递归的语言中,你总是会有......因为无法判断任意程序是否落入无限循环旋转,他们什么也不做,你反而得到保守的近似值。而那些保守的近似值,为了让你写出更有用的程序,随着时间的推移变得越来越复杂,比如,“哦,我们可以允许这个,我们可以允许这个。你必须非常小心才能完全正确,并且仍然有用。虽然与消除器的版本,就像我们在Pie中使用一样,就像他们使用精益和幕后使用的缩影一样,这很好,因为它......规则说,什么时候有递归行为可以接受,非常非常简单。</p><p>And this way of formulating things is nice, where you have a few built-in ways of doing recursion, at least one for each finite data type. It’s wonderful because you’re able to have very simple rules that describe when the recursion is acceptable. So in languages that allow recursion, you’re always going to have… Because it’s impossible to tell whether an arbitrary program falls into an infinite loop spinning they’re doing nothing, you instead get conservative approximations. And those conservative approximations in order to allow you to write more useful programs, get more and more complicated over time like, “Oh, we can allow this, we can allow this, we can allow this.” And you have to be very careful to get it exactly right, and still be useful. Whereas the version with the eliminators, like we use in Pie and like they use Lean and like epigram used behind the scenes, that’s nice because it’s… The rule saying like, when is something that has a recursive behavior acceptable are very, very simple.</p>
<p><strong>丹:</strong>
你还没有提到我认为在这一点上相关的死亡功能。你想多说一点,大卫?</p><p><strong>Dan:</strong>
You haven’t mentioned yet about fatality functions that I think is relevant in this point. Do you want to say a little bit more about that, David?</p>
<p><strong>大卫:</strong>
肯定的。是的。所以函数是,我们有域,我们有范围。这是一个函数,如果域的每个元素都与范围的一个元素配对,并且如果它们都是,那么它们都是一个总函数。函数不会说,不,它不会坐在那里旋转它的轮子,但是你给它的每一个输入,它总是会给你一个输出。</p><p><strong>David:</strong>
Sure. Yeah. So function it’s, we’ve got the domain and we’ve got the range. And it’s a function, if every element of the domain is paired up with exactly one element of the range and it’s a total function if all of them are, every single thing. The function doesn’t get to say, nope, it doesn’t get to sit there spinning its wheels, but every input you give it, it’ll always give you back an output.</p>
<p>因为我们正在处理程序,我们希望在有限的时间内恢复输出。时间有限并不是一个强有力的保证。我的意思是,你可以很容易地用像派这样的语言,你可以写一个程序,直到你老了,灰色,以返回一个答案,如果不是直到你伟大的,伟大的,伟大的孙子是老和灰色。</p><p>And because we’re dealing with programs, we want to get back that output in finite time. And finite time isn’t a very strong guarantee. I mean, you can easily in a language like Pie, you can write a program that will take until you’re old and gray to give back an answer, if not until your great, great, great grandchildren are old and gray.</p>
<p><strong>丹:</strong>
我的意思是,毕竟,我们确实在书中有[阿克曼00:50:42]。</p><p><strong>Dan:</strong>
I mean, after all, we do have [Ackerman 00:50:42] in the book.</p>
<p><strong>大卫:</strong>
是的。你可以写非常非常慢的程序,这些程序需要很长时间,即使是用[听不见的00:50:49]语言。但重要的是,程序和证明之间的这种对应关系是修改的真理。我们没有任何旧程序和任何旧证明之间的通信。我们所拥有的是总功能程序和直觉证明之间的对应关系,然后其他逻辑也有这些对应关系,但传统的Curry Howard对应关系是......直觉证明是那些不利用非建设性推理证明的。</p><p><strong>David:</strong>
Yeah. You can write very, very slow programs that take a very long time, even in a [inaudible 00:50:49] language. But the important thing is that this correspondence between programs and proofs is a truth with modification. We don’t have a correspondence between any old program and any old proof. What we have is a correspondence between total functional programs and intuitionistic proofs, and then other logics also have these correspondences, but the sort of the traditional Curry Howard correspondence is… Intuitionistic proofs are those that don’t make use of non-constructive reasoning proofs.</p>
<p>所以我们可以有......我们无法利用被排斥的中间原则,这让我们......我们不允许使用双重否定消除,你从不,不是A,到只是A,诸如此类的东西,因为那些对应于[听不见的00:51:50]演算中无法直接表示的东西。</p><p>So we can have… We’re not able to make use of the principle of the excluded middle, which lets us… We’re not allowed to make use of double negation elimination, where you go from not, not A, to just A, things like that, because those correspond to things that aren’t sort of directly representable in [inaudible 00:51:50] calculus.</p>
<p>这是一个非常长,深厚的事情。你可以通过在语言中添加诸如延续之类的东西来获得很多这些原则,这很有趣,但为了我们在这里做的事情,我们需要在一边拥有总函数,因为如果......嗯,一个函数可能在很多方面都不是完全的。一种是,对于某些输入,它可能会说,“不,我不会在这里被定义。在这种情况下,我们的证明不起作用,因为功能是我们为所有陈述证明的方式,对吗?因此,我们可能会说所有偶数,在该数字中添加一个数字,它会给你一个奇数。这将是一个函数,你给它一个数字,你给它一个数字是均匀的,它给你一个比这个数字更大的证据是奇怪的。</p><p>And this is a really long, deep thing. And you can get a lot of those principles by adding things like continuations to your language, which is really fun, but for purposes of what we’re doing here we need to have the total functions on the one side because if… Well, a function may not be total in a couple of ways. One is that it might for certain inputs just say, “Nah, I’m not going to be defined here.” And in that case then our proof doesn’t work because functions are the way we prove for all statement, right? So we might say like for all even numbers, adding one to that number it gets you an odd number. That’ll be a function where you give it a number, you give it evidence the number is even, and it gives you back evidence that one greater than that number was odd.</p>
<p>如果它只是因为24岁不起作用,出于某种原因,那么我们就有问题了。因此,它必须涵盖所有可能的输入。但是,如果24的情况只是坐在那里旋转它的循环,说,好吧,“嘿,如果我要检查25是否奇怪,我会通过检查24是否再次是第一。那么,这也将是一个不令人满意的证明。我想说这不会是一个证据。</p><p>And if it just like didn’t work for 24, for some reason, then we’d have a problem. So it’s got to cover all the possible inputs. But also if the case for 24, just sort of sat there spinning its loop by saying, well, “Hey, if I’m going to check whether 25 is odd I’m going to do that by checking whether 24 is even again first.” Then that would also be an unsatisfactory proof. I’d say it wouldn’t be a proof.</p>
<p><strong>丹:</strong>
只是不会。</p><p><strong>Dan:</strong>
Simply wouldn’t be.</p>
<p><strong>大卫:</strong>
这不会是证据。是的。因此,为了使我们所有的程序都与Pie中的证明相对应,我们确保您只能编写总函数。这些消除形式,如你之前谈论的[听不见的00:53:14],这些形式允许你确保你涵盖了所有可能的Nats,并且你所做的任何递归都以递归调用都发生在一个较小的数字上的方式控制。</p><p><strong>David:</strong>
It wouldn’t be evidence. Yeah. So in order for all of our programs to correspond to proofs in Pie, we make sure that you can only write total functions. And these elimination forms like the [inaudible 00:53:14] that you were talking about earlier, those allow you to make sure both that you’re covering all the possible Nats and that any recursion you do is controlled in such a way that recursive calls are all happening on one smaller number.</p>
<p><strong>丹:</strong>
如果我们允许递归。</p><p><strong>Dan:</strong>
If we allowed recursions.</p>
<p><strong>大卫:</strong>
是的。嗯,我的意思是行为递归,对吗?</p><p><strong>David:</strong>
Yes. Well, I mean the behavior acts recursive, right?</p>
<p><strong>丹:</strong>
是的。</p><p><strong>Dan:</strong>
Yeah.</p>
<p><strong>亚当:</strong>
对我来说,这感觉像是递归,因为就像,我不知道......我每天都在用Scala编程,我不倾向于像直接递归一样写作,我打电话给自己,我倾向于使用像折叠之类的东西,争论是相似的。对吗?你最终给它一个自然数,你需要给它一个返回下一个类型的函数,我想,我试图记住。</p><p><strong>Adam:</strong>
To me it feels like recursion because like, I don’t know… I’m programming in Scala day-to-day and I don’t tend to write like direct recursion where I’m calling myself, I tend to use like a fold or something and the arguments are similar. Right? You end up giving it a natural number and you need to give it a function that returns the next type, I think, I’m trying to remember.</p>
<p><strong>大卫:</strong>
所以,在这方面,或者让我们进入列表,因为我们谈论的是折叠,大多数人更习惯于从列表而不是数字的角度来考虑折叠。</p><p><strong>David:</strong>
So for, in that, or let’s take in the list because we’re talking about folds and most people are more used to thinking about folds in terms of lists rather than in terms of numbers.</p>
<p><strong>亚当:</strong>
MM-hmm(肯定)。</p><p><strong>Adam:</strong>
Mm-hmm (affirmative).</p>
<p><strong>大卫:</strong>
虽然基本思想本质上是相同的想法。所以,当你在列表上做一个折叠时——</p><p><strong>David:</strong>
Although the underlying idea is essentially the same idea. So, when you’re doing a fold on a list-</p>
<p><strong>丹:</strong>
是文件夹R,还是折叠L?</p><p><strong>Dan:</strong>
Is that a folder R, or a fold L?</p>
<p><strong>大卫:</strong>
让我们在这里为R而去。</p><p><strong>David:</strong>
… let’s go for R here.</p>
<p><strong>丹:</strong>
好的。这就是我所想的。</p><p><strong>Dan:</strong>
Okay. That’s what I thought.</p>
<p><strong>大卫:</strong>
我会努力保持他们的直率,因为我总是把它们弄乱。但我通常的思维方式,比如,我想在这里使用折叠L或折叠R吗?我总是会尝试一个,如果它不起作用,我会做另一个,或者我会做某种小测试,以确保它是哪一个,因为我的大脑没有连接记住那些。但是,是的,当我们使用这个鲁莽的运算符时,我们拥有非独立类型折叠,然后我们给它一个值,当列表是空列表时返回。</p><p><strong>David:</strong>
And I will try to keep them straight because I always mess them up. But my usual way of thinking, like, do I want to use fold L or fold R here is I’ll always sort of like I’ll try one, if it doesn’t work, I’ll do the other one, or I’ll do some sort of little test to make sure which one it is because my brain just isn’t wired to remember those. But yeah, when we’re doing using this reckless operator, which we have, which is the non independently typed fold, then we give it a value to return when the list is the empty list.</p>
<p>我们给它一些东西,需要列表的头部和列表的尾部,以及在列表的其余部分完成折叠的结果,并给我们一个新的输出。然后通过在每个步骤中完成这些步骤,我们向右走......最后它会做这个步骤,做这个步骤,做这个步骤,直到它击中空列表的基本情况。依赖类型版本需要一个额外的论点,这就是我们所说的动机,或者我们不叫它,这就是它所谓的。</p><p>We give it something that takes the head of a list and the tail of a list and the result of doing the fold over the rest of the list and gives us back a new output. And then by doing those at each step, we get down to the right… Finally it’ll do the step, do the step, do the step until it hits the base case for the empty list. The dependently typed version of that takes one additional argument, which is what we call the motive, or we don’t call it, that’s what it’s called.</p>
<p><strong>丹:</strong>
好,这个[crosstalk 00:55:27]你现在谈论的是感应,对吧?</p><p><strong>Dan:</strong>
Well, this [crosstalk 00:55:27] you’re talking about induction now, right?</p>
<p><strong>大卫:</strong>
是的。</p><p><strong>David:</strong>
Yes.</p>
<p><strong>丹:</strong>
好的。</p><p><strong>Dan:</strong>
Okay.</p>
<p><strong>大卫:</strong>
因此,依赖性类型折叠是感应。动机解释了你反复出现的列表的类型是什么,这意味着每个步骤的类型可能有点不同。因此,例如,如果我们想检查......如果我们想写一个证明,将空列表颠倒到任何旧列表会给你回同一个列表,那么动机将是lambda-xs,颠覆,空列表Xs等于Xs。然后,当我们对基本情况进行操作时,我们将动机应用于空列表,以找出基本情况的类型,这将是空列表,依赖空列表等于空列表。然后对于该步骤,我们将将其应用于一种未知列表,以找出其余递归结果的类型,然后将其应用于将额外元素粘贴到该步骤上,以获得我们需要的结果的类型,然后我们把它拿回来。</p><p><strong>David:</strong>
And so dependently typed fold is induction. The motive explains what the type is for in terms of the list that you’re reoccurring over, which means that the type at each step could be a little bit different. So for instance if we wanted to check… If we wanted to write a proof that upending the empty list to any old list gives you back that same list, then the motive is going to be lambda-xs, upend, empty list Xs is equal to Xs. And then when we do that for the base case, we then apply the motive to the empty list to figure out what the type of the base case is, which is going to be the empty list, depend empty list is equal to empty list. And then for the step we’re going to apply it to one sort of unknown list to find out the type of the result of the rest of the recursion, and then apply it to sticking the extra element onto that, to get the type for the result that we need, and we get that back.</p>
<p>因此,通过在每一步中结合这些,您可以适当地保持生成类型与您现在正在查看的列表之间的关系。因此,这个递归运算符和典型的折叠R之间的真正区别是,它需要更多的参数,或者需要另一个参数,这是列表的尾部。你通常不会在你去的时候包括那个。但是把它放在这里让生活更轻松,你也可以把另一个从中解脱出来。</p><p>And so then by combining these at each step, you get the relationship between the resulting type and the list that you’re looking at right now is maintained appropriately. And so the real difference between this recursion operator and the typical fold R, is that it takes a couple more arguments or it takes another argument, which is sort of the tail of the list. You’re not usually having that one included as you go. But putting it here makes life easier and you can get the other one out of this one as well.</p>
<p><strong>亚当:</strong>
我真的很喜欢这本书。</p><p><strong>Adam:</strong>
So I really liked the book.</p>
<p><strong>大卫:</strong>
谢谢。</p><p><strong>David:</strong>
Thanks.</p>
<p><strong>亚当:</strong>
我会继续为它工作。我发现......我要通过它。我会去尝试。</p><p><strong>Adam:</strong>
I’m going to keep working on it. I have found… I’m going to make it through it. I’m going to try.</p>
<p><strong>大卫:</strong>
我希望如此。</p><p><strong>David:</strong>
I hope so.</p>
<p><strong>丹:</strong>
你可能会提到它有多少页,以便人们理解你的意思,当你说我要通过它。</p><p><strong>Dan:</strong>
You might mention how many pages it is so that people understand what you mean when you say I’m going to make it through it.</p>
<p><strong>亚当:</strong>
我在这里夸大。但我确实得到了Little Schemer和Little Typer,我认为Little Typer是两倍长,但我认为有很多附录。</p><p><strong>Adam:</strong>
I’m exaggerating here. But I did get the Little Schemer and Little Typer, and I think the Little Typer is twice as long, but I think there’s a lot of appendix.</p>
<p><strong>大卫:</strong>
是的。</p><p><strong>David:</strong>
Yeah.</p>
<p><strong>丹:</strong>
是的,有一个公平的金额。</p><p><strong>Dan:</strong>
Yeah, there’s a fair amount.</p>
<p><strong>大卫:</strong>
是的,我们希望在书的后面包括源代码,Pie,以便人们可以更容易理解和玩弄实现。但是,就像你没有把方案编译器放在方案书的后面一样,它太大了。因此,我们尝试做下一个最好的事情,即对语言进行数学描述,然后一些文本解释如何阅读数学,因为这最终比代码短得多。</p><p><strong>David:</strong>
Yeah, we wanted to include the source code, the Pie in the back of the book so that people could have an easier time understanding and playing with the implementation. But just like you don’t put the scheme compiler in the back of the scheme book, it was too big. So we tried to do the next best thing, which was give a mathematical description of the language and then some text explaining how to read the math, because that ends up being a lot shorter than the code.</p>
<p><strong>丹:</strong>
可能对于那些想要确切地知道附录B语言中的内容的人来说,这是非常有用的。</p><p><strong>Dan:</strong>
And probably be for the people who want to know just exactly what’s in the language that appendix B is pretty useful.</p>
<p><strong>大卫:</strong>
如果你有正确的背景,否则我们尽力解释它,以便你弄清楚。</p><p><strong>David:</strong>
If you have the right background and otherwise we did our best explaining it so that you could figure it out.</p>
<p><strong>丹:</strong>
但是,我们试图在该部分为您提供背景。所以希望我们非常接近。</p><p><strong>Dan:</strong>
But we try to give you the background as well in that section. So hopefully we came pretty close.</p>
<p><strong>亚当:</strong>
是的。书的背面有一些有趣的东西,它说你试图做一些不实际或严格,但美丽的事情。伙计们,这是什么意思?</p><p><strong>Adam:</strong>
Yeah. And there’s something interesting on the back of the book here where it says that you were trying to do something not practical or rigorous, but beautiful. What did you guys mean by that?</p>
<p><strong>丹:</strong>
嗯,还有其他这些系统Idriss,等等,我们不断提到的,它们是实用的。</p><p><strong>Dan:</strong>
Well, there are these other systems Idriss, et cetera, the ones we keep mentioning and they are practical.</p>
<p><strong>大卫:</strong>
这也是修改的真理。它们是在正确情况下为正确类型的人提供的。希望有一天,他们会在更多情况下对更多人实用。</p><p><strong>David:</strong>
That is also a truth with modifications. They are practical for the right kinds of people in the right kinds of situations. And hopefully someday they will be practical for more people in more situations.</p>
<p><strong>丹:</strong>
是的。</p><p><strong>Dan:</strong>
Yes.</p>
<p><strong>大卫:</strong>
我只是这么说,因为我[听不见的00:59:00]在Idriss [听不见的00:59:01]很多。如果一群人出现并开始说:“伟大的丹·弗里德曼说,这很实用,但我很难写一个全新的网络浏览器,并在其中编写一个操作系统。</p><p><strong>David:</strong>
I’m just saying this because I [inaudible 00:59:00] on the Idriss [inaudible 00:59:01] a lot. And if a bunch of people show up and start saying, “The great Dan Friedman said, this was practical, but I’m having a difficult time writing a brand new web browser and writing an operating system in it.”</p>
<p><strong>丹:</strong>
嗯,有这个,当然。</p><p><strong>Dan:</strong>
Well, there is that, of course.</p>
<p><strong>大卫:</strong>
我们正在向更多领域的实用性迈进,但它们仍然是研究软件。</p><p><strong>David:</strong>
We are moving toward practicality in more domains, but they are still research software.</p>
<p><strong>丹:</strong>
正确。这是肯定的。但是我们没有尝试这个。我们试图让它,这样你就可以理解关于依赖类型的兴奋是什么。我喜欢讲一个小故事,如果可以的话,当我刚刚和卡尔·伊斯特伦德(Carl Eastlund)一起读完一本名为《小箴言》(Little Prover)的书时,我把它寄给了我的朋友亚当(Adam)[福赛尔(Faulser 00:59:51)],我一拿到他就收到他发来的电子邮件,他说:“那么你的下一本书要讲什么,下一本小书?”我说,“好吧,我见过很多关于依赖型的兴奋。他说:“不要动。“什么意思不动?”所以我在想,“如果我想要一杯水,我拿不到它什么的?”于是他给我寄了一封信,同时给大卫介绍了我们,那天下午我们决定写这本书。所以这是一个不错的小故事。如果我们没有提到亚当的参与,我会感到不舒服,</p><p><strong>Dan:</strong>
Right. That’s for sure. But we didn’t try that. We tried to make it so that you would understand pretty much what the excitement is about with respect to the dependent types. I like to tell a little story if I may, when I had just finished a book called Little Prover with Carl Eastlund, I sent it to my friend, Adam [Faulser 00:59:51], and I got an email from him as soon as he got it and he said, “So what’s your next book going to be about, next little book?” And I said, “Well, I’ve seen an awful lot of excitement about dependent types.” And he said, “Don’t move.” “What do you mean don’t move?” So I’m thinking to myself, “If I want a glass of water, I can’t get it or something?” So he sent me a letter and to David at the same time introducing us and that afternoon we decided to write the book. So that was a nice little story. And I would be uncomfortable if we did not mention Adam’s involvement,</p>
<p><strong>大卫:</strong>
他配得上累积的信用。所以不是责备,取决于你如何[crosstalk 01:00:49]。</p><p><strong>David:</strong>
He deserves the credit that accrues. So not the blame, depending on how you [crosstalk 01:00:49].</p>
<p><strong>丹:</strong>
[crosstalk 01:00:48] 责任。</p><p><strong>Dan:</strong>
[crosstalk 01:00:48] the blame.</p>
<p><strong>大卫:</strong>
是的。所以我认识亚当,因为我当时是[加洛伊丝01:00:54]的实习生,这就是我现在工作的地方。他当时在那里工作,所以我们就是这样认识的。</p><p><strong>David:</strong>
Yeah. So I knew Adam because I was an intern at the time at [Galois 01:00:54], which is where I’m working right now. And he worked there at the time, and so we met each other that way.</p>
<p><strong>亚当:</strong>
丹你现在是一个皈依者,就像你在开始时提到的类型也许不是你最喜欢的?</p><p><strong>Adam:</strong>
Dan are you a convert now, like you mentioned at the beginning types maybe not your favorite?</p>
<p><strong>丹:</strong>
嗯,我通常从问题的结构来看,有时问题的结构与亨利·米尔纳不那么友好。我不在乎,只要那些正在读我写的书的人能理解我们想说什么,我们想出什么技巧。有时类型是非常好的选择,但有时它们不是。就是这么简单。我们只有这么多页。我们只有这么多,以至于程序的大小只能是一定的大小。只要语言尽可能清楚地传达正在发生的事情,那么我认为没有必要。这就是我的感受。当有必要时,就像在与Matthias Felleisen的Little Mler中一样,当然这是一个很好的时机。</p><p><strong>Dan:</strong>
Well, I usually think in terms of the structure of the problem, and sometimes the structure of the problem is not as friendly with Henley Milner. And I don’t care as long as the people who are reading the books that I’m writing can understand what we’re trying to say with whatever tricks we come up with. Sometimes the types are perfectly good choice, but sometimes they aren’t. It’s just that simple. We only have so many pages. We only have so many that the size of programs can only be certain size. And as long as the language is communicating as clearly as possible what’s going on, then I don’t think it’s necessary. That’s how I feel. When it is necessary, like in the Little MLer with Matthias Felleisen, sure that’s a good time to do it.</p>
<p>即使在小Java中,我们最终也使用了一些类型。但总的来说,问题背后的想法对我来说最重要。如果我的合著者在其中一本小书上没有看到任何类型的需求,而且我没有看到任何类型的需求,那么我认为我们可以得到相同的概念。然后,如果你要用类型语言编写程序,那应该相对容易,因为我们非常了解这些类型,因为我们正在考虑如何解释这些想法。</p><p>And even in Little Java, a few patterns we ended up using types. But by and large it’s the ideas behind the problem that mattered to me the most. And if my co-author on one of the little books doesn’t see any need for the types, and I don’t see any need for the types, then I think we can get the same concepts across. And then if you’re going to be writing a program in a type language, it should be relatively easy because we are very conscious of the types as we’re thinking about how we’re explaining the ideas.</p>
<p><strong>大卫:</strong>
并非所有类型都需要通过机器检查。</p><p><strong>David:</strong>
Not all types need to be checked by machine.</p>
<p><strong>丹:</strong>
这是一个很好的方式来重新措辞。我喜欢这个大卫。</p><p><strong>Dan:</strong>
That’s a good way to rephrase it. I like that David.</p>
<p><strong>大卫:</strong>
我从马蒂亚斯那里偷了它。</p><p><strong>David:</strong>
I stole that from Matthias.</p>
<p><strong>丹:</strong>
哦,好。</p><p><strong>Dan:</strong>
Oh, okay.</p>
<p><strong>亚当:</strong>
好的家伙们。非常感谢你的时间。书的伟大。我建议人们检查一下。</p><p><strong>Adam:</strong>
All right guys. Well, thank you so much for your time. The book’s great. I recommend people check it out.</p>
<p><strong>大卫:</strong>
非常感谢你让我们在这里,也感谢你们为阅读这本书付出了如此多的努力。</p><p><strong>David:</strong>
And thank you very much for having us on here and also for putting in so much effort to read through the book.</p>
<p><strong>丹:</strong>
好,继续尝试。你会没事的。</p><p><strong>Dan:</strong>
Well, just keep trying. You’ll be fine.</p>
<p><strong>大卫:</strong>
如果可以——</p><p><strong>David:</strong>
If I may-</p>
<p><strong>丹:</strong>
只记下我讲的第八章,读得很仔细。</p><p><strong>Dan:</strong>
Just remember what I said about chapter eight, read it very carefully.</p>
<p><strong>大卫:</strong>
如果我可以插入一个小插头。</p><p><strong>David:</strong>
… and if I may insert one little plug.</p>
<p><strong>亚当:</strong>
哦,是的。</p><p><strong>Adam:</strong>
Oh yeah.</p>
<p><strong>大卫:</strong>
我最近在Strange Loop进行了一次演讲,在那里我们有一个Pie的演示和书中使用的语言以及我们的解释风格。因此,如果你想对事情的运作方式进行一点预览,那么你可以去发现它在YouTube上。因为我知道40美元对很多人来说是一大笔钱,如果你不确定你是否想在这本书中投资,有图书馆,但你也可以去YouTube上查看一下,也许它会让你做出更明智的决定。</p><p><strong>David:</strong>
I had a talk at Strange Loop recently where we had a demo of Pie and the language used in the book and sort of our explanatory style. So if you want to get a little preview of how things work, then you can go find that it’s on YouTube. Because I know $40 is a lot of money for a lot of people, and if you aren’t sure whether or not you want to invest that in the book, there’s libraries, but also you can go on YouTube and check that out and maybe it’ll make you sort of be able to make a more informed decision.</p>
<p><strong>亚当:</strong>
好的。这就是采访。我要感谢在Twitter上与韦德一起推广最后一集的许多人,特别是[解码01:03:57]小牛在六条推文中提到了这个节目,其中大部分是西班牙语,但我会假设他说的很好话。我最近还参加了旧金山的Scale By the Bay会议和[听不见的01:04:12]功能编程培训。我只想说,两者都是惊人的。在Scale By the Bay有很多有趣的会谈。这有点过载,当谈到会议时,我认为这确实是一件好事。然后我跟着会议做了[听不见的01:04:29]训练,这很棒。我在第九集中采访了他,和他一起参加为期四天的训练课是一次很棒的经历。</p><p><strong>Adam:</strong>
All right. That was the interview. I’d like to thank the many people who promoted the last episode with Wade [Waldron 01:03:55] on Twitter, especially [Decode 01:03:57] Maverick who has mentioned the show in a half a dozen tweets, most of which are in Spanish, but I’m going to assume that he’s saying nice things. I was also recently at the Scale By the Bay conference in San Francisco and the [inaudible 01:04:12] functional programming training. Let me just say that both were amazing. There were so many interesting talks at Scale By the Bay. It was a bit of an overload, which when it comes to conference is I think is really a good thing. Then I followed the conference by doing the [inaudible 01:04:29] training, which was great. I interviewed him back in episode nine and taking a four day training session with him was a great experience.</p>
<h2 id="using-the-pie-language"><strong>使用Pie语言</strong></h2><h2><strong>Using the Pie Language</strong></h2>
<p>这有点累,实际上我还没有完成所有提供的练习,但我学到了很多东西,我会向任何想学习功能编程的人推荐培训,特别是使用头皮。好的,使用Pie语言。因此,Little Typer使用这种定制的语言,称为Pie。以下是我对本书的概述。首先,您要下载DrRacket,然后安装Pie语言。然后[听不见的01:05:14]文件的顶部,你只需要像磅线一样放一个Pie,足够容易。当你在写这本书的时候,我的第一个技巧是深入而有条不紊地阅读。因此,这本书是一种两列对话格式,当你阅读它时,你想做什么,就是试着猜猜你通过右列中的答案。</p><p>It was a bit exhausting and actually I still haven’t completed all of the provided exercises, but I learned a lot and I would recommend the training to anyone who wants to learn about functional programming especially using scalp. All right, using the Pie Language. So the Little Typer uses this custom built language as was discussed called Pie. So here is my overview for working through the book. First of all, you want to download DrRacket and then install the Pie Language. And then [inaudible 01:05:14] top of your file you just have to put like a pound line Pie, easy enough. As you’re working through the book, my first tip is to read deeply and methodically. So the book is kind of a two column dialogue format and what you want to do as you read it is try to guess the answer that’s in the right column as you go through.</p>
<p>如果你不能得到答案,那很好,但要确保你理解答案。我的意思是,如果你不能理解答案,我经常做的只是通过这本书多进步一点,要么它会变得更加清晰,要么很快就会变得不那么清晰。如果不太清楚,那么你应该回溯。正如你从作者那里听到的,建议重读章节。这本书的语气很合乱,但我想说它很密集。另一件事是运行代码。因此,当你浏览这本书时,有一些代码片段是固体的......它们被勾勒在一个坚实的盒子里。所以你想把所有这些输入到DrRacket。您可以使用小写字母代替希腊字母,如Lambda和Pie。</p><p>And if you can’t get the answer, that’s fine, but make sure that you understand the answer. And I mean, if you can’t understand the answer, what I often did was just progress a little bit more through the book and either it will get more clear or less clear very quickly. And if it’s less clear, then you should backtrack. And as you heard from the authors, rereading chapters is recommended. The book it has a very conversational tone, but I would say it’s dense. So the other thing is running the code. So as you work through the book, there are snippets of code that are in a solid… They’re outlined in a solid box. So you want to type all those in to DrRacket. You can use lowercase words in place of the Greek letters like Lambda and Pie.</p>
<p>然后我发现什么只是玩代码。因此,尝试通过[听不见的01:06:27]来了解我们定义的内容,并尝试在它上写下自己的变体,并确保它编译并且我可以运行它。我也发现用我在上面的评论中更熟悉的语言写类型是有用的。还有一个函数称为 check 相同,对于测试函数调用的结果是否具有...如果函数调用的结果具有某种值非常有用。所以我发现这很有助于忘记我的直觉。我会从书中输入一个函数。然后,我会尝试在[听不见的01:07:04]中运行它,并用一些参数,然后为了巩固这些知识,我会在检查中给出同样的[听不见的01:07:11]调用等于这个结果。好的。这些是我的提示。谢谢你这么远听播客。如果你喜欢它,传播这个词,告诉你的朋友。</p><p>And then what I found helpful with just playing with the code. So trying to run things through the [inaudible 01:06:27] to get a feel about what we were defining and try and write my own variations on it and making sure that it compiled and that I could run it. I also found it useful to write up the types in a language I was more familiar with in the comments above the claim. There is also a function called check same, that is useful for testing if the results of a function call have the… If the result of a function call have a certain value. So I found that quite useful for forgetting my intuition. I would type out a function from the book. I would then try running it in the [inaudible 01:07:04] with some arguments and then to solidify that knowledge, I would put in a check same this [inaudible 01:07:11] call equals this result. All right. So those are my tips. Thank you for listening to the podcast this far. If you enjoyed it, spread the word, tell your friends.</p>
 
 </div>
 </div>
 
 </div>
 
 
</div>
</div>
<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>