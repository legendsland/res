<!DOCTYPE html><html class="translated-ltr" style=""><!--
 Page saved with SingleFile 
 url: file:///home/zy/ws/res/res/plt/generator/antlr/The%20Definitive%20ANTLR%204%20Reference.Parr2013.2e.html 
 saved date: Sun Sep 08 2024 13:55:37 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/1ebdcb5aea1dac45902413a043f21a819d2cc091">
<meta charset="utf-8">


<title>The Definitive ANTLR 4 Reference.Parr2013.2e</title>
<style>@font-face{font-family:DroidSansMono;font-weight:normal;font-style:normal;src:url(data:,)}@font-face{font-family:DroidSansMono;font-weight:bold;font-style:normal;src:url(data:,)}@font-face{font-family:DroidSans;font-weight:normal;font-style:normal;src:url(data:,)}@font-face{font-family:"DroidFont",serif,sans-serif;font-weight:normal;font-style:normal;src:url(data:,)}@font-face{font-family:"DroidFont",serif,sans-serif;font-weight:bold;font-style:normal;src:url(data:,)}@font-face{font-family:"DroidFont",sans-serif;font-weight:normal;font-style:italic;src:url(data:,)}@font-face{font-family:"DroidFont",sans-serif;font-weight:bold;font-style:italic;src:url(data:,)}@font-face{font-family:"DejaVuSans",sans-serif;font-weight:normal;font-style:normal;src:url(data:,)}@font-face{font-family:"DejaVuSans",sans-serif;font-weight:bold;font-style:normal;src:url(data:,)}@font-face{font-family:"DejaVuSans",sans-serif;font-weight:normal;font-style:italic;src:url(data:,)}@font-face{font-family:"DejaVuSans",sans-serif;font-weight:bold;font-style:italic;src:url(data:,)}@font-face{font-family:"DroidSerif",serif;font-weight:normal;font-style:normal;src:url(data:,)}@font-face{font-family:"DroidSerif",serif;font-weight:bold;font-style:normal;src:url(data:,)}@font-face{font-family:"DroidSerif",serif;font-weight:normal;font-style:italic;src:url(data:,)}@font-face{font-family:"DroidSerif",serif;font-weight:bold;font-style:italic;src:url(data:,)}body{margin:0pt 1em;padding:0pt}tt,code,kbd,samp{font-size:80%}h1.part-title{text-align:center}h1.part-title .part-number{font-size:80%}.partintro{border-top:3px solid #aaaadd;border-bottom:3px solid #aaaadd;padding-top:3px;padding-bottom:3px;margin-top:2em;margin-left:10%;margin-right:10%;font-style:italic}h1.chapter-title{margin-top:2em;text-align:right}h1.chapter-title .chapter-number{color:#999999;font-weight:bold;display:block;font-size:90%}h1.chapter-title .chapter-name{display:block;color:#555555;background:url(data:,)repeat-x bottom;font-size:120%;font-weight:bold;margin-bottom:1ex}h2{font-size:140%;font-weight:bold;text-align:left!important;color:#445;margin-top:1em;margin-bottom:1ex!important}h3{font-size:110%;font-weight:bold;color:#225555;clear:both;margin-top:1em;margin-bottom:1ex}h4{font-size:100%;font-weight:bold;color:#225555;clear:both;margin-top:0.8em;margin-bottom:0.8ex}p{line-height:130%;margin-top:0pt}.contribution{font-size:smaller;color:#888;padding-left:10%;padding-right:10%}.acronym{font-weight:bold;font-variant:small-caps;color:#333333}.author{margin-top:1em;margin-bottom:1em;text-align:right}.authoraffiliation{font-style:italic}.authors{margin-top:3em;font-size:18pt;color:#666666}div.authorq{margin:1em 0;padding:1em;background:#dddddd;font-size:smaller}div.authorq .the-author-asks{font-weight:bold;display:inline}.b{font-weight:bold}.bad-xref{color:red}dl.bibliography{margin-left:0pt}dl.bibliography dt{float:left;clear:left;width:4.5em;text-align:left;font-size:90%;font-weight:bold}dl.bibliography dd{margin-bottom:8px;margin-left:4em;padding:0 0 0 0}dl.bibliography dd em{color:#223388;font-weight:bold}.unused-bookinfo{margin-top:2em;margin-bottom:4em;padding:3em;border-width:8px;border-style:dotted;border-color:#dddddd}.titlepage{margin-left:10%;margin-right:10%;text-align:center}.tp-title{display:block;margin-top:50px;padding-top:10px;padding-bottom:10px;color:#555555;border-width:3px;border-style:solid none;border-color:#888888}.tp-subtitle{display:block;margin-top:10px;color:#777777}.tp-authors{display:block;color:#777;margin-top:20px}.tp-copyright{margin-top:45px;margin-left:20%;margin-right:20%;font-size:x-small;border-top:1px solid #bbb;color:#444}.tp-extracted-from{font-size:70%;color:#9999bb}div.tp-extract-explanation{margin-top:72pt}div.tp-extract-explanation p{font-size:70%;margin-left:20%;margin-right:20%}.copyright-body{font-family:"DroidSans";font-size:70%}.tp-docinfo{margin-top:30px;font-size:small;color:#777}.booksectname{font-style:italic}.cf{color:#227;font-family:"DroidSans"}.stringinfile{font-style:italic}.emph{font-style:italic}.epigraph{width:60%;position:relative;left:30%;padding-top:0px;padding-top:0px;padding-left:8px;padding-right:8px;border-style:solid;text-align:left;border-width:6px;border-color:#dddddd;font-size:small;font-style:italic;margin-bottom:0.7em}.episign{padding:2px;border-style:solid;text-align:right;border-width:2px 0px 0px 0px;border-color:#dddddd;font-size:small}.episigntitle{font-style:italic}.figure{padding:7px;border-style:dotted;text-align:center;border-width:3px;border-color:#dddddd;margin-top:1em;margin-bottom:1em}.figurecaption{font-weight:bold;text-align:center}.firstuseinline{font-style:italic}.firstusemargin{position:absolute;top:auto;left:1em;font-style:italic;font-size:x-small;float:left;width:1in;text-align:right}.flag{color:red}.flagadvanced{float:left;margin-right:1em}.footnotes{margin-top:2em;border-width:2px 0 0 0;border-style:solid none none none;border-color:#888888;font-size:smaller}.footnotes td.footnote-number{white-space:nowrap;width:1.5em}div.highlight{border-top:3px solid #acc;border-bottom:3px solid #acc;width:20%;float:left;margin-right:2em}div.highlight p{margin-bottom:0.2em}.initials{font-weight:bold;font-variant:small-caps;color:#333333}.example{border:2px solid #88d;background:#ccf;padding-left:1em;padding-right:1em;margin-left:0pt;margin-right:0pt;border-radius:15px;-moz-border-radius:15px}.marginnote{position:absolute;top:auto;left:1em;font-weight:bold;font-size:x-small;float:left;width:1in;text-align:right;line-height:100%}.nohyphen{-webkit-hyphens:none}.missing{position:absolute;top:auto;left:1em;font-weight:bold;font-size:x-small;float:left;width:1in;text-align:right;line-height:100%}.prefacesignoff a{font-weight:bold}.prefacesignoffemail{font-family:courier,fixed,monospace;font-size:small}.prefacesignoffdate{font-size:small}span.shade-fg-white{color:white}span.shade-fg-black{color:black}span.shade-fg-red{color:red}span.shade-fg-green{color:green}span.shade-fg-yellow{color:yellow}span.shade-fg-blue{color:blue}span.shade-fg-magenta{color:magenta}span.shade-fg-cyan{color:cyan}span.shade-fg-light{color:rgb(220,220,180)}span.shade-fg-dark{color:rgb(50,50,100)}span.shade-bg-white{background-color:white}span.shade-bg-black{background-color:black}span.shade-bg-red{background-color:red}span.shade-bg-green{background-color:green}span.shade-bg-yellow{background-color:yellow}span.shade-bg-blue{background-color:blue}span.shade-bg-magenta{background-color:magenta}span.shade-bg-cyan{background-color:cyan}span.shade-bg-light{background-color:rgb(220,220,180)}span.shade-bg-dark{background-color:rgb(50,50,100)}table.processedcode{margin:0.7em 0px}.processedcode tr{margin-top:0px;margin-bottom:0px}.processedcode tr td{padding-top:0px;padding-bottom:0px}.codeprefix{font-family:DroidSansMono;font-weight:bold;font-size:70%}.codeline{font-family:DroidSansMono;line-height:1.2;font-size:80%}.codeline code{font-family:DroidSansMono}.codeline pre{font-family:DroidSansMono;margin-top:0px;margin-bottom:0px;font-weight:bold}.codecalloutnumber{font-size:80%}tr.livecodelozenge td{font-size:90%;padding-left:0.2em;padding-top:0.2em;padding-bottom:0.4em;text-decoration:underline}span.callout-number{font-size:80%;color:green}dl.calloutlist{margin-left:0pt}dl.calloutlist dt{float:left;clear:left;width:1em;text-align:left;font-size:70%}dl.calloutlist dd{margin:0 0 0 1.5em;padding:0 0 0 0}.simpletable{margin-top:1em;margin-bottom:2em;border-collapse:collapse}table.outerlines,table.hlines{padding:2px;border:2px solid #aaaadd}th.outerlines,th.hlines{border-bottom:2px solid #aaaadd;background:#ddddff}.simpletable td,.simpletable th{text-align:left;vertical-align:top;padding-left:0.5em;padding-right:0.5em}.simpletable p.last-para-in-cell{margin-bottom:0pt}.simpletable tr.zebra{background:#ddffdd}.simpletable tr.line-on-top td{border-top:1px solid #aaaadd}.standin{font-style:italic;font-weight:bold;color:#444444}table.arr-recipe{font-family:"Trebuchet MS",Arial,Helvetica,sans-serif;border:6px solid #6aa;width:100%;padding:0px}table.arr-recipe td.arr-recipe-number{font-size:smaller;font-weight:bold;text-align:center;width:15%;background:#6aa;padding:0;margin:0;color:white}table.arr-recipe .arr-recipe-name{font-size:larger;padding-top:1ex;padding-left:1em;padding-bottom:1ex}.tabletitle{font-weight:bold;padding:2px;border-width:0px 0 2px 0;border-style:none none solid none;border-color:#888888}table.pg-task{font-size:140%;font-weight:bold;text-align:left!important;color:#445;margin-top:1em;margin-bottom:1ex!important}td.pg-what-to-do{font-size:110%;font-weight:bold;color:#445;padding:2px;text-align:center;border-style:dotted;border-width:3px;border-color:#008000;margin-top:1em;margin-bottom:1em}.xmltag{}.comment{color:#115511;font-style:italic}.kw{color:#111199;font-weight:bold}.prompt{color:rgb(144,17,125);font-weight:bold}.string{color:#555511;font-style:italic}.sidebar{margin-top:2em;margin-bottom:2em;padding:1em;font-size:90%;font-family:sans;border:3px solid #aaa}.sidebar .sidebar-title{text-align:center;font-weight:bold;border-bottom:1px solid #aaa}.underline{text-decoration:underline}div.webresources .title{font-weight:bold;margin-bottom:0pt}div.webresources .url{font-weight:bold;margin-top:0pt;margin-bottom:0pt}div.webresources .desc{margin-top:0px;margin-left:2em}div.webresources .desc p{margin-top:0px}.xref-title{font-style:italic}div.xxxsays{font-size:small;margin:1em 0;padding:1em;border:2px #aaaaaa solid}div.xxxsays .heading{padding-bottom:0.5em;margin-bottom:1em;border-bottom:2px #aaaaaa solid}div.xxxsays .heading .persons-picture{float:left;margin-right:2em}div.xxxsays .heading .label{font-weight:bold;color:#999999;margin-bottom:0.2em}div.xxxsays .heading .title{font-weight:bold;font-size:larger;color:#555555}.copyright{font-size:x-small;color:#335555;background:#aabbbb;margin-top:3em;padding-top:3px;padding-bottom:3px;text-align:center;border-top:1px #335555 solid}div.backmatter-cover{float:left;padding-right:20px;padding-bottom:20px}hr.backmatter-end{clear:both}ul.praise{list-style:none}.praisename{font-weight:bold}.dedication-text{margin-top:3em;font-style:italic;text-align:center}.dedication-name{margin-top:0.5em;text-align:right}</style>
<style></style>
<style>.VIpgJd-ZVi9od-ORHb-OEVmcd{left:0;top:0;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6B90DA;margin:0;box-shadow:0 0 8px 1px #999}.VIpgJd-ZVi9od-xl07Ob-OEVmcd{z-index:10000002;border:none;position:fixed;box-shadow:0 3px 8px 2px #999}.VIpgJd-ZVi9od-SmfZ-OEVmcd{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#FFF;border-left:1px solid #D5D5D5;border-top:1px solid #9B9B9B;border-bottom:1px solid #E8E8E8;border-right:1px solid #D5D5D5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline}.goog-te-gadget .goog-te-combo{margin:4px 0}.VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-l4eHX-hSRGPd:link,.VIpgJd-ZVi9od-l4eHX-hSRGPd:visited,.VIpgJd-ZVi9od-l4eHX-hSRGPd:hover,.VIpgJd-ZVi9od-l4eHX-hSRGPd:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-TvD9Pc-hSRGPd{display:block;margin:0 10px}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd{padding-top:2px;padding-left:4px}.goog-te-combo,.VIpgJd-ZVi9od-ORHb *,.VIpgJd-ZVi9od-SmfZ *,.VIpgJd-ZVi9od-xl07Ob *,.VIpgJd-ZVi9od-vH1Gmf *,.VIpgJd-ZVi9od-l9xktf *{font-family:arial;font-size:10pt}.VIpgJd-ZVi9od-ORHb{margin:0;background-color:#E4EFFB;overflow:hidden}.VIpgJd-ZVi9od-ORHb img{border:none}.VIpgJd-ZVi9od-ORHb-bN97Pc{color:#000}.VIpgJd-ZVi9od-ORHb-bN97Pc img{vertical-align:middle}.VIpgJd-ZVi9od-ORHb-Tswv1b{color:#666;vertical-align:top;margin-top:0;font-size:7pt}.VIpgJd-ZVi9od-ORHb-KE6vqe{width:8px}.VIpgJd-ZVi9od-LgbsSe{border-color:#E7E7E7;border-style:none solid solid none;border-width:0 1px 1px 0}.VIpgJd-ZVi9od-LgbsSe div{border-color:#CCC #999 #999 #CCC;border-right:1px solid #999;border-style:solid;border-width:1px;height:20px}.VIpgJd-ZVi9od-LgbsSe button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.VIpgJd-ZVi9od-LgbsSe button:active{background:none repeat scroll 0 0#CCC}.VIpgJd-ZVi9od-SmfZ{margin:0;background-color:#FFF;white-space:nowrap}.VIpgJd-ZVi9od-SmfZ-hSRGPd{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-SmfZ-hSRGPd img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.VIpgJd-ZVi9od-SmfZ-hSRGPd span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-te-float-top .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-top-width:0}.goog-te-float-bottom .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-bottom-width:0}.VIpgJd-ZVi9od-xl07Ob-lTBxed{text-decoration:none;color:#00C;white-space:nowrap;margin-left:4px;margin-right:4px}.VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:underline}.VIpgJd-ZVi9od-xl07Ob-lTBxed img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed{color:#000}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:none}.VIpgJd-ZVi9od-xl07Ob{background-color:#FFF;text-decoration:none;border:2px solid #C3D9FF;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-xl07Ob-ibnC6b{padding:3px;text-decoration:none}.VIpgJd-ZVi9od-xl07Ob-ibnC6b,.VIpgJd-ZVi9od-xl07Ob-ibnC6b:link{color:#00C;background:#FFF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:visited{color:#551A8B}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:hover{background:#C3D9FF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:active{color:#00C}.VIpgJd-ZVi9od-vH1Gmf{background-color:#FFF;text-decoration:none;border:1px solid #6B90DA;overflow:hidden;padding:4px}.VIpgJd-ZVi9od-vH1Gmf-KrhPNb{width:16px}.VIpgJd-ZVi9od-vH1Gmf-hgDUwe{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div{padding:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b .uDEFge{display:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .uDEFge{display:auto}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .fmcmS{padding-left:4px;padding-right:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd{text-decoration:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:active div{color:#00C;background:#FFF}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:hover div{color:#FFF;background:#36C}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:hover div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:active div{color:#000;font-weight:bold}.VIpgJd-ZVi9od-l9xktf{background-color:#FFF;overflow:hidden;padding:8px;border:none;border-radius:10px}.VIpgJd-ZVi9od-l9xktf-OEVmcd{background-color:#FFF;border:1px solid #6B90DA;box-shadow:0 3px 8px 2px #999;border-radius:8px}.VIpgJd-ZVi9od-l9xktf img{border:none}.VIpgJd-ZVi9od-l9xktf-fmcmS{margin-top:6px}.VIpgJd-ZVi9od-l9xktf-VgwJlc{margin-top:6px;white-space:nowrap}.VIpgJd-ZVi9od-l9xktf-VgwJlc *{vertical-align:middle}.VIpgJd-ZVi9od-l9xktf-VgwJlc .DUGJie{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc .TdyTDe{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc span{color:#00C;text-decoration:underline;cursor:pointer;margin:0 4px}.VIpgJd-ZVi9od-l9xktf-I9GLp{margin:6px 0 0}.VIpgJd-ZVi9od-l9xktf-I9GLp form{margin:0}.VIpgJd-ZVi9od-l9xktf-I9GLp form textarea{margin-bottom:4px;width:100%}.VIpgJd-ZVi9od-l9xktf-yePe5c{margin:6px 0 4px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf{z-index:1000;position:fixed;-webkit-transition-delay:.6s;transition-delay:.6s;left:-1000px;top:-1000px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf-ti6hGc{-webkit-transition-delay:0s;transition-delay:0s;left:-14px;top:-14px}.VIpgJd-ZVi9od-aZ2wEe-OiiCO{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#FFF url(data:image/png;base64,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)50% 50%no-repeat;-webkit-transition:all .6s ease-in-out;transition:all .6s ease-in-out;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}.VIpgJd-ZVi9od-aZ2wEe-OiiCO-ti6hGc{-webkit-transform:scale(.5);transform:scale(.5);opacity:1}.VIpgJd-ZVi9od-aZ2wEe{margin:2px 0 0 2px;-webkit-animation:spinner-rotator 1.4s linear infinite;animation:spinner-rotator 1.4s linear infinite}@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}.VIpgJd-ZVi9od-aZ2wEe-Jt5cK{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285F4;-webkit-transform-origin:center;transform-origin:center;-webkit-animation:spinner-dash 1.4s ease-in-out infinite;animation:spinner-dash 1.4s ease-in-out infinite}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb html,.VIpgJd-yAWNEb-L7lbkb body,.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb h1,.VIpgJd-yAWNEb-L7lbkb h2,.VIpgJd-yAWNEb-L7lbkb h3,.VIpgJd-yAWNEb-L7lbkb h4,.VIpgJd-yAWNEb-L7lbkb h5,.VIpgJd-yAWNEb-L7lbkb h6,.VIpgJd-yAWNEb-L7lbkb p,.VIpgJd-yAWNEb-L7lbkb a,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul,.VIpgJd-yAWNEb-L7lbkb li,.VIpgJd-yAWNEb-L7lbkb table,.VIpgJd-yAWNEb-L7lbkb form,.VIpgJd-yAWNEb-L7lbkb tbody,.VIpgJd-yAWNEb-L7lbkb tr,.VIpgJd-yAWNEb-L7lbkb td{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul{list-style:none}.VIpgJd-yAWNEb-L7lbkb table{border-collapse:collapse;border-spacing:0}.VIpgJd-yAWNEb-L7lbkb caption,.VIpgJd-yAWNEb-L7lbkb th,.VIpgJd-yAWNEb-L7lbkb td{text-align:left;font-weight:normal}.VIpgJd-yAWNEb-L7lbkb input::-moz-focus-inner{border:0}div>.VIpgJd-yAWNEb-L7lbkb{padding:10px 14px}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS,.VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-r4nke{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TvD9Pc-LgbsSe{display:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-l4eHX{float:left;margin:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-PLDbbf{display:inline-block}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf{display:none;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-H9tDt{margin-top:20px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-LK5yu{float:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-qwU8Me{float:right}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-cGMI2b{min-height:15px;position:relative;height:1%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-jOfkMb-Ne3sFf{background:-webkit-linear-gradient(top,#29910d 0,#20af0e 100%);background:-webkit-gradient(linear,left top,left bottom,from(#29910d),to(#20af0e));background:linear-gradient(top,#29910d 0,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0 2px 2px #1e6609;-moz-box-shadow:inset 0 2px 2px #1e6609;-webkit-box-shadow:inset 0 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-hSRGPd{color:#15c;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}.VIpgJd-yAWNEb-L7lbkb>textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}.VIpgJd-yAWNEb-L7lbkb textarea:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);border:1px solid #4d90fe;outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-IbE0S{margin-right:10px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp{min-height:25px;vertical-align:middle;padding-top:8px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp{margin-bottom:5px;margin-bottom:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);border-radius:2px;-webkit-transition:all .218s;transition:all .218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0s;transition:all 0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe{outline:none;border:1px solid #4d90fe;z-index:4!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.gk6SMd{background-color:#eee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eee,#e0e0e0);background-image:linear-gradient(top,#eee,#e0e0e0);box-shadow:inset 0 1px 2px rgba(0,0,0,.1);border:1px solid #ccc;color:#333}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-moz-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{border-color:#3079ed}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-mrxPge{color:#999;font-family:arial,sans-serif}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-W0vJo-fmcmS{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0 5px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-u0pjoe-fmcmS{color:#800;display:none;font-size:9pt}.VIpgJd-yAWNEb-VIpgJd-fmcmS-sn54Q{background-color:#c9d7f1;box-shadow:2px 2px 4px #99a;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-xl07Ob{background:#fff;border:1px solid #ddd;box-shadow:0 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb{cursor:pointer;padding:2px 5px 5px;margin-right:0;border-style:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb:hover{background:#ddd}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb h1{font-size:100%;font-weight:bold;margin:4px 0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb strong{color:#345aad}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:right;position:absolute;right:0;left:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-j7LFlb-SIsrTd .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:left;position:absolute;left:0;right:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-fmcmS,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{color:#222}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{color:white;position:absolute!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#c9d7f1;border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-DyVDA{background-color:transparent;border:1px solid #4d90fe;border-radius:0;-webkit-border-radius:0;-moz-border-radius:0;margin:-2px;padding:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-LzX3ef{border-left:2px solid red;margin-left:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-YIAiIb{border-right:2px solid red;margin-right:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf{padding:2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);outline:none;border:1px solid #4d90fe}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-sFeBqf{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-SIsrTd{position:absolute;top:10px;right:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c,.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd .VIpgJd-yAWNEb-hvhgNd-IuizWc{text-align:right;margin:0 36px 0 0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-UTujCb{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 .VIpgJd-yAWNEb-SIsrTd{left:5px;right:auto}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}sentinel{}</style><meta name="referrer" content="no-referrer"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="cover.xhtml"><div>

    <div>
      <img src="data:image/jpg;base64,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" alt="实用书架" title="实用书架">
    </div>
  </div></div>
<div id="f_0000.html"><div>

<h1 class="titlepage tp-title">权威的 ANTLR 4 参考</h1><h1 class="titlepage tp-title">The Definitive ANTLR 4 Reference</h1>
<h3 class="titlepage tp-subtitle"></h3>
<h3 class="titlepage tp-authors">作者：Terence Parr</h3><h3 class="titlepage tp-authors">by Terence Parr</h3>
<div class="titlepage tp-docinfo">版本：P1.0（2013年1月）</div>
<div class="titlepage tp-copyright">版权所有 © 2012 The Pragmatic Programmers, LLC。本书已授权给购买者本人。我们不对其进行版权保护，因为这会限制您将其用于个人目的的能力。请不要破坏这份信任 — 您可以在所有设备上使用它，但请不要与团队的其他成员、朋友或通过文件共享服务共享此副本。谢谢。 
       <br><br>—Dave 和 Andy。</div>

</div></div>
<div id="f_0001.html"><div>

<h1>
</h1><h1>
</h1>
<p>
<span class="copyright-body">
      制造商和销售商用来区分其产品的许多名称均已声明为商标。当这些名称出现在本书中且 The Pragmatic Programmers, LLC 知晓商标声明时，这些名称均以首字母大写或全大写形式印刷。The Pragmatic Starter Kit、The Pragmatic Programmer、Pragmatic Programming、Pragmatic Bookshelf 和链接 
      <i>g</i>
      设备是 The Pragmatic Programmers, LLC 的商标。</span>
</p><p>
<span class="copyright-body">
      Many of the designations used by manufacturers and sellers to
      distinguish their products are claimed as trademarks. Where those
      designations appear in this book, and The Pragmatic Programmers, LLC
      was aware of a trademark claim, the designations have been printed in
      initial capital letters or in all capitals. The Pragmatic Starter Kit,
      The Pragmatic Programmer, Pragmatic Programming, Pragmatic Bookshelf
      and the linking 
      <i>g</i>
      device are trademarks of The Pragmatic Programmers,
      LLC.</span>
</p>
<p>
<span class="copyright-body">
      本书在编写过程中已采取一切预防措施。但是，出版商对书中的错误或遗漏，或因使用其中的信息（包括程序列表）而造成的损失不承担任何责任。</span>
</p><p>
<span class="copyright-body">
      Every precaution was taken in the preparation of this
      book. However, the publisher assumes no responsibility for errors or
      omissions, or for damages that may result from the use of information
      (including program listings) contained herein.</span>
</p>
<p>
<span class="copyright-body">
      我们的实用课程、研讨会和其他产品可以帮助您和您的团队创建更好的软件并获得更多乐趣。如需更多信息以及最新的实用书籍，请访问 
      <a href="http://pragprog.com/">http://pragprog.com</a>。</span>
</p><p>
<span class="copyright-body">
      Our Pragmatic courses,
      workshops, and other products can help you and your team create better
      software and have more fun. For more information, as well as the
      latest Pragmatic titles, please visit us at 
      <a href="http://pragprog.com">http://pragprog.com</a>.</span>
</p>

</div></div>
<div id="f_0002.html"><div>

<h1 class="table-of-contents">目录</h1><h1 class="table-of-contents">Table of Contents</h1>
<table width="100%" class="table-of-contents2">
<tbody>
<tr>
<td valign="top"></td>
<td>
<a href="#f_0004.html.N10089">致谢</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<tbody>
<tr>
<td valign="top"></td>
<td>
<a href="#f_0005.html.N100A6">欢迎加入！</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
</colgroup><tbody>
<tr>
<td> </td>
<td>
<a href="#f_0006.html.N100DB">这本书适合哪些人阅读？</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
</colgroup><tbody>
<tr>
<td> </td>
<td>
<a href="#f_0007.html.N100F3">ANTLR V4 有什么特别之处？</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
</colgroup><tbody>
<tr>
<td> </td>
<td>
<a href="#f_0008.html.N10191">这本书里有什么？</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
</colgroup><tbody>
<tr>
<td> </td>
<td>
<a href="#f_0009.html.N101E1">在线了解有关 ANTLR 的更多信息</a>
</td>
</tr>
</tbody>
</table>
<div class="table-of-contents1">
<a href="#f_0010.html.N101FF">
<strong>一、ANTLR 和计算机语言简介</strong>
</a>
</div>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0011.html.chp.antlr">1.</a>
</td>
<td>
<a href="#f_0011.html.chp.antlr">认识 ANTLR</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0012.html.N1021D">1.1</a>
</td>
<td>
<a href="#f_0012.html.N1021D">安装 ANTLR</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0013.html.sec.intro_launch">1.2</a>
</td>
<td>
<a href="#f_0013.html.sec.intro_launch">执行 ANTLR 并测试识别器</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0014.html.chp.bigpic">2.</a>
</td>
<td>
<a href="#f_0014.html.chp.bigpic">总体情况</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0015.html.sec.terms">2.1</a>
</td>
<td>
<a href="#f_0015.html.sec.terms">让我们获得 Meta！</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0016.html.sec.parsing-terminology">2.2</a>
</td>
<td>
<a href="#f_0016.html.sec.parsing-terminology">实现解析器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0017.html.sec.ambiguity">2.3</a>
</td>
<td>
<a href="#f_0017.html.sec.ambiguity">你不能向核反应堆中加入太多的水</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0018.html.sec.parse-trees">2.4</a>
</td>
<td>
<a href="#f_0018.html.sec.parse-trees">使用解析树构建语言应用程序</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0019.html.sec.listeners-and-visitors">2.5</a>
</td>
<td>
<a href="#f_0019.html.sec.listeners-and-visitors">解析树监听器和访问者</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0020.html.chp.starter">3.</a>
</td>
<td>
<a href="#f_0020.html.chp.starter">入门级 ANTLR 项目</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0021.html.sec.fjfj">3.1</a>
</td>
<td>
<a href="#f_0021.html.sec.fjfj">ANTLR 工具、运行时和生成的代码</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0022.html.sec.testing-parser">3.2</a>
</td>
<td>
<a href="#f_0022.html.sec.testing-parser">测试生成的解析器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0023.html.sec.boilerplate">3.3</a>
</td>
<td>
<a href="#f_0023.html.sec.boilerplate">将生成的解析器集成到 Java 程序中</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0024.html.N10E3D">3.4</a>
</td>
<td>
<a href="#f_0024.html.N10E3D">构建语言应用程序</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0025.html.chp.tour">4.</a>
</td>
<td>
<a href="#f_0025.html.chp.tour">快速浏览</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0026.html.sec.tour-calc">4.1</a>
</td>
<td>
<a href="#f_0026.html.sec.tour-calc">匹配算术表达式语言</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0027.html.sec.calc-visitor">4.2</a>
</td>
<td>
<a href="#f_0027.html.sec.calc-visitor">使用访问者构建计算器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0028.html.sec.tour-java">4.3</a>
</td>
<td>
<a href="#f_0028.html.sec.tour-java">构建带有监听器的翻译器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0029.html.sec.actions-during-parse">4.4</a>
</td>
<td>
<a href="#f_0029.html.sec.actions-during-parse">在解析过程中发生事情</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0030.html.N11BE0">4.5</a>
</td>
<td>
<a href="#f_0030.html.N11BE0">很酷的词汇特征</a>
</td>
</tr>
</tbody>
</table>
<div class="table-of-contents1">
<a href="#f_0031.html.N11E8F">
<strong>II. 使用 ANTLR 语法开发语言应用程序</strong>
</a>
</div>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0032.html.chp.structures">5.</a>
</td>
<td>
<a href="#f_0032.html.chp.structures">设计语法</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0033.html.sec.abstracting-grammars">5.1</a>
</td>
<td>
<a href="#f_0033.html.sec.abstracting-grammars">从语言样本中导出语法</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0034.html.sec.existing-grammars">5.2</a>
</td>
<td>
<a href="#f_0034.html.sec.existing-grammars">使用现有语法作为指导</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0035.html.sec.common-lex-structures">5.3</a>
</td>
<td>
<a href="#f_0035.html.sec.common-lex-structures">使用 ANTLR 语法识别常见语言模式</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0036.html.sec.precedence">5.4</a>
</td>
<td>
<a href="#f_0036.html.sec.precedence">处理优先级、左递归和结合性</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0037.html.sec.lexicalstructures">5.5</a>
</td>
<td>
<a href="#f_0037.html.sec.lexicalstructures">识别常见的词汇结构</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0038.html.sec.lexer_parser_line">5.6</a>
</td>
<td>
<a href="#f_0038.html.sec.lexer_parser_line">词法分析器和解析器之间的界限</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0039.html.chp.examples">6.</a>
</td>
<td>
<a href="#f_0039.html.chp.examples">探索一些真正的语法</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0040.html.sec.CSV">6.1</a>
</td>
<td>
<a href="#f_0040.html.sec.CSV">解析逗号分隔的值</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0041.html.sec.JSON">6.2</a>
</td>
<td>
<a href="#f_0041.html.sec.JSON">解析 JSON</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0042.html.sec.DOT">6.3</a>
</td>
<td>
<a href="#f_0042.html.sec.DOT">解析 DOT</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0043.html.sec.Cymbol">6.4</a>
</td>
<td>
<a href="#f_0043.html.sec.Cymbol">解析 Cymbol</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0044.html.sec.R">6.5</a>
</td>
<td>
<a href="#f_0044.html.sec.R">解析 R</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0045.html.chp.listeners">7.</a>
</td>
<td>
<a href="#f_0045.html.chp.listeners">将语法与特定于应用程序的代码分离</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0046.html.N13C17">7.1</a>
</td>
<td>
<a href="#f_0046.html.N13C17">从嵌入式动作演变为监听器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0047.html.sec.listeners">7.2</a>
</td>
<td>
<a href="#f_0047.html.sec.listeners">使用解析树监听器实现应用程序</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0048.html.N13F4F">7.3</a>
</td>
<td>
<a href="#f_0048.html.N13F4F">实现访问者应用程序</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0049.html.sec.labeling-alts">7.4</a>
</td>
<td>
<a href="#f_0049.html.sec.labeling-alts">精确事件方法的标记规则替代方案</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0050.html.N1427C">7.5</a>
</td>
<td>
<a href="#f_0050.html.N1427C">在事件方法间共享信息</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0051.html.chp.listener-examples">8.</a>
</td>
<td>
<a href="#f_0051.html.chp.listener-examples">构建一些真正的语言应用程序</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0052.html.N14728">8.1</a>
</td>
<td>
<a href="#f_0052.html.N14728">加载 CSV 数据</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0053.html.N149A4">8.2</a>
</td>
<td>
<a href="#f_0053.html.N149A4">将 JSON 转换为 XML</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0054.html.sec.call-graph">8.3</a>
</td>
<td>
<a href="#f_0054.html.sec.call-graph">生成调用图</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0055.html.sec.validating">8.4</a>
</td>
<td>
<a href="#f_0055.html.sec.validating">验证程序符号的使用</a>
</td>
</tr>
</tbody>
</table>
<div class="table-of-contents1">
<a href="#f_0056.html.N1545C">
<strong>III. 高级主题</strong>
</a>
</div>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0057.html.chp.errors">9.</a>
</td>
<td>
<a href="#f_0057.html.chp.errors">错误报告和恢复</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0058.html.sec.parade">9.1</a>
</td>
<td>
<a href="#f_0058.html.sec.parade">错误百出</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0059.html.sec.error-listeners">9.2</a>
</td>
<td>
<a href="#f_0059.html.sec.error-listeners">更改和重定向 ANTLR 错误消息</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0060.html.sec.auto_error">9.3</a>
</td>
<td>
<a href="#f_0060.html.sec.auto_error">自动错误恢复策略</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0061.html.sec.error-alts">9.4</a>
</td>
<td>
<a href="#f_0061.html.sec.error-alts">错误替代方案</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0062.html.sec.error-handling">9.5</a>
</td>
<td>
<a href="#f_0062.html.sec.error-handling">改变 ANTLR 的错误处理策略</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0063.html.chp.actions">10.</a>
</td>
<td>
<a href="#f_0063.html.chp.actions">属性和动作</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0064.html.N164A9">10.1</a>
</td>
<td>
<a href="#f_0064.html.N164A9">使用语法操作构建计算器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0065.html.sec.token-rule-attributes">10.2</a>
</td>
<td>
<a href="#f_0065.html.sec.token-rule-attributes">访问令牌和规则属性</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0066.html.sec.dynamic-keywords">10.3</a>
</td>
<td>
<a href="#f_0066.html.sec.dynamic-keywords">识别关键词不固定的语言</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0067.html.chp.predicates">11.</a>
</td>
<td>
<a href="#f_0067.html.chp.predicates">使用语义谓词改变解析</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0068.html.N16D65">11.1</a>
</td>
<td>
<a href="#f_0068.html.N16D65">识别多种语言方言</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0069.html.N16FD4">11.2</a>
</td>
<td>
<a href="#f_0069.html.N16FD4">停用代币</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0070.html.sec.recog-ambig-phrases">11.3</a>
</td>
<td>
<a href="#f_0070.html.sec.recog-ambig-phrases">识别歧义短语</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0071.html.chp.lexmagic">12.</a>
</td>
<td>
<a href="#f_0071.html.chp.lexmagic">运用词汇黑魔法</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0072.html.sec.token-channels">12.1</a>
</td>
<td>
<a href="#f_0072.html.sec.token-channels">在不同频道上广播代币</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0073.html.sec.context-sensitive-lexers">12.2</a>
</td>
<td>
<a href="#f_0073.html.sec.context-sensitive-lexers">语境相关词汇问题</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0074.html.sec.islands">12.3</a>
</td>
<td>
<a href="#f_0074.html.sec.islands">海流中的岛屿</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0075.html.sec.XML">12.4</a>
</td>
<td>
<a href="#f_0075.html.sec.XML">XML 解析和词法分析</a>
</td>
</tr>
</tbody>
</table>
<div class="table-of-contents1">
<a href="#f_0076.html.N184B1">
<strong>IV. ANTLR 参考</strong>
</a>
</div>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0077.html.chp.api">13.</a>
</td>
<td>
<a href="#f_0077.html.chp.api">探索运行时 API</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0078.html.N184CA">13.1</a>
</td>
<td>
<a href="#f_0078.html.N184CA">库软件包概述</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0079.html.N18587">13.2</a>
</td>
<td>
<a href="#f_0079.html.N18587">识别器</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0080.html.N18740">13.3</a>
</td>
<td>
<a href="#f_0080.html.N18740">字符和标记的输入流</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0081.html.N187CA">13.4</a>
</td>
<td>
<a href="#f_0081.html.N187CA">代币和代币工厂</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0082.html.N189C3">13.5</a>
</td>
<td>
<a href="#f_0082.html.N189C3">解析树</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0083.html.N18A0D">13.6</a>
</td>
<td>
<a href="#f_0083.html.N18A0D">错误监听器和策略</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0084.html.sec.maximizing-speed">13.7</a>
</td>
<td>
<a href="#f_0084.html.sec.maximizing-speed">最大化解析器速度</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0085.html.N18AE9">13.8</a>
</td>
<td>
<a href="#f_0085.html.N18AE9">无缓冲字符和标记流</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0086.html.N18CA4">13.9</a>
</td>
<td>
<a href="#f_0086.html.N18CA4">改变 ANTLR 的代码生成</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0087.html.chp.left-recursion-removal">14.</a>
</td>
<td>
<a href="#f_0087.html.chp.left-recursion-removal">删除直接左递归</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0088.html.N18D7D">14.1</a>
</td>
<td>
<a href="#f_0088.html.N18D7D">直接左递归替代模式</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0089.html.N18F22">14.2</a>
</td>
<td>
<a href="#f_0089.html.N18F22">左递归规则变换</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td valign="top">
<a href="#f_0090.html.chp.ref">15.</a>
</td>
<td>
<a href="#f_0090.html.chp.ref">语法参考</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0091.html.sec.lexicon">15.1</a>
</td>
<td>
<a href="#f_0091.html.sec.lexicon">语法词典</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0092.html.N19325">15.2</a>
</td>
<td>
<a href="#f_0092.html.N19325">语法结构</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0093.html.sec.parsers">15.3</a>
</td>
<td>
<a href="#f_0093.html.sec.parsers">解析器规则</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0094.html.sec.actions">15.4</a>
</td>
<td>
<a href="#f_0094.html.sec.actions">动作和属性</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0095.html.sec.lexers">15.5</a>
</td>
<td>
<a href="#f_0095.html.sec.lexers">词法分析器规则</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0096.html.sec.nongreedy">15.6</a>
</td>
<td>
<a href="#f_0096.html.sec.nongreedy">通配符运算符和非贪婪子规则</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0097.html.sec.pred-fine-print">15.7</a>
</td>
<td>
<a href="#f_0097.html.sec.pred-fine-print">语义谓词</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0098.html.sec.options">15.8</a>
</td>
<td>
<a href="#f_0098.html.sec.options">选项</a>
</td>
</tr>
</tbody>
</table>
<table class="table-of-contents2">
<colgroup><col width="1em">
<col width="1em">
<col width="2em">
</colgroup><tbody>
<tr>
<td> </td>
<td> </td>
<td valign="top">
<a href="#f_0099.html.sec.tool-options">15.9</a>
</td>
<td>
<a href="#f_0099.html.sec.tool-options">ANTLR 工具命令行选项</a>
</td>
</tr>
</tbody>
</table>
<table width="100%" class="table-of-contents2">
<colgroup><col width="2em">
</colgroup><tbody>
<tr>
<td valign="top">
<a href="#f_0100.html.N1B3B3">A1。</a>
</td>
<td>
<a href="#f_0100.html.N1B3B3">参考书目</a>
</td>
</tr>
</tbody>
</table>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>

</div></div>
<div id="f_0003.html"><div>

<h1><span class="emph">对权威 ANTLR 4 参考</span>
    的早期赞誉<span class="emph"></span>
</h1><h1>
    Early Praise for <span class="emph">The Definitive ANTLR 4 Reference</span>
</h1>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N1003A">
			Parr 清晰的文笔和轻松的风格使学习构建语言处理器的实际细节成为一种乐趣。
	      </p><p>
			Parr’s clear writing and lighthearted style make it a pleasure to
			learn the practical details of building language processors.
	      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>丹·伯恩斯坦</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Android Dalvik VM 的设计者</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N10044">
			ANTLR 是一种非常强大且灵活的形式语言解析工具。在 Twitter，我们专门使用它来解析搜索引擎中的查询。我们的语法简洁明了，生成的代码高效稳定。这本书是我们关于 ANTLR v4 的首选参考书 — 引人入胜的写作、清晰的描述和实用示例一应俱全。
	      </p><p>
			ANTLR is an exceptionally powerful and flexible tool for parsing formal languages. At Twitter, we use it exclusively for query parsing in our search engine. Our grammars are clean and concise, and the generated code is efficient and stable. This book is our go-to reference for ANTLR v4—engaging writing, clear descriptions, and practical examples all in one place.
	      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>塞缪尔·卢肯比尔</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Twitter 公司搜索基础设施高级经理</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N10050">
			ANTLR v4 确实让解析变得简单，而这本书让解析变得更加简单。它解释了解析过程的每个步骤，从设计语法到利用输出。
	      </p><p>
			ANTLR v4 really makes parsing easy, and this book makes it even easier.  It explains every step of the process, from designing the grammar to making use of the output.
	      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>尼科·松崎</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Rust 语言的核心贡献者和 Mozilla Research 的研究员</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N1005A">
			我真希望四年前我开始在 NetBeans IDE 和 Sun Studio IDE 中研究 C++ 语法时能有 ANTLR 4 和这本书。内容很棒，可读性很强。
	      </p><p>
			I sure wish I had ANTLR 4 and this book four years ago when I started to work on a C++ grammar in the NetBeans IDE and the Sun Studio IDE. Excellent content and very readable.
	      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>尼古拉·克拉西尔尼科夫</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Oracle 公司高级软件工程师</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N10066">
	这本书是充分利用 ANTLR 的必备书籍。每当我编辑语法时，我都会经常参考它。
      </p><p>
	This book is an absolute requirement for getting the most out of ANTLR. I refer to it constantly whenever I’m editing a grammar.
      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>里奇·昂格</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Salesforce.com Apex Code 团队主要技术人员</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N10072">
	我已经使用 ANTLR 创建语言六年了，新 v4 绝对棒极了。最好的消息是 Terence 写了这本很棒的书来配合该软件。它会让新手和专家都满意。如果您处理数据或实现语言，请帮自己一个忙，买本书！
      </p><p>
	I have been using ANTLR to create languages for six years now, and the new v4 is absolutely wonderful.  The best news is that Terence has written this fantastic book to accompany the software. It will please newbies and experts alike. If you process data or implement languages, do yourself a favor and buy this book!
      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>拉胡尔吉德瓦尼</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">Xoom Corp. 高级软件工程师</td>
</tr>
</tbody></table>
</div>
<div style="margin-bottom:9px;margin-top:9px">
<div class="praise">
<p id="f_0003.html.N1007E">
	从未如此简单地解释过解析的复杂性。本书对 ANTLR v4 软件进行了精彩的深入介绍，从安装到高级用法都有清晰的解释。书中有大量真实示例，例如 JSON 和 R，使本书成为任何 ANTLR 用户的必读书籍。
      </p><p>
	Never have the complexities surrounding parsing been so simply explained. This book provides brilliant insight into the ANTLR v4 software, with clear explanations from installation to advanced usage. An array of real-life examples, such as JSON and R, make this book a must-have for any ANTLR user.
      </p>
</div>
<table class="praise">
<colgroup><col align="left">
<col align="left">
</colgroup><tbody><tr>
<td style="width:5%">→</td>
<td>戴维·摩根</td>
</tr>
<tr class="praise">
<td class="praise">
</td>
<td class="praise">思克莱德大学计算机与电子系统专业学生</td>
</tr>
</tbody></table>
</div>



</div></div>
<div id="f_0004.html"><div>

<h1 class="chapter-title" id="f_0004.html.N10089">
<span class="chapter-number"></span>
<br><br>
<span class="chapter-name">致谢</span>
</h1><h1 class="chapter-title">
<span class="chapter-number"></span>
<br><br>
<span class="chapter-name">Acknowledgments</span>
</h1>

<p id="f_0004.html.N10090">
我开始研究 ANTLR 已经大约 25 年了。在此期间，许多人帮助塑造了该工具的语法和功能，对此我深表感谢。对于 ANTLR 版本 4 来说，最重要的是 Sam Harwell <a id="f_0004.html.FNPTR-1" href="#f_0004.html.FOOTNOTE-1">[1]</a>是我的合著者。他帮助编写了该软件，也为 Adaptive <span class="emph">LL(*)</span>语法分析算法做出了重要贡献。Sam 还在构建 ANTLRWorks2 语法 IDE。
</p><p>
It’s been roughly 25 years since I started working on ANTLR. In that time, many people have
helped shape the tool syntax and functionality, for which I’m most grateful. Most
importantly for ANTLR version 4, Sam
Harwell<a href="#f_0004.html.FOOTNOTE-1">[1]</a> was my
coauthor. He helped write the software but also made critical contributions to the
Adaptive <span class="emph">LL(*)</span> grammar analysis algorithm. Sam is also building the ANTLRWorks2
grammar IDE.
</p>
<p id="f_0004.html.N1009C">
    以下人员提供了技术评论：Oliver Ziegermann、Sam Rose、Kyle Ferrio、Maik Schmidt、Colin Yates、Ian Dees、Tim Ottinger、Kevin Gisi、Charley Stran、Jerry Kuch、Aaron Kalair、Michael Bevilacqua-Linn、Javier Collado、Stephen Wolff 和 Bernard Kaiflin。我也很感谢那些报告本书和 v4 软件测试版错误的人。Kim Shrier 和 Graham Wideman 值得特别关注，因为他们提供了如此详细的评论。Graham 的技术评论非常详尽、篇幅长、范围广，以至于我不知道是应该和他握手还是去买一把手枪。
  </p><p>
    The following people provided technical reviews: Oliver Ziegermann, Sam Rose, Kyle
    Ferrio, Maik Schmidt, Colin Yates, Ian Dees, Tim Ottinger, Kevin Gisi, Charley Stran,
    Jerry Kuch, Aaron Kalair, Michael Bevilacqua-Linn, Javier Collado, Stephen Wolff, and
    Bernard Kaiflin. I also appreciate those people who reported errors in beta versions of
    the book and v4 software. Kim Shrier and Graham Wideman deserve special attention
    because they provided such detailed reviews. Graham’s technical reviews were so
    elaborate, voluminous, and extensive that I wasn’t sure whether to shake his hand
    vigorously or go buy a handgun.
  </p>
<p id="f_0004.html.N1009F">
最后，我要感谢 Pragmatic Bookshelf 的编辑 Susannah Davidson Pfalzer，她陪我读了三本书！她的建议和精心的编辑确实让这本书更加完美。
</p><p>
Finally, I’d like to thank Pragmatic Bookshelf editor Susannah Davidson Pfalzer, who has stuck with me through three books! Her suggestions and careful editing really improved this book.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0004.html.FOOTNOTE-1" href="#f_0004.html.FNPTR-1">[1]</a>
</td>
<td>
<p id="f_0004.html.N10094">
<a href="http://tunnelvisionlabs.com/">http://tunnelvisionlabs.com</a>
</p><p>
<a href="http://tunnelvisionlabs.com">http://tunnelvisionlabs.com</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0005.html"><div>

<h1 class="chapter-title" id="f_0005.html.N100A6">
<span class="chapter-number"></span>
<br><br>
<span class="chapter-name">欢迎加入！</span>
</h1><h1 class="chapter-title">
<span class="chapter-number"></span>
<br><br>
<span class="chapter-name">Welcome Aboard!</span>
</h1>

<p id="f_0005.html.N100AD">
ANTLR v4 是一个功能强大的解析器生成器，可用于读取、处理、执行或翻译结构化文本或二进制文件。它在学术界和工业界被广泛用于构建各种语言、工具和框架。Twitter 搜索使用 ANTLR 进行查询解析，每天有超过 20 亿条查询。Hive 和 Pig 的语言以及 Hadoop 的数据仓库和分析系统都使用 ANTLR。Lex Machina <a id="f_0005.html.FNPTR-2" href="#f_0009.html.FOOTNOTE-2">[2]</a>使用 ANTLR 从法律文本中提取信息。Oracle 在 SQL Developer IDE 及其迁移工具中使用 ANTLR。NetBeans IDE 使用 ANTLR 解析 C++。Hibernate 对象关系映射框架中的 HQL 语言是使用 ANTLR 构建的。
</p><p>
ANTLR v4 is a powerful parser generator that you can use to read, process, execute, or
translate structured text or binary files. It’s widely used in academia and industry to
build all sorts of languages, tools, and frameworks. Twitter search uses ANTLR for query
parsing, with more than 2 billion queries a day. The languages for Hive and Pig and the data
warehouse and analysis systems for Hadoop all use ANTLR. Lex
Machina<a href="#f_0009.html.FOOTNOTE-2">[2]</a> uses ANTLR for
information extraction from legal texts. Oracle uses ANTLR within the SQL Developer IDE and
its migration tools. The NetBeans IDE parses C++ with ANTLR. The HQL language in the Hibernate
object-relational mapping framework is built with ANTLR.
</p>
<p id="f_0005.html.N100B6">
除了这些知名、备受关注的项目之外，您还可以构建各种有用的工具，例如配置文件读取器、旧代码转换器、wiki 标记渲染器和 JSON 解析器。我构建了一些小工具，用于创建对象关系数据库映射、描述 3D 可视化以及将分析代码注入 Java 源代码，我甚至还为讲座做了一个简单的 DNA 模式匹配示例。
</p><p>
Aside from these big-name, high-profile projects, you can build all sorts of useful tools such as configuration file readers, legacy code converters, wiki markup renderers, and JSON parsers. I’ve built little tools for creating object-relational database mappings, describing 3D  visualizations, and injecting profiling code into Java source code, and I’ve even done a simple DNA pattern matching example for a lecture.
</p>
<p id="f_0005.html.N100B9">
ANTLR根据一种正式的语言描述（称为<span class="emph">语法）</span>生成该语言的解析器，该解析器可以自动构建解析树，解析树是表示语法如何与输入匹配的数据结构。ANTLR 还会自动生成树遍历器，您可以使用它来访问这些树的节点以执行特定于应用程序的代码。
</p><p>
From a formal language description called a <span class="emph">grammar</span>, ANTLR generates a parser for that
language that can automatically build parse trees, which are data structures representing
how a grammar matches the input. ANTLR also automatically generates tree walkers that you
can use to visit the nodes of those trees to execute application-specific code.
</p>
<p id="f_0005.html.N100BF">
本书既是 ANTLR v4 的参考书，也是使用它解决语言识别问题的指南。您将学习如何执行以下操作：
</p><p>
This book is both a reference for ANTLR v4 and a guide to using it to solve language recognition problems.  You’re going to learn how to do the following:
</p>
<ul>
<li>
<p id="f_0005.html.N100C5">
	在语言样本和参考手册中识别语法模式以构建自己的语法。
	</p>
</li><li>
<p>
	Identify grammar patterns in language samples and reference manuals in order to build your
own grammars.
	</p>
</li>
<li>
<p id="f_0005.html.N100C9">
     为 JSON 等简单语言一直到 R 等复杂编程语言构建语法。您还将解决 Python 和 XML 中的一些棘手的识别问题。
  </p>
</li><li>
<p>
     Build grammars for simple languages like JSON all the way up to complex programming languages like R.  You’ll also solve some tricky recognition problems from Python and XML.
  </p>
</li>
<li>
<p id="f_0005.html.N100CD">
    通过遍历自动生成的解析树，基于这些语法实现语言应用程序。
  </p>
</li><li>
<p>
    Implement language applications based upon those grammars by walking the
   automatically generated parse trees.
  </p>
</li>
<li>
<p id="f_0005.html.N100D1">
   针对特定应用领域定制识别错误处理和错误报告。
  </p>
</li><li>
<p>
   Customize recognition error handling and error reporting for specific application
   domains.
  </p>
</li>
<li>
<p id="f_0005.html.N100D5">
   通过将 Java 操作嵌入到语法中来完全控制解析。
  </p>
</li><li>
<p>
   Take absolute control over parsing by embedding Java actions into a grammar.
  </p>
</li>
</ul>
<p id="f_0005.html.N100D8">
与教科书不同的是，讨论以示例为导向，以使内容更加具体，并为构建自己的语言应用程序提供入门工具包。
</p><p>
Unlike a textbook, the discussions are example-driven in order to make things more concrete
and to provide starter kits for building your own language applications.
</p>

</div></div>
<div id="f_0006.html"><div>

<h2 id="f_0006.html.N100DB">这本书适合哪些人阅读？</h2><h2>Who Is This Book For?</h2>
<p id="f_0006.html.N100DF">
本书专门针对有兴趣学习如何构建数据读取器、语言解释器和翻译器的程序员。本书当然是专门介绍如何使用 ANTLR 构建东西的，但您将学到很多有关词法分析器和解析器的知识。初学者和专家都需要这本书来有效地使用 ANTLR v4。要理解第三部分中的高级主题，您需要通过前面的章节积累一些 ANTLR 经验。读者应该了解 Java，以便从本书中获得最大收获。
</p><p>
This book is specifically targeted at any programmer interested in learning how to build
data readers, language interpreters, and translators. This book is about how to build things
with ANTLR specifically, of course, but you’ll learn a lot about lexers and parsers in
general. Beginners and experts alike will need this book to use ANTLR v4 effectively. To get
your head around the advanced topics in Part III, you’ll need some experience with ANTLR by
working through the earlier chapters. Readers should know Java to get the most out of the
book.
</p>
<div class="sidebar" id="f_0006.html.sb.honeyBadgerRelease">
<div class="sidebar-title">蜜獾释放</div>
<div class="sidebar-content">
<p id="f_0006.html.N100E7">
ANTLR v4 被命名为“Honey Badger” 版本，以纪念 YouTube 轰动一时的大无畏英雄<span class="emph">The Crazy Nastyass Honey Badger </span><a id="f_0006.html.FNPTR-3" href="#f_0009.html.FOOTNOTE-3">[3]</a>。
它接受你给它的任何语法；它根本不在乎！
</p><p>
ANTLR v4 is named the “Honey Badger” release after the fearless hero of the YouTube
sensation <span class="emph">The Crazy Nastyass Honey
Badger</span>.<a href="#f_0009.html.FOOTNOTE-3">[3]</a>
It takes whatever grammar you give it; it doesn’t give a damn!
</p>
</div>
</div>

</div></div>
<div id="f_0007.html"><div>

<h2 id="f_0007.html.N100F3">ANTLR V4 有什么特别之处？</h2><h2>What’s So Cool About ANTLR V4?</h2>
<p id="f_0007.html.N100F7">
ANTLR 的 v4 版本具有一些重要的新功能，可以缩短学习曲线，使语法和语言应用程序的开发变得更加容易。最重要的新功能是 ANTLR v4 很乐意接受您提供的每个语法（关于间接左递归的一个例外，稍后会介绍）。当 ANTLR 将您的语法转换为可执行的、人类可读的解析代码时，不会出现语法冲突或歧义警告。如果您为 ANTLR 生成的解析器提供有效输入，则无论语法多么复杂，解析器都将始终正确识别输入。当然，您需要确保语法准确地描述相关语言。
	</p><p>
The v4 release of ANTLR has some important new capabilities that reduce the learning curve
and make developing grammars and language applications much easier. The most important new
feature is that ANTLR v4 gladly accepts every grammar you give it (with one exception
regarding indirect left recursion, described shortly). There are no grammar conflict or
ambiguity warnings as ANTLR translates your grammar to executable, human-readable parsing
code. If you give your ANTLR-generated parser valid input, the parser will always recognize
the input properly, no matter how complicated the grammar. Of course, it’s up to you to make
sure the grammar accurately describes the language in question.
	</p>
<p id="f_0007.html.N100FA">
	ANTLR 解析器使用一种新的解析技术，称为<span class="firstuseinline">Adaptive LL(*)</span>或<span class="firstuseinline">ALL(*)</span>（“全明星”），是我与 Sam Harwell 共同开发的。<a id="f_0007.html.FNPTR-4" href="#f_0009.html.FOOTNOTE-4">[4] </a>
<span class="emph">ALL(*)是 v3 的</span><span class="emph">LL(*)</span>的扩展，它在运行时动态执行语法分析，而不是在生成的解析器执行之前静态执行语法分析。由于<span class="emph">ALL(*)</span>解析器可以访问实际的输入序列，因此它们始终可以通过适当地编织语法来找出如何识别序列。另一方面，静态分析必须考虑所有可能的（无限长的）输入序列。
	</p><p>
	ANTLR parsers use a new parsing technology called <span class="firstuseinline">Adaptive
LL(*)</span> or <span class="firstuseinline">ALL(*)</span> (“all star”) that I developed with Sam
Harwell.<a href="#f_0009.html.FOOTNOTE-4">[4]</a>
<span class="emph">ALL(*)</span> is an extension to v3’s <span class="emph">LL(*)</span> that performs grammar
analysis dynamically at runtime rather than statically, before the generated parser
executes. Because <span class="emph">ALL(*)</span> parsers have access to actual input sequences, they
can always figure out how to recognize the sequences by appropriately weaving through the
grammar. Static analysis, on the other hand, has to consider all possible (infinitely long)
input sequences.
	</p>
<p id="f_0007.html.N10118">
	实际上，有了<span class="emph">ALL(*)</span>意味着您不必像使用大多数其他解析器生成器工具（包括 ANTLR v3）那样扭曲语法以适应底层解析策略。如果您曾因 ANTLR v3 中的歧义警告或 中的减少/减少冲突而抓狂<code class="cf commandname">yacc</code>，那么 ANTLR v4 就是您的不二之选！
	</p><p>
	In practice, having <span class="emph">ALL(*)</span> means you don’t have to contort your grammars to
fit the underlying parsing strategy as you would with most other parser generator tools,
including ANTLR v3. If you’ve ever pulled your hair out because of an ambiguity warning in
ANTLR v3 or a reduce/reduce conflict in <code class="cf commandname">yacc</code>, ANTLR v4 is for
you!
	</p>
<p id="f_0007.html.N10121">
下一个很棒的新功能是 ANTLR v4 大大简化了用于匹配语法结构（如编程语言算术表达式）的语法规则。使用 ANTLR 语法指定表达式一直很麻烦（使用递归下降解析器手动识别表达式也很难）。识别表达式的最自然语法对于传统的自上而下的解析器生成器（如 ANTLR v3）无效。现在，使用 v4，您可以使用如下所示的规则匹配表达式：
  </p><p>
The next awesome new feature is that ANTLR v4 dramatically simplifies the grammar rules used
to match syntactic structures like programming language arithmetic expressions. Expressions
have always been a hassle to specify with ANTLR grammars (and to recognize by hand with
recursive-descent parsers). The most natural grammar to recognize expressions is invalid for
traditional top-down parser generators like ANTLR v3. Now, with v4, you can match
expressions with rules that look like this:
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expr <em class="string">'*'</em> expr  <em class="comment">// match subexpressions joined with '*' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'+'</em> expr  <em class="comment">// match subexpressions joined with '+' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | INT            <em class="comment">// matches simple integer atom</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0007.html.N10145">
诸如此类的自引用规则<code class="cf keyword">expr</code>是递归的，特别是
<span class="firstuseinline">左递归的</span>，因为至少它的一个替代方案直接引用其自身。
</p><p>
Self-referential rules like <code class="cf keyword">expr</code> are recursive and, in particular,
<span class="firstuseinline">left recursive</span> because at least one of its alternatives immediately
refers to itself.
</p>
<p id="f_0007.html.N1014E">
ANTLR v4 会自动将左递归规则重写为非<code class="cf keyword">expr</code>左递归等价规则。唯一的限制是左递归必须是直接的，规则会直接引用自身。规则不能引用替代规则左侧的另一条规则，而该规则最终会返回引用原始规则，而无需匹配标记。有关更多详细信息，请参阅第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em></a>。
</p><p>
ANTLR v4 automatically rewrites left-recursive rules such as <code class="cf keyword">expr</code> into
non-left-recursive equivalents. The only constraint is that the left recursion must be
direct, where rules immediately reference themselves. Rules cannot reference another rule
on the left side of an alternative that eventually comes back to reference the original
rule without matching a token. See Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a> for more details.
</p>
<p id="f_0007.html.N10157">
除了这两项与语法相关的改进之外，ANTLR v4 还使语言应用程序的构建变得更加容易。ANTLR 生成的解析器会自动构建输入的便捷表示，即<span class="firstuseinline">解析树</span>，应用程序可以在遇到感兴趣的构造时遍历解析树以触发代码片段。以前，v3 用户必须使用树构造操作来扩充语法。除了自动构建树之外，ANTLR v4 还会以
<span class="firstuseinline">侦听器</span>和<span class="firstuseinline">访问者模式</span>实现的形式自动生成解析树遍历器。侦听器类似于 XML 文档处理程序对象，它们响应由 XML 解析器触发的 SAX 事件。
  </p><p>
In addition to those two grammar-related improvements, ANTLR v4 makes it much easier to
build language applications. ANTLR-generated parsers automatically build convenient
representations of the input called <span class="firstuseinline">parse trees</span> that an application can
walk to trigger code snippets as it encounters constructs of interest. Previously, v3 users
had to augment the grammar with tree construction operations. In addition to building trees
automatically, ANTLR v4 also automatically generates parse-tree walkers in the form of
<span class="firstuseinline">listener</span> and <span class="firstuseinline">visitor pattern</span> implementations.
Listeners are analogous to XML document handler objects that respond to SAX events triggered
by XML parsers.
  </p>
<p id="f_0007.html.N10163">
ANTLR v4 更容易学习，因为它不仅具有这些出色的新功能，而且还没有继承 v3 中的一些功能。
</p><p>
ANTLR v4 is much easier to learn because of those awesome new features but also because of
what it does not carry forward from v3.
</p>
<ul>
<li>
<p id="f_0007.html.N10169">
最大的变化是 v4 不再强调在语法中嵌入操作（代码），而是更倾向于监听器和访问者。新机制将语法与应用程序代码分离，很好地封装了应用程序，而不是将其拆分并分散到语法中。即使没有嵌入操作，您也可以在不同的应用程序中重用相同的语法，甚至无需重新编译生成的解析器。ANTLR 仍然允许嵌入操作，但在 v4 中这样做被认为是先进的。此类操作提供了最高级别的控制，但代价是失去语法重用。
</p>
</li><li>
<p>
The biggest change is that v4 deemphasizes embedding actions (code) in the grammar, favoring
listeners and visitors instead. The new mechanisms decouple grammars from application code,
nicely encapsulating an application instead of fracturing it and dispersing the pieces
across a grammar. Without embedded actions, you can also reuse the same grammar in different
applications without even recompiling the generated parser. ANTLR still allows embedded
actions, but doing so is considered advanced in v4. Such actions give the highest level of
control but at the cost of losing grammar reuse.
</p>
</li>
<li>
<p id="f_0007.html.N1016D">
由于 ANTLR 会自动生成解析树和树遍历器，因此您无需在 v4 中构建树语法。您可以使用熟悉的设计模式（如访问者）。这意味着，一旦您学会了 ANTLR 语法，您就可以回到 Java 编程语言这个舒适而熟悉的领域来实现实际的语言应用程序。
</p>
</li><li>
<p>
Because ANTLR automatically generates parse trees and tree walkers, there’s no need for you
to build tree grammars in v4. You get to use familiar design patterns like the visitor
instead. This means that once you’ve learned ANTLR grammar syntax, you get to move back
into the comfortable and familiar realm of the Java programming language to implement the
actual language application.
</p>
</li>
<li>
<p id="f_0007.html.N10171">
ANTLR v3 的<span class="emph">LL(*)解析策略比 v4 的</span><span class="emph">ALL(*)</span>弱，因此 v3 有时依赖回溯来正确解析输入短语。回溯使得通过逐步执行生成的解析器来调试语法变得困难，因为解析器可能会多次（递归）解析相同的输入。回溯还会使解析器更难在输入无效时给出良好的错误消息。
</p>
</li><li>
<p>
ANTLR v3’s <span class="emph">LL(*)</span> parsing strategy is weaker than v4’s <span class="emph">ALL(*)</span>,
so v3 sometimes relied on backtracking to properly parse input phrases. Backtracking makes
it hard to debug a grammar by stepping through the generated parser because the parser
might parse the same input multiple times (recursively). Backtracking can also make it
harder for the parser to give a good error message upon invalid input.
</p>
</li>
</ul>
<p id="f_0007.html.N10184">
ANTLR v4 是我在研究生院走过的一个小弯路（二十五年）的成果。我想我得稍微改变一下我的座右铭了。
</p><p>
ANTLR v4 is the result of a minor detour (twenty-five years) I took in graduate school. I guess I’m
going to have to change my motto slightly.
</p>
<blockquote>
<p id="f_0007.html.N10188">
为什么要花五天时间手动编写程序来实现你可以花费<span class="emph">二十五年</span>时间实现的自动化呢？
</p>
</blockquote><blockquote>
<p>
Why program by hand in five days what you can spend <span class="emph">twenty-five</span> years of your life automating?
</p>
</blockquote>
<p id="f_0007.html.N1018E">
ANTLR v4 正是我想要的解析器生成器，所以我终于可以回到我最初在 1980 年代试图解决的问题了。现在，如果我能记得那是什么就好了。
</p><p>
ANTLR v4 is exactly what I want in a parser generator, so I can finally get back to the
problem I was originally trying to solve in the 1980s. Now, if I could just remember what that
was.
</p>

</div></div>
<div id="f_0008.html"><div>

<h2 id="f_0008.html.N10191">这本书里有什么？</h2><h2>What’s in This Book?</h2>
<p id="f_0008.html.N10195">
本书是您在任何地方都能找到的有关 ANTLR v4 的最佳、最完整的信息来源。免费的在线文档提供了足够的信息来学习基本的语法和语义，但没有详细解释 ANTLR 概念。只有这本书解释了如何识别语言中的语法模式以及如何将它们表达为 ANTLR 语法。贯穿全文的示例为您提供了开始构建自己的语言应用程序所需的基础。本书可帮助您充分利用 ANTLR，是成为高级用户的必读书籍。
</p><p>
This book is the best, most complete source of information on ANTLR v4 that you’ll find
anywhere. The free, online documentation provides enough to learn the basic grammar syntax
and semantics but doesn’t explain ANTLR concepts in detail. Only this book explains how to
identify grammar patterns in languages and how to express them as ANTLR grammars. The
examples woven throughout the text give you the leg up you need to start building your own
language applications. This book helps you get the most out of ANTLR and is required reading
to become an advanced user.
</p>
<p id="f_0008.html.N10198">
本书分为四个部分。
</p><p>
This book is organized into four parts.
</p>
<ul>
<li>
<p id="f_0008.html.N1019E">
第一部分介绍了 ANTLR，提供了一些语言背景知识，并带您了解 ANTLR 的功能。您将了解语法以及可以使用它做什么。
</p>
</li><li>
<p>
Part I introduces ANTLR, provides some background knowledge about languages, and gives you
a tour of ANTLR’s capabilities. You’ll get a taste of the syntax and what you can do with
it.
</p>
</li>
<li>
<p id="f_0008.html.N101A2">
第二部分是关于设计语法以及使用这些语法和树遍历器构建语言应用程序。 
</p>
</li><li>
<p>
Part II is all about designing grammars and building language applications using those
grammars in combination with tree walkers. 
</p>
</li>
<li>
<p id="f_0008.html.N101A6">
第三部分首先向您展示如何自定义 ANTLR 生成的解析器的错误处理。接下来，您将学习如何在语法中嵌入操作，因为有时这样做比构建树并遍历它更简单或更有效。与操作相关，您还将学习如何使用<span class="firstuseinline">语义谓词</span>来改变解析器的行为以处理一些具有挑战性的识别问题。</p>
<p id="f_0008.html.N101AC">最后一章解决了一些具有挑战性的语言识别问题，例如识别 XML 和 Python 中的上下文敏感的换行符。
</p>
</li><li>
<p>
Part III starts out by showing you how to customize the error handling of ANTLR-generated
parsers. Next, you’ll learn how to embed actions in the grammar because sometimes it’s
simpler or more efficient to do so than building a tree and walking it. Related to
actions, you’ll also learn how to use <span class="firstuseinline">semantic predicates</span> to alter the
behavior of the parser to handle some challenging recognition problems. </p>
<p>The final chapter
solves some challenging language recognition problems, such as recognizing XML and
context-sensitive newlines in Python.
</p>
</li>
<li>
<p id="f_0008.html.N101B0">
第 IV 部分是参考部分，列出了使用 ANTLR 语法元语言及其运行时库的所有规则。
</p>
</li><li>
<p>
Part IV is the reference section and lays out all of the rules for using the ANTLR grammar
meta-language and its runtime library.
</p>
</li>
</ul>
<p id="f_0008.html.N101B3"><a href="#f_0011.html.chp.antlr">对于语法和语言工具完全陌生的读者，绝对应该从阅读第 1 章“认识<em>ANTLR”</em>和</a>第 2 章<a href="#f_0014.html.chp.bigpic"><em>“</em></a><a href="#f_0014.html.chp.bigpic">概述<em></em></a>
开始<a href="#f_0014.html.chp.bigpic">。</a>经验丰富的 ANTLR v3 用户可以直接跳到第 4 章“<a href="#f_0025.html.chp.tour">快速<em>浏览”</em> ，以</a>了解有关 v4 新功能的更多信息。
</p><p>
Readers who are totally new to grammars and language tools should definitely start by
reading Chapter 1, <a href="#f_0011.html.chp.antlr">​<em>Meet ANTLR</em>​</a> and Chapter 2, <a href="#f_0014.html.chp.bigpic">​<em>The Big Picture</em>​</a>. Experienced
ANTLR v3 users can jump directly to Chapter 4, <a href="#f_0025.html.chp.tour">​<em>A Quick Tour</em>​</a> to learn more about
v4’s new capabilities.
</p>
<p id="f_0008.html.N101BF">
本书所有示例的源代码均可在线获取。如果您以电子方式阅读本书，可以单击源代码上方的框，它将在浏览器窗口中显示代码。如果您正在阅读本书的纸质版或只是想要完整的代码包，则可以在本书的网站上获取。<a id="f_0008.html.FNPTR-5" href="#f_0009.html.FOOTNOTE-5">[5]</a>
为了集中讨论的关键元素，书中展示的大多数代码片段都是部分的。下载内容显示完整的源代码。
</p><p>
The source code for all examples in this book is available online. For those of you reading
this electronically, you can click the box above the source code, and it will
display the code in a browser window. If you’re reading the paper version of this book or
would simply like a complete bundle of the code, you can grab it at the book
website.<a href="#f_0009.html.FOOTNOTE-5">[5]</a>
To focus on the key elements being discussed, most of the code snippets shown in
the book itself are partial. The downloads show the full source.
</p>
<p id="f_0008.html.N101C8">
还请注意，所有文件顶部都有版权声明作为注释，这会弄乱示例输入文件。在将文件（例如
代码子目录<code class="cf filename">t.properties</code>中的<code class="cf dir">listeners</code>文件）用作本书所述解析器的输入之前，请先删除其中的版权声明。电子版的读者也可以从不显示版权声明的书中剪切和粘贴，如下所示：
</p><p>
Also be aware that all files have a copyright notice as a comment at the top, which kind of
messes up the sample input files. Please remove the copyright notice from files, such as
<code class="cf filename">t.properties</code> in the <code class="cf dir">listeners</code> code subdirectory, before
using them as input to the parsers described in this book. Readers of the electronic
version can also cut and paste from the book, which does not display the copyright notice,
as shown here:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/t.properties">听众/t.properties</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​user="parrt"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​machine="maniac"​</code></div>
</td>
</tr>
</tbody></table>

</div></div>
<div id="f_0009.html"><div>

<h2 id="f_0009.html.N101E1">在线了解有关 ANTLR 的更多信息</h2><h2>Learning More About ANTLR Online</h2>
<p id="f_0009.html.N101E5">
在<a href="http://www.antlr.org/">http://www.antlr.org</a>网站上，您可以找到 ANTLR 下载、ANTLRWorks2 图形用户界面 (GUI) 开发环境、文档、预建语法、示例、文章和文件共享区。技术支持邮件列表<a id="f_0009.html.FNPTR-6" href="#f_0009.html.FOOTNOTE-6">[6]</a>
是一个对新手友好的公共 Google 群组。
</p><p>
At the <a href="http://www.antlr.org">http://www.antlr.org</a> website, you’ll find the ANTLR download, the
ANTLRWorks2 graphical user interface (GUI) development environment, documentation, prebuilt
grammars, examples, articles, and a file-sharing area. 
 The tech support mailing
list<a href="#f_0009.html.FOOTNOTE-6">[6]</a>
is a newbie-friendly public Google group.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/jpg;base64,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" alt="图片/parrt.jpg">
</div>
<div>
</div>
<div class="prefacesignoff">特伦斯·帕尔</div>
<div class="prefacesignoffdate">旧金山大学，2012 年 11 月</div>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0009.html.FOOTNOTE-2" href="#f_0005.html.FNPTR-2">[2]</a>
</td>
<td>
<p id="f_0009.html.N100B1">
<a href="http://lexmachina.com/">http://lexmachina.com</a>
</p><p>
<a href="http://lexmachina.com">http://lexmachina.com</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0009.html.FOOTNOTE-3" href="#f_0006.html.FNPTR-3">[3]</a>
</td>
<td>
<p id="f_0009.html.N100EE">
<a href="http://www.youtube.com/watch?v=4r7wHMg5Yjg">http://www.youtube.com/watch?v=4r7wHMg5Yjg</a>
</p><p>
<a href="http://www.youtube.com/watch?v=4r7wHMg5Yjg">http://www.youtube.com/watch?v=4r7wHMg5Yjg</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0009.html.FOOTNOTE-4" href="#f_0007.html.FNPTR-4">[4]</a>
</td>
<td>
<p id="f_0009.html.N1010B">
<a href="http://tunnelvisionlabs.com/">http://tunnelvisionlabs.com</a>
</p><p>
<a href="http://tunnelvisionlabs.com">http://tunnelvisionlabs.com</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0009.html.FOOTNOTE-5" href="#f_0008.html.FNPTR-5">[5]</a>
</td>
<td>
<p id="f_0009.html.N101C3">
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p><p>
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0009.html.FOOTNOTE-6" href="#f_0009.html.FNPTR-6">[6]</a>
</td>
<td>
<p id="f_0009.html.N101EE">
<a href="https://groups.google.com/d/forum/antlr-discussion">https://groups.google.com/d/forum/antlr-discussion</a>
</p><p>
<a href="https://groups.google.com/d/forum/antlr-discussion">https://groups.google.com/d/forum/antlr-discussion</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0010.html"><div>

<h1 class="part-title" id="f_0010.html.N101FF">
<span class="part-number">第 1 部分</span>
<br><br>介绍 ANTLR 和计算机语言</h1><h1 class="part-title">
<span class="part-number">Part 1</span>
<br><br>Introducing ANTLR and Computer Languages</h1>
<blockquote class="pg-partintro">
<p id="f_0010.html.N10208">
在第一部分中，我们将安装 ANTLR，在简单的“hello world”语法上试用它，并了解语言应用程序开发的全貌。掌握这些基础知识后，我们将构建一个语法来识别和翻译花括号中的整数列表，如
<code class="cf ic">{1, 2, 3}</code>。最后，我们将通过快速浏览一些简单的语法和应用程序来快速了解 ANTLR 的功能。
</p>
</blockquote><blockquote class="pg-partintro">
<p>
In Part I, we’ll get ANTLR installed, try it on a simple “hello world” grammar, and
look at the big picture of language application development. With those basics down,
we’ll build a grammar to recognize and translate lists of integers in curly braces like
<code class="cf ic">{1, 2, 3}</code>. Finally, we’ll take a whirlwind tour of ANTLR features by racing through
a number of simple grammars and applications.
</p>
</blockquote>



</div></div>
<div id="f_0011.html"><div>

<h1 class="chapter-title" id="f_0011.html.chp.antlr">
<span class="chapter-number">
	      第 1 章</span>
<br><br>
<span class="chapter-name">认识 ANTLR</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      1</span>
<br><br>
<span class="chapter-name">Meet ANTLR</span>
</h1>

<p id="f_0011.html.N1021A">
本书第一部分的目标是让您大致了解 ANTLR 的功能并探索语言应用程序架构。一旦我们掌握了大局，我们将在第二部分使用大量真实示例慢慢系统地学习 ANTLR。首先，让我们安装 ANTLR，然后在简单的“hello world”语法上尝试一下。
</p><p>
Our goals in this first part of the book are to get a general overview of ANTLR’s
capabilities and to explore language application architecture. Once we have the big
picture, we’ll learn ANTLR slowly and systematically in Part II using lots of
real-world examples. To get started, let’s install ANTLR and then try it on a simple “hello world” grammar.
</p>

</div></div>
<div id="f_0012.html"><div>

<h2 id="f_0012.html.N1021D">1.1 安装 ANTLR</h2><h2>1.1 Installing ANTLR</h2>
<p id="f_0012.html.N10221">
ANTLR 是用 Java 编写的，因此在开始之前需要安装 Java。<a id="f_0012.html.FNPTR-7" href="#f_0013.html.FOOTNOTE-7">[7]</a>
即使您要使用 ANTLR 生成其他语言（例如 C# 或 C++）的解析器，也是如此。（我希望在不久的将来会有其他目标。）ANTLR 需要 Java 1.6 或更高版本。
</p><p>
ANTLR is written in Java, so you need to have Java installed before you
begin.<a href="#f_0013.html.FOOTNOTE-7">[7]</a>
This is true even if you’re going to use ANTLR to generate parsers in another language such
as C# or C++. (I expect to have other targets in the near future.) ANTLR requires Java version 1.6 or newer.
</p>
<div class="sidebar">
<div class="sidebar-title">为什么本书使用命令行 Shell</div>
<div class="sidebar-content">
<p id="f_0012.html.N10239">
在本书中，我们将使用命令行 (shell) 来运行 ANTLR 并构建我们的应用程序。由于程序员使用各种开发环境和操作系统，因此操作系统 shell 是我们唯一共同的“界面”。使用 shell 还可以使语言应用程序开发和构建过程的每个步骤都清晰易懂。我将始终使用 Mac OS X shell 以保持一致性，但这些命令应该可以在任何 Unix shell 中使用，并且经过细微的改动，也可以在 Windows 上使用。
</p><p>
Throughout this book, we’ll be using the command line (shell) to run ANTLR and build
our applications. Since programmers use a variety of development environments and
operating systems, the operating system shell is the only “interface” we have in
common. Using the shell also makes each step in the language application development
and build process explicit. I’ll be using the Mac OS X shell throughout for
consistency, but the commands should work in any Unix shell and, with trivial variations, on Windows.
</p>
</div>
</div>
<p id="f_0012.html.N1023F">
安装 ANTLR 本身就是下载最新的 jar 文件（例如
<code class="cf filename">antlr-4.0-complete.jar</code>，<a id="f_0012.html.FNPTR-8" href="#f_0013.html.FOOTNOTE-8">[8]）</a>并将其存储在适当位置。jar 文件包含运行 ANTLR 工具所需的所有依赖项以及编译和执行 ANTLR 生成的识别器所需的运行时库。简而言之，ANTLR 工具将语法转换为识别语法描述的语言中的句子的程序。例如，给定 JSON 的语法，ANTLR 工具将使用 ANTLR 运行时库中的一些支持类生成一个识别 JSON 输入的程序。
</p><p>
Installing ANTLR itself is a matter of downloading the latest jar, such as
<code class="cf filename">antlr-4.0-complete.jar</code>,<a href="#f_0013.html.FOOTNOTE-8">[8]</a> and storing it somewhere
appropriate. The jar contains all dependencies necessary to run the ANTLR tool and the
runtime library needed to compile and execute recognizers generated by ANTLR. In a
nutshell, the ANTLR tool converts grammars into programs that recognize sentences in the
language described by the grammar. For example, given a grammar for JSON, the ANTLR tool
generates a program that recognizes JSON input using some support classes from the ANTLR
runtime library.
</p>
<p id="f_0012.html.N10250">
该 jar 还包含两个支持库：一个复杂的树布局库<a id="f_0012.html.FNPTR-9" href="#f_0013.html.FOOTNOTE-9">[9]</a>和 StringTemplate <a id="f_0012.html.FNPTR-10" href="#f_0013.html.FOOTNOTE-10">[10]</a> ，一个用于生成代码和其他结构化文本的模板引擎（请参阅侧边栏
 <a href="#f_0012.html.sb.ST"><em>​StringTemplate</em></a><a href="#f_0012.html.sb.ST">引擎​）<em></em></a> 。在 4.0 版中，ANTLR 仍以 ANTLR v3 编写，因此完整的 jar 也包含 ANTLR 的先前版本。
</p><p>
The jar also contains two support libraries: a sophisticated tree layout
library<a href="#f_0013.html.FOOTNOTE-9">[9]</a> and
StringTemplate,<a href="#f_0013.html.FOOTNOTE-10">[10]</a> a
template engine useful for generating code and other structured text (see the sidebar
 <a href="#f_0012.html.sb.ST">​<em>The StringTemplate Engine</em>​</a>). At version 4.0, ANTLR is still written in ANTLR v3, so
the complete jar contains the previous version of ANTLR as well.
</p>
<div class="sidebar" id="f_0012.html.sb.ST">
<div class="sidebar-title">StringTemplate 引擎</div>
<div class="sidebar-content">
<p id="f_0012.html.N10267">
StringTemplate 是一个 Java 模板引擎（具有 C#、Python、Ruby 和 Scala 端口），用于生成源代码、网页、电子邮件或任何其他格式化的文本输出。StringTemplate 特别擅长多目标代码生成器、多站点皮肤和国际化/本地化。它是经过多年开发 jGuru.com 的努力而发展起来的。StringTemplate 还生成该网站并为 ANTLR v3 和 v4 代码生成器提供支持。有关更多信息，请参阅网站上的
“关于” <a id="f_0012.html.FNPTR-11" href="#f_0013.html.FOOTNOTE-11">[11]页面。</a></p><p>
StringTemplate is a Java template engine (with ports for C#, Python, Ruby, and Scala) for
generating source code, web pages, emails, or any other formatted text output.
StringTemplate is particularly good at multitargeted code generators, multiple site skins,
and internationalization/localization. It evolved over years of effort developing jGuru.com.
StringTemplate also generates that website and powers the ANTLR v3 and v4 code generators. See the About<a href="#f_0013.html.FOOTNOTE-11">[11]</a> page on the website for more information.
</p>
</div>
</div>
<p id="f_0012.html.N10273">
您可以使用 Web 浏览器从 ANTLR 网站手动下载 ANTLR，也可以使用命令行工具<code class="cf commandname">curl</code>来获取它。
</p><p>
You can manually download ANTLR from the ANTLR website using a web browser, or you
can use the command-line tool <code class="cf commandname">curl</code> to grab it.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cd /usr/local/lib</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">curl -O http://www.antlr.org/download/antlr-4.0-complete.jar</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N1028E">
在 Unix 上，<code class="cf filename">/usr/local/lib</code>是存储 ANTLR 等 jar 的好目录。在 Windows 上，似乎没有标准目录，因此您可以简单地将其存储在项目目录中。大多数开发环境都希望您将 jar 放入语言应用程序项目的依赖项列表中。无需更改配置脚本或配置文件 — 您只需确保 Java 知道如何找到 jar。
</p><p>
On Unix, <code class="cf filename">/usr/local/lib</code> is a good directory to store jars like
ANTLR’s. On Windows, there doesn’t seem to be a standard directory, so you can simply
store it in your project directory. Most development environments want you to drop
the jar into the dependency list of your language application project. There is no
configuration script or configuration file to alter—you just need to make sure that
Java knows how to find the jar.
</p>
<p id="f_0012.html.N1029E">
由于本书始终使用命令行，因此您需要经历设置
<code class="cf variable">CLASSPATH</code>
<a id="f_0012.html.FNPTR-12" href="#f_0013.html.FOOTNOTE-12">[12]</a>
环境变量的典型繁琐过程。使用<code class="cf variable">CLASSPATH</code>set，Java 可以找到 ANTLR 工具和运行时库。在 Unix 系统上，您可以从 shell 执行以下命令或将其添加到 shell 启动脚本（<code class="cf filename">.bash_profile</code>对于<code class="cf commandname">bash</code>shell）：
</p><p>
Because this book uses the command line throughout, you need to go through the typical
onerous process of setting the
<code class="cf variable">CLASSPATH</code>
<a href="#f_0013.html.FOOTNOTE-12">[12]</a>
environment variable. With <code class="cf variable">CLASSPATH</code> set, Java can find both the ANTLR
tool and the runtime library. On Unix systems, you can execute the following from the shell
 or add it to the shell start-up script
(<code class="cf filename">.bash_profile</code> for <code class="cf commandname">bash</code> shell):
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">export CLASSPATH=".:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH"</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N102CC">
在 中的某个位置放置点（当前目录标识符）至关重要
<code class="cf variable">CLASSPATH</code>。没有它，Java 编译器和 Java 虚拟机将无法看到当前目录中的类。您将在本书中始终从当前目录编译和测试内容。
</p><p>
It’s critical to have the dot, the current directory identifier, somewhere in the
<code class="cf variable">CLASSPATH</code>. Without that, the Java compiler and Java virtual machine
won’t see classes in the current directory. You’ll be compiling and testing things from the
current directory all the time in this book.
</p>
<p id="f_0012.html.N102D2">
现在，您可以通过不带参数运行 ANTLR 工具来检查 ANTLR 是否已正确安装。您可以使用
<code class="cf commandname">java</code>&nbsp;<code class="cf commandoption">-jar</code>选项直接引用 jar，也可以直接调用<code class="cf class">org.antlr.v4.Tool</code>类。
</p><p>
You can check to see that ANTLR is installed correctly now by running the ANTLR tool
without arguments. You can either reference the jar directly with the
<code class="cf commandname">java</code>&nbsp;<code class="cf commandoption">-jar</code> option or directly
invoke the <code class="cf class">org.antlr.v4.Tool</code> class.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java -jar /usr/local/lib/antlr-4.0-complete.jar  </strong>
<em class="comment"># launch org.antlr.v4.Tool</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLR Parser Generator  Version 4.0​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -o ___              specify output directory where all output is generated​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -lib ___            specify location of .tokens files​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...<strong class="prompt"></strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java org.antlr.v4.Tool    </strong>
<em class="comment"># launch org.antlr.v4.Tool</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLR Parser Generator  Version 4.0​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​-o ___              specify output directory where all output is generated​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​-lib ___            specify location of .tokens files​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N10312">
一直输入上述任一<code class="cf commandname">java</code>命令来运行 ANTLR 会很麻烦，因此最好创建一个别名或 shell 脚本。在整本书中，我将使用 alias <code class="cf commandname">antlr4</code>，您可以在 Unix 上按如下方式定义它：
</p><p>
Typing either of those <code class="cf commandname">java</code> commands to run ANTLR all the
time would be painful, so it’s best to make an alias or shell script. Throughout the
book, I’ll use alias <code class="cf commandname">antlr4</code>, which you can define as follows on Unix:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">alias antlr4='java -jar /usr/local/lib/antlr-4.0-complete.jar'</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N10334">
或者，你可以将以下脚本放入<code class="cf dir">/usr/local/bin</code>（电子书的读者可以点击<code class="cf filename">install/antlr4</code>标题栏来获取文件）：
</p><p>
Or, you could put the following script into <code class="cf dir">/usr/local/bin</code> (readers of the ebook
can click the <code class="cf filename">install/antlr4</code> title bar to get the file):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/install/antlr4">安装/antlr4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​#!/bin/sh​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​java -cp "/usr/local/lib/antlr4-complete.jar:$CLASSPATH" org.antlr.v4.Tool $*​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N1034F">
在 Windows 上，你可以做这样的事情（假设你将 jar 放入<code class="cf filename">C:\libraries</code>）：
</p><p>
On Windows you can do something like this (assuming you put the jar in <code class="cf filename">C:\libraries</code>):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/install/antlr4.bat">安装/antlr4.bat</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​java -cp C:\libraries\antlr-4.0-complete.jar;%CLASSPATH% org.antlr.v4.Tool %*​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N10367">
无论哪种方式，你都可以说<code class="cf commandname">antlr4</code>。
</p><p>
Either way, you get to say just <code class="cf commandname">antlr4</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLR Parser Generator  Version 4.0​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​-o ___              specify output directory where all output is generated​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​-lib ___            specify location of .tokens files​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0012.html.N1038C">
如果您看到帮助消息，那么您就可以快速试用 ANTLR 了！

</p><p>
If you see the help message, then you’re ready to give ANTLR a quick test-drive!

</p>

</div></div>
<div id="f_0013.html"><div>

<h2 id="f_0013.html.sec.intro_launch">1.2 执行 ANTLR 并测试识别器</h2><h2>1.2 Executing ANTLR and Testing Recognizers</h2>
<p id="f_0013.html.N10394"><code class="cf ic">hello parrt</code>这是一个识别类似和的
短语的简单语法<code class="cf ic">hello world</code>：
</p><p>
Here’s a simple grammar that recognizes phrases like <code class="cf ic">hello parrt</code> and <code class="cf ic">hello world</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/install/Hello.g4">安装/Hello.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Hello;            <em class="comment">// Define a grammar called Hello</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r  : <em class="string">'hello'</em> ID ;         <em class="comment">// match keyword hello followed by an identifier</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : [a-z]+ ;             <em class="comment">// match lower-case identifiers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS : [ \t\r\n]+ -&gt; skip ; <em class="comment">// skip spaces, tabs, newlines, \r (Windows)</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N103CA">
为了保持整洁，我们将语法文件放在<code class="cf filename">Hello.g4</code>它自己的目录中，例如<code class="cf filename">/tmp/test</code>。然后我们可以在其上运行 ANTLR 并编译结果。
</p><p>
To keep things tidy, let’s put grammar file <code class="cf filename">Hello.g4</code> in its own
directory, such as <code class="cf filename">/tmp/test</code>. Then we can run ANTLR on it and compile the results.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cd /tmp/test</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <em class="comment"># copy-n-paste Hello.g4 or download the file into /tmp/test</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Hello.g4  </strong>
<em class="comment"># Generate parser and lexer using antlr4 alias from before</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Hello.g4                HelloLexer.java     HelloParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Hello.tokens            HelloLexer.tokens​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​HelloBaseListener.java  HelloListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac *.java     </strong>
<em class="comment"># Compile ANTLR-generated code</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N10408">
运行 ANTLR 工具<code class="cf filename">Hello.g4</code>会生成一个可执行识别器，具体为<code class="cf filename">HelloParser.java</code>和<code class="cf filename">HelloLexer.java</code>，但我们没有主程序来触发语言识别。（我们将在下一章中了解什么是解析器和词法分析器。）这是项目开始时的典型情况。在构建实际应用程序之前，您将尝试几种不同的语法。最好避免创建主程序来测试每个新语法。</p><p>
Running the ANTLR tool on <code class="cf filename">Hello.g4</code> generates an executable recognizer
embodied by <code class="cf filename">HelloParser.java</code> and <code class="cf filename">HelloLexer.java</code>, but
we don’t have a main program to trigger language recognition. (We’ll learn what parsers and
lexers are in the next chapter.) That’s the typical case at the start of a project. You’ll
play around with a few different grammars before building the actual application. It’d be
nice to avoid having to create a main program to test every new grammar.</p>
<p id="f_0013.html.N10420">
ANTLR 在运行时库中提供了一个灵活的测试工具，名为
<code class="cf class">TestRig</code>。它可以显示大量有关识别器如何匹配文件或标准输入的信息。<code class="cf class">TestRig</code>使用 Java 反射来调用已编译的识别器。像以前一样，创建一个方便的别名或批处理文件是个好主意。我将<code class="cf commandname">grun</code>在整本书中使用它（但您可以随意命名）。
</p><p>
ANTLR provides a flexible testing tool in the runtime library called
<code class="cf class">TestRig</code>. It can display lots of information about how a recognizer matches
input from a file or standard input. <code class="cf class">TestRig</code> uses Java reflection to invoke
compiled recognizers. Like before, it’s a good idea to create a convenient alias or batch
file. I’m going to call it <code class="cf commandname">grun</code> throughout the book (but you can
call it whatever you want).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">alias grun='java org.antlr.v4.runtime.misc.TestRig'</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N10445">
测试装置采用语法名称、类似于
<code class="cf methodname">main</code>方法的起始规则名称以及决定我们想要的输出的各种选项。假设我们想要打印识别过程中创建的标记。标记是词汇符号，如关键字<code class="cf keyword">hello</code>和标识符。要测试语法，请按如下方式
<code class="cf ic">parrt</code>启动：<code class="cf commandname">grun</code></p><p>
The test rig takes a grammar name, a starting rule name kind of like a
<code class="cf methodname">main</code> method, and various options that dictate the output we want. Let’s
say we’d like to print the tokens created during recognition. Tokens are vocabulary
symbols like keyword <code class="cf keyword">hello</code> and identifier <code class="cf ic">parrt</code>. To test the
grammar, start up <code class="cf commandname">grun</code> as follows:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Hello r -tokens     # start the TestRig on grammar Hello at rule r</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">hello parrt                # input for the recognizer that you type</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​                         # type ctrl-D on Unix or Ctrl+Z on Windows</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:4='hello',&lt;1&gt;,1:0]   # these three lines are output from grun​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,6:10='parrt',&lt;2&gt;,1:6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,12:11='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N10476">
在命令中按下换行符后<code class="cf commandname">grun</code>，计算机将耐心等待您输入，<code class="cf ic">hello parrt</code>然后按下换行符。此时，您必须输入文件结束符以终止从标准输入读取；否则，程序将永远盯着您。识别器读取完所有输入后，将根据选项on<code class="cf class">TestRig</code>的使用打印出标记列表
。
<code class="cf commandoption">-tokens</code><code class="cf commandname">grun</code></p><p>
After you hit a newline on the <code class="cf commandname">grun</code> command, the computer will
patiently wait for you to type in <code class="cf ic">hello parrt</code> followed by a newline. At that point,
you must type the end-of-file character to terminate reading from standard input;
otherwise, the program will stare at you for eternity. Once the recognizer has read all of
the input, <code class="cf class">TestRig</code> prints out the list of tokens per the use of option
<code class="cf commandoption">-tokens</code> on <code class="cf commandname">grun</code>.
</p>
<p id="f_0013.html.N10488">
输出的每一行代表一个标记，并显示我们对该标记所了解的所有内容。例如，<code class="cf ic">[@1,6:10=’parrt’,&lt;2&gt;,1:6]</code>表示该标记是第二个标记（从 0 开始索引），从字符位置 6 到 10（从 0 开始包含），包含文本<code class="cf ic">parrt</code>，标记类型为 2（<code class="cf keyword">ID</code>），位于第 1 行（从 1 开始），位于字符位置 6（从零开始并将制表符算作一个字符）。
</p><p>
Each line of the output represents a single token and shows everything we know about the
token. For example, <code class="cf ic">[@1,6:10=’parrt’,&lt;2&gt;,1:6]</code> indicates that the token is the
second token (indexed from 0), goes from character position 6 to 10 (inclusive starting
from 0), has text <code class="cf ic">parrt</code>, has token type 2 (<code class="cf keyword">ID</code>), is on line 1
(from 1), and is at character position 6 (starting from zero and counting tabs as a single
character).
</p>
<p id="f_0013.html.N10494">我们可以同样轻松地
以 LISP 样式的文本形式（<span class="emph">根子项</span>）
打印解析树。</p><p>
We can print the parse tree in LISP-style text form (<span class="emph">root children</span>) just as
easily.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Hello r -tree</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">hello parrt</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(r hello parrt)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N104B8">
不过，查看语法如何识别输入的最简单方法是通过视觉查看解析树。使用<code class="cf class">TestRig</code>选项
<code class="cf commandname">grun</code>&nbsp;<code class="cf commandoption">-gui</code>运行<code class="cf ic">grun
Hello r -gui</code>，将生成以下对话框：
</p><p>
The easiest way to see how a grammar recognizes the input, though, is by looking at the
parse tree visually. Running <code class="cf class">TestRig</code> with the
<code class="cf commandname">grun</code>&nbsp;<code class="cf commandoption">-gui</code> option, <code class="cf ic">grun
Hello r -gui</code>, produces the following dialog box:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/安装/Hello-parse-tree.png">
</div>
<p id="f_0013.html.N104D1"><code class="cf class">TestRig</code>不使用任何命令行选项

运行会打印一条简短的帮助消息。</p><p>
Running <code class="cf class">TestRig</code> without any command-line options prints a small help message.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  [-trace] [-diagnostics] [-SLL]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  [input-filename(s)]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Use startRuleName='tokens' if GrammarName is a lexer grammar.​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Omitting input-filename makes rig read from stdin.​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0013.html.N104FB">
随着本书的进展，我们将会使用其中的许多选项；下面简要介绍一下它们的作用：
</p><p>
As we go along in the book, we’ll use many of those options; here’s briefly what they do:
</p>
<dl>
<dt>
<code class="cf commandoption">-tokens</code>
</dt><dt>
<code class="cf commandoption">-tokens</code>
</dt>
<dd>
<p id="f_0013.html.N1050F">打印出标记流。</p>
</dd><dd>
<p>prints out the token stream.</p>
</dd>
<dt>
<code class="cf commandoption">-tree</code>
</dt><dt>
<code class="cf commandoption">-tree</code>
</dt>
<dd>
<p id="f_0013.html.N10518">以 LISP 形式打印出解析树。</p>
</dd><dd>
<p>prints out the parse tree in LISP form.</p>
</dd>
<dt>
<code class="cf commandoption">-gui</code>
</dt><dt>
<code class="cf commandoption">-gui</code>
</dt>
<dd>
<p id="f_0013.html.N10521">在对话框中直观地显示解析树。</p>
</dd><dd>
<p>displays the parse tree visually in a dialog box.</p>
</dd>
<dt>
<code class="cf commandoption">-ps file.ps</code>
</dt><dt>
<code class="cf commandoption">-ps file.ps</code>
</dt>
<dd>
<p id="f_0013.html.N1052A">用 PostScript 生成解析树的可视化表示并将其存储在 中<code class="cf filename">file.ps</code>。本章中的解析树图形是使用 生成的<code class="cf commandoption">-ps</code>。
  </p>
</dd><dd>
<p>generates a visual representation of the parse tree in PostScript and stores it in <code class="cf filename">file.ps</code>. The parse tree
  figures in this chapter were generated with <code class="cf commandoption">-ps</code>.
  </p>
</dd>
<dt>
<code class="cf commandoption">-encoding encodingname</code>
</dt><dt>
<code class="cf commandoption">-encoding encodingname</code>
</dt>
<dd>
<p id="f_0013.html.N10539">如果当前语言环境无法正确读取输入，则指定测试装置输入文件编码。例如，我们需要此选项来解析第 12.4 节“<a href="#f_0075.html.sec.XML">解析<em>和词法分析 XML”</em></a>中的日语编码 XML 文件。</p>
</dd><dd>
<p>specifies the test rig input file encoding if the current locale would not read  the input properly. For example, we need this option to parse a Japanese-encoded XML file in Section 12.4, <a href="#f_0075.html.sec.XML">​<em>Parsing and Lexing XML</em>​</a>.</p>
</dd>
<dt>
<code class="cf commandoption">-trace</code>
</dt><dt>
<code class="cf commandoption">-trace</code>
</dt>
<dd>
<p id="f_0013.html.N10545">在规则进入和退出时打印规则名称和当前标记。</p>
</dd><dd>
<p>prints the rule name and current token upon rule entry and exit.</p>
</dd>
<dt>
<code class="cf commandoption">-diagnostics</code>
</dt><dt>
<code class="cf commandoption">-diagnostics</code>
</dt>
<dd>
<p id="f_0013.html.N1054E">在解析过程中打开诊断消息。这只会在出现歧义输入短语等异常情况时生成消息。
  </p>
</dd><dd>
<p>turns on diagnostic messages during parsing. This  generates messages only for unusual situations such as ambiguous input phrases.
  </p>
</dd>
<dt>
<code class="cf commandoption">-SLL</code>
</dt><dt>
<code class="cf commandoption">-SLL</code>
</dt>
<dd>
<p id="f_0013.html.N10557">使用更快但稍弱的解析策略。
 </p>
</dd><dd>
<p>uses a faster but slightly weaker parsing strategy.
 </p>
</dd>
</dl>
<p id="f_0013.html.N1055A">
现在我们已经安装了 ANTLR，并在简单的语法上尝试了它，让我们退一步来看看大局，并在下一章中学习一些重要的术语。之后，我们将尝试一个简单的入门项目，它可以识别和翻译整数列表，例如。然后，我们将在第 4 章<a href="#f_0025.html.chp.tour">“</a><a href="#f_0025.html.chp.tour"><em>快速浏览”</em></a><code class="cf ic">{1, 2, 3}</code>中介绍一些有趣的示例，<a href="#f_0025.html.chp.tour">这些</a>示例展示了 ANTLR 的功能并说明了 ANTLR 适用的几个领域。
<a href="#f_0025.html.chp.tour"><em></em></a></p><p>
Now that we have ANTLR installed and have tried it on a simple grammar, let’s take a step
back to look at the big picture and learn some important terminology in the next chapter.
After that, we’ll try a simple starter project that recognizes and translates lists of
integers such as <code class="cf ic">{1, 2, 3}</code>. Then, we’ll walk through a number of interesting
examples in Chapter 4, <a href="#f_0025.html.chp.tour">​<em>A Quick Tour</em>​</a> that demonstrate ANTLR’s capabilities and that
illustrate a few of the domains where ANTLR applies.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-7" href="#f_0012.html.FNPTR-7">[7]</a>
</td>
<td>
<p id="f_0013.html.N10230">
<a href="http://www.java.com/en/download/help/download_options.xml">http://www.java.com/en/download/help/download_options.xml</a>
</p><p>
<a href="http://www.java.com/en/download/help/download_options.xml">http://www.java.com/en/download/help/download_options.xml</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-8" href="#f_0012.html.FNPTR-8">[8]</a>
</td>
<td>
<p id="f_0013.html.N10246">请参阅<a href="http://www.antlr.org/download.html">http://www.antlr.org/download.html</a>，但您也可以通过从
<a href="https://github.com/antlr/antlr4">https://github.com/antlr/antlr4</a>提取源代码来构建ANTLR 。</p><p>See <a href="http://www.antlr.org/download.html">http://www.antlr.org/download.html</a>,
but you can also build ANTLR from the source by pulling from
<a href="https://github.com/antlr/antlr4">https://github.com/antlr/antlr4</a>.</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-9" href="#f_0012.html.FNPTR-9">[9]</a>
</td>
<td>
<p id="f_0013.html.N10254">
<a href="http://code.google.com/p/treelayout">http://code.google.com/p/treelayout</a>
</p><p>
<a href="http://code.google.com/p/treelayout">http://code.google.com/p/treelayout</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-10" href="#f_0012.html.FNPTR-10">[10]</a>
</td>
<td>
<p id="f_0013.html.N1025A">
<a href="http://www.stringtemplate.org/">http://www.stringtemplate.org</a>
</p><p>
<a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-11" href="#f_0012.html.FNPTR-11">[11]</a>
</td>
<td>
<p id="f_0013.html.N1026E">
<a href="http://www.stringtemplate.org/about.html">http://www.stringtemplate.org/about.html</a>
</p><p>
<a href="http://www.stringtemplate.org/about.html">http://www.stringtemplate.org/about.html</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0013.html.FOOTNOTE-12" href="#f_0012.html.FNPTR-12">[12]</a>
</td>
<td>
<p id="f_0013.html.N102A4">
<a href="http://docs.oracle.com/javase/tutorial/essential/environment/paths.html">http://docs.oracle.com/javase/tutorial/essential/environment/paths.html</a>
</p><p>
<a href="http://docs.oracle.com/javase/tutorial/essential/environment/paths.html">http://docs.oracle.com/javase/tutorial/essential/environment/paths.html</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0014.html"><div>

<h1 class="chapter-title" id="f_0014.html.chp.bigpic">
<span class="chapter-number">
	      第 2 章</span>
<br><br>
<span class="chapter-name">总体情况</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      2</span>
<br><br>
<span class="chapter-name">The Big Picture</span>
</h1>

<p id="f_0014.html.N10575">
现在我们已经安装了 ANTLR，并且知道如何构建和运行一个小示例，我们将从整体上进行研究。在本章中，我们将了解与语言应用程序相关的重要流程、术语和数据结构。在学习过程中，我们将识别关键的 ANTLR 对象，并了解 ANTLR 在幕后为我们做了哪些工作。
</p><p>
Now that we have ANTLR installed and some idea of how to build and run a small example,
we’re going to look at the big picture. In this chapter, we’ll learn about the important
processes, terminology, and data structures associated with language applications. As we go
along, we’ll identify the key ANTLR objects and learn a little bit about what ANTLR does
for us behind the scenes.
</p>

</div></div>
<div id="f_0015.html"><div>

<h2 id="f_0015.html.sec.terms">2.1 让我们获得元！</h2><h2>2.1 Let’s Get Meta!</h2>
<p id="f_0015.html.N10585">
要实现一种语言，我们必须构建一个应用程序，它可以读取句子并对发现的短语和输入符号做出适当的反应。（语言是一组有效句子，句子由短语组成，短语由子短语和词汇符号组成。）广义上讲，如果应用程序计算或“执行”句子，我们将该应用程序称为解释器<span class="firstuseinline">。</span>示例包括计算器、配置文件阅读器和 Python 解释器。如果我们将句子从一种语言转换为另一种语言，我们将该应用程序称为<span class="firstuseinline">翻译器</span>。示例包括 Java 到 C# 的转换器和编译器。
</p><p>
To implement a language, we have to build an application that reads sentences and reacts
appropriately to the phrases and input symbols it discovers. (A language is a set of valid
sentences, a sentence is made up of phrases, and a phrase is made up of subphrases and
vocabulary symbols.) Broadly speaking, if an application computes or “executes” sentences,
we call that application an <span class="firstuseinline">interpreter</span>. Examples include calculators,
configuration file readers, and Python interpreters. If we’re converting sentences from one
language to another, we call that application a <span class="firstuseinline">translator</span>. Examples
include Java to C# converters and compilers.
</p>
<p id="f_0015.html.N1059B">
为了做出适当的反应，解释器或翻译器必须识别特定语言的所有有效句子、短语和子短语。识别短语意味着我们可以识别出各个组成部分并将其与其他短语区分开来。例如，我们将输入识别<code class="cf ic">sp = 100;</code>为编程语言赋值语句。这意味着我们知道这<code class="cf ic">sp</code>是赋值目标，也是<code class="cf ic">100</code>需要存储的值。同样，如果我们识别英语句子，我们会识别出词性，如主语、谓语和宾语。识别赋值<code class="cf ic">sp
= 100;</code>还意味着语言应用程序将其视为与 import 语句等截然不同的事物。识别后，应用程序将执行适当的操作，如<code class="cf ic">performAssignment("sp", 100)</code>或<code class="cf ic">translateAssignment("sp",
100)</code>。
</p><p>
To react appropriately, the interpreter or translator has to recognize all of the
valid sentences, phrases, and subphrases of a particular language. Recognizing a phrase
means we can identify the various components and can differentiate it from other phrases.
For example, we recognize input <code class="cf ic">sp = 100;</code> as a programming language assignment
statement. That means we know that <code class="cf ic">sp</code> is the assignment target and <code class="cf ic">100</code> is
the value to store. Similarly, if we were recognizing English sentences, we’d identify the
parts of speech, such as the subject, predicate, and object. Recognizing assignment <code class="cf ic">sp
= 100;</code> also means that the language application sees it as clearly distinct from, say, an
import statement. After recognition, the application would then perform a suitable
operation such as <code class="cf ic">performAssignment("sp", 100)</code> or <code class="cf ic">translateAssignment("sp",
100)</code>.
</p>
<p id="f_0015.html.N105B0">
识别语言的程序称为<span class="firstuseinline">解析器</span>或
<span class="firstuseinline">语法分析器</span>。<span class="firstuseinline">语法</span>是指管理语言成员资格的规则，在本书中，我们将构建 ANTLR
<span class="firstuseinline">语法</span>来指定语言语法。语法只是一组规则，每条规则都表达了短语的结构。ANTLR 工具将语法转换为解析器，这些解析器看起来与经验丰富的程序员手工构建的解析器非常相似。（ANTLR 是一个编写其他程序的程序。）语法本身遵循为指定其他语言而优化的语言的语法：ANTLR 的
<span class="firstuseinline">元语言</span>。
</p><p>
Programs that recognize languages are called <span class="firstuseinline">parsers</span> or
<span class="firstuseinline">syntax analyzers</span>. <span class="firstuseinline">Syntax</span> refers to the rules
governing language membership, and in this book we’re going to build ANTLR
<span class="firstuseinline">grammars</span> to specify language syntax. A grammar is just a set of rules,
each one expressing the structure of a phrase. The ANTLR tool translates grammars to parsers
that look remarkably similar to what an experienced programmer might build by hand. (ANTLR
is a program that writes other programs.) Grammars themselves follow the syntax of a
language optimized for specifying other languages: ANTLR’s
<span class="firstuseinline">meta-language</span>.
</p>
<p id="f_0015.html.N105D4">
如果我们将解析分解为两个相似但不同的任务或阶段，解析就会容易得多。这两个独立阶段反映了我们的大脑阅读英文文本的方式。我们不会逐个字符地阅读句子，而是将句子视为一连串的单词。人类大脑会下意识地将字符序列分组为单词，然后在词典中查找，然后再识别语法结构。如果我们阅读摩尔斯电码，这个过程会更加明显，因为我们必须在阅读消息之前将点和划转换为字符。在阅读长单词（例如夏威夷州的州鱼
<span class="emph">Humuhumunukunukuapua'a ）时，这个过程也很明显。</span></p><p>
Parsing is much easier if we break it down into two similar but distinct tasks or stages. The
separate stages mirror how our brains read English text. We don’t read a sentence character
by character. Instead, we perceive a sentence as a stream of words. The human brain
subconsciously groups character sequences into words and looks them up in a dictionary before
recognizing grammatical structure. This process is more obvious if we’re reading Morse code
because we have to convert the dots and dashes to characters before reading a message. It’s
also obvious when reading long words such as <span class="emph">Humuhumunukunukuapua’a</span>, the Hawaiian state fish.
</p>
<p id="f_0015.html.N105DF"><span class="firstuseinline">将字符分组为单词或符号（标记</span>）
的过程称为<span class="firstuseinline">词法分析</span>或简称为<span class="firstuseinline">标记化</span>。我们将对输入进行标记化的程序称为词法分析器<span class="firstuseinline">。</span>词法分析器可以将相关标记分组为标记类或<span class="firstuseinline">标记类型</span>，例如
<code class="cf keyword">INT</code>（整数）、<code class="cf keyword">ID</code>（标识符）、
 <code class="cf keyword">FLOAT</code>（浮点数）等等。当解析器只关心类型而不是单个符号时，词法分析器会将词汇符号分组为不同类型。标记至少包含两条信息：标记类型（标识词汇结构）和词法分析器与该标记匹配的文本。
</p><p>
The process of grouping characters into words or symbols (<span class="firstuseinline">tokens</span>) is
called <span class="firstuseinline">lexical analysis</span> or simply <span class="firstuseinline">tokenizing</span>. We
call a program that tokenizes the input a <span class="firstuseinline">lexer</span>. The lexer can group
related tokens into token classes, or <span class="firstuseinline">token types</span>, such as
<code class="cf keyword">INT</code> (integers), <code class="cf keyword">ID</code> (identifiers),
<code class="cf keyword">FLOAT</code> (floating-point numbers), and so on. The lexer groups vocabulary
symbols into types when the parser cares only about the type, not the individual symbols.
Tokens consist of at least two pieces of information: the token type (identifying the
lexical structure) and the text matched for that token by the lexer.
</p>
<p id="f_0015.html.N10607">
第二阶段是实际的解析器，它利用这些标记来识别句子结构，在本例中是赋值语句。默认情况下，ANTLR 生成的解析器会构建一个称为<span class="firstuseinline">解析树</span>或<span class="firstuseinline">语法树</span>的数据结构，该结构记录解析器如何识别输入句子及其组成短语的结构。下图说明了语言识别器的基本数据流：
</p><p>
The second stage is the actual parser and feeds off of these tokens to recognize the
sentence structure, in this case an assignment statement. By default, ANTLR-generated
parsers build a data structure called a <span class="firstuseinline">parse tree</span> or <span class="firstuseinline">syntax
tree</span> that records how the parser recognized the structure of the input sentence
and its component phrases. The following diagram  illustrates the basic data flow of a
language recognizer:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/大图/流程.png">
</div>
<p id="f_0015.html.N1061A">
解析树的内部节点是短语名称，用于分组和标识其子节点。根节点是最抽象的短语名称，在本例中为<span class="emph">stat</span>（“statement” 的缩写）。解析树的叶子始终是输入标记。句子、符号的线性序列实际上只是我们人类在硬件中原生理解的解析树的序列化。为了让某人理解一个想法，我们必须使用单词流在他们的头脑中构想出相同的解析树。
</p><p>
The interior nodes of the parse tree are phrase names that group and identify their children.
The root node is the most abstract phrase name, in this case <span class="emph">stat</span> (short for
“statement”). The leaves of a parse tree are always the input tokens. Sentences, linear
sequences of symbols, are really just serializations of parse trees we humans grok natively
in hardware. To get an idea across to someone, we have to conjure up the same parse tree in
their heads using a word stream.
</p>
<p id="f_0015.html.N10625">
通过生成解析树，解析器向应用程序的其余部分提供了一个方便的数据结构，其中包含有关解析器如何将符号分组为短语的完整信息。解析树在后续步骤中易于处理，并且程序员很容易理解。更好的是，解析器可以自动生成解析树。
</p><p>
By producing a parse tree, a parser delivers a handy data structure to the rest of the
application that contains complete information about how the parser grouped the symbols
into phrases. Trees are easy to process in subsequent steps and are well understood by
programmers. Better yet, the parser can generate parse trees automatically.
</p>
<p id="f_0015.html.N10628">
通过操作解析树，需要识别相同语言的多个应用程序可以重用单个解析器。另一种选择是将特定于应用程序的代码片段直接嵌入到语法中，这是解析器生成器传统上所做的。ANTLR v4 仍然允许这样做（参见第 10 章“<a href="#f_0063.html.chp.actions">属性<em>和操作</em>”）</a> ，但解析树的设计更加整洁，耦合度更高。
</p><p>
By operating off parse trees, multiple applications that need to recognize the same
language can reuse a single parser. The other choice is to embed application-specific code
snippets directly into the grammar, which is what parser generators have done
traditionally. ANTLR v4 still allows this (see Chapter 10, <a href="#f_0063.html.chp.actions">​<em>Attributes and Actions</em>​</a>), but parse
trees make for a much tidier and more decoupled design.
</p>
<p id="f_0015.html.N1062E">
解析树对于需要多次传递（遍历树）的翻译也很有用，因为计算依赖性，一个阶段需要来自前一个阶段的信息。在其他情况下，由于应用程序非常复杂，因此在多个阶段进行编码和测试要容易得多。我们不必为每个阶段重新解析输入字符，而是可以多次遍历解析树，这样效率要高得多。
</p><p>
Parse trees are also useful for translations that require multiple passes (tree walks) because
of computation dependencies where one stage needs information from a previous stage. In other
cases, an application is just a heck of a lot easier to code and test in multiple stages
because it’s so complex. Rather than reparse the input characters for each stage, we can just
walk the parse tree multiple times, which is much more efficient.
</p>
<p id="f_0015.html.N10631">
因为我们用一组规则来指定短语结构，所以解析树子树根对应于语法规则名称。作为后续内容的预览，以下是与图中
<span class="emph">分配子树第一级相对应的语法规则：</span></p><p>
Because we specify phrase structure with a set of rules, parse-tree subtree roots
correspond to grammar rule names. As a preview of things to come, here’s the grammar rule
that corresponds to the first level of the <span class="emph">assign</span> subtree from the diagram:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​assign : ID <em class="string">'='</em> expr <em class="string">';'</em> ; <em class="comment">// match an assignment statement like "sp = 100;"</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0015.html.N1064B">
了解 ANTLR 如何将这些规则转换为人类可读的解析代码是使用和调试语法的基础，因此让我们深入了解解析的工作原理。
</p><p>
Understanding how ANTLR translates such rules into human-readable parsing code is
fundamental to using and debugging grammars, so let’s dig deeper into how parsing works.
</p>

</div></div>
<div id="f_0016.html"><div>

<h2 id="f_0016.html.sec.parsing-terminology">2.2 实现解析器</h2><h2>2.2 Implementing Parsers</h2>
<p id="f_0016.html.N10653">
ANTLR 工具根据我们刚刚看到的语法规则生成<span class="firstuseinline">递归下降解析器</span><code class="cf keyword">assign</code>。递归下降解析器实际上只是递归方法的集合，每个规则一个递归方法。术语“<span class="emph">下降”</span>指的是解析从解析树的根开始，然后向叶子（标记）进行。我们首先调用的规则，即起始<span class="firstuseinline">符号</span>，成为解析树的根。这意味着调用<code class="cf methodname">stat</code>上一节中解析树的方法。这种解析的更通用术语是<span class="firstuseinline">自上而下的解析</span>；递归下降解析器只是自上而下解析器实现的一种。
</p><p>
The ANTLR tool generates <span class="firstuseinline">recursive-descent parsers</span> from grammar rules
such as <code class="cf keyword">assign</code> that we just saw. Recursive-descent parsers are really just
a collection of recursive methods, one per rule. The <span class="emph">descent</span> term refers to the
fact that parsing begins at the root of a parse tree and proceeds toward the leaves
(tokens). The rule we invoke first, the <span class="firstuseinline">start symbol</span>, becomes the root
of the parse tree. That would mean calling method <code class="cf methodname">stat</code> for the parse tree in
the previous section. A more general term for this kind of parsing is <span class="firstuseinline">top-down
parsing</span>; recursive-descent parsers are just one kind of top-down parser
implementation.
</p>
<p id="f_0016.html.N10675">
为了让您了解递归下降解析器的样子，下面是 ANTLR 为规则生成的方法（略微清理过的）<code class="cf keyword">assign</code>：
</p><p>
To get an idea of what recursive-descent parsers look like, here’s the (slightly
cleaned up) method that ANTLR generates for rule <code class="cf keyword">assign</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// assign : ID '=' expr ';' ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> assign() {     <em class="comment">// method generated from rule assign</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    match(ID);      <em class="comment">// compare ID to current input symbol then consume</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    match(<em class="string">'='</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    expr();         <em class="comment">// match an expression by calling expr()</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    match(<em class="string">';'</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0016.html.N106A8">
递归下降解析器最酷的地方在于，通过调用方法 、 和 描绘出的调用图<code class="cf methodname">stat</code>反映<code class="cf methodname">assign</code>了<code class="cf methodname">expr</code>内部解析树节点。（快速回顾一下解析树图。）对 的调用
<code class="cf methodname">match</code>对应于解析树叶子。要在手工构建的解析器中手动构建解析树，我们会在每个规则方法的开头插入“添加新子树根”操作，并在 中插入“添加新叶节点”操作<code class="cf methodname">match</code>。
</p><p>
The cool part about recursive-descent parsers is that the call graph traced out by invoking
methods <code class="cf methodname">stat</code>, <code class="cf methodname">assign</code>, and <code class="cf methodname">expr</code> mirrors the
interior parse tree nodes. (Take a quick peek back at the parse tree figure.) The calls to
<code class="cf methodname">match</code> correspond to the parse tree leaves. To build a parse tree manually in a
handbuilt parser, we’d insert “add new subtree root” operations at the start of each rule
method and an “add new leaf node” operation to <code class="cf methodname">match</code>.
</p>
<p id="f_0016.html.N106BA">
方法<code class="cf methodname">assign</code>只是检查以确保所有必要的标记都存在且顺序正确。当解析器输入时<code class="cf methodname">assign</code>，它不必在多个<span class="firstuseinline">替代方案</span>之间进行选择。替代方案是规则定义右侧的选项之一。例如，<code class="cf keyword">stat</code>调用的规则<code class="cf keyword">assign</code>可能具有其他类型语句的列表。
</p><p>
Method <code class="cf methodname">assign</code> just checks to make sure all necessary tokens are present and in
the right order. When the parser enters <code class="cf methodname">assign</code>, it doesn’t have to choose
between more than one <span class="firstuseinline">alternative</span>. An alternative is one of the choices on
the right side of a rule definition. For example, the <code class="cf keyword">stat</code> rule that
invokes <code class="cf keyword">assign</code> likely has a list of other kinds of statements.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match any kind of statement starting at the current input position */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: assign          <em class="comment">// First alternative ('|' is alternative separator)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ifstat          <em class="comment">// Second alternative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | whilestat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0016.html.N106EC">
的解析规则看起来<code class="cf keyword">stat</code>像<code class="cf keyword">switch</code>。
</p><p>
A parsing rule for <code class="cf keyword">stat</code> looks like a <code class="cf keyword">switch</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> stat() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">switch</strong> ( current input token ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CASE ID    : assign(); <strong class="prompt">break</strong>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CASE IF    : ifstat(); <strong class="prompt">break</strong>; <em class="comment">// IF is token type for keyword 'if'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CASE WHILE : whilestat(); <strong class="prompt">break</strong>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        default    : raise no viable alternative exception​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0016.html.N1072E">
方法<code class="cf methodname">stat</code>必须通过检查下一个输入标记来做出<span class="firstuseinline">解析决策</span>或<span class="firstuseinline">预测</span>。解析决策预测哪种替代方案会成功。在这种情况下，看到关键字<code class="cf keyword">WHILE</code>会预测规则的第三种替代方案
<code class="cf keyword">stat</code>。因此，规则方法<code class="cf methodname">stat</code>调用
<code class="cf methodname">whilestat</code>。您可能以前听说过术语<span class="firstuseinline">“前瞻标记”</span> 
；那只是下一个输入标记。前瞻标记是解析器在匹配和使用之前嗅探的任何标记。
</p><p>
Method <code class="cf methodname">stat</code> has to make a <span class="firstuseinline">parsing decision</span> or <span class="firstuseinline">prediction</span> by examining
the next input token. Parsing decisions predict which alternative will be successful. In this
case, seeing a <code class="cf keyword">WHILE</code> keyword predicts the third alternative of rule
<code class="cf keyword">stat</code>. Rule method <code class="cf methodname">stat</code> therefore calls
<code class="cf methodname">whilestat</code>. You might’ve heard the term <span class="firstuseinline">lookahead token</span>
before; that’s just the next input token. A lookahead token is any token that the parser
sniffs before matching and consuming it.
</p>
<p id="f_0016.html.N10759">
有时，解析器需要大量的前瞻标记来预测哪个替代方案会成功。它甚至可能必须考虑从当前位置到文件末尾的所有标记！ANTLR 会默默地为您处理所有这些，但对决策有基本的了解会很有帮助，这样调试生成的解析器会更容易。
</p><p>
Sometimes, the parser needs lots of lookahead tokens to predict which alternative will succeed. It  might even have to consider all tokens from the current position until the end
of file! ANTLR silently handles all of this for you, but it’s helpful to have a basic
understanding of decision making so debugging generated parsers is easier.
</p>
<p id="f_0016.html.N1075C">
为了直观地展示解析决策，想象一个迷宫，它只有一个入口和一个出口，地板上写着单词。从入口到出口的路径上的每个单词序列都代表一个句子。迷宫的结构类似于定义语言的语法规则。为了测试一个句子是否属于某种语言，我们在穿越迷宫时将句子的单词与地板上的单词进行比较。如果我们可以按照句子的单词到达出口，那么这个句子就是有效的。
</p><p>
To visualize parsing decisions, imagine a maze with a single entrance and a single exit  that has words
written on the floor. Every sequence of words along a path from entrance to exit represents a
sentence. The structure of the maze is analogous to the rules in a grammar that define a
language. To test a sentence for membership in a language, we compare the sentence’s words
with the words along the floor as we traverse the maze. If we can get to the exit by
following the sentence’s words, that sentence is valid.
</p>
<p id="f_0016.html.N1075F">
要穿越迷宫，我们必须在每个分叉处选择一条有效路径，就像我们必须在解析器中选择备选方案一样。我们必须通过将句子中的下一个单词与从分叉处发出的每条路径上可见的单词进行比较来决定走哪条路径。我们从分叉处看到的单词类似于前瞻标记。当每条路径都以唯一的单词开头时，决策就相当容易。在规则中<code class="cf keyword">stat</code>，每个备选方案都以唯一的标记开头，因此<code class="cf methodname">stat</code>可以通过查看第一个前瞻标记来区分备选方案。
</p><p>
To navigate the maze, we must choose a valid path at each fork, just as we must choose
alternatives in a parser. We have to decide which path to take by comparing the next word or
words in our sentence with the words visible down each path emanating from the fork. The
words we can see from the fork are analogous to lookahead tokens. The decision is pretty easy
when each path starts with a unique word. In rule <code class="cf keyword">stat</code>, each alternative
begins with a unique token, so <code class="cf methodname">stat</code> can distinguish the alternatives by
looking at the first lookahead token.
</p>
<p id="f_0016.html.N10768">
当从分叉开始的每条路径上的单词重叠时，解析器需要进一步向前看，扫描区分备选方案的单词。ANTLR 会根据每个决策的需要自动限制向前看的次数。如果在出口（文件末尾）的多个路径上向前看的次数相同，则当前输入短语有多种解释。解决此类歧义是我们下一个主题。之后，我们将弄清楚如何使用解析树来构建语言应用程序。
</p><p>
When the words starting each path from a fork overlap, a parser needs to look further ahead,
scanning for words that distinguish the alternatives. ANTLR automatically throttles the
amount of lookahead up-and-down as necessary for each decision. If the lookahead is the same
down multiple paths to the exit (end of file), there are multiple interpretations of the
current input phrase. Resolving such ambiguities is our next topic. After that, we’ll figure
out how to use parse trees to build language applications.
</p>

</div></div>
<div id="f_0017.html"><div>

<h2 id="f_0017.html.sec.ambiguity">2.3 核反应堆中不能注入过多的水</h2><h2>2.3 You Can’t Put Too Much Water into a Nuclear Reactor</h2>
<p id="f_0017.html.N1077C">
歧义短语或句子是指具有多种解释的短语或句子。换句话说，这些单词符合多种语法结构。章节标题“你不能向核反应堆中注入过多的水”是我多年前看过的<span class="emph">周六夜现场</span>小品中的一个歧义句子。剧中角色不确定他们是否应该小心<span class="emph">不要</span>向反应堆中注入过多的水，或者是否应该向反应堆中注入大量的水。
</p><p>
An ambiguous phrase or sentence is one that has more than one interpretation. In other words,
the words fit more than one grammatical structure. The section title “You Can’t Put Too Much
Water into a Nuclear Reactor” is an ambiguous sentence from a <span class="emph">Saturday Night Live</span> sketch I
saw years ago. The characters weren’t sure if they should be careful <span class="emph">not</span> to put
too much water into the reactor or if they should put lots of water into the reactor.
</p>
<div class="sidebar">
<div class="sidebar-title">对于那些人来说“不，谢谢”已经太多</div>
<div class="sidebar-content">
<p id="f_0017.html.N10793">
我最喜欢的一句模棱两可的句子出现在我朋友凯文的博士论文致谢页上：“献给我的博士导师，对他来说，再多的感谢也不过分。”我不清楚他是感激还是忘恩负义。凯文说是忘恩负义，所以我问他为什么会为同一个人做博士后工作。他回答说：“报复。”
</p><p>
One of my favorite ambiguous sentences is on the dedication page of my friend Kevin’s Ph.D.
thesis: “To my Ph.D. supervisor, for whom no thanks is too much.” It’s
unclear whether he was grateful or ungrateful. Kevin claimed it was the latter, so I
asked why he had taken a postdoc job working for the same guy. His reply: “Revenge.”
</p>
</div>
</div>
<p id="f_0017.html.N10796">
歧义在自然语言中很有趣，但对基于计算机的语言应用程序来说却会带来问题。要解释或翻译短语，程序必须唯一地识别其含义。这意味着我们必须提供无歧义的语法，以便生成的解析器能够以完全相同的方式匹配每个输入短语。
</p><p>
Ambiguity can be funny in natural language but causes problems for computer-based language
applications. To interpret or translate a phrase, a program has to uniquely identify the
meaning. That means we have to provide unambiguous grammars so that the generated parser can
match each input phrase in exactly one way.
</p>
<p id="f_0017.html.N10799">
我们还没有详细学习语法，但让我们在这里包含一些歧义语法，以使歧义的概念更加具体。如果您在以后构建语法时遇到歧义，可以参考本节。
</p><p>
We haven’t studied grammars in detail yet, but let’s include a few ambiguous grammars here
to make the notion of ambiguity more concrete. You can refer to this section if you
run into ambiguities later when building a grammar.
</p>
<p id="f_0017.html.N1079C">
有些语法歧义是显而易见的。
</p><p>
Some ambiguous grammars are obvious.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: ID <em class="string">'='</em> expr <em class="string">';'</em>  <em class="comment">// match an assignment; can match "f();"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ID <em class="string">'='</em> expr <em class="string">';'</em>  <em class="comment">// oops! an exact duplicate of previous alternative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: INT ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0017.html.N107C4">
不过，大多数时候，歧义会更加微妙，如下面的语法可以通过规则的两种替代方式匹配函数调用
<code class="cf keyword">stat</code>：
</p><p>
Most of the time, though, the ambiguity will be more subtle, as in the following grammar
that can match a function call via both alternatives of rule
<code class="cf keyword">stat</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: expr <em class="string">';'</em>        <em class="comment">// expression statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ID <em class="string">'('</em> <em class="string">')'</em> <em class="string">';'</em>  <em class="comment">// function call statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: ID <em class="string">'('</em> <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0017.html.N107FA"><code class="cf ic">f();</code>以下是对规则中

输入的两种解释<code class="cf keyword">stat</code>：
</p><p>
Here are the two interpretations of input <code class="cf ic">f();</code> starting in rule
<code class="cf keyword">stat</code>:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/bigpic/func-combined.png">
</div>
<p id="f_0017.html.N10808">
左侧的解析树显示<code class="cf ic">f()</code>匹配规则
的情况<code class="cf keyword">expr</code>。右侧的解析树显示匹配<code class="cf ic">f()</code>规则的第二个替代方案的开头的情况<code class="cf keyword">stat</code>。
</p><p>
The parse tree on the left shows the case where <code class="cf ic">f()</code> matches to rule
<code class="cf keyword">expr</code>. The tree on the right shows <code class="cf ic">f()</code> matching to the start of
rule <code class="cf keyword">stat</code>’s second alternative.
</p>
<p id="f_0017.html.N10817">
由于大多数语言发明者都将其语法设计为无歧义的，因此歧义语法类似于编程错误。我们需要重新组织语法，以便为每个输入短语向解析器提供单一选择。如果解析器检测到歧义短语，它必须选择可行的替代方案之一。ANTLR 通过选择决策中涉及的第一个替代方案来解决歧义问题。在这种情况下，解析器将选择<code class="cf ic">f();</code>与左侧解析树相关的解释。
</p><p>
Since most language inventors design their syntax to be unambiguous, an ambiguous grammar
is analogous to a programming bug. We need to reorganize the grammar to present a single
choice to the parser for each input phrase. If the parser detects an ambiguous
phrase, it has to pick one of the viable alternatives. ANTLR resolves the ambiguity by
choosing the first alternative involved in the decision. In this case, the parser would
choose the interpretation of <code class="cf ic">f();</code> associated with the parse tree on the left.
</p>
<p id="f_0017.html.N10820">
歧义可能出现在词法分析器和解析器中，但 ANTLR 可以解决这些歧义，使规则自然运行。ANTLR 通过将输入字符串与语法中首先指定的规则进行匹配来解决词汇歧义。要了解其工作原理，让我们看一下大多数编程语言中常见的歧义：关键字和标识符规则之间的歧义。关键字<code class="cf keyword">begin</code>（后跟非字母）也是标识符，至少在词汇上是如此，因此词法分析器可以将 begin 与任一规则进行匹配。
</p><p>
Ambiguities can occur in the lexer as well as the parser, but ANTLR resolves them so the
rules behave naturally. ANTLR resolves lexical ambiguities by matching the input string to
the rule specified first in the grammar. To see how this works, let’s look at an ambiguity
that’s common to most programming languages: the ambiguity between keywords and identifier
rules. Keyword <code class="cf keyword">begin</code> (followed by a nonletter) is also an identifier, at
least lexically, so the lexer can match b-e-g-i-n to either rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​BEGIN : <em class="string">'begin'</em> ;  <em class="comment">// match b-e-g-i-n sequence; ambiguity resolves to BEGIN</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID    : [a-z]+ ;   <em class="comment">// match one or more of any lowercase letter</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0017.html.N1083F">
有关词汇歧义的更多信息，请参阅<a href="#f_0037.html.sec.matching-identifiers">匹配<em>标识符</em></a>。
</p><p>
For more on this lexical ambiguity, see <a href="#f_0037.html.sec.matching-identifiers">​<em>Matching Identifiers</em>​</a>.
</p>
<p id="f_0017.html.N10845">
请注意，词法分析器会尝试匹配每个标记的最长字符串，这意味着输入
<code class="cf keyword">beginner</code>只会与规则匹配<code class="cf keyword">ID</code>。词法分析器不会匹配<code class="cf keyword">beginner</code>后面<code class="cf keyword">BEGIN</code>跟着
<code class="cf keyword">ID</code>匹配的输入<code class="cf keyword">ner</code>。
</p><p>
Note that lexers try to match the longest string possible for each token, meaning that input
<code class="cf keyword">beginner</code> would match only to rule <code class="cf keyword">ID</code>. The lexer would
not match <code class="cf keyword">beginner</code> as <code class="cf keyword">BEGIN</code> followed by an
<code class="cf keyword">ID</code> matching input <code class="cf keyword">ner</code>.
</p>
<p id="f_0017.html.N1085A">
有时，语言的语法完全是模棱两可的，无论多少语法重组都无法改变这一事实。例如，算术表达式的自然语法可以用两种方式解释输入，要么从左到右执行操作（如 Smalltalk 所做的那样），要么像大多数语言一样按优先顺序执行。我们将在第 5.4 节<a href="#f_0036.html.sec.precedence"><em>“</em></a><a href="#f_0036.html.sec.precedence">处理</a><code class="cf ic">1+2*3</code>中学习如何隐式指定表达式的运算符优先顺序。
<a href="#f_0036.html.sec.precedence"><em></em></a></p><p>
Sometimes the syntax for a language is just plain ambiguous and no amount of grammar
reorganization will change that fact. For example, the natural grammar for arithmetic
expressions can interpret input such as <code class="cf ic">1+2*3</code> in two ways, either by performing the
operations left to right (as Smalltalk does) or in precedence order like most languages.
We’ll learn how to implicitly specify the operator precedence order for expressions in Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>.
</p>
<p id="f_0017.html.N10863">
古老的 C 语言表现出另一种歧义，我们可以使用上下文信息（例如标识符的定义方式）来解决它。考虑代码片段
<code class="cf ic">i*j;</code>。从语法上讲，它看起来像一个表达式，但其含义或语义取决于是<code class="cf variable">i</code>类型名称还是变量。如果
<code class="cf variable">i</code>是类型名称，则代码片段不是表达式。它是将变量声明<code class="cf variable">j</code>为指向类型的指针。我们将在第 11 章<a href="#f_0067.html.chp.predicates"><em>“使用语义谓词</em></a><a href="#f_0067.html.chp.predicates">改变</a><code class="cf variable">i</code>中了解如何解决这些歧义。
<a href="#f_0067.html.chp.predicates"><em></em></a></p><p>
The venerable C language exhibits another kind of ambiguity, which we can resolve using
context information such as how an identifier is defined. Consider the code snippet
<code class="cf ic">i*j;</code>. Syntactically, it looks like an expression, but its meaning, or semantics,
depends on whether <code class="cf variable">i</code> is a type name or variable. If
<code class="cf variable">i</code> is a type name, then the snippet isn’t an expression. It’s a
declaration of variable <code class="cf variable">j</code> as a pointer to type <code class="cf variable">i</code>.
We’ll see how to resolve these ambiguities in Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>.
</p>
<p id="f_0017.html.N10888">
解析器本身仅测试输入句子的语言成员身份并构建解析树。这是至关重要的东西，但现在是时候看看语言应用程序如何使用解析树来解释或翻译输入了。
</p><p>
Parsers by themselves  test input sentences only for language membership and build a parse
tree. That’s crucial stuff, but it’s time to see how language applications use parse
trees to interpret or translate the input.
</p>

</div></div>
<div id="f_0018.html"><div>

<h2 id="f_0018.html.sec.parse-trees">2.4 使用解析树构建语言应用程序</h2><h2>2.4 Building Language Applications Using Parse Trees</h2>
<p id="f_0018.html.N10892">
要创建语言应用程序，我们必须为每个输入短语或子短语执行一些适当的代码。最简单的方法是对解析器自动创建的解析树进行操作。对树进行操作的好处是我们回到了熟悉的 Java 领域。构建应用程序时无需进一步学习 ANTLR 语法。
</p><p>
To make a language application, we have to execute some appropriate code for each input
phrase or subphrase. The easiest way to do that is to operate on the parse tree created
automatically by the parser. The nice thing about operating on the tree is that we’re back
in familiar Java territory. There’s no further ANTLR syntax to learn in order to build an
application.
</p>
<p id="f_0018.html.N10895">
首先让我们仔细看看 ANTLR 用于识别和解析树的数据结构和类名。对数据结构的了解将使未来的讨论更加具体。 
</p><p>
Let’s start by looking more closely at the data structures and class names ANTLR uses for
recognition and for parse trees. A passing familiarity with the data structures will make
future discussions more concrete. 
</p>
<p id="f_0018.html.N108A4">前面我们了解到，
词法分析器处理字符并将标记传递给解析器，解析器则检查语法并创建解析树。相应的 ANTLR 类是、、、<code class="cf class">CharStream</code>和
。
连接词法分析器和解析器的“管道”称为
。下图说明了这些类型的对象如何在内存中相互连接。<code class="cf class">Lexer</code><code class="cf class">Token</code><code class="cf class">Parser</code><code class="cf class">ParseTree</code><code class="cf class">TokenStream</code></p><p>
Earlier we learned that lexers process characters and pass tokens to the parser, which in
turn checks syntax and creates a parse tree. The corresponding ANTLR classes are <code class="cf class">CharStream</code>,
<code class="cf class">Lexer</code>, <code class="cf class">Token</code>, <code class="cf class">Parser</code>, and
<code class="cf class">ParseTree</code>. The “pipe” connecting the lexer and parser is called a
<code class="cf class">TokenStream</code>. The diagram below illustrates how objects of these types
connect to each other in memory.</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/bigpic/数据结构.png">
</div>
<p id="f_0018.html.N108C4">
这些 ANTLR 数据结构共享尽可能多的数据以减少内存需求。该图显示，解析树中的叶（标记）节点是指向标记流中的标记的容器。标记将起始和终止字符索引记录到 中
<code class="cf class">CharStream</code>，而不是复制子字符串。没有与空格字符（索引 2 和 4）关联的标记，因为我们可以假设我们的词法分析器会丢弃空格。
</p><p>
These ANTLR data structures share as much data as possible to reduce memory requirements.
The diagram shows that leaf (token) nodes in the parse tree are containers that point at
tokens in the token stream. The tokens record start and stop character indexes into the
<code class="cf class">CharStream</code>, rather than making copies of substrings. There are no tokens
associated with whitespace characters (indexes 2 and 4) since we can assume our lexer
tosses out whitespace.
</p>
<p id="f_0018.html.N108CA">
该图还显示了与子树根和叶节点相对应的
<code class="cf class">ParseTree</code>子类<code class="cf class">RuleNode</code>和
。具有熟悉的方法，例如和
，但并不特定于特定语法。为了更好地支持对特定节点内元素的访问，ANTLR
为每个规则生成一个子类。下图显示了我们的赋值语句示例的子树根的特定类，即
、和：
<code class="cf class">TerminalNode</code><code class="cf class">RuleNode</code><code class="cf methodname">getChild</code><code class="cf methodname">getParent</code><code class="cf class">RuleNode</code><code class="cf class">RuleNode</code><code class="cf class">StatContext</code><code class="cf class">AssignContext</code><code class="cf class">ExprContext</code></p><p>
The figure also shows <code class="cf class">ParseTree</code> subclasses <code class="cf class">RuleNode</code> and
<code class="cf class">TerminalNode</code> that correspond to subtree roots and leaf nodes.
<code class="cf class">RuleNode</code> has familiar methods such as <code class="cf methodname">getChild</code> and
<code class="cf methodname">getParent</code>, but <code class="cf class">RuleNode</code> isn’t specific to a particular
grammar. To better support access to the elements within specific nodes, ANTLR generates a
<code class="cf class">RuleNode</code> subclass for each rule. The following figure shows the specific
classes of the subtree roots for our assignment statement example, which are
<code class="cf class">StatContext</code>, <code class="cf class">AssignContext</code>, and <code class="cf class">ExprContext</code>:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/bigpic/stat-nodes-combined.png">
</div>
<p id="f_0018.html.N108F3">
这些被称为<span class="emph">上下文</span>对象，因为它们记录了我们所知道的有关规则如何识别短语的所有信息。每个上下文对象都知道已识别短语的开始和结束标记，并提供对该短语所有元素的访问。例如，<code class="cf class">AssignContext</code>提供方法<code class="cf methodname">ID</code>和
<code class="cf methodname">expr</code>来访问标识符节点和表达式子树。
</p><p>
These are called <span class="emph">context</span> objects because they record everything we know about the
recognition of a phrase by a rule. Each context object knows the start and stop tokens for
the recognized phrase and provides access to all of the elements of that phrase. For
example, <code class="cf class">AssignContext</code> provides methods <code class="cf methodname">ID</code> and
<code class="cf methodname">expr</code> to access the identifier node and expression subtree.
</p>
<p id="f_0018.html.N10905">
有了这种具体类型的描述，我们可以手动编写代码来执行树的深度优先遍历。在发现和完成节点时，我们可以执行任何我们想要的操作。典型的操作包括计算结果、更新数据结构或生成输出等。不过，我们可以使用 ANTLR 自动生成的树遍历机制，而不是为每个应用程序重新编写相同的树遍历样板代码。
</p><p>
Given this description of the concrete types, we could write code by hand to perform a
depth-first walk of the tree. We could perform whatever actions we wanted as we discovered
and finished nodes. Typical operations are things such as computing results, updating data
structures, or generating output. Rather than writing the same tree-walking boilerplate
code over again for each application, though, we can use the tree-walking mechanisms that
ANTLR generates automatically.
</p>

</div></div>
<div id="f_0019.html"><div>

<h2 id="f_0019.html.sec.listeners-and-visitors">2.5 分析树监听器和访问者</h2><h2>2.5 Parse-Tree Listeners and Visitors</h2>
<p id="f_0019.html.N10913">
ANTLR 在其运行时库中支持两种树遍历机制。默认情况下，ANTLR 会生成一个解析树<span class="firstuseinline">监听器</span>接口，该接口响应内置树遍历器触发的事件。监听器本身与 XML 解析器的 SAX 文档处理程序对象完全相同。SAX 监听器接收诸如<code class="cf methodname">startDocument</code>和 之类的事件通知<code class="cf methodname">endDocument</code>。监听器中的方法只是回调，例如，我们用它来响应 GUI 应用程序中的复选框单击。一旦我们了解了监听器，我们就会看到 ANTLR 如何生成遵循访问者设计模式的树遍历器。<a id="f_0019.html.FNPTR-13" href="#f_0019.html.FOOTNOTE-13">[13]</a>
</p><p>
ANTLR provides support for two tree-walking mechanisms in its runtime library. By default,
ANTLR generates a parse-tree <span class="firstuseinline">listener</span> interface that responds to
events triggered by the built-in tree walker. The listeners themselves are exactly like
SAX document handler objects for XML parsers. SAX listeners receive notification of events
like <code class="cf methodname">startDocument</code> and <code class="cf methodname">endDocument</code>. The methods in a
listener are just callbacks, such as we’d use to respond to a checkbox click in a GUI
application. Once we look at listeners, we’ll see how ANTLR can also generate tree walkers
that follow the visitor design
pattern.<a href="#f_0019.html.FOOTNOTE-13">[13]</a>
</p>
<h3>解析树监听器</h3><h3>Parse-Tree Listeners</h3>
<p id="f_0019.html.N10932">
为了遍历树并触发对侦听器的调用，ANTLR 的运行时提供了类
<code class="cf class">ParseTreeWalker</code>。为了制作语言应用程序，我们构建了一个
<code class="cf class">ParseTreeListener</code>包含应用程序特定代码的实现，该实现通常会调用更大的周围应用程序。
</p><p>
To walk a tree and trigger calls into a listener, ANTLR’s runtime provides class
<code class="cf class">ParseTreeWalker</code>. To make a language application, we build a
<code class="cf class">ParseTreeListener</code> implementation containing application-specific code that
typically calls into a larger surrounding application.
</p>
<p id="f_0019.html.N10944">
ANTLR 为每个语法生成一个子类，每个规则都有进入和退出方法。例如，<code class="cf class">ParseTreeListener</code>当遍历器遇到规则的节点时
，它会触发并传递给解析树节点。在遍历器访问完节点的所有子节点后，它会触发。下面显示的树形图显示执行深度优先遍历，用粗虚线表示。<code class="cf keyword">assign</code><code class="cf methodname">enterAssign</code><code class="cf class">AssignContext</code><code class="cf keyword">assign</code><code class="cf methodname">exitAssign</code><code class="cf class">ParseTreeWalker</code></p><p>
ANTLR generates a <code class="cf class">ParseTreeListener</code> subclass specific to each grammar with
enter and exit methods for each rule. As the walker encounters the node for rule
<code class="cf keyword">assign</code>, for example, it triggers <code class="cf methodname">enterAssign</code> and passes
it the <code class="cf class">AssignContext</code> parse-tree node. After the walker visits all children of
the <code class="cf keyword">assign</code> node, it triggers <code class="cf methodname">exitAssign</code>. The 
  tree diagram shown below shows <code class="cf class">ParseTreeWalker</code> performing a depth-first walk,
  represented by the thick dashed line.</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/bigpic/stat-listener-calls.png">
</div>
<p id="f_0019.html.N10961">它还标识了在 walk 中 
  <code class="cf class">ParseTreeWalker</code>调用规则的进入和退出方法的位置<code class="cf keyword">assign</code>。（未显示其他侦听器调用。）
  </p><p>It also identifies where in the walk 
  <code class="cf class">ParseTreeWalker</code> calls the enter and exit methods for rule <code class="cf keyword">assign</code>.
  (The other listener calls aren’t shown.)
  </p>
<p id="f_0019.html.N1096A">
  图 1 中的图表<a href="#f_0019.html.fig.stat-listener">​ParseTreeWalker<em>调用序列</em>​显示了</a>我们的语句树对侦听器进行的完整调用序列
<code class="cf class">ParseTreeWalker</code>。
</p><p>
  And the diagram in Figure 1, <a href="#f_0019.html.fig.stat-listener">​<em>ParseTreeWalker call sequence</em>​</a> shows the complete sequence of calls made to the listener by
<code class="cf class">ParseTreeWalker</code> for our statement tree.
</p>
<div class="figure" id="f_0019.html.fig.stat-listener">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/bigpic/stat-listener.png">
</div>
<div class="figurecaption">
<hr>图 1.<code class="cf class">ParseTreeWalker</code>调用序列</div>
</div>
<p id="f_0019.html.N10981">
侦听器机制的优点在于它是完全自动化的。我们不必编写解析树遍历器，并且我们的侦听器方法不必显式访问其子级。
</p><p>
The beauty of the listener mechanism is that it’s all automatic. We don’t have to write a
parse-tree walker, and our listener methods don’t have to explicitly visit their children.
</p>
<h3>分析树访问者</h3><h3>Parse-Tree Visitors</h3>
<p id="f_0019.html.N1098E">
但是，有些情况下，我们想要控制遍历本身，明确调用方法来访问子节点。Option<code class="cf commandoption">-visitor</code>要求 ANTLR 根据语法生成访问者接口，每个规则都有一个访问方法。以下是在我们的解析树上运行的熟悉的访问者模式：
</p><p>
There are situations, however, where we want to control the walk itself, explicitly
calling methods to visit children. Option <code class="cf commandoption">-visitor</code> asks
  ANTLR to generate a visitor interface from a grammar with a visit method per rule. 
  Here’s the familiar visitor pattern operating on our parse tree:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/bigpic/stat-visitor.png">
</div>
<p id="f_0019.html.N1099F">
粗虚线表示解析树的深度优先遍历。细虚线表示访问者方法中的方法调用顺序。要启动树的遍历，我们的应用程序特定代码将创建一个访问者实现并调用<code class="cf methodname">visit</code>。
</p><p>
The thick dashed line shows a depth-first walk of the parse tree.
The thin dashed lines indicate the method call sequence among the visitor
methods. To initiate a walk of the tree, our application-specific code would create a visitor implementation and call <code class="cf methodname">visit</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree tree = ... ; <em class="comment">// tree is result of parsing</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​MyVisitor v = <strong class="prompt">new</strong> MyVisitor();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​v.visit(tree);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0019.html.N109BC">
ANTLR 的访问者支持代码将<code class="cf methodname">visitStat</code>在看到根节点时调用。从那里，<code class="cf methodname">visitStat</code>实现将
<code class="cf methodname">visit</code>使用子节点作为参数调用以继续遍历。或者，
<code class="cf methodname">visitMethod</code>可以显式调用<code class="cf methodname">visitAssign</code>，等等。
</p><p>
ANTLR’s visitor support code would then call <code class="cf methodname">visitStat</code> upon seeing the
root node. From there, the <code class="cf methodname">visitStat</code> implementation would call
<code class="cf methodname">visit</code> with the children as arguments to continue the walk. Or,
<code class="cf methodname">visitMethod</code> could explicitly call <code class="cf methodname">visitAssign</code>, and so on.
</p>
<p id="f_0019.html.N109CE">
ANTLR 通过生成访问者接口并提供具有访问者方法默认实现的类，使我们比自己编写所有内容更有优势。这样，我们就不必重写接口中的每个方法，而只需专注于感兴趣的方法。我们将在第 7 章“将<a href="#f_0045.html.chp.listeners"><em>语法与特定于应用程序的代码</em></a><a href="#f_0045.html.chp.listeners">分离”<em></em></a>中了解有关访问者和侦听器的所有信息。
</p><p>
ANTLR gives us a leg up over writing everything ourselves by generating the visitor interface
and providing a class with default implementations for the visitor methods. This way, we avoid
having to override every method in the interface, letting us focus on just the methods of
interest. We’ll learn all about visitors and listeners in Chapter 7, <a href="#f_0045.html.chp.listeners">​<em>Decoupling Grammars from Application-Specific Code</em>​</a>.
</p>
<div class="sidebar" id="f_0019.html.sb.parsingTerms">
<div class="sidebar-title">解析术语</div>
<div class="sidebar-content">
<p id="f_0019.html.N109DC">
	本章介绍了一些重要的语言识别术语。
	</p><p>
	This chapter introduced a number of important language recognition terms.
	</p>
<dl>
<dt>语言</dt><dt>Language</dt>
<dd>
<p id="f_0019.html.N109E5">
  语言是一组有效的句子；句子由短语组成，短语由子短语组成，依此类推。
</p>
</dd><dd>
<p>
  A language is a set of valid sentences; sentences are composed of phrases, which are
  composed of subphrases, and so on.
</p>
</dd>
<dt>语法</dt><dt>Grammar</dt>
<dd>
<p id="f_0019.html.N109ED">
  语法正式定义了语言的语法规则。语法中的每个规则都表达了一个子短语的结构。
</p>
</dd><dd>
<p>
  A grammar formally defines the syntax rules of a language. Each rule in a grammar
  expresses the structure of a subphrase.
</p>
</dd>
<dt>语法树或解析树</dt><dt>Syntax tree or parse tree</dt>
<dd>
<p id="f_0019.html.N109F5">
这表示句子的结构，其中每个子树根为其下的元素提供一个抽象名称。子树根对应于语法规则名称。树的叶子是句子的符号或标记。
</p>
</dd><dd>
<p>
This represents the structure of the sentence where each subtree root gives an abstract name to the elements beneath it. The subtree roots correspond to grammar rule names. The leaves of the tree are symbols or tokens of the sentence.
</p>
</dd>
<dt>代币</dt><dt>Token</dt>
<dd>
<p id="f_0019.html.N109FD">
	标记是语言中的词汇符号；它们可以表示一类符号（例如“标识符”），也可以表示单个运算符或关键字。
  </p>
</dd><dd>
<p>
	A token is a vocabulary symbol in a language; these can represent a category of symbols such as “identifier” or can represent a single operator or keyword.
  </p>
</dd>
<dt>词法分析器或标记器</dt><dt>Lexer or tokenizer</dt>
<dd>
<p id="f_0019.html.N10A05">
这会将输入字符流分解为标记。词法分析器执行词法分析。
</p>
</dd><dd>
<p>
This breaks up an input character stream into tokens. A lexer performs lexical analysis.
</p>
</dd>
<dt>解析器</dt><dt>Parser</dt>
<dd>
<p id="f_0019.html.N10A0D">
解析器通过检查句子结构是否符合语法规则来检查句子是否属于特定语言。解析的最佳类比是穿越迷宫，将句子中的单词与地板上写的单词进行比较，从入口走到出口。ANTLR 生成自上而下的解析器，称为<span class="emph">ALL(*)</span>，它可以使用所有剩余的输入符号来做出决策。自上而下的解析器是面向目标的，从与最粗略的构造相关的规则开始匹配，例如<code class="cf keyword">program</code>或<code class="cf keyword">inputFile</code>。
</p>
</dd><dd>
<p>
A parser checks sentences for membership in a specific language by checking the sentence’s
structure against the rules of a grammar. The best analogy for parsing is traversing a
maze, comparing words of a sentence to words written along the floor to go from entrance
to exit. ANTLR generates top-down parsers called <span class="emph">ALL(*)</span> that can use all remaining input symbols to make decisions. Top-down parsers are goal-oriented and start matching at the rule associated with the coarsest construct, such as <code class="cf keyword">program</code> or <code class="cf keyword">inputFile</code>.
</p>
</dd>
<dt>递归下降解析器</dt><dt>Recursive-descent parser</dt>
<dd>
<p id="f_0019.html.N10A1E">
这是一种特定类型的自上而下的解析器，它为语法中的每个规则实现一个函数。  
</p>
</dd><dd>
<p>
This is a specific kind of top-down parser implemented with a function for each rule in the grammar.  
</p>
</dd>
<dt>前瞻</dt><dt>Lookahead</dt>
<dd>
<p id="f_0019.html.N10A26">
解析器使用前瞻技术，通过比较每个替代方案的起始符号来做出决策。
</p>
</dd><dd>
<p>
Parsers use lookahead to make decisions by comparing the symbols that begin each alternative.
</p>
</dd>
</dl>
</div>
</div>
<p id="f_0019.html.N10A29">
现在，我们已经有了大致的了解。我们查看了从字符流到解析树的总体数据流，并确定了 ANTLR 运行时中的关键类名。我们刚刚看到了用于将解析器与特定于应用程序的代码连接起来的侦听器和访问者机制的摘要。让我们在下一章中通过一个真实的例子来使这一切更加具体。
</p><p>
So, now we have the big picture. We looked at the overall data flow from character stream
to parse tree and identified the key class names in the ANTLR runtime. And we just saw a
summary of the listener and visitor mechanisms used to connect parsers with
application-specific code. Let’s make this all more concrete by working through a real
example in the next chapter.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0019.html.FOOTNOTE-13" href="#f_0019.html.FNPTR-13">[13]</a>
</td>
<td>
<p id="f_0019.html.N1092A">
<a href="http://en.wikipedia.org/wiki/Visitor_pattern">http://en.wikipedia.org/wiki/Visitor_pattern</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Visitor_pattern">http://en.wikipedia.org/wiki/Visitor_pattern</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0020.html"><div>

<h1 class="chapter-title" id="f_0020.html.chp.starter">
<span class="chapter-number">
	      第三章</span>
<br><br>
<span class="chapter-name">入门级 ANTLR 项目</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      3</span>
<br><br>
<span class="chapter-name">A Starter ANTLR Project</span>
</h1>

<p id="f_0020.html.N10A35">

对于我们的第一个项目，让我们为 C 的一个小子集或其衍生语言之一（如 Java）构建一个语法。特别是，让我们识别可能嵌套在大括号（如<code class="cf ic">{1, 2, 3}</code>和 ）中的整数<code class="cf ic">{1, {2, 3}, 4}</code>。这些构造可以是
<code class="cf keyword">int</code>数组或<code class="cf keyword">struct</code>   初始化器。此语法的语法在各种情况下都会派上用场。首先，我们可以使用它为 C 构建一个源代码重构工具，如果所有初始化值都适合一个字节，则将整数数组转换为字节数组。我们还可以使用此语法将初始化的 Java 短数组转换为字符串。例如，我们可以转换以下内容：
</p><p>

For our first project, let’s build a grammar for a tiny subset of C or one of its
derivatives like Java. In particular, let’s recognize integers in, possibly nested, curly
braces like <code class="cf ic">{1, 2, 3}</code> and <code class="cf ic">{1, {2, 3}, 4}</code>. These constructs could be
<code class="cf keyword">int</code> array  or <code class="cf keyword">struct</code>   initializers. A grammar for this syntax would come in handy in a variety of situations. For one, we could use it to build a source code refactoring tool
for C that converted integer arrays to byte arrays if all of the initialized values fit
within a byte. We could also use this grammar to convert initialized Java short arrays to
strings. For example, we could transform the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">static</strong> <strong class="prompt">short</strong>
<strong class="prompt">[]</strong> data = {1,2,3};​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0020.html.N10A70">
转换为具有 Unicode 常量的以下等效字符串：
</p><p>
into the following equivalent string with Unicode constants:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">static</strong> <strong class="prompt">String</strong> data = <em class="string">"\u0001\u0002\u0003"</em>; <em class="comment">// Java char are unsigned short</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0020.html.N10A89">
其中 Unicode 字符说明符（例如<code class="cf ic">\u0001</code>）使用四个十六进制数字来表示 16 位字符值，即<code class="cf keyword">short</code>。
</p><p>
where Unicode character specifiers, such as <code class="cf ic">\u0001</code>, use four hexadecimal digits
representing a 16-bit character value, that is, a <code class="cf keyword">short</code>.
</p>
<p id="f_0020.html.N10A92">
我们之所以要进行这种转换，可能是为了克服 Java
<code class="cf fileextension">class</code>文件格式的限制。Java 类文件将数组初始化器存储为显式数组元素初始化器序列（相当于）
 <code class="cf ic">data[0]=1; data[1]=2; data[2]=3;</code>，而不是紧凑的打包字节块。<a id="f_0020.html.FNPTR-14" href="#f_0024.html.FOOTNOTE-14">[14]</a>由于 Java 限制了初始化方法的大小，因此它限制了我们可以初始化的数组的大小。相比之下，Java 类文件将字符串存储为连续的短序列。将数组初始化器转换为字符串可使类文件更紧凑，并避免 Java 的初始化方法大小限制。
</p><p>
The reason we might want to do this translation is to overcome a limitation in the Java
<code class="cf fileextension">class</code> file format. A Java class file stores array
initializers as a sequence of explicit array-element initializers, equivalent to
<code class="cf ic">data[0]=1; data[1]=2; data[2]=3;</code>, instead of a compact block of packed
bytes.<a href="#f_0024.html.FOOTNOTE-14">[14]</a> Because Java
limits the size of initialization methods, it limits the size of the arrays we can
initialize. In contrast, a Java class file stores a string as a contiguous sequence of
shorts. Converting array initializers to strings results in a more compact class file and
avoids Java’s initialization method size limit.
</p>
<p id="f_0020.html.N10AA3">
通过完成这个入门示例，您将学到一些 ANTLR 语法句法、ANTLR 从语法中生成的内容、如何将生成的解析器合并到 Java 应用程序中，以及如何使用解析树监听器构建转换器。
</p><p>
By working through this starter example, you’ll learn a bit of ANTLR grammar syntax, what
ANTLR generates from a grammar, how to incorporate the generated parser into a Java
application, and how to build a translator with a parse-tree listener.
</p>

</div></div>
<div id="f_0021.html"><div>

<h2 id="f_0021.html.sec.fjfj">3.1 ANTLR 工具、运行时和生成的代码</h2><h2>3.1 The ANTLR Tool, Runtime, and Generated Code</h2>
<p id="f_0021.html.N10AAE">
首先，让我们先来看看 ANTLR 的 jar 内部。有两个关键的 ANTLR 组件：ANTLR 工具本身和 ANTLR 运行时（解析时）API。当我们说“在语法上运行 ANTLR”时，我们指的是运行 ANTLR 工具类
<code class="cf class">org.antlr.v4.Tool</code>。运行 ANTLR 会生成代码（解析器和词法分析器），用于识别语法所描述的语言中的句子。词法分析器将输入的字符流分解为标记，并将它们传递给检查语法的解析器。运行时是生成的代码所需的类和方法的库，例如
<code class="cf class">Parser</code>、<code class="cf class">Lexer</code>和<code class="cf class">Token</code>。首先，我们在语法上运行 ANTLR，然后根据 jar 中的运行时类编译生成的代码。最终，编译后的应用程序与运行时类一起运行。
</p><p>
To get started, let’s peek inside ANTLR’s jar. There are two key ANTLR components: the
ANTLR tool itself and the ANTLR runtime (parse-time) API. When we say “run ANTLR on a
grammar,” we’re talking about running the ANTLR tool, class
<code class="cf class">org.antlr.v4.Tool</code>. Running ANTLR generates code (a parser and a lexer) that
recognizes sentences in the language described by the grammar. A lexer breaks up an input
stream of characters into tokens and passes them to a parser that checks the syntax. The
runtime is a library of classes and methods needed by that generated code such as
<code class="cf class">Parser</code>, <code class="cf class">Lexer</code>, and <code class="cf class">Token</code>. First we run ANTLR
on a grammar and then compile the generated code against the runtime classes in the jar.
Ultimately, the compiled application runs in conjunction with the runtime classes.
</p>
<p id="f_0021.html.N10AC2">构建语言应用程序的第一步是创建描述语言句法规则（有效句子集）的语法。我们将在第 5 章“<a href="#f_0032.html.chp.structures">设计<em>语法”</em>中学习如何编写语法，</a>但目前，这里有一个可以满足我们需求的语法：
</p><p> The first step to building a language application is to
create a grammar that describes a language’s syntactic rules (the set of valid sentences).
We’ll learn how to write grammars in Chapter 5, <a href="#f_0032.html.chp.structures">​<em>Designing Grammars</em>​</a>, but for the moment,
here’s a grammar that’ll do what we want:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/starter/ArrayInit.g4">启动器/ArrayInit.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Grammars always start with a grammar header. This grammar is called</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  ArrayInit and must match the filename: ArrayInit.g4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> ArrayInit;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** A rule called init that matches comma-separated values between {...}. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">init</strong>  : <em class="string">'{'</em> value (<em class="string">','</em> value)* <em class="string">'}'</em> ;  <em class="comment">// must match at least one value</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** A value can be either a nested array/struct or a simple integer (INT) */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​value : <strong class="prompt">init</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// parser rules start with lowercase letters, lexer rules with uppercase</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;             <em class="comment">// Define token INT as one or more digits</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\r\n]+ -&gt; skip ; <em class="comment">// Define whitespace rule, toss it out</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0021.html.N10B1B">
我们将语法文件放在<code class="cf filename">ArrayInit.g4</code>它自己的目录中，例如
<code class="cf filename">/tmp/array</code>（通过剪切和粘贴或从本书网站下载源代码）。然后，我们可以在语法文件上运行 ANTLR（工具）。
</p><p>
Let’s put grammar file <code class="cf filename">ArrayInit.g4</code> in its own directory, such as
<code class="cf filename">/tmp/array</code> (by cutting and pasting or downloading the source code from
the book website). Then, we can run ANTLR (the tool) on the grammar file.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cd /tmp/array</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 ArrayInit.g4  </strong>
<em class="comment"># Generate parser and lexer using antlr4 alias</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0021.html.N10B3B">
从语法来看<code class="cf filename">ArrayInit.g4</code>，ANTLR 生成了许多我们通常必须手写的文件。
</p><p>
From grammar <code class="cf filename">ArrayInit.g4</code>, ANTLR generates lots of files that we’d
normally have to write by hand.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/安装/工具-gen.png">
</div>
<p id="f_0021.html.N10B50">
此时，我们只是想了解开发过程的要点，因此这里对生成的文件进行简要描述：
</p><p>
At this point, we’re just trying to get the gist of the development process, so here’s a
quick description of the generated files:
</p>
<dl>
<dt>
<code class="cf filename">ArrayInitParser.java</code>
</dt><dt>
<code class="cf filename">ArrayInitParser.java</code>
</dt>
<dd>
<p id="f_0021.html.N10B5A">
该文件包含特定于语法的解析器类定义<code class="cf class">ArrayInit</code>，可识别我们的数组语言语法。
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ArrayInitParser <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> { ... }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0021.html.N10B77">
它包含语法中每个规则的方法以及一些支持代码。
</p>
</dd><dd>
<p>
This file contains the parser class definition specific to grammar <code class="cf class">ArrayInit</code> that recognizes our array language syntax.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ArrayInitParser <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> { ... }​</code>​</div>
</td>
</tr>
</tbody></table>
<p>
It contains a method for each rule in the grammar as well as some support code.
</p>
</dd>
<dt>
<code class="cf filename">ArrayInitLexer.java</code>
</dt><dt>
<code class="cf filename">ArrayInitLexer.java</code>
</dt>
<dd>
<p id="f_0021.html.N10B80">
ANTLR 会自动从我们的语法中提取单独的解析器和词法分析器规范。此文件包含词法分析器类定义，它是 ANTLR 通过分析词汇规则<code class="cf keyword">INT</code>和<code class="cf keyword">WS</code>以及语法文字<code class="cf ic">’{’</code>、<code class="cf ic">’,’</code>和生成的<code class="cf ic">’}’</code>。回想一下，词法分析器将输入标记化，将其分解为词汇符号。以下是类大纲：
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ArrayInitLexer <strong class="prompt">extends</strong> Lexer { ... }​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
ANTLR automatically extracts a separate parser and lexer specification from our grammar. This file contains the lexer class definition, which ANTLR generated by analyzing the lexical rules <code class="cf keyword">INT</code> and <code class="cf keyword">WS</code> as well as the grammar literals <code class="cf ic">’{’</code>, <code class="cf ic">’,’</code>, and <code class="cf ic">’}’</code>.  Recall that the lexer tokenizes the input, breaking it up into vocabulary symbols. Here’s the class outline:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ArrayInitLexer <strong class="prompt">extends</strong> Lexer { ... }​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf filename">ArrayInit.tokens</code>
</dt><dt>
<code class="cf filename">ArrayInit.tokens</code>
</dt>
<dd>
<p id="f_0021.html.N10BAC">
ANTLR 为我们定义的每个标记分配一个标记类型编号，并将这些值存储在此文件中。当我们将大型语法拆分为多个较小的语法时，需要这样做，以便 ANTLR 可以同步所有标记类型编号。请参阅<a href="#f_0026.html.sec.tour-importing">​导入<em>语法</em></a>​。
</p>
</dd><dd>
<p>
ANTLR assigns a token type number to each token we define and stores these values in this file. It’s needed when we split a large grammar into multiple smaller grammars so that ANTLR can synchronize all the token type numbers. See <a href="#f_0026.html.sec.tour-importing">​<em>Importing Grammars</em>​</a>.
</p>
</dd>
<dt>
<code class="cf filename">ArrayInitListener.java</code>，<code class="cf filename">ArrayInitBaseListener.java</code>
</dt><dt>
<code class="cf filename">ArrayInitListener.java</code>, <code class="cf filename">ArrayInitBaseListener.java</code>
</dt>
<dd>
<p id="f_0021.html.N10BBB">
默认情况下，ANTLR 解析器会根据输入构建一棵树。通过遍历该树，树遍历器可以向我们提供的侦听器对象触发“事件”（回调）。
<code class="cf class">ArrayInitListener</code>是描述我们可以实现的回调的接口。<code class="cf class">ArrayInitBaseListener</code>是一组空的默认实现。此类使我们可以轻松地覆盖我们感兴趣的回调。（请参阅第 7.2 节“<a href="#f_0047.html.sec.listeners"><em>使用解析树侦听器</em></a><a href="#f_0047.html.sec.listeners">实现。<em></em></a> ）ANTLR 还可以使用
<code class="cf commandoption">-visitor</code>命令行选项为我们生成树访问者。（请参阅<a href="#f_0050.html.sec.visitors"><em>使用访问者</em></a><a href="#f_0050.html.sec.visitors">遍历。<em></em></a> ）
</p>
</dd><dd>
<p>
By default, ANTLR parsers build a tree from the input. By walking that tree, a tree walker
can fire “events” (callbacks) to a listener object that we provide.
<code class="cf class">ArrayInitListener</code> is the interface that describes the callbacks  we can
implement. <code class="cf class">ArrayInitBaseListener</code> is a set of empty default implementations.
This class makes it easy for us to override just the callbacks we’re interested in. (See
Section 7.2, <a href="#f_0047.html.sec.listeners">​<em>Implementing Applications with Parse-Tree Listeners</em>​</a>.) ANTLR can also generate tree visitors for us with the
<code class="cf commandoption">-visitor</code> command-line option. (See <a href="#f_0050.html.sec.visitors">​<em>Traversing Parse Trees with Visitors</em>​</a>.)
</p>
</dd>
</dl>
<p id="f_0021.html.N10BCD">
我们将使用侦听器类将<code class="cf keyword">short</code>数组初始值设定项转换为<code class="cf class">String</code>对象（抱歉使用了双关语），但首先让我们验证我们的解析器是否正确匹配某些示例输入。
</p><p>
We’ll use the listener classes to translate <code class="cf keyword">short</code> array initializers
to <code class="cf class">String</code> objects shortly (sorry about the pun), but first let’s verify
that our parser correctly matches some sample input.
</p>
<div class="sidebar">
<div class="sidebar-title">ANTLR 语法比正则表达式更强大</div>
<div class="sidebar-content">
<p id="f_0021.html.N10BDA"><a id="f_0021.html.FNPTR-15" href="#f_0024.html.FOOTNOTE-15">熟悉正则表达式[15]</a>
	的人
可能会想知道 ANTLR 对于如此简单的识别问题是否有点小题大做。事实证明，由于嵌套的初始化器，我们无法使用正则表达式来识别初始化。正则表达式没有记忆，因为它们无法记住它们在输入中之前匹配的内容。因此，它们不知道如何匹配左花括号和右花括号。我们将在<a href="#f_0035.html.sec.nested-phrase">“模式<em>：嵌套短语”</em></a>中更详细地介绍这一点。
	</p><p>
	Those of you familiar with regular
expressions<a href="#f_0024.html.FOOTNOTE-15">[15]</a>
might be wondering if ANTLR is overkill for such a simple recognition problem. It turns
out that we can’t use regular expressions to recognize initializations because of
nested initializers. Regular expressions have no memory in the sense that they
can’t remember what they matched earlier in the input. Because of that, they don’t
know how to match up left and right curlies. We’ll get to this in more detail in <a href="#f_0035.html.sec.nested-phrase">​<em>Pattern: Nested Phrase</em>​</a>.
	</p>
</div>
</div>

</div></div>
<div id="f_0022.html"><div>

<h2 id="f_0022.html.sec.testing-parser">3.2 测试生成的解析器</h2><h2>3.2 Testing the Generated Parser</h2>
<p id="f_0022.html.N10BF1">
一旦我们在语法上运行了 ANTLR，我们就需要编译生成的 Java 源代码。我们只需编译<code class="cf dir">/tmp/array</code>目录中的所有内容即可完成此操作。
</p><p>
Once we’ve run ANTLR on our grammar, we need to compile the generated Java source code. We can do that by simply compiling everything in our <code class="cf dir">/tmp/array</code> directory.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cd /tmp/array</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac *.java     </strong>
<em class="comment"># Compile ANTLR-generated code</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0022.html.N10C14">
如果<code class="cf class">ClassNotFoundException</code>编译器出现错误，则意味着您可能没有正确设置 Java <code class="cf keyword">CLASSPATH</code>。在 UNIX 系统上，您需要执行以下命令（并可能将其添加到启动脚本中，例如<code class="cf filename">.bash_profile</code>）：
</p><p>
If you get a <code class="cf class">ClassNotFoundException</code> error from the compiler, that means you  probably haven’t set the Java <code class="cf keyword">CLASSPATH</code> correctly. On UNIX systems, you’ll need to execute the following command (and likely add to your start-up script such as <code class="cf filename">.bash_profile</code>):
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">export CLASSPATH=".:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH"</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0022.html.N10C2F">
为了测试我们的语法，我们使用了上一章中看到的
<code class="cf class">TestRig</code>via 别名
。下面是如何打印出词法分析器创建的标记：<code class="cf commandname">grun</code></p><p>
To test our grammar, we use the <code class="cf class">TestRig</code> via alias
<code class="cf commandname">grun</code> that we saw in the previous chapter. Here’s how to print out the
tokens created by the lexer:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun ArrayInit init -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{99, 3, 451}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:0='{',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,1:2='99',&lt;4&gt;,1:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,3:3=',',&lt;2&gt;,1:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,5:5='3',&lt;4&gt;,1:5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,6:6=',',&lt;2&gt;,1:6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,8:10='451',&lt;4&gt;,1:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,11:11='}',&lt;3&gt;,1:11]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,13:12='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0022.html.N10C71">
在输入数组初始化器之后<code class="cf ic">{99, 3, 451}</code>，我们必须在一行上
点击<small><sup>E</sup></small><small> <small>​O</small> <sub>​F</sub><sup></sup><small></small><sub></sub></small> ​​[<a id="f_0022.html.FNPTR-16" href="#f_0024.html.FOOTNOTE-16"> 16] 。默认情况下，ANTLR 会在处理之前加载整个输入。（这是最常见的情况，也是最有效的。）</a></p><p>
After typing in array initializer <code class="cf ic">{99, 3, 451}</code>, we have to hit
​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​<a href="#f_0024.html.FOOTNOTE-16">[16]</a> on a line by itself. By default, ANTLR loads the entire input before processing. (That’s the most common case and the most efficient.)
</p>
<p id="f_0022.html.N10C90">
输出的每一行代表一个标记，并显示我们所知道的有关该标记的所有信息。例如，<code class="cf ic">[@5,8:10=’451’,&lt;4&gt;,1:8]</code>表示它是索引 5 处的标记（从 0 开始索引），从字符位置 8 到 10（从 0 开始包含），具有文本<code class="cf ic">451</code>，标记类型为 4（<code class="cf keyword">INT</code>），位于第 1 行（从 1 开始），并且位于字符位置 8（从零开始并将制表符算作一个字符）。请注意，空格和换行符没有标记。
<code class="cf keyword">WS</code>由于指令，我们的语法中的规则将它们丢弃<code class="cf ic">-&gt; skip</code>
。
</p><p>
Each line of the output represents a single token and shows everything we know about the
token. For example, <code class="cf ic">[@5,8:10=’451’,&lt;4&gt;,1:8]</code> indicates that it’s the token at
index 5 (indexed from 0), goes from character position 8 to 10 (inclusive starting from 0),
has text <code class="cf ic">451</code>, has token type 4 (<code class="cf keyword">INT</code>), is on line 1 (from 1), and
is at character position 8 (starting from zero and counting tabs as a single character).
Notice that there are no tokens for the space and newline characters. Rule
<code class="cf keyword">WS</code> in our grammar tosses them out because of the <code class="cf ic">-&gt; skip</code>
directive.
</p>
<p id="f_0022.html.N10CA5">
要了解有关解析器如何识别输入的更多信息，我们可以使用选项请求解析树<code class="cf commandoption">-tree</code>。
</p><p>
To learn more about how the parser recognized the input, we can ask for the parse tree
with the <code class="cf commandoption">-tree</code> option.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun ArrayInit init -tree</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{99, 3, 451}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(init { (value 99) , (value 3) , (value 451) })​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0022.html.N10CD4">
选项以类似 LISP 的文本形式 ( <span class="emph">root </span><span class="emph">children</span> )
<code class="cf commandoption">-tree</code>打印出解析树。或者，我们可以使用该选项在对话框中可视化树。尝试使用一组嵌套的整数作为输入：。
<span class="emph"></span>&nbsp;<span class="emph"></span><code class="cf commandoption">-gui</code><code class="cf ic">{1,{2,3},4}</code></p><p>
Option <code class="cf commandoption">-tree</code> prints out the parse tree  in LISP-like text
form (<span class="emph">root</span>&nbsp;<span class="emph">children</span>). Or, we can use the
<code class="cf commandoption">-gui</code> option to visualize the tree in a dialog box.  Try it with a nested group of integers as input: <code class="cf ic">{1,{2,3},4}</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun ArrayInit init -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{1,{2,3},4}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0022.html.N10D06">
这是弹出的解析树对话框：
</p><p>
Here’s the parse tree dialog box that pops up:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/安装/ArrayInit-parse-tree.png">
</div>
<p id="f_0022.html.N10D0E">
用英语来说，解析树的意思是：“输入是一个初始化器，它由三个值组成，并用花括号括起来。第一个和第三个值是整数<code class="cf ic">1</code>和<code class="cf ic">4</code>。第二个值本身是一个初始化器，它由两个值组成，并用花括号括起来。这两个值是整数<code class="cf ic">2</code>和<code class="cf ic">3</code>。”
</p><p>
In English, the parse tree says, “The input is an initializer with three values surrounded
by curly braces. The first and third values are the integers <code class="cf ic">1</code> and <code class="cf ic">4</code>.
The second value is itself an initializer with two values surrounded by curly braces. Those
values are integers <code class="cf ic">2</code> and <code class="cf ic">3</code>.”
</p>
<p id="f_0022.html.N10D1D">
这些内部节点<code class="cf keyword">init</code>和<code class="cf keyword">value</code>非常方便，因为它们通过名称识别所有不同的输入元素。这有点像识别英语句子中的动词和主语。最好的部分是，ANTLR 会根据语法中的规则名称自动为我们创建该树。我们将在本章末尾基于此语法构建一个翻译器，使用内置的树遍历器来触发像<code class="cf methodname">enterInit</code>和这样的回调<code class="cf methodname">enterValue</code>。
</p><p>
Those interior nodes, <code class="cf keyword">init</code> and <code class="cf keyword">value</code>, are really
handy because they identify all of the various input elements by name. It’s kind of like
identifying the verb and subject in an English sentence. The best part is that ANTLR creates
that tree automatically for us based upon the rule names in our grammar. We’ll build a
translator based on this grammar at the end of this chapter using a built-in tree walker to
trigger callbacks like <code class="cf methodname">enterInit</code> and <code class="cf methodname">enterValue</code>.
</p>
<p id="f_0022.html.N10D35">
现在我们可以在语法上运行 ANTLR 并对其进行测试，现在是时候考虑如何从 Java 应用程序中调用这个解析器了。
</p><p>
Now that we can run ANTLR on a grammar and test it, it’s time to think about how to call
this parser from a Java application.
</p>

</div></div>
<div id="f_0023.html"><div>

<h2 id="f_0023.html.sec.boilerplate">3.3 将生成的解析器集成到 Java 程序中</h2><h2>3.3 Integrating a Generated Parser into a Java Program</h2>
<p id="f_0023.html.N10D3D">
一旦我们对语法有了良好的开端，我们就可以将 ANTLR 生成的代码集成到更大的应用程序中。在本节中，我们将介绍一个简单的 Java ，它调用我们的初始化解析器并打印出像选项一样的
<code class="cf methodname">main</code>解析树。这是一个样板
文件，它体现了我们在第 2.1 节“<a href="#f_0015.html.sec.terms">让</a><a href="#f_0015.html.sec.terms"><em>我们获取元数据！”</em></a>中看到的整体识别器数据流：
<code class="cf class">TestRig</code><code class="cf commandoption">-tree</code><code class="cf filename">Test.java</code><a href="#f_0015.html.sec.terms"><em></em></a></p><p>
Once we have a good start on a grammar, we can integrate the ANTLR-generated code into a
larger application. In this section, we’ll look at a simple Java <code class="cf methodname">main</code> that
invokes our initializer parser and prints out the parse tree like <code class="cf class">TestRig</code>’s
<code class="cf commandoption">-tree</code> option. Here’s a boilerplate
<code class="cf filename">Test.java</code> file that embodies the overall recognizer data flow we saw in Section 2.1, <a href="#f_0015.html.sec.terms">​<em>Let’s Get Meta!</em>​</a>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/starter/Test.java">启动器/测试.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// import ANTLR's runtime libraries</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.tree.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> Test {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">void</strong> main(<strong class="prompt">String</strong>
<strong class="prompt">[]</strong> args) <strong class="prompt">throws</strong> Exception {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a CharStream that reads from standard input</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRInputStream(<strong class="prompt">System</strong>.in);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a lexer that feeds off of input CharStream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ArrayInitLexer lexer = <strong class="prompt">new</strong> ArrayInitLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a buffer of tokens pulled from the lexer</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a parser that feeds off the tokens buffer</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ArrayInitParser parser = <strong class="prompt">new</strong> ArrayInitParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ParseTree tree = parser.init(); <em class="comment">// begin parsing at init rule</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(tree.toStringTree(parser)); <em class="comment">// print LISP-style tree</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0023.html.N10DDB">
该程序使用了许多类，例如<code class="cf class">CommonTokenStream</code>和
来自 ANTLR 运行时库的类，我们将从第 4.1 节<a href="#f_0026.html.sec.tour-calc"><em>“</em></a><a href="#f_0026.html.sec.tour-calc">匹配</a><code class="cf class">ParseTree</code>开始了解更多信息。
<a href="#f_0026.html.sec.tour-calc"><em></em></a></p><p>
The program uses a number of classes like <code class="cf class">CommonTokenStream</code> and
<code class="cf class">ParseTree</code> from ANTLR’s runtime library that we’ll learn more about starting
in Section 4.1, <a href="#f_0026.html.sec.tour-calc">​<em>Matching an Arithmetic Expression Language</em>​</a>.
</p>
<p id="f_0023.html.N10DE7">
以下是编译所有内容并运行的方法<code class="cf class">Test</code>：
</p><p>
Here’s how to compile everything and run <code class="cf class">Test</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac ArrayInit*.java Test.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Test</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{1,{2,3},4}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(init { (value 1) , (value (init { (value 2) , (value 3) })) , (value 4) })​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0023.html.N10E0D">
ANTLR 解析器还会自动报告语法错误并进行恢复。例如，如果我们输入的初始化程序缺少最后的花括号，则会发生以下情况：
</p><p>
ANTLR parsers also automatically report and recover from syntax errors. For example,
here’s what happens if we enter an initializer that’s missing the final
curly brace:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Test</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{1,2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:0 missing '}' at '&lt;EOF&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(init { (value 1) , (value 2) &lt;missing '}'&gt;)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0023.html.N10E2E">
至此，我们已经了解了如何在语法上运行 ANTLR，并将生成的解析器集成到一个简单的 Java 应用程序中。不过，仅检查语法的应用程序并不那么令人印象深刻，因此让我们通过构建一个将
<code class="cf keyword">short</code>数组初始化器转换为<code class="cf class">String</code>对象的转换器来结束。
</p><p>
At this point, we’ve seen how to run ANTLR on a grammar and integrate the generated parser
into a trivial Java application. An application that merely checks syntax is not that
impressive, though, so let’s finish up by building a translator that converts
<code class="cf keyword">short</code> array initializers to <code class="cf class">String</code> objects.
</p>

</div></div>
<div id="f_0024.html"><div>

<h2 id="f_0024.html.N10E3D">3.4 构建语言应用程序</h2><h2>3.4 Building a Language Application</h2>
<p id="f_0024.html.N10E41">
继续我们的数组初始化器示例，我们的下一个目标是翻译而不仅仅是识别初始化器。例如，让我们将 Java<code class="cf keyword">short</code>数组翻译<code class="cf ic">{99 , 3 , 451 }</code>为<code class="cf ic">"\u0063\u0003\u01c3"</code>63 是十进制数 99 的十六进制表示。
</p><p>
Continuing with our array initializer example, our next goal is to translate not just
recognize initializers. For example, let’s translate Java <code class="cf keyword">short</code> arrays
like <code class="cf ic">{99 , 3 , 451 }</code> to <code class="cf ic">"\u0063\u0003\u01c3"</code> where 63 is the hexadecimal
representation of the 99 decimal.
</p>
<p id="f_0024.html.N10E4D">
要使应用程序变得面目全非，就必须从解析树中提取数据。最简单的方法是让 ANTLR 的内置解析树遍历器在执行深度优先遍历时触发一堆回调。如前所述，ANTLR 会自动为我们生成侦听器基础结构。这些侦听器就像 GUI 小部件上的回调（例如，按钮会在按下按钮时通知我们）或 XML 解析器中的 SAX 事件。
</p><p>
To move beyond recognition, an application has to extract data from the parse tree. The
easiest way to do that is to have ANTLR’s built-in parse-tree walker trigger a bunch of
callbacks as it performs a depth-first walk. As we saw earlier, ANTLR automatically generates
a listener infrastructure for us. These listeners are like the callbacks on GUI widgets
(for example, a button would notify us upon a button press) or like SAX events in an XML parser.
</p>
<p id="f_0024.html.N10E60">
要编写一个对输入作出反应的程序，我们所要做的就是在 的子类中实现一些方法<code class="cf class">ArrayInitBaseListener</code>。基本策略是让每个侦听器方法在被树遍历器调用时打印出输入的翻译部分。
</p><p>
To write a program that reacts to the input, all we have to do is implement a few methods in
a subclass of <code class="cf class">ArrayInitBaseListener</code>. The basic strategy is to have each
listener method print out a translated piece of the input when called to do so by the tree
walker.
</p>
<p id="f_0024.html.N10E66">
侦听器机制的优点在于我们不必自己进行任何树遍历。事实上，我们甚至不必知道运行时正在遍历树来调用我们的方法。我们所知道的只是我们的侦听器会在与语法规则相关的短语的开始和结束时收到通知。正如我们将在第 7.2 节“使用解析树<a href="#f_0047.html.sec.listeners"><em>侦听器</em></a><a href="#f_0047.html.sec.listeners">实现<em></em></a>中看到的那样
<a href="#f_0047.html.sec.listeners">，</a></p><p>
The beauty of the listener mechanism is that we don’t have to do any tree walking ourselves.
In fact, we don’t even have to know that the runtime is walking a tree to call our methods.
All we know is that our listener gets notified at the beginning and end of phrases
associated with rules in the grammar. As we’ll see in Section 7.2, <a href="#f_0047.html.sec.listeners">​<em>Implementing Applications with Parse-Tree Listeners</em>​</a>, this
approach reduces how much we have to learn about ANTLR—we’re back in familiar programming
language territory for anything but phrase recognition.
</p>
<p id="f_0024.html.N10E6C">
启动翻译项目意味着要弄清楚如何将每个输入标记或短语转换为输出字符串。为此，最好手动翻译一些代表性样本，以便找出一般的短语到短语的转换。在这种情况下，翻译非常简单。
</p><p>
Starting a translation project means figuring out how to convert each input token or phrase
to an output string. To do that, it’s a good idea to manually translate a few representative
samples in order to pick out the general phrase-to-phrase conversions. In this case, the
translation is pretty straightforward.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/安装/Array-String-map.png">
</div>
<p id="f_0024.html.N10E74">
在英语中，翻译是一系列“ <span class="emph">X 变为 Y</span> ”的规则。
</p><p>
In English, the translation is a series of “<span class="emph">X goes to Y</span>” rules.
</p>
<ol>
<li>
<p id="f_0024.html.N10E7D">
	 翻譯<code class="cf ic">{</code>為<code class="cf ic">"</code>。
	</p>
</li><li>
<p>
	 Translate <code class="cf ic">{</code> to <code class="cf ic">"</code>.
	</p>
</li>
<li>
<p id="f_0024.html.N10E87">
   	 翻譯<code class="cf ic">}</code>為<code class="cf ic">"</code>。
  </p>
</li><li>
<p>
   	 Translate <code class="cf ic">}</code> to <code class="cf ic">"</code>.
  </p>
</li>
<li>
<p id="f_0024.html.N10E91">
     将整数转换为以 为前缀的四位十六进制字符串<code class="cf ic">\u</code>。
  </p>
</li><li>
<p>
     Translate integers to four-digit hexadecimal strings prefixed with <code class="cf ic">\u</code>.
  </p>
</li>
</ol>
<p id="f_0024.html.N10E97">
要编写翻译器，我们需要编写一些方法，在看到适当的输入标记或短语时打印出转换后的字符串。内置的树遍历器在看到各种短语的开头和结尾时会触发侦听器中的回调。以下是我们的翻译规则的侦听器实现：
</p><p>
To code the translator, we need to write methods that print out the converted strings
upon seeing the appropriate input token or phrase. The built-in tree walker triggers
callbacks in a listener upon seeing the beginning and end of the various phrases. Here’s a
listener implementation for our translation rules:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/starter/ShortToUnicodeString.java">启动器/ShortToUnicodeString.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Convert short array inits like {1,2,3} to "\u0001\u0002\u0003" */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ShortToUnicodeString <strong class="prompt">extends</strong> ArrayInitBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Translate { to " */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterInit(ArrayInitParser.InitContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.print(<em class="string">'"'</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Translate } to " */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitInit(ArrayInitParser.InitContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.print(<em class="string">'"'</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Translate integers to 4-digit hexadecimal strings prefixed with \\u */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterValue(ArrayInitParser.ValueContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// Assumes no nested array initializers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> value = <strong class="prompt">Integer</strong>.valueOf(ctx.INT().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.printf(<em class="string">"\\u%04x"</em>, value);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0024.html.N10F1F">
我们不需要重写每个进入/退出方法；我们只重写我们关心的方法。唯一不熟悉的表达式是<code class="cf ic">ctx.INT()</code>，它向上下文对象请求
<code class="cf keyword">INT</code>与规则调用匹配的整数标记<code class="cf keyword">value</code>。上下文对象记录规则识别过程中发生的所有事情。
</p><p>
We don’t need to override every enter/exit method; we do just the ones we care about. The only
unfamiliar expression is <code class="cf ic">ctx.INT()</code>, which asks the context object for the integer
<code class="cf keyword">INT</code> token matched by that invocation of rule <code class="cf keyword">value</code>.
Context objects record everything that happens during the recognition of a rule.
</p>
<p id="f_0024.html.N10F2E">
剩下要做的就是创建一个源自<code class="cf class">Test</code>前面显示的样板代码的翻译应用程序。
</p><p>
The only thing left to do is to create a translator application derived from the <code class="cf class">Test</code> boilerplate code shown earlier.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/starter/Translate.java">starter/Translate.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// import ANTLR's runtime libraries</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.tree.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> Translate {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">void</strong> main(<strong class="prompt">String</strong>
<strong class="prompt">[]</strong> args) <strong class="prompt">throws</strong> Exception {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a CharStream that reads from standard input</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRInputStream(<strong class="prompt">System</strong>.in);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a lexer that feeds off of input CharStream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ArrayInitLexer lexer = <strong class="prompt">new</strong> ArrayInitLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a buffer of tokens pulled from the lexer</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// create a parser that feeds off the tokens buffer</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ArrayInitParser parser = <strong class="prompt">new</strong> ArrayInitParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ParseTree tree = parser.init(); <em class="comment">// begin parsing at init rule</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// Create a generic parse tree walker that can trigger callbacks</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// Walk the tree created during the parse, trigger callbacks</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        walker.walk(<strong class="prompt">new</strong> ShortToUnicodeString(), tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(); <em class="comment">// print a \n after translation</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0024.html.N10FC4">
与样板代码的唯一区别是突出显示的部分，该部分创建了一个树遍历器并要求它遍历从解析器返回的树。当树遍历器遍历时，它会触发对我们的<code class="cf class">ShortToUnicodeString</code>侦听器的调用。 
</p><p>
The only difference from the boilerplate code is the highlighted section that creates a tree walker and asks it to walk the tree returned from the parser. As the tree walker traverses, it triggers calls into our <code class="cf class">ShortToUnicodeString</code> listener. 
</p>
<p id="f_0024.html.N10FCA">
<span class="emph">请注意：</span>为了集中我们的注意力并减少内容臃肿，本书的其余部分通常只展示重要或新颖的代码片段，而不是整个文件。如果您正在阅读本书的电子版，您可以随时单击代码片段标题；标题栏是指向网络上完整源代码的链接。您还可以在本书的网站上获取完整的源代码包。<a id="f_0024.html.FNPTR-17" href="#f_0024.html.FOOTNOTE-17">[17]</a>
</p><p>
<span class="emph">Please note:</span> To focus our attention and to reduce bloat, the remainder
of the book will typically show just the important or novel bits of code rather than entire
files. If you’re reading the electronic version of this book, you can always click the
code snippet titles; the title bars are links to the full source code on the Web. You can
also grab the full source code bundle on the book’s
website.<a href="#f_0024.html.FOOTNOTE-17">[17]</a>
</p>
<p id="f_0024.html.N10FD4">
让我们构建翻译器并在示例输入上尝试它。
</p><p>
Let’s build the translator and try it on our sample input.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac ArrayInit*.java Translate.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Translate</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{99, 3, 451}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​"\u0063\u0003\u01c3"​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0024.html.N10FF7">
成功了！我们刚刚构建了第一个翻译器，甚至无需触及语法。我们所要做的就是实现一些方法来打印适当的短语翻译。此外，我们只需传入不同的侦听器即可生成完全不同的输出。侦听器有效地将语言应用程序与语法隔离开来，使语法可供其他应用程序重用。
</p><p>
It works! We’ve just built our first translator, without even touching the grammar. All
we had to do was implement a few methods that printed the appropriate phrase translations.
Moreover, we can generate completely different output simply by passing in a different
listener. Listeners effectively isolate the language application from the grammar, making
the grammar reusable for other applications.
</p>
<p id="f_0024.html.N11000">
在下一章中，我们将快速了解 ANTLR 语法符号以及使 ANTLR 强大且易于使用的关键特性。

</p><p>
In the next chapter, we’ll take a whirlwind tour of ANTLR
grammar notation and the key features that make ANTLR powerful and easy to use.

</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0024.html.FOOTNOTE-14" href="#f_0020.html.FNPTR-14">[14]</a>
</td>
<td>
<p id="f_0024.html.N10A9C">要了解有关该主题的更多信息，请观看我的 JVM 语言峰会演示的视频：<a href="http://www.mefeedia.com/watch/24642856">http://www.mefeedia.com/watch/24642856</a>。</p><p>To learn more about this topic, check out a video of my JVM Language Summit
presentation: <a href="http://www.mefeedia.com/watch/24642856">http://www.mefeedia.com/watch/24642856</a>.</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0024.html.FOOTNOTE-15" href="#f_0021.html.FNPTR-15">[15]</a>
</td>
<td>
<p id="f_0024.html.N10BE4">
<a href="http://en.wikipedia.org/wiki/Regular_expression">http://en.wikipedia.org/wiki/Regular_expression</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Regular_expression">http://en.wikipedia.org/wiki/Regular_expression</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0024.html.FOOTNOTE-16" href="#f_0022.html.FNPTR-16">[16]</a>
</td>
<td>
<p id="f_0024.html.N10C79">
文件结束字符在 Unix 上
是<span style="background-color:rgb(230,230,250);font-family:&quot;DroidSans&quot;;color:#227">Ctrl+D ，在 Windows 上是</span><span style="background-color:rgb(230,230,250);font-family:&quot;DroidSans&quot;;color:#227">Ctrl+Z</span>。</p><p>
The end-of-file character is <span style="background-color:rgb(230,230,250); font-family:'DroidSans';color:#227">Ctrl+D</span> on Unix and
<span style="background-color:rgb(230,230,250); font-family:'DroidSans';color:#227">Ctrl+Z</span> on Windows.</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0024.html.FOOTNOTE-17" href="#f_0024.html.FNPTR-17">[17]</a>
</td>
<td>
<p id="f_0024.html.N10FD0">
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p><p>
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0025.html"><div>

<h1 class="chapter-title" id="f_0025.html.chp.tour">
<span class="chapter-number">
	      第四章</span>
<br><br>
<span class="chapter-name">快速浏览</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      4</span>
<br><br>
<span class="chapter-name">A Quick Tour</span>
</h1>

<p id="f_0025.html.N1100C">
到目前为止，我们已经学习了如何安装 ANTLR，并了解了构建语言应用程序所需的关键流程、术语和构建块。在本章中，我们将通过快速浏览一些示例来快速了解 ANTLR，这些示例说明了它的功能。为了简洁起见，我们将略过许多细节，所以如果事情不太清楚，请不要担心。目的只是让您了解 ANTLR 可以做什么。我们将从第 5 章“<a href="#f_0032.html.chp.structures">设计<em>语法”</em>开始深入了解。</a>对于那些有使用 ANTLR 以前版本经验的人来说，本章是一个很好的重新学习方法。
</p><p>
So far, we have learned how to install ANTLR and have looked at the key processes,
terminology, and building blocks needed to build a language application. In this chapter,
we’re going to take a whirlwind tour of ANTLR by racing through a number of examples that
illustrate its capabilities. We’ll be glossing over a lot of details in the interest of
brevity, so don’t worry if things aren’t crystal clear. The goal is just to get a feel for
what you can do with ANTLR. We’ll look underneath the hood starting in Chapter 5, <a href="#f_0032.html.chp.structures">​<em>Designing Grammars</em>​</a>. For those with experience using previous versions of ANTLR,
this chapter is a great way to retool.
</p>
<p id="f_0025.html.N11016">
本章分为四个广泛的主题，很好地说明了功能集。下载本书的代码<a id="f_0025.html.FNPTR-18" href="#f_0030.html.FOOTNOTE-18">[18]</a>（或点击电子书版本中的链接）并在阅读过程中完成示例是个好主意。这样，您将习惯使用语法文件和构建 ANTLR 应用程序。请记住，您在文本中看到的许多代码片段都不是完整的文件，因此我们可以专注于有趣的部分。
</p><p>
This chapter is broken down into four broad topics that nicely illustrate the feature set.
It’s a good idea to download the
code<a href="#f_0030.html.FOOTNOTE-18">[18]</a> for this book
(or follow the links in the ebook version) and work through the examples as we go along. That
way, you’ll get used to working with grammar files and building ANTLR applications. Keep in
mind that many of the code snippets you see interspersed in the text aren’t complete files
so that we can focus on the interesting bits.
</p>
<p id="f_0025.html.N11027">
首先，我们将使用一种简单的算术表达式语言的语法。我们将首先使用 ANTLR 的内置测试装置对其进行测试，然后详细了解启动解析器的样板主程序，如第 3.3 节“将<a href="#f_0023.html.sec.boilerplate"><em>生成的解析器</em></a><a href="#f_0023.html.sec.boilerplate">集成中所示。<em></em></a>然后，我们将查看表达式语法的非平凡解析树。（回想一下，解析树记录了解析器如何匹配输入短语。）对于处理非常大的语法，我们将了解如何使用 grammar 将语法拆分为可管理的块<code class="cf keyword">import</code>。接下来，我们将检查 ANTLR 生成的解析器如何响应无效输入。
</p><p>
First, we’re going to work with a grammar for a simple arithmetic expression language. We’ll
test it initially using ANTLR’s built-in test rig and then learn more about the boilerplate
main program that launches parsers shown in Section 3.3, <a href="#f_0023.html.sec.boilerplate">​<em>Integrating a Generated Parser into a Java Program</em>​</a>. Then, we’ll
look at a nontrivial parse tree for the expression grammar. (Recall that a parse tree
records how a parser matches an input phrase.) For dealing with very large grammars, we’ll
see how to split a grammar into manageable chunks using grammar <code class="cf keyword">import</code>s.
Next, we’ll check out how ANTLR-generated parsers respond to invalid input.
</p>
<p id="f_0025.html.N11030">
其次，在了解了算术表达式的解析器之后，我们将使用访问者模式构建一个遍历表达式语法解析树的计算器。ANTLR 解析器会自动生成访问者接口和空白方法实现，因此我们可以轻松上手。
</p><p>
Second, after looking at the parser for arithmetic expressions, we’ll use a visitor pattern
to build a calculator that walks expression grammar parse trees. ANTLR parsers automatically
generate visitor interfaces and blank method implementations so we can get started
painlessly.
</p>
<p id="f_0025.html.N11033">
第三，我们将构建一个转换器，它读取 Java 类定义并输出从该类中的方法派生的 Java 接口。我们的实现将使用 ANTLR 自动生成的树监听器机制。
</p><p>
Third, we’ll build a translator that reads in a Java class definition and spits out a Java
interface derived from the methods in that class. Our implementation will use the tree
listener mechanism that ANTLR also generates automatically.
</p>
<p id="f_0025.html.N11036">
第四，我们将学习如何将<span class="firstuseinline">动作</span>（任意代码）直接嵌入到语法中。大多数时候，我们可以使用访问者或侦听器构建语言应用程序，但为了获得最大的灵活性，ANTLR 允许我们将自己的特定于应用程序的代码注入到生成的解析器中。这些动作在解析期间执行，可以收集信息或生成输出，就像任何其他任意代码片段一样。结合<span class="firstuseinline">语义谓词</span>（布尔表达式），我们甚至可以使语法的某些部分在运行时消失！例如，我们可能希望
<code class="cf keyword">enum</code>在 Java 语法中打开和关闭关键字以解析语言的不同版本。如果没有语义谓词，我们将需要两个不同版本的语法。
</p><p>
Fourth, we’ll learn how to embed <span class="firstuseinline">actions</span> (arbitrary code) directly in
the grammar. Most of the time, we can build language applications with visitors or
listeners, but for the ultimate flexibility, ANTLR allows us to inject our own
application-specific code into the generated parser. These actions execute during the parse
and can collect information or generate output like any other arbitrary code snippets. In
conjunction with <span class="firstuseinline">semantic predicates</span> (Boolean expressions), we can even
make parts of our grammar disappear at runtime! For example, we might want to turn the
<code class="cf keyword">enum</code> keyword on and off in a Java grammar to parse different versions of
the language. Without semantic predicates, we’d need two different versions of the grammar.
</p>
<p id="f_0025.html.N11042">
最后，我们将在词汇（标记）级别上详细了解 ANTLR 的一些功能。我们将了解 ANTLR 如何处理包含多种语言的输入文件。然后，我们将了解一个很棒的<code class="cf class">TokenStreamRewriter</code>类，它允许我们调整、修改或以其他方式操纵标记流，而所有这些都不会干扰原始输入流。最后，我们将重新访问我们的接口生成器示例，以了解 ANTLR 如何在 Java 解析期间忽略空格和注释，但保留它们以供以后处理。
</p><p>
Finally, we’ll zoom in on a few ANTLR features at the lexical (token) level. We’ll
see how ANTLR deals with input files that contain more than one language. Then we’ll look
at the awesome <code class="cf class">TokenStreamRewriter</code> class that lets us tweak, mangle, or
otherwise manipulate token streams, all without disturbing the original input stream.
Finally, we’ll revisit our interface generator example to learn how ANTLR can ignore  whitespace and comments during Java parsing but retain them for later processing.
</p>
<p id="f_0025.html.N11048">
让我们从熟悉 ANTLR 语法符号开始我们的旅程。确保您已
定义<code class="cf commandname">antlr4</code>和<code class="cf commandname">grun</code>别名或脚本，如第 1.2 节“<a href="#f_0013.html.sec.intro_launch">执行<em>ANTLR 和测试识别器”</em></a>中所述。
</p><p>
Let’s begin our tour by getting acquainted with ANTLR grammar notation. Make sure you have the
<code class="cf commandname">antlr4</code> and <code class="cf commandname">grun</code> aliases or scripts
defined, as explained in Section 1.2, <a href="#f_0013.html.sec.intro_launch">​<em>Executing ANTLR and Testing Recognizers</em>​</a>.
</p>

</div></div>
<div id="f_0026.html"><div>

<h2 id="f_0026.html.sec.tour-calc">4.1 匹配算术表达式语言</h2><h2>4.1 Matching an Arithmetic Expression Language</h2>
<p id="f_0026.html.N11059">
对于我们的第一个语法，我们将构建一个简单的计算器。使用表达式做某事是有意义的，因为它们非常常见。为了简单起见，我们只允许使用基本算术运算符（加、减、乘、除）、​​括号表达式、整数和变量。我们还将限制为整数，而不允许使用浮点数。</p><p>
For our first grammar, we’re going to build a simple calculator. Doing something with
expressions makes sense because they’re so common. To keep things simple, we’ll  allow only
the basic arithmetic operators (add, subtract, multiply, and divide), parenthesized
expressions, integer numbers, and variables. We’ll also restrict ourselves to integers
instead of allowing floating-point numbers.</p>
<p id="f_0026.html.N11063">以下是一些说明所有语言特性的示例输入：
</p><p>Here’s some sample input that illustrates all language features:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/t.expr">旅游/t.expr</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​193​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a = 5​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​b = 6​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a+b*2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(1+2)*3​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N11082">
在英语中，我们的表达式语言中的<span class="emph">程序</span>是一系列以换行符结尾的语句。语句可以是表达式、赋值或空行。以下是 ANTLR 语法，它将为我们解析这些语句和表达式：
</p><p>
In English, a <span class="emph">program</span> in our expression language is a sequence of statements terminated by newlines. A statement is either an expression, an assignment, or a blank line. Here’s an ANTLR grammar that’ll parse those statements and expressions for us:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Expr.g4">旅游/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">1号线&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Expr;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** The start rule; begin parsing here. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   stat+ ; ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">5&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   expr NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">10&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr (<em class="string">'*'</em>|<em class="string">'/'</em>) expr   ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'+'</em>|<em class="string">'-'</em>) expr   ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">15&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;      <em class="comment">// match identifiers </em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;         <em class="comment">// match integers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">20&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NEWLINE:<em class="string">'\r'</em>? <em class="string">'\n'</em> ;     <em class="comment">// return newlines to parser (is end-statement signal)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t]+ -&gt; skip ; <em class="comment">// toss out whitespace</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N1110F">
我们不必深入探讨细节，只需看一下 ANTLR 语法符号的一些关键元素。
</p><p>
Without going into too much detail, let’s look at some of the key elements of ANTLR’s
grammar notation.
</p>
<ul>
<li>
<p id="f_0026.html.N11115">语法由一组描述语言句法的规则组成。有用于描述句法结构的规则（如和<code class="cf keyword">stat</code>），<code class="cf keyword">expr</code>   也有用于描述词汇符号（标记）的规则（如标识符和整数）。
	</p>
</li><li>
<p> Grammars consist of a set of rules that describe language syntax. There are rules for syntactic structure like <code class="cf keyword">stat</code> and <code class="cf keyword">expr</code>   as well as rules for vocabulary symbols (tokens) such as identifiers and integers.
	</p>
</li>
<li>
<p id="f_0026.html.N1111F">
   	 以小写字母开头的规则构成解析器规则。
  </p>
</li><li>
<p>
   	 Rules starting with a lowercase letter comprise the parser rules.
  </p>
</li>
<li>
<p id="f_0026.html.N11123">
  以大写字母开头的规则构成词汇（标记）规则。
  </p>
</li><li>
<p>
  Rules starting with an uppercase letter comprise the lexical (token) rules.
  </p>
</li>
<li>
<p id="f_0026.html.N11127">
   	我们用运算符将​​规则的选项分开<code class="cf ic">|</code>，并且可以用括号将符号分组为<span class="firstuseinline">子规则</span>。例如，子规则<code class="cf ic">(’*’|’/’)</code>匹配乘法符号或除法符号。
  </p>
</li><li>
<p>
   	We separate the alternatives of a rule with the <code class="cf ic">|</code> operator, and we can group
    symbols with parentheses into <span class="firstuseinline">subrules</span>. For example,
    subrule <code class="cf ic">(’*’|’/’)</code> matches either a multiplication symbol or a division symbol.
  </p>
</li>
</ul>
<p id="f_0026.html.N11134">
当我们进入第 5 章<a href="#f_0032.html.chp.structures">“设计<em>语法”</em></a>时，我们将详细讨论所有这些内容。
</p><p>
We’ll tackle all of this stuff in detail when we get to Chapter 5, <a href="#f_0032.html.chp.structures">​<em>Designing Grammars</em>​</a>.
</p>
<p id="f_0026.html.N1113A">
ANTLR v4 最重要的新功能之一是它能够处理（大多数类型的）左递归规则。左递归规则是在替代项开始时调用自身的规则。例如，在此语法中，规则<code class="cf keyword">expr</code>在第 11 行和第 12 行有替代项，它们在左边缘递归调用<code class="cf keyword">expr</code>。以这种方式指定算术表达式符号比典型的自上而下的解析器策略所需的要容易得多。在该策略中，我们需要多个规则，每个运算符优先级一个。有关此功能的更多信息，请参见第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em></a>。
</p><p>
One of ANTLR v4’s most significant new features is its ability to handle (most kinds of)
left-recursive rules. A left-recursive rule is one that invokes itself at the start of an
alternative. For example, in this grammar, rule <code class="cf keyword">expr</code> has alternatives on
lines 11 and 12 that
recursively invoke <code class="cf keyword">expr</code> on the left edge. Specifying arithmetic
expression notation this way is dramatically easier than what we’d need for the typical
top-down parser strategy. In that strategy, we’d need multiple rules, one for each operator
precedence level. For more on this feature, see Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>.
</p>
<p id="f_0026.html.N11154">
具有正则表达式经验的人应该熟悉标记定义的符号。我们将在第 6 章“<a href="#f_0039.html.chp.examples">探索<em>一些真正的语法”</em>中介绍许多词汇（标记）规则。</a>唯一不寻常的语法是<code class="cf ic">-&gt; skip</code>对<code class="cf keyword">WS</code>
空格规则的操作。它是一个指令，告诉词法分析器匹配但丢弃空格。（每个可能的输入字符都必须至少与一条词汇规则匹配。）我们避免将语法与特定的目标语言绑定在一起，方法是使用正式的 ANTLR 符号，而不是在语法中使用任意代码片段来告诉词法分析器跳过。
</p><p>
The notation for the token definitions should be familiar to those with regular expression
experience. We’ll look at lots of lexical (token) rules in Chapter 6, <a href="#f_0039.html.chp.examples">​<em>Exploring Some Real Grammars</em>​</a>.
The only unusual syntax is the <code class="cf ic">-&gt; skip</code> operation on the <code class="cf keyword">WS</code>
whitespace rule. It’s a directive that tells the lexer to match but throw out whitespace.
(Every possible input character must be matched by at least one lexical rule.) We avoid
tying the grammar to a specific target language by using formal ANTLR notation instead of an
arbitrary code snippet in the grammar that tells the lexer to skip.
</p>
<p id="f_0026.html.N11165">
好的，让我们来<code class="cf class">Expr</code>一场语法之旅。<code class="cf filename">tour/Expr.g4</code>如果您正在查看电子书版本，可以通过单击上一个代码清单上的链接来下载，或者将语法剪切并粘贴到名为的文件中
<code class="cf filename">Expr.g4</code>。
</p><p>
OK, let’s take grammar <code class="cf class">Expr</code> out for a joy ride. Download it either by
clicking the <code class="cf filename">tour/Expr.g4</code> link on the previous code listing, if you’re
viewing the ebook version, or by cutting and pasting the grammar into a file called
<code class="cf filename">Expr.g4</code>.
</p>
<p id="f_0026.html.N11177">
测试语法最简单的方法是使用内置的<code class="cf class">TestRig</code>，我们可以使用别名来访问它<code class="cf commandname">grun</code>。例如，这是在 Unix 机器上的构建和测试序列：
</p><p>
The easiest way to test grammars is with the built-in <code class="cf class">TestRig</code>, which we can
access using alias <code class="cf commandname">grun</code>.
For example, here is the build and test sequence on a Unix
box:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Expr.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls Expr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExprBaseListener.java   ExprListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExprLexer.java          ExprParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Expr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun Expr prog -gui t.expr </strong>
<em class="comment"># launches org.antlr.v4.runtime.misc.TestRig</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N111A9">
由于该<code class="cf commandoption">-gui</code>选项，测试装置弹出一个显示解析树的窗口，如图 2 所示。<a href="#f_0026.html.fig.Expr-gui"><em>​显示解析树的</em></a><a href="#f_0026.html.fig.Expr-gui">窗口<em></em></a>​。
</p><p>
Because of the <code class="cf commandoption">-gui</code> option, the test rig pops up a window
  showing the parse tree, as shown in Figure 2, <a href="#f_0026.html.fig.Expr-gui">​<em>Window showing the parse tree</em>​</a>.
</p>
<div class="figure" id="f_0026.html.fig.Expr-gui">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/游览/Expr-gui.png">
</div>
<div class="figurecaption">
<hr>图 2. 显示解析树的窗口</div>
</div>
<p id="f_0026.html.N111BE">
解析树类似于我们的解析器在识别输入时会跟踪的函数调用树。（ANTLR 为每条规则生成一个函数。）
</p><p>
The parse tree is analogous to the function call tree our parser would trace as it
recognizes input. (ANTLR generates a function for each rule.)
</p>
<p id="f_0026.html.N111C1">
使用测试装置开发和测试语法是可以的，但最终我们需要将 ANTLR 生成的解析器集成到应用程序中。下面给出的主程序显示了创建所有必要对象并从规则开始启动表达式语言解析器所需的代码<code class="cf keyword">prog</code>：
</p><p>
It’s OK to develop and test grammars using the test rig, but ultimately we’ll need to
integrate our ANTLR-generated parser into an application. The main program given below
shows the code necessary to create all necessary objects and launch our expression
language parser starting at rule <code class="cf keyword">prog</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/ExprJoyRide.java">旅游/ExprJoyRide.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">1号线&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.tree.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.io.FileInputStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.io.InputStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">5&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ExprJoyRide {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">void</strong> main(<strong class="prompt">String</strong>
<strong class="prompt">[]</strong> args) <strong class="prompt">throws</strong> Exception {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> inputFile = null; ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( args.length&gt;0 ) inputFile = args[0];​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">InputStream</strong> is = <strong class="prompt">System</strong>.in;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">10&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( inputFile!=null ) is = <strong class="prompt">new</strong> <strong class="prompt">FileInputStream</strong>(inputFile);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRInputStream(is); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ExprLexer lexer = <strong class="prompt">new</strong> ExprLexer(input); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ExprParser parser = <strong class="prompt">new</strong> ExprParser(tokens); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">15&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ParseTree tree = parser.prog(); <em class="comment">// parse; start at prog </em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(tree.toStringTree(parser)); <em class="comment">// print tree as text </em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N1126D">
第 7 行到第 11 行创建了词法分析器的字符输入流。第 12 行到第 14 行创建了词法分析器和解析器对象，以及它们之间的标记流“管道”。第 15 行实际上启动了解析器。（调用规则方法就像调用该规则；我们可以调用任何我们想要的解析器规则方法。）最后，第 16 行<code class="cf methodname">prog</code>以文本形式打印出规则方法返回的解析树。
</p><p>
Lines 7..11 create an input
stream of characters for the lexer. Lines 12..14 create the lexer and parser objects and a token stream “pipe”
between them. Line 15 actually launches the parser. (Calling
a rule method is like invoking that rule; we can call any parser rule method we want.)
Finally, line 16 prints out the parse tree returned from the
rule method <code class="cf methodname">prog</code> in text form.
</p>
<p id="f_0026.html.N11285">
以下是如何构建测试程序并在输入文件上运行它的方法
<code class="cf filename">t.expr</code>：
</p><p>
Here is how to build the test program and run it on input file
<code class="cf filename">t.expr</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac ExprJoyRide.java Expr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java ExprJoyRide t.expr</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(prog​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat (expr 193) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat a = (expr 5) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat b = (expr 6) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat (expr (expr a) + (expr (expr b) * (expr 2))) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat (expr (expr ( (expr (expr 1) + (expr 2)) )) * (expr 3)) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N112B3">
解析树的（稍微清理过的）文本表示不如视觉表示那么容易阅读，但它对于功能测试很有用。
</p><p>
The (slightly cleaned up) text representation of the parse tree is not as easy to read as
the visual representation, but it’s useful for functional testing.
</p>
<p id="f_0026.html.N112B6">
这个表达式语法非常小，但语法可能会达到数千行。在下一节中，我们将学习如何使如此大的语法易于管理。
</p><p>
This expression grammar is pretty small, but grammars can run into the thousands of lines.
In the next section, we’ll learn how to keep such large grammars manageable.
</p>
<h3 id="f_0026.html.sec.tour-importing">导入语法</h3><h3>Importing Grammars</h3>
<p id="f_0026.html.N112C1">
将非常大的语法分解成逻辑块是一个好主意，就像我们对软件所做的那样。一种方法是将语法拆分为解析器语法和词法分析器语法。这不是一个坏主意，因为不同语言在词汇上存在大量重叠。例如，标识符和数字在不同语言中通常是相同的。将词汇规则分解成“模块”意味着我们可以将其用于不同的解析器语法。这是一个包含所有词汇规则的词法分析器语法：
</p><p>
It’s a good idea to break up very large grammars into logical chunks, just like we do with
software. One way to do that is to split a grammar into parser and lexer grammars. That’s
not a bad idea because there’s a surprising amount of overlap between different languages
lexically. For example, identifiers and numbers are usually the same across languages.
Factoring out lexical rules into a “module” means we can use it for different parser
grammars. Here’s a lexer grammar containing all of the lexical rules:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/CommonLexerRules.g4">tour/CommonLexerRules.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> CommonLexerRules; <em class="comment">// note "lexer grammar"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;      <em class="comment">// match identifiers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;         <em class="comment">// match integers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NEWLINE:<em class="string">'\r'</em>? <em class="string">'\n'</em> ;     <em class="comment">// return newlines to parser (end-statement signal)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t]+ -&gt; skip ; <em class="comment">// toss out whitespace</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N112FF">现在我们可以用 import 语句替换原始语法中的词汇规则。
</p><p>Now we can replace the lexical rules from the original grammar with an import statement.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/LibExpr.g4">旅游/LibExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> LibExpr;         <em class="comment">// Rename to distinguish from original</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> CommonLexerRules; <em class="comment">// includes all rules from CommonLexerRules.g4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** The start rule; begin parsing here. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   stat+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   expr NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr (<em class="string">'*'</em>|<em class="string">'/'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'+'</em>|<em class="string">'-'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N1135D">
构建和测试顺序与没有导入时相同。我们不会对导入的语法本身运行 ANTLR。
</p><p>
The build and test sequence is the same as it was without the import. We do not run ANTLR
on the imported grammar itself.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 LibExpr.g4 # automatically pulls in CommonLexerRules.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ ls Lib*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LibExprBaseListener.java        LibExprListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LibExprLexer.java               LibExprParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac LibExpr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun LibExpr prog -tree</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">3+4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(prog (stat (expr (expr 3) + (expr 4)) \n))​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N11391">
到目前为止，我们假设输入有效，但错误处理是几乎所有语言应用程序的重要组成部分。让我们看看 ANTLR 如何处理错误输入。
</p><p>
So far, we’ve assumed valid input, but error handling is an important part of almost all language applications. Let’s see what ANTLR does with erroneous input.
</p>
<h3>处理错误输入</h3><h3>Handling Erroneous Input</h3>
<p id="f_0026.html.N113A2">
ANTLR 解析器会自动报告语法错误并进行恢复。例如，如果我们忘记了表达式中的右括号，解析器就会自动发出错误消息。
</p><p>
ANTLR parsers automatically report and recover from syntax errors. For example, if we
forget a closing parenthesis in an expression, the parser automatically emits an error
message.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java ExprJoyRide</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">(1+2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">3</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:4 mismatched input '\n' expecting {')', '+', '*', '-', '/'}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(prog​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat (expr ( (expr (expr 1) + (expr 2)) &lt;missing ')'&gt;) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  (stat (expr 3) \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0026.html.N113DB">
同样重要的是，解析器恢复以正确匹配第二个表达式（<code class="cf ic">3</code>）。
</p><p>
Equally important is that the parser recovers to correctly match the second
expression (the <code class="cf ic">3</code>).
</p>
<p id="f_0026.html.N113E1">
当使用<code class="cf commandoption">-gui</code>选项
时<code class="cf commandname">grun</code>，解析树对话框会自动用红色突出显示错误节点。
</p><p>
When using the <code class="cf commandoption">-gui</code> option on
<code class="cf commandname">grun</code>, the parse-tree dialog automatically highlights error nodes
in red.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun LibExpr prog -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">(1+2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">34*69</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/游览/Expr-gui-errors.png">
</div>
<p id="f_0026.html.N1140B">
请注意，ANTLR 再次成功从第一个表达式中的错误中恢复，以正确匹配第二个表达式。
</p><p>
Notice that ANTLR successively recovered from the error in the first expression again to
properly match the second.
</p>
<p id="f_0026.html.N1140E">
ANTLR 的错误机制具有很大的灵活性。我们可以更改错误消息，捕获识别异常，甚至更改基本的错误处理策略。我们将在第 9 章“<a href="#f_0057.html.chp.errors">错误<em>报告和恢复”</em></a>中介绍这一点。
</p><p>
ANTLR’s error mechanism has lots of flexibility.
We can alter the error messages, catch recognition exceptions, and even alter the
fundamental error handling strategy. We’ll cover this in Chapter 9, <a href="#f_0057.html.chp.errors">​<em>Error Reporting and Recovery</em>​</a>.
</p>
<p id="f_0026.html.N11414">
至此，我们对语法和解析的快速了解就结束了。我们了解了一个简单的表达式语法，以及如何使用内置测试装置和示例主程序来启动它。我们还了解了如何获取解析树的文本和视觉表示，这些解析树显示了我们的语法如何识别输入短语。该<code class="cf keyword">import</code>语句让我们将语法分解为<span class="emph">模块</span>。现在，让我们超越语言识别，解释表达式（计算它们的值）。
</p><p>
That completes our quick tour of grammars and parsing. We’ve looked at a simple expression
grammar and how to launch it using the built-in test rig and a sample main program. We also
saw how to get text and visual representations of parse trees that show how our grammar
recognizes input phrases. The <code class="cf keyword">import</code> statement lets us break up grammars
into <span class="emph">modules</span>. Now, let’s move beyond language recognition to interpreting expressions
(computing their values).
</p>

</div></div>
<div id="f_0027.html"><div>

<h2 id="f_0027.html.sec.calc-visitor">4.2 使用访问者构建计算器</h2><h2>4.2 Building a Calculator Using a Visitor</h2>
<p id="f_0027.html.N11428">
为了让之前的算术表达式解析器计算值，我们需要编写一些 Java 代码。ANTLR v4 鼓励我们保持语法清晰，并使用解析树访问者和其他遍历器来实现语言应用程序。在本节中，我们将使用众所周知的访问者模式来实现我们的小计算器。为了方便我们，ANTLR 会自动生成访问者接口和空白访问者实现对象。
</p><p>
To get the previous arithmetic expression parser to compute values, we need to write some
Java code. ANTLR v4 encourages us to keep grammars clean and use parse-tree visitors and
other walkers to implement language applications. In this section, we’ll use the well-known
visitor pattern to implement our little calculator. To make things easier for us, ANTLR
automatically generates a visitor interface and blank visitor implementation object.
</p>
<p id="f_0027.html.N1142F">
在开始使用访问者之前，我们需要对语法进行一些修改。首先，我们需要标记规则的替代方案。（标签可以是任何与规则名称不冲突的标识符。）如果替代方案没有标签，ANTLR 只会为每个规则生成一个访问者方法。（第 7 章“<a href="#f_0045.html.chp.listeners"><em>将语法与特定于应用程序的代码</em></a><a href="#f_0045.html.chp.listeners">分离”使用<em></em></a>类似的语法来更详细地解释访问者机制。）在我们的例子中，我们希望每个替代方案都有一个不同的访问者方法，以便我们可以为每种输入短语获得不同的“事件”。标签出现在替代方案的右边缘，并以<code class="cf ic">#</code>我们新语法中的符号开头<code class="cf class">LabeledExpr</code>。
</p><p>
Before we get to the visitor, we need to make a few modifications to the grammar. First, we
need to label the alternatives of the rules. (The labels can be any identifier that doesn’t
collide with a rule name.) Without labels on the alternatives, ANTLR generates only one
visitor method per rule. (Chapter 7, <a href="#f_0045.html.chp.listeners">​<em>Decoupling Grammars from Application-Specific Code</em>​</a> uses a similar grammar to explain
the visitor mechanism in more detail.) In our case, we’d like a different visitor method for
each alternative so that we can get different “events” for each kind of input phrase.
Labels appear on the right edge of alternatives and start with the <code class="cf ic">#</code> symbol in our new grammar, <code class="cf class">LabeledExpr</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/LabeledExpr.g4">旅游/LabeledExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   expr NEWLINE                # printExpr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr NEWLINE         # assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NEWLINE                     # blank​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr op=(<em class="string">'*'</em>|<em class="string">'/'</em>) expr      # MulDiv​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr op=(<em class="string">'+'</em>|<em class="string">'-'</em>) expr      # AddSub​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT                         # int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                          # id​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>                # parens​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N11484">
接下来，让我们为运算符文字定义一些标记名称，以便稍后我们可以在访问者中将标记名称引用为 Java 常量。
</p><p>
Next, let’s define some token names for the operator literals so that, later, we can
reference token names as Java constants in the visitor.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/LabeledExpr.g4">旅游/LabeledExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​MUL :   <em class="string">'*'</em> ; <em class="comment">// assigns token name to '*' used above in grammar</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIV :   <em class="string">'/'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ADD :   <em class="string">'+'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SUB :   <em class="string">'-'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N114AB">
现在我们有了适当增强的语法，让我们开始编写计算器代码，看看主程序是什么样子。文件中的主程序与之前的<code class="cf filename">Calc.java</code>几乎相同。第一个区别是我们创建了从语法派生的词法分析器和解析器对象，而不是。
<code class="cf methodname">main</code><code class="cf filename">ExprJoyRide.java</code><code class="cf class">LabeledExpr</code><code class="cf class">Expr</code></p><p>
Now that we have a properly enhanced grammar, let’s start coding our calculator and see what
the main program looks like. Our main program in file <code class="cf filename">Calc.java</code> is
nearly identical to the <code class="cf methodname">main</code> in <code class="cf filename">ExprJoyRide.java</code> from
earlier. The first difference is that we create lexer and parser objects derived from
grammar <code class="cf class">LabeledExpr</code>, not <code class="cf class">Expr</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Calc.java">旅游/Calc.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LabeledExprLexer lexer = <strong class="prompt">new</strong> LabeledExprLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LabeledExprParser parser = <strong class="prompt">new</strong> LabeledExprParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree tree = parser.prog(); <em class="comment">// parse</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N114DE">
我们还可以删除将树显示为文本的打印语句。另一个区别是我们创建了访问者类的实例，<code class="cf class">EvalVisitor</code>我们将在稍后介绍。要开始遍历从方法返回的解析树
<code class="cf methodname">prog</code>，我们调用<code class="cf methodname">visit</code>。
</p><p>
We also can remove the print statement that displays the tree as text. The other difference
is that we create an instance of our visitor class, <code class="cf class">EvalVisitor</code>, which we’ll
get to in just a second. To start walking the parse tree returned from method
<code class="cf methodname">prog</code>, we call <code class="cf methodname">visit</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Calc.java">旅游/Calc.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EvalVisitor eval = <strong class="prompt">new</strong> EvalVisitor();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​eval.visit(tree);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N114FD">
现在，我们所有的支持机制都已就位。剩下要做的就是实现一个访问者，通过遍历解析树来计算并返回值。首先，让我们看看当我们输入时 ANTLR 会为我们生成什么。
</p><p>
All of our supporting machinery is now in place. The only thing left to do is implement
a visitor that computes and returns values by walking the parse tree. To get started,
let’s see what ANTLR generates for us when we type.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener -visitor LabeledExpr.g4</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N1150D">
首先，ANTLR 为每个标记的替代名称生成一个带有方法的访问者接口。
</p><p>
First, ANTLR generates a visitor interface with a method for each labeled alternative name.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> LabeledExprVisitor&lt;T&gt; {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    T visitId(LabeledExprParser.IdContext ctx);          # from label id​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    T visitAssign(LabeledExprParser.AssignContext ctx);  # from label assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    T visitMulDiv(LabeledExprParser.MulDivContext ctx);  # from label MulDiv​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N11530">
接口定义使用 Java 泛型，并将参数化类型用于访问方法的返回值。这样，我们就可以派生出实现类，选择适合我们想要实现的计算的返回值类型。
</p><p>
The interface definition uses Java generics with a parameterized type for the return values of the visit methods. This allows us to derive implementation classes with our choice of return value type to suit the computations we want to implement.
</p>
<p id="f_0027.html.N11533">
接下来，ANTLR 生成一个默认的访问者实现，名为，
<code class="cf class">LabeledExprBaseVisitor</code>我们可以将其子类化。在本例中，我们的表达式结果是整数，因此我们的<code class="cf class">EvalVisitor</code>应该扩展
<code class="cf ic">LabeledExprBaseVisitor&lt;Integer&gt;</code>。为了实现计算器，我们重写了与语句和表达式替代方案相关的方法。这里是它的全部功能。您可以剪切和粘贴或保存链接<code class="cf ic">tour/EvalVisitor</code>（电子书版本）。
</p><p>
Next, ANTLR generates a default visitor implementation called
<code class="cf class">LabeledExprBaseVisitor</code> that we can subclass. In this case, our expression
results are integers and so our <code class="cf class">EvalVisitor</code> should extend
<code class="cf ic">LabeledExprBaseVisitor&lt;Integer&gt;</code>. To implement the calculator, we override the
methods associated with statement and expression alternatives. Here it is in its full glory.
You can either cut and paste or save the <code class="cf ic">tour/EvalVisitor</code> link (ebook version).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/EvalVisitor.java">旅游/EvalVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.HashMap;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.Map;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> EvalVisitor <strong class="prompt">extends</strong> LabeledExprBaseVisitor&lt;<strong class="prompt">Integer</strong>&gt; {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** "memory" for our calculator; variable/value pairs go here */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">Integer</strong>&gt; memory = <strong class="prompt">new</strong> <strong class="prompt">HashMap</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">Integer</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** ID '=' expr NEWLINE */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitAssign(LabeledExprParser.AssignContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> id = ctx.ID().getText();  <em class="comment">// id is left-hand side of '='</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> value = visit(ctx.expr());   <em class="comment">// compute value of expression on right</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        memory.put(id, value);           <em class="comment">// store it in our memory</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> value;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** expr NEWLINE */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitPrintExpr(LabeledExprParser.PrintExprContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">Integer</strong> value = visit(ctx.expr()); <em class="comment">// evaluate the expr child</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(value);         <em class="comment">// print the result</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> 0;                          <em class="comment">// return dummy value</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** INT */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitInt(LabeledExprParser.IntContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> <strong class="prompt">Integer</strong>.valueOf(ctx.INT().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** ID */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitId(LabeledExprParser.IdContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> id = ctx.ID().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( memory.containsKey(id) ) <strong class="prompt">return</strong> memory.get(id);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** expr op=('*'|'/') expr */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitMulDiv(LabeledExprParser.MulDivContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> left = visit(ctx.expr(0));  <em class="comment">// get value of left subexpression</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> right = visit(ctx.expr(1)); <em class="comment">// get value of right subexpression</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( ctx.op.getType() == LabeledExprParser.MUL ) <strong class="prompt">return</strong> left * right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> left / right; <em class="comment">// must be DIV</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** expr op=('+'|'-') expr */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitAddSub(LabeledExprParser.AddSubContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> left = visit(ctx.expr(0));  <em class="comment">// get value of left subexpression</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> right = visit(ctx.expr(1)); <em class="comment">// get value of right subexpression</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( ctx.op.getType() == LabeledExprParser.ADD ) <strong class="prompt">return</strong> left + right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> left - right; <em class="comment">// must be SUB</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** '(' expr ')' */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitParens(LabeledExprParser.ParensContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> visit(ctx.expr()); <em class="comment">// return child expr's value</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N116BB">
这里是构建和测试序列，用于评估表达式<code class="cf filename">t.expr</code>：
</p><p>
And here is the build and test sequence that evaluates expressions in <code class="cf filename">t.expr</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener -visitor LabeledExpr.g4   # -visitor is required!!!</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ ls LabeledExpr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LabeledExprBaseVisitor.java     LabeledExprParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LabeledExprLexer.java           LabeledExprVisitor.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Calc.java LabeledExpr*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ cat t.expr</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​193​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a = 5​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​b = 6​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a+b*2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(1+2)*3​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Calc t.expr</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​193​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​17​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​9​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0027.html.N11706">
重点在于，我们构建计算器时无需将原始 Java 操作插入语法中，而 ANTLR v3 中则需要这样做。语法保持独立于应用程序且与编程语言无关。访问者机制还将除识别相关内容之外的所有内容保留在熟悉的 Java 领域中。无需学习额外的 ANTLR 符号即可在生成的解析器上构建语言应用程序。
</p><p>
The takeaway is that we built a calculator without having to insert raw Java actions into
the grammar, as we would need to do in ANTLR v3. The grammar is kept application independent
and programming language neutral. The visitor mechanism also keeps everything beyond the
recognition-related stuff in familiar Java territory. There’s no extra ANTLR notation to
learn in order to build a language application on top of a generated parser.
</p>
<p id="f_0027.html.N11709">
在继续之前，您可以花点时间尝试通过添加语句来扩展此表达式语言<code class="cf keyword">clear</code>。这是一种很好的方式，可以让您在无需了解所有细节的情况下开始尝试并做一些实际的事情。该<code class="cf keyword">clear</code>
命令应该清除<code class="cf variable">memory</code>地图，并且您需要在规则中添加一个新的替代方案<code class="cf keyword">stat</code>来识别它。用 标记替代方案
<code class="cf ic"># clear</code>，然后在语法上运行 ANTLR 以获取增强的访问者界面。然后，要使 发生某些事情<code class="cf keyword">clear</code>，请实现访问者方法
。按照前面的顺序
<code class="cf methodname">visitClear</code>进行编译和运行。<code class="cf class">Calc</code></p><p>
Before moving on, you might take a moment to try to extend  this expression language by
adding a <code class="cf keyword">clear</code> statement. It’s a great way to get your feet wet and do
something real without having to know all of the details. The <code class="cf keyword">clear</code>
command should clear out the <code class="cf variable">memory</code> map, and you’ll need a new
alternative in rule <code class="cf keyword">stat</code> to recognize it. Label the alternative with
<code class="cf ic"># clear</code> and then run ANTLR on the grammar to get the augmented visitor interface.
Then, to make something happen upon <code class="cf keyword">clear</code>, implement visitor method
<code class="cf methodname">visitClear</code>. Compile and run <code class="cf class">Calc</code> following the earlier sequence.
</p>
<p id="f_0027.html.N1172A">
现在让我们换个角度，考虑一下翻译，而不是评估或解释输入。在下一节中，我们将使用访问者的变体（称为
<span class="emph">侦听器）</span>来构建 Java 源代码的翻译器。
</p><p>
Let’s switch gears now and think about translation rather than evaluating or interpreting
input. In the next section, we’re going to use a variation of the visitor called a
<span class="emph">listener</span> to build a translator for Java source code.
</p>

</div></div>
<div id="f_0028.html"><div>

<h2 id="f_0028.html.sec.tour-java">4.3 构建带有监听器的翻译器</h2><h2>4.3 Building a Translator with a Listener</h2>
<p id="f_0028.html.N11738">
想象一下，你的老板指派你开发一个工具，根据 Java 类定义中的方法生成 Java 接口文件。如果你是一名初级程序员，你可能会感到恐慌。作为一名经验丰富的 Java 开发人员，你可能会建议使用 Java 反射 API 或工具
<code class="cf commandname">javap</code>来提取方法签名。如果你的 Java 工具构建功夫很强，你甚至可以尝试使用字节码库，比如 ASM。<a id="f_0028.html.FNPTR-19" href="#f_0030.html.FOOTNOTE-19">[19]</a>然后你的老板说：“哦，对了。在方法签名的范围内保留空格和注释。”现在没有办法了。我们必须解析 Java 源代码。例如，我们想读入这样的 Java 代码：
</p><p>
Imagine your boss assigns you to build a tool that generates a Java interface file from
the methods in a Java class definition. Panic ensues if you’re a junior programmer. As an
experienced Java developer, you might suggest using the Java reflection API or the
<code class="cf commandname">javap</code> tool to extract method signatures. If your Java tool
building kung fu is very strong, you might even try using a bytecode library such as
ASM.<a href="#f_0030.html.FOOTNOTE-19">[19]</a> Then your boss says, “Oh,
yeah. Preserve whitespace and comments within the bounds of the method signature.”
There’s no way around it now. We have to parse Java source code. For example, we’d like
to read in Java code like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Demo.java">游览/Demo.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.List;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.Map;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> Demo {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> f(<strong class="prompt">int</strong> x, <strong class="prompt">String</strong> y) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong>[ ] g(<em class="comment">/*no args*/</em>) { <strong class="prompt">return</strong> null; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">List</strong>&lt;<strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">Integer</strong>&gt;&gt;<strong class="prompt">[]</strong> h() { <strong class="prompt">return</strong> null; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N117A6">
并生成具有方法签名的接口，保留空格和注释。
</p><p>
and generate an interface with the method signatures, preserving the whitespace and
comments.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/IDemo.java">旅游/IDemo.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">interface</strong> IDemo {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> f(<strong class="prompt">int</strong> x, <strong class="prompt">String</strong> y);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong>[ ] g(<em class="comment">/*no args*/</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">List</strong>&lt;<strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">Integer</strong>&gt;&gt;<strong class="prompt">[]</strong> h();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N117E2">
信不信由你，我们将通过监听 Java 解析树遍历器触发的“事件”，用大约 15 行代码解决这个问题的核心。Java 解析树将来自本书源代码中包含的现有 Java 语法生成的解析器。我们将从类名中派生出生成的接口的名称，并从方法定义中获取方法签名（返回类型、方法名称和参数列表）。有关类似但解释更详尽的示例，请参阅第 8.3 节“<a href="#f_0054.html.sec.call-graph">生成<em>调用图”</em></a>。
</p><p>
Believe it or not, we’re going to solve the core of this problem in about fifteen lines of code
by listening to “events” fired from a Java parse-tree walker. The Java parse tree will
come from a parser generated from an existing Java grammar included in the source code for
this book. We’ll derive the name of the generated interface from the class name and grab
method signatures (return type, method name, and argument list) from method definitions. For
a similar but more thoroughly explained example, see Section 8.3, <a href="#f_0054.html.sec.call-graph">​<em>Generating a Call Graph</em>​</a>.
</p>
<p id="f_0028.html.N117E8">
语法和我们的侦听器对象之间的关键“接口”称为
<code class="cf class">JavaListener</code>，ANTLR 会自动为我们生成它。它定义了<code class="cf class">ParseTreeWalker</code>ANTLR 运行时类在遍历解析树时可以触发的所有方法。在我们的例子中，我们需要通过重写三种方法来响应三个事件：当遍历器进入和退出类定义时以及当它遇到方法定义时。以下是生成的侦听器接口中的相关方法：
</p><p>
The key “interface” between the grammar and our listener object is called
<code class="cf class">JavaListener</code>, and ANTLR automatically generates it for us. It defines all of
the methods that class <code class="cf class">ParseTreeWalker</code> from ANTLR’s runtime can trigger as it
traverses the parse tree. In our case, we need to respond to three events by overriding
three methods: when the walker enters and exits a class definition and when it encounters a
method definition. Here are the relevant methods from the generated listener interface:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> JavaListener <strong class="prompt">extends</strong> ParseTreeListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterClassDeclaration(JavaParser.ClassDeclarationContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitClassDeclaration(JavaParser.ClassDeclarationContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterMethodDeclaration(JavaParser.MethodDeclarationContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N1181D">
监听器和访问者机制之间的最大区别在于监听器方法由 ANTLR 提供的遍历器对象调用，而访问者方法必须使用显式的访问调用遍历其子节点。忘记对<code class="cf methodname">visit</code>节点的子节点进行调用意味着这些子树不会被访问。
</p><p>
The biggest difference between the listener and visitor mechanisms is that listener methods
are called by the ANTLR-provided walker object, whereas visitor methods must walk their
children with explicit visit calls. Forgetting to invoke <code class="cf methodname">visit</code> on a node’s children means those subtrees don’t get visited.
</p>
<p id="f_0028.html.N11823">
要构建我们的侦听器实现，我们需要知道规则
<code class="cf keyword">classDeclaration</code>和<code class="cf keyword">methodDeclaration</code>样子，因为侦听器方法必须获取与规则匹配的短语元素。File<code class="cf filename">Java.g4</code>是 Java 的完整语法，但对于这个问题，我们需要查看以下两种方法：
</p><p>
To build our listener implementation, we need to know what rules
<code class="cf keyword">classDeclaration</code> and <code class="cf keyword">methodDeclaration</code> look like
because listener methods have to grab phrase elements matched by the rules. File <code class="cf filename">Java.g4</code> is a complete grammar for Java, but here are the two methods we need to look at for this problem:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Java.g4">游览/Java.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​classDeclaration​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'class'</em> Identifier typeParameters? (<em class="string">'extends'</em> type)?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        (<em class="string">'implements'</em> typeList)?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        classBody​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Java.g4">游览/Java.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​methodDeclaration​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type Identifier formalParameters (<em class="string">'['</em> <em class="string">']'</em>)* methodDeclarationRest​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'void'</em> Identifier formalParameters methodDeclarationRest​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N11870">
为了使我们不必实现所有 200 个左右的接口方法，ANTLR 生成了一个名为的默认实现<code class="cf class">JavaBaseListener</code>。然后我们的接口提取器可以子类化<code class="cf class">JavaBaseListener</code>并覆盖感兴趣的方法。
</p><p>
So that we don’t have to implement all 200 or so interface methods, ANTLR generates a
default implementation called <code class="cf class">JavaBaseListener</code>. Our interface extractor can
then subclass <code class="cf class">JavaBaseListener</code> and override the methods of interest.
</p>
<p id="f_0028.html.N11879">
我们的基本策略是，当我们看到类定义的开头时，打印出接口头。然后，我们将<code class="cf ic">}</code>在类定义的末尾打印一个终止符。在每个方法定义之后，我们将输出其签名。以下是完整的实现：
</p><p>
Our basic strategy will be to print out the interface header when we see the start of a class definition. Then, we’ll print a terminating <code class="cf ic">}</code> at the end of the class definition. Upon each method definition, we’ll spit out its signature.  Here’s the complete implementation:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/ExtractInterfaceListener.java">旅游/ExtractInterfaceListener.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.misc.Interval;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ExtractInterfaceListener <strong class="prompt">extends</strong> JavaBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    JavaParser parser;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> ExtractInterfaceListener(JavaParser parser) {this.parser = parser;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Listen to matches of classDeclaration */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterClassDeclaration(JavaParser.ClassDeclarationContext ctx){​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(<em class="string">"interface I"</em>+ctx.Identifier()+<em class="string">" {"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitClassDeclaration(JavaParser.ClassDeclarationContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(<em class="string">"}"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Listen to matches of methodDeclaration */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterMethodDeclaration(​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        JavaParser.MethodDeclarationContext ctx​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    )​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// need parser to get tokens</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        TokenStream tokens = parser.getTokenStream();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> type = <em class="string">"void"</em>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( ctx.type()!=null ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            type = tokens.getText(ctx.type());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> args = tokens.getText(ctx.formalParameters());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(<em class="string">"\t"</em>+type+<em class="string">" "</em>+ctx.Identifier()+args+<em class="string">";"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N11935">
要启动它，我们需要一个主程序，它看起来与本章中的其他程序几乎相同。启动解析器后，我们的应用程序代码就开始了。
</p><p>
To fire this up, we need a main program, which looks almost the same as the others in
this chapter. Our application code starts after we’ve launched the parser.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/ExtractInterfaceTool.java">旅游/ExtractInterfaceTool.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​JavaLexer lexer = <strong class="prompt">new</strong> JavaLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​JavaParser parser = <strong class="prompt">new</strong> JavaParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree tree = parser.compilationUnit(); <em class="comment">// parse</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker(); <em class="comment">// create standard walker</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExtractInterfaceListener extractor = <strong class="prompt">new</strong> ExtractInterfaceListener(parser);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(extractor, tree); <em class="comment">// initiate walk of tree with listener</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N1196E"><code class="cf ic">import org.antlr.v4.runtime.tree.*;</code>我们还需要在文件顶部

添加。</p><p>
We also need to add <code class="cf ic">import org.antlr.v4.runtime.tree.*;</code> at the top of the file.
</p>
<p id="f_0028.html.N11974">
给定语法 Java.g4 和我们的<code class="cf methodname">main</code>，
<code class="cf class">ExtractInterfaceTool</code>这里是完整的构建和测试序列：
</p><p>
Given grammar Java.g4 and our <code class="cf methodname">main</code> in
<code class="cf class">ExtractInterfaceTool</code>, here’s the complete build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Java.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ ls Java*.java ExtractInterface*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExtractInterfaceListener.java  JavaBaseListener.java   JavaListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExtractInterfaceTool.java      JavaLexer.java          JavaParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Java*.java Extract*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java ExtractInterfaceTool Demo.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​interface IDemo {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        void f(int x, String y);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        int[ ] g(/*no args*/);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        List&lt;Map&lt;String, Integer&gt;&gt;[] h();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0028.html.N119B0">
此实现并不完整，因为它没有在接口文件中包括接口方法所引用类型的导入语句，例如
<code class="cf class">List</code>。作为练习，请尝试处理导入。它应该会让您相信使用侦听器构建这些类型的提取器或转换器很容易。我们甚至不需要知道规则是什么<code class="cf keyword">importDeclaration</code>样子，因为
<code class="cf methodname">enterImportDeclaration</code>应该只打印整个规则匹配的文本：<code class="cf ic">parser.getTokenStream().getText(ctx)</code>。
</p><p>
This implementation isn’t quite complete because it doesn’t include in the interface file
the import statements for the types referenced by the interface methods such as
<code class="cf class">List</code>. As an exercise, try handling the imports. It should convince you that
it’s easy to build these kinds of extractors or translators using a listener. We don’t even
need to know what the <code class="cf keyword">importDeclaration</code> rule looks like because
<code class="cf methodname">enterImportDeclaration</code> should simply print the text matched by the entire
rule: <code class="cf ic">parser.getTokenStream().getText(ctx)</code>.
</p>
<p id="f_0028.html.N119BF">
访问者和监听器机制运行良好，促进了解析和解析器应用程序之间的关注点分离。但有时我们需要额外的控制和灵活性。
</p><p>
The visitor and listener mechanisms work very well and promote the separation of concerns
between parsing and parser application. Sometimes, though, we need extra control and
flexibility.
</p>

</div></div>
<div id="f_0029.html"><div>

<h2 id="f_0029.html.sec.actions-during-parse">4.4 解析过程中发生的事情</h2><h2>4.4 Making Things Happen During the Parse</h2>
<p id="f_0029.html.N119D3">
监听器和访问者程序非常棒，因为它们将特定于应用程序的代码置于语法之外，使语法更易于阅读，并防止它们与特定应用程序纠缠在一起。但是，为了获得最大的灵活性和控制力，我们可以直接在语法中嵌入代码片段（操作）。这些操作被复制到 ANTLR 生成的递归下降解析器代码中。在本节中，我们将实现一个简单的程序，该程序读取数据行并打印出在特定列中找到的值。之后，我们将了解如何制作特殊操作（称为<span class="emph">语义谓词）</span>，动态地打开和关闭语法的某些部分。
</p><p>
Listeners and visitors are great because they keep application-specific code out of
grammars, making grammars easier to read and preventing them from getting entangled with a
particular application. For the ultimate flexibility and control, however, we can directly
embed code snippets (actions) within grammars. These actions are copied into the
recursive-descent parser code ANTLR generates. In this section, we’ll implement a simple
program that reads in rows of data and prints out the values found in a specific column.
After that, we’ll see how to make special actions, called <span class="emph">semantic predicates</span>, dynamically
turn parts of a grammar on and off.
</p>
<h3>在语法中嵌入任意动作</h3><h3>Embedding Arbitrary Actions in a Grammar</h3>
<p id="f_0029.html.N119DD">
如果我们不想产生构建解析树的开销，我们可以在解析过程中即时计算值或打印内容。另一方面，这意味着在表达式语法中嵌入任意代码，这更难；我们必须了解操作对解析器的影响以及将这些操作定位在何处。
</p><p>
We can compute values or print things out on-the-fly during parsing if we don’t want the
overhead of building a parse tree. On the other hand, it means embedding arbitrary code
within the expression grammar, which is harder; we have to understand the effect of the
actions on the parser and where to position those actions.
</p>
<p id="f_0029.html.N119F2">
为了演示语法中嵌入的操作，让我们构建一个程序，从数据行中打印出特定列。这对我来说总是会出现，因为人们会向我发送文本文件，我需要从中获取姓名或电子邮件列。为了我们的目的，让我们使用以下数据：
</p><p>
To demonstrate actions embedded in a grammar, let’s build a program that prints out a
specific column from rows of data. This comes up all the time for me because people send me
text files from which I need to grab, say, the name or email column. For our purposes, let’s
use the following data:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/t.rows">旅游/t.rows</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parrt   Terence Parr    101​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tombu   Tom Burns       020​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​bke     Kevin Edgar     008​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11A08">
列以制表符分隔，每行以换行符结尾。匹配这种输入在语法上非常简单。
</p><p>
The columns are tab-delimited, and each row ends with a newline character. Matching this kind of  input is pretty simple grammatically.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : (row NL)+ ; <em class="comment">// NL is newline token: '\r'? '\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row  : STUFF+ ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11A1C">
但是，当我们添加操作时，它会变得一团糟。我们需要创建一个构造函数，以便我们可以传入我们想要的列号（从 1 开始计数），并且我们需要在
<code class="cf ic">(...)+</code>规则中的循环内执行操作<code class="cf keyword">row</code>。
</p><p>
It gets mucked up, though, when we add actions. We need to create a constructor so that we
can pass in the column number we want (counting from 1), and we need an action inside the
<code class="cf ic">(...)+</code> loop in rule <code class="cf keyword">row</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Rows.g4">巡回赛/Rows.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Rows;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@parser</strong>::members { <em class="comment">// add members to generated RowsParser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    int col;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> RowsParser(TokenStream input, int col) { <em class="comment">// custom constructor</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        this(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        this.col = col;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file: (row NL)+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : (   STUFF​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          $i++;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          if ( $i == col ) System.out.println($STUFF.text);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      )+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TAB  :  <em class="string">'\t'</em> -&gt; skip ;   <em class="comment">// match but don't pass to the parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NL   :  <em class="string">'\r'</em>? <em class="string">'\n'</em> ;     <em class="comment">// match and pass to the parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STUFF:  ~[\t\r\n]+ ;     <em class="comment">// match any chars except tab, newline</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11A92">
词汇<code class="cf keyword">STUFF</code>规则匹配任何非制表符或换行符的内容，这意味着我们可以在一列中有空格字符。
</p><p>
The <code class="cf keyword">STUFF</code> lexical rule matches anything that’s not a tab or newline, which means we can have space characters in a column.
</p>
<p id="f_0029.html.N11A98">
现在，合适的主程序看起来应该相当熟悉了。这里唯一不同的是，我们使用自定义构造函数将列号传递给解析器，并告诉解析器不要构建树。
</p><p>
A suitable main program should be looking pretty familiar by now. The only thing different
here is that we’re passing in a column number to the parser using a custom constructor and
telling the parser not to build a tree.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Col.java">旅游/Col.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RowsLexer lexer = <strong class="prompt">new</strong> RowsLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> col = <strong class="prompt">Integer</strong>.valueOf(args[0]);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RowsParser parser = <strong class="prompt">new</strong> RowsParser(tokens, col); <em class="comment">// pass column number!</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.setBuildParseTree(false); <em class="comment">// don't waste time bulding a tree</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.file(); <em class="comment">// parse</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11ACB">
其中有很多细节，我们将在第 10 章“<a href="#f_0063.html.chp.actions">属性<em>和动作”</em>中探讨。</a>目前，动作是用花括号括起来的代码片段。动作
<code class="cf keyword">members</code>将该代码注入生成的解析器类的成员区域。规则内的动作访问<code class="cf keyword">row</code>用子句<code class="cf ic">$i</code>定义的局部变量<code class="cf keyword">locals</code>。它还用于
<code class="cf ic">$STUFF.text</code>获取最近匹配的<code class="cf keyword">STUFF</code>
标记的文本。
</p><p>
There are a lot of details in there that we’ll explore in Chapter 10, <a href="#f_0063.html.chp.actions">​<em>Attributes and Actions</em>​</a>.
For now, actions are code snippets surrounded by curly braces. The
<code class="cf keyword">members</code> action injects that code into the member area of the generated
parser class. The action within rule <code class="cf keyword">row</code> accesses <code class="cf ic">$i</code>, the local
variable defined with the <code class="cf keyword">locals</code> clause. It also uses
<code class="cf ic">$STUFF.text</code> to get the text for the most recently matched <code class="cf keyword">STUFF</code>
token.
</p>
<p id="f_0029.html.N11AE3">
以下是构建和测试序列，每列一个测试：
</p><p>
Here’s the build and test sequence, one test per column:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener Rows.g4  # don't need the listener</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Rows*.java Col.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Col 1 &lt; t.rows          # print out column 1, reading from file t.rows</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parrt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tombu​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​bke​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Col 2 &lt; t.rows</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Terence Parr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Tom Burns​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Kevin Edgar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java Col 3 &lt; t.rows</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​101​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​020​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​008​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11B25">
这些操作提取并打印解析器匹配的值，但它们不会改变解析本身。操作还可以巧妙地处理解析器识别输入短语的方式。在下一节中，我们将进一步探讨嵌入式操作的概念。
</p><p>
These actions extract and print values matched by the parser, but they don’t alter the parse
itself. Actions can also finesse how the parser recognizes input phrases. In the next
section, we’ll take the concept of embedded actions one step further.
</p>
<h3 id="f_0029.html.sec.tour-preds">使用语义谓词改变解析</h3><h3>Altering the Parse with Semantic Predicates</h3>
<p id="f_0029.html.N11B36">
在我们进入第 11 章“<a href="#f_0067.html.chp.predicates"><em>使用语义谓词</em></a><a href="#f_0067.html.chp.predicates">改变之前，<em></em></a>我们可以通过一个简单的示例来展示语义谓词的强大功能。让我们看一个读取整数序列的语法。诀窍在于输入的一部分指定要将多少个整数组合在一起。我们直到运行时才知道要匹配多少个整数。这是一个示例输入文件：
</p><p>
Until we get to Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>, we can demonstrate the power of semantic
predicates with a simple example. Let’s look at a grammar that reads in sequences of
integers. The trick is that part of the input specifies how many integers to group together.
We don’t know until runtime how many integers to match. Here’s a sample input file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/t.data">旅游/t.数据</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​2 9 10 3 1 2 3​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11B4D">
第一个数字表示匹配后面两个数字 9 和 10。10 后面的 3 表示匹配另外三个数字作为序列。我们的目标是<code class="cf class">Data</code>
将 9 和 10 组合在一起，然后将 1、2 和 3 组合在一起，如下所示：
</p><p>
The first number says to match the two subsequent numbers, 9 and 10. The 3 following the
10 says to match three more as a sequence. Our goal is a grammar called <code class="cf class">Data</code>
that groups 9 and 10 together and then 1, 2, and 3 like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener Data.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Data*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Data file -tree t.data</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(file (group 2 (sequence 9 10)) (group 3 (sequence 1 2 3)))​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11B71">
解析树清楚地标识了各个组。
</p><p>
The parse tree clearly identifies the groups.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAABvBAAAAAA4olGLAAAACXBIWXMAAABIAAAASABGyWs+AAAD/0lEQVRYw+2ZP2/UMBjGM8C1EUj+CBUjUz9C+QJ8B1ZAomMpHHdCDDDRqyqBjiVzxVDBQNluPHW6jVZiuAUdZSGRkJpETs7YsZ2/fm2TS6VWwqqixPfkl8dPfPF7qUM6aIFz2ZR7CHVAQaQDSuAgFDvuyl4QCrxRFxTHKn0TZeVcuhtRB+nat/+UNpTTFx1Qjr2fdhgd5dgjJH6+IuX9hG3jxytROIQQ/Kw9Zfl6Lnfxw7aU5c68OEh221HSN37lcMdvQWmclT71/5mS7jbOKcVkSVGmWQnKgoKBLOWdt6LAk/XdxJqim/HHR5aUc+2374tnRTF9haeeBeXsLTG004GRshyYIPRCNrm0bFePMlpH7sbI8WjdE7wE1lSdhlPcEPV8N0ZMsQes7zoNp9BPkNgEBKg2dBpBSYUi1VA0mnxEiFC3txdwxaLTiHR7VEGT219HwQMoXY1GetnKO6C7qdMILzdmRopOc/XmbpeUcGjWLzwTpT81QpZPPhgo4Swxmln4Sk1BWb5gIpMV+uzVUhiBqXTtlGpUZnIKB+jNcMBUQ+Hn683w89MBSJHP//OZyYrKsKTkNvsmKyrDglJEFoJmYk/uNcwISikx0Mw432ssf5xSvnuQmcJKU8Mph+prErC7r6CUL1M/ki2alI9qZjJK7epKM33dIaPUL64yU0+iqmGUw/opX41WaoYZZVZXJH69J21ocCOXlVvg2PzwNmkCx+YlgElDKWKRoosn+1tnazrdce94vIfrPgvNmLqqalgPy+UgU6zFiK7l7gVT0J3er0036+EXuyU0FEyqGtZDKd/uZ4r9XeI4iBcocof1cC+vhIa9kKlqWE/gJHe5LjmgxVZWpbBChUvliyk56uSA5VPVBFkuf2Zc6UbZiEJWoPDCqxiRTNeNshFVNHxE8qWRSHcN0QKFF4FFuvJOi3QrGplutSGLWVbXXBalTbvylGjPfOIPz0Q5t/ih9GhsogzOjJDwezTTU9Jh5JsofVx+iKooIVkODZB4gknoayknhJheR43pc7e06Kso28yOtiV77Om90FHwEXU801Km2RqQDjWUUPiBG4sNk1KloaB8zDdQY/ULo2APpmznhqDGYs1WtTFI4ZGwcKAWziVFzrwmJSw5UrdsuuFiV0URU+UEhMSTgiJmXoMipy0cDA+DU8TMa1DkVygdAhA64wqKmHkNSv51hp4OYpLg8sUalN+NnVqbi5GXDy/niSmLBLwB1Syfsm2xznkKiiwSHOhVgTghX3MzfZ2S/+cJfG0RiK34FG+qvIR2FFn1EGeiyqVnSRFVD4m2FBSCt6wosurhCTRGdDGUFKAi5JS86lGmO7opY4butEi3qHrINVjtrzflLy4/E65ORMqrAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjQyLTA2OjAwtQ61swAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo0Mi0wNjowMMRTDQ8AAAAgdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADYxMng3OTIrMCswn519VwAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuMyBTBqy/AAAAAElFTkSuQmCC" alt="图片/旅游/数据.png">
</div>
<p id="f_0029.html.N11B79">
以下语法中的关键是称为<span class="emph">语义谓词</span><code class="cf class">Data</code>的特殊布尔值动作： 。该谓词的计算结果为真，直到我们超过规则参数所要求的整数数量。假谓词使相关替代方案从语法中“消失”，从而从生成的解析器中消失。在这种情况下，假谓词使循环终止并从规则返回
。
<span class="emph"></span><code class="cf ic">{$i&lt;=$n}?</code><code class="cf keyword">sequence</code><code class="cf variable">n</code><code class="cf ic">(...)*</code><code class="cf keyword">sequence</code></p><p>
The key in the following <code class="cf class">Data</code> grammar is a special Boolean-valued action
called a <span class="emph">semantic predicate</span>: <code class="cf ic">{$i&lt;=$n}?</code>. That predicate evaluates to true until
we surpass the number of integers requested by the <code class="cf keyword">sequence</code> rule
parameter <code class="cf variable">n</code>. False predicates make the associated alternative
“disappear” from the grammar and, hence, from the generated parser. In this case, a false
predicate makes the <code class="cf ic">(...)*</code> loop terminate and return from rule
<code class="cf keyword">sequence</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Data.g4">旅游/数据.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Data;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : group+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​group: INT sequence[$INT.int] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​sequence[int n]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i = 1;]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     : ( {$i&lt;=$n}? INT {$i++;} )* <em class="comment">// match n integers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;             <em class="comment">// match integers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\n\r]+ -&gt; skip ; <em class="comment">// toss out all whitespace</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0029.html.N11BC8"><code class="cf keyword">sequence</code>从视觉上看，解析器使用的

规则的内部语法表示看起来像这样：</p><p>
Visually, the internal grammar representation of rule <code class="cf keyword">sequence</code> used by
the parser looks something like this:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/谓词/Data-atn.png">
</div>
<p id="f_0029.html.N11BD2">
剪刀和虚线表示谓词可以剪断该路径，使得解析器只剩下一个选择：通往出口的路径。
</p><p>
The scissors and dashed line indicate that the predicate can snip that path, leaving the
parser with only one choice: the path to the exit.
</p>
<p id="f_0029.html.N11BD8">
大多数时候，我们不需要这样的微观管理，但很高兴知道我们有一种处理病理解析问题的武器。
</p><p>
Most of the time we won’t need such micromanagement, but it’s nice to know we have  a
weapon for handling pathological parsing problems.
</p>
<p id="f_0029.html.N11BDB">
到目前为止，我们一直专注于解析功能，但在词汇层面上还有很多有趣的事情发生。让我们来看看。
</p><p>
During our tour so far, we’ve focused on parsing features, but there is a lot of
interesting stuff going on at the lexical level. Let’s take a look.
</p>

</div></div>
<div id="f_0030.html"><div>

<h2 id="f_0030.html.N11BE0">4.5 酷炫词汇特征</h2><h2>4.5 Cool Lexical Features</h2>
<p id="f_0030.html.N11BE4">
ANTLR 具有三个与标记相关的出色功能，值得在我们的介绍中加以展示。首先，我们将了解如何处理同一文件中具有不同词汇结构（内部和外部标记）的格式（如 XML）。接下来，我们将学习如何通过调整输入流将字段插入 Java 类。它将展示如何以最小的努力生成与输入非常相似的输出。最后，我们将了解 ANTLR 解析器如何忽略空格和注释，而无需将其丢弃。
</p><p>
ANTLR has three great token-related features that are worth demonstrating in our tour.
First, we’ll see how to deal with formats like XML that have different lexical structures
(inside and outside tags) in the same file. Next, we’ll learn how to insert a field into
a Java class by tweaking the input stream. It’ll show how to generate
output that is very similar to the input with minimal effort. And, lastly, we’ll see how
ANTLR parsers can ignore whitespace and comments without having to throw them out.
</p>
<h3>岛语法：处理同一文件中的不同格式</h3><h3>Island Grammars: Dealing with Different Formats in the Same File</h3>
<p id="f_0030.html.N11BEB">
到目前为止，我们看到的所有示例输入文件都包含一种语言，但有些常见的文件格式包含多种语言。例如，<code class="cf ic">@author</code>
Java 文档注释中的标签等遵循一种微型语言；注释之外的所有内容都是 Java 代码。StringTemplate <a id="f_0030.html.FNPTR-20" href="#f_0030.html.FOOTNOTE-20">[20]</a>和 Django <a id="f_0030.html.FNPTR-21" href="#f_0030.html.FOOTNOTE-21">[21]</a>等模板引擎也存在类似的问题。它们必须以不同的方式处理模板表达式周围的所有文本。这些通常称为<span class="emph">孤岛语法</span>。
</p><p>
All the sample input files we’ve seen so far contain a single language, but there are
common file formats that contain multiple languages. For example, the <code class="cf ic">@author</code>
tags and so on inside Java document comments follow a mini language; everything outside
the comment is Java code. Template engines such as
StringTemplate<a href="#f_0030.html.FOOTNOTE-20">[20]</a> and
Django<a href="#f_0030.html.FOOTNOTE-21">[21]</a> have a
similar problem. They have to treat all of the text surrounding the template expressions
differently. These are often called <span class="emph">island grammars</span>.
</p>
<p id="f_0030.html.N11C0A">
ANTLR 提供了一项著名的词法分析器功能，称为<span class="firstuseinline">词法模式</span>，它让我们可以轻松处理包含混合格式的文件。基本思想是让词法分析器在看到特殊的标记字符序列时在模式之间来回切换。
</p><p>
ANTLR provides a well-known lexer feature called <span class="firstuseinline">lexical modes</span> that
lets us deal easily with files containing mixed formats. The basic idea is to have the
lexer switch back and forth between modes when it sees special sentinel character
sequences.
</p>
<p id="f_0030.html.N11C13">
XML 就是一个很好的例子。XML 解析器将除标签和实体引用（例如<code class="cf ic">&amp;pound;</code>）之外的所有内容视为文本块。当词法分析器看到 &lt; 时，它会切换到“内部”模式，当看到 &gt; 或 /&gt; 时，它会切换回默认模式。以下语法演示了它的工作原理。我们将在第 12 章“<a href="#f_0071.html.chp.lexmagic">运用<em>词汇黑魔法”</em></a>中更详细地探讨这一点。
</p><p>
XML is a good example. An XML parser treats everything other than tags and entity
references (such as <code class="cf ic">&amp;pound;</code>) as text chunks. When the lexer sees &lt;, it
switches to “inside” mode and switches back to the default mode when it sees &gt; or /&gt;.
The following grammar demonstrates how this works. We’ll explore this in more detail in
Chapter 12, <a href="#f_0071.html.chp.lexmagic">​<em>Wielding Lexical Black Magic</em>​</a>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/XMLLexer.g4">旅游/XMLLexer.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> XMLLexer;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// Default "mode": Everything OUTSIDE of a tag</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​OPEN        :   <em class="string">'&lt;'</em>                 -&gt; pushMode(INSIDE) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT     :   <em class="string">'&lt;!--'</em> .*? <em class="string">'--&gt;'</em>    -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EntityRef   :   <em class="string">'&amp;'</em> [a-z]+ <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT        :   ~(<em class="string">'&lt;'</em>|<em class="string">'&amp;'</em>)+ ;           <em class="comment">// match any 16 bit char minus &lt; and &amp;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// ----------------- Everything INSIDE of a tag ---------------------</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode INSIDE;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CLOSE       :   <em class="string">'&gt;'</em>                 -&gt; popMode ; <em class="comment">// back to default mode</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SLASH_CLOSE :   <em class="string">'/&gt;'</em>                -&gt; popMode ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EQUALS      :   <em class="string">'='</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING      :   <em class="string">'"'</em> .*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SlashName   :   <em class="string">'/'</em> Name ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Name        :   ALPHA (ALPHA|DIGIT)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​S           :   [ \t\r\n]           -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ALPHA       :   [a-zA-Z] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIGIT       :   [0-9] ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11CA4">
让我们使用以下 XML 文件作为该语法的示例输入：
</p><p>
Let’s use the following XML file as a sample input to that grammar:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/t.xml">旅游/t.xml</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;tools&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">&lt;tool</strong> name=<em class="string">"ANTLR"</em>
<strong class="prompt">&gt;</strong>A parser generator<strong class="prompt">&lt;/tool&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/tools&gt;</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11CC6">
构建和启动测试台的方法如下：
</p><p>
Here’s how to do a build and launch the test rig:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 XMLLexer.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac XML*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun XML tokens -tokens t.xml</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:0='&lt;',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,1:5='tools',&lt;10&gt;,1:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,6:6='&gt;',&lt;5&gt;,1:6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,7:8='\n\t',&lt;4&gt;,1:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,9:9='&lt;',&lt;1&gt;,2:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,10:13='tool',&lt;10&gt;,2:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,15:18='name',&lt;10&gt;,2:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,19:19='=',&lt;7&gt;,2:11]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,20:26='"ANTLR"',&lt;8&gt;,2:12]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,27:27='&gt;',&lt;5&gt;,2:19]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,28:45='A parser generator',&lt;4&gt;,2:20]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,46:46='&lt;',&lt;1&gt;,2:38]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@12,47:51='/tool',&lt;9&gt;,2:39]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@13,52:52='&gt;',&lt;5&gt;,2:44]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@14,53:53='\n',&lt;4&gt;,2:45]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@15,54:54='&lt;',&lt;1&gt;,3:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@16,55:60='/tools',&lt;9&gt;,3:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@17,61:61='&gt;',&lt;5&gt;,3:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@18,62:62='\n',&lt;4&gt;,3:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@19,63:62='&lt;EOF&gt;',&lt;-1&gt;,4:9]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11D1D">
该输出的每一行代表一个标记，包含标记索引、起始和终止字符、标记文本、标记类型，以及行和行内的字符位置。这告诉我们词法分析器如何标记输入。
</p><p>
Each line of that output represents a token and contains the token index, the start and
stop character, the token text, the token type, and finally the line and character
position within the line. This tells us how the lexer tokenized the input.
</p>
<p id="f_0030.html.N11D20">
在测试装置命令行上，<code class="cf ic">XML tokens</code>序列通常是语法名称后跟起始规则。在本例中，我们使用语法名称后跟特殊规则名称<code class="cf keyword">tokens</code>来告诉测试装置它应该运行词法分析器而不是解析器。然后，我们使用测试装置选项<code class="cf commandoption">-tokens</code>打印出匹配的标记列表。
</p><p>
On the test rig command line, the <code class="cf ic">XML tokens</code> sequence is normally a grammar
name followed by the start rule. In this case, we use the grammar name followed by
special rule name <code class="cf keyword">tokens</code> to tell the test rig it should run the lexer but not the parser. Then, we use test rig option <code class="cf commandoption">-tokens</code> to print out the list of matched tokens.
</p>
<p id="f_0030.html.N11D2C">
了解从词法分析器流向解析器的标记流可能非常有用。例如，一些翻译问题实际上只是对输入的调整。有时我们可以改变原始标记流，而不是生成全新的输出。
</p><p>
Knowledge of the token stream flowing from the lexer to the parser can be pretty useful.
For example, some translation problems are really just tweaks of the input. We can
sometimes get away with altering the original token stream rather than generating completely new output.
</p>
<h3 id="f_0030.html.sec.rewriting-input">重写输入流</h3><h3>Rewriting the Input Stream</h3>
<p id="f_0030.html.N11D3E">
让我们构建一个工具来处理 Java 源代码以插入序列化标识符，
<code class="cf variable">serialVersionUID</code>以供使用<code class="cf class">java.io.Serializable</code>
（就像 Eclipse 自动执行的那样）。我们希望避免在接口中实现每个侦听器方法
<code class="cf class">JavaListener</code>（由 ANTLR 从 Java 语法生成），只是为了捕获文本并将其打印出来。将适当的常量字段插入原始标记流然后打印出更改后的输入流更容易。没有麻烦，没有混乱。
</p><p>
Let’s build a tool that processes Java source code to insert serialization identifiers,
<code class="cf variable">serialVersionUID</code>, for use with <code class="cf class">java.io.Serializable</code>
(like Eclipse does automatically). We want to avoid implementing every listener method in a
<code class="cf class">JavaListener</code> interface, generated from a Java grammar by ANTLR, just to
capture the text and print it back out. It’s easier to insert the appropriate constant field
into the original token stream and then print out the altered input stream. No fuss, no
muss.
</p>
<p id="f_0030.html.N11D4E"><code class="cf filename">ExtractInterfaceTool.java</code>我们的主程序看起来与第 4.3 节“<a href="#f_0028.html.sec.tour-java"><em>使用监听器</em></a><a href="#f_0028.html.sec.tour-java">构建<em></em></a>
中的程序完全相同，
<a href="#f_0028.html.sec.tour-java">只是</a>我们在监听器完成时打印出标记流（用箭头突出显示）。
</p><p>
Our main program looks exactly the same as the one in
<code class="cf filename">ExtractInterfaceTool.java</code> from Section 4.3, <a href="#f_0028.html.sec.tour-java">​<em>Building a Translator with a Listener</em>​</a> except
that we print the token stream out when the listener has finished (highlighted with an
arrow).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/InsertSerialID.java">游览/InsertSerialID.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker(); <em class="comment">// create standard walker</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​InsertSerialIDListener extractor = <strong class="prompt">new</strong> InsertSerialIDListener(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(extractor, tree); <em class="comment">// initiate walk of tree with listener</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// print back ALTERED stream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(extractor.rewriter.getText());​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11D7F">
为了实现监听器，我们需要在看到一个类的开始时触发插入。
</p><p>
To implement the listener, we need to trigger an insertion when we see the start of a
class.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/InsertSerialIDListener.java">旅游/InsertSerialIDListener.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenStreamRewriter;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> InsertSerialIDListener <strong class="prompt">extends</strong> JavaBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    TokenStreamRewriter rewriter;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> InsertSerialIDListener(TokenStream tokens) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        rewriter = <strong class="prompt">new</strong> TokenStreamRewriter(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterClassBody(JavaParser.ClassBodyContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> field = <em class="string">"\n\tpublic static final long serialVersionUID = 1L;"</em>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        rewriter.insertAfter(ctx.start, field);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11DD5">
关键是<code class="cf class">TokenStreamRewriter</code>对象知道如何在不实际修改流的情况下提供标记流的更改视图。它将所有操作方法视为“指令”，并在遍历标记流以将其重新呈现为文本时将它们排队以进行延迟执行。每次我们调用时，重写器都会执行这些指令<code class="cf methodname">getText</code>。
</p><p>
The key is the <code class="cf class">TokenStreamRewriter</code> object that knows how to give altered
views of a token stream without actually modifying the stream. It treats all of the
manipulation methods as “instructions” and queues them up for lazy execution when
traversing the token stream to render it back as text. The rewriter executes those
instructions every time we call <code class="cf methodname">getText</code>.
</p>
<p id="f_0030.html.N11DE7">
让<code class="cf filename">Demo.java</code>我们在之前使用的测试文件上构建并测试监听器。
</p><p>
Let’s build and test the listener on the <code class="cf filename">Demo.java</code> test file we
used before.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Java.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac InsertSerialID*.java Java*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java InsertSerialID Demo.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​import java.util.List;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​import java.util.Map;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​public class Demo {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        public static final long serialVersionUID = 1L;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        void f(int x, String y) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        int[ ] g(/*no args*/) { return null; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        List&lt;Map&lt;String, Integer&gt;&gt;[] h() { return null; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11E1D">
只需几行代码，我们就能调整 Java 类定义，而不会干扰插入点之外的任何内容。此策略对于源代码检测或重构的一般问题非常有效。这
<code class="cf class">TokenStreamRewriter</code>是一种强大且极其有效的操纵标记流的方法。 
</p><p>
With only a few lines of code, we were able to tweak a Java class definition without
disturbing anything outside of our insertion point. This strategy is very effective for the
general problem of source code instrumentation or refactoring. The
<code class="cf class">TokenStreamRewriter</code> is a powerful and extremely efficient means of
manipulating a token stream. 
</p>
<p id="f_0030.html.N11E24">
在结束我们的旅程之前，还有一个词汇方面的好东西涉及一个平凡的问题，但如果没有像 ANTLR 的令牌通道这样的通用方案，这个问题将很难解决。
</p><p>
One more lexical goodie before finishing our tour  involves a mundane issue but one
that is a beast to solve without a general scheme like ANTLR’s token channels.
</p>
<h3>通过不同渠道发送代币</h3><h3>Sending Tokens on Different Channels</h3>
<p id="f_0030.html.N11E2B">
我们之前研究过的 Java 接口提取器神奇地保留了方法签名中的空格和注释，如下所示：
</p><p>
The Java interface extractor we looked at earlier magically preserves whitespace and comments in method signatures such as the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong>[ ] g(<em class="comment">/*no args*/</em>) { <strong class="prompt">return</strong> null; }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11E51">
传统上，这是一项难以满足的要求。对于大多数语法，注释和空格是解析器可以忽略的内容。如果我们不想在语法中明确允许空格和注释，我们需要词法分析器将它们丢弃。不幸的是，这意味着应用程序代码和任何后续处理步骤都无法访问空格和注释。保留但忽略注释和空格的秘诀是将这些标记通过“隐藏通道”发送给解析器。解析器只调整到一个通道，因此我们可以在其他通道上传递任何我们想要的东西。Java 语法就是这样做的：
</p><p>
Traditionally, this has been a nasty requirement to fulfill. For most grammars, comments and
whitespace are things the parser can ignore. If we don’t want to explicitly allow whitespace
and comments all over the place in a grammar, we need the lexer to throw them out.
Unfortunately, that means the whitespace and comments are inaccessible to application
code and any subsequent processing steps. The secret to preserving but ignoring comments and
whitespace is to send those tokens to the parser on a “hidden channel.” The parser 
tunes to only a single channel and so we can pass anything we want on the other channels. Here’s
how the Java grammar does it:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Java.g4">游览/Java.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'/*'</em> .*? <em class="string">'*/'</em>    -&gt; channel(HIDDEN) <em class="comment">// match anything between /* and */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0030.html.N11E7A">
是<code class="cf ic">-&gt; channel(HIDDEN)</code>一个词法分析器命令，就像<code class="cf ic">-&gt; skip</code>我们之前讨论过的一样。在这种情况下，它设置这些标记的通道号，以便解析器忽略它。标记流仍然保持标记的原始序列，但在提供给解析器时会跳过通道外的标记。
</p><p>
The <code class="cf ic">-&gt; channel(HIDDEN)</code> is a lexer command like the <code class="cf ic">-&gt; skip</code> we discussed
before. In this case, it sets the channel number of these tokens so that it’s ignored by
the parser. The token stream still maintains the original sequence of tokens but skips
over the off-channel tokens when feeding the parser.
</p>
<p id="f_0030.html.N11E83">
了解了这些词汇特性之后，我们就可以结束 ANTLR 之旅了。本章介绍了使 ANTLR 易于使用和灵活的所有主要元素。我们没有介绍任何细节，但我们看到 ANTLR 正在解决一些小而实际的问题。我们对语法符号有了一定的了解。我们实现了访问者和监听器，让我们可以在不将动作嵌入语法的情况下进行计算和翻译。我们还看到，有时，为了满足我们内心的控制欲，嵌入的动作正是我们想要的。最后，我们了解了使用 ANTLR 词法分析器和标记流可以做的一些很酷的事情。
</p><p>
With these lexical features out of the way, we can wrap up our ANTLR tour. This
chapter covered all of the major elements that make ANTLR easy to use and flexible. We
didn’t cover any of the details, but we saw ANTLR in action solving some small but real
problems. We got a feel for grammar notation. We implemented visitors and listeners that
let us calculate and translate without embedding actions in the grammar. We also saw
that, sometimes, embedded actions are exactly what we want in order to satisfy our inner
control freak. And, finally, we looked at some cool things we can do with ANTLR lexers
and token streams.
</p>
<p id="f_0030.html.N11E8C">
现在是时候放慢我们的步伐，重新回顾本章中探讨的所有概念，以学习所有细节为目标。本书下一部分的每一章都将使我们朝着成为语言实现者迈出一步。我们将从学习 ANTLR 符号开始，并弄清楚如何从示例和语言参考手册中得出语法。一旦我们掌握了这些基础知识，我们将为现实世界的语言构建一些语法，然后学习我们刚刚快速浏览过的树监听器和访问者的细节。之后，我们将继续讨论第三部分中的一些精湛主题。
</p><p>
It’s time to slow down our pace  and revisit all of the concepts explored in this chapter
with the goal of learning all of the details. Each chapter in the next part of the book
will take us another step toward becoming language implementers. We’ll start by learning
ANTLR notation and figuring out how to derive grammars from examples and language reference
manuals. Once we have those fundamentals, we’ll build some grammars for real-world
languages and then learn the details of the tree listeners and visitors we just raced
through. After that, we’ll move on to some
virtuoso topics in Part III.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0030.html.FOOTNOTE-18" href="#f_0025.html.FNPTR-18">[18]</a>
</td>
<td>
<p id="f_0030.html.N11022">
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p><p>
<a href="http://pragprog.com/titles/tpantlr2/source_code">http://pragprog.com/titles/tpantlr2/source_code</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0030.html.FOOTNOTE-19" href="#f_0028.html.FNPTR-19">[19]</a>
</td>
<td>
<p id="f_0030.html.N11755">
<a href="http://asm.ow2.org/">http://asm.ow2.org</a>
</p><p>
<a href="http://asm.ow2.org">http://asm.ow2.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0030.html.FOOTNOTE-20" href="#f_0030.html.FNPTR-20">[20]</a>
</td>
<td>
<p id="f_0030.html.N11BF2">
<a href="http://www.stringtemplate.org/">http://www.stringtemplate.org</a>
</p><p>
<a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0030.html.FOOTNOTE-21" href="#f_0030.html.FNPTR-21">[21]</a>
</td>
<td>
<p id="f_0030.html.N11BF8">
<a href="https://www.djangoproject.com/">https://www.djangoproject.com</a>
</p><p>
<a href="https://www.djangoproject.com">https://www.djangoproject.com</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0031.html"><div>

<h1 class="part-title" id="f_0031.html.N11E8F">
<span class="part-number">第 2 部分</span>
<br><br>使用 ANTLR 语法开发语言应用程序</h1><h1 class="part-title">
<span class="part-number">Part 2</span>
<br><br>Developing Language Applications with ANTLR Grammars</h1>
<blockquote class="pg-partintro">
<p id="f_0031.html.N11E98">
在第二部分中，我们将学习如何从语言规范和示例输入中得出语法。我们将为逗号分隔值、JSON、DOT 图形格式、一种简单的编程语言和 R 构建语法。一旦我们知道如何设计语法，我们将通过遍历解析树来深入了解构建语言应用程序的细节。
</p>
</blockquote><blockquote class="pg-partintro">
<p>
In Part II, we’ll learn how to derive grammars from language specifications and sample inputs. We’ll build grammars for comma-separated values, JSON, the DOT graphics format, a simple programming language, and R. Once we know how to design grammars, we’ll dig into the details of building language applications by walking parse trees.
</p>
</blockquote>



</div></div>
<div id="f_0032.html"><div>

<h1 class="chapter-title" id="f_0032.html.chp.structures">
<span class="chapter-number">
	      第五章</span>
<br><br>
<span class="chapter-name">设计语法</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      5</span>
<br><br>
<span class="chapter-name">Designing Grammars</span>
</h1>

<p id="f_0032.html.N11EA4">
在第一部分中，我们熟悉了 ANTLR，并了解了语法和语言应用程序的高级视图。现在，我们将放慢速度，学习执行有用任务所需的细节，例如构建内部数据结构、提取信息和生成输入的翻译。不过，我们旅程的第一步是学习如何构建语法。在本章中，我们将研究最常用的词汇和句法语言结构，并弄清楚如何用 ANTLR 符号来表达它们。有了这些 ANTLR 构建块，我们将在下一章中将它们组合起来构建一些真正的语法。
</p><p>
In Part I, we got acquainted with ANTLR and saw a high-level view of grammars and
language applications. Now we’re going to slow down and learn the details needed to perform
useful tasks such as building internal data structures, extracting information, and generating
a translation of the input. The first step on our journey, though, is to learn how to build
grammars. In this chapter, we’ll look at the most commonly used lexical and syntactic
language structures and figure out how to express them in ANTLR notation. Armed with these
ANTLR building blocks, we’ll combine them to build some real grammars in the next chapter.
</p>
<p id="f_0032.html.N11EA7">
要学习如何构建语法，我们不能仅仅浏览各种 ANTLR 构造。首先，我们需要研究常见的语言模式，并学会在计算机语言句子中识别它们。这就是我们了解整体语言结构的方式。（语言模式是一种重复出现的语法结构，例如英语中的主语-谓语-宾语或日语中的主语-宾语-谓语这样的序列。）最终，我们需要能够从一组代表性输入文件中推断出一种语言的结构。一旦我们识别出一种语言的结构，我们就可以用 ANTLR 语法正式地表达它。
</p><p>
To learn how to build grammars, we can’t just wade through the various ANTLR
constructs. First, we need to study the common language patterns and learn to identify them
in computer language sentences. That is how we get a picture of the overall language
structure. (A language pattern is a recurring grammatical structure, such as a sequence like
subject–verb–object in English or subject–object–verb in Japanese.) Ultimately, we need the
ability to divine a language’s structure from a set of representative input files. Once we
identify a language’s structure, we can express it formally with an ANTLR grammar.
</p>
<p id="f_0032.html.N11EB0">好消息是，尽管过去五十年发明了大量语言，但需要处理的基本语言模式相对较少。这是有道理的，因为人们倾向于设计遵循我们大脑对自然语言的限制的语言。我们期望标记顺序很重要，并且期望标记之间存在依赖关系。例如，<code class="cf ic">{(})</code>由于标记顺序， 是不合语法的，并且
<code class="cf ic">(1+2</code>让我们疯狂地寻找匹配的<code class="cf ic">)</code>。语言也往往相似，因为设计师遵循数学中的通用符号。即使在词汇层面，语言也倾向于重用相同的结构，例如标识符、整数、字符串等。</p><p>The good news is that there are relatively few fundamental language patterns to deal with,
despite the vast number of languages invented over the past fifty years. This makes sense
because people tend to design languages that follow the constraints our brains place on
natural language. We expect token order to matter and expect dependencies between tokens.
For example, <code class="cf ic">{(})</code> is ungrammatical because of the token order, and
<code class="cf ic">(1+2</code> drives us crazy looking for the matching <code class="cf ic">)</code>. Languages also
tend to be similar because designers follow common notation from mathematics. Even at the
lexical level, languages tend to reuse the same structures, such as identifiers, integers,
strings, and so on.</p>
<p id="f_0032.html.N11EC1">
源自自然语言的词序和依赖性的约束发展成为四种抽象的计算机语言模式。
</p><p>
The constraints of word order and dependency, derived from natural language, blossom into
four abstract computer language patterns.
</p>
<ul>
<li>
<p id="f_0032.html.N11EC7">
<span class="firstuseinline">序列</span>：这是元素的序列，例如数组初始值设定项中的值。
	</p>
</li><li>
<p>
<span class="firstuseinline">Sequence</span>: This is a sequence of elements such as the values in an array initializer.
	</p>
</li>
<li>
<p id="f_0032.html.N11ECD">
<span class="firstuseinline">选择</span>：这是在多个备选短语之间的选择，例如编程语言中的不同类型的语句。
</p>
</li><li>
<p>
<span class="firstuseinline">Choice</span>: This is a choice between multiple, alternative phrases such as the different kinds of statements in a programming language.
</p>
</li>
<li>
<p id="f_0032.html.N11ED3">
<span class="firstuseinline">标记依赖性</span>：一个标记的存在要求其对应部分在短语的其他地方也存在，例如匹配左括号和右括号。
</p>
</li><li>
<p>
<span class="firstuseinline">Token dependence</span>: The presence of one token requires the presence of its counterpart elsewhere in a phrase such as matching left and right parentheses.
</p>
</li>
<li>
<p id="f_0032.html.N11ED9">
<span class="firstuseinline">嵌套短语</span>：这是一种自相似的语言结构，例如编程语言中的嵌套算术表达式或嵌套语句块。
  </p>
</li><li>
<p>
<span class="firstuseinline">Nested phrase</span>: This is a self-similar language construct such as nested arithmetic expressions or nested statement blocks in a programming language.
  </p>
</li>
</ul>
<p id="f_0032.html.N11EDE">
为了实现这些模式，我们实际上只需要由替代项、标记引用和规则引用组成的语法规则（<span class="firstuseinline">Backus-Naur-Format</span> [BNF]）。但为了方便起见，我们还将这些元素分组为<span class="firstuseinline">子规则</span>。子规则只是用括号括起来的内联规则。我们可以将子规则标记为可选（<code class="cf ic">?</code>）以及零个或多个（<code class="cf ic">*</code>）或一个或多个（<code class="cf ic">+</code>）循环，以多次识别封闭的语法片段（<span class="firstuseinline">扩展 Backus-Naur-Format</span> [EBNF]）。
</p><p>
To implement these patterns, we really only need grammar rules comprised
of alternatives, token references, and rule references (<span class="firstuseinline">Backus-Naur-Format</span> [BNF]). For convenience, though, we’ll also
group those elements into <span class="firstuseinline">subrules</span>. Subrules are just in-lined rules
wrapped in parentheses. We can mark subrules as optional (<code class="cf ic">?</code>) and as zero-or-more
(<code class="cf ic">*</code>) or one-or-more (<code class="cf ic">+</code>) loops to recognize the enclosed grammar fragments
multiple times (<span class="firstuseinline">Extended Backus-Naur-Format</span> [EBNF]).
</p>
<p id="f_0032.html.N11EF9">
毫无疑问，大多数读者在其职业生涯中都会看到某种形式的语法或至少是正则表达式，但让我们从头开始，以便我们都能达成共识。
</p><p>
No doubt most readers will have seen some form of grammar or at least regular expressions during their career, but let’s start at the very beginning so we’re all on the same page.
</p>

</div></div>
<div id="f_0033.html"><div>

<h2 id="f_0033.html.sec.abstracting-grammars">5.1 从语言样本导出文法</h2><h2>5.1 Deriving Grammars from Language Samples</h2>
<p id="f_0033.html.N11F01">
编写语法与编写软件非常相似，只不过我们使用的是规则而不是函数或过程。（请记住，ANTLR 会为语法中的每个规则生成一个函数。）但是，在关注规则内部之前，值得讨论一下语法的整体结构以及如何形成初始语法骨架。这就是我们在本节中要做的，因为这是任何语言项目中重要的第一步。如果您迫不及待地想要构建和执行第一个解析器，您可以重新阅读第 4 章“<a href="#f_0025.html.chp.tour"><em>快速</em></a><a href="#f_0025.html.chp.tour">浏览或<em></em></a>跳至下一章中的第一个示例：第 6.1 节“<a href="#f_0040.html.sec.CSV">解析<em>逗号分隔值”</em>。</a>在我们学习这里的基础知识时，您可以随意来回跳转到下一章中的示例。
</p><p>
Writing a grammar is a lot like writing software except that we work with rules instead of
functions or procedures. (Remember that ANTLR generates a function for each rule in your
grammar.) But, before focusing on the rule innards, it’s worth discussing the overall
anatomy of a grammar and how to form an initial grammar skeleton. That’s what we’ll do in
this section because it’s an important first step in any language project. If you’re itching
to build and execute your first parser, you can revisit Chapter 4, <a href="#f_0025.html.chp.tour">​<em>A Quick Tour</em>​</a> or jump to
the first example in the next chapter: Section 6.1, <a href="#f_0040.html.sec.CSV">​<em>Parsing Comma-Separated Values</em>​</a>. Feel free to pop back and
forth to the examples in the next chapter as we learn the fundamentals here.
</p>
<p id="f_0033.html.N11F10">
语法由一个命名语法的标题和一组可以相互调用的规则组成。
</p><p>
Grammars consist of a header that names the grammar and a set of rules that can invoke each other.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> MyG;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule1 : stuff ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule2 : more stuff ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0033.html.N11F33">
就像编写软件一样，我们必须弄清楚我们需要哪些规则，“<span class="elide emph">东西</span>”是什么，以及哪条规则是<span class="firstuseinline">起始规则</span>（类似于<code class="cf methodname">main</code>方法）。
</p><p>
Just like writing software, we have to figure out which rules we need, what «<span class="elide emph">stuff</span>» is, and which rule is the <span class="firstuseinline">start rule</span> (analogous to a <code class="cf methodname">main</code> method).
</p>
<p id="f_0033.html.N11F3F">
要弄清楚某一特定语言的所有这些问题，我们要么必须非常了解该语言，要么拥有一组有代表性的输入样本。当然，从参考手册或甚至以另一个解析器生成器的格式获取该语言的语法会很有帮助。但现在，让我们假设我们没有现有的语法作为指南。
</p><p>
To figure all this out for a given language, we either have to know that language really well or have a set of representative input samples.  Naturally, it helps to have a grammar for the language from a reference manual or even in the format of another parser generator.  But for now, let’s assume we don’t have an existing grammar as a guide.
</p>
<p id="f_0033.html.N11F42">
正确的语法设计反映了编程世界中的功能分解或自上而下的设计。这意味着我们从最粗略到最精细的层次进行工作，识别语言结构并将其编码为语法规则。因此，第一个任务是找到最粗略的语言结构的名称，这将成为我们的起始规则。在英语中，我们可以使用<code class="cf keyword">sentence</code>。对于 XML 文件，我们可以使用<code class="cf keyword">document</code>。对于 Java 文件，我们可以使用<code class="cf keyword">compilationUnit</code>。</p><p>
Proper grammar design mirrors functional decomposition or top-down design in the programming world. That means we work from the coarsest to the finest level, identifying language structures and encoding them as grammatical rules.  So, the first task is to find a name for the coarsest language structure, which becomes our start rule. In English, we could use <code class="cf keyword">sentence</code>. For an XML file, we could use <code class="cf keyword">document</code>. For a Java file, we could use <code class="cf keyword">compilationUnit</code>.</p>
<p id="f_0033.html.N11F4F">
设计起始规则的内容就是用英语伪代码描述输入的整体格式，就像我们编写软件时所做的一样。例如，“逗号分隔值 (CSV) 文件是由换行符终止的行序列。”左边的单词<span class="emph">file </span><span class="emph">is a是规则名称，而</span><span class="emph">is a</span>右边的所有内容则成为规则定义右侧的
“<span class="elide emph">内容”。</span></p><p>
Designing the contents of the start rule is a matter of describing the overall format of the input in English pseudocode, kind of like we do when writing software. For example, “a comma-separated-value (CSV) file is a sequence of rows terminated by newlines.”  The essential word <span class="emph">file</span> to the left of <span class="emph">is a</span> is the rule name, and everything to the right of <span class="emph">is a</span> becomes the «<span class="elide emph">stuff</span>» on the right side of a rule definition.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : sequence of rows that are terminated by newlines ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0033.html.N11F6D">
然后，我们通过描述起始规则右侧标识的元素，将粒度降低一个级别。右侧的名词通常是对标记或尚未定义的规则的引用。标记是我们大脑通常将其视为单词、标点符号或运算符的元素。正如单词是英语句子中的原子元素一样，标记是解析器语法中的原子。但是，规则引用指的是需要分解成更详细的其他语言结构，例如<span class="emph">行</span>。
</p><p>
Then we step down a level in granularity by describing the elements identified on the right side of the start rule. The nouns on the right side are typically references to either tokens or yet-to-be-defined rules. The tokens are elements that our brain normally latches onto as words, punctuation, or operators.  Just as words are the atomic elements in an English sentence, tokens are the atoms in a parser grammar. The rule references, however, refer to other language structures that need to be broken down into more detail like <span class="emph">row</span>.
</p>
<p id="f_0033.html.N11F73">
再进一步，我们可以说一行是由逗号分隔的一系列<span class="emph">字段。然后，</span><span class="emph">字段</span>是一个数字或字符串。我们的伪代码如下所示：
</p><p>
Stepping down another level of detail, we could say that a row is a sequence of <span class="emph">field</span>s separated by commas.   Then, a <span class="emph">field</span> is a number or string. Our pseudocode looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file  : sequence of rows that are terminated by newlines ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row   : sequence of fields separated by commas ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field : number or string ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0033.html.N11F97">
当我们没有规则可定义时，我们就有了语法的草稿。
</p><p>
When we run out of rules to define, we have a rough draft of our grammar.
</p>
<p id="f_0033.html.N11F9A">
让我们看看这种技术如何描述 Java 文件中的一些关键结构。（我们可以用斜体突出规则名称。）在最粗略的级别上，Java
<span class="emph">编译单元</span>是一个可选的<span class="emph">包说明</span>符，后跟一个或多个<span class="emph">类定义</span>。向下一级，类定义是关键字
<code class="cf ic">class</code>，后跟标识符，后跟可选的<span class="emph">超类说明符</span>，后跟可选的<span class="emph">implements 子句</span>，后跟类
<span class="emph">主体</span>。<span class="emph">类主体</span>是一系列用大括号括起来的<span class="emph">成员。</span><span class="emph">成员</span>是嵌套的类定义、
<span class="emph">字段</span>或<span class="emph">方法</span>。从这里开始，我们将描述
<span class="emph">字段</span>和<span class="emph">方法</span>，然后描述<span class="emph">方法</span>中的
<span class="emph">语句</span>。你明白了。从尽可能高的级别开始，然后向下工作，甚至将像 Java 类定义这样的大型子短语视为稍后要定义的规则。在语法伪代码中，我们将像这样开始：
<span class="emph"></span></p><p>
Let’s see how this technique works for describing some of the key structures in a Java file.
(We can make the rule names stand out by italicizing them.) At the coarsest level, a Java
<span class="emph">compilation unit</span> is an optional <span class="emph">package specifier</span>, followed by one
or more <span class="emph">class definition</span>s. Stepping down a level, a class definition is keyword
<code class="cf ic">class</code>, followed by an identifier, followed optionally by a <span class="emph">superclass
specifier</span>, followed optionally by an <span class="emph">implements clause</span>, followed by a
<span class="emph">class body</span>. A <span class="emph">class body</span> is a series of <span class="emph">member</span>s
enclosed in curly braces. A <span class="emph">member</span> is a nested class definition, a
<span class="emph">field</span>, or a <span class="emph">method</span>. From here, we would describe
<span class="emph">fields</span> and <span class="emph">methods</span> and then the <span class="emph">statements</span> within
<span class="emph">method</span>s. You get the idea. Start at the highest possible level and work your
way down, treating even large subphrases like Java class definitions as rules to define
later. In grammar pseudocode, we’d start out like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​compilationUnit  : optional packageSpec then classDefinitions ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​packageSpec      : <em class="string">'package'</em> identifier <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​classDefinition  :​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="string">'class'</em> optional superclassSpec optional implementsClause classBody ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​superclassSpec   : <em class="string">'super'</em> identifier ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​implementsClause :​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="string">'implements'</em> one or more identifiers separated by comma ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​classBody        : <em class="string">'{'</em> zero-or-more members <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​member           : nested classDefinition or field or method ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0033.html.N12018">
如果我们有可以作为参考的语法，那么为 Java 这样的大型语言设计语法就会容易得多，但要小心。盲目遵循现有的语法可能会让你误入歧途，我们将在下文中讨论。
</p><p>
Designing a grammar for a large language like Java is a lot easier if we have access
to a grammar that we can use as a reference, but be careful. Blindly following an existing grammar can lead you astray, as we’ll discuss next.
</p>

</div></div>
<div id="f_0034.html"><div>

<h2 id="f_0034.html.sec.existing-grammars">5.2 使用现有语法作为指导</h2><h2>5.2 Using Existing Grammars as a Guide</h2>
<p id="f_0034.html.N12023">
能够访问非 ANTLR 格式的现有语法是了解其他人如何决定分解语言中的短语的好方法。至少，现有语法为我们提供了一份不错的规则名称列表，可用作指南。不过，需要注意的是。我建议不要将参考手册中的语法剪切并粘贴到 ANTLR 中并对其进行修改直至其正常工作。将其视为指南而不是一段代码。
	</p><p>
Having access to existing grammar in non-ANTLR format is a great way to figure out how
somebody else decided to break down the phrases in a language. At the very least, an
existing grammar gives us a nice list of rule names to use as a guide. A word of caution,
though. I recommend against cutting and pasting a grammar from a reference manual into ANTLR
and massaging it until it works. Treat it as a guide rather than a piece of code.
	</p>
<p id="f_0034.html.N12032">
出于语法清晰度的原因，参考手册通常相当松散，这意味着语法可以识别出许多语言中没有的句子。或者，语法可能具有歧义，能够以多种方式匹配相同的输入序列。例如，语法可能会说表达式可以调用构造函数或调用函数。问题是输入<code class="cf ic">T(i)</code>可能匹配两者。理想情况下，我们的语法中不会有这样的歧义。我们确实需要对每个输入句子进行单一解释，以便翻译它或执行其他任务。
</p><p>
Reference manuals are often pretty loose for grammar clarity reasons, meaning that the
grammar recognizes lots of sentences not in the language. Or, the grammar might be
ambiguous, able to match the same input sequence in more than one way. For example, a
grammar might say that an expression can invoke a constructor or call a function. The
problem is that input like <code class="cf ic">T(i)</code> could match both. Ideally, there would be no such
ambiguities in our grammar. We really need a single interpretation of each input sentence   to translate it or perform some other task.
</p>
<p id="f_0034.html.N12038">
在另一个极端，参考手册中的语法有时会过度指定规则。有些约束我们应该在解析输入后强制执行，而不是尝试用语法结构来强制执行约束。例如，在处理第 12.4 节“<a href="#f_0075.html.sec.XML">解析<em>和词法分析 XML”</em>时，</a>我浏览了 W3C XML 语言定义，却迷失在所有细节中。举一个简单的例子，XML 语法明确指定了标记中必须有空格的位置以及空格是可选的。知道这一点很好，但我们只需让词法分析器在将标记发送到解析器之前删除标记内的空格即可。我们的语法不需要在任何地方都测试空格。
</p><p>
At the opposite extreme, grammars in reference manuals sometimes over-specify the rules.  There are some constraints that we should enforce after parsing the input, rather than trying to enforce the constraints with grammatical structure. For example, when working on Section 12.4, <a href="#f_0075.html.sec.XML">​<em>Parsing and Lexing XML</em>​</a>, I scanned through the W3C XML language definition and got lost in all the details.  As a trivial example, the XML grammar explicitly specifies where we must have whitespace in a tag and where it’s optional. That’s good to know, but we can simply have a lexer strip out whitespace inside of tags before sending it to the parser. Our grammar need not have tests for whitespace everywhere.
</p>
<p id="f_0034.html.N1203E">
规范还指出，<code class="cf ic">&lt;?xml ...&gt;</code>标签可以具有两个特殊属性：<code class="cf ic">encoding</code>和<code class="cf ic">standalone</code>。我们需要知道该约束，但允许任何属性名称，然后在解析后检查解析树以确保满足所有这些约束会更容易。最后，XML 只是嵌入在文本中的一堆标签，因此其语法结构相当简单。唯一的挑战是区别对待标签内部和外部的内容。我们将在第 12.3 节“<a href="#f_0074.html.sec.islands"><em>流中的</em></a><a href="#f_0074.html.sec.islands">岛屿”<em></em></a>中进一步讨论这一点。
</p><p>
The specification also says that the <code class="cf ic">&lt;?xml ...&gt;</code> tag can have two special
attributes: <code class="cf ic">encoding</code> and <code class="cf ic">standalone</code>. We need to know that constraint, but
it’s easier to allow any attribute name and then, after parsing, inspect the parse tree to
ensure all such constraints are satisfied. In the end, XML is just a bunch of tags embedded
in text, so its grammatical structure is fairly straightforward. The only challenge is
treating what’s inside and outside the tags differently. We’ll look at this more in Section 12.3, <a href="#f_0074.html.sec.islands">​<em>Islands in the Stream</em>​</a>.
</p>
<p id="f_0034.html.N1204D">
识别语法规则并用伪代码表达它们的右侧一开始很有挑战性，但随着你为更多语言构建语法，它会变得越来越容易。通过本书中的示例，你将得到大量的练习。
</p><p>
Identifying the grammar rules and expressing their right sides in pseudocode is
challenging at first but gets easier and easier as you build grammars for more languages.
You’ll get lots of practice as you go through the examples in this book.
</p>
<p id="f_0034.html.N12050">
一旦我们有了伪代码，我们就需要将其转换为 ANTLR 符号以获得可用的语法。在下一节中，我们将定义几乎任何语言中都有的四种语言模式，并了解它们如何映射到 ANTLR 构造。之后，我们将弄清楚如何定义语法中引用的标记，例如整数和标识符。请记住，我们在本章中研究的是语法开发基础知识。它将为我们在下一章中处理现实世界的例子提供坚实的基础。
</p><p>
Once we have pseudocode, we need to translate it to ANTLR notation to get a working grammar.
In the next section, we’ll define four language patterns found in just about any language
and see how they map to ANTLR constructs. After that, we’ll figure out how to define the
tokens referenced in our grammars, such as integer and identifier. Remember that we’re
looking at grammar development fundamentals in this chapter. It will give us the solid
footing we need in order to tackle the real-world examples in the next chapter.
</p>

</div></div>
<div id="f_0035.html"><div>

<h2 id="f_0035.html.sec.common-lex-structures">5.3 使用 ANTLR 语法识别常见语言模式</h2><h2>5.3 Recognizing Common Language Patterns with ANTLR Grammars</h2>
<p id="f_0035.html.N1205E">
现在我们已经有了自上而下粗略制定语法的通用策略，我们需要关注常见的语言模式：序列、选择、标记依赖和嵌套短语。我们在上一节中看到了这些模式的一些示例，但现在我们将看到来自各种语言的更多示例。随着我们的学习，我们将通过将特定模式表达为正式的语法规则来学习基本的 ANTLR 符号。让我们从最常见的语言模式开始。
</p><p>
Now that we have a general top-down strategy for roughing out a grammar, we need to focus
on the common language patterns: sequence, choice, token dependence, and nested phrase.
We saw a few examples of these patterns in the previous section, but now we’re going to see many more examples from a variety of languages. As we go along, we’ll learn basic ANTLR notation by expressing the specific patterns as formal grammar rules. Let’s start with the most common language pattern.
</p>
<h3 id="f_0035.html.sec.sequences">模式：序列</h3><h3>Pattern: Sequence</h3>
<p id="f_0035.html.N12066">
计算机语言中最常见的结构是元素序列，例如类定义中的方法序列。即使是 HTTP、POP 和 SMTP 网络协议等简单语言也表现出序列模式。协议需要一系列命令。例如，以下是登录 POP 服务器并获取第一条消息的序列：
</p><p>
The structure you’ll see most often in computer languages is a sequence of elements, such
as the sequence of methods in a class definition. Even simple languages like the HTTP,
POP, and SMTP network protocols exhibit the sequence pattern. Protocols expect a sequence
of commands. For example, here’s the sequence to log into a POP server and get the first message:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​USER parrt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PASS secret​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RETR 1​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12080">
甚至命令本身也是序列。大多数命令都是一个关键字（保留标识符），例如<code class="cf ic">USER</code>和<code class="cf ic">RETR</code>，后跟一个操作数，然后是换行符。例如，在语法中，我们会说检索命令是一个关键字，后跟一个整数，后跟一个换行符标记。要在语法中指定这样的序列，我们只需按顺序列出元素即可。在 ANTLR 表示法中，检索命令只是序列<code class="cf ic">’RETR’ INT ’\n’</code>，其中<code class="cf keyword">INT</code>表示整数标记类型。
</p><p>
Even the commands themselves are sequences. Most commands are a keyword (reserved
identifier), such as <code class="cf ic">USER</code> and <code class="cf ic">RETR</code>, followed by an operand and then
newline. For example, in a grammar we’d say that the retrieve command is a keyword
followed by an integer followed by a newline token. To specify such a sequence in a
grammar, we simply list the elements in order. In ANTLR notation, the retrieve command is
just sequence <code class="cf ic">’RETR’ INT ’\n’</code>, where <code class="cf keyword">INT</code> represents the
integer token type.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​retr  : <em class="string">'RETR'</em> INT <em class="string">'\n'</em> ; <em class="comment">// match keyword integer newline sequence</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N120A3">
请注意，我们可以将任何简单的字母序列（例如关键字或标点符号）直接作为字符串文字包含<code class="cf ic">’RETR’</code>在语法中。（我们将探索词汇结构，例如<code class="cf keyword">INT</code>第 5.5 节<a href="#f_0037.html.sec.lexicalstructures">“识别<em>常见词汇结构”</em>。</a> ）</p><p>
Notice that we can include any simple sequence of letters, such as keywords or punctuation,
directly as string literals like <code class="cf ic">’RETR’</code> in the grammar. (We’ll explore lexical
structures such as <code class="cf keyword">INT</code> in Section 5.5, <a href="#f_0037.html.sec.lexicalstructures">​<em>Recognizing Common Lexical Structures</em>​</a>.)</p>
<p id="f_0035.html.N120AF">我们使用语法规则来标记语言结构，就像我们在编程语言中将语句列表标记为函数一样。在这种情况下，我们将序列标记<code class="cf ic">RETR</code>为<code class="cf keyword">retr</code>规则。在语法的其他地方，我们可以使用
<code class="cf ic">RETR</code>规则名称作为简写来引用序列。
</p><p>We use grammar rules to label language structures just like we label statement lists as
functions in a programming language. In this case, we’re labeling the <code class="cf ic">RETR</code> sequence
as the <code class="cf keyword">retr</code> rule. Elsewhere in the grammar, we can refer to the
<code class="cf ic">RETR</code> sequence with the rule name as a shorthand.
</p>
<p id="f_0035.html.N120BB">
让我们看一个任意长的序列，例如 Matlab 向量中的简单整数列表，如<code class="cf ic">[1 2 3]</code>。与有限序列一样，我们希望一个元素跟随下一个元素，但我们不能用 这样的规则片段列出所有可能的整数列表
<code class="cf ic">INT INT INT INT INT INT INT INT INT...</code>。
</p><p>
Let’s look at an arbitrarily long sequence such as the simple list of integers in a
Matlab vector like <code class="cf ic">[1 2 3]</code>. As with a finite sequence, we want one element to
follow the next, but we can’t list all possible integer lists with rule fragments like
<code class="cf ic">INT INT INT INT INT INT INT INT INT...</code>.
</p>
<p id="f_0035.html.N120C4">
要对一个或多个元素的序列进行编码，我们使用<code class="cf ic">+</code>子规则运算符。例如，<code class="cf ic">(INT)+</code>描述任意长的整数序列。作为简写，
<code class="cf ic">INT+</code>也可以。要指定列表可以为空，我们使用零或多个
<code class="cf ic">*</code>运算符：<code class="cf ic">INT*</code>。此运算符类似于编程语言中的循环，当然，ANTLR 生成的解析器就是这样实现它们的。
</p><p>
To encode a sequence of one or more elements, we use the <code class="cf ic">+</code> subrule operator. For
example, <code class="cf ic">(INT)+</code> describes an arbitrarily long sequence of integers. As a shorthand,
<code class="cf ic">INT+</code> is OK too. To specify that a list can be empty, we use the zero-or-more
<code class="cf ic">*</code> operator: <code class="cf ic">INT*</code>. This operator is analogous to a loop in a programming
language, which of course is how ANTLR-generated parsers implement them.
</p>
<p id="f_0035.html.N120E0">
此模式的变体包括<span class="firstuseinline">带终止符的序列</span>  和<span class="firstuseinline">带分隔符的序列</span>。CSV 文件很好地演示了这两种序列。以下是我们用 ANTLR 符号表达上一节中的伪代码语法的方法：
</p><p>
Variations on this pattern include the <span class="firstuseinline">sequence with terminator</span>  and <span class="firstuseinline">sequence with separator</span>. CSV
files demonstrate both nicely. Here’s how we can express the pseudocode grammar from
the previous section in ANTLR notation:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : (row <em class="string">'\n'</em>)* ;        <em class="comment">// sequence with a '\n' terminator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row  : field (<em class="string">','</em> field)* ; <em class="comment">// sequence with a ',' separator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field: INT ;                <em class="comment">// assume fields are just integers</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12107">
规则<code class="cf keyword">file</code>使用带有终止符模式的列表来匹配零个或多个
<code class="cf ic">row ’\n’</code>序列。<code class="cf keyword">’\n’</code>标记终止序列的每个元素。规则<code class="cf keyword">row</code>使用带有分隔符模式的列表，通过匹配<code class="cf keyword">field</code>后跟零个或多个<code class="cf ic">’,’ field</code>
序列。<code class="cf keyword">’,’</code>分隔字段。匹配诸如和和之<code class="cf keyword">row</code>
类的序列，等等。
<code class="cf ic">1</code><code class="cf ic">1,2</code><code class="cf ic">1,2,3</code></p><p>
Rule <code class="cf keyword">file</code> uses the list with terminator pattern to match zero or more
<code class="cf ic">row ’\n’</code> sequences. The <code class="cf keyword">’\n’</code> token terminates each element of
the sequence. Rule <code class="cf keyword">row</code> uses the list with separator pattern by
matching a <code class="cf keyword">field</code> followed by zero or more <code class="cf ic">’,’ field</code>
sequences. The <code class="cf keyword">’,’</code> separates the fields. <code class="cf keyword">row</code>
matches sequences like <code class="cf ic">1</code> and <code class="cf ic">1,2</code> and <code class="cf ic">1,2,3</code>, and so on.
</p>
<p id="f_0035.html.N1212B">
我们在编程语言中也看到同样的结构。例如，下面介绍如何在 Java 等编程语言中识别语句序列，其中每个语句都以分号结尾：
</p><p>
We see the same constructs in programming languages. For example, here’s how to
recognize statement sequences in a programming language like Java where each statement is
terminated by a semicolon:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stats : (stat <em class="string">';'</em>)* ; <em class="comment">// match zero or more ';'-terminated statements</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N1213F">
这里是如何指定一个以逗号分隔的表达式列表，例如我们在函数调用参数列表中找到的表达式列表：
</p><p>
And here is how to specify a comma-separated list of expressions such as we’d find in a
function call argument list:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​exprList : expr (<em class="string">','</em> expr)* ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12151">
甚至 ANTLR 的元语言也使用序列模式。以下是 ANTLR 在其自身语法中表达规则定义语法的部分方式：
</p><p>
Even ANTLR’s metalanguage uses sequence patterns. Here’s partially how ANTLR expresses rule
definition syntax in its own syntax:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// match 'rule-name :' followed by at least one alternative followed</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// by zero or more alternatives separated by '|' symbols followed by ';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule : ID <em class="string">':'</em> alternative (<em class="string">'|'</em> alternative )* <em class="string">';'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12171">
最后，有一种特殊的零或一序列，用 指定<code class="cf ic">?</code>，我们用它来表达可选构造。例如，在 Java 语法中，我们可能会找到与<code class="cf ic">(’extends’ identifier)?</code>可选超类规范匹配的序列。同样，为了匹配变量定义上的可选初始化程序，我们可以说<code class="cf ic">(’=’ expr)?</code>。可选运算符有点像在某物和无物之间进行选择。作为下一节的预览，<code class="cf ic">(’=’ expr)?</code>
与 相同<code class="cf ic">(’=’ expr | )</code>。
</p><p>
Finally, there is a special kind of zero-or-one sequence, specified with the <code class="cf ic">?</code>,
that we use to express optional constructs. In a Java grammar, for example, we might find
a sequence like <code class="cf ic">(’extends’ identifier)?</code> that matches the optional superclass
specification. Similarly, to match an optional initializer on a variable definition, we
could say <code class="cf ic">(’=’ expr)?</code>. The optional operator is kind of like a choice between
something and nothing. As a preview to the next section, <code class="cf ic">(’=’ expr)?</code>
is the same as <code class="cf ic">(’=’ expr | )</code>.
</p>
<h3>模式：选择（替代方案）</h3><h3>Pattern: Choice (Alternatives)</h3>
<p id="f_0035.html.N1218F">
只有一个句子的语言会非常无聊。即使是最简单的语言（例如网络协议），也有多个有效句子，例如POP 的<code class="cf ic">USER</code>和
<code class="cf ic">RETR</code>命令。这给我们带来了选择模式。我们已经在 J​​ava 语法伪代码中看到了规则的选择“<span class="elide emph">嵌套的 classDefinition 或字段或方法</span>” <code class="cf keyword">member</code>。
</p><p>
A language with only one sentence would be pretty boring. Even the simplest languages, such
as network protocols, have multiple valid sentences such as the <code class="cf ic">USER</code> and
<code class="cf ic">RETR</code> commands of POP. This brings us to the choice pattern. We’ve already seen a
choice in the Java grammar pseudocode «<span class="elide emph">nested classDefinition or field or
method</span>» for rule <code class="cf keyword">member</code>.
</p>
<p id="f_0035.html.N121A4">
为了在语言中表达选择的概念，我们<code class="cf ic">|</code>在 ANTLR 规则中使用“或”运算符来分隔称为<span class="firstuseinline">替代</span>或
<span class="firstuseinline">产生式</span>的语法选择。语法充满了选择。 
</p><p>
To express the notion of choice in a language, we use <code class="cf ic">|</code> as the “or” operator in
ANTLR rules to separate grammatical choices called <span class="firstuseinline">alternatives</span> or
<span class="firstuseinline">productions</span>. Grammars are full of choices. 
</p>
<p id="f_0035.html.N121B5">
回到我们的 CSV 语法，我们可以<code class="cf keyword">field</code>通过允许选择整数或字符串来制定更灵活的规则。
</p><p>
Returning to our CSV grammar, we can make a more flexible <code class="cf keyword">field</code> rule by
allowing the choice of integers or strings.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field : INT | STRING ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N121C7">
查看下一章中的语法，我们会发现很多选择模式的示例，例如<code class="cf keyword">type</code>第 6.4 节<a href="#f_0043.html.sec.Cymbol">“解析<em>Cymbol”</em></a>中的规则中的类型名称列表。
</p><p>
Looking through the grammars in the next chapter, we’ll find lots of choice pattern examples, such as the list of type names in rule <code class="cf keyword">type</code> from Section 6.4, <a href="#f_0043.html.sec.Cymbol">​<em>Parsing Cymbol</em>​</a>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​type:   <em class="string">'float'</em> | <em class="string">'int'</em> | <em class="string">'void'</em> ; <em class="comment">// user-defined types</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N121E7">
在第 6.3 节<a href="#f_0042.html.sec.DOT">“解析<em>DOT”</em>中，</a>我们将看到图形描述中可能的语句列表。
</p><p>
In Section 6.3, <a href="#f_0042.html.sec.DOT">​<em>Parsing DOT</em>​</a>, we’ll see the list of possible statements in a graph description.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stmt:   node_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   edge_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   attr_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   id <em class="string">'='</em> id​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   subgraph​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N1220B">
任何时候，如果你发现自己说“语言结构<span class="standin">x</span>可以是这个或那个”，那么你就确定了一个选择模式。<code class="cf ic">|</code>在规则<span class="standin">x</span>中使用。
</p><p>
Any time you find yourself saying “language structure <span class="standin">x</span> can be either this or that,” then you’ve identified a choice pattern. Use <code class="cf ic">|</code> in rule <span class="standin">x</span>.
</p>
<p id="f_0035.html.N12217">
语法序列和选择让我们可以对许多语言结构进行编码，但还有两个关键模式需要关注：标记依赖性和短语嵌套。它们通常在语法中一起使用，但为了简单起见，我们先单独讨论标记依赖性。
</p><p>
Grammar sequences and choices let us encode lots of language constructs, but there are
two key remaining patterns to look at: token dependency and phrase nesting. They’re
typically used together in grammars, but let’s start with token dependencies in isolation
for simplicity.
</p>
<h3>模式：Token 依赖</h3><h3>Pattern: Token Dependency</h3>
<p id="f_0035.html.N12221">
以前，我们用<code class="cf ic">INT+</code>Matlab 向量来表示非空整数序列，<code class="cf ic">[1 2 3]</code>。要用方括号指定向量，我们需要一种方法来表达标记之间的依赖关系。如果我们在句子中看到一个符号，我们必须在句子的其他地方找到与之匹配的符号。为了用语法来表达这一点，我们使用一个指定两个符号的序列，通常将其他元素括起来或分组。在这种情况下，我们完全指定这样的向量：
</p><p>
Previously, we used <code class="cf ic">INT+</code> to express the nonempty sequence of integers in a Matlab
vector, <code class="cf ic">[1 2 3]</code>. To specify a vector with the surrounding square brackets, we need
a way to express dependencies between tokens. If we see one symbol in a sentence, we must
find its matching counterpart elsewhere in the sentence. To express this with a grammar, we
use a sequence that specifies both symbols, usually enclosing or grouping other elements. In
this case, we completely specify vectors like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​vector : <em class="string">'['</em> INT+ <em class="string">']'</em> ; <em class="comment">// [1], [1 2], [1 2 3], ...</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N1224A">
浏览一下您最喜欢的语言中的任何非平凡程序，您都会看到各种必须成对出现的分组符号：<code class="cf ic">(...)</code>、<code class="cf ic">{...}</code>和
<code class="cf ic">[...]</code>。从第 6.4 节<a href="#f_0043.html.sec.Cymbol">“解析<em>Cymbol”</em>中，</a>我们发现方法调用的括号和数组索引的方括号之间存在标记依赖关系。
</p><p>
Glance at any nontrivial program in your favorite language, and you’ll see all sorts of
grouping symbols that must occur in pairs: <code class="cf ic">(...)</code>, <code class="cf ic">{...}</code>, and
<code class="cf ic">[...]</code>. From Section 6.4, <a href="#f_0043.html.sec.Cymbol">​<em>Parsing Cymbol</em>​</a>, we find token dependencies between the parentheses of a method call and the square brackets of an array index.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr <em class="string">'('</em> exprList? <em class="string">')'</em>  <em class="comment">// func call like f(), f(x), f(1,2)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'['</em> expr <em class="string">']'</em>       <em class="comment">// array index like a[i], a[i][j]</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N1227E">
我们还看到方法声明中左括号和右括号之间的标记依赖关系。
</p><p>
We also see token dependencies between left and right parentheses in method declarations.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​functionDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type ID <em class="string">'('</em> formalParameters? <em class="string">')'</em> block <em class="comment">// "void f(int x) {...}"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​formalParameters​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   formalParameter (<em class="string">','</em> formalParameter)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​formalParameter​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N122B1"><a href="#f_0041.html.sec.JSON">第 6.2 节“解析<em>JSON”</em></a>
中的语法将对象定义周围的花括号<a href="#f_0041.html.sec.JSON">匹配</a><code class="cf ic">{ "name":"parrt", "passwd":"secret" }</code>。
</p><p>
The grammar from Section 6.2, <a href="#f_0041.html.sec.JSON">​<em>Parsing JSON</em>​</a> matches up curly braces around object definitions such as <code class="cf ic">{ "name":"parrt", "passwd":"secret" }</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'{'</em> pair (<em class="string">','</em> pair)* <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'{'</em> <em class="string">'}'</em> <em class="comment">// empty object</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​pair:   STRING <em class="string">':'</em> value ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N122E6">有关匹配标记的更多  
<a href="#f_0044.html.sec.R">示例</a>
请参阅第 6.5 节<a href="#f_0044.html.sec.R">“解析<em>R” 。</em></a></p><p>
See Section 6.5, <a href="#f_0044.html.sec.R">​<em>Parsing R</em>​</a> for more examples of matching tokens.  
</p>
<p id="f_0035.html.N122EC">
请记住，依赖符号不一定必须匹配。C 派生语言也有<code class="cf ic">a?b:c</code>三元运算符，其中设置了在短语后面
<code class="cf ic">?</code>看到的要求。<code class="cf ic">:</code></p><p>
Keep in mind that dependent symbols don’t necessarily have to match. C-derived languages
also have the <code class="cf ic">a?b:c</code> ternary operator where the <code class="cf ic">?</code> sets up a requirement to
see <code class="cf ic">:</code> later in the phrase.
</p>
<p id="f_0035.html.N122F8">
此外，仅仅因为我们有匹配的标记并不一定意味着嵌套短语。例如，向量可能不允许嵌套向量。但一般来说，包含在匹配符号中的子短语通常会嵌套。我们得到像<code class="cf ic">a[(i)]</code>和 这样的结构<code class="cf ic">{while
(b) {i=1;}}</code>。这将我们带到了我们可能需要的最终语言模式。
</p><p>
Also, just because we have matching tokens doesn’t necessarily imply a nested phrase. For
example, a vector might not allow nested vectors. In general, though, subphrases enclosed
in matching symbols typically nest. We get constructs like <code class="cf ic">a[(i)]</code> and <code class="cf ic">{while
(b) {i=1;}}</code>. This brings us to the final language pattern we’re likely to need.
</p>
<h3 id="f_0035.html.sec.nested-phrase">模式：嵌套短语</h3><h3>Pattern: Nested Phrase</h3>
<p id="f_0035.html.N1230C">
嵌套短语具​​有自相似语言结构，其子短语符合相同的结构。表达式是典型的自相似语言结构，由用运算符分隔的嵌套子表达式组成。类似地， 的
<code class="cf ic">while</code>代码块是嵌套在外部代码块中的代码块。我们在语法中使用递归规则来表达自相似语言结构。因此，如果规则的伪代码引用自身，我们将需要递归（自引用）规则。
</p><p>
A nested phrase has a self-similar language structure, one whose subphrases
conform to that same structure. Expressions are the quintessential self-similar language
structure and are made up of nested subexpressions separated by operators. Similarly, a
<code class="cf ic">while</code>’s code block is a code block nested within an outer code block. We express
self-similar language structures using recursive rules in grammars. So, if the pseudocode for
a rule references itself, we are going to need a recursive (self-referencing) rule.
</p>
<p id="f_0035.html.N12318">
让我们看看代码块的嵌套是如何工作的。while 语句是关键字<code class="cf ic">while</code>
后跟括号中的条件表达式，后跟语句。我们还可以通过将多个语句括在花括号中来将它们视为单个块语句。语法上表达如下：
</p><p>
Let’s see how nesting works for code blocks. A while statement is the keyword <code class="cf ic">while</code>
followed by a condition expression in parentheses followed by a statement. We can also treat
multiple statements as a single block statement by wrapping them in curly braces. Expressing
that grammatically looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'while'</em> <em class="string">'('</em> expr <em class="string">')'</em> stat  <em class="comment">// match WHILE statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'{'</em> stat* <em class="string">'}'</em>              <em class="comment">// match block of statements in curlies</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...                           <em class="comment">// and other kinds of statements</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12348"><code class="cf keyword">stat</code>的
循环语句<code class="cf ic">while</code>可以是单个语句，也可以是一组语句（如果我们将它们括在 中）<code class="cf ic">{...}</code>。规则
<code class="cf keyword">stat</code>是<span class="firstuseinline">直接递归的</span>，因为它在第一个（和第二个）替代方案中引用了自身。如果我们将第二个替代方案移至其自己的规则，规则<code class="cf keyword">stat</code>和<code class="cf keyword">block</code>将相互
<span class="firstuseinline">间接递归</span>。
</p><p>
The looping statement, <code class="cf keyword">stat</code>, of the <code class="cf ic">while</code> can be a single
statement or a group of statements if we enclose them in <code class="cf ic">{...}</code>. Rule
<code class="cf keyword">stat</code> is <span class="firstuseinline">directly recursive</span> because it refers to
itself in the first (and second) alternatives. If we moved the second alternative to its own
rule, rules <code class="cf keyword">stat</code> and <code class="cf keyword">block</code> would be mutually
<span class="firstuseinline">indirectly recursive</span>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'while'</em> <em class="string">'('</em> expr <em class="string">')'</em> stat  <em class="comment">// match WHILE statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | block                      <em class="comment">// match a block of statements</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...                           <em class="comment">// and other kinds of statements</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​block: <em class="string">'{'</em> stat* <em class="string">'}'</em> ;           <em class="comment">// match block of statements in curlies</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N12392">
大多数非平凡语言都有多个自相似结构，从而导致大量递归规则。让我们看一个简单语言的表达式规则，该语言只有三种表达式：索引数组引用、括号表达式和整数。以下是我们在 ANTLR 符号中表达的方式：
</p><p>
Most nontrivial languages have multiple self-similar constructs, leading to lots of
recursive rules. Let’s look at an expression rule for a simple language that has just three
kinds of expressions: indexed array references, parenthesized expressions, and integers.
Here’s how we would express that in ANTLR notation:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: ID <em class="string">'['</em> expr <em class="string">']'</em>  <em class="comment">// a[1], a[b[1]], a[(2*b[1])]</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'('</em> expr <em class="string">')'</em>     <em class="comment">// (1), (a[1]), (((1))), (2*a[1])</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT              <em class="comment">// 1, 94117</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0035.html.N123C2">
注意递归是如何自然发生的。数组索引表达式的索引部分本身就是一个表达式，因此我们只需引用<code class="cf keyword">expr</code>该替代方案即可。数组索引替代方案本身就是一个表达式这一事实不应该困扰我们。语言构造的性质决定了规则引用的使用恰好是递归的。
</p><p>
Notice how the recursion happens naturally. The index component of an array index
expression is itself an expression, so we just reference <code class="cf keyword">expr</code> in that
alternative. The fact that the array index alternative is itself an expression shouldn’t
bother us. The nature of the language construct dictates the use of a rule reference that
just happens to be recursive.
</p>
<p id="f_0035.html.N123C8">
以下是两个示例输入的解析树：
</p><p>
Here are the parse trees for two sample inputs:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJEAAACEBAAAAABwWHvWAAAACXBIWXMAAABIAAAASABGyWs+AAAD80lEQVRo3u3Xv08TYRgHcGZ3/gOjiYMsThpl0IQQQuokCZgwODgQ6UTKL7nFgAzKZjSadNCIBpJKITaGhHfERLGTkOhQ42BRikcUuJa73uP9eO/uvev74+4KRsw9Ce3b9Hk/fd/3rvClBQ6pdlr+fWkDaTVJOOs9blzhSIX6VUgJpTRuXGVK31Gh/kUs6WncuMuUPl0vwI5YUiXcyJa0m+GkLG5USizpeUhJwo37MkvqzoSUcCN7d0MdoSTox417TAngdQm0dqF0Cze+5EhbRgMSStu4scSR4lciJVIixZI2s1qpUtlAlWXBLFojKeln7qjtvQu95xf6+BC1kZSqA3kYSufhWV6wJGojKSk9GXiVW4KlJYFEbSSlWhqg61JenhRJ1Ebfid/oUKSh/JWLIona2HgXCBlG41FKlbBSRSTFrSOUPnaHnFmV+FK1c/h+KEgfn5J5kjoqzW/kwkjr8so4R9JHyqCYf/KFdSABqmbZ0tTPQajKMCyWpgEQFJjSalGRoZ6F+pgIKhdNqT7IkMpZMLcuGWu/zYe0CTAlKCOqVJuAWs54njd+NiWu9BBsyR4EJc3Y0htzoJgP64gDKTlHshYXkHTjmDVrJcaRGzUrMyHdvvzWZ30rNUjmzLI1Mo4cy4xalT0JRoOStRt8KSR3t9SqzQAhOa8cyTphJ6fPu1eAWs4nIN8KsWRf9SfOgeLncpYGuSeDfKdmS/adWHMmVp3DXi02Qqq7UuS0Zz3prjV867TU3bUEvu7g9pISzLqS/Y2tS26PO9JHglC52CjZN5Up5exle+1et1oKSMR/md5bP7wTP4zyJEWivF0LfpXLNOSeX9ql9cCY4LVV61iaRYSkT8Oa/mFtTH+HqDPbrcdAftqVLUl/fIGQvr5ILe7NtT6da6VKWtr6uEB+UpC9pq0eQppcblOuqW0HXW3U3ajWYQbzkzJjSVrnTUIaykjqCTWldqU4UjA/KVlLUmYyhPTAGCxuna0O0KV6v3VF0/78hHd3cIrc3f45KaP0nbz8mS7hEw/kp9/+u+CX5O0h5YxqXQHpkTf0Uk/BL6mIImkrAUmjSUW/RJRehBB1HPOTWSjMzGDQii01BK24UmPQiilRglZMiRK04km0oBVLogatOBI9aMWQGEErusQKWtElVtCKLDGDVlSJHbQiSpygFU3iBa1oEi9oRZK4QYsqyQwpZz0ygtYR//bd5k5hBC2aVD3NlRhBiyapGTrBD1rU3dElQdCKIAmCVgRJELQiSIKgFUESBK0YdyYjaMWQGEGruW8LGbSOTX4KXSiREimREum/l+RDk8hqTiKDVlOSL2g1JfmCVnO7S6S/LZGVSCGlPxgSZ0PbIMYCAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjQyLTA2OjAwtQ61swAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo0Mi0wNjowMMRTDQ8AAAAgdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADE0NXgxMzIrMCsw9qXYBQAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuNQ1Ag1dMAAAAAElFTkSuQmCC" alt="图片/结构/Expr-parse-trees.png">
</div>
<p id="f_0035.html.N123D0">
正如我们在第 2.1 节“<a href="#f_0015.html.sec.terms">让<em>我们获取元数据！”</em>中看到的，</a>内部树节点是规则引用，而叶子是标记引用。从树根到任何节点的路径表示该元素的规则调用堆栈（或 ANTLR 生成的递归下降解析器的调用堆栈）。表示递归嵌套子树的路径对同一规则有多个引用。我喜欢将规则节点视为标记下面的子树。根是
，所以整个树都是一个表达式。带有<code class="cf keyword">expr</code>的子树
将该整数标记为表达式。
<code class="cf keyword">expr</code><code class="cf ic">1</code></p><p>
As we saw in Section 2.1, <a href="#f_0015.html.sec.terms">​<em>Let’s Get Meta!</em>​</a>, the internal tree nodes are rule references, and the
leaves are token references. A path from the root of the tree to any node represents the rule
invocation stack for that element (or call stack for an ANTLR-generated recursive-descent
parser). Paths representing recursive, nested subtrees have multiple references to the same
rule. I like to think of the rule nodes as labeling the subtrees underneath. The root is
<code class="cf keyword">expr</code>, so the entire tree is an expression. The subtree with
<code class="cf keyword">expr</code> before <code class="cf ic">1</code> labels that integer as an expression.
</p>
<p id="f_0035.html.N123DF">
并非所有语言都有表达式，例如数据格式，但您遇到的大多数语言都有相当复杂的表达式（请参阅第 6.5 节<a href="#f_0044.html.sec.R">“解析<em>R”</em>）</a> 。此外，表达式语法规范并不总是显而易见的，因此值得花一些时间深入研究识别表达式的细节。我们接下来会这样做。 
</p><p>
Not all languages have expressions, such as data formats, but most languages you’ll run into
have fairly complex expressions (see Section 6.5, <a href="#f_0044.html.sec.R">​<em>Parsing R</em>​</a>). Moreover, expression grammar
specifications are not always obvious, so it’s worth spending some time digging into the
details of recognizing expressions. We’ll do that next. 
</p>
<p id="f_0035.html.N123EB">
为了方便将来参考，这里有一个表格总结了 ANTLR 的核心语法符号：
</p><p>
For future reference, here’s a table summarizing ANTLR’s core grammar notation:
</p>
<hr>
<div class="figurecaption">表 1. ANTLR 核心符号</div>
<table class="simpletable ">
<thead>
<tr>
<th>句法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">
<span class="standin">十</span>
</p><p class="last-para-in-cell">
<span class="standin">x</span>
</p>
</td>
<td style="">
<p class="last-para-in-cell">匹配标记、规则引用或子规则<span class="standin">x</span>。</p><p class="last-para-in-cell">Match token, rule reference, or subrule <span class="standin">x</span>.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">
<span class="standin">xy</span>
 ... <span class="standin">z</span><span class="standin">​</span><span class="standin"></span>
</p><p class="last-para-in-cell">
<span class="standin">x</span>
<span class="standin">y</span> ... <span class="standin">z</span>
</p>
</td>
<td style="">
<p class="last-para-in-cell">匹配一系列规则元素。</p><p class="last-para-in-cell">Match a sequence of rule elements.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">（... | ... | ...）</p><p class="last-para-in-cell">(... | ... | ...)</p>
</td>
<td style="">
<p class="last-para-in-cell">具有多种替代方案的子规则。</p><p class="last-para-in-cell">Subrule with multiple alternatives.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">
<span class="standin">x</span>？</p><p class="last-para-in-cell">
<span class="standin">x</span>?</p>
</td>
<td style="">
<p class="last-para-in-cell">匹配<span class="standin">x</span>或跳过它。</p><p class="last-para-in-cell">Match <span class="standin">x</span> or skip it.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">
<span class="standin">x</span> *</p><p class="last-para-in-cell">
<span class="standin">x</span>*</p>
</td>
<td style="">
<p class="last-para-in-cell">匹配<span class="standin">x</span>零次或多次。</p><p class="last-para-in-cell">Match <span class="standin">x</span> zero or more times.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">
<span class="standin">x</span> +</p><p class="last-para-in-cell">
<span class="standin">x</span>+</p>
</td>
<td style="">
<p class="last-para-in-cell">匹配<span class="standin">x</span>一次或多次。</p><p class="last-para-in-cell">Match <span class="standin">x</span> one or more times.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">r：...；</p><p class="last-para-in-cell">r : ... ;</p>
</td>
<td style="">
<p class="last-para-in-cell">定义规则<code class="cf keyword">r</code>。</p><p class="last-para-in-cell">Define rule <code class="cf keyword">r</code>.</p>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:17%">
<p class="last-para-in-cell">r：...|...|...；</p><p class="last-para-in-cell">r : ... | ... | ... ;</p>
</td>
<td style="">
<p class="last-para-in-cell">定义<code class="cf keyword">r</code>具有多种替代方案的规则。</p><p class="last-para-in-cell">Define rule <code class="cf keyword">r</code> with multiple alternatives.</p>
</td>
</tr>
</tbody>
</table>
<hr>
<p id="f_0035.html.N12475">
下表总结了我们迄今为止所了解的有关常见计算机语言模式的知识：
</p><p>
And here is a table summarizing what we’ve learned so far about common computer language patterns:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>图案名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:32%">
<p class="last-para-in-cell">顺序</p><p class="last-para-in-cell">Sequence</p>
</td>
<td style="">
<p>
      这是有限或任意长度的标记或子短语序列。示例包括变量声明（类型后跟标识符）和整数列表。以下是一些示例实现：</p><p>
      This is a finite or arbitrarily long sequence of tokens or subphrases. Examples include  variable declarations (type followed by identifier) and lists of integers. Here are some sample  implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​x y ... z           <em class="comment">// x followed by y, ..., z</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<em class="string">'['</em> INT+ <em class="string">']'</em>        <em class="comment">// Matlab vector of integers</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:32%">
<p class="last-para-in-cell">带终止子的序列</p><p class="last-para-in-cell">Sequence with terminator</p>
</td>
<td style="">
<p>这是一个任意长度、可能为空的标记或子短语序列，由标记（通常是分号或换行符）分隔。示例包括 C 类语言的语句列表和以换行符结尾的数据行。以下是一些示例实现：</p><p>This is an arbitrarily long, potentially empty sequence of tokens or subphrases separated by a token, usually a semicolon or newline. Examples include statement lists from C-like languages and rows of data terminated with newlines. Here are some sample implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​(statement <em class="string">';'</em>)*    <em class="comment">// Java statement list</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​(row <em class="string">'\n'</em>)*         <em class="comment">// Lines of data</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:32%">
<p class="last-para-in-cell">带分隔符的序列</p><p class="last-para-in-cell">Sequence with separator</p>
</td>
<td style="">
<p>这是由标记（通常是逗号、分号或句点）分隔的非空任意长度的标记或子短语序列。示例包括函数参数定义列表、函数调用参数列表、语句分隔但不终止的语言以及目录名称。以下是一些示例实现：</p><p>This is a nonempty arbitrarily long sequence of tokens or subphrases separated by a token, usually a comma, semicolon, or period. Examples include function argument definition lists, function call argument lists, languages where statements are separated but not terminated, and directory names. Here are some sample implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​expr (<em class="string">','</em> expr)*        <em class="comment">// function call arguments</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​( expr (<em class="string">','</em> expr)* )?   <em class="comment">// optional function call arguments</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<em class="string">'/'</em>? name (<em class="string">'/'</em> name)*   <em class="comment">// simplified directory name</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​stat (<em class="string">'.'</em> stat)*        <em class="comment">// SmallTalk statement list</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:32%">
<p class="last-para-in-cell">选择</p><p class="last-para-in-cell">Choice</p>
</td>
<td style="">
<p>这是一组替代短语。示例包括不同类型的类型、语句、表达式或 XML 标记。以下是一些示例实现：</p><p>This is a set of alternative phrases. Examples include the different kinds of types, statements, expressions, or XML tags. Here are some sample implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​type : <em class="string">'int'</em> | <em class="string">'float'</em> ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​stat : ifstat | whilestat | <em class="string">'return'</em> expr <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​expr : <em class="string">'('</em> expr <em class="string">')'</em> | INT | ID ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​tag  : <em class="string">'&lt;'</em> Name attribute* <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em> <em class="string">'/'</em> Name <em class="string">'&gt;'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:32%">
<p class="last-para-in-cell">代币依赖</p><p class="last-para-in-cell">Token dependency</p>
</td>
<td style="">
<p>一个标记的存在要求存在一个或多个后续标记。示例包括匹配括号、花括号、方括号和尖括号。以下是一些示例实现：</p><p>The presence of one token requires the  presence of one or more subsequent tokens. Examples include matching parentheses, curly braces, square bracket, and angle brackets. Here are some sample  implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<em class="string">'('</em> expr <em class="string">')'</em>         <em class="comment">// nested expression</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​ID <em class="string">'['</em> expr <em class="string">']'</em>      <em class="comment">// array index</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<em class="string">'{'</em> stat* <em class="string">'}'</em>        <em class="comment">// statements grouped in curlies</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<em class="string">'&lt;'</em> ID (<em class="string">','</em> ID)* <em class="string">'&gt;'</em> <em class="comment">// generic type specifier</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody>
</table>
<table class="simpletable ">
<thead>
<tr>
<th>图案名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:22%">
<p class="last-para-in-cell">嵌套短语</p><p class="last-para-in-cell">Nested phrase</p>
</td>
<td style="">
<p>这是一种自相似的语言结构。示例包括表达式、嵌套 Java 类、嵌套代码块和嵌套 Python 函数定义。以下是一些示例实现：</p><p>This is a self-similar language structure. Examples include expressions, nested Java classes, nested code blocks, and nested Python function definitions. Here are some sample  implementations:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​expr : <em class="string">'('</em> expr <em class="string">')'</em> | ID ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​classDef : <em class="string">'class'</em> ID <em class="string">'{'</em> (classDef|method|field) <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody>
</table>

</div></div>
<div id="f_0036.html"><div>

<h2 id="f_0036.html.sec.precedence">5.4 处理优先级、左递归和结合律</h2><h2>5.4 Dealing with Precedence, Left Recursion, and Associativity</h2>
<p id="f_0036.html.N125B9">
表达式总是很难用自上而下的语法来指定，也很难用递归下降解析器手动识别，首先是因为最自然的语法是有歧义的，其次是因为最自然的规范使用了一种特殊的递归，称为
<span class="emph">左递归</span>。我们稍后会详细讨论后者，但现在请记住，自上而下的语法和解析器无法处理其经典形式的左递归。
</p><p>
Expressions have always been a hassle to specify with top-down grammars and to recognize by
hand with recursive-descent parsers, first because the most natural grammar is ambiguous
and second because the most natural specification uses a special kind of recursion called
<span class="emph">left recursion</span>. We’ll discuss the latter in detail later, but for now, keep in mind that
top-down grammars and parsers cannot deal with left recursion in their classic form.
</p>
<p id="f_0036.html.N125C7">
为了说明这个问题，想象一种简单的算术表达式语言，它有乘法和加法运算符以及整数“原子”。表达式是自相似的，所以我们很自然地会说乘法表达式是由运算<code class="cf ic">*</code>
符连接的两个子表达式。类似地，加法表达式是由 连接的两个子表达式<code class="cf ic">+</code>。我们也可以使用简单的整数作为表达式。将其逐字编码为语法会得到以下看似合理的规则：
</p><p>
To illustrate the problem, imagine a simple arithmetic expression language that has multiply
and addition operators and integer “atoms.” Expressions are self-similar, so it’s natural
for us to say that a multiplicative expression is two subexpressions joined by the <code class="cf ic">*</code>
operator. Similarly, an additive expression is two subexpressions joined by a <code class="cf ic">+</code>. We
can also have simple integers as expressions.  Literally encoding this as a grammar leads to
the following reasonable-looking rule:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expr <em class="string">'*'</em> expr  <em class="comment">// match subexpressions joined with '*' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'+'</em> expr  <em class="comment">// match subexpressions joined with '+' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | INT            <em class="comment">// matches simple integer atom</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0036.html.N125F1">
问题是，对于某些输入短语，此规则不明确。换句话说，此规则可以以多种方式匹配单个输入流，您可能还记得第 2.3 节“<a href="#f_0017.html.sec.ambiguity">你<em>不能将太多的水放入核反应堆”中</em></a>的内容<a href="#f_0017.html.sec.ambiguity">。</a><code class="cf ic">1+2</code>和），<code class="cf ic">1*2</code>因为只有一种方法可以匹配它们。例如，规则只能<code class="cf ic">1+2</code>使用第二种替代方法进行匹配，如图 3 中左侧解析树所示，“<a href="#f_0036.html.fig.ExprLR-parse-trees">解析<em>树</em>解释”</a>
</p><p>
The problem is that this rule is ambiguous for some input phrases. In other words, this rule
can match a single input stream in more than one way, which you might recall from Section 2.3, <a href="#f_0017.html.sec.ambiguity">​<em>You Can’t Put Too Much Water into a Nuclear Reactor</em>​</a>. It’s fine for simple integers and for single-operator expressions
such as <code class="cf ic">1+2</code> and <code class="cf ic">1*2</code> because there is only one way to match them. For
example, the rule can  match <code class="cf ic">1+2</code> only using the second alternative, as shown by the
  left parse tree in the diagram in Figure 3, <a href="#f_0036.html.fig.ExprLR-parse-trees">​<em>Parse tree interpretations</em>​</a>
</p>
<div class="figure" id="f_0036.html.fig.ExprLR-parse-trees">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM0AAABVCAAAAADP4j+bAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAASkSURBVHja7ZvLEaQ2EIYnBacwKUwIVgIuF+UMdPWxHYJSIAVdfPGtU+DgBChnoBRkgYBpCRB6IDyepau2htmlH59ohPQz+9DfZI//uoCb5gel6d5HfXZQJ4jqOlUSLCWiS9M3y3eEl8zL7AfhoCW8SnCiI3o0avzeWscmM7cNYqNgIxowRyBKaNyy9iM+tr7DeCghN7sNClMQAKWRlbWaW9ZuxDVNj8gRzSHvdKaZoHOUKUhZp22VFdFp1A15yUhOUZYg+Rd6r6ytiLudppgqobFR3kGKaVZlJdHwJyu/b+Ygghd3mlfWdsTvfnr+v+2m+Vy7aT7XbprPtZvmc+2m+VyjNEq0dtutuh7M4lt144Yi1gZ36p/ofkYaQqOeUjB86UbiT40022/zkVDO6K6Jf5r7KWkIjTC7oaeGhmvzoSUbP+LNuhP/NPdT0hAaaABA48NcFKaHP8NHvFl34p/mfkoaQtOOe1TTawqfyoxBIo11J/51aIJp6CzAX2zghgafjJmtXWI5g7sm/nVogmk2Z+jSOipxHKf5AWhUtpJ2jn92mu9dCyzMv/9SFBN/vuTaiF9Xsv8GDYL6E/KlQQWIsq3OoqBbp1nTgCFGJXKHtxsUb40lrwRibFA6cUwWorH/bhY+Iu/tzeiGepXnXFPDonhIo7iTxqNp7ZgO5+Z0Sw/97K6g8HVawNAO1bjYBNpEDk0/VzCe1yXr0KIl7m6eM21uG5uGjjqlkUuz2/O8y3hkail/WqG3VeaCdw9Pacg9+qZRZCznDUPK8JI3ELN7+tU9tvZd+5JGzHzk9Si5EMv2J3p47X3pu/dnzwU9Hd8lzXKPPjaKIeeR7guaMxbEXZ1787jVkJKnNJbGn0/Jee/LGDBvOqcjI87bTftDQyPbJnq8D3fOU4c0q35yAE6bqJUIpdELzdqxMO9ZAKn2fWtoddAMCoMnHLnXMkn3N/1Yo6ERz/BjoWPwDEzUYfeKiiMnk0JvapQjDYJfzqr2PiCNrd2Jf0XFEQRzfm0iG9tpq3JW5XWhjf6a5v0XNRVH3pLnQo8Mt2iWH7QQa0LbA4/G8a+pOPb02YHAui0a0znMK5AHbyzvZMf/QsVxuBtiOo2Hfz8U6rQLFUeMoxEPxnLvG5KsqkYnX+zVXfj0vERxvIzmEsXx+1Y2l9g/f5f5//VJNBJ+K2k1BX/E7MqvoRm2tthm/r5aj1tbjNmVX0Iz7rMxdle+MRaD/BqzK7+Cxu6zswXQRX7VcLRgrU8zI1gBNB1nkhxHkKNmrU6zaA55Aqgrvx4pdJVpiP41dUmavC08+fXg6taloff93PMJL0O25Nfgu5iaNK7kuBxHzwVyU34NvYupSIOu/kUF0BhdRIkd+TXQrPVowBtCWlvE1QnIr7rbw6lGI/2C0yYzJXPc7zV0hK0ERentT/oyxXFHsKxDsxYUufvYnNS8PcsVLKt1miso+lKetmrengUVx634tWk8QZF7Syyr5u3asXKyKVhWo/EExd57DWTVvFiaDcVyU7CsRcMPt4ohbTuoOAbiV6Lhx/8hERNotN9pO/Hr0BwJirOal0uzF/9+en6u3TSfa/8CCCOn8ySHuuwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTMtMDEtMTVUMjI6NDY6NDItMDY6MDC1DrWzAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEzLTAxLTE1VDIyOjQ2OjQyLTA2OjAwxFMNDwAAAB90RVh0cGRmOkhpUmVzQm91bmRpbmdCb3gAMjA1eDg1KzArMBMxNlYAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/结构/ExprLR-parse-trees.png">
</div>
<div class="figurecaption">
<hr>图 3. 解析树解释</div>
</div>
<p id="f_0036.html.N1260E">
问题在于，所指定的规则可以像<code class="cf ic">1+2*3</code>中间和右边的解析树所描绘的那样解释输入。它们之所以不同，是因为中间的解析树表示将 2 和 3 相乘的结果加 1，而右边的解析树表示将 1 和 2 相加的结果乘以 3。这是一个运算符优先级的问题，而传统语法根本无法指定优先级。大多数语法工具（例如 Bison）<a id="f_0036.html.FNPTR-22" href="#f_0038.html.FOOTNOTE-22">[22]</a>使用额外的符号来指定运算符优先级。
</p><p>
The problem is that the rule as specified can interpret input such as <code class="cf ic">1+2*3</code> in the
two ways depicted by the middle and right parse trees. They’re different because the middle
tree says to add 1 to the result of multiplying 2 and 3, whereas the  tree on the right
multiplies 3 by the result of adding 1 and 2. This is a question of operator precedence,
and conventional grammars simply have no way to specify precedence. Most grammar tools, such
as Bison,<a href="#f_0038.html.FOOTNOTE-22">[22]</a> use
extra notation to specify the operator precedence.
</p>
<p id="f_0036.html.N1261A">
相反，ANTLR 会根据最先给出的选项来解决歧义问题，从而隐式地允许我们指定运算符优先级。规则<code class="cf keyword">expr</code>中乘法选项在加法选项之前，因此 ANTLR 会<code class="cf ic">1+2*3</code>根据乘法来解决运算符歧义问题。
</p><p>
Instead, ANTLR resolves ambiguities in favor of the alternative given first, implicitly
allowing us to specify operator precedence. Rule <code class="cf keyword">expr</code> has the
multiplication alternative before the addition alternative, so ANTLR resolves the operator
ambiguity for <code class="cf ic">1+2*3</code> in favor of the multiplication.
</p>
<p id="f_0036.html.N12623">
默认情况下，ANTLR 将运算符关联为从左到右，正如我们期望的那样。<code class="cf ic">*</code>但是
<code class="cf ic">+</code>，某些运算符（如指数组）是从右到左的，因此我们必须使用选项手动指定运算符标记的关联性
。以下是正确解释如下<code class="cf keyword">assoc</code>输入的表达式规则
：
<code class="cf ic">2^3^4</code><code class="cf ic">2^(3^4)</code></p><p>
By default, ANTLR associates operators left to right as we’d expect for <code class="cf ic">*</code> and
<code class="cf ic">+</code>. Some operators like exponentiation group right to left, though, so we have to
manually specify the associativity on the operator token using option
<code class="cf keyword">assoc</code>. Here’s an expression rule that properly interprets input like
<code class="cf ic">2^3^4</code> as <code class="cf ic">2^(3^4)</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expr <em class="string">'^'</em>&lt;assoc=right&gt; expr <em class="comment">// ^ operator is right associative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0036.html.N12654">
下面的解析树说明了 的左结合和右结合版本之间的区别<code class="cf ic">^</code>。右侧的解析树是通常的解释，但语言设计者可以自由使用任一结合性。
</p><p>
The following parse trees illustrates the difference between left and right associative versions of <code class="cf ic">^</code>. The parse tree on the right is the usual interpretation, but language designers are free to use either associativity.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAABVCAAAAABYs5hBAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAPgSURBVGje7ZrLkZwwEIZJwSlMCqRAAj6QAhnYSkEXX11FCro4gL75TApKQSlgvYCWEFIjsM1UjWqHZSn1z6cHqH/tNPNTSvO/Ad6EZDIHac9kdHq+kMX2JLI318ZWH4C1wp8K1tagnBBLkChzbRhH8wf06ynjNSR0sdTo6GvA52G29MspdHXDQxY7IGFqZmBaMy2ndaNzQixNIjW40h8Y1lPTojoSothBn7iiOrVdrSYhimVJhle3RPChfnRoYs9+s31InlI+JB+SD8mH5B+RKD6apFNN+kfqzEJNABTZirg8iXoJ3kE792KGL71ohT5SSGri8iR8AHjNrDd5zktnFZ05EkpNXJ6E9Yzp5LMRJvU0H3MklJq4PMloM2Hdz0q3TZmm0khq4gozdmg70zrWa8WuayWRpCaO/BRTGarj3pBETXUk5Li3ecduTftdeQNyHJEE2LexhmNiX0mrA5VE6ZUDoMIDjnyGkdgECsmkffUM7teZIpl0cXeRcLf5YbrmlCEVfI2jNKFIIv3t7XAz+qOsfF0TpzghrkTCl80fN/Gog66nuMJxvDxvC/nJ1gleijboikEUV25ClgTvcizSkjDoeG7Deq2eRAVdCtvl0qDzMRk35JtwTAJh4xFVftBl+IShuvn5fkjCRQSGzsfM08x5XdwhCcRBxOcX4nrUl/0brsW4TyQc9rKSmbh7SOx+uwfp2Euka/EXO447QZIzbn3wahJ9Wg1YTILijLzTT/pCRJIzbjol2G6uM/WjeRiToDgrP1v9pC9EJDnj1vutdy/fHY1+TILinLzVT/pCRJIxbna/HY2IPDKXEQmOc/JWP+kLEckJ4wZEElycvNVPyuMZSzRuou1a6ujMkfxs9ZPy6ae41mYRS1L+6SS1ho9YkvIPX3fgx1+9p/qeyplSJFz8rPtPG61M7FcqZ2oSFfX7pJTqXSh69YFUgr0jsXUAZ/W3Fu8L5723beKKFsAsFaMgSZ/skMUX7j1CSCJ8EmoXLVG1O5Ar2BfuvG2Qn6zLrft92pIXigh9IVrdIxLg6419lVvnLbJPy0kwbzcShubFGnPfvE35wsAYNomK2BrcNVkC+7TJow0NTxL5JTSAUPO1k32HHPnCzdtaEhlv0eCpVPu1INwhUccGM3XpLEcSh16/eVYuKf+stbhk3BRc6qNEeKjvPGVTNm6T9nwXnqBEeKjvPWVTMG6+Mu1fXUclDt/pG09pRidj3NZ2XSKJwmN95ylTJIHhc1eurctReKzvPGWCJDZ82qlcS+GGkr4dvlSf7JSGayDlcKCR8KbrLsyTYrj3lM96sz2jfEj25Q+0H5VegC6EAQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0Njo0My0wNjowMBN5vgcAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDY6NDMtMDY6MDBiJAa7AAAAH3RFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAAxMzd4ODUrMCswg6627QAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuNQ1Ag1dMAAAAAElFTkSuQmCC" alt="图片/结构/Exponent-parse-trees.png">
</div>
<p id="f_0036.html.N1265F">
为了将所有三个运算符组合在一条规则中，我们将<code class="cf ic">^</code>替代运算符放在其他运算符之前，因为它的优先级高于<code class="cf ic">*</code>和<code class="cf ic">+</code>（<code class="cf ic">1+2^3</code>
为 9）。
</p><p>
To combine all three operators in a single rule, we place the <code class="cf ic">^</code> alternative before
the others because it has higher precedence than <code class="cf ic">*</code> and <code class="cf ic">+</code> (<code class="cf ic">1+2^3</code>
is 9).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expr <em class="string">'^'</em>&lt;assoc=right&gt; expr  <em class="comment">// ^ operator is right associative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'*'</em> expr  <em class="comment">// match subexpressions joined with '*' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'+'</em> expr  <em class="comment">// match subexpressions joined with '+' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | INT            <em class="comment">// matches simple integer atom</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0036.html.N1269A">
熟悉 ANTLR v3 的读者一直在耐心等待我指出 ANTLR 与所有传统的自上而下的解析器生成器一样，无法处理左递归规则。但是，ANTLR v4 的一项主要改进是它现在可以处理直接左递归。左递归规则是直接或间接在替代项的左边缘调用自身的规则。该<code class="cf keyword">expr</code>规则是直接左递归的，因为除<code class="cf keyword">INT</code>替代项之外的所有内容都以对规则本身的引用开始<code class="cf keyword">expr</code>。（它也是<span class="firstuseinline">右递归的，</span>因为<code class="cf keyword">expr</code>某些替代项的右边缘有引用。）
</p><p>
Readers familiar with ANTLR v3 have been waiting patiently for me to point out that ANTLR,
like all conventional top-down parser generators, cannot handle left-recursive rules.
However, one of ANTLR v4’s major improvements is that it can now handle direct
left recursion. A left-recursive rule is one that either directly or indirectly invokes
itself on the left edge of an alternative. The <code class="cf keyword">expr</code> rule is directly
left recursive because everything but the <code class="cf keyword">INT</code> alternative starts with a reference
to the <code class="cf keyword">expr</code> rule itself. (It’s also <span class="firstuseinline">right
recursive</span> because of the <code class="cf keyword">expr</code> references on the right edges of
some alternatives.)
</p>
<p id="f_0036.html.N126BE">
虽然 ANTLR v4 可以处理<span class="emph">直接</span>左递归，但无法处理
<span class="emph">间接</span>左递归。这意味着我们无法考虑<code class="cf keyword">expr</code>
语法等效规则。
</p><p>
While ANTLR v4 can handle <span class="emph">direct</span> left recursion, it can’t handle
<span class="emph">indirect</span> left recursion. That means we can’t factor <code class="cf keyword">expr</code>
into the grammatically equivalent rules.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expo  <em class="comment">// indirectly invokes expr left recursively via expo</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expo : expr <em class="string">'^'</em>&lt;assoc=right&gt; expr ;​</code></div>
</td>
</tr>
</tbody></table>
<div class="sidebar" id="f_0036.html.sb.precedenceClimbingExpressionParsing">
<div class="sidebar-title">优先攀升表达式解析</div>
<div class="sidebar-content">
<p id="f_0036.html.N126E9">
经验丰富的编译器编写者经常手工构建递归下降解析器，以充分利用每一点性能，并完全控制错误恢复。然而，他们通常使用<span class="firstuseinline">运算符优先级解析器</span>，而不是为长链表达式规则编写代码。<a id="f_0036.html.FNPTR-23" href="#f_0038.html.FOOTNOTE-23">[23]</a>
</p><p>
Experienced compiler writers often build recursive-descent parsers by hand to
squeeze out every last drop of performance and to allow complete control over error
recovery. Instead of writing code for the long chain of expression rules, however, they
often use <span class="firstuseinline">operator precedence
parsers</span>.<a href="#f_0038.html.FOOTNOTE-23">[23]</a>
</p>
<p id="f_0036.html.N126FA">
ANTLR 使用了一种与运算符优先级类似但更强大的策略，该策略遵循 Keith Clarke <a id="f_0036.html.FNPTR-24" href="#f_0038.html.FOOTNOTE-24">[24]</a>
在 1986 年所做的工作。Theodore Norvell 随后创造了术语“<span class="firstuseinline">优先级攀升”</span>。<a id="f_0036.html.FNPTR-25" href="#f_0038.html.FOOTNOTE-25">[25]类似地，ANTLR 用一个谓词循环代替了直接左递归，该循环比较前一个和下一个运算符的优先级。我们将在第 11 章</a><a href="#f_0067.html.chp.predicates"><em>“</em></a><a href="#f_0067.html.chp.predicates">使用<em></em></a>
中讨论谓词。 
</p><p>
ANTLR uses a similar but more powerful strategy than operator precedence that follows work
done by Keith
Clarke<a href="#f_0038.html.FOOTNOTE-24">[24]</a>
from 1986. Theodore Norvell subsequently coined the term <span class="firstuseinline">precedence
climbing</span>.<a href="#f_0038.html.FOOTNOTE-25">[25]</a>
Similarly, ANTLR replaces direct left recursion with a predicated loop that compares the precedence of
the previous and next operators. We’ll get into predicates in Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>. 
</p>
</div>
</div>
<p id="f_0036.html.N1270F">
为了使用 ANTLR v3 识别表达式，我们必须将前面看到的左递归分解<code class="cf keyword">expr</code>为多个规则，每个优先级一个规则。例如，对于带有乘法和加法运算符的表达式，我们将使用如下规则：
</p><p>
To recognize expressions with ANTLR v3, we had to unravel the left recursion we saw in the earlier <code class="cf keyword">expr</code> into multiple rules, one for each precedence level. For example, we’d use rules like the following for expressions with multiplication and addition operators:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr    : addExpr ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​addExpr : multExpr (<em class="string">'+'</em> multExpr)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​multExpr: atom (<em class="string">'*'</em> atom)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​atom    : INT ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0036.html.N12730">
C 和 Java 等语言的表达式最终有大约 15 条这样的规则，无论我们是构建自上而下的语法还是手动构建递归下降解析器，这都很麻烦。  
</p><p>
Expressions for languages such as C and Java end up with about fifteen such rules, which is a
hassle whether we’re building a top-down grammar or building a recursive-descent parser
by hand.  
</p>
<p id="f_0036.html.N12733">
ANTLR v4 简化了（直接）左递归表达式规则。新机制不仅效率更高，而且表达式规则也更小、更易于理解。例如，在 Java 语法中，专用于表达式的行数减少了一半（从 172 行减少到 91 行）。
</p><p>
ANTLR v4 makes short work of (directly) left-recursive expression rules. Not only is the new
mechanism more efficient, expression rules are much smaller and easier to understand. For
example, in a Java grammar, the number of lines dedicated to expressions dropped in half
(from 172 to 91 lines).
</p>
<p id="f_0036.html.N12736">
实际上，我们可以使用直接左递归来处理我们关心的所有语言结构。例如，这里有一条匹配 C 声明器语言子集的规则，包括如下输入<code class="cf ic">*(*a)[][]</code>：
</p><p>
In practice, we can handle all of the language structures we care about with direct left recursion. For example, here’s a rule that matches a subset of the C declarator language including input such as <code class="cf ic">*(*a)[][]</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl : decl <em class="string">'['</em> <em class="string">']'</em>  <em class="comment">// match [] suffixes using direct left-recursion</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | <em class="string">'*'</em> decl      <em class="comment">// *x, *x[], **x</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | <em class="string">'('</em> decl <em class="string">')'</em>  <em class="comment">// (x), (x[]), (*x)[]</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0036.html.N12769">
 要了解有关 ANTLR 如何支持直接左递归（使用语法转换）的更多信息，请参阅第 14 章“<a href="#f_0087.html.chp.left-recursion-removal">删除<em>直接左递归”</em></a>。
</p><p>
 To learn more about how ANTLR supports direct left recursion (using grammar transformations), please see Chapter 14, <a href="#f_0087.html.chp.left-recursion-removal">​<em>Removing Direct Left Recursion</em>​</a>.
</p>
<p id="f_0036.html.N1276F">
至此，我们已经研究了计算机语言中常见的模式，并弄清楚了如何用 ANTLR 符号来表达它们。但是在深入研究一些完整的示例之前，我们需要弄清楚如何描述语法规则中引用的标记。正如存在一些关键的语法语言模式一样，我们会发现存在一些极其常见的词汇结构。创建完整的语法就是将本节中的语法规则与下一节中的词汇规则结合起来。
</p><p>
At this point, we’ve studied the common patterns found in computer languages and figured
out how to express them in ANTLR notation. But, before we can dive into some complete
examples, we need to figure out how to describe the tokens referenced in our grammar
rules. Just as there are a few key grammatical language patterns, we’ll find that there
are some extremely common lexical structures. Creating a complete grammar is a matter of
combining grammatical rules from this section and lexical rules from the next
section.
</p>

</div></div>
<div id="f_0037.html"><div>

<h2 id="f_0037.html.sec.lexicalstructures">5.5 识别常见的词汇结构</h2><h2>5.5 Recognizing Common Lexical Structures</h2>
<p id="f_0037.html.N12783">
	 计算机语言在词汇上看起来非常相似。例如，如果我打乱顺序以掩盖语法信息，<code class="cf ic">) 10 ( f</code>从最早的语言到最新的语言，标记都可以组合成有效的短语。五十年前，我们会<code class="cf ic">(f 10)</code>在 LISP 和<code class="cf ic">f(10)</code>Algol 中看到。当然，<code class="cf ic">f(10)</code>在从 Prolog 到 Java 再到新的 Go 语言的几乎所有编程语言中也有效。<a id="f_0037.html.FNPTR-26" href="#f_0038.html.FOOTNOTE-26">[26]</a>从词汇上看，函数式、过程式、声明式和面向对象语言看起来几乎相同。太神奇了！
	 </p><p>
	 Computer languages look remarkably similar lexically. For example, if I scramble up the
     order to obscure grammatical information, tokens <code class="cf ic">) 10 ( f</code> could be combined
     into valid phrases from the earliest languages to the most recent. Fifty years ago, we’d
     see <code class="cf ic">(f 10)</code> in LISP and <code class="cf ic">f(10)</code> in Algol. Of course, <code class="cf ic">f(10)</code> is
     also valid in virtually all programming languages from Prolog to Java to the new Go
     language.<a href="#f_0038.html.FOOTNOTE-26">[26]</a> Lexically, then,
     functional, procedural, declarative, and object-oriented languages look pretty much the
     same. Amazing!
	 </p>
<p id="f_0037.html.N1279C">
这很棒，因为我们只需学习一次如何描述标识符和整数，然后几乎不用改变，就可以将它们应用于大多数编程语言。与解析器一样，词法分析器使用规则来描述各种语言结构。我们可以使用基本相同的符号。唯一的区别是解析器识别标记流中的语法结构，而词法分析器识别字符流中的语法结构。
</p><p>
That’s great because we  have to learn only how to describe identifiers and integers once
and, with little variation, apply them to most programming languages. As with parsers,
lexers use rules to describe the various language constructs. We get to use essentially the
same notation. The only difference is that parsers recognize grammatical structure in a
token stream and lexers recognize grammatical structure in a character stream.
</p>
<p id="f_0037.html.N1279F">
由于词法分析和解析规则具有相似的结构，ANTLR 允许我们将两者合并到一个语法文件中。但由于词法分析和解析是语言识别的两个不同阶段，我们必须告诉 ANTLR 每个规则与哪个阶段相关。我们通过以大写字母开头的词法分析器规则名称和以小写字母开头的解析器规则名称来实现这一点。例如，<code class="cf keyword">ID</code>是词法规则名称，
<code class="cf keyword">expr</code>是解析器规则名称。
</p><p>
Since lexing and parsing rules have similar structures, ANTLR allows us to combine both in a
single grammar file. But since lexing and parsing are two distinct phases of language
recognition, we must tell ANTLR which phase is associated with each rule. We do this by
starting lexer rule names with uppercase letters and parser rule names with lowercase
letters. For example, <code class="cf keyword">ID</code> is a lexical rule name, and
<code class="cf keyword">expr</code> is a parser rule name.
</p>
<p id="f_0037.html.N127A8">
开始编写新语法时，我通常会从现有语法（如 Java <a id="f_0037.html.FNPTR-27" href="#f_0038.html.FOOTNOTE-27">[27]）</a>中剪切并粘贴常见词汇构造的规则：<span class="emph">标识符</span>、<span class="emph">数字</span>、
<span class="emph">字符串</span>、<span class="emph">注释</span>和<span class="emph">空格</span>。只需进行一些调整，我就可以开始使用了。几乎所有语言，甚至非编程语言（如 XML 和 JSON）都有这些标记的变体。例如，尽管语法上非常不同，但 C 的词法分析器可以毫无问题地标记以下 JSON：
</p><p>
When starting a new grammar, I typically cut and paste rules from an existing grammar, such
as Java,<a href="#f_0038.html.FOOTNOTE-27">[27]</a> for the
common lexical constructs: <span class="emph">identifiers</span>, <span class="emph">numbers</span>,
<span class="emph">strings</span>, <span class="emph">comments</span>, and <span class="emph">whitespace</span>. A few tweaks, and
I’m up and running. Almost all languages, even
nonprogramming languages like XML and JSON,  have a variation of those tokens. For example, despite being very distinct
grammatically, a lexer for C would have no problem tokenizing the following JSON:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  "title":"Cat wrestling",​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  "chapters":[ {"Intro":"..."}, ... ]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N127D4">
再举一个例子，考虑一下块注释。在 Java 中，它们被括在 中<code class="cf ic">/* ...
*/</code>，而在 XML 中，注释被括在 中<code class="cf ic">&lt;!-- ... --&gt;</code>，但除了开始和结束符号外，它们的词汇结构大致相同。
</p><p>
As another example, consider block comments. In Java, they are bracketed by <code class="cf ic">/* ...
*/</code>, and in XML, comments are bracketed by <code class="cf ic">&lt;!-- ... --&gt;</code>, but they are more
or less the same lexical construct except for the start and stop symbols.
</p>
<p id="f_0037.html.N127E2">
对于关键字、运算符和标点符号，我们不需要词法分析器规则，因为我们可以在解析器规则中直接用单引号引用它们，如<code class="cf keyword">’while’</code>、
<code class="cf keyword">’*’</code>和<code class="cf keyword">’++’</code>。一些开发人员更喜欢使用诸如 之类的词法分析器规则引用，<code class="cf keyword">MULT</code>而不是文字<code class="cf ic">’*’</code>。这样，他们可以更改乘法运算符字符，而无需更改
<code class="cf keyword">MULT</code>解析器规则中的引用。同时拥有文字和词法规则<code class="cf keyword">MULT</code>没有问题；它们都产生相同的标记类型。
</p><p>
For keywords, operators, and punctuation, we don’t need lexer rules because we can directly
reference them in parser rules in single quotes like <code class="cf keyword">’while’</code>,
<code class="cf keyword">’*’</code>, and <code class="cf keyword">’++’</code>. Some developers prefer to use lexer
rule references such as <code class="cf keyword">MULT</code> instead of literal <code class="cf ic">’*’</code>. That way,
they can change the multiply operator character without altering the references to
<code class="cf keyword">MULT</code> in the parser rules.  Having both the literal and lexical rule <code class="cf keyword">MULT</code> is no problem; they both result in the same token type.
</p>
<p id="f_0037.html.N127FA">
为了演示词汇规则是什么样的，让我们构建常用标记的简单版本，从我们的朋友不起眼的标识符开始。
</p><p>
To demonstrate what lexical rules look like, let’s build simple versions of the common tokens, starting with our friend the humble identifier.
</p>
<h3 id="f_0037.html.sec.matching-identifiers">匹配标识符</h3><h3>Matching Identifiers</h3>
<p id="f_0037.html.N12802">
在语法伪代码中，基本标识符是大写和小写字母的非空序列。利用我们新学到的技能，我们知道使用符号来表达序列模式<code class="cf ic">(...)+</code>。由于序列的元素可以是大写或小写字母，我们还知道在子规则中会有一个选择运算符。
</p><p>
In grammar pseudocode, a basic identifier is a nonempty sequence of uppercase and lowercase letters.  Using our newfound skills, we know to express the sequence pattern using notation <code class="cf ic">(...)+</code>. Because the elements of the sequence can be either uppercase or lowercase letters, we also know that we’ll have a choice operator inside the subrule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : (<em class="string">'a'</em>..<em class="string">'z'</em>|<em class="string">'A'</em>..<em class="string">'Z'</em>)+ ; <em class="comment">// match 1-or-more upper or lowercase letters</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12827">
这里唯一的新 ANTLR 符号是范围运算符：<code class="cf ic">’a’..’z’</code>表示从<code class="cf ic">a</code>到 的任何字符<code class="cf ic">z</code>。这实际上是从 97 到 122 的 ASCII 代码范围。要使用 Unicode 代码点，我们需要使用<code class="cf ic">’\uXXXX’</code>文字，其中
<code class="cf ic">XXXX</code>是 Unicode 字符代码点值的十六进制值。</p><p>
The only new ANTLR notation here is the range operator: <code class="cf ic">’a’..’z’</code> means any
character from <code class="cf ic">a</code> to <code class="cf ic">z</code>. That is literally the ASCII code range from 97 to
122. To use Unicode code points, we need to use <code class="cf ic">’\uXXXX’</code> literals where
<code class="cf ic">XXXX</code> is the hexadecimal value for the Unicode character code point value.</p>
<p id="f_0037.html.N12844">
    作为字符集的简写，ANTLR 支持更为熟悉的正则表达式集符号。
  </p><p>
    As a shorthand for character sets, ANTLR supports the more familiar regular expression set notation.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : [a-zA-Z]+ ; <em class="comment">// match 1-or-more upper or lowercase letters</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12855">
诸如这样的规则<code class="cf keyword">ID</code>有时会与语法中引用的其他词汇规则或文字相冲突，例如<code class="cf ic">’enum’</code>。
</p><p>
Rules such as <code class="cf keyword">ID</code> sometimes conflict with other lexical rules or literals referenced in the grammar such as <code class="cf ic">’enum’</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> KeywordTest;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enumDef : <em class="string">'enum'</em> <em class="string">'{'</em> ... <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​FOR : <em class="string">'for'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : [a-zA-Z]+ ; <em class="comment">// does NOT match 'enum' or 'for'</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12889">
规则<code class="cf keyword">ID</code>还可以匹配诸如<code class="cf keyword">enum</code>和 之
类的关键字<code class="cf keyword">for</code>，这意味着有多个规则可以匹配同一个字符串。为了更清楚地说明这一点，请考虑 ANTLR 如何处理此类组合词法分析器/解析器语法。ANTLR 会收集所有字符串文字和词法分析器规则并将其与解析器规则分开。诸如 之类的文字<code class="cf ic">’enum’</code>将成为词法规则，并紧跟在解析器规则之后，但在显式词法规则之前。
</p><p>
Rule <code class="cf keyword">ID</code> could also match keywords such as <code class="cf keyword">enum</code> and
<code class="cf keyword">for</code>, which means there’s more than one rule that could match the same
string. To make this clearer, consider how ANTLR handles combined lexer/parser
grammars such as this. ANTLR collects and separates all of the string literals and lexer
rules from the parser rules. Literals such as <code class="cf ic">’enum’</code> become lexical rules and go
immediately after the parser rules but before the explicit lexical rules.
</p>
<p id="f_0037.html.N12898">
ANTLR 词法分析器通过优先考虑最先指定的规则来解决词法规则之间的歧义。这意味着您的<code class="cf keyword">ID</code>规则应该在所有关键字规则之后定义，就像这里相对于 一样<code class="cf keyword">FOR</code>。ANTLR 将隐式生成的文字词法规则放在显式词法分析器规则之前，因此显式词法分析器规则始终具有优先权。在这种情况下，<code class="cf ic">’enum’</code>的优先级<code class="cf keyword">ID</code>自动高于 。
</p><p>
ANTLR lexers resolve ambiguities between lexical rules by favoring the rule specified first.
That means your <code class="cf keyword">ID</code> rule should be defined after all of your keyword
rules, like it is here relative to <code class="cf keyword">FOR</code>. ANTLR puts the implicitly generated
lexical rules for literals before explicit lexer rules, so those always have priority. In
this case, <code class="cf ic">’enum’</code> is given priority over <code class="cf keyword">ID</code> automatically.
</p>
<p id="f_0037.html.N128B4"><code class="cf keyword">KeywordTest</code>由于 ANTLR 将词法规则重新排序，使其出现在解析器规则之后，因此在同一个解析器和词法分析器中会产生

以下变化：</p><p>
Because ANTLR reorders the lexical rules to occur after the parser rules, the following
variation on <code class="cf keyword">KeywordTest</code> results in the same parser and lexer:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> KeywordTestReordered;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​FOR : <em class="string">'for'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : [a-zA-Z]+ ; <em class="comment">// does NOT match 'enum' or 'for'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enumDef : <em class="string">'enum'</em> <em class="string">'{'</em> ... <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N128E8">
此标识符的定义不允许使用数字，但您可以提前查看第 6.3 节<a href="#f_0042.html.sec.DOT">“解析<em>DOT”</em>、</a> “第 6.4 节<a href="#f_0043.html.sec.Cymbol">“解析<em>Cymbol”</em> ”</a>和第 6.5 节<a href="#f_0044.html.sec.R">“解析<em>R”</em>以了解</a>完整<code class="cf keyword">ID</code>规则。
</p><p>
This definition of an identifier doesn’t allow numbers, but you can peek ahead to Section 6.3, <a href="#f_0042.html.sec.DOT">​<em>Parsing DOT</em>​</a>, Section 6.4, <a href="#f_0043.html.sec.Cymbol">​<em>Parsing Cymbol</em>​</a>, and Section 6.5, <a href="#f_0044.html.sec.R">​<em>Parsing R</em>​</a> for full-blown <code class="cf keyword">ID</code> rules.
</p>
<h3>匹配数字</h3><h3>Matching Numbers</h3>
<p id="f_0037.html.N128FB">
描述这样的整数<code class="cf ic">10</code>很容易，因为它只是一串数字。
</p><p>
Describing integer numbers such as <code class="cf ic">10</code> is easy because it’s just a sequence of
digits.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT : <em class="string">'0'</em>..<em class="string">'9'</em>+ ; <em class="comment">// match 1 or more digits</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N1291A">
或者
</p><p>
or
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT : [0-9]+ ; <em class="comment">// match 1 or more digits</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N1292B">
不幸的是，浮点数要复杂得多，但如果我们忽略指数，我们可以轻松地制作一个简化版本。（请参阅第 6.5 节<a href="#f_0044.html.sec.R">“解析<em>R”</em> ，了解</a>与完整浮点数甚至复数（如）匹配的词汇规则
<code class="cf ic">3.2i</code>。）浮点数是数字序列，后跟句点，然后是可选的小数部分，或者以句点开头，然后是数字序列。句点本身是不合法的。因此，我们的浮点规则使用选择和一些序列模式。
</p><p>
Floating-point numbers are much more complicated, unfortunately, but we can make a
simplified version easily if we ignore exponents. (See Section 6.5, <a href="#f_0044.html.sec.R">​<em>Parsing R</em>​</a> for
lexical rules that match full floating-point numbers and even complex numbers like
<code class="cf ic">3.2i</code>.) A floating-point number is a sequence of digits followed by a
period and then optionally a fractional part, or it starts with a period and continues
with a sequence of digits. A period by itself is not legal. Our floating-point rule
therefore uses a choice and a few sequence patterns.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​FLOAT:  DIGIT+ <em class="string">'.'</em> DIGIT*  <em class="comment">// match 1. 39. 3.14159 etc...</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |          <em class="string">'.'</em> DIGIT+  <em class="comment">// match .1 .14159</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIGIT   :   [0-9] ;        <em class="comment">// match single digit</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N1295B">
这里我们还使用了辅助规则，<code class="cf keyword">DIGIT</code>，因此我们不必
<code class="cf ic">[0-9]</code>到处都写。通过在规则前加上，我们让 ANTLR 知道该规则将仅由其他词汇规则使用。它本身并不是一个标记。这意味着我们无法从解析器规则中
<code class="cf keyword">fragment</code>引用。<code class="cf keyword">DIGIT</code></p><p>
Here we’re also using a helper rule, <code class="cf keyword">DIGIT</code>, so we don’t have to write
<code class="cf ic">[0-9]</code> everywhere. By prefixing the rule with <code class="cf keyword">fragment</code>, we let
ANTLR know that the rule will  be used only by other lexical rules. It is not a token in and
of itself. This means that we could not reference <code class="cf keyword">DIGIT</code> from a parser
rule.
</p>
<h3 id="f_0037.html.sec.string_literals">匹配字符串文字</h3><h3>Matching String Literals</h3>
<p id="f_0037.html.N12974">
计算机语言往往具有的下一个共同标记是字符串文字，例如
<code class="cf ic">"Hello"</code>。大多数使用双引号，但有些使用单引号甚至两者（Python）。无论选择哪种分隔符，我们都使用一条规则来匹配它们，该规则会消耗分隔符之间的所有内容。在语法伪代码中，字符串是双引号之间的任意字符序列。
</p><p>
The next token that computer languages tend to have in common is the string literal like
<code class="cf ic">"Hello"</code>. Most use double quotes, but some use single quotes or even both (Python).
Regardless of the choice of delimiters, we match them using a rule that consumes everything
between the delimiters. In grammar pseudocode, a string is a sequence of any characters between double quotes.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> .*? <em class="string">'"'</em> ; <em class="comment">// match anything in "..."</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12994">
点<span class="firstuseinline">通配符</span>运算符匹配任何单个字符。因此，
<code class="cf ic">.*</code>将是一个匹配任何零个或多个字符序列的循环。当然，这会消耗直到文件末尾，这不是很有用。相反，ANTLR  使用标准正则表达式表示法（后缀）提供对<span class="firstuseinline">非贪婪子规则</span><code class="cf ic">?</code>的支持。非贪婪本质上意味着“在词法分析器规则中看到子规则后面的内容之前，一直使用字符”。更准确地说，非贪婪子规则匹配最少数量的字符，同时仍允许整个周围规则匹配。有关更多详细信息，请参见第 15.6 节“<a href="#f_0096.html.sec.nongreedy">通配符<em>运算符和非贪婪子规则”</em>。</a>相反，被<code class="cf ic">.*</code>
认为是<span class="firstuseinline">贪婪的，</span>因为它贪婪地消耗与循环内部匹配的字符（在本例中为通配符）。如果<code class="cf ic">.*?</code>令人困惑，请不要担心。只需记住它是匹配引号或其他分隔符内内容的模式。当我们查看注释时，我们很快就会再次看到非贪婪循环。

</p><p>
The dot <span class="firstuseinline">wildcard</span> operator matches any single character. Therefore,
<code class="cf ic">.*</code> would be a loop that matches any sequence of zero or more characters. Of course,
that would consume until the end of file, which is not very useful. Instead, ANTLR provides
support for  <span class="firstuseinline">nongreedy subrules</span> using standard regular
expression notation (the <code class="cf ic">?</code> suffix). Nongreedy means essentially to “scarf
characters until you see what follows the subrule in the lexer rule.” To be more precise,
nongreedy subrules match the fewest number of characters while still allowing the entire surrounding rule
to match. See Section 15.6, <a href="#f_0096.html.sec.nongreedy">​<em>Wildcard Operator and Nongreedy Subrules</em>​</a> for more details. In contrast, the <code class="cf ic">.*</code>
is considered <span class="firstuseinline">greedy</span> because it greedily consumes characters that match
the inside of the loop (wildcard in this case). If <code class="cf ic">.*?</code> is confusing, don’t worry
about it. Just remember it as a pattern for matching stuff inside quotes or other
delimiters. We’ll see nongreedy loops again shortly when we look at comments.

</p>
<p id="f_0037.html.N129C7">
我们的<code class="cf keyword">STRING</code>规则还不够好，因为它不允许在字符串中使用双引号。为了支持这一点，大多数语言都定义了以反斜杠开头的转义序列。要在双引号字符串中使用双引号，我们使用<code class="cf ic">\"</code>。为了支持常见的转义字符，我们需要类似以下内容：
</p><p>
Our <code class="cf keyword">STRING</code> rule isn’t quite good enough yet because it doesn’t
allow double quotes inside strings. To support that, most languages define escape
sequences starting with a backslash. To get a double quote inside a double-quoted
string, we use <code class="cf ic">\"</code>. To support the common escape characters, we need something
like the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING: <em class="string">'"'</em> (ESC|.)*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ESC : <em class="string">'\\"'</em> | <em class="string">'\\\\'</em> ; <em class="comment">// 2-char sequences \" and \\</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N129F6">
ANTLR 本身需要转义转义字符，因此我们需要<code class="cf ic">\\</code>指定反斜杠字符。
</p><p>
ANTLR itself needs to escape the escape character, so that’s why we need <code class="cf ic">\\</code> to
specify the backslash character.
</p>
<p id="f_0037.html.N129FC">
现在，中的循环<code class="cf keyword">STRING</code>要么通过调用片段规则匹配转义字符序列，<code class="cf keyword">ESC</code>要么通过点通配符匹配任何单个字符。子规则运算符在看到后面的内容（未转义的双引号字符）后
<code class="cf ic">*?</code>终止循环。<code class="cf keyword">(ESC|.)*?</code></p><p>
The loop in <code class="cf keyword">STRING</code> now matches either an escape character sequence, by calling fragment rule <code class="cf keyword">ESC</code>, or any single character via the dot wildcard. The <code class="cf ic">*?</code> subrule operator terminates the <code class="cf keyword">(ESC|.)*?</code> loop upon seeing what follows, an unescaped double-quote character.
</p>
<h3>匹配注释和空格</h3><h3>Matching Comments and Whitespace</h3>
<p id="f_0037.html.N12A12">
当词法分析器匹配我们迄今为止定义的标记时，它会通过标记流将它们发送到解析器。然后，解析器检查流的语法结构。但是当词法分析器匹配注释和空格标记时，我们希望它将它们丢弃。这样，解析器就不必担心到处匹配可选注释和空格。例如，以下解析器规则在 是<code class="cf keyword">WS</code>空格词法规则时会非常尴尬且容易出错：
</p><p>
When a lexer matches the tokens we’ve defined so far, it emits them via the token stream to
the parser. The parser then checks the grammatical structure of the stream. But when the
lexer matches comment and whitespace tokens, we’d like it to toss them out. That way,
the parser doesn’t have to worry about matching optional comments and whitespace everywhere.
For example, the following parser rule would be very awkward and error-prone where <code class="cf keyword">WS</code> is a whitespace lexical rule:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​assign : ID (WS|COMMENT)? <em class="string">'='</em> (WS|COMMENT)? expr (WS|COMMENT)? ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12A33">
定义这些丢弃的标记与定义非丢弃的标记相同。我们只需使用命令指示词法分析器应丢弃它们
<code class="cf keyword">skip</code>。例如，以下是如何匹配 C 派生语言的单行和多行注释：
</p><p>
Defining these discarded tokens is the same as for nondiscarded tokens.
We just have to indicate that the lexer should throw them out using the
<code class="cf keyword">skip</code> command. For example, here is how to match both single-line and
multiline comments for C-derived languages:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LINE_COMMENT : <em class="string">'//'</em> .*? <em class="string">'\r'</em>? <em class="string">'\n'</em> -&gt; skip ; <em class="comment">// Match "//" stuff '\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT      : <em class="string">'/*'</em> .*? <em class="string">'*/'</em>       -&gt; skip ; <em class="comment">// Match "/*" stuff "*/"</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12A5B">
在 中<code class="cf keyword">LINE_COMMENT</code>，<code class="cf ic">.*?</code>使用 之后的所有内容，<code class="cf ic">//</code>
直到它看到换行符（可以选择在前面加上回车符以匹配 Windows 样式的换行符）。在 中<code class="cf keyword">COMMENT</code>，<code class="cf ic">.*?</code>使用 之后<code class="cf ic">/*</code>和之前的所有内容<code class="cf ic">*/</code>。 
</p><p>
In <code class="cf keyword">LINE_COMMENT</code>, <code class="cf ic">.*?</code> consumes everything after <code class="cf ic">//</code>
until it sees a newline (optionally preceded by a carriage return to match
Windows-style newlines). In <code class="cf keyword">COMMENT</code>, <code class="cf ic">.*?</code> consumes
everything after <code class="cf ic">/*</code> and before the terminating <code class="cf ic">*/</code>. 
</p>
<p id="f_0037.html.N12A73">
词法分析器接受运算符后面的许多命令<code class="cf ic">-&gt;</code>；
<code class="cf keyword">skip</code>只是其中之一。例如，我们可以选择使用命令将这些标记通过“隐藏通道”传递给解析器<code class="cf keyword">channel</code>
。有关标记通道的更多信息，请参阅第 12.1 节“<a href="#f_0072.html.sec.token-channels"><em>在不同通道上</em></a><a href="#f_0072.html.sec.token-channels">广播<em></em></a>。
</p><p>
The lexer accepts a number of commands following the <code class="cf ic">-&gt;</code> operator;
<code class="cf keyword">skip</code> is just one of them. For example, we have the option to pass these
tokens to the parser on a “hidden channel” by using the <code class="cf keyword">channel</code>
command. See Section 12.1, <a href="#f_0072.html.sec.token-channels">​<em>Broadcasting Tokens on Different Channels</em>​</a> for more on token channels.
</p>
<p id="f_0037.html.N12A82">
让我们来处理空格，这是我们的最后一个常用标记。大多数编程语言将空格字符视为标记分隔符，但在其他情况下会忽略它们。（Python 是一个例外，因为它将空格用于特定的语法目的：换行符用于终止命令和缩进级别，初始制表符或空格用于指示嵌套级别。）以下是如何告诉 ANTLR 丢弃空格：
</p><p>
Let’s deal with whitespace, our final common token. Most programming languages treat
whitespace characters as token separators but otherwise ignore them. (Python is an exception
because it uses whitespace for particular syntax purposes: newlines to terminate commands
and indent level, with initial tabs or spaces to indicate nesting level.) Here is how to tell
ANTLR to throw out whitespace:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS : (' '|'\t'|'\r'|'\n')+ -&gt; skip ; // match 1-or-more whitespace but discard​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12A9B">
或者
</p><p>
or
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS : [ \t\r\n]+ -&gt; skip ; // match 1-or-more whitespace but discard​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12AAA">
当换行符既是要忽略的空格又是命令终止符时，我们就遇到了问题。换行符是上下文敏感的。在一种语法上下文中，我们应该抛出换行符，而在另一种语法上下文中，我们应该将其传递给解析器，以便它知道命令已完成。例如，在 Python 中，<code class="cf ic">f()</code>后面跟着换行符会执行代码，调用<code class="cf methodname">f</code>。但我们也可以在括号之间插入一个额外的换行符。Python 会等到后面有换行符后才
<code class="cf ic">)</code>执行调用。
</p><p>
When newline is both whitespace to be ignored and the command terminator, we have a
problem. Newline is context-sensitive. In one grammatical context, we should throw
out newlines, and in another, we should pass it to the parser so that it knows a
command has finished. For example, in Python, <code class="cf ic">f()</code> followed by newline
executes the code, calling <code class="cf methodname">f</code>. But we could also insert an extra
newline between the parentheses. Python waits until the newline after the
<code class="cf ic">)</code> before executing the call.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> $ python</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> &gt;&gt;&gt; def f(): print "hi"</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​... ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> &gt;&gt;&gt; f()</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​hi​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> &gt;&gt;&gt; f(</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> ... )</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​hi​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0037.html.N12AED">
有关问题和解决方案的详细讨论，请参阅<a href="#f_0073.html.sec.python-newlines"><em>《Python 换行符的</em></a><a href="#f_0073.html.sec.python-newlines">乐趣<em></em></a>。
</p><p>
For a detailed discussion of the problem and solutions, see <a href="#f_0073.html.sec.python-newlines">​<em>Fun with Python Newlines</em>​</a>.
</p>
<p id="f_0037.html.N12AF9">
现在，我们知道如何匹配最常见的词汇结构的基本版本：标识符、数字、字符串、注释和空格。信不信由你，这对于词法分析器来说是一个很好的开始，即使是对于一个大型编程语言来说也是如此。这是一个词法分析器入门工具包，我们稍后可以将其用作参考：
</p><p>
So, now we know how to match basic versions of the most common lexical constructs:
identifiers, numbers, strings, comments, and whitespace. Believe it or not, that’s a great
start on a lexer for even a big programming language. Here’s a lexer starter kit we can use
as a reference later:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>代币类别</th>
<th>描述和示例</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">标点</p><p class="last-para-in-cell">Punctuation</p>
</td>
<td style="">
<p>处理运算符和标点符号的最简单方法是在解析器规则中直接引用它们。
		      </p><p>The easiest way to handle operators and punctuation is to directly reference them in parser rules.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​call : ID <em class="string">'('</em> exprList <em class="string">')'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p>一些程序员更喜欢定义诸如<code class="cf keyword">LP</code>（左括号）之类的标记标签。
			</p><p>Some programmers prefer to define token labels such as <code class="cf keyword">LP</code> (left parenthesis) instead.
			</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​call : ID LP exprList RP ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​LP : <em class="string">'('</em> ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​RP : <em class="string">')'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">关键词</p><p class="last-para-in-cell">Keywords</p>
</td>
<td style="">
<p>关键字是保留的标识符，我们可以直接引用它们，也可以为它们定义标记类型。
		      </p><p>Keywords are reserved identifiers, and we can either reference them directly or define token types for them.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​returnStat : <em class="string">'return'</em> expr <em class="string">';'</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">标识符</p><p class="last-para-in-cell">Identifiers</p>
</td>
<td style="">
<p>每种语言中的标识符看起来几乎相同，只是第一个字符以及是否允许使用 Unicode 字符略有不同。
		      </p><p>Identifiers look almost the same in every language, with some variation about what the first character can be and whether Unicode characters are allowed.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​ID : ID_LETTER (ID_LETTER | DIGIT)* ; <em class="comment">// From C language</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> ID_LETTER : <em class="string">'a'</em>..<em class="string">'z'</em>|<em class="string">'A'</em>..<em class="string">'Z'</em>|<em class="string">'_'</em> ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> DIGIT : <em class="string">'0'</em>..<em class="string">'9'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">数字</p><p class="last-para-in-cell">Numbers</p>
</td>
<td style="">
<p>这些是整数和简单浮点数的定义。
		      </p><p>These are definitions for integers and simple floating-point numbers.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​INT : DIGIT+ ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​FLOAT​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​    : DIGIT+ <em class="string">'.'</em> DIGIT*​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​    | <em class="string">'.'</em> DIGIT+​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">字符串</p><p class="last-para-in-cell">Strings</p>
</td>
<td style="">
<p>匹配双引号字符串。
		      </p><p>Match double-quoted strings.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​STRING :  <em class="string">'"'</em> ( ESC | . )*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> ESC : <em class="string">'\\'</em> [btnr<em class="string">"\\] ; // \b, \t, \n etc...</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">评论</p><p class="last-para-in-cell">Comments</p>
</td>
<td style="">
<p>
			匹配并丢弃评论。
		</p><p>
			Match and discard comments.
		</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​LINE_COMMENT : <em class="string">'//'</em> .*? <em class="string">'\n'</em> -&gt; skip ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​COMMENT      : <em class="string">'/*'</em> .*? <em class="string">'*/'</em> -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="font-weight:bold;font-family:Droid Sans;width:20%">
<p class="last-para-in-cell">空格</p><p class="last-para-in-cell">Whitespace</p>
</td>
<td style="">
<p>在词法分析器中匹配空格并将其丢弃。
		      </p><p>Match whitespace in the lexer and throw it out.
		      </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​WS : [ \t\n\r]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody>
</table>
<p id="f_0037.html.N12C21">
此时，我们已经制定了从示例输入文件到解析器和词法分析器规则的策略，并准备在下一章中处理这些示例。但在继续之前，有两个重要问题需要考虑。首先，在解析器中匹配的内容和在词法分析器中匹配的内容之间的界限并不总是很明显。其次，ANTLR 对我们的语法规则施加了一些我们应该了解的限制。
</p><p>
At this point, we have a strategy to go from sample input files to parser and lexer rules and are ready to tackle the examples in the next chapter.  Before we move on, though, there are two important  issues to consider.  First, it’s not always obvious where to draw the line between what we match in the parser and what we match in the lexer.   Second, ANTLR places a few constraints on our grammar rules that we should know about.
</p>

</div></div>
<div id="f_0038.html"><div>

<h2 id="f_0038.html.sec.lexer_parser_line">5.6 词法分析器和解析器之间的界限</h2><h2>5.6 Drawing the Line Between Lexer and Parser</h2>
<p id="f_0038.html.N12C2C">
由于 ANTLR 词法分析器规则可以使用递归，因此从技术上讲，词法分析器与解析器一样强大。这意味着我们甚至可以在词法分析器中匹配语法结构。或者，在另一个极端，我们可以将字符视为标记，并使用解析器将语法结构应用于字符流。（这些被称为<span class="firstuseinline">无扫描器解析器</span>。请参阅
<code class="cf filename">code/extras/CSQL.g4</code>了解与 C + SQL 的小混合相匹配的语法。）
</p><p>
Because ANTLR lexer rules can use recursion, lexers are technically as powerful as parsers.
That means we could match even grammatical structure in the lexer. Or, at the opposite
extreme, we could treat characters as tokens and use a parser to apply grammatical structure
to a character stream. (These are called <span class="firstuseinline">scannerless parsers</span>. See
<code class="cf filename">code/extras/CSQL.g4</code> for a grammar matching a small mix of C + SQL.)
</p>
<p id="f_0038.html.N12C59">
词法分析器和解析器之间的界限部分取决于语言，部分取决于预期应用程序。幸运的是，一些经验法则可以帮我们走得很远。
</p><p>
Where to draw the line between the lexer and the parser is partially a function of the
language but also a function of the intended application. Fortunately, a few rules of thumb
will get us pretty far.
</p>
<ul>
<li>
<p id="f_0038.html.N12C5F">
匹配并丢弃词法分析器中解析器根本不需要看到的任何内容。识别并丢弃编程语言中的空格和注释等内容。否则，解析器必须不断检查标记之间是否有注释或空格。
	</p>
</li><li>
<p>
Match and discard anything in the lexer that the parser does not need to see at all.
Recognize and toss out things like whitespace and comments for programming languages.
Otherwise, the parser would have to constantly check to see whether there are comments or
whitespace in between tokens.
	</p>
</li>
<li>
<p id="f_0038.html.N12C63">
  在词法分析器中匹配常见标记，例如标识符、关键字、字符串和数字。解析器的开销比词法分析器大，因此我们不应该增加解析器的负担，例如将数字放在一起以识别整数。
  </p>
</li><li>
<p>
  Match common tokens such as identifiers, keywords, strings, and numbers in
  the lexer. The parser has more overhead than the lexer, so we shouldn’t burden the
  parser with, say, putting digits together to recognize integers.
  </p>
</li>
<li>
<p id="f_0038.html.N12C67">
  将那些解析器不需要区分的词汇结构集中到单个标记类型中。例如，如果我们的应用程序将整数和浮点数视为相同，则将它们集中到一起作为标记类型<code class="cf keyword">NUMBER</code>。将单独的标记类型发送给解析器是没有意义的。
  </p>
</li><li>
<p>
  Lump together into a single token type those lexical structures that the parser does
  not need to distinguish. For example, if our application treats integer and
  floating-point numbers the same, then lump them together as token type <code class="cf keyword">NUMBER</code>.
  There’s no point in sending separate token types to the parser.
  </p>
</li>
<li>
<p id="f_0038.html.N12C6E">
  将解析器可以视为单个实体的所有内容集中在一起。例如，如果解析器不关心 XML 标记的内容，则词法分析器可以将尖括号内的所有内容集中到名为 的单个标记类型中<code class="cf keyword">TAG</code>。
  </p>
</li><li>
<p>
  Lump together anything that the parser can treat as a single entity. For example, if
  the parser doesn’t care about the contents of an XML tag, the lexer can lump
  everything between angle brackets into a single token type called <code class="cf keyword">TAG</code>.
  </p>
</li>
<li>
<p id="f_0038.html.N12C75">
   另一方面，如果解析器需要拆分一大段文本进行处理，词法分析器应该将各个组成部分作为标记传递给解析器。例如，如果解析器需要处理 IP 地址的元素，词法分析器应该发送 IP 组成部分（整数和句点）的单独标记。
  </p>
</li><li>
<p>
   On the other hand, if the parser needs to pull apart a lump of text to process it,
   the lexer should pass the individual components as tokens to the parser. For example, if the parser needs to process the elements of an IP address, the lexer should send individual tokens for the IP components (integers and periods).
  </p>
</li>
</ul>
<p id="f_0038.html.N12C78">
当我们说解析器不需要区分某些词汇结构或不关心结构内部的内容时，我们实际上是说我们的应用程序不关心。我们的应用程序对这些词汇结构执行相同的操作或翻译。
</p><p>
When we say that the parser doesn’t need to distinguish between certain lexical structures or doesn’t care about what’s inside a structure, we really mean that our application doesn’t care. Our application performs the same action or translation on those lexical structures.
</p>
<p id="f_0038.html.N12C7B">
要了解预期应用程序如何影响我们在词法分析器和解析器中匹配的内容，想象一下处理来自 Web 服务器的日志文件，该日志文件每行只有一条记录。我们将逐渐增加应用程序要求，以查看它如何改变词法分析器和解析器之间的界限。假设每行都有一个请求 IP 地址、HTTP 协议命令和结果代码。以下是示例日志条目：
</p><p>
To see how the intended application affects what we match in the lexer vs. the parser,
imagine processing a log file from a web server that has one record per line. We’ll
gradually increase the application requirements to see how it shifts the boundary between
the lexer and the parser. Let’s assume each row has a requesting IP address, HTTP protocol
command, and result code. Here’s a sample log entry:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​192.168.209.85 "GET /download/foo.html HTTP/1.0" 200​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0038.html.N12C8A">
我们的大脑会自然地挑选出各种词汇元素，但如果我们只想计算文件中有多少行，我们可以忽略换行符序列以外的所有内容。
</p><p>
Our brain naturally picks out the various lexical elements, but if all we want to do is
count how many lines there are in the file, we can ignore everything but the sequence of
newline characters.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file  : NL+ ;              <em class="comment">// parser rule matching newline (NL) sequence</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STUFF : ~<em class="string">'\n'</em>+ -&gt; skip ;   <em class="comment">// match and discard anything but a '\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NL    : <em class="string">'\n'</em> ;             <em class="comment">// return NL to parser or other invoking code</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0038.html.N12CAB">
词法分析器不需要识别太多结构，解析器会匹配换行符序列。（<code class="cf ic">~x</code>运算符匹配除 之外的任何内容<code class="cf ic">x</code>。）
</p><p>
The lexer doesn’t have to recognize much in the way of structure, and the parser matches a
sequence of newline tokens. (The <code class="cf ic">~x</code> operator matches anything but <code class="cf ic">x</code>.)
</p>
<p id="f_0038.html.N12CB4">
接下来，假设我们需要从日志文件中收集 IP 地址列表。这意味着我们需要一条规则来识别 IP 地址的词汇结构，并且我们还可以为其他记录元素提供词法分析器规则。
</p><p>
Next, let’s say that we need to collect a list of IP addresses from the log file. This
means we need a rule to recognize the lexical structure of an IP address, and we might as well provide lexer rules for the other record elements.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​IP    : INT <em class="string">'.'</em> INT <em class="string">'.'</em> INT <em class="string">'.'</em> INT ; <em class="comment">// 192.168.209.85</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT   : [0-9]+ ;        <em class="comment">// match IP octet or HTTP result code</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING: <em class="string">'"'</em> .*? <em class="string">'"'</em> ;   <em class="comment">// matches the HTTP protocol command</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NL    : <em class="string">'\n'</em> ;          <em class="comment">// match log file record terminator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS    : <em class="string">' '</em> -&gt; skip ;   <em class="comment">// ignore spaces</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0038.html.N12CEE">
有了完整的标记集，我们就可以制定与日志文件中的记录匹配的解析器规则。
</p><p>
With a complete set of tokens, we can make parser rules that match the records in a
log file.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file  : row+ ;              <em class="comment">// parser rule matching rows of log file</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row   : IP STRING INT NL ;  <em class="comment">// match log file record</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0038.html.N12D04">
稍微提高一下我们的处理需求，假设我们需要将文本 IP 地址转换为 32 位数字。借助方便的库函数（例如）<code class="cf ic">split(’.’)</code>，我们可以将 IP 地址作为字符串传递给解析器并在那里进行处理。但是，最好让词法分析器匹配 IP 地址词法结构并将组件作为标记传递给解析器。
</p><p>
Stepping up our processing needs a little bit, let’s say we need to convert the text IP
addresses to 32-bit numbers. With convenient library functions like <code class="cf ic">split(’.’)</code>,
we could pass IP addresses as strings to the parser and process them there. But, it’s
better to have the lexer match the IP address lexical structure and pass the components
to the parser as tokens.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file  : row+ ;                <em class="comment">// parser rule matching rows of log file</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row   : ip STRING INT NL ;    <em class="comment">// match log file record</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ip    : INT <em class="string">'.'</em> INT <em class="string">'.'</em> INT <em class="string">'.'</em> INT ; <em class="comment">// match IPs in parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT   : [0-9]+ ;        <em class="comment">// match IP octet or HTTP result code</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING: <em class="string">'"'</em> .*? <em class="string">'"'</em> ;   <em class="comment">// matches the HTTP protocol command</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NL    : <em class="string">'\n'</em> ;          <em class="comment">// match log file record terminator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS    : <em class="string">' '</em> -&gt; skip ;   <em class="comment">// ignore spaces</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0038.html.N12D4D">
将词法分析器规则转换<code class="cf keyword">IP</code>为解析器规则<code class="cf keyword">ip</code>表明我们可以多么轻松地移动分界线。（将四个<code class="cf keyword">INT</code>
标记转换为 32 位数字需要在语法中嵌入一些应用程序代码，我们尚未深入研究这些代码，因此我们将不讨论它们。）
</p><p>
Switching lexer rule <code class="cf keyword">IP</code> to parser rule <code class="cf keyword">ip</code> shows
how easily we can shift the dividing line. (Converting the four <code class="cf keyword">INT</code>
tokens to a 32-bit number would require some application code embedded in the grammar, which we haven’t looked at yet in depth, so we’ll leave them out.)
</p>
<p id="f_0038.html.N12D59">
如果需求要求处理 HTTP 协议命令字符串的内容，我们将遵循类似的思维过程。如果我们的应用程序不需要检查字符串的各个部分，那么词法分析器可以将整个字符串作为单个标记传递给解析器。但是，如果我们需要提取各个部分，最好让词法分析器识别这些部分并将组件传递给解析器。
</p><p>
If the requirements call for processing the contents of the HTTP protocol command string, we
would follow a similar thought process. If our application doesn’t need to examine the parts
of the string, then the lexer can pass the whole string to the parser as a single token.
But, if we need to pull out the various pieces, it’s better to have the lexer recognize
those pieces and pass the components to the parser.
</p>
<p id="f_0038.html.N12D5D">
很快就能学会根据语言的符号和应用程序的需求来划清界限。下一章中的示例将帮助您内化本节中的经验法则。然后，凭借这一坚实的基础，我们将在第 12 章“运用<a href="#f_0071.html.chp.lexmagic">词汇<em>黑魔法”</em>中研究一些棘手的词汇问题。</a>例如，Java 编译器需要忽略和处理 Javadoc 注释，并且 XML 文件在标记内部和外部具有不同的词汇结构。
</p><p>
It doesn’t take long to get a good feel for drawing the line according to a
language’s symbols and the needs of an application. The examples in the next chapter
will help you internalize the rules of thumb from this section. Then, with that
solid foundation, we’ll examine a few nasty lexical problems in Chapter 12, <a href="#f_0071.html.chp.lexmagic">​<em>Wielding Lexical Black Magic</em>​</a>. For example, Java compilers need to both ignore and process
Javadoc comments, and XML files have different lexical structures inside and outside
of tags.
</p>
<p id="f_0038.html.N12D66">
在本章中，我们学习了如何根据语言的代表性样本或语言文档来创建语法伪代码，然后创建 ANTLR 符号的正式语法。我们还研究了常见的语言模式：序列、选择、标记依赖性和嵌套短语。在词汇领域，我们研究了最常见标记的实现：标识符、数字、字符串、注释和空格。现在是时候将这些知识用于为一些现实世界的语言构建语法了。
</p><p>
In this chapter, we learned how to work from a representative sample of the language, or
language documentation, to create grammar pseudocode and then a formal grammar in ANTLR
notation. We also studied the common language patterns: sequence, choice, token dependency,
and nested phrase. In the lexical realm, we looked at implementations for the most common
tokens: identifiers, numbers, strings, comments, and whitespace. Now it’s time to put this
knowledge to work building grammars for some real-world languages.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-22" href="#f_0036.html.FNPTR-22">[22]</a>
</td>
<td>
<p id="f_0038.html.N12615">
<a href="http://dinosaur.compilertools.net/bison/bison_8.html#SEC71">http://dinosaur.compilertools.net/bison/bison_8.html#SEC71</a>
</p><p>
<a href="http://dinosaur.compilertools.net/bison/bison_8.html#SEC71">http://dinosaur.compilertools.net/bison/bison_8.html#SEC71</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-23" href="#f_0036.html.FNPTR-23">[23]</a>
</td>
<td>
<p id="f_0038.html.N126F6">
<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-24" href="#f_0036.html.FNPTR-24">[24]</a>
</td>
<td>
<p id="f_0038.html.N126FE">
<a href="http://antlr.org/papers/Clarke-expr-parsing-1986.pdf">http://antlr.org/papers/Clarke-expr-parsing-1986.pdf</a>
</p><p>
<a href="http://antlr.org/papers/Clarke-expr-parsing-1986.pdf">http://antlr.org/papers/Clarke-expr-parsing-1986.pdf</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-25" href="#f_0036.html.FNPTR-25">[25]</a>
</td>
<td>
<p id="f_0038.html.N12707">
<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>
</p><p>
<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-26" href="#f_0037.html.FNPTR-26">[26]</a>
</td>
<td>
<p id="f_0038.html.N12797">
<a href="http://golang.org/">http://golang.org/</a>
</p><p>
<a href="http://golang.org/">http://golang.org/</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0038.html.FOOTNOTE-27" href="#f_0037.html.FNPTR-27">[27]</a>
</td>
<td>
<p id="f_0038.html.N127AC">
<a href="http://www.antlr.org/grammar/java">http://www.antlr.org/grammar/java</a>
</p><p>
<a href="http://www.antlr.org/grammar/java">http://www.antlr.org/grammar/java</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0039.html"><div>

<h1 class="chapter-title" id="f_0039.html.chp.examples">
<span class="chapter-number">
	      第六章</span>
<br><br>
<span class="chapter-name">探索一些真正的语法</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      6</span>
<br><br>
<span class="chapter-name">Exploring Some Real Grammars</span>
</h1>

<p id="f_0039.html.N12D7E">
在上一章中，我们学习了常见的词汇和语法结构，并学习了如何将它们表达为 ANTLR 语法的片段。现在是时候将这些知识用于构建一些现实世界的语法了。我们的主要目标是学习如何通过筛选参考手册、示例输入文件和现有的非 ANTLR 语法来汇编完整的语法。我们将解决五种语言，复杂性逐渐增加。您不必现在就构建所有这些语言。只需完成您熟悉的那些，然后在实践中遇到更复杂的问题时再回来。也可以随时返回查看上一章中的模式和 ANTLR 片段。
</p><p>
In the previous chapter, we studied common lexical and grammatical structures and learned how to
express them as snippets of ANTLR grammars. Now it’s time to put that knowledge to use
building some real-world grammars. Our primary goal is to learn how to assemble full
grammars by sifting through reference manuals, sample input files, and existing non-ANTLR
grammars. We’ll tackle five languages, ramping up gradually in complexity. You don’t have to
build all of them now. Just work through the ones you’re comfortable with and come back as
you encounter more complicated problems in practice. Also feel free to pop back to look at
the patterns and ANTLR snippets in the previous chapter.
</p>
<p id="f_0039.html.N12D85">
我们将要研究的第一种语言是电子表格和数据库使用的逗号分隔值 (CSV) 格式。CSV 是一个很好的起点，因为它简单且适用范围广。第二种语言也是一种数据格式，称为 JSON，<a id="f_0039.html.FNPTR-28" href="#f_0044.html.FOOTNOTE-28">[28]</a>它具有嵌套数据元素，这让我们可以探索规则递归在真实语言中的使用。
</p><p>
The first language we’ll look at is the comma-separated-value (CSV) format used by
spreadsheets and databases. CSV is a great place to start because it’s simple and yet
widely applicable. The second language is also a data format, called
JSON,<a href="#f_0044.html.FOOTNOTE-28">[28]</a> that has nested data
elements, which lets us explore the use of rule recursion in a real language.
</p>
<p id="f_0039.html.N12D8E">
接下来，我们将介绍一种用于描述图（网络）的声明性语言 DOT <a id="f_0039.html.FNPTR-29" href="#f_0044.html.FOOTNOTE-29">[29]</a>。在声明性语言中，我们表达逻辑结构而不指定控制流。DOT 让我们探索更复杂的词汇结构，例如不区分大小写的关键字。
</p><p>
Next, we’ll look at a declarative language called
DOT<a href="#f_0044.html.FOOTNOTE-29">[29]</a> for describing graphs
(networks). In a declarative language, we express logical constructions without specifying
control flow. DOT lets us explore more complicated lexical structures, such as case-insensitive keywords.
</p>
<p id="f_0039.html.N12D97">
我们的第四种语言是一种简单的非面向对象编程语言，称为 Cymbol（也在<em>语言实现模式</em>&nbsp;[Par09] 的第 6 章中讨论过）。它是一种原型语法，我们可以将其用作其他命令式编程语言（由函数、变量、语句和表达式组成的语言）的参考或起点。
</p><p>
Our fourth language is a simple non-object-oriented programming language called Cymbol (also
discussed in Chapter 6 of <em>Language Implementation Patterns</em>&nbsp;[Par09]). It’s a prototypical grammar we can
use as a reference or starting point for other imperative programming languages (those
composed of functions, variables, statements, and expressions).
</p>
<p id="f_0039.html.N12D9D">
最后，我们将为 R 函数式编程语言构建语法。<a id="f_0039.html.FNPTR-30" href="#f_0044.html.FOOTNOTE-30">[30]</a>（函数式语言通过评估表达式进行计算。）R 是一种统计编程语言，越来越多地用于数据分析。我之所以选择 R，是因为它的语法主要由一个庞大的表达式规则组成。这是一个很好的机会来加强我们对真实语言的运算符优先级和结合性的理解。
</p><p>
Finally, we’ll build a grammar for the R functional programming
language.<a href="#f_0044.html.FOOTNOTE-30">[30]</a> (Functional
languages compute by evaluating expressions.) R is a statistical programming language
increasingly used for data analysis. I chose R because its grammar consists primarily of a
jumbo expression rule. It’s a great opportunity to reinforce our understanding of operator
precedence and associativity for a real language.
</p>
<p id="f_0039.html.N12DA6">
一旦我们牢牢掌握了语法构建，我们就可以超越认知，开始在应用程序看到感兴趣的输入短语时触发操作。在下一章中，我们将创建解析器侦听器来构建数据结构、管理跟踪变量和函数定义的符号表以及执行语言翻译。
</p><p>
Once we have a firm grip on building grammars, we can move beyond recognition and get down
to the business of triggering actions when the application sees input phrases of interest.
In the next chapter, we’ll create parser listeners that build data structures, manage symbol
tables that track variable and function definitions, and perform language translations.
</p>
<p id="f_0039.html.N12DA9">
我们从 CSV 文件的语法开始。
</p><p>
We begin with a grammar for CSV files.
</p>

</div></div>
<div id="f_0040.html"><div>

<h2 id="f_0040.html.sec.CSV">6.1 解析逗号分隔的值</h2><h2>6.1 Parsing Comma-Separated Values</h2>
<p id="f_0040.html.N12DB1">
虽然我们已经在<a href="#f_0035.html.sec.sequences">“模式<em>：序列”</em>中看到了基本的 CSV 语法，</a>但让我们用标题行的概念来增强它并允许空列。这是一个代表性的输入文件：
</p><p>
While we have already seen a basic CSV grammar in <a href="#f_0035.html.sec.sequences">​<em>Pattern: Sequence</em>​</a>, let’s
beef it up with the notion of a header row and allow empty columns. Here’s a
representative input file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/data.csv">示例/数据.csv</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Details,Month,Amount​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Mid Bonus,June,"$2,000"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​,January,"""zippo"""​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Total Bonuses,"","$5,000"​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12DD2">
标题行与常规行没有区别；我们只是将列值解释为列标题名称。我们不是使用<code class="cf ic">row+</code>ANTLR 片段来匹配行和标题行，而是分别匹配。当基于此语法构建实际应用程序时，我们可能希望以不同的方式处理标题。这样，我们就可以处理第一个特殊行。以下是语法的第一部分：
</p><p>
Header rows are no different from regular rows; we simply interpret the column value as the
column header name. Rather than using a <code class="cf ic">row+</code> ANTLR fragment to match rows as well
as the header row, we match it separately. When building a real application based upon this
grammar, we’d probably want to treat the header differently. This way, we can get a handle on
the first special row. Here’s the first part of the grammar:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/CSV.g4">例子/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> CSV;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : hdr row+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​hdr : row ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12DEF">
请注意，我们引入了一条额外的规则，称为“<code class="cf keyword">hdr</code>清晰度”。从语法上讲，它只是一个<code class="cf keyword">row</code>，但我们通过将其分离出来，使其作用更加清晰。将其与在右侧使用“仅<code class="cf ic">row+</code>或”规则进行比较。
<code class="cf ic">row row*</code><code class="cf keyword">file</code></p><p>
Note that we’ve introduced an extra rule called <code class="cf keyword">hdr</code> for clarity.
Grammatically it’s just a <code class="cf keyword">row</code>, but we’ve made its role clearer by
separating it out. Compare this to using just <code class="cf ic">row+</code> or <code class="cf ic">row row*</code> on the
right-side rule <code class="cf keyword">file</code>.
</p>
<p id="f_0040.html.N12E01">
规则<code class="cf keyword">row</code>与之前相同：字段列表以逗号分隔并以换行符终止。
</p><p>
Rule <code class="cf keyword">row</code> is the same as before: a list of fields separated by commas and terminated by a newline.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/CSV.g4">例子/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row : field (<em class="string">','</em> field)* <em class="string">'\r'</em>? <em class="string">'\n'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12E1D">
为了使我们的字段比上一章更加灵活，我们允许在逗号之间使用任意文本、字符串甚至空字段。
</p><p>
To make our fields more flexible than they were in the previous chapter, let’s allow
arbitrary text, strings, and even empty fields in between commas.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/CSV.g4">例子/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   TEXT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   STRING​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12E39">
标记定义还不错。<code class="cf keyword">TEXT</code>标记是字符序列，直到我们遇到下一个逗号字段分隔符或行尾。字符串是双引号之间的任何字符。以下是我们迄今为止使用的两个标记定义：
</p><p>
The token definitions aren’t too bad. <code class="cf keyword">TEXT</code> tokens are a sequence of
characters until we hit the next comma field separator or the end of the line. Strings are
any characters in between double quotes. Here are the two token definitions we’ve used so
far:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/CSV.g4">例子/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT : ~[,\n\r<em class="string">"]+ ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="string">STRING : '"' ('""'|~'"')* '"' ; // quote-quote is an escaped quote</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12E52">
为了在双引号字符串内获得双引号，CSV 格式通常使用连续两个双引号。这就是<code class="cf ic">(’""’|~’"’)*</code>规则中的子规则所做的事情<code class="cf keyword">STRING</code>。我们不能使用带有通配符的非贪婪循环，因为它会在字符串开头后看到的<code class="cf ic">(’""’|.)*?</code>第一个字符处停止。输入 like将匹配两个字符串，而不是一个字符串。请记住，非贪婪子规则匹配尽可能少的字符，但仍然会导致与周围规则匹配。
<code class="cf ic">"</code><code class="cf ic">"x""y"</code><code class="cf ic">""</code></p><p>
To get a double quote inside a double-quoted string, the CSV format generally uses two double quotes in a row. That’s what the <code class="cf ic">(’""’|~’"’)*</code> subrule does in rule <code class="cf keyword">STRING</code>.  We can’t use a nongreedy loop with the wildcard, <code class="cf ic">(’""’|.)*?</code>, because it would stop at the first <code class="cf ic">"</code> it saw after the start of the string. Input like <code class="cf ic">"x""y"</code> would match two strings, not one string with <code class="cf ic">""</code> inside it. Remember that nongreedy subrules match the fewest characters possible that still results in a match for the surrounding rule.
</p>
<p id="f_0040.html.N12E77">
在测试我们的解析器规则之前，让我们看一下标记流，以确保我们的词法分析器正确地分解字符流。使用带有选项的<code class="cf class">TestRig</code>via alias ，我们得到以下内容：
<code class="cf commandname">grun</code><code class="cf commandoption">-tokens</code></p><p>
Before testing our parser rules, let’s take a look at the token stream just to make sure that our lexer breaks up the character stream properly. Using <code class="cf class">TestRig</code> via alias <code class="cf commandname">grun</code> with option <code class="cf commandoption">-tokens</code>, we get the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 CSV.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac CSV*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun CSV file -tokens data.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:6='Details',&lt;4&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,7:7=',',&lt;1&gt;,1:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,8:12='Month',&lt;4&gt;,1:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,13:13=',',&lt;1&gt;,1:13]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,14:19='Amount',&lt;4&gt;,1:14]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,20:20='\n',&lt;2&gt;,1:20]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,21:29='Mid Bonus',&lt;4&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,30:30=',',&lt;1&gt;,2:9]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,31:34='June',&lt;4&gt;,2:10]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,35:35=',',&lt;1&gt;,2:14]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,36:43='"$2,000"',&lt;5&gt;,2:15]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,44:44='\n',&lt;2&gt;,2:23]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@12,45:45=',',&lt;1&gt;,3:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@13,46:52='January',&lt;4&gt;,3:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12EC8">
这些标记看起来不错。标点符号、文本和字符串均按预期显示。 
</p><p>
Those tokens look fine. The punctuation, text, and strings all come through as expected. 
</p>
<p id="f_0040.html.N12ECB">
现在，让我们看看我们的语法如何识别输入流中的语法结构。使用选项<code class="cf commandoption">-tree</code>，测试装置打印出解析树的文本形式（已为本书清理过）。
</p><p>
Now, let’s see how our grammar recognizes grammatical structure in the input stream. Using option <code class="cf commandoption">-tree</code>, the test rig prints out a text form of the parse tree (cleaned up for the book).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun CSV file -tree data.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(file​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ (hdr (row (field Details) , (field Month) , (field Amount) \n))​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ (row (field Mid Bonus) , (field June) , (field "$2,000") \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ (row field , (field January) , (field """zippo""") \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ (row (field Total Bonuses) , (field "") , (field "$5,000") \n)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0040.html.N12EF1">
根节点表示起始规则<code class="cf keyword">file</code>匹配的所有内容。它有许多行作为子节点，从标题行开始。以下是解析树的视觉效果（使用选项获得<code class="cf commandoption">-ps file.ps</code>）：
</p><p>
The root node represents everything that start rule <code class="cf keyword">file</code> matched. It has
a number of rows as children, starting with the header row. Here’s what the parse tree looks
like visually (obtained with the <code class="cf commandoption">-ps file.ps</code> option):
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/CSV-parse-tree.png">
</div>
<p id="f_0040.html.N12EFE">
CSV 的优点在于其简单性，但是当我们需要一个字段来保存多个值时，它就不行了。为此，我们需要一种允许嵌套元素的数据格式。
</p><p>
CSV is nice because of its simplicity, but it breaks down when we need a single field to hold multiple values. For that, we need a data format that allows nested elements.
</p>

</div></div>
<div id="f_0041.html"><div>

<h2 id="f_0041.html.sec.JSON">6.2 解析 JSON</h2><h2>6.2 Parsing JSON</h2>
<p id="f_0041.html.N12F0A">
JSON 是一种文本数据格式，用于捕获名称-值对的集合，由于值本身可以是集合，因此 JSON 可以包含嵌套结构。设计 JSON 解析器使我们有机会从语言参考手册<a id="f_0041.html.FNPTR-31" href="#f_0044.html.FOOTNOTE-31">[31]</a>中推导出语法，并使用一些更复杂的词汇规则。为了更具体，下面是一个简单的 JSON 数据文件：
</p><p>
JSON is a text data format that captures a collection of name-value pairs, and since values
can themselves be collections, JSON can include nested structures. Designing a parser for
JSON gives us an opportunity to derive a grammar from a language reference
manual<a href="#f_0044.html.FOOTNOTE-31">[31]</a> and to work with some more
complicated lexical rules. To make things more concrete, here’s a simple JSON data file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/t.json">例子/t.json</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        "antlr.org": {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                "owners" : [],​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                "live" : true,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                "speed" : 1e100,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                "menus" : [<em class="string">"File"</em>, <em class="string">"Help\nMenu"</em>]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N12F42">
我们的目标是通过阅读 JSON 参考手册并查看其语法图和现有语法来构建 ANTLR 语法。我们将从手册中提取关键短语，并找出如何将它们编码为 ANTLR 规则，从语法结构开始。
</p><p>
Our goal is to build an ANTLR grammar by reading the JSON reference manual and looking
at its syntax diagram and existing grammar. We’ll pull out key phrases from the manual
and figure out how to encode them as ANTLR rules, starting with the grammatical structures.
</p>
<h3>JSON 语法规则</h3><h3>JSON Grammatical Rules</h3>
<p id="f_0041.html.N12F49">
语言参考指出 JSON 文件可以是对象（如前所述），也可以是值数组。从语法上讲，这只是一种选择模式，我们可以用以下规则正式指定它：
</p><p>
The language reference says that a JSON file can be either an object, as shown earlier, or an
array of values. Grammatically, that’s just a choice pattern, which we can specify formally
with this rule:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​json:   object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   array​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N12F5F">
下一步是深入研究 中的规则引用<code class="cf keyword">json</code>。对于对象，引用内容如下：
</p><p>
The next step is to drill down into the rule references in <code class="cf keyword">json</code>. For
objects, the reference says the following:
</p>
<blockquote>
<p id="f_0041.html.N12F66">
对象是一组无序的名称-值对。对象以左括号 ({) 开头<span class="emph">，</span>以右括号 (}) 结尾。每个名称后跟一个冒号 (:)，名称-值对之间用逗号 (,) 分隔。
</p>
</blockquote><blockquote>
<p>
An <span class="emph">object</span> is an unordered set of name-value pairs. An object begins with a left brace ({) and ends with a right brace (}). Each name is followed by a colon (:), and the name-value pairs are separated by a comma (,).
</p>
</blockquote>
<p id="f_0041.html.N12F6C">
JSON 网站上的语法图也表明名称必须是字符串。
</p><p>
The syntax diagram at the JSON website also indicates that names have to be strings.
</p>
<p id="f_0041.html.N12F6F">
为了将此英语描述转换为语法结构，我们将其分解以寻找代表我们的模式之一的关键短语：序列、选择、标记依赖性和嵌套短语。句子的开头“一个<span class="emph">对象</span>是”清楚地表明我们应该创建一个名为的规则<code class="cf keyword">object</code>。接下来，“无序的名称-值对集”实际上只是一个对的序列。“无序集”指的是名称的语义或含义；具体来说，名称的顺序没有意义。这意味着我们可以匹配任何旧的对列表，因为我们只是在解析。
</p><p>
To convert this English description into grammar constructs, we break it apart looking for key phrases that represent one of our patterns: sequence, choice, token dependency, and nested phrase. The start of the sentence “An <span class="emph">object</span> is” clearly  indicates we should create a rule called <code class="cf keyword">object</code>. Next, an “unordered set of name-value pairs” is really just a sequence of pairs. The “unordered set” is referring to the semantics, or meaning, of the names; specifically, the order of the names has no meaning. That means we can just match any old list of pairs since we are just parsing.
</p>
<p id="f_0041.html.N12F78">
第二句引入了标记依赖关系，因为对象以花括号开头和结尾。最后一句将我们的对序列细化为带有逗号分隔符的序列。总之，我们在 ANTLR 符号中得到如下内容：
</p><p>
The second sentence introduces a token dependency because an object starts and ends with curly braces.  The final sentence refines our sequence of pairs to be a sequence with a comma separator. Altogether, we get something like this in ANTLR notation:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'{'</em> pair (<em class="string">','</em> pair)* <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'{'</em> <em class="string">'}'</em> <em class="comment">// empty object</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​pair:   STRING <em class="string">':'</em> value ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N12FA7">
为了清晰起见并减少代码重复，最好将名称-值对分解为自己的规则。否则，第一个替代方案<code class="cf keyword">object</code>
将如下所示：
</p><p>
For clarity and to reduce code duplication, it’s a good idea to break out the name-value
pairs into their own rule. Otherwise, the first alternative of <code class="cf keyword">object</code>
would look like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​object : <em class="string">'{'</em> STRING <em class="string">':'</em> value (<em class="string">','</em> STRING <em class="string">':'</em> value)* <em class="string">'}'</em> | ... ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N12FC8">
请注意，我们有<code class="cf keyword">STRING</code>一个标记，而不是语法规则。读取 JSON 文件的应用程序几乎肯定会将字符串视为完整实体，而不是字符序列。根据第 5.6 节“在<a href="#f_0038.html.sec.lexer_parser_line"><em>词法分析器和解析器之间</em></a><a href="#f_0038.html.sec.lexer_parser_line">划清经验法则，<em></em></a>字符串应该是标记。
</p><p>
Notice that we have <code class="cf keyword">STRING</code> as a token and not a grammatical rule.
It’s almost certainly the case that an application reading JSON files would want to
treat strings as complete entities, rather than character sequences. Per our rules of
thumb from Section 5.6, <a href="#f_0038.html.sec.lexer_parser_line">​<em>Drawing the Line Between Lexer and Parser</em>​</a>, strings should be tokens.
</p>
<p id="f_0041.html.N12FD1">
JSON 参考也有一些非正式的语法规则，所以让我们看看我们的 ANTLR 规则如何比较。以下是参考中的语法逐字逐句：</p><p>
The JSON reference also has some informal grammatical rules, so let’s see how our ANTLR
rules compare. Here’s the grammar verbatim from the reference:</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    { members }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    pair​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    pair , members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​pair​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    string : value​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N12FFB">
参考文献也分解了<code class="cf keyword">pair</code>规则，但有一个
<code class="cf keyword">members</code>规则我们没有。如侧栏 
<a href="#f_0041.html.sb.tail_recursion">​循环<em>与尾递归</em>​中所述，</a>它是语法如何表达没有
<code class="cf ic">(...)*</code>循环的序列。
</p><p>
The reference has also broken out the <code class="cf keyword">pair</code> rule, but there’s a
<code class="cf keyword">members</code> rule that we don’t have. As described in the sidebar 
<a href="#f_0041.html.sb.tail_recursion">​<em>Loops vs. Tail Recursion</em>​</a>, it’s how a grammar expresses sequences without
<code class="cf ic">(...)*</code> loops.
</p>
<div class="sidebar" id="f_0041.html.sb.tail_recursion">
<div class="sidebar-title">循环与尾递归</div>
<div class="sidebar-content">
<p id="f_0041.html.N1300F">
JSON 参考手册中的规则<code class="cf keyword">members</code>看起来很奇怪，因为英文描述中没有任何内容似乎适合选择<code class="cf keyword">pair</code>
或<code class="cf keyword">pair</code>后跟逗号并引用自身。
</p><p>
Rule <code class="cf keyword">members</code> from the JSON reference manual looks strange because there
is nothing in the English description that seems to fit a choice of <code class="cf keyword">pair</code>
or <code class="cf keyword">pair</code> followed by a comma and reference to itself.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    pair​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    pair , members​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N1302C">
不同之处在于 ANTLR 支持扩展 BNF (EBNF) 语法，而 JSON 参考手册中的非正式规则使用直接 BNF。BNF 不支持像我们的<code class="cf ic">(...)*</code>循环这样的子规则，因此它们使用尾部递归（规则调用自身作为替代方案中的最后一个元素）模拟循环。
</p><p>
The difference lies in that ANTLR supports Extended BNF (EBNF) grammars and the informal
rules from the JSON reference manual use straight BNF. BNF does not support subrules like
our <code class="cf ic">(...)*</code> loop so they simulate looping with tail recursion (a rule invocation
to itself as the last element in an alternative).
</p>
<p id="f_0041.html.N13046">
为了了解英语序列描述和此尾部递归规则之间的关系，下面是如何<code class="cf keyword">members</code>  推导出一对、两对和三对：
</p><p>
To see the relationship between the English sequence description and this tail
recursive rule, here’s how <code class="cf keyword">members</code>  derives one, two, and three
pairs:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​members =&gt; pair​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​members =&gt; pair , members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        =&gt; pair , pair​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​members =&gt; pair , members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        =&gt; pair , pair , members​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        =&gt; pair , pair , pair​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N1306B"><a href="#f_0034.html.sec.existing-grammars">这强化了第 5.2 节“使用<em>现有语法作为指南”</em></a>
中的警告，<a href="#f_0034.html.sec.existing-grammars">即</a>现有语法应该作为指南，而不是福音真理。
</p><p>
This reinforces the warning in Section 5.2, <a href="#f_0034.html.sec.existing-grammars">​<em>Using Existing Grammars as a Guide</em>​</a> that existing grammars should be used as a guide, not the gospel truth.
</p>
</div>
</div>
<p id="f_0041.html.N13071">
谈到另一个高级构造数组，参考手册这样说：
</p><p>
Turning to arrays, the other high-level construct, the reference manual says this:
</p>
<blockquote>
<p id="f_0041.html.N13075">
数组是值的有序集合。数组以左括号 ([) 开头，以右括号 (])<span class="emph">结尾</span>。值之间用逗号 (,) 分隔。
</p>
</blockquote><blockquote>
<p>
An <span class="emph">array</span> is an ordered collection of values. An array begins with a left bracket ([) and ends with a right bracket (]). Values are separated by a comma (,).
</p>
</blockquote>
<p id="f_0041.html.N1307B">
与规则类似<code class="cf keyword">object</code>，<code class="cf keyword">array</code>具有逗号分隔的序列和左右方括号之间的标记依赖关系。
</p><p>
Like rule <code class="cf keyword">object</code>, <code class="cf keyword">array</code> has a comma-separated sequence and a token dependency between the left and right square brackets.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​array​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'['</em> value (<em class="string">','</em> value)* <em class="string">']'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'['</em> <em class="string">']'</em> <em class="comment">// empty array</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N130AA">
进一步降低粒度，我们得到<code class="cf keyword">value</code>，这是根据参考的选择模式。
</p><p>
Stepping down a level of granularity, we get to <code class="cf keyword">value</code>, which is a
choice pattern according to the reference.
</p>
<blockquote>
<p id="f_0041.html.N130B1">
值可以是双引号内的<span class="emph">字符串，也可以是</span><span class="emph">数字</span>，也可以是对象，也可以是<span class="emph">数组</span><span class="emph">。</span><span class="emph">这些</span>结构可以嵌套。
<span class="emph"></span><span class="emph"></span><code class="cf keyword">true</code><code class="cf keyword">false</code><code class="cf keyword">null</code><span class="emph"></span><span class="emph"></span></p>
</blockquote><blockquote>
<p>
A <span class="emph">value</span> can be a <span class="emph">string</span> in double quotes or a <span class="emph">number</span> or <code class="cf keyword">true</code> or <code class="cf keyword">false</code> or <code class="cf keyword">null</code> or an <span class="emph">object</span> or an <span class="emph">array</span>. These structures can be nested.
</p>
</blockquote>
<p id="f_0041.html.N130CC">
  术语<span class="emph">“嵌套”</span>自然表示嵌套短语模式，我们应该期望其中有一些递归规则引用。在 ANTLR 符号中，<code class="cf keyword">value</code>如图 4 所示，<a href="#f_0041.html.code.JSON.g4.value"><em>​ANTLR 符号中的</em></a><a href="#f_0041.html.code.JSON.g4.value">值<em></em></a>​。
</p><p>
  The term <span class="emph">nested</span> naturally indicates a nested phrase pattern for which we should expect some recursive rule references. In ANTLR notation, <code class="cf keyword">value</code> looks like Figure 4, <a href="#f_0041.html.code.JSON.g4.value">​<em>value in ANTLR notation</em>​</a>.
</p>
<div class="figure" id="f_0041.html.code.JSON.g4.value">
<div>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​value​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   STRING​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NUMBER​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   object  <em class="comment">// recursion</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   array   <em class="comment">// recursion</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'true'</em>  <em class="comment">// keywords</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'false'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'null'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</div>
<div class="figurecaption">
<hr>图 4. <code class="cf keyword">value</code>ANTLR 符号</div>
</div>
<p id="f_0041.html.N13113">
通过引用<code class="cf keyword">object</code>或<code class="cf keyword">array</code>，规则
<code class="cf keyword">value</code>变成（间接）递归的。通过从 调用 中的任一规则
<code class="cf keyword">value</code>，我们最终会回到规则<code class="cf keyword">value</code>。
</p><p>
By referencing <code class="cf keyword">object</code> or <code class="cf keyword">array</code>, rule
<code class="cf keyword">value</code> becomes (indirectly) recursive. By invoking either rule from
<code class="cf keyword">value</code>, we would eventually get back to rule <code class="cf keyword">value</code>.
</p>
<p id="f_0041.html.N13128">
规则<code class="cf keyword">value</code>直接引用字符串文字来匹配 JSON 关键字。我们还将数字视为标记，原因与字符串相同：应用程序将数字视为完整实体。
</p><p>
Rule <code class="cf keyword">value</code> directly references string literals to match the JSON
keywords. We also treat numbers as tokens for the same reason as strings: applications will
treat numbers as complete entities.
</p>
<p id="f_0041.html.N1312E">
这就是语法规则。我们已经完全指定了 JSON 文件的结构。以下是我们的语法如何解析之前的示例输入：
</p><p>
That’s it for the grammatical rules. We’ve completely specified the structure of a JSON
file. Here’s how our grammar parses the sample input from earlier:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/JSON-parse-tree.png">
</div>
<p id="f_0041.html.N13136">
当然，在完成词法分析器语法之前，我们还不能运行程序来生成该图中的图像。我们需要两个关键标记的规则：<code class="cf keyword">STRING</code>
和<code class="cf keyword">NUMBER</code>。
</p><p>
Of course, we can’t yet run our program to generate the image in that figure until we’ve
completed the lexer grammar. We need rules for the two key tokens: <code class="cf keyword">STRING</code>
and <code class="cf keyword">NUMBER</code>.
</p>
<h3>JSON 词汇规则</h3><h3>JSON Lexical Rules</h3>
<p id="f_0041.html.N13143">
根据 JSON 参考，字符串定义如下：
</p><p>
According to the JSON reference, strings are defined as follows:
</p>
<blockquote>
<p id="f_0041.html.N13147">
字符串是零个或多个 Unicode 字符的序列，用双引号括起来，使用反斜杠转义。字符表示为单个字符串。字符串与 C 或 Java 字符串非常相似
<span class="emph">。</span></p>
</blockquote><blockquote>
<p>
A <span class="emph">string</span> is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A character is represented as a single character string. A string is very much like a C or Java string.
</p>
</blockquote>
<p id="f_0041.html.N1314D">
正如我们在上一章中讨论的那样，大多数语言中的字符串都大同小异。JSON 的字符串与我们在“<a href="#f_0037.html.sec.string_literals">匹配<em>字符串文字”</em>中所做的类似，</a>但添加了 Unicode 转义。查看现有的 JSON 语法，我们可以发现书面描述是不完整的。语法如下：
</p><p>
As we discussed in the previous chapter, strings in most languages are pretty much the
same. JSON’s strings are similar to what we did in <a href="#f_0037.html.sec.string_literals">​<em>Matching String Literals</em>​</a>, with
the addition of Unicode escapes. Looking at the existing JSON grammar, we can tell that
the written description is incomplete. The grammar says this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​char​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    any-Unicode-character-except-"-or-\-or-control-character​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \\​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \/​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \b​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \f​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \n​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \r​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \t​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    \u four-hex-digits​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N1317C">
这指定了所有转义符，并且我们应该匹配除双引号和反斜杠之外的任何 Unicode 字符，我们可以使用<code class="cf ic">~["\\]</code>反转字符集来指定。（运算符<code class="cf ic">~</code>表示“不”。）我们的<code class="cf keyword">STRING</code>定义如下：
</p><p>
This specifies what all of the escapes are and that we should match any Unicode character
except for the double quote and backslash, which we can specify with a <code class="cf ic">~["\\]</code> inverted
character set. (Operator <code class="cf ic">~</code> means “not.”) Our <code class="cf keyword">STRING</code> definition
looks like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING :  <em class="string">'"'</em> (ESC | ~[<em class="string">"\\])* '"' ;</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N131A5">
该<code class="cf keyword">ESC</code>规则与预定义的转义或 Unicode 序列匹配。
</p><p>
The <code class="cf keyword">ESC</code> rule matches either a predefined escape or a Unicode sequence.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> ESC :   <em class="string">'\\'</em> ([<em class="string">"\\/bfnrt] | UNICODE) ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="string">fragment UNICODE : 'u' HEX HEX HEX HEX ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="string">fragment HEX : [0-9a-fA-F] ;</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N131C7"><code class="cf keyword">UNICODE</code>我们使用<code class="cf keyword">HEX</code>片段规则作为简写
，
而不是在 中多次重复十六进制数字的定义。（以 为前缀的规则<code class="cf keyword">fragment</code>只能从其他词法分析器规则中调用；它们本身并不是标记。）
</p><p>
Rather than repeat the definition of a hex digit multiple times in <code class="cf keyword">UNICODE</code>,
we use the <code class="cf keyword">HEX</code> fragment rule as a shorthand. (Rules prefixed with
<code class="cf keyword">fragment</code> can be called only from other lexer rules; they are not tokens
in their own right.)
</p>
<p id="f_0041.html.N131D8">
解析器使用的最后一个标记是<code class="cf keyword">NUMBER</code>。 JSON 参考对它们的定义如下：
</p><p>
The last token used by the parser is <code class="cf keyword">NUMBER</code>. The JSON reference defines
them as follows:
</p>
<blockquote>
<p id="f_0041.html.N131DF">
数字<span class="emph">与</span>C 或 Java 数字非常相似，只是不使用八进制和十六进制格式。
</p>
</blockquote><blockquote>
<p>
A <span class="emph">number</span> is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
</p>
</blockquote>
<p id="f_0041.html.N131E5">
JSON 参考的现有语法对于数字有一些相当复杂的规则，但我们可以将其全部打包成三个主要替代方案。
</p><p>
The JSON reference’s existing grammar has some fairly complicated rules for numbers, but
we can pack it all into three main alternatives.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NUMBER​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'-'</em>? INT <em class="string">'.'</em> INT EXP?   <em class="comment">// 1.35, 1.35E-9, 0.3, -4.5</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'-'</em>? INT EXP            <em class="comment">// 1e10 -3e4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'-'</em>? INT                <em class="comment">// -3, 45</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> INT :   <em class="string">'0'</em> | [1-9] [0-9]* ; <em class="comment">// no leading zeros</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> EXP :   [Ee] [+\-]? INT ; <em class="comment">// \- since - means "range" inside [...]</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N13229">
再次，使用片段规则<code class="cf keyword">INT</code>可以<code class="cf keyword">EXP</code>减少重复并使语法更易于阅读。   
</p><p>
Again, using fragment rules <code class="cf keyword">INT</code> and <code class="cf keyword">EXP</code> reduces duplication and makes the grammar easier to read.   
</p>
<p id="f_0041.html.N13232"><code class="cf keyword">INT</code>从非正式的 JSON 语法中

我们知道不应该匹配以数字 0 开头的整数。</p><p>
We know that <code class="cf keyword">INT</code> should not match integers beginning with digit 0 from the informal JSON grammar.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    digit​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    digit1-9 digits​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    - digit​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    - digit1-9 digits​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N1324F">
我们处理了<code class="cf ic">-</code>中的否定运算符，<code class="cf keyword">NUMBER</code>因此我们可以只关注前两个选项：<code class="cf ic">digit</code>和<code class="cf ic">digit1-9 digits</code>。第一个选项匹配任何一位数字，因此<code class="cf ic">0</code>本身就很酷。第二个选项以 开头<code class="cf ic">digit1-9</code>，即除 0 之外的任何数字。
</p><p>
We deal with the <code class="cf ic">-</code> negation operator in <code class="cf keyword">NUMBER</code> so we can focus
on just the first two choices: <code class="cf ic">digit</code> and <code class="cf ic">digit1-9 digits</code>. The first choice
matches any single digit, so <code class="cf ic">0</code> is cool all by itself. The second choice starts
with <code class="cf ic">digit1-9</code>, which is any digit but 0.
</p>
<p id="f_0041.html.N13264">
与上一节中的 CSV 示例不同，JSON 需要担心空格。
</p><p>
Unlike the CSV example in the previous section, JSON has to worry about whitespace.
</p>
<blockquote>
<p id="f_0041.html.N13268">
任意一对标记之间都可以插入空格。
</p>
</blockquote><blockquote>
<p>
Whitespace can be inserted between any pair of tokens.
</p>
</blockquote>
<p id="f_0041.html.N1326B">
这是空格的典型含义，因此我们可以重用上一章末尾的词法分析器“入门工具包”中的规则。
</p><p>
That is the typical meaning of whitespace, so we can reuse a rule from the lexer “starter kit” found at the end of the previous chapter.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/JSON.g4">示例/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\n\r]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N13280">
现在我们有了一套完整的语法和词汇规则，我们可以尝试一下了。让我们首先打印出示例输入中的标记<code class="cf ic">[1,"\u0049",1.3e9]</code>。
</p><p>
Now that we have a complete set of grammatical and lexical rules, we can try it.
Let’s start by printing out the tokens from sample input <code class="cf ic">[1,"\u0049",1.3e9]</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 JSON.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac JSON*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun JSON json -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">[1,"\u0049",1.3e9]</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:0='[',&lt;5&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,1:1='1',&lt;11&gt;,1:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,2:2=',',&lt;4&gt;,1:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,3:10='"\u0049"',&lt;10&gt;,1:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,11:11=',',&lt;4&gt;,1:11]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,12:16='1.3e9',&lt;11&gt;,1:12]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,17:17=']',&lt;1&gt;,1:17]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,19:18='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N132C0">
我们的词法分析器正确地将输入流分解为标记，因此让我们尝试语法规则。
</p><p>
Our lexer correctly breaks up the input stream into tokens, so let’s try the grammar rules.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun JSON json -tree</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">[1,"\u0049",1.3e9]</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(json (array [ (value 1) , (value "\u0049") , (value 1.3e9) ]))​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0041.html.N132DE">
语法正确地将标记流解释为三个值的数组，因此一切看起来都很好。对于更复杂的语法，我们需要尝试大量其他输入文件来验证正确性。
</p><p>
The grammar properly interprets the token stream as an array of three values, so
everything looks great. For a more complicated grammar, we’d want to try lots of other
input files to verify correctness.
</p>
<p id="f_0041.html.N132E1">
至此，我们已经了解了两种数据语言（CSV 和 JSON）的语法，接下来让我们继续了解一种名为 DOT 的声明性语言，它增加了语法复杂性并向我们介绍了一种新的词汇模式：不区分大小写的关键字。
</p><p>
At this point, we’ve seen grammars for two data languages (CSV and JSON), so let’s move on
to a declarative language called DOT that ratchets up the grammatical complexity and introduces us to a new lexical pattern: case-insensitive keywords.
</p>

</div></div>
<div id="f_0042.html"><div>

<h2 id="f_0042.html.sec.DOT">6.3 解析 DOT</h2><h2>6.3 Parsing DOT</h2>
<p id="f_0042.html.N132ED">
DOT <a id="f_0042.html.FNPTR-32" href="#f_0044.html.FOOTNOTE-32">[32]</a>
是一种用于描述网络图、树或状态机等图形的声明性语言。（DOT 是一种声明性语言，因为我们说的是图形连接是什么，而不是如何构建图形。）它是一种通用的绘图工具，特别是如果你有一个需要生成图像的程序。例如，ANTLR 的
<code class="cf commandoption">-atn</code>选项使用 DOT 来生成状态机可视化。
</p><p>
DOT<a href="#f_0044.html.FOOTNOTE-32">[32]</a>
is a declarative language for describing graphs such as network diagrams, trees, or state
machines. (DOT is a declarative language because we say what the graph connections are, not
how to build the graph.) It’s a generically useful graphing tool, particularly if you have a
program that needs to generate images. For example, ANTLR’s
<code class="cf commandoption">-atn</code> option uses DOT to generate state machine
visualizations.
</p>
<p id="f_0042.html.N13305">
为了了解该语言，假设我们想要可视化一个包含四个函数的程序的调用树图。我们可以手工绘制该图，也可以使用 DOT 指定关系，如下所示（可以手工指定，也可以通过构建一个语言应用程序自动指定，该应用程序从程序源计算关系）：
</p><p>
To get a feel for the language, imagine that we want to visualize a call tree graph for
a program with four functions. We could draw this by hand, or we could specify the
relationships with DOT as follows (either by hand or automatically by building a
language application that computed the relationships from a program source):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/t.dot">例子/t.dot</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​digraph G {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    rankdir=LR;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    main [shape=box];​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    main -&gt; f -&gt; g;         // main calls f which calls g​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    f -&gt; f [style=dotted] ; // f is recursive​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    f -&gt; h;                 // f calls h​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13327">
以下是使用 DOT 可视化工具创建的结果图：
 <code class="cf commandname">graphviz</code>[ <a id="f_0042.html.FNPTR-33" href="#f_0044.html.FOOTNOTE-33">33]</a>
</p><p>
Here’s the resulting diagram created using the DOT visualizer,
<code class="cf commandname">graphviz</code>:<a href="#f_0044.html.FOOTNOTE-33">[33]</a>
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/DOT-sample-diagram.png">
</div>
<p id="f_0042.html.N1333A">
我们很幸运，因为 DOT 参考指南中有语法规则，如果我们将它们转换为 ANTLR 语法，我们几乎可以逐字重复使用。不幸的是，我们只能自己研究词汇规则。我们必须通读文档和一些示例才能找出确切的规则。最简单的方法是从语法规则开始。
</p><p>
We’re in a bit of luck because the DOT reference guide has syntax rules that we can reuse
almost verbatim, if we convert them to ANTLR syntax. Unfortunately, we’re on our own for the
lexical rules. We’ll have to read through the documentation and some examples to figure out
the exact rules. Our easiest path is to start with the grammatical rules.
</p>
<h3>DOT 语法规则</h3><h3>DOT Grammatical Rules</h3>
<p id="f_0042.html.N13341">
以下是从主要语言参考翻译而来的 ANTLR 符号中的核心语法：<a id="f_0042.html.FNPTR-34" href="#f_0044.html.FOOTNOTE-34">[34]</a>
</p><p>
Here’s the core grammar in ANTLR notation translated from the primary language
reference:<a href="#f_0044.html.FOOTNOTE-34">[34]</a>
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​graph       :   STRICT? (GRAPH | DIGRAPH) id? <em class="string">'{'</em> stmt_list <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stmt_list   :   ( stmt <em class="string">';'</em>? )* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stmt        :   node_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   edge_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   attr_stmt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   id <em class="string">'='</em> id​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   subgraph​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​attr_stmt   :   (GRAPH | NODE | EDGE) attr_list ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​attr_list   :   (<em class="string">'['</em> a_list? <em class="string">']'</em>)+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a_list      :   (id (<em class="string">'='</em> id)? <em class="string">','</em>?)+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​edge_stmt   :   (node_id | subgraph) edgeRHS attr_list? ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​edgeRHS     :   ( edgeop (node_id | subgraph) )+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​edgeop      :   <em class="string">'-&gt;'</em> | <em class="string">'--'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​node_stmt   :   node_id attr_list? ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​node_id     :   id port? ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​port        :   <em class="string">':'</em> id (<em class="string">':'</em> id)? ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​subgraph    :   (SUBGRAPH id?)? <em class="string">'{'</em> stmt_list <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​id          :   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   STRING​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   HTML_STRING​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   NUMBER​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N133C2">
我们与参考语法的唯一偏差是规则<code class="cf keyword">port</code>。参考提供了这一点。</p><p>
The only deviation we make from the reference grammar is rule <code class="cf keyword">port</code>. The reference provides this.</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​port:   ':' ID [ ':' compass_pt ]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ':' compass_pt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​compass_pt​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   (n | ne | e | se | s | sw | w | nw)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N133DC">
如果指南针点是关键字，并且不能作为标识符，那么这些规则通常没有问题。但是，参考文献中的文本改变了语法的含义。
</p><p>
These rules would normally be fine if the compass points were keywords and not legal as
identifiers. But, the text in the reference alters the meaning of the grammar.
</p>
<blockquote>
<p id="f_0042.html.N133E0">
还要注意，允许的罗盘点值不是关键字，因此这些字符串可以在其他地方用作普通标识符......
</p>
</blockquote><blockquote>
<p>
Note also that the allowed compass point values are not keywords, so these strings can be used elsewhere as ordinary identifiers....
</p>
</blockquote>
<p id="f_0042.html.N133E3">
这意味着我们必须接受诸如<code class="cf ic">n -&gt; sw;</code>where
<code class="cf ic">n</code>和 之类的边缘语句<code class="cf ic">sw</code>，它们是标识符，而不是罗盘点。参考文献继续说道：“...相反，解析器实际上会接受任何标识符。”这并不完全清楚，但听起来解析器接受任何罗盘点标识符。如果这是真的，我们根本不必担心语法中的罗盘点；我们可以用 替换对规则的<code class="cf keyword">compass_pt</code>引用
<code class="cf keyword">id</code>。
</p><p>
That means we have to accept edge statements such as <code class="cf ic">n -&gt; sw;</code> where
<code class="cf ic">n</code> and <code class="cf ic">sw</code> are identifiers, not compass points. The reference goes on to
say this: “...conversely, the parser will actually accept any identifier.” That’s not
entirely clear, but it sounds like the parser accepts any identifier for a compass
point. If that’s true, we don’t have to worry about compass points at all in the
grammar; we can replace references to rule <code class="cf keyword">compass_pt</code> with
<code class="cf keyword">id</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​port:   <em class="string">':'</em> id (<em class="string">':'</em> id)? ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13407">
为了确保万无一失，使用 DOT 查看器（例如 Graphviz 网站上的查看器）尝试假设绝不会有什么坏处。<a id="f_0042.html.FNPTR-35" href="#f_0044.html.FOOTNOTE-35">[35]</a>事实上，DOT 确实接受以下图形定义，因此我们的<code class="cf keyword">port</code>规则没有问题：
</p><p>
Just to be sure, it never hurts to try suppositions with a DOT viewer like those  found on the Graphviz website.<a href="#f_0044.html.FOOTNOTE-35">[35]</a> DOT does, in fact, accept the following graph definition, so our <code class="cf keyword">port</code> rule is OK:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​digraph G { n -&gt; sw; }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13421">
至此，我们已经有了语法规则。假设我们的标记定义已经完成，让我们查看示例输入的解析树<code class="cf filename">t.dot</code>（使用<code class="cf ic">grun DOT graph -gui t.dot</code>）。
</p><p>
At this point, we have our grammatical rules in place. Pretending that our token
definitions are finished, let’s look at the parse tree for sample input <code class="cf filename">t.dot</code> (using <code class="cf ic">grun DOT graph -gui t.dot</code>).
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/DOT-parse-tree.png">
</div>
<p id="f_0042.html.N1342F">
现在让我们尝试定义这些标记。
</p><p>
Now let’s try to define those tokens.
</p>
<h3>DOT 词汇规则</h3><h3>DOT Lexical Rules</h3>
<p id="f_0042.html.N13436">
由于参考指南没有提供正式的词汇规则，因此我们必须从书面描述中得出它们。关键字是最简单的，所以我们从关键字开始。
</p><p>
Since the reference guide does not provide formal lexical rules, we have to derive them from the written description. The keywords are the simplest, so let’s start with those.
</p>
<p id="f_0042.html.N13439">
参考资料中说“关键字 node、edge、graph、digraph、subgraph 和 strict 不区分大小写”。如果它们不区分大小写，我们可以简单地在语法中使用文字，例如<code class="cf keyword">’node’</code>。为了允许诸如 这样的变体<code class="cf ic">nOdE</code>，我们需要在每个字符位置上布置带有大写和小写变体的词汇规则。
</p><p>
The reference says that “the keywords node, edge, graph, digraph, subgraph, and strict are case-independent.” If they weren’t case insensitive, we could simply use literals in the grammar like <code class="cf keyword">’node’</code>. To allow variations such as <code class="cf ic">nOdE</code>, we  need to lay out lexical rules with uppercase and lowercase variations at each character position.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRICT      :   [Ss][Tt][Rr][Ii][Cc][Tt] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​GRAPH       :   [Gg][Rr][Aa][Pp][Hh] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIGRAPH     :   [Dd][Ii][Gg][Rr][Aa][Pp][Hh] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NODE        :   [Nn][Oo][Dd][Ee] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EDGE        :   [Ee][Dd][Gg][Ee] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SUBGRAPH    :   [Ss][Uu][Bb][Gg][Rr][Aa][Pp][Hh] ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13463">
标识符与大多数编程语言类似。
</p><p>
Identifiers are similar to most programming languages.
</p>
<blockquote>
<p id="f_0042.html.N13467">
任意由字母 ([a-zA-Z\200-\377])、下划线 ('_') 或数字 ([0-9]) 组成的字符串，不以数字开头。
</p>
</blockquote><blockquote>
<p>
Any string of alphabetic ([a-zA-Z\200-\377]) characters, underscores (’_’), or digits ([0-9]), not beginning with a digit.
</p>
</blockquote>
<p id="f_0042.html.N1346A">
八进制的范围<code class="cf ic">\200-\377</code>是 80 到十六进制的 FF，所以我们的<code class="cf keyword">ID</code>规则如下：
</p><p>
The <code class="cf ic">\200-\377</code> octal range is 80 through FF in hex, so our <code class="cf keyword">ID</code> rule looks like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID          :   LETTER (LETTER|DIGIT)*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LETTER      :   [a-zA-Z\u0080-\u00FF_] ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13487">
辅助规则<code class="cf keyword">DIGIT</code>是我们匹配数字所需的词汇规则之一。参考指南说数字遵循以下正则表达式：
</p><p>
Helper rule <code class="cf keyword">DIGIT</code> is one of the lexical rules we need to match numbers.
The reference guide says numbers follow this regular expression:
</p>
<blockquote>
<p id="f_0042.html.N1348E">
[-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )
</p>
</blockquote><blockquote>
<p>
[-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )
</p>
</blockquote>
<p id="f_0042.html.N13491"><code class="cf ic">[0-9]</code>用
替换<code class="cf keyword">DIGIT</code>，ANTLR 符号中的 DOT 数字如下所示：
</p><p>
Replacing <code class="cf ic">[0-9]</code> with <code class="cf keyword">DIGIT</code>, DOT numbers in ANTLR notation look like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NUMBER      :   <em class="string">'-'</em>? (<em class="string">'.'</em> DIGIT+ | DIGIT+ (<em class="string">'.'</em> DIGIT*)? ) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIGIT       :   [0-9] ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N134B7">
点字符串非常基础。
</p><p>
DOT strings are pretty basic.
</p>
<blockquote>
<p id="f_0042.html.N134BB">
任何双引号字符串（“...”）可能包含转义引号（“\”）
</p>
</blockquote><blockquote>
<p>
any double-quoted string ("...") possibly containing escaped quotes (\")
</p>
</blockquote>
<p id="f_0042.html.N134BE">
要匹配字符串中的任何内容，我们使用点通配符运算符来消耗字符，直到看到最后一个双引号。我们还可以匹配转义的双引号作为子规则循环的替代。
</p><p>
To match anything inside the string, we use the dot wildcard operator to consume characters
until it sees the final double quote. We can also match the escaped double quote as an
alternative of the subrule loop.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING      :   <em class="string">'"'</em> (<em class="string">'\\"'</em>|.)*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N134DC">
DOT 还具有所谓的 HTML 字符串，据我所知，它与字符串完全一样，只是使用尖括号而不是双引号。参考资料使用符号 &lt;...&gt; 并继续说明：
</p><p>
DOT also has what it calls an HTML string, which is, as far as I can tell, exactly like a string except it uses angle brackets instead of double quotes. The reference  uses notation &lt;...&gt; and goes on to say this:
</p>
<blockquote>
<p id="f_0042.html.N134E3">
... 在 HTML 字符串中，尖括号必须成对出现，并且允许未转义的换行符。此外，内容必须是合法的 XML，因此可能需要特殊的 XML 转义序列“、&amp;、&lt; 和 &gt;，以便将这些字符嵌入属性值或原始文本中。
</p>
</blockquote><blockquote>
<p>
... in HTML strings, angle brackets must occur in matched pairs, and unescaped newlines are allowed. In addition, the content must be legal XML, so that the special XML escape sequences for ", &amp;, &lt;, and &gt; may be necessary in order to embed these characters in attribute values or raw text.
</p>
</blockquote>
<p id="f_0042.html.N134E6">
该描述告诉了我们大部分所需的内容，但没有回答我们是否可以<code class="cf ic">&gt;</code>在 HTML 注释中包含这些内容。此外，它似乎暗示我们应该将标签序列包装在尖括号中，如下所示：<code class="cf ic">&lt;&lt;i&gt;hi&lt;/i&gt;&gt;</code>。从使用 DOT 查看器进行的实验来看，情况确实如此。只要括号匹配，DOT 似乎可以接受尖括号之间的任何内容。因此，<code class="cf ic">&gt;</code>HTML 注释内部不会像 XML 解析器那样被忽略。HTML 字符串<code class="cf ic">&lt;foo&lt;!--ksjdf &gt; --&gt;&gt;</code>被视为字符串<code class="cf ic">"foo&lt;!--ksjdf &gt; --"</code>。
</p><p>
That description tells us most of what we need but doesn’t answer whether we can have <code class="cf ic">&gt;</code> inside an HTML comment. Also, it seems to imply we should wrap sequences of tags in angle brackets like this: <code class="cf ic">&lt;&lt;i&gt;hi&lt;/i&gt;&gt;</code>. From experimentation with a DOT viewer, that is the case. DOT seems to accept anything between angle brackets as long as the brackets match. So, <code class="cf ic">&gt;</code> inside HTML comments are not ignored like they would be by an XML parser. HTML string <code class="cf ic">&lt;foo&lt;!--ksjdf &gt; --&gt;&gt;</code> gets treated like string <code class="cf ic">"foo&lt;!--ksjdf &gt; --"</code>.
</p>
<p id="f_0042.html.N134F8">
要接受尖括号中的任何内容，我们可以使用 ANTLR 构造<code class="cf ic">’&lt;’ .*? ’&gt;’</code>。但这不允许在里面嵌套尖括号，因为它会将第一个
<code class="cf ic">&gt;</code>与第一个<code class="cf ic">&lt;</code>而不是最近的关联起来<code class="cf ic">&lt;</code>。以下规则可以解决问题：
</p><p>
To accept anything in angle brackets, we can use ANTLR construct <code class="cf ic">’&lt;’ .*? ’&gt;’</code>.
But that doesn’t allow for angle brackets nested inside because it will associate the first
<code class="cf ic">&gt;</code> with the first <code class="cf ic">&lt;</code> rather than the most recent <code class="cf ic">&lt;</code>. The
following rules do the trick:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** "HTML strings, angle brackets must occur in matched pairs, and</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  unescaped newlines are allowed."</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​HTML_STRING :   <em class="string">'&lt;'</em> (TAG|~[&lt;&gt;])* <em class="string">'&gt;'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TAG         :   <em class="string">'&lt;'</em> .*? <em class="string">'&gt;'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13533">
该<code class="cf keyword">HTML_STRING</code>规则允许在一对尖括号内使用<code class="cf keyword">TAG</code>，从而实现单层嵌套。该<code class="cf ic">~[&lt;&gt;]</code>集合负责匹配 XML 字符实体，例如
<code class="cf ic">&amp;</code>
<code class="cf ic">lt;</code>。它匹配除左尖括号或右尖括号之外的任何内容。我们不能在这里使用通配符和非贪婪循环。<code class="cf ic">(TAG|.)*?</code>将匹配无效输入，例如<code class="cf ic">&lt;&lt;foo&gt;</code>因为循环内的通配符可以匹配<code class="cf ic">&lt;foo</code>。<code class="cf keyword">HTML_STRING</code>在这种情况下，不必调用<code class="cf keyword">TAG</code>来匹配标签或标签的一部分。
</p><p>
The <code class="cf keyword">HTML_STRING</code> rule allows a <code class="cf keyword">TAG</code> within a pair of
angle brackets, implementing the single level of nesting. The <code class="cf ic">~[&lt;&gt;]</code> set
takes care of matching XML character entities such as
<code class="cf ic">&amp;</code>
<code class="cf ic">lt;</code>. It matches anything other than a left or right angle bracket. We can’t use wildcard and a nongreedy loop here. <code class="cf ic">(TAG|.)*?</code> would match invalid input such as <code class="cf ic">&lt;&lt;foo&gt;</code> because the wildcard inside the loop can match <code class="cf ic">&lt;foo</code>. <code class="cf keyword">HTML_STRING</code> in that case wouldn’t have to call <code class="cf keyword">TAG</code> to match a tag or portion of a tag.
</p>
<p id="f_0042.html.N13553">
您可能会尝试使用递归来匹配尖括号，如下所示：
</p><p>
You might be tempted to use recursion to match up the angle brackets like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​HTML_STRING : <em class="string">'&lt;'</em> (HTML_STRING|~[&lt;&gt;])* <em class="string">'&gt;'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13568">
但是，这样会匹配嵌套标签，而不仅仅是匹配起始和终止尖括号。嵌套标签看起来就像这样<code class="cf ic">&lt;&lt;i&lt;br&gt;&gt;&gt;</code>，这是我们不想要的。
</p><p>
But, that matches nested tags instead of just balancing the start and stop angle
brackets. A nested tag would look like <code class="cf ic">&lt;&lt;i&lt;br&gt;&gt;&gt;</code>, which we don’t
want.
</p>
<p id="f_0042.html.N1356E"></p>
<p id="f_0042.html.N13570">
DOT 具有最后一个我们之前从未见过的词汇结构。DOT 匹配并丢弃以 开头的行，<code class="cf ic">#</code>因为它认为它们是 C 预处理器输出。我们可以像我们见过的单行注释规则一样对待它们。
</p><p>
DOT has one last lexical structure we haven’t seen before. DOT matches and discards
lines starting with <code class="cf ic">#</code> because it considers them C preprocessor output. We can
treat them just like the single-line comment rules we’ve seen.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/DOT.g4">例子/DOT.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PREPROC     :   <em class="string">'#'</em> .*? <em class="string">'\n'</em> -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0042.html.N13589">
这就是 DOT 语法的全部内容（除了我们非常熟悉的规则）。我们已经完成了第一个中等复杂的语言！除了更复杂的语法和词汇结构之外，本节强调我们经常必须查看多个来源才能揭开整个语言的面纱。语言越大，我们就越需要多个参考资料和多个代表性输入样本。有时，探究现有实现是找出边缘情况的唯一方法。没有任何语言参考资料是完美全面的。
</p><p>
That’s it for the DOT grammar (except for rules we’re very familiar with). We’ve made it
through our first moderately complex language! Aside from the more complex grammatical and
lexical structures, this section emphasizes that we often have to look at multiple sources
to unmask an entire language. The larger a language is, the more we need multiple references
and multiple representative input samples. Sometimes poking and prodding an existing
implementation is the only way to ferret out the edge cases. No language reference is ever
perfectly comprehensive.
</p>
<p id="f_0042.html.N1358C">
我们还必须决定哪些内容是解析过程的正确组成部分，哪些内容应在稍后作为单独的阶段进行处理。例如，我们将特殊端口名称（如<code class="cf variable">ne</code>和<code class="cf variable">sw</code>）视为解析器中的简单标识符。我们也不会解释字符串中的 HTML <code class="cf ic">&lt;...&gt;</code>。完整的 DOT 实现必须在某个时候验证和处理这些元素，但解析器会将它们视为块。
</p><p>
We also have to decide what is properly part of the parsing process and what should be
processed later as a separate phase. For example, we treat the special port names, such
as <code class="cf variable">ne</code> and <code class="cf variable">sw</code>, as simple identifiers in the
parser. We also don’t interpret the HTML inside <code class="cf ic">&lt;...&gt;</code> strings. A full DOT
implementation would have to verify and process these elements at some point, but the
parser gets to treat them as chunks.
</p>
<p id="f_0042.html.N1359C">
现在是时候解决一些编程语言的问题了。在下一节中，我们将为类似于 C 的传统命令式编程语言构建语法。之后，我们将使用 R 函数式编程语言迎接迄今为止最大的挑战。
</p><p>
Now it’s time to tackle some programming languages. In the next section, we’ll build a
grammar for a traditional imperative programming language that looks like C. After that, we’ll take on our biggest challenge yet with the R
functional programming language.
</p>

</div></div>
<div id="f_0043.html"><div>

<h2 id="f_0043.html.sec.Cymbol">6.4 解析 Cymbol</h2><h2>6.4 Parsing Cymbol</h2>
<p id="f_0043.html.N135A4">
为了演示如何解析一种语法源自 C 的编程语言，我们将为我发明的一种名为 Cymbol 的语言构建一个语法。Cymbol 是一种简单的非面向对象编程语言，看起来像没有 s 的 C。
<code class="cf keyword">struct</code>如果您想构建一种新编程语言，这种语言的语法可以作为其他新编程语言的良好原型。我们不会看到任何新的 ANTLR 语法，但我们的语法将演示如何构建一个简单的左递归表达式规则。
</p><p>
To demonstrate how to parse a programming language with syntax derived from C, we’re going
to build a grammar for a language I conjured up called Cymbol. Cymbol is a simple
non-object-oriented programming language that looks like C without
<code class="cf keyword">struct</code>s. A grammar for this language serves as a good prototype for other
new programming languages, if you’d like to build one. We won’t see any new ANTLR syntax,
but our grammar will demonstrate how to build a simple left-recursive expression rule.
</p>
<p id="f_0043.html.N135B1">

在设计语言时，没有正式的语法或语言参考手册可供参考。相反，我们首先会想出该语言的代表性样本。然后，我们像在第 5.1 节“<a href="#f_0033.html.sec.abstracting-grammars"><em>从语言样本中</em></a><a href="#f_0033.html.sec.abstracting-grammars">导出中所做的那样导出语法。<em></em></a> （这也是我们处理没有正式语法或语言参考的现有语言的方式。）这是一个带有全局变量和递归函数声明的程序，它显示了 Cymbol 代码的样子：
</p><p>

When designing a language, there’s no formal grammar or language reference manual to work
from. Instead, we start by conjuring up representative samples of the language. From there,
we derive a grammar as we did in Section 5.1, <a href="#f_0033.html.sec.abstracting-grammars">​<em>Deriving Grammars from Language Samples</em>​</a>. (This is also
how we’d deal with an existing language for which we had no formal grammar or language
reference.) Here’s a program with a global variable and recursive function declaration that
shows what Cymbol code looks like:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/t.cymbol">例子/t.cymbol</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​// Cymbol test​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int g = 9;        // a global variable​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int fact(int x) { // factorial function​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    if x==0 then return 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    return x * fact(x-1);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N135D3">
就像在烹饪节目中一样，让我们​​看看最终产品是什么样子，这样我们心中就会有一个目标。以下是说明我们的语法应如何解释输入（via <code class="cf ic">grun Cymbol file -gui t.cymbol</code>）的解析树：
</p><p>
Just like on a cooking show, let’s see what the final product looks like so we have a target
in mind. Here’s the parse tree that illustrates how our grammar should interpret the input (via <code class="cf ic">grun Cymbol file -gui t.cymbol</code>):
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/Cymbol-parse-tree.png">
</div>
<p id="f_0043.html.N135DD">
从最粗略的层面来看该 Cymbol 程序，我们会看到一系列全局变量和函数声明。
</p><p>
Looking at that Cymbol program at the coarsest level, we see a sequence of global
variable and function  declarations.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file:   (functionDecl | varDecl)+ ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N135ED">
变量声明看起来与所有 C 衍生产品中的声明一样，具有类型后跟标识符（可选），后跟初始化表达式。
</p><p>
Variable declarations look like they do in all C derivatives, with a type followed by an
identifier optionally followed by an initialization expression.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​varDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type ID (<em class="string">'='</em> expr)? <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​type:   <em class="string">'float'</em> | <em class="string">'int'</em> | <em class="string">'void'</em> ; <em class="comment">// user-defined types</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N13616">
函数基本相同：类型后跟函数名称，后跟带括号的参数列表，后跟函数体。
</p><p>
Functions are basically the same: a type followed by the function name followed by a
parenthesized argument list followed by a function body.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​functionDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type ID <em class="string">'('</em> formalParameters? <em class="string">')'</em> block <em class="comment">// "void f(int x) {...}"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​formalParameters​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   formalParameter (<em class="string">','</em> formalParameter)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​formalParameter​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   type ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N13649">
函数体是被花括号括起来的语句块。让我们创建六种语句：嵌套块、变量声明、<code class="cf keyword">if</code>语句、
<code class="cf keyword">return</code>语句、赋值和函数调用。我们可以用 ANTLR 语法对其进行编码，如下所示：
</p><p>
A function body is a block of statements surrounded by curly braces. Let’s make six kinds
of statements: nested block, variable  declaration, <code class="cf keyword">if</code> statement,
<code class="cf keyword">return</code> statement, assignment, and function call. We can encode that
in ANTLR syntax as follows:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​block:  <em class="string">'{'</em> stat* <em class="string">'}'</em> ;   <em class="comment">// possibly empty statement block</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   block​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   varDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'if'</em> expr <em class="string">'then'</em> stat (<em class="string">'else'</em> stat)?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'return'</em> expr? <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'='</em> expr <em class="string">';'</em> <em class="comment">// assignment</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">';'</em>          <em class="comment">// func call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N13697">
该语言的最后一个主要部分是表达式语法。由于 Cymbol 实际上只是构建其他编程语言的原型或垫脚石，因此可以避免使用一大堆运算符。假设我们有一元取反、布尔非、乘法、加法、减法、函数调用、数组索引、相等比较、变量、整数和括号表达式。
</p><p>
The last major chunk of the language is the expression syntax. Because Cymbol is really just
a prototype or stepping-stone for building other programming languages, it’s OK to avoid a
big list of operators. Let’s say we have unary negate, Boolean not, multiplication,
addition, subtraction, function calls, array indexing, equality comparison, variables,
integers, and parenthesized expressions.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   ID <em class="string">'('</em> exprList? <em class="string">')'</em>    <em class="comment">// func call like f(), f(x), f(1,2)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'['</em> expr <em class="string">']'</em>       <em class="comment">// array index like a[i], a[i][j]</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'-'</em> expr                <em class="comment">// unary minus</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'!'</em> expr                <em class="comment">// boolean not</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'*'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'+'</em>|<em class="string">'-'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'=='</em> expr          <em class="comment">// equality comparison (lowest priority op)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                      <em class="comment">// variable reference</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​exprList : expr (<em class="string">','</em> expr)* ;   <em class="comment">// arg list</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0043.html.N13710">
这里最重要的教训是，我们通常必须按从最高优先级到最低优先级的顺序列出替代方案。（有关 ANTLR 如何消除左递归和处理运算符优先级的深入讨论，请参阅第 14 章“<a href="#f_0087.html.chp.left-recursion-removal">消除<em>直接左递归</em></a>”
<a href="#f_0087.html.chp.left-recursion-removal">。</a></p><p>
The most important lesson here is that we generally have to list the alternatives in order
from highest to lowest precedence. (For an in-depth discussion of how ANTLR removes left
recursion and handles operator precedence, see Chapter 14, <a href="#f_0087.html.chp.left-recursion-removal">​<em>Removing Direct Left Recursion</em>​</a>.)
</p>
<p id="f_0043.html.N13716">
要查看优先级的实际效果，请查看输入的解析树<code class="cf ic">-x+y;</code>并
<code class="cf ic">-a[i];</code>从规则开始<code class="cf keyword">stat</code>（而不是为了<code class="cf keyword">file</code>
减少混乱）。
</p><p>
To see the precedence in action, take a look at the parse trees for input <code class="cf ic">-x+y;</code> and
<code class="cf ic">-a[i];</code> starting at rule <code class="cf keyword">stat</code> (instead of <code class="cf keyword">file</code>
to reduce clutter).
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/示例/Cymbol-expr-parse-tree.png">
</div>
<p id="f_0043.html.N1372A">
左侧的解析树显示一元减法与 的绑定最紧密，<code class="cf ic">x</code>
因为它的优先级高于加法。一元减法替代出现在加法替代之前。另一方面，一元减法的优先级低于数组索引后缀运算符，因为带有一元减法的替代出现在数组索引替代之后。右侧的解析树说明否定应用于 ，而
<code class="cf ic">a[i]</code>不仅仅是标识符<code class="cf ic">a</code>。我们将在下一节中看到更复杂的表达式规则。
</p><p>
The parse tree on the left shows the unary minus binding most tightly to the <code class="cf ic">x</code>
since it has higher priority than addition. The unary minus alternative appears before the
addition alternative. On the other hand, unary minus has lower precedence than the array
index suffix operator because the alternative with unary minus appears after the array index
alternative. The parse tree on the right illustrates that the negation is applied to the
<code class="cf ic">a[i]</code>, not just identifier <code class="cf ic">a</code>. We’ll see a more complicated expression rule
in the next section.
</p>
<p id="f_0043.html.N1373B">
我们不必像平常一样继续学习词汇规则。研究它们不会带来任何新的和有趣的东西。这些规则几乎逐字逐句地摘自上一章的词汇模式。我们这里的重点实际上是探索命令式编程语言的语法结构。
</p><p>
We don’t have to move on to the lexical rules like we usually do. Examining them wouldn’t
introduce anything new and interesting. The rules are pulled almost verbatim from the
lexical patterns in the previous chapter. Our focus here is really on exploring the
grammatical structure of an imperative programming language.
</p>
<p id="f_0043.html.N1373E"><code class="cf keyword">struct</code>利用我们对-less 或
-less Java 语言
的直觉，<code class="cf keyword">class</code>可以非常轻松地构建 Cymbol 语法。而且，如果您已经理解了这种语法，那么您就可以为自己的中等复杂的命令式编程语言构建语法了。 
</p><p>
Using our intuitive sense of what a <code class="cf keyword">struct</code>-less or
<code class="cf keyword">class</code>-less Java language might look like made building the Cymbol grammar
pretty easy. And, if you’ve wrapped your head around this grammar, you’re ready to build
grammars for your own moderately complex imperative programming languages. 
</p>
<p id="f_0043.html.N13747">
接下来，我们将研究另一种极端的语言。为了得到一个像样的 R 语法，我们必须通过查阅多个参考资料、检查示例程序和测试现有的 R 实现来推断出精确的语言结构。
</p><p>
Next, we’re going to tackle a language at the other extreme. To get a decent R grammar
together, we’ll have to deduce precise language structure by trudging through multiple
references, examining sample programs, and testing the existing R implementation.
</p>

</div></div>
<div id="f_0044.html"><div>

<h2 id="f_0044.html.sec.R">6.5 解析 R</h2><h2>6.5 Parsing R</h2>
<p id="f_0044.html.N13758">
R 是一种富有表现力的领域特定编程语言，用于描述统计问题。例如，它可以轻松创建向量、对向量应用函数以及过滤向量（此处使用 R 交互式 shell 进行显示）。
</p><p>
R is an expressive domain-specific programming language for describing statistical problems.
For example, it’s easy to create vectors, apply functions to them, and filter them (shown
here using the R interactive shell).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> x &lt;- seq(1,10,.5)     # x = 1, 1.5, 2, 2.5, 3, 3.5, ..., 10</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> y &lt;- 1:5              # y = 1, 2, 3, 4, 5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> z &lt;- c(9,6,2,10,-4)   # z = 9, 6, 2, 10, -4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> y + z                 # add two vectors</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[1] 10  8  5 14  1     # result is 1-dimensional vector​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> z[z&lt;5]                # all elements in z &lt; 5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[1]  2 -4​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> mean(z)               # compute the mean of vector z</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[1] 4.6​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> zero &lt;- function() { return(0) }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"> zero()</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[1] 0​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N137A2">
R 是一种中等规模但复杂的编程语言，我们大多数人或所有人都有一个障碍：我们不了解 R。这意味着我们不能像上一节中对 Cymbol 所做的那样，仅仅根据我们对语言结构的内部理解写下语法。我们必须通过查阅参考手册、示例和

现有实现中的
形式化<code class="cf commandname">yacc</code>
语法<a id="f_0044.html.FNPTR-36" href="#f_0044.html.FOOTNOTE-36">[36]来推断 R 的结构。</a></p><p>
R is a medium-sized but complicated programming language, and most or all of us have a
handicap: we don’t know R. That means we can’t just write down the grammar from our
internal sense of the language structure like we could for Cymbol in the previous section.
We must deduce R’s structure by wading through reference manuals, examples, and a formal
<code class="cf commandname">yacc</code>
grammar<a href="#f_0044.html.FOOTNOTE-36">[36]</a>
from the existing implementation.
</p>
<p id="f_0044.html.N137AE">
首先，最好先浏览一些语言概述。<a id="f_0044.html.FNPTR-37" href="#f_0044.html.FOOTNOTE-37">[37] </a>
<a id="f_0044.html.FNPTR-38" href="#f_0044.html.FOOTNOTE-38">[38]</a>
我们还应该查看 R 示例，以了解该语言，然后选择一些文件作为“验收测试”。Ajay Shah 已经构建了一组很好的例子<a id="f_0044.html.FNPTR-39" href="#f_0044.html.FOOTNOTE-39">[39]</a>
供我们使用。涵盖这些示例意味着我们的语法可以处理很大一部分 R 代码。（如果不熟悉该语言，就不可能获得完美的语法。）为了帮助我们构建 R 语法，主网站上有很多文档可用，<a id="f_0044.html.FNPTR-40" href="#f_0044.html.FOOTNOTE-40">[40]</a>但让我们专注于 R-intro <a id="f_0044.html.FNPTR-41" href="#f_0044.html.FOOTNOTE-41">[41]</a>
和语言定义 R-lang。<a id="f_0044.html.FNPTR-42" href="#f_0044.html.FOOTNOTE-42">[42]</a>
</p><p>
To get started, it’s a good idea to skim through some language
overviews.<a href="#f_0044.html.FOOTNOTE-37">[37]</a>
<a href="#f_0044.html.FOOTNOTE-38">[38]</a>
We should also look at R examples to get a feel for the language and then pick some files to
serve as an “acceptance test.” Ajay Shah has built a fine set of
examples<a href="#f_0044.html.FOOTNOTE-39">[39]</a>
we can use. Covering those examples would mean that our grammar handles a large percentage
of R code. (Getting a perfect grammar without knowing the language intimately is unlikely.)
To help us in our quest to build an R grammar, there’s a lot of documentation available at
the main website,<a href="#f_0044.html.FOOTNOTE-40">[40]</a> but let’s
focus on
R-intro<a href="#f_0044.html.FOOTNOTE-41">[41]</a>
and language definition
R-lang.<a href="#f_0044.html.FOOTNOTE-42">[42]</a>
</p>
<p id="f_0044.html.N137DB">
像往常一样，我们的语法构建从最粗略的层次开始。从语言概述中可以清楚地看出，R 程序是一系列表达式或赋值。甚至函数定义也是赋值；我们将函数文字分配给变量。唯一不熟悉的是，有三个赋值运算符：<code class="cf ic">&lt;-</code>、<code class="cf ic">=</code>和<code class="cf ic">&lt;&lt;-</code>。就我们的目的而言，我们不必关心它们的含义，因为我们只构建一个解析器，而不是解释器或编译器。我们对程序结构的第一次尝试看起来像这样：
</p><p>
Construction of our grammar begins at the coarsest level, as usual. From the language
overviews, it’s clear that R programs are a series of expressions or assignments. Even
function definitions are assignments; we assign a function literal to a variable. The only
unfamiliar thing is that there are three assignment operators: <code class="cf ic">&lt;-</code>, <code class="cf ic">=</code>,
and <code class="cf ic">&lt;&lt;-</code>. For our purposes, we don’t have to care about their meaning because
we’re  building only a parser, not an interpreter or compiler. Our first whack at the program
structure looks something like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog : (expr_or_assign <em class="string">'\n'</em>)* <strong class="prompt">EOF</strong> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr_or_assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   expr (<em class="string">'&lt;-'</em> | <em class="string">'='</em> | <em class="string">'&lt;&lt;-'</em> ) expr_or_assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13811">
不过，在阅读了一些示例之后，我们似乎还可以在一行中放置多个表达式，方法是用分号分隔它们。R-intro 证实了这一点。此外，虽然手册中没有提到，但 R shell 允许并忽略空行。相应地调整规则将引导我们开始语法。</p><p>
After reading some examples, though, it looks like we can also put more than one
expression on a line by separating them with semicolons. R-intro confirms this. Also,
while not in the manuals, the R shell allows and ignores blank lines. Tweaking our rules
accordingly leads us to the beginning of our grammar.</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   (   expr_or_assign (<em class="string">';'</em>|NL)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        |   NL​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">EOF</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr_or_assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   expr (<em class="string">'&lt;-'</em>|<em class="string">'='</em>|<em class="string">'&lt;&lt;-'</em>) expr_or_assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N1384B">
我们使用标记<code class="cf keyword">NL</code>而不是文字，<code class="cf ic">’\n’</code>因为我们应该允许 Windows（<code class="cf ic">\r\n</code>）和 Unix 换行符（<code class="cf ic">\n</code>），这更容易定义为词汇规则。
</p><p>
We use token <code class="cf keyword">NL</code> rather than literal <code class="cf ic">’\n’</code> because we should
allow Windows (<code class="cf ic">\r\n</code>) and Unix newlines (<code class="cf ic">\n</code>), which is easier to define
as a lexical rule.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// Match both UNIX and Windows newlines</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NL      :   <em class="string">'\r'</em>? <em class="string">'\n'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13883">
请注意，这<code class="cf keyword">NL</code>并不是说要像惯例那样丢弃这些标记。解析器将它们用作表达式终止符，就像 Java 中的分号一样，因此词法分析器必须将它们传递给解析器。
</p><p>
Notice that <code class="cf keyword">NL</code> doesn’t say to discard those tokens as is customary.
The parser uses them as expression terminators, like semicolons in Java, so the lexer
must pass them to the parser.
</p>
<p id="f_0044.html.N13889">
R 语法的大部分内容与表达式有关，因此我们将在本节的其余部分重点介绍表达式。主要有三种类型：语句表达式、运算符表达式和函数相关表达式。由于 R 语句与命令式语言的对应语句非常相似，因此让我们先从这些语句开始，以将它们排除在外。以下是处理规则中的语句的替代方案<code class="cf keyword">expr</code>（它们在 中的运算符替代方案之后实际出现<code class="cf keyword">expr</code>）：
</p><p>
The majority of R syntax relates to expressions, so that’s what we’ll focus on for the rest of the section. There
are three main kinds: statement expressions, operator expressions, and function-related
expressions. Since R statements are very similar to their imperative language
counterparts, let’s start with those to get them out of the way. Here are the
alternatives dealing with statements from rule <code class="cf keyword">expr</code> (which physically appear after the operator alternatives in <code class="cf keyword">expr</code>):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'{'</em> exprlist <em class="string">'}'</em> <em class="comment">// compound statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'if'</em> <em class="string">'('</em> expr <em class="string">')'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'if'</em> <em class="string">'('</em> expr <em class="string">')'</em> expr <em class="string">'else'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'for'</em> <em class="string">'('</em> ID <em class="string">'in'</em> expr <em class="string">')'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'while'</em> <em class="string">'('</em> expr <em class="string">')'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'repeat'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'?'</em> expr <em class="comment">// get help on expr, usually string or ID</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'next'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'break'</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N138F5">
第一个替代方案与 R-intro 中的表达式组相匹配：“基本命令可以通过括号（'{' 和 '}'）组合成一个复合表达式。” 以下是<code class="cf keyword">exprlist</code>：
</p><p>
The first alternative matches the group of expressions per R-intro: “Elementary commands can be grouped together into one compound expression by braces (’{’ and ’}’).” Here is <code class="cf keyword">exprlist</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​exprlist​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   expr_or_assign ((<em class="string">';'</em>|NL) expr_or_assign?)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13914">
大多数 R 表达式语言处理大量运算符。要获得它们的正确形式，我们最好的办法是依靠语法<code class="cf commandname">yacc</code>。可执行代码通常（但并非总是）是语言作者意图的最佳指南。要获得优先级，我们需要查看优先级表，该表明确列出了相对运算符优先级。例如，以下是语法<code class="cf commandname">yacc</code>对算术运算符的说明（<code class="cf ic">%left</code>首先列出的优先级命令优先级较低）：
</p><p>
Most of the R expression language handles the plentiful operators. To get their correct
forms, our best bet is to rely on the <code class="cf commandname">yacc</code> grammar. Executable
code is often, but not always, the best guide to a language author’s intentions. To get the
precedence, we need to look at the precedence table, which explicitly lays out the relative
operator precedence. For example, here is what the <code class="cf commandname">yacc</code> grammar
says for the arithmetic operators (<code class="cf ic">%left</code> precedence commands listed first have
lower priority):
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​%left           <em class="string">'+'</em> <em class="string">'-'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​%left           <em class="string">'*'</em> <em class="string">'/'</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N1393F">
R-lang 文档中还有一个名为“中缀和前缀运算符”的部分，其中给出了运算符优先级规则，但似乎缺少语法<code class="cf ic">:::</code>中的运算符
<code class="cf commandname">yacc</code>。综合起来，我们可以对二进制、前缀和后缀运算符使用以下替代方案：
</p><p>
The R-lang document also has a section called “Infix and prefix operators” that gives the
operator precedence rules, but it seems to be missing the <code class="cf ic">:::</code> operator found in the
<code class="cf commandname">yacc</code> grammar.  Putting it all together, we can use the following alternatives for the binary, prefix, and suffix operators:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr <em class="string">'[['</em> sublist <em class="string">']'</em> <em class="string">']'</em>  <em class="comment">// '[[' follows R's yacc grammar</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'['</em> sublist <em class="string">']'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'::'</em>|<em class="string">':::'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'$'</em>|<em class="string">'@'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'^'</em>&lt;assoc=right&gt; expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   (<em class="string">'-'</em>|<em class="string">'+'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">':'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr USER_OP expr <em class="comment">// anything wrappedin %: '%' .* '%'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'*'</em>|<em class="string">'/'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'+'</em>|<em class="string">'-'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'&gt;'</em>|<em class="string">'&gt;='</em>|<em class="string">'&lt;'</em>|<em class="string">'&lt;='</em>|<em class="string">'=='</em>|<em class="string">'!='</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'!'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'&amp;'</em>|<em class="string">'&amp;&amp;'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'|'</em>|<em class="string">'||'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'~'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'~'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'-&gt;'</em>|<em class="string">'-&gt;&gt;'</em>|<em class="string">':='</em>) expr​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N139EB">
我们不必关心运算符的含义，因为在这个例子中我们只关心识别。我们只需确保我们的语法正确匹配优先级和结合性。
</p><p>
We don’t have to care about what the operators mean since we  care only about recognition in
this example. We just have to ensure that our grammar matches the precedence and
associativity correctly.
</p>
<p id="f_0044.html.N139EE">
该规则的一个不寻常的特征是在替代中
使用<code class="cf keyword">expr</code>了。 （选择一个元素，而产生一个子列表。）我直接从 R 的语法中借鉴而来。这可能强制执行“两个左括号之间没有空格”规则，但参考手册中没有对此的明显规范。
<code class="cf ic">’[[’</code><code class="cf ic">’[’ ’[’</code><code class="cf ic">expr ’[[’ sublist ’]’ ’]’</code><code class="cf ic">[[...]]</code><code class="cf ic">[...]</code><code class="cf ic">’[[’</code><code class="cf commandname">yacc</code></p><p>
The one unusual feature of the <code class="cf keyword">expr</code> rule is the use of <code class="cf ic">’[[’</code>
instead of <code class="cf ic">’[’ ’[’</code> in alternative <code class="cf ic">expr ’[[’ sublist ’]’ ’]’</code>.
(<code class="cf ic">[[...]]</code> selects a single element, whereas <code class="cf ic">[...]</code> yields a sublist.) I
took <code class="cf ic">’[[’</code> directly from R’s <code class="cf commandname">yacc</code> grammar. This probably
enforces a “no space between two left brackets” rule, but there was no obvious
specification of this in the reference manual.
</p>
<p id="f_0044.html.N13A09">
该<code class="cf ic">^</code>运算符具有标记后缀，<code class="cf ic">&lt;assoc=right&gt;</code>因为 R-lang 表示以下内容：
</p><p>
The <code class="cf ic">^</code> operator has token suffix <code class="cf ic">&lt;assoc=right&gt;</code> because R-lang indicates the following:
</p>
<blockquote>
<p id="f_0044.html.N13A1B">
幂运算符 '^' 和左赋值运算符 '&lt;- = &lt;&lt;-' 从右到左分组，其他所有运算符从左到右分组。也就是说，2 ^ 2 ^ 3 是 2 ^ 8，而不是 4 ^ 3。
</p>
</blockquote><blockquote>
<p>
The exponentiation operator ’^’ and the left assignment operators ’&lt;- = &lt;&lt;-’ group right to left, all other operators group left to right. That is, 2 ^ 2 ^ 3 is 2 ^ 8, not 4 ^ 3.
</p>
</blockquote>
<p id="f_0044.html.N13A1E">
了解了语句和运算符表达式之后，让我们看一下规则的最后一个主要部分<code class="cf keyword">expr</code>：定义和调用函数。我们可以使用以下两种替代方法：
</p><p>
With the statement and operator expressions out of the way, let’s look at the last
major chunk of the <code class="cf keyword">expr</code> rule: defining and calling functions. We can
use the following two alternatives:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   <em class="string">'function'</em> <em class="string">'('</em> formlist? <em class="string">')'</em> expr <em class="comment">// define function</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   expr <em class="string">'('</em> sublist <em class="string">')'</em>              <em class="comment">// call function</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13A47">
规则<code class="cf keyword">formlist</code>和<code class="cf keyword">sublist</code>分别定义形式参数定义列表和调用点参数表达式。规则名称反映了<code class="cf commandname">yacc</code>语法所使用的内容，以便于比较这两个语法。
</p><p>
Rules <code class="cf keyword">formlist</code> and <code class="cf keyword">sublist</code> define the formal
argument definition lists and call site argument expressions, respectively. The rule
names mirror what the <code class="cf commandname">yacc</code> grammar uses to make it easier to compare the two grammars.
</p>
<p id="f_0044.html.N13A53">
所表达的形式函数参数<code class="cf keyword">formlist</code>遵循 R-lang 中的规范。
</p><p>
The formal function arguments expressed by <code class="cf keyword">formlist</code> follow the specification in R-lang.
</p>
<blockquote>
<p id="f_0044.html.N13A5A"><span class="standin">... 以逗号分隔的项目列表，每个项目可以是标识符，也可以是“标识符</span>
<code class="cf ic">=</code>
<span class="standin">默认值</span>”
的形式，或特殊标记<code class="cf ic">’...’</code>。<span class="standin">默认值</span>可以是任何有效的表达式。
</p>
</blockquote><blockquote>
<p>
... a comma-separated list of items each of which can be an identifier, or of the form ’<span class="standin">identifier</span>
<code class="cf ic">=</code>
<span class="standin">default</span>’, or the special token <code class="cf ic">’...’</code>. The <span class="standin">default</span> can be any valid expression.
</p>
</blockquote>
<p id="f_0044.html.N13A6A">
  我们可以使用类似于<code class="cf keyword">formlist</code>语法的ANTLR 规则对其进行编码<code class="cf commandname">yacc</code>（参见图 5，<a href="#f_0044.html.code.R.g4.formalargs">​ANTLR<em>规则为类似形式列表的规则</em>​）</a> 。
</p><p>
  We can encode that using an ANTLR rule that is similar to <code class="cf keyword">formlist</code> in the <code class="cf commandname">yacc</code> grammar (see Figure 5, <a href="#f_0044.html.code.R.g4.formalargs">​<em>ANTLR rule for a formlist-like rule</em>​</a>).
</p>
<div class="figure" id="f_0044.html.code.R.g4.formalargs">
<div>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​formlist : form (<em class="string">','</em> form)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​form:   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'...'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</div>
<div class="figurecaption">
<hr>图 5. ANTLR 的 a <code class="cf keyword">formlist</code>-like 规则</div>
</div>
<p id="f_0044.html.N13AA3">
现在，为了调用函数而不是定义函数，R-lang 描述了参数语法，如图 6 所示，<a href="#f_0044.html.blockquote.call.function">R<em> -lang 参数语法</em></a>。
</p><p>
Now, to call a function instead of defining one, R-lang describes the argument syntax
as shown in Figure 6, <a href="#f_0044.html.blockquote.call.function">​<em>R-lang argument syntax</em>​</a>.
</p>
<div class="figure" id="f_0044.html.blockquote.call.function">
<div>
<blockquote>
<p id="f_0044.html.N13AB4">
每个参数都可以被标记（tag=expr），或者只是一个简单的表达式。它也可以为空，也可以是特殊标记“...”、“..2”等之一。
</p>
</blockquote><blockquote>
<p>
Each argument can be tagged (tag=expr), or just be a simple expression. It can also be empty or it can be one of the special tokens ’...’, ’..2’, etc.
</p>
</blockquote>
</div>
<div class="figurecaption">
<hr>图 6. 调用函数的 R-lang 参数语法</div>
</div>
<p id="f_0044.html.N13AB7">
看一下<code class="cf commandname">yacc</code>语法，我们可以稍微收紧一点；它表明我们还可以有诸如 、 和 之类的东西<code class="cf ic">"n"=0</code>。<code class="cf ic">n=1</code>结合<code class="cf ic">NULL =
2</code>规范，我们得出函数调用参数的以下规则：
</p><p>
A peek at the <code class="cf commandname">yacc</code> grammar tightens this up a little bit for
us; it indicates we can also have things like <code class="cf ic">"n"=0</code>, <code class="cf ic">n=1</code>, and <code class="cf ic">NULL =
2</code>. Combining specifications, we arrive at the following rules for function call
arguments:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​sublist : sub (<em class="string">','</em> sub)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​sub :   expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   STRING <em class="string">'='</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   STRING <em class="string">'='</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'NULL'</em> <em class="string">'='</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'NULL'</em> <em class="string">'='</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'...'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13B0B">
您可能想知道<code class="cf keyword">sub</code>我们在规则中的哪个位置匹配特殊标记，例如
<code class="cf ic">..2</code>。事实证明，我们不必明确匹配它们，因为我们的词法分析器可以将它们视为标识符。根据 R-lang：
</p><p>
You might be wondering where in rule <code class="cf keyword">sub</code> we match special tokens like
<code class="cf ic">..2</code>. It turns out we don’t have to explicitly match them because our lexer can
treat them as identifiers. According to R-lang:
</p>
<blockquote>
<p id="f_0044.html.N13B15">
标识符由字母、数字、句点（“.”）和下划线序列组成。它们不能以数字或下划线开头，也不能以句点后跟数字开头。...请注意，以句点开头的标识符（如）“...”和“..1”、“..2”等是特殊的。
</p>
</blockquote><blockquote>
<p>
Identifiers consist of a sequence of letters, digits, the period (’.’), and the underscore. They must not start with a digit nor underscore, nor with a period followed by a digit. ... Notice that identifiers starting with a period [like] ‘...’ and ‘..1’, ‘..2’, etc., are special.
</p>
</blockquote>
<p id="f_0044.html.N13B18">
为了对所有这些进行编码，我们使用以下标识符规则：
</p><p>
To encode all of that, we use the following identifier rule:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/R.g4">例子/R.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   <em class="string">'.'</em> (LETTER|<em class="string">'_'</em>|<em class="string">'.'</em>) (LETTER|DIGIT|<em class="string">'_'</em>|<em class="string">'.'</em>)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   LETTER (LETTER|DIGIT|<em class="string">'_'</em>|<em class="string">'.'</em>)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> LETTER  : [a-zA-Z] ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13B48">
第一个替代方案分离出第一种情况，其中标识符以句点开头。我们必须确保数字不是下一个字符。我们可以使用子规则来确保这一点<code class="cf ic">(LETTER|’_’|’.’)</code>。为了确保标识符不以数字或下划线开头，我们以对帮助规则的引用开始第二个替代方案
<code class="cf keyword">LETTER</code>。要匹配<code class="cf ic">..2</code>，我们使用第一个替代方案。初始<code class="cf ic">’.’</code>引用匹配第一个点，<code class="cf ic">(LETTER|’_’|’.’)</code>
子规则匹配第二个点，最后一个子规则匹配数字<code class="cf ic">2</code>。
</p><p>
The first alternative separates out the first case, where an identifier starts with a
period. We have to make sure that a digit is not the next character. We can ensure that
with subrule <code class="cf ic">(LETTER|’_’|’.’)</code>. To ensure that an identifier does not start with
a digit or underscore, we start the second alternative with a reference to help rule
<code class="cf keyword">LETTER</code>. To match <code class="cf ic">..2</code>, we use the first alternative. The
initial <code class="cf ic">’.’</code> reference matches the first dot, the <code class="cf ic">(LETTER|’_’|’.’)</code>
subrule matches the second dot, and the last subrule matches digit <code class="cf ic">2</code>.
</p>
<p id="f_0044.html.N13B5D">
词法分析器规则的其余部分是我们之前见过的规则的直接复制或小扩展，因此我们可以在这里不讨论它们。
</p><p>
The remainder of the lexer rules are direct copies or small extensions of rules we’ve
seen before, so we can leave them out of our discussion here.
</p>
<p id="f_0044.html.N13B60"><code class="cf commandname">grun</code>现在让我们使用以下输入

来看看我们的作品：</p><p>
Let’s take a look our handiwork now by using <code class="cf commandname">grun</code> on the following input:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/t.R">例子/tR</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​addMe &lt;- function(x,y) { return(x+y) }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​addMe(x=1,2)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r &lt;- 1:5​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0044.html.N13B79">
  下面展示了如何以可视化的方式构建和显示输入的解析树（图 7，<a href="#f_0044.html.fig.R-parse-tree"><em>输入 tR 的</em></a><a href="#f_0044.html.fig.R-parse-tree">解析<em></em></a>）<code class="cf filename">t.R</code>：
</p><p>
  Here’s how to build and bring up the parse tree visually (Figure 7, <a href="#f_0044.html.fig.R-parse-tree">​<em>Parse tree for input t.R</em>​</a>) for input <code class="cf filename">t.R</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 R.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac R*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun R prog -gui t.R</strong>​</code></div>
</td>
</tr>
</tbody></table>
<div class="figure" id="f_0044.html.fig.R-parse-tree">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/示例/R-parse-tree.png">
</div>
<div class="figurecaption">
<hr>图 7. 输入的解析树<code class="cf filename">t.R</code>
</div>
</div>
<p id="f_0044.html.N13BAA">
只要每个表达式都占一行，我们的 R 语法就能很好地工作，例如函数
<code class="cf methodname">addMe</code>。不幸的是，这个假设过于严格，因为 R 允许函数和其他表达式跨多行。不过，我们将在这里结束，因为我们已经介绍了 R 语法结构本身。在源目录 中<code class="cf dir">code/extras</code>，您将找到忽略表达式中的换行符这一棘手问题的解决方案；请参阅<code class="cf filename">R.g4</code>、<code class="cf filename">RFilter.g4</code>和
<code class="cf filename">TestR.java</code>。它会根据语法过滤来自词法分析器的标记，以适当地保留或丢弃换行符。
</p><p>
Our R grammar works well as long as each expression fits on a line, such as function
<code class="cf methodname">addMe</code>. Unfortunately, that assumption is too restrictive because R
allows functions and other expressions to span multiple lines. Nonetheless, we’ll wrap up here because
we’ve covered the R grammatical structure itself. In source directory <code class="cf dir">code/extras</code>,
you’ll find a solution to the persnickety problem of ignoring newlines within expressions;
see <code class="cf filename">R.g4</code>, <code class="cf filename">RFilter.g4</code>, and
<code class="cf filename">TestR.java</code>. It filters tokens from the lexer to keep or toss out newlines appropriately, according to syntax.
</p>
<p id="f_0044.html.N13BBC">
本章的目标是巩固我们对 ANTLR 语法的了解，并学习如何从语言参考手册、示例和现有的非 ANTLR 语法中导出语法。为此，我们研究了两种数据语言（CSV、JSON）、一种声明性语言（DOT）、一种命令式语言（Cymbol）和一种函数式语言（R）。这些示例涵盖了为大多数中等复杂度语言构建语法所需的所有技能。不过，在继续学习之前，最好先下载语法并尝试一些简单的修改来改变语言，以巩固您的新专业知识。例如，您可以尝试向 Cymbol 语法添加更多运算符和语句。使用<code class="cf class">TestRig</code>查看更改后的语法与示例输入之间的关系。
</p><p>
Our goal in this chapter was to solidify our knowledge of ANTLR syntax and to learn how
to derive grammars from language reference manuals, examples, and existing non-ANTLR
grammars. To that end, we looked at two data languages (CSV, JSON), a declarative
language (DOT), an imperative language (Cymbol), and a functional language (R). These
examples cover all of the skills you’ll need to build grammars for most
moderately complex languages. Before you move on, though, it’s a good idea to lock in
your new expertise by downloading the grammars and trying some simple modifications to
alter the languages. For example, you might try adding more operators and statements to
the Cymbol grammar. Use the <code class="cf class">TestRig</code> to see the relationship between your
altered grammars and sample inputs.
</p>
<p id="f_0044.html.N13BC9">
到目前为止，我们在本书中关注的是语言识别。但是，语法本身只能指示输入是否符合语言。现在我们是解析向导，我们准备学习如何将特定于应用程序的代码附加到解析机制，我们将在下一章中进行介绍。之后，我们将构建一些真正的语言应用程序。
</p><p>
So far in this book, we have focused on language recognition. But, grammars by themselves
can  indicate only whether  the input conforms to the language. Now that we are parsing
wizards, we’re ready to learn about attaching application-specific code to the parsing
mechanism, which we’ll do in the next chapter. Following that, we’ll build some real
language applications.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-28" href="#f_0039.html.FNPTR-28">[28]</a>
</td>
<td>
<p id="f_0044.html.N12D89">
<a href="http://www.json.org/">http://www.json.org</a>
</p><p>
<a href="http://www.json.org">http://www.json.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-29" href="#f_0039.html.FNPTR-29">[29]</a>
</td>
<td>
<p id="f_0044.html.N12D92">
<a href="http://www.graphviz.org/">http://www.graphviz.org</a>
</p><p>
<a href="http://www.graphviz.org">http://www.graphviz.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-30" href="#f_0039.html.FNPTR-30">[30]</a>
</td>
<td>
<p id="f_0044.html.N12DA1">
<a href="http://www.r-project.org/">http://www.r-project.org</a>
</p><p>
<a href="http://www.r-project.org">http://www.r-project.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-31" href="#f_0041.html.FNPTR-31">[31]</a>
</td>
<td>
<p id="f_0044.html.N12F15">
<a href="http://json.org/">http://json.org</a>
</p><p>
<a href="http://json.org">http://json.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-32" href="#f_0042.html.FNPTR-32">[32]</a>
</td>
<td>
<p id="f_0044.html.N132F8">
<a href="http://www.graphviz.org/Documentation/dotguide.pdf">http://www.graphviz.org/Documentation/dotguide.pdf</a>
</p><p>
<a href="http://www.graphviz.org/Documentation/dotguide.pdf">http://www.graphviz.org/Documentation/dotguide.pdf</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-33" href="#f_0042.html.FNPTR-33">[33]</a>
</td>
<td>
<p id="f_0044.html.N13331">
<a href="http://www.graphviz.org/">http://www.graphviz.org</a>
</p><p>
<a href="http://www.graphviz.org">http://www.graphviz.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-34" href="#f_0042.html.FNPTR-34">[34]</a>
</td>
<td>
<p id="f_0044.html.N13345">
<a href="http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html">http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html</a>
</p><p>
<a href="http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html">http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-35" href="#f_0042.html.FNPTR-35">[35]</a>
</td>
<td>
<p id="f_0044.html.N1340E">
<a href="http://www.graphviz.org/">http://www.graphviz.org</a>
</p><p>
<a href="http://www.graphviz.org">http://www.graphviz.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-36" href="#f_0044.html.FNPTR-36">[36]</a>
</td>
<td>
<p id="f_0044.html.N137A9">
<a href="http://svn.r-project.org/R/trunk/src/main/gram.y">http://svn.r-project.org/R/trunk/src/main/gram.y</a>
</p><p>
<a href="http://svn.r-project.org/R/trunk/src/main/gram.y">http://svn.r-project.org/R/trunk/src/main/gram.y</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-37" href="#f_0044.html.FNPTR-37">[37]</a>
</td>
<td>
<p id="f_0044.html.N137BA">
<a href="http://www.stat.wisc.edu/~deepayan/SIBS2005/slides/language-overview.pdf">http://www.stat.wisc.edu/~deepayan/SIBS2005/slides/language-overview.pdf</a>
</p><p>
<a href="http://www.stat.wisc.edu/~deepayan/SIBS2005/slides/language-overview.pdf">http://www.stat.wisc.edu/~deepayan/SIBS2005/slides/language-overview.pdf</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-38" href="#f_0044.html.FNPTR-38">[38]</a>
</td>
<td>
<p id="f_0044.html.N137BF">
<a href="http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat600/Notes/R_introduction.pdf">http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat600/Notes/R_introduction.pdf</a>
</p><p>
<a href="http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat600/Notes/R_introduction.pdf">http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat600/Notes/R_introduction.pdf</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-39" href="#f_0044.html.FNPTR-39">[39]</a>
</td>
<td>
<p id="f_0044.html.N137C5">
<a href="http://www.mayin.org/ajayshah/KB/R/index.html">http://www.mayin.org/ajayshah/KB/R/index.html</a>
</p><p>
<a href="http://www.mayin.org/ajayshah/KB/R/index.html">http://www.mayin.org/ajayshah/KB/R/index.html</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-40" href="#f_0044.html.FNPTR-40">[40]</a>
</td>
<td>
<p id="f_0044.html.N137CB">
<a href="http://www.r-project.org/">http://www.r-project.org/</a>
</p><p>
<a href="http://www.r-project.org/">http://www.r-project.org/</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-41" href="#f_0044.html.FNPTR-41">[41]</a>
</td>
<td>
<p id="f_0044.html.N137D1">
<a href="http://cran.r-project.org/doc/manuals/R-intro.pdf">http://cran.r-project.org/doc/manuals/R-intro.pdf</a>
</p><p>
<a href="http://cran.r-project.org/doc/manuals/R-intro.pdf">http://cran.r-project.org/doc/manuals/R-intro.pdf</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0044.html.FOOTNOTE-42" href="#f_0044.html.FNPTR-42">[42]</a>
</td>
<td>
<p id="f_0044.html.N137D7">
<a href="http://cran.r-project.org/doc/manuals/R-lang.html">http://cran.r-project.org/doc/manuals/R-lang.html</a>
</p><p>
<a href="http://cran.r-project.org/doc/manuals/R-lang.html">http://cran.r-project.org/doc/manuals/R-lang.html</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0045.html"><div>

<h1 class="chapter-title" id="f_0045.html.chp.listeners">
<span class="chapter-number">
	      第七章</span>
<br><br>
<span class="chapter-name">将语法与特定于应用程序的代码分离</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      7</span>
<br><br>
<span class="chapter-name">Decoupling Grammars from Application-Specific Code</span>
</h1>

<p id="f_0045.html.N13BD5">
现在我们已经知道如何使用 ANTLR 语法来正式定义语言，是时候为我们的语法注入一些活力了。语法本身并没有那么有用，因为相关的解析器只能告诉我们输入的句子是否符合语言规范。要构建语言应用程序，我们需要解析器在看到特定的输入句子、短语或标记时触发特定的操作。短语 → 操作对的集合代表我们的语言应用程序，或者至少是语法与更大的周围应用程序之间的接口。
</p><p>
Now that we know how to formally define languages using ANTLR grammar syntax, it’s time to
breathe some life into our grammars. By itself, a grammar isn’t that useful because the
associated parser  tells us only whether  an input sentence conforms to a language
specification. To build language applications, we need the parser to trigger specific
actions when it sees specific input sentences, phrases, or tokens. The collection of phrase
→ action pairs represents our language application or at least the interface between
the grammar and a larger surrounding application.
</p>
<p id="f_0045.html.N13BD8">
在本章中，我们将学习如何使用解析树<span class="firstuseinline">监听器</span>
和<span class="firstuseinline">访问者</span>来构建语言应用程序。监听器是一个对象，它响应解析树遍历器在发现和完成节点时触发的规则进入和退出事件（短语识别事件）。为了支持应用程序必须控制树的遍历方式的情况，ANTLR 生成的解析树还支持众所周知的树访问者模式。
</p><p>
In this chapter, we’re going to learn how to use parse-tree <span class="firstuseinline">listeners</span>
and <span class="firstuseinline">visitors</span> to build language applications. A listener is an object
that responds to rule entry and exit events (phrase recognition events) triggered by a parse-tree walker as it discovers and finishes nodes. To support situations where an application
must control how a tree is walked, ANTLR-generated parse trees also support the well-known
tree visitor pattern.
</p>
<p id="f_0045.html.N13BEC">
监听器和访问者之间的最大区别在于，监听器方法不负责显式调用方法来遍历其子节点。而访问者则必须显式触发对子节点的访问，以保持树的遍历继续进行（如我们在第 2.5 节“<a href="#f_0019.html.sec.listeners-and-visitors">解析<em>树监听器和访问者</em></a>”中看到的那样<a href="#f_0019.html.sec.listeners-and-visitors">）</a><span class="firstuseinline">事件方法”</span>来指代监听器回调或访问者方法。
</p><p>
The biggest difference between listeners and visitors is that listener methods aren’t
responsible for explicitly calling methods to walk their children. Visitors, on the other
hand, must explicitly trigger visits to child nodes to keep the tree traversal going (as we
saw in Section 2.5, <a href="#f_0019.html.sec.listeners-and-visitors">​<em>Parse-Tree Listeners and Visitors</em>​</a>). Visitors get to control the order of
traversal and how much of the tree gets visited because of these explicit calls to visit
children. For convenience, I’ll use the term <span class="firstuseinline">event method</span> to refer to
either a listener callback or a visitor method.
</p>
<p id="f_0045.html.N13C08">
本章的目标是准确理解 ANTLR 为我们构建了哪些树遍历功能以及构建的原因。我们首先会了解监听器机制的起源，以及如何使用监听器和访问者将特定于应用程序的代码排除在我们的语法之外。接下来，我们将学习如何让 ANTLR 生成更精确的事件，每个事件对应于规则中的每个替代方案。一旦我们对 ANTLR 的树遍历有了更多的了解，我们将研究三种计算器实现，它们说明了传递子表达式结果的不同方法。最后，我们将讨论这三种方法的优缺点。到那时，我们将准备好在下一章中处理真实的例子。
</p><p>
Our goal in this chapter is to understand exactly what tree-walking facilities ANTLR
builds for us and why. We’ll start by looking at the origins of the listener mechanism and
how we can keep application-specific code out of our grammars using listeners and
visitors. Next, we’ll learn how to get ANTLR to generate more precise events, one for each
alternative in a rule. Once we know a little more about ANTLR’s tree walking, we’ll look
at three calculator implementations that illustrate different ways to pass around
subexpression results. Finally, we’ll discuss the advantages and disadvantages of the
three approaches. At that point, we’ll be ready to tackle the real examples in the next
chapter.
</p>

</div></div>
<div id="f_0046.html"><div>

<h2 id="f_0046.html.N13C17">7.1 从嵌入式动作演变为监听器</h2><h2>7.1 Evolving from Embedded Actions to Listeners</h2>
<p id="f_0046.html.N13C1B">
如果您习惯使用 ANTLR 或其他解析器生成器的早期版本，您会惊讶地发现我们可以构建语言应用程序而无需在语法中嵌入操作（代码）。侦听器和访问者机制将语法与应用程序代码分离，从而提供了一些引人注目的好处。这种分离很好地封装了应用程序，而不是将其拆分并分散到语法中。没有嵌入的操作，我们可以在不同的应用程序中重用相同的语法，甚至无需重新编译生成的解析器。
</p><p>
If you’re used to previous versions of ANTLR or other parser generators, you’ll be
surprised to hear that we can build language applications without embedding actions (code)
in the grammars. The listener and visitor mechanisms decouple grammars from application
code, providing some compelling benefits. Such decoupling nicely encapsulates an
application instead of fracturing it and dispersing the pieces across a grammar. Without embedded actions, we can reuse the same grammar in different applications without even
recompiling the generated parser.
</p>
<p id="f_0046.html.N13C2A">
如果缺少操作，ANTLR 还可以为同一语法生成不同编程语言的解析器。（我预计在 4.0 版本之后将支持不同的目标语言。）集成语法错误修复或更新也很容易，因为我们不必担心由于嵌入操作而导致的合并冲突。
</p><p>
ANTLR can also generate parsers in different programming languages for the same grammar if
it’s bereft of actions. (I anticipate supporting different target languages after the 4.0
release.) Integrating grammar bug fixes or updates is also easy because we don’t have to
worry about merge conflicts because of embedded actions.
</p>
<p id="f_0046.html.N13C2D">
在本节中，我们将研究从嵌入操作的语法到完全解耦的语法和应用程序的演变。以下嵌入操作的属性文件语法以“ <span class="elide emph">... ”表示，它读取属性文件，每行一个属性分配。诸如“</span><span class="elide emph">启动文件</span>”之类的操作只是适当 Java 代码的替代品。
</p><p>
In this section, we’re going to investigate the evolution from grammar with embedded actions
to completely decoupled grammar and application. The following property file grammar with
embedded actions sketched in with «<span class="elide emph">...</span>» reads property files, one property
assignment per line. Actions like «<span class="elide emph">start file</span>» are just stand-ins for
appropriate Java code.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> PropertyFile;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : {start file} prop+ {finish file} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prop : ID <em class="string">'='</em> STRING <em class="string">'\n'</em> {process property} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID   : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> .*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0046.html.N13C65">
如此紧密的耦合将语法与一个特定的应用程序联系在一起。更好的方法是创建 （<code class="cf class">PropertyFileParser</code>由 ANTLR 生成的解析器）的子类，并将嵌入的操作转换为方法。重构只会在语法中留下触发新创建方法的简单方法调用操作。然后，通过对解析器进行子类化，我们可以实现任意数量的不同应用程序而无需更改语法。一个这样的重构如下所示：
</p><p>
Such a tight coupling ties the grammar to one specific application. A better approach is to
create a subclass of <code class="cf class">PropertyFileParser</code>, the parser generated by ANTLR, and
convert the embedded actions to methods. The refactoring leaves only trivial method call
actions in the grammar that trigger the newly created methods. Then, by subclassing the
parser, we can implement any number of different applications without altering the grammar.
One such refactoring looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> PropertyFile;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@members</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    void startFile() { }  <em class="comment">// blank implementations</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    void finishFile() { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    void defineProperty(Token name, Token value) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : {startFile();} prop+ {finishFile();} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prop : ID <em class="string">'='</em> STRING <em class="string">'\n'</em> {defineProperty($ID, $STRING)} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID   : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> .*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0046.html.N13CA4">
这种解耦使得语法可以在不同的应用程序中重复使用，但由于方法调用，语法仍然与 Java 绑定。我们稍后会处理这个问题。
</p><p>
This decoupling makes the grammar reusable for different applications, but the grammar
is still tied to Java because of the method calls. We’ll deal with that shortly.
</p>
<p id="f_0046.html.N13CA7">
为了演示重构语法的可重用性，让我们构建两个不同的“应用程序”，首先是一个在遇到属性时打印属性的应用程序。这个过程只是扩展 ANTLR 生成的解析器类并覆盖语法触发的一个或多个方法。
</p><p>
To demonstrate the reusability of the refactored grammar, let’s build two different
“applications,” starting with one that just prints out the properties as it encounters
them. The process is simply to extend the parser class generated by ANTLR and override one or more of the methods triggered by the grammar.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class</strong> PropertyFilePrinter <strong class="prompt">extends</strong> PropertyFileParser {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> defineProperty(Token name, Token value) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(name.getText()+<em class="string">"="</em>+value.getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0046.html.N13CD0">
请注意，我们不必覆盖<code class="cf methodname">startFile</code>或
因为ANTLR 生成的超类
<code class="cf methodname">finishFile</code>中的默认实现
。<code class="cf class">PropertyFileParser</code></p><p>
Notice that we don’t have to override <code class="cf methodname">startFile</code> or
<code class="cf methodname">finishFile</code> because of the default implementations in the
<code class="cf class">PropertyFileParser</code> superclass generated by ANTLR.
</p>
<p id="f_0046.html.N13CDC">
要启动此应用程序，我们需要创建一个特殊的
<code class="cf class">PropertyFilePrinter</code>解析器子类的实例，而不是通常的
<code class="cf class">PropertyFileParser</code>。
</p><p>
To launch this application, we need to create an instance of our special
<code class="cf class">PropertyFilePrinter</code> parser subclass instead of the usual
<code class="cf class">PropertyFileParser</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileLexer lexer = <strong class="prompt">new</strong> PropertyFileLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFilePrinter parser = <strong class="prompt">new</strong> PropertyFilePrinter(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.file(); <em class="comment">// launch our special version of the parser</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0046.html.N13D05">
作为第二个应用，让我们将属性加载到映射中，而不是将其打印出来。我们要做的就是创建一个新的子类并放入不同的功能<code class="cf methodname">defineProperty</code>。
</p><p>
As a second application, let’s load the properties into a map instead of printing
them out. All we have to do is create a new subclass and put different functionality in <code class="cf methodname">defineProperty</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class</strong> PropertyFileLoader <strong class="prompt">extends</strong> PropertyFileParser {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt; props = <strong class="prompt">new</strong> OrderedHashMap&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> defineProperty(Token name, Token value) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        props.put(name.getText(), value.getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0046.html.N13D40">
解析器执行后，字段<code class="cf variable">props</code>将包含名称-值对。
</p><p>
After the parser executes, field <code class="cf variable">props</code> will contain the name-value pairs.
</p>
<p id="f_0046.html.N13D46">
此语法仍存在一个问题，即嵌入操作限制我们只能用 Java 生成解析器。为了使语法可重用且语言中立，我们需要完全避免嵌入操作。接下来的两节将展示如何使用侦听器和访问者来实现这一点。
</p><p>
This grammar still has the problem that the embedded actions restrict us to generating
parsers only in Java. To make the grammar reusable and language neutral, we need to
completely avoid embedded actions. The next two sections show how to do that with a
listener and a visitor.
</p>

</div></div>
<div id="f_0047.html"><div>

<h2 id="f_0047.html.sec.listeners">7.2 使用解析树监听器实现应用程序</h2><h2>7.2 Implementing Applications with Parse-Tree Listeners</h2>
<p id="f_0047.html.N13D57">
要构建语言应用程序而不使应用程序和语法纠缠在一起，关键是让解析器创建解析树，然后遍历它以触发特定于应用程序的代码。我们可以使用我们最喜欢的技术来遍历树，也可以使用 ANTLR 生成的树遍历机制之一。在本节中，我们将使用 ANTLR 的内置功能<code class="cf class">ParseTreeWalker</code>构建上一节中属性文件应用程序的基于侦听器的版本。
</p><p>
To build language applications without entangling the application and the grammar, the key
is to have the parser create a parse tree and then walk it to trigger application-specific
code. We can walk the tree using our favorite technique, or we can use one of the
tree-walking mechanisms that ANTLR generates. In this section, we’re going to use ANTLR’s
built-in <code class="cf class">ParseTreeWalker</code> to build a listener-based version of the property
file application from the previous section.
</p>
<p id="f_0047.html.N13D6D">
让我们从属性文件语法的简化版本开始。
</p><p>
Let’s start with a denuded version of the property file grammar.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/PropertyFile.g4">听众/PropertyFile.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : prop+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prop : ID <em class="string">'='</em> STRING <em class="string">'\n'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13D86">
以下是示例属性文件：
</p><p>
Here’s a sample property file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/t.properties">听众/t.properties</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​user="parrt"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​machine="maniac"​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13D99">
从语法中，ANTLR 生成<code class="cf class">PropertyFileParser</code>，它自动构建以下解析树：
</p><p>
From the grammar, ANTLR generates <code class="cf class">PropertyFileParser</code>, which automatically
builds the following parse tree:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOkAAABPBAAAAADu6VDNAAAACXBIWXMAAABIAAAASABGyWs+AAAET0lEQVRo3u2ZvVMTQRTAD2eMXOEsHUOjY2Xl0NhYaWerfwFpbQIzznCACLHKOKNwoTCTGcwxNhbMSGHBaINdoCFYIVXGhohNdnAgHElu3bf3tXe5JHcb8oHyYLJ7b9/ub9/bl8u9RCJ9ECxdJuojhPpARaQPVCwhpEtyz31FCGtqP6iScCZ2QhVlXsII9yGbOpMr6hXVI0fKTKHX1HPlLTE+zhZ7Sa2l5llbz8z1jEpZZYevvOkN1RfXc+V996nbSsGvOlA+dZfaBBCwlYujtghmxHQOT7UTN1j4FLs4avtVW+9KiBoqguHTORQ1dLaETecQ1INUhHdGuA22pf6OehcIcxhtqCJ3vBDp3JIqenevpV4IUzv4JCNV+kkoRtULokyQo1Y7vmRPMP8MFb+S5duqpNFWZNHhETUN9cjwiBaJuqzGyrKOaCtE1aUE1F7DOopEJRi+AqDFolC5iIgESzT/GmGgqJqKCERYrESVdQmWgBUiUeMyIpBNcaFsikkqgWyKSVokqq+NKMjXDjS123JFBdHvv+xg3drzxxsC1B/K6mvBOpFKfm7+MN98ejPq5lKWLFRnymKOKhuVgrFIm2jUzIaukRKpp4pCjhJjgTasF54KsCx9lt8iRmZLwFFCDmmQaovWRTgqBJa6SgjdMNnMRXaUPugloLvjXIeg6mCXhV4JXvajpLLlG7hKzJ0HuttILc07E84K8HrU5uHW7ygFLZmXWY+2FTW/wNkvstfqbDmKoyyPiOtsgLt+akbjzffNpq4UwztqppEpqw1jQVTDqsi+WNdnFi1EKnP+5B1lpeAO81npodYUM5Q1Z4FJu9MulTlnzpddNVe+57lz4qn6rNXZdlRfnV7LVPYcXJYbqJR5I2fnHLVkb8w9F35Wi1T2nJqdE6YkPHa2uy7VTF7Wc+0MdwNNU9mXoVnP4GHZa5rzUjPOFjlXCVnn+vWZYjtHqaueLVh3Kb+7FtXgvk7I81b8wRAjtdXGUU/+MCk1TMg51Dq3uMchwxvVBmrVr/CHo172W+wO3BMMxg0X+mSAWfDjq+fXWcTr3oWmYvPCuBVIDZKg34RN3c8yo9IyiFYH9B+neZuTU1p+ZkGL09L1U6Z7hlfGWOeG/FSDikSV1PQYJvId2tP42ROTYAJVBx1DzFKbYKE61aiGUfGiSosh7EtyKENBS/8sxWecWGEd+dv6ONROdLOTHzCJHY03FFJgAhUWHUPM0hqvPqQa09dRSpewddCSPR+Rm8oUJm45ebxndRFUifsKjRnsGSpGa5Y7G0zqyhSMIWZpyz2oUClsj+w8CMoKRK4pazy1MsVT785x1IZzBJNjZY2NMUtbFJO6G8daEiLs95XGL5fkqfURnir/QqxQZVQrgl5fcS7JqMzSXvU7o+ojSSub/NuNSdmhaai6/9gznvBUdTROs8miqv5SFUz0oWkEVGZpj58wKmkqiHRLBo/aPfmvqH8BOxJXYO+S3Z4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTMtMDEtMTVUMjI6NDY6NDUtMDY6MDBwqYs9AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEzLTAxLTE1VDIyOjQ2OjQ1LTA2OjAwAfQzgQAAACB0RVh0cGRmOkhpUmVzQm91bmRpbmdCb3gANjEyeDc5MiswKzCfnX1XAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS4zIFMGrL8AAAAASUVORK5CYII=" alt="图片/听众/prop-file.png">
</div>
<p id="f_0047.html.N13DA4">
一旦我们有一个解析树，我们就可以用来<code class="cf class">ParseTreeWalker</code>访问所有节点，触发进入和退出方法。
</p><p>
Once we have a parse tree, we can use <code class="cf class">ParseTreeWalker</code> to visit all of the nodes, triggering enter and exit methods.
</p>
<p id="f_0047.html.N13DAE">
让我们看一下<code class="cf class">PropertyFileListener</code>ANTLR 从 grammar 生成的监听器接口<code class="cf class">PropertyFile</code>。ANTLR<code class="cf class">ParseTreeWalker</code>
在发现和完成节点时分别触发每个规则子树的进入和退出方法。由于 grammar 中只有两个解析器规则
<code class="cf class">PropertyFile</code>，因此接口中有四个方法。
</p><p>
Let’s take a look at listener interface <code class="cf class">PropertyFileListener</code> that ANTLR
generates from grammar <code class="cf class">PropertyFile</code>. ANTLR’s <code class="cf class">ParseTreeWalker</code>
triggers enter and exit methods for each rule subtree as it discovers and finishes nodes,
respectively. Because there are only two parser rules in grammar
<code class="cf class">PropertyFile</code>, there are four methods in the interface.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/PropertyFileListener.java">听众/PropertyFileListener.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.tree.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.Token;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> PropertyFileListener <strong class="prompt">extends</strong> ParseTreeListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> enterFile(PropertyFileParser.FileContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> exitFile(PropertyFileParser.FileContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> enterProp(PropertyFileParser.PropContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">void</strong> exitProp(PropertyFileParser.PropContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13DFC"><code class="cf class">FileContext</code>和
对象<code class="cf class">PropContext</code>是针对每个语法规则的解析树节点的实现。它们包含一些有用的方法，我们将在后面的内容中探索它们。
</p><p>
The <code class="cf class">FileContext</code> and <code class="cf class">PropContext</code> objects are implementations
of parse-tree nodes specific to each grammar rule. They contain useful methods that we’ll
explore as we go along.
</p>
<p id="f_0047.html.N13E05">
为了方便起见，ANTLR 还生成具有默认实现的类，模仿我们在上一节语法区域
<code class="cf class">PropertyFileBaseListener</code>中手动编写的空白方法
。<code class="cf keyword">@members</code></p><p>
As a convenience, ANTLR also generates class <code class="cf class">PropertyFileBaseListener</code> with
default implementations that mimic the blank methods we manually wrote in the
<code class="cf keyword">@members</code> area of the grammar in the previous section.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> PropertyFileBaseVisitor&lt;T&gt; <strong class="prompt">extends</strong> AbstractParseTreeVisitor&lt;T&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">implements</strong> PropertyFileVisitor&lt;T&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override <strong class="prompt">public</strong> T visitFile(PropertyFileParser.FileContext ctx) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override <strong class="prompt">public</strong> T visitProp(PropertyFileParser.PropContext ctx) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13E3A">
默认实现允许我们重写和实现我们关心的方法。例如，下面是属性文件加载器的重新实现，它像以前一样只有一个方法，但使用了侦听器机制：
</p><p>
The default implementations let us override and implement only those methods we care
about. For example, here’s a reimplementation of the property file loader that has a
single method like before, but using the listener mechanism:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestPropertyFile.java">听众/TestPropertyFile.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> PropertyFileLoader <strong class="prompt">extends</strong> PropertyFileBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt; props = <strong class="prompt">new</strong> OrderedHashMap&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitProp(PropertyFileParser.PropContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> id = ctx.ID().getText(); <em class="comment">// prop : ID '=' STRING '\n' ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> value = ctx.STRING().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        props.put(id, value);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13E8A">
主要区别在于，此版本扩展了基本侦听器而不是解析器，并且侦听器方法在解析器完成后被触发。
</p><p>
The main differences are that this version extends the base listener instead of the parser
and that the listener methods get triggered after the parser has completed.
</p>
<p id="f_0047.html.N13E8D">
这里有很多接口和类，所以让我们看看关键参与者（斜体接口）之间的继承关系。
</p><p>
There are a lot of interfaces and classes in flight here, so let’s look at the inheritance relationship between the key players (interfaces in italics).
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/听众/听众-hier.png">
</div>
<p id="f_0047.html.N13E94">
接口<code class="cf class">ParseTreeListener</code>位于 ANTLR 运行时库中，指示每个侦听器响应事件<code class="cf methodname">visitTerminal</code>、
 <code class="cf methodname">enterEveryRule</code>、<code class="cf methodname">exitEveryRule</code>和（语法错误时）
 <code class="cf methodname">visitErrorNode</code>。ANTLR
<code class="cf class">PropertyFileListener</code>根据语法<code class="cf class">PropertyFile</code>和类 中所有方法的默认实现生成接口<code class="cf class">PropertyFileBaseListener</code>。我们唯一要构建的是<code class="cf class">PropertyFileLoader</code>，它继承了 的所有空白功能<code class="cf class">PropertyFileBaseListener</code>。
</p><p>
Interface <code class="cf class">ParseTreeListener</code> is in the ANTLR runtime library and dictates
that every listener respond to events <code class="cf methodname">visitTerminal</code>,
<code class="cf methodname">enterEveryRule</code>, <code class="cf methodname">exitEveryRule</code>, and (upon syntax errors)
<code class="cf methodname">visitErrorNode</code>. ANTLR generates interface
<code class="cf class">PropertyFileListener</code> from grammar <code class="cf class">PropertyFile</code> and default
implementations for all methods in class <code class="cf class">PropertyFileBaseListener</code>. The only
thing that we’re building is the <code class="cf class">PropertyFileLoader</code>, which inherits all of
the blank functionality from <code class="cf class">PropertyFileBaseListener</code>.
</p>
<p id="f_0047.html.N13EB9">
方法可以访问与规则关联的<code class="cf methodname">exitProp</code>规则上下文对象
。该上下文对象具有规则中提到的每个元素的方法
（和）。由于这些元素是语法中的标记引用，因此这些方法返回解析树节点。我们可以通过直接访问标记有效负载的文本
（如我们在此处所做的那样），也可以先通过获取有效负载。
<code class="cf class">PropContext</code><code class="cf keyword">prop</code><code class="cf keyword">prop</code><code class="cf keyword">ID</code><code class="cf keyword">STRING</code><code class="cf class">TerminalNode</code><code class="cf methodname">getText</code><code class="cf class">Token</code><code class="cf methodname">getSymbol</code></p><p>
Method <code class="cf methodname">exitProp</code> has access to the rule context object,
<code class="cf class">PropContext</code>, associated with rule <code class="cf keyword">prop</code>. That context
object has methods for each of the elements mentioned in rule <code class="cf keyword">prop</code>
(<code class="cf keyword">ID</code> and <code class="cf keyword">STRING</code>). Because those elements are token
references in the grammar, the methods return <code class="cf class">TerminalNode</code> parse-tree
nodes. We can either directly access the text of the token payload via
<code class="cf methodname">getText</code>, as we’ve done here, or get the <code class="cf class">Token</code> payload
first via <code class="cf methodname">getSymbol</code>.
</p>
<p id="f_0047.html.N13EDA">
现在到了激动人心的结论。让我们沿着树走一走，用我们的新声音聆听
<code class="cf class">PropertyFileLoader</code>。
</p><p>
And now for the exciting conclusion. Let’s walk the tree, listening in with our new
<code class="cf class">PropertyFileLoader</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestPropertyFile.java">听众/TestPropertyFile.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// create a standard ANTLR parse tree walker</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// create listener then feed to walker</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileLoader loader = <strong class="prompt">new</strong> PropertyFileLoader();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(loader, tree);        <em class="comment">// walk parse tree</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(loader.props); <em class="comment">// print results</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13F0A">
以下是有关如何在语法上运行 ANTLR、编译生成的代码以及启动测试程序来处理输入文件的复习：
</p><p>
Here’s a refresher on how to run ANTLR on a grammar, compile the generated code, and launch
a test program to process an input file:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 PropertyFile.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls PropertyFile*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileBaseListener.java   PropertyFileListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileLexer.java          PropertyFileParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac TestPropertyFile.java PropertyFile*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat t.properties</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​user="parrt"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​machine="maniac"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java TestPropertyFile t.properties</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{user="parrt", machine="maniac"}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0047.html.N13F43">
我们的测试程序成功地将文件中的属性分配重构到内存中的地图数据结构中。
</p><p>
Our test program successfully reconstitutes the property assignments from the file into a
map data structure in memory.
</p>
<p id="f_0047.html.N13F46">
基于侦听器的方法很棒，因为所有树遍历和方法触发都是自动完成的。但有时，自动树遍历也是一个弱点，因为我们无法控制遍历本身。例如，我们可能想要遍历 C 程序的解析树，通过跳过函数体子树来忽略函数内的所有内容。侦听器事件方法也不能使用方法返回值来传递数据。当我们需要控制遍历或想要使用事件方法返回值返回值时，我们使用访问者模式。让我们构建此属性文件加载器的基于访问者的版本来比较这些方法。
</p><p>
A listener-based approach is great because all of the tree walking and method triggering is
done automatically. Sometimes, though, automatic tree walking is also a weakness because we
can’t control the walk itself. For example, we might want to walk a parse tree for a C
program, ignoring everything inside functions by skipping the function body subtrees.
Listener event methods also can’t use method return values to pass data around. When we need
to control the walk or want to return values with event-method return values, we use a
visitor pattern. Let’s build a visitor-based version of this property file loader to compare
the approaches.
</p>

</div></div>
<div id="f_0048.html"><div>

<h2 id="f_0048.html.N13F4F">7.3 使用访问者实现应用程序</h2><h2>7.3 Implementing Applications with Visitors</h2>
<p id="f_0048.html.N13F53">
要使用访问者而不是监听器，我们要求 ANTLR 生成访问者接口，实现该接口，然后创建调用<code class="cf methodname">visit</code>解析树的测试装置。我们根本不需要触及语法。
</p><p>
To use a visitor instead of a listener, we ask ANTLR to generate a visitor interface,
implement that interface, and then create a test rig that calls <code class="cf methodname">visit</code> on
the parse tree. We don’t have to touch the grammar at all.
</p>
<p id="f_0048.html.N13F5D"><code class="cf commandoption">-visitor</code>当我们在命令行上 
  
使用该选项时，ANTLR 会生成接口<code class="cf class">PropertyFileVisitor</code>和类<code class="cf class">PropertyFileBaseVisitor</code>，它们具有以下默认实现：
</p><p>
When we use the <code class="cf commandoption">-visitor</code> option on the command line, ANTLR generates interface 
  <code class="cf class">PropertyFileVisitor</code> and class <code class="cf class">PropertyFileBaseVisitor</code>, which has the following default implementations:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> PropertyFileBaseVisitor&lt;T&gt; <strong class="prompt">extends</strong> AbstractParseTreeVisitor&lt;T&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">implements</strong> PropertyFileVisitor&lt;T&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override <strong class="prompt">public</strong> T visitFile(PropertyFileParser.FileContext ctx) { ... }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override <strong class="prompt">public</strong> T visitProp(PropertyFileParser.PropContext ctx) { ... }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0048.html.N13F9F">
我们可以从侦听器中复制映射功能<code class="cf methodname">exitProp</code>并将其粘贴到与规则关联的访问者方法中<code class="cf keyword">prop</code>。
</p><p>
We can copy the map functionality from <code class="cf methodname">exitProp</code> in the listener and paste
it into the visitor method associated with rule <code class="cf keyword">prop</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestPropertyFileVisitor.java">听众/TestPropertyFileVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> PropertyFileVisitor <strong class="prompt">extends</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    PropertyFileBaseVisitor&lt;<strong class="prompt">Void</strong>&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt; props = <strong class="prompt">new</strong> OrderedHashMap&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Void</strong> visitProp(PropertyFileParser.PropContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> id = ctx.ID().getText(); <em class="comment">// prop : ID '=' STRING '\n' ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> value = ctx.STRING().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        props.put(id, value);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> null; <em class="comment">// Java says must return something even when Void</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0048.html.N14005">
为了与上一节中的监听器版本进行比较，下面是访问者的接口和类之间的继承关系：
</p><p>
For comparison to the listener version in the previous section, here’s the inheritance relationship between the visitor’s interfaces and classes:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/听众/访客-hier.png">
</div>
<p id="f_0048.html.N1400D"><code class="cf class">ParseTreeVisitor</code>访问者通过在子节点上显式调用接口的
方法
来遍历解析树<code class="cf methodname">visit</code>。该方法在中实现
<code class="cf class">AbstractParseTreeVisitor</code>。在这种情况下，为调用创建的节点
<code class="cf keyword">prop</code>没有子节点，因此<code class="cf methodname">visitProp</code>
不必调用。我们将在<a href="#f_0050.html.sec.visitors"><em>使用访问者</em></a><a href="#f_0050.html.sec.visitors">遍历</a><code class="cf methodname">visit</code>中查看访问者泛型类型参数。
<a href="#f_0050.html.sec.visitors"><em></em></a></p><p>
Visitors walk parse trees by explicitly calling interface <code class="cf class">ParseTreeVisitor</code>’s
<code class="cf methodname">visit</code> method on child nodes. That method is implemented in
<code class="cf class">AbstractParseTreeVisitor</code>. In this case, the nodes created for
<code class="cf keyword">prop</code> invocations don’t have children, so <code class="cf methodname">visitProp</code>
doesn’t have to call <code class="cf methodname">visit</code>. We’ll look at visitor generic type parameters
in <a href="#f_0050.html.sec.visitors">​<em>Traversing Parse Trees with Visitors</em>​</a>.
</p>
<p id="f_0048.html.N14025">
访问者测试装置和监听器测试装置（例如
<code class="cf class">TestPropertyFile</code>）之间的最大区别在于访问者测试装置不需要
<code class="cf class">ParseTreeWalker</code>。它们只是要求访问者访问解析器创建的树。
</p><p>
The biggest difference between a visitor and listener test rig (such as
<code class="cf class">TestPropertyFile</code>) is that visitor test rigs don’t need a
<code class="cf class">ParseTreeWalker</code>. They just ask the visitor to visit the tree created by the
parser.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestPropertyFileVisitor.java">听众/TestPropertyFileVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileVisitor loader = <strong class="prompt">new</strong> PropertyFileVisitor();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​loader.visit(tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(loader.props); <em class="comment">// print results</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0048.html.N14048">
所有一切就绪后，构建和测试顺序如下：
</p><p>
With all of that in place, here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -visitor PropertyFile.g4  </strong>
<em class="comment"># create visitor as well this time</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls PropertyFile*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileBaseListener.java   PropertyFileListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileBaseVisitor.java    PropertyFileParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PropertyFileLexer.java          PropertyFileVisitor.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac TestPropertyFileVisitor.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat t.properties</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​user="parrt"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​machine="maniac"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java TestPropertyFileVisitor t.properties</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{user="parrt", machine="maniac"}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0048.html.N14086">
我们可以用访问者和监听器构建几乎任何我们想要的东西。一旦我们进入 Java 领域，就不再需要学习 ANTLR 的东西了。我们只需要知道语法、语法解析树和访问者或监听器事件方法之间的关系。除此之外，它只是代码。为了响应对输入短语的识别，我们可以生成输出、收集信息（就像我们在这里所做的那样）、以某种方式验证短语或执行计算。
</p><p>
We can build just about anything we want with visitors and listeners. Once we’re in the
Java space, there’s no more ANTLR stuff to learn. All we have to know is the relationship
between a grammar, its parse tree, and the visitor or listener event methods. Beyond that,
it’s just code. In response to recognizing input phrases, we can generate output, collect
information (as we’ve done here), validate phrases in some way, or perform computations.
</p>
<p id="f_0048.html.N1408F">
此属性文件示例足够小，因此我们没有遇到与带有备选规则相关的问题。默认情况下，无论解析器匹配哪个备选，ANTLR 都会为每个规则生成一种事件。这非常不方便，因为侦听器和访问者方法必须确定解析器匹配了哪个备选。在下一节中，我们将了解如何以更精细的粒度获取事件。
</p><p>
This property file example is small enough that we didn’t run into an issue regarding
rules with alternatives. By default, ANTLR generates a single kind of event for each rule
no matter which alternative the parser matches. That’s pretty inconvenient because the
listener and visitor methods have to figure out which alternative was matched by the
parser. In the next section, we’ll see how to get events at a finer granularity.
</p>

</div></div>
<div id="f_0049.html"><div>

<h2 id="f_0049.html.sec.labeling-alts">7.4 精确事件方法的标记规则替代方案</h2><h2>7.4 Labeling Rule Alternatives for Precise Event Methods</h2>
<p id="f_0049.html.N14097">
为了说明事件粒度问题，我们来尝试构建一个简单的计算器，其中包含以下表达式语法的监听器：
</p><p>
To illustrate the event granularity problem, let’s try to build a simple calculator with a
listener for the following expression grammar:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/Expr.g4">听众/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Expr;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​s : e ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e : e op=MULT e    <em class="comment">// MULT is '*'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | e op=ADD e     <em class="comment">// ADD is '+'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N140C8">
就目前情况而言，规则产生了一个相当无用的监听器，因为导致树遍历器
<code class="cf keyword">e</code>的所有替代方案都会触发相同的方法。
<code class="cf keyword">e</code><code class="cf methodname">enterE</code><code class="cf methodname">exitE</code></p><p>
As it stands, rule <code class="cf keyword">e</code> yields a fairly unhelpful listener because all
alternatives of <code class="cf keyword">e</code> result in a tree walker triggering the same
<code class="cf methodname">enterE</code> and <code class="cf methodname">exitE</code> methods.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> ExprListener <strong class="prompt">extends</strong> ParseTreeListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterE(ExprParser.EContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitE(ExprParser.EContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N140FD">
侦听器方法必须
<code class="cf keyword">e</code>使用<code class="cf variable">op</code>标记标签和方法来测试解析器为每个子树匹配哪个替代方案<code class="cf variable">ctx</code>。
</p><p>
The listener methods would have to test to see which alternative the parser matched for each
<code class="cf keyword">e</code> subtree using the <code class="cf variable">op</code> token label and the methods
of <code class="cf variable">ctx</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestEvaluator.java">听众/TestEvaluator.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitE(ExprParser.EContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( ctx.getChildCount()==3 ) { <em class="comment">// operations have 3 children</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> left = values.get(ctx.e(0));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> right = values.get(ctx.e(1));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( ctx.op.getType()==ExprParser.MULT ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            values.put(ctx, left * right);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">else</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            values.put(ctx, left + right);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">else</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        values.put(ctx, values.get(ctx.getChild(0))); <em class="comment">// an INT</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N1415B"><code class="cf variable">MULT</code>中引用的字段
由<code class="cf methodname">exitE</code>ANTLR 在中生成<code class="cf class">ExprParser</code>：
</p><p>
The <code class="cf variable">MULT</code> field referenced in <code class="cf methodname">exitE</code> is generated by ANTLR in <code class="cf class">ExprParser</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> ExprParser <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">int</strong> MULT=1, ADD=2, INT=3, WS=4;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N14193">
如果我们查看 class<code class="cf class">EContext</code>中的class <code class="cf class">ExprParser</code>，我们可以看到 ANTLR 将来自所有三个替代方案的所有元素打包到同一个上下文对象中。
</p><p>
If we look at class <code class="cf class">EContext</code> in class <code class="cf class">ExprParser</code>, we can see
that ANTLR packed all elements from all three alternatives into the same context object.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> EContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> Token op;                     <em class="comment">// derived from label op</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">List</strong>&lt;EContext&gt; e() { ... }    <em class="comment">// get all e subtrees</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> EContext e(<strong class="prompt">int</strong> i) { ... }     <em class="comment">// get ith e subtree</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> TerminalNode INT() { ... }    <em class="comment">// get INT node if alt 3 of e</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N141DF">
为了获得更精确的侦听器事件，ANTLR 允许我们使用运算符标记任何规则的最外层替代方案。让我们从中
<code class="cf ic">#</code>推导出语法并标记替代方案。以下是修改后的规则：
<code class="cf class">LExpr</code><code class="cf class">Expr</code><code class="cf keyword">e</code><code class="cf keyword">e</code></p><p>
To get more precise listener events, ANTLR lets us label the outermost alternatives of any
rule using the <code class="cf ic">#</code> operator. Let’s derive grammar <code class="cf class">LExpr</code> from
<code class="cf class">Expr</code> and label <code class="cf keyword">e</code>’s alternatives. Here’s the modified <code class="cf keyword">e</code> rule:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LExpr.g4">听众/LExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e : e MULT e            # Mult​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | e ADD e             # Add​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | INT                 # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N14211">
现在 ANTLR 为 的每个替代方案生成一个单独的侦听器方法
<code class="cf keyword">e</code>。因此，我们不再需要<code class="cf variable">op</code>标记标签。对于替代标签<code class="cf ic">X</code>，ANTLR 生成<code class="cf methodname">enterX</code>和
<code class="cf methodname">exitX</code>。
</p><p>
Now ANTLR generates a separate listener method for each alternative of
<code class="cf keyword">e</code>. Consequently, we don’t need the <code class="cf variable">op</code> token label
anymore. For alternative label <code class="cf ic">X</code>, ANTLR generates <code class="cf methodname">enterX</code> and
<code class="cf methodname">exitX</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> LExprListener <strong class="prompt">extends</strong> ParseTreeListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterMult(LExprParser.MultContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitMult(LExprParser.MultContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterAdd(LExprParser.AddContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitAdd(LExprParser.AddContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterInt(LExprParser.IntContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitInt(LExprParser.IntContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0049.html.N14261">
还请注意，ANTLR 会为备选方案生成特定的上下文对象（的子类
<code class="cf class">EContext</code>），并以标签命名。专用上下文对象的 getter 方法仅限于适用于相关备选方案的方法。例如，<code class="cf class">IntContext</code>  只有一种<code class="cf methodname">INT</code>
方法。我们可以要求<code class="cf ic">ctx.INT()</code>在 中<code class="cf methodname">enterInt</code>，但不能要求在 中
<code class="cf methodname">enterAdd</code>。
</p><p>
Note also that ANTLR generates specific context objects (subclasses of
<code class="cf class">EContext</code>) for the alternatives, named after the labels. The getter methods of
the specialized context objects are limited to just those applicable to the associated
alternatives. For example, <code class="cf class">IntContext</code>  has only an <code class="cf methodname">INT</code>
method. We can ask for <code class="cf ic">ctx.INT()</code> in <code class="cf methodname">enterInt</code> but not in
<code class="cf methodname">enterAdd</code>.
</p>
<p id="f_0049.html.N14279">
监听器和访问者非常棒。我们只需充实事件方法，就可以获得可重用和可重定向的语法以及封装的语言应用程序。ANTLR 甚至会自动为我们生成骨架代码。但事实证明，到目前为止，我们构建的应用程序非常简单，我们还没有遇到常见的实现问题，即事件方法有时需要传递部分结果或其他信息。
</p><p>
Listeners and visitors are great. We get reusable and retargetable grammars as well as
encapsulated language applications just by fleshing out event methods. ANTLR even
automatically generates the skeleton code for us. It turns out, though, that the
applications we’ve built so far are so simple we haven’t run into a common implementation
issue, which is that event methods sometimes need to pass around partial results or other information.
</p>

</div></div>
<div id="f_0050.html"><div>

<h2 id="f_0050.html.N1427C">7.5 在事件方法之间共享信息</h2><h2>7.5 Sharing Information Among Event Methods</h2>
<p id="f_0050.html.N14280">
无论我们是在收集信息还是计算值，传递参数和返回值往往是最方便和良好的编程习惯，而不是使用字段或其他“全局变量”。问题是 ANTLR 会自动生成侦听器方法的签名，而不包含特定于应用程序的返回值或参数。ANTLR 还会生成访问者方法，而不包含特定于应用程序的参数。
</p><p>
Whether we’re collecting information or computing values, it’s often most convenient and
good programming practice to pass around arguments and return values, rather than using
fields or other “global variables.” The problem is that ANTLR automatically generates
the signature of the listener methods without application-specific return values or
arguments. ANTLR also generates visitor methods without application-specific arguments.
</p>
<p id="f_0050.html.N14289">
在本节中，我们将探索允许事件方法传递数据而不改变事件方法签名的机制。我们将根据<code class="cf class">LExpr</code>上一节中的表达式语法构建同一个简单计算器的三种不同实现。第一种实现使用访问者方法返回值，第二种实现定义事件方法之间共享的字段，第三种实现注释解析树节点以存储感兴趣的值。
</p><p>
In this section, we’re going to explore mechanisms that let event methods pass data around
without altering the event method signatures. We’ll build three different implementations
of the same simple calculator based upon the <code class="cf class">LExpr</code> expression grammar from
the previous section. The first implementation uses visitor method return values, the
second defines a field shared among event methods, and the third annotates parse tree
nodes to squirrel away values of interest.
</p>
<h3 id="f_0050.html.sec.visitors">使用访问者遍历解析树</h3><h3>Traversing Parse Trees with Visitors</h3>
<p id="f_0050.html.N14294">
要构建基于访问者的计算器，最简单的方法是让与规则关联的事件方法<code class="cf keyword">expr</code>返回子表达式值。例如，
<code class="cf methodname">visitAdd</code>将返回两个子表达式相加的结果。
<code class="cf methodname">visitInt</code>将返回整数的值。常规访问者不会为其访问方法指定返回值。当我们为特定应用程序的需求实现一个类时，添加返回类型很容易，扩展
<code class="cf class">LExprBaseVisitor&lt;T&gt;</code>并提供<code class="cf class">Integer</code>类型
<code class="cf ic">&lt;T&gt;</code>参数。我们的访问者如下所示：
</p><p>
To build a visitor-based calculator, the easiest approach is to have the event methods
associated with rule <code class="cf keyword">expr</code> return subexpression values. For example,
<code class="cf methodname">visitAdd</code> would return the result of adding two subexpressions.
<code class="cf methodname">visitInt</code> would return the value of the integer. Conventional visitors don’t
specify return values for their visit methods. Adding a return type is easy when we
implement a class for our specific application’s needs, extending
<code class="cf class">LExprBaseVisitor&lt;T&gt;</code> and supplying <code class="cf class">Integer</code> as the
<code class="cf ic">&lt;T&gt;</code> type parameter. Here’s what our visitor looks like:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvalVisitor.java">听众/TestLEvalVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> EvalVisitor <strong class="prompt">extends</strong> LExprBaseVisitor&lt;<strong class="prompt">Integer</strong>&gt; {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitMult(LExprParser.MultContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> visit(ctx.e(0)) * visit(ctx.e(1));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitAdd(LExprParser.AddContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> visit(ctx.e(0)) + visit(ctx.e(1));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitInt(LExprParser.IntContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> <strong class="prompt">Integer</strong>.valueOf(ctx.INT().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N1430A">
<code class="cf class">EvalVisitor</code><code class="cf methodname">visit</code>从 ANTLR 的类继承通用
方法<code class="cf class">AbstractParseTreeVisitor</code>，我们的访问者使用该方法简洁地触发子树访问。
</p><p>
<code class="cf class">EvalVisitor</code> inherits the general
<code class="cf methodname">visit</code> method from ANTLR’s <code class="cf class">AbstractParseTreeVisitor</code> class,
which our visitor uses to concisely trigger subtree visits.
</p>
<p id="f_0050.html.N14319">
请注意，<code class="cf class">EvalVisitor</code>规则没有访问者方法
<code class="cf keyword">s</code>。 的默认实现<code class="cf methodname">visitS</code>调用
<code class="cf class">LExprBaseVisitor</code>预定义方法<code class="cf class">ParseTreeVisitor</code>。。返回访问最后一个子节点返回的值。在本例中，<code class="cf methodname">visitChildren</code>返回
访问其唯一子节点（节点）返回的表达式的值。我们可以使用此默认行为。
<code class="cf methodname">visitChildren</code><code class="cf methodname">visitS</code><code class="cf keyword">e</code></p><p>
Notice that <code class="cf class">EvalVisitor</code> doesn’t have a visitor method for rule
<code class="cf keyword">s</code>. The default implementation of <code class="cf methodname">visitS</code> in
<code class="cf class">LExprBaseVisitor</code> calls predefined method <code class="cf class">ParseTreeVisitor</code>.<code class="cf methodname">visitChildren</code>.
<code class="cf methodname">visitChildren</code> returns the value returned from the visit of the last child.
In this case, <code class="cf methodname">visitS</code> returns the value of the expression returned from
visiting its only child (the <code class="cf keyword">e</code> node). We can use this default behavior.
</p>
<p id="f_0050.html.N14337">
在测试装置中<code class="cf filename">TestLEvalVisitor.java</code>，我们有常用的代码来启动
<code class="cf class">LExprParser</code>和打印解析树。然后我们需要代码来启动
<code class="cf class">EvalVisitor</code>并打印出访问树时计算出的表达式值。
</p><p>
In test rig <code class="cf filename">TestLEvalVisitor.java</code>, we have the usual code to launch
<code class="cf class">LExprParser</code> and print the parse tree. Then we need code to launch
<code class="cf class">EvalVisitor</code> and print out the expression value computed while visiting the
tree.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvalVisitor.java">听众/TestLEvalVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EvalVisitor evalVisitor = <strong class="prompt">new</strong> EvalVisitor();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> result = evalVisitor.visit(tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(<em class="string">"visitor result = "</em>+result);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14360">
为了构建我们的计算器，我们告诉 ANTLR 生成访问者，使用选项
<code class="cf commandoption">-visitor</code>，就像我们之前对属性文件语法所做的那样。（如果我们不再想生成侦听器，我们也使用选项
<code class="cf commandoption">-no-listener</code>。）以下是完整的构建和测试序列：
</p><p>
To build our calculator, we tell ANTLR to generate the visitor, using the
<code class="cf commandoption">-visitor</code> option as we did for the property file grammar
earlier. (If we no longer want to generate a listener, we also use option
<code class="cf commandoption">-no-listener</code>.) Here’s the complete build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -visitor LExpr.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac LExpr*.java TestLEvalVisitor.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestLEvalVisitor</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">1+2*3</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(s (e (e 1) + (e (e 2) * (e 3))))​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​visitor result = 7​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14397">
如果我们需要特定于应用程序的返回值，那么访问者方法就非常适用，因为我们可以使用内置的 Java 返回值机制。如果我们不想显式调用访问者方法来访问子级，我们可以切换到侦听器机制。不幸的是，这意味着放弃使用 Java 方法返回值的整洁性。
</p><p>
Visitors work very well if we need application-specific return values because we get to
use the built-in Java return value mechanism. If we prefer not having to explicitly invoke
visitor methods to visit children, we can switch to the listener mechanism. Unfortunately,
that means giving up the cleanliness of using Java method return values.
</p>
<h3>使用堆栈模拟返回值</h3><h3>Simulating Return Values with a Stack</h3>
<p id="f_0050.html.N143A1">
ANTLR 生成不返回任何值（<code class="cf keyword">void</code>返回类型）的侦听器事件方法。要将值返回到在解析树中较高节点上执行的侦听器方法，我们可以将部分结果存储在侦听器的字段中。我想到了一个值堆栈，就像 Java 运行时使用 CPU 堆栈临时存储方法返回值一样。这个想法是将计算子表达式的结果推送到堆栈上。解析树上层子表达式的方法将操作数从堆栈中弹出。这是完整的
<code class="cf class">Evaluator</code>计算器侦听器（物理上位于文件中
<code class="cf filename">TestLEvaluator.java</code>）：
</p><p>
ANTLR generates listener event methods that return no values (<code class="cf keyword">void</code> return
types). To return values to listener methods executing on nodes higher in the parse
tree, we can store partial results in a field of our listener. A stack of values comes to
mind, just as the Java runtime uses the CPU stack to store method return values temporarily.
The idea is to push the result of computing a subexpression onto the stack. Methods for
subexpressions further up the parse tree pop operands off the stack. Here’s the full
<code class="cf class">Evaluator</code> calculator listener (physically in file
<code class="cf filename">TestLEvaluator.java</code>):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluator.java">听众/TestLEvaluator.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> Evaluator <strong class="prompt">extends</strong> LExprBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Stack</strong>&lt;<strong class="prompt">Integer</strong>&gt; stack = <strong class="prompt">new</strong> <strong class="prompt">Stack</strong>&lt;<strong class="prompt">Integer</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitMult(LExprParser.MultContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> right = stack.pop();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> left = stack.pop();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        stack.push( left * right );​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitAdd(LExprParser.AddContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> right = stack.pop();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> left = stack.pop();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        stack.push(left + right);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitInt(LExprParser.IntContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        stack.push( <strong class="prompt">Integer</strong>.valueOf(ctx.INT().getText()) );​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14431">
为了尝试这一点，我们可以创建并使用<code class="cf class">ParseTreeWalker</code>测试装置
，按照
本章前面
<code class="cf class">TestLEvaluator</code>所做的操作。<code class="cf class">TestPropertyFile</code></p><p>
To try this, we can create and use a <code class="cf class">ParseTreeWalker</code> in test rig
<code class="cf class">TestLEvaluator</code>, following what we did in <code class="cf class">TestPropertyFile</code>
earlier in this chapter.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 LExpr.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac LExpr*.java TestLEvaluator.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestLEvaluator</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">1+2*3</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(s (e (e 1) + (e (e 2) * (e 3))))​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stack result = 7​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14465">
使用堆栈字段有点麻烦，但效果很好。我们必须确保事件方法在侦听器事件中以正确的顺序推送和弹出内容。具有返回值的访问者消除了堆栈的麻烦，但需要我们手动访问树的节点。第三个选项是通过将部分结果存储在树节点中来捕获它们。
</p><p>
Using a stack field is a bit awkward but works fine. We have to make sure that the event
methods push and pop things in the correct order across listener events. Visitors with
return values do away with the awkwardness of the stack but require that we manually visit
the nodes of the tree. The third option is to capture partial results by stashing them in
tree nodes.
</p>
<h3>注释解析树</h3><h3>Annotating Parse Trees</h3>
<p id="f_0050.html.N1446F">
我们可以将这些值存储在解析树本身中，而不是使用临时存储在事件方法之间共享数据。我们可以将这种树注释方法与侦听器和访问者一起使用，但我们将在此演示如何使用侦听器工作。让我们首先查看带部分结果注释<code class="cf class">LExpr</code>的语法解析树（图 8，1 <a href="#f_0050.html.fig.listeners.123"><em>+2*3</em></a><a href="#f_0050.html.fig.listeners.123">的</a><a href="#f_0050.html.fig.listeners.123">）</a> 。
<code class="cf ic">1+2*3</code><a href="#f_0050.html.fig.listeners.123"><em></em></a></p><p>
Instead of using temporary storage to share data between event methods, we can store those
values in the parse tree itself. We can use this tree annotation approach with both a
listener and a visitor, but we’ll demonstrate how it works using a listener here. Let’s start
by looking at the <code class="cf class">LExpr</code> grammar parse tree for <code class="cf ic">1+2*3</code> annotated with
  partial results (Figure 8, <a href="#f_0050.html.fig.listeners.123">​<em>The LExpr grammar parse tree for 1+2*3</em>​</a>).
</p>
<div class="figure" id="f_0050.html.fig.listeners.123">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/听众/123.png">
</div>
<div class="figurecaption">
<hr>图 8.<code class="cf class">LExpr</code>语法分析树<code class="cf ic">1+2*3</code>
</div>
</div>
<p id="f_0050.html.N1449C">
每个子表达式对应一个子树根（以及一个<code class="cf keyword">e</code>规则调用）。从节点发出的水平右箭头指向的数字
<code class="cf keyword">e</code>是我们想要“返回”的部分结果。
</p><p>
Each subexpression corresponds to a subtree root (and to an <code class="cf keyword">e</code> rule
invocation). The numbers pointed at by horizontal right arrows emanating from
<code class="cf keyword">e</code> nodes are the partial results we’d like to “return.”
</p>
<div class="sidebar">
<div class="sidebar-title">通过规则参数和返回值向节点添加字段</div>
<div class="sidebar-content">
<p id="f_0050.html.N144A9">
如果我们不关心将语法与特定语言绑定，我们可以简单地向感兴趣的规则规范添加返回值。
	</p><p>
If we didn’t care about tying our grammar to a particular language, we could simply add a
return value to the rule specification of interest.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e <strong class="prompt">returns</strong> [int value]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  : e <em class="string">'*'</em> e             # Mult​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | e <em class="string">'+'</em> e             # Add​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | INT                 # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N144D2">
	ANTLR 将规则的所有参数和返回值放入相关的上下文对象中，因此<code class="cf variable">value</code>最终成为一个字段<code class="cf class">EContext</code>。
	</p><p>
	ANTLR places all parameters and return values of rules into the associated context object and so <code class="cf variable">value</code> ends up as a field of <code class="cf class">EContext</code>.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> EContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">int</strong> value;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14501">
	由于特定于替代方案的上下文源自<code class="cf class">EContext</code>，因此所有侦听器方法都可以访问此值。例如，侦听器方法可以说
<code class="cf ic">ctx.value = 0;</code>。
	</p><p>
	Because the alternative-specific context is derived from <code class="cf class">EContext</code>, all
listener methods have access to this value. For example, listener methods could say
<code class="cf ic">ctx.value = 0;</code>.
	</p>
<p id="f_0050.html.N1450A">
这里展示的方法涉及指定规则方法生成结果值，该结果值存储在规则的上下文对象中。该规范使用目标语言语法，因此将语法与特定目标语言联系起来。但是，该方法不一定将语法与特定应用程序联系起来，假设其他应用程序可以使用相同的规则结果值。另一方面，如果我们需要多个返回值或不同应用程序的不同类型的返回值，这种方法就行不通了。
	</p><p>
The approach shown here involves specifying that a rule method produces a result value,
which is stored in the rule’s context object. The specification uses target language syntax
and consequently ties the grammar to a particular target language. However, the approach
doesn’t necessarily tie the grammar to a particular application, assuming that other
applications can use the same rule result values. On the other hand, if we need more than
one return value or a return value of a different type for a different application, this
approach would not work.
	</p>
</div>
</div>
<p id="f_0050.html.N1450D">
让我们看看节点注释策略如何适用于<code class="cf keyword">e</code>我们的
<code class="cf class">LExpr</code>语法规则。
</p><p>
Let’s see how the node annotation strategy would work for rule <code class="cf keyword">e</code> from our
<code class="cf class">LExpr</code> grammar.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LExpr.g4">听众/LExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e : e MULT e            # Mult​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | e ADD e             # Add​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | INT                 # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N1452C">
备选方案的侦听器方法<code class="cf keyword">e</code>会分别将结果存储在相应的<code class="cf keyword">e</code>解析树节点中。解析树中较高节点上的任何后续加法或乘法事件都会通过查看存储在其相应子节点中的值来获取子表达式值。
</p><p>
The listener methods for the alternatives of <code class="cf keyword">e</code> would each store a result
in the corresponding <code class="cf keyword">e</code> parse-tree node. Any subsequent add or multiply
events on nodes higher up in the parse tree would grab subexpression values by looking at
the values stored in their corresponding children.
</p>
<p id="f_0050.html.N14535">
如果我们暂时假设每个解析树节点（每个规则上下文对象）都有一个名为的字段<code class="cf variable">value</code>，那么<code class="cf methodname">exitAdd</code>看起来会像这样：
</p><p>
If we assume, for the moment, that each parse-tree node (each rule context object) has a
field called <code class="cf variable">value</code>, then <code class="cf methodname">exitAdd</code> would look like
this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitAdd(LExprParser.AddContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// e(0).value is the subexpression value of the first e in the alternative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ctx.value = ctx.e(0).value + ctx.e(1).value; <em class="comment">// e '+' e # Add</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N1455C">
这看起来非常合理，但不幸的是，我们无法扩展类
<code class="cf class">ExprContext</code>以<code class="cf variable">value</code>在 Java 中动态添加字段（Ruby 和 Python 可以做到）。为了使解析树注释工作，我们需要一种方法来注释各种节点，而无需手动更改由 ANTLR 生成的相关节点类。（否则，ANTLR 会在下次生成代码时覆盖我们的更改。）
</p><p>
That looks pretty reasonable, but unfortunately, we can’t extend class
<code class="cf class">ExprContext</code> to add field <code class="cf variable">value</code> dynamically in Java (like
Ruby and Python can). To make parse-tree annotation work, we need a way to annotate the
various nodes without manually altering the associated node classes generated by ANTLR.
(Otherwise, ANTLR would overwrite our changes the next time it generated code.)
</p>
<p id="f_0050.html.N14565">
注释解析树节点的最简单方法是使用<code class="cf class">Map</code>将任意值与节点关联的。为此，ANTLR 提供了一个名为的简单辅助类
<code class="cf class">ParseTreeProperty</code>。让我们构建另一个计算器版本，名为
<code class="cf class">EvaluatorWithProps</code>in file ，它使用实例将部分结果与解析树节点
<code class="cf filename">TestLEvaluatorWithProps.java</code>
关联起来。这是我们监听器开头的相应定义：
<code class="cf class">LExpr</code><code class="cf class">ParseTreeProperty</code></p><p>
The easiest way to annotate parse-tree nodes is to use a <code class="cf class">Map</code> that associates
arbitrary values with nodes. For that reason, ANTLR provides a simple helper class called
<code class="cf class">ParseTreeProperty</code>. Let’s build another calculator version called
<code class="cf class">EvaluatorWithProps</code> in file <code class="cf filename">TestLEvaluatorWithProps.java</code>
that associates partial results with <code class="cf class">LExpr</code> parse-tree nodes using a
<code class="cf class">ParseTreeProperty</code> instance. Here’s the appropriate definition at the start of our listener:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> EvaluatorWithProps <strong class="prompt">extends</strong> LExprBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ParseTreeProperty&lt;<strong class="prompt">Integer</strong>&gt; values = <strong class="prompt">new</strong> ParseTreeProperty&lt;<strong class="prompt">Integer</strong>&gt;();​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N145A7">
注意：如果你想使用自己的类型字段
<code class="cf class">Map</code>而不是<code class="cf class">ParseTreeProperty</code>，请确保从派生它<code class="cf class">IdentityHashMap</code>，而不是通常的<code class="cf class">HashMap</code>。我们需要注释特定节点，通过身份而不是进行测试<code class="cf methodname">equals</code>。两个
<code class="cf keyword">e</code>节点可能是<code class="cf methodname">equals</code>但不是内存中的同一物理节点。
</p><p>
Caution: If you want to use your own field of type
<code class="cf class">Map</code> instead of <code class="cf class">ParseTreeProperty</code>, make sure to derive it
from <code class="cf class">IdentityHashMap</code>, not the usual <code class="cf class">HashMap</code>. We need to
annotate specific nodes, testing by identity instead of <code class="cf methodname">equals</code>. Two
<code class="cf keyword">e</code> nodes might be <code class="cf methodname">equals</code> but not the same physical node
in memory.
</p>
<p id="f_0050.html.N145BF">
要注释一个节点，我们说<code class="cf ic">values.put(node, value)</code>。要获取与节点关联的值，我们说<code class="cf ic">values.get(node)</code>。这没问题，但让我们创建一些名称明显的辅助方法，使代码更易于阅读。
</p><p>
To annotate a node, we say <code class="cf ic">values.put(node, value)</code>. To get a value associated
with a node, we say <code class="cf ic">values.get(node)</code>. This is OK, but let’s create some helper
methods with obvious names to make the code easier to read.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> setValue(ParseTree node, <strong class="prompt">int</strong> value) { values.put(node, value); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">int</strong> getValue(ParseTree node) { <strong class="prompt">return</strong> values.get(node); }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N145E8">
让我们用最简单的表达式替代方案来启动侦听器方法
<code class="cf keyword">Int</code>。我们希望<code class="cf keyword">e</code>用其匹配的标记的整数值来注释其解析树节点<code class="cf keyword">INT</code>。
</p><p>
Let’s start the listener methods with the simplest expression alternative,
<code class="cf keyword">Int</code>. We want to annotate its parse-tree <code class="cf keyword">e</code> node with
the integer value of the <code class="cf keyword">INT</code> token it matches.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitInt(LExprParser.IntContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> intText = ctx.INT().getText(); <em class="comment">// INT   # Int</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setValue(ctx, <strong class="prompt">Integer</strong>.valueOf(intText));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14617">
对于加法子树，我们获取两个子表达式子项（操作数）的值，并用和来注释子树根。
</p><p>
For addition subtrees, we get the value of the two subexpression children (operands) and
annotate the subtree root with the sum.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitAdd(LExprParser.AddContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> left = getValue(ctx.e(0)); <em class="comment">// e '+' e   # Add</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> right = getValue(ctx.e(1));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setValue(ctx, left + right);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N14640">
方法<code class="cf methodname">exitMult</code>相同，只是计算使用乘法而不是加法。
</p><p>
Method <code class="cf methodname">exitMult</code> is the same except that the calculation uses multiply
instead of add.
</p>
<p id="f_0050.html.N14646">
我们的测试装置从规则 开始解析<code class="cf keyword">s</code>，因此我们必须确保解析树根具有<code class="cf keyword">e</code>子树的值。（或者，我们可以从 开始解析，<code class="cf keyword">e</code>而不是<code class="cf keyword">s</code>。）为了将值从<code class="cf keyword">e</code>节点冒泡到根节点<code class="cf keyword">s</code>，我们实现了
<code class="cf methodname">exitS</code>。
</p><p>
Our test rig starts parsing at rule <code class="cf keyword">s</code>, so we have to make sure that the
parse-tree root has the value of the <code class="cf keyword">e</code> subtree. (Or, we could start
parsing at <code class="cf keyword">e</code> instead of <code class="cf keyword">s</code>.) To bubble up the value
from the <code class="cf keyword">e</code> node to the root <code class="cf keyword">s</code> node, we implement
<code class="cf methodname">exitS</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Need to pass e's value out of rule s : e ; */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitS(LExprParser.SContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setValue(ctx, getValue(ctx.e())); <em class="comment">// like: int s() { return e(); }</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N1467C">
下面展示了如何启动监听器并从解析树根节点打印出表达式的值：
</p><p>
Here’s how to launch the listener and print out the expression value from the parse-tree root node:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/TestLEvaluatorWithProps.java">听众/TestLEvaluatorWithProps.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EvaluatorWithProps evalProp = <strong class="prompt">new</strong> EvaluatorWithProps();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(evalProp, tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(<em class="string">"properties result = "</em> +evalProp.getValue(tree));​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N146A0">
以下是构建和测试顺序：
</p><p>
And here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 LExpr.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac LExpr*.java TestLEvaluatorWithProps.java </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestLEvaluatorWithProps</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">1+2*3</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(s (e (e 1) + (e (e 2) * (e 3))))​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​properties result = 7​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0050.html.N146CB">
现在我们已经了解了同一种计算器的三种实现，我们几乎准备好将我们的知识用于构建真实示例。由于每种方法都有其优点和缺点，让我们回顾一下我们在本章中迄今为止学到的知识并比较不同的技术。
</p><p>
Now we’ve seen three implementations of the same calculator, and we’re almost ready
to put our knowledge to use building real examples. Because each approach has its strengths
and weaknesses, let’s review what we’ve learned so far in this chapter and compare the
different techniques.
</p>
<h3>比较信息共享方法</h3><h3>Comparing Information Sharing Approaches</h3>
<p id="f_0050.html.N146DB">
为了获得可重用和可重新定位的语法，我们需要让它们完全摆脱用户定义的操作。这意味着将所有特定于应用程序的代码放入语法外部的某种侦听器或访问者中。侦听器和访问者对解析树进行操作，ANTLR 会自动生成适当的树遍历接口和默认实现。由于事件方法签名是固定的，而不是特定于应用程序的，我们研究了事件方法可以共享信息的三种方式。
</p><p>
To get reusable and retargetable grammars, we need to keep them completely clear of
user-defined actions. This means putting all of the application-specific code into some
kind of listener or visitor external to the grammar. Listeners and visitors operate on
parse trees, and ANTLR automatically generates appropriate tree-walking interfaces and
default implementations. Since the event method signatures are fixed and not application
specific, we looked at three ways event methods can share information.
</p>
<ul>
<li>
<p id="f_0050.html.N146E1">
<span class="emph">本机 Java 调用堆栈</span>：访问者方法返回用户定义类型的值。如果访问者需要传递参数，还必须使用以下两种技术之一。</p>
</li><li>
<p>
<span class="emph">Native Java call stack</span>: Visitor methods return a value of user-defined type.  If a visitor needs to pass parameters, it must also use one of the next two techniques.</p>
</li>
<li>
<p id="f_0050.html.N146E7">
<span class="emph">基于堆栈</span>：堆栈字段模拟类似 Java 调用堆栈的参数和返回值。</p>
</li><li>
<p>
<span class="emph">Stack-based</span>: A stack field simulates parameters and  return values like the Java call stack.</p>
</li>
<li>
<p id="f_0050.html.N146ED">
<span class="emph">注释器</span>：地图字段使用有用的值注释节点。</p>
</li><li>
<p>
<span class="emph">Annotator</span>: A map field annotates nodes with useful values.</p>
</li>
</ul>
<p id="f_0050.html.N146F2">
这三种方法都与语法本身完全脱钩，并很好地封装在专用对象中。除此之外，每种方法都有优点和缺点。我们问题的需求和个人品味决定了采用哪种方法。即使在同一个应用程序中，我们也没有理由不能使用多种解决方案。
</p><p>
All three are completely decoupled from the grammar itself and nicely encapsulated in
specialized objects. Beyond that, there are advantages and disadvantages to each. The needs
of our problem and personal taste dictate which approach to take. There’s also no reason
that we can’t use a variety of solutions even within the same application.
</p>
<p id="f_0050.html.N146F5">
访问者方法读起来很顺畅，因为它们直接调用其他访问者方法来获取部分结果，并且可以像任何其他方法一样返回值。但这也是它们的缺点。访问者方法必须明确访问其子方法，而监听器则不需要。由于访问者具有通用接口，因此它不能定义参数。访问者必须使用其他解决方案之一将参数传递给它在子方法上调用的访问者方法。访问者的空间效率很高，因为它一次只需保留几个部分结果。树遍历之后不会有任何部分结果残留。虽然访问者方法可以返回值，但与其他解决方案不同，每个值必须是同一类型。
</p><p>
Visitor methods read nicely because they directly call other visitor methods to get
partial results and can return values like any other method. That is also their negative.
The visitor methods must explicitly visit their children, whereas the listeners do not.
Because the visitor has a general interface, it can’t define arguments. Visitors must use
one of the other solutions to pass arguments to visitor methods it calls on children. A
visitor’s space efficiency is good because it  has to keep around only a few partial
results at any one time. There are no partial results hanging around after the tree walk.
While visitor methods can return values, each value must be of the same type, unlike the
other solutions.
</p>
<p id="f_0050.html.N146F8">
基于堆栈的解决方案可以使用堆栈模拟参数和返回值，但手动管理堆栈时可能会出现断开连接的情况。发生这种情况的原因是侦听器方法不会直接相互调用。作为程序员，我们必须确保我们推送的内容在将来的事件方法调用中被适当弹出。堆栈可以传递多个值和多个返回值。基于堆栈的解决方案还节省空间，因为它不会将任何东西附加到树上。所有部分结果存储在树遍历后都会消失。
</p><p>
The stack-based solution can simulate arguments and return values with a stack, but
there’s a chance of a disconnect when manually managing the stack. This can occur because
the listener methods aren’t calling each other directly. As programmers, we have to make
sure that what we push is appropriately popped off by future event method calls. The stack
can pass multiple values and multiple return values. The stack-based solution is also
space efficient because it does not attach anything to the tree. All partial results
storage goes away after the tree walk.
</p>
<p id="f_0050.html.N146FB">
注释器是我的默认解决方案，因为它允许我任意向在解析树的上方和下方节点上运行的事件方法提供信息。我可以传递多个值，它们可以是任意类型。在许多情况下，注释比使用带有短暂值的堆栈更好。各种方法的数据传递期望之间出现脱节的可能性较小。用注释树<code class="cf ic">setValue(ctx,
value)</code>不如<code class="cf ic">return value</code>用编程语言说的直观，但更通用。这种方法与其他两种方法相比的唯一缺点是，部分结果在树遍历期间保留，因此占用的内存更大。
</p><p>
The annotator is my default solution because it allows me to arbitrarily provide information
to event methods operating on nodes above and below in the parse tree. I can pass multiple
values around, and they can be of arbitrary types. Annotation is better than using a stack
with fleeting values in many cases. There is less chance of a disconnect between the data-passing expectations of the various methods. Annotating the tree with <code class="cf ic">setValue(ctx,
value)</code> is less intuitive than saying <code class="cf ic">return value</code> in a programming language
but is more general. The only disadvantage of this approach over the other two is that the
partial results are kept around during the tree walk and so it has a larger memory
footprint.
</p>
<p id="f_0050.html.N14704">
另一方面，在某些应用中，能够注释树正是我们所需要的，例如第 8.4 节“<a href="#f_0055.html.sec.validating">验证<em>程序符号使用情况”</em>。</a>该应用需要多次遍历树，第一次遍历计算并将数据储存在树中很方便。当解析树遍历器重新遍历树时，第二次遍历可以轻松访问数据。总而言之，树注释非常灵活，并且内存负担可接受。
</p><p>
On the other hand, being able to annotate the tree is precisely what we need in some
applications, such as Section 8.4, <a href="#f_0055.html.sec.validating">​<em>Validating Program Symbol Usage</em>​</a>. That application requires multiple
passes over the tree, and it’s convenient for the first pass to compute and squirrel away
data in the tree. The second pass then has easy access to the data as the parse-tree
walker rewalks the tree. All in all, tree annotation is extremely flexible and has an
acceptable memory burden.
</p>
<p id="f_0050.html.N1470D">
现在我们已经知道如何使用解析树监听器和访问者实现一些基本的语言应用程序，是时候基于这些技术构建一些真正的工具了。这正是我们在下一章中要做的。
</p><p>
Now that we know how to implement some basic language applications using parse-tree
listeners and visitors, it’s time to build some real tools based upon these techniques.
That’s exactly what we’ll do in the next chapter.
</p>

<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0051.html"><div>

<h1 class="chapter-title" id="f_0051.html.chp.listener-examples">
<span class="chapter-number">
	      第八章</span>
<br><br>
<span class="chapter-name">构建一些真正的语言应用程序</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      8</span>
<br><br>
<span class="chapter-name">Building Some Real Language Applications</span>
</h1>

<p id="f_0051.html.N1471C">
现在我们知道了如何通过监听器和访问者触发应用程序代码，是时候构建一些有用的应用程序了。我们将根据第 6 章“<a href="#f_0039.html.chp.examples">探索<em>一些真实语法”</em>中的 CSV、JSON 和 Cymbol 语法构建四个复杂性不断增加的监听器。</a> （我们可以轻松地使用访问者。）
</p><p>
Now that we know how to trigger application code via listeners and visitors, it’s time to
build some useful applications. We’ll construct four listeners of increasing complexity
based upon the CSV, JSON, and Cymbol grammars from Chapter 6, <a href="#f_0039.html.chp.examples">​<em>Exploring Some Real Grammars</em>​</a>. (We
could just as easily use visitors.)
</p>
<p id="f_0051.html.N14722">
第一个实际应用程序是构建二维列表数据结构的 CSV 文件加载器。然后，我们将弄清楚如何将 JSON 文本文件转换为 XML 文本文件。接下来，我们将读取 Cymbol 程序并使用 DOT/graphviz 可视化函数调用依赖关系图。最后，我们将为 Cymbol 程序构建一个真正的符号表，用于检查未定义的变量或函数并验证变量和函数是否正确使用。检查器需要多次遍历解析树，因此，演示了如何在一次遍历中收集信息并在下一次遍历中使用它。
</p><p>
The first real application is a loader for CSV files that constructs a two-dimensional
list data structure. Then, we’ll figure out how to translate JSON text files into XML text
files. Next, we’ll read in Cymbol programs and visualize the function call dependency
graph using DOT/graphviz. Finally, we’ll build a real symbol table for Cymbol programs
that checks for undefined variables or functions and verifies that variables and functions
are used properly. The checker needs to make multiple passes over the parse tree and,
therefore, demonstrates how to collect information in one pass and use it in the next.
</p>
<p id="f_0051.html.N14725">
让我们从最简单的应用程序开始。
</p><p>
Let’s get started with the simplest application.
</p>

</div></div>
<div id="f_0052.html"><div>

<h2 id="f_0052.html.N14728">8.1 加载 CSV 数据</h2><h2>8.1 Loading CSV Data</h2>
<p id="f_0052.html.N1472C">
我们的目标是构建一个监听器，将逗号分隔值 (CSV) 数据加载到一个漂亮的“映射列表”数据结构中。这是任何数据格式读取器甚至配置文件读取器都会做的事情。我们将把每行的字段收集到一个将标题名称与值关联的映射中。因此，给定以下输入：
</p><p>
Our goal is to build a listener that loads comma-separated-value (CSV) data into a nice
“list of maps” data structure. This is the kind of thing that any data format reader or
even a configuration file reader would do. We’ll collect the fields of each row into a map
that associates a header name with a value. So, given the following input:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/t.csv">听众/t.csv</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Details,Month,Amount​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Mid Bonus,June,"$2,000"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​,January,"""zippo"""​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Total Bonuses,"","$5,000"​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14754">
我们希望打印出以下地图列表：
</p><p>
we’d like to see the following list of maps printed out:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[{Details=Mid Bonus, Month=June, Amount="$2,000"},​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ {Details=, Month=January, Amount="""zippo"""},​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ {Details=Total Bonuses, Month="", Amount="$5,000"}]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14769"><a href="#f_0040.html.sec.CSV">为了在我们的监听器中获得精确的方法，让我们根据第 6.1 节“解析</a><a href="#f_0040.html.sec.CSV"><em>逗号分隔值”</em></a><code class="cf keyword">field</code>中构建的 CSV 语法规则
标记每个替代方案。
<a href="#f_0040.html.sec.CSV"><em></em></a></p><p>
To get precise methods within our listener, let’s label each of the alternatives in rule <code class="cf keyword">field</code> from the CSV grammar we built in Section 6.1, <a href="#f_0040.html.sec.CSV">​<em>Parsing Comma-Separated Values</em>​</a>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CSV.g4">听众/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> CSV;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : hdr row+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​hdr : row ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row : field (<em class="string">','</em> field)* <em class="string">'\r'</em>? <em class="string">'\n'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   TEXT    # text​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   STRING  # string​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |           # empty​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT : ~[,\n\r<em class="string">"]+ ;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="string">STRING : '"' ('""'|~'"')* '"' ;</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N147BD">
除此之外，CSV 语法与以前相同。 
</p><p>
Other than that, the CSV grammar is the same as before. 
</p>
<p id="f_0052.html.N147C0">
我们可以通过定义所需的数据结构来开始实现我们的监听器。首先，我们需要主要的数据结构，即名为 的映射列表
<code class="cf variable">rows</code>。我们还需要一个在标题行中找到的列名列表，<code class="cf variable">header</code>。要处理一行，我们将字段值读入临时列表，<code class="cf variable">currentRowFieldValues</code>，然后在完成每一行时将列名映射到这些值。</p><p>
We can start the implementation of our listener by defining the data structures we’ll
need. First, we need the main data structure, a list of maps called
<code class="cf variable">rows</code>. We also need a list of the column names found in the header
row, <code class="cf variable">header</code>. To process a row, we’ll read the field values into a
temporary list, <code class="cf variable">currentRowFieldValues</code>, and then map the column names
to those values as we finish each row. </p>
<p id="f_0052.html.N147CC">以下是我们的监听器的开始：
</p><p>Here is the start of our listener:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> Loader <strong class="prompt">extends</strong> CSVBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">String</strong> EMPTY = <em class="string">""</em>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Load a list of row maps that map field name to value */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">List</strong>&lt;<strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt;&gt; rows = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;<strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** List of column names */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">List</strong>&lt;<strong class="prompt">String</strong>&gt; header;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Build up a list of fields in current row */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">List</strong>&lt;<strong class="prompt">String</strong>&gt; currentRowFieldValues;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14838">
以下三种规则方法通过计算适当的字符串并将其添加到来处理字段值<code class="cf variable">currentRowFieldValues</code>：
</p><p>
The following three rule methods process field values by computing the appropriate string
and adding it to the <code class="cf variable">currentRowFieldValues</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitString(CSVParser.StringContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentRowFieldValues.add(ctx.STRING().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitText(CSVParser.TextContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentRowFieldValues.add(ctx.TEXT().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitEmpty(CSVParser.EmptyContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentRowFieldValues.add(EMPTY);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14879">
在处理行之前，我们需要从第一行获取列名列表。标题行在语法上只是另一行，但我们需要将其与常规数据行区别对待。这意味着我们需要检查上下文。现在，我们假设执行后
<code class="cf methodname">exitRow</code>包含<code class="cf variable">currentRowFieldValues</code>列名列表。要填写<code class="cf variable">header</code>，我们只需捕获第一行的字段值。
</p><p>
Before we can process the rows, we need to get the list of column names from the first row.
The header row is just another row syntactically, but we need to treat it differently than a
regular row of data. That means we need to check context. For now, let’s assume that after
<code class="cf methodname">exitRow</code> executes, <code class="cf variable">currentRowFieldValues</code> contains a
list of the column names. To fill in <code class="cf variable">header</code>, we just have to capture
the field values of that first row.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitHdr(CSVParser.HdrContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    header = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;<strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    header.addAll(currentRowFieldValues);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N148A9">
谈到行本身，我们需要两个操作：一个是开始一行时，另一个是结束一行时。开始一行时，我们需要分配（或清除）
<code class="cf variable">currentRowFieldValues</code>以准备获取一组新数据。
</p><p>
Turning to the rows themselves, we need two operations: one when we start a row and one
when we finish. When we start a row, we need to allocate (or clear)
<code class="cf variable">currentRowFieldValues</code> to prepare for getting a fresh set of data.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterRow(CSVParser.RowContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentRowFieldValues = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;<strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N148D0">
在行的末尾，我们必须考虑上下文。如果我们只是加载了标题行，我们不想更改字段<code class="cf variable">rows</code>。列名不是数据。在 中
<code class="cf methodname">exitRow</code>，我们可以通过查看
<code class="cf methodname">getRuleIndex</code>解析树中父节点的值（或询问父节点是否为 类型）来测试上下文。如果当前行是数据行，我们将使用通过同时遍历 中的列名和 中的值<code class="cf class">HdrContext</code>获得的值创建一个映射
。<code class="cf variable">header</code><code class="cf variable">currentRowFieldValues</code></p><p>
At the end of a row, we have to consider context. If we just loaded the header row, we don’t
want to alter the <code class="cf variable">rows</code> field. The column names aren’t data. In
<code class="cf methodname">exitRow</code>, we can test context by looking at the
<code class="cf methodname">getRuleIndex</code> value of our parent node in the parse tree (or by asking if
the parent is of type <code class="cf class">HdrContext</code>). If the current row is instead a data row,
we create a map using values obtained by simultaneously walking the column names in
<code class="cf variable">header</code> and the values in <code class="cf variable">currentRowFieldValues</code>.</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitRow(CSVParser.RowContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// If this is the header row, do nothing</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// if ( ctx.parent instanceof CSVParser.HdrContext ) return; OR:</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr ) <strong class="prompt">return</strong>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// It's a data row</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt; m = <strong class="prompt">new</strong> <strong class="prompt">LinkedHashMap</strong>&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> i = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">for</strong> (<strong class="prompt">String</strong> v : currentRowFieldValues) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        m.put(header.get(i), v);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        i++;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    rows.add(m);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14946">这就是将 CSV 数据加载到一个良好的数据结构中的全部内容。使用
<code class="cf class">ParseTreeWalker</code>遍历树后，我们的<code class="cf methodname">main</code>in
<code class="cf class">LoadCSV</code>可以打印出该<code class="cf variable">rows</code>字段。
</p><p>And that’s all there is to loading the CSV data into a nice data structure. After using a
<code class="cf class">ParseTreeWalker</code> to traverse the tree, our <code class="cf methodname">main</code> in
<code class="cf class">LoadCSV</code> can print out the <code class="cf variable">rows</code> field.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/LoadCSV.java">听众/LoadCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Loader loader = <strong class="prompt">new</strong> Loader();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(loader, tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(loader.rows);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N14977">
以下是构建和测试顺序：
</p><p>
Here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 CSV.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac CSV*.java LoadCSV.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java LoadCSV t.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[{Details=Mid Bonus, Month=June, Amount="$2,000"}, {Details=, Month=January,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ Amount="""zippo"""}, {Details=Total Bonuses, Month="", Amount="$5,000"}]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0052.html.N1499B">
读取一些数据后我们可能想做的另一件事是将其翻译成另一种语言，这就是我们在下一节中要做的。
</p><p>
The other thing we might want to do after reading some data is to translate it to a
different language, which is what we’ll do in the next section.
</p>

</div></div>
<div id="f_0053.html"><div>

<h2 id="f_0053.html.N149A4">8.2 将 JSON 转换为 XML</h2><h2>8.2 Translating JSON to XML</h2>
<p id="f_0053.html.N149A8">
许多 Web 服务都会返回 JSON 数据，我们可能会遇到这样的情况：我们想将一些 JSON 数据输入到仅接受 XML 的现有代码中。让我们使用第 6.2 节<a href="#f_0041.html.sec.JSON">“解析<em>JSON”</em>中的 JSON 语法作为</a>基础来构建 JSON 到 XML 的转换器。我们的目标是读取如下 JSON 文本：
</p><p>
Lots of web services return JSON data, and we might run into a situation where we want to
feed some JSON data into existing code that accepts only XML. Let’s use our JSON grammar
from Section 6.2, <a href="#f_0041.html.sec.JSON">​<em>Parsing JSON</em>​</a> as a foundation to build a JSON to XML translator. Our goal
is to read in JSON text like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/t.json">听众/t.json</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    "description" : <em class="string">"An imaginary server config file"</em>,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    "logs" : {"level":<em class="string">"verbose"</em>, "dir":<em class="string">"/var/log"</em>},​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    "host" : <em class="string">"antlr.org"</em>,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    "admin": [<em class="string">"parrt"</em>, <em class="string">"tombu"</em>],​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    "aliases": []​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N149F7">
并以等效形式发出 XML，如下所示：
</p><p>
and emit XML in an equivalent form, like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;description&gt;</strong>An imaginary server config file<strong class="prompt">&lt;/description&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;logs&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">&lt;level&gt;</strong>verbose<strong class="prompt">&lt;/level&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">&lt;dir&gt;</strong>/var/log<strong class="prompt">&lt;/dir&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/logs&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;host&gt;</strong>antlr.org<strong class="prompt">&lt;/host&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;admin&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">&lt;element&gt;</strong>parrt<strong class="prompt">&lt;/element&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">&lt;element&gt;</strong>tombu<strong class="prompt">&lt;/element&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/admin&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;aliases&gt;</strong>
<strong class="prompt">&lt;/aliases&gt;</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14A4A"><code class="cf keyword">&lt;element&gt;</code>我们在翻译过程中需要想到的标签在

哪里？</p><p>
where <code class="cf keyword">&lt;element&gt;</code> is a tag we need to conjure up during translation.
</p>
<p id="f_0053.html.N14A50">
正如我们对 CSV 语法所做的那样，让我们​​标记 JSON 语法中的某些替代方案，以让 ANTLR 生成更精确的监听器方法。
</p><p>
As we did with the CSV grammar, let’s label some of the alternatives in the JSON grammar to
get ANTLR to generate more precise listener methods.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON.g4">听众/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'{'</em> pair (<em class="string">','</em> pair)* <em class="string">'}'</em>    # AnObject​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'{'</em> <em class="string">'}'</em>                     # EmptyObject​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​array​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'['</em> value (<em class="string">','</em> value)* <em class="string">']'</em>  # ArrayOfValues​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'['</em> <em class="string">']'</em>                     # EmptyArray​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14A9F">
我们将对规则执行相同的操作<code class="cf keyword">value</code>，但略有不同。除了三个替代方案之外，其他所有替代方案都只需返回替代方案匹配的值的文本。我们可以对所有这些替代方案使用相同的标签，从而使解析树遍历器为这些替代方案触发相同的侦听器方法。
</p><p>
We’ll do the same thing for rule <code class="cf keyword">value</code>, but with a twist.  All but three of the alternatives just have to return the text of the value matched by the alternative. We can use the same label for all of them, causing the parse-tree walker to trigger the same listener method for those alternatives.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON.g4">听众/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​value​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   STRING          # String​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NUMBER          # Atom​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   object          # ObjectValue​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   array           # ArrayValue​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'true'</em>          # Atom​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'false'</em>         # Atom​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'null'</em>          # Atom​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14AD3">
为了实现我们的翻译器，让每条规则返回与规则匹配的输入短语的 XML 等效项是有意义的。为了跟踪这些部分结果，我们将使用字段<code class="cf variable">xml</code>和两个辅助方法注释解析树。
</p><p>
To implement our translator, it makes sense to have each rule return the XML equivalent
of the input phrase matched by the rule. To track these partial results, we’ll annotate the parse tree using field <code class="cf variable">xml</code> and two helper methods.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> XMLEmitter <strong class="prompt">extends</strong> JSONBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ParseTreeProperty&lt;<strong class="prompt">String</strong>&gt; xml = <strong class="prompt">new</strong> ParseTreeProperty&lt;<strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> getXML(ParseTree ctx) { <strong class="prompt">return</strong> xml.get(ctx); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> setXML(ParseTree ctx, <strong class="prompt">String</strong> s) { xml.put(ctx, s); }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14B22">
我们将每个子树的翻译字符串附加到该子树的根。在解析树上层节点上工作的方法可以获取这些值来计算更大的字符串。附加到根节点的字符串就是完整的翻译。
</p><p>
We’ll attach the translated string for each subtree to the root of that subtree. Methods working on nodes further up the parse tree can grab those values to compute larger strings. The string attached to the root node is then the complete translation.
</p>
<p id="f_0053.html.N14B25">
让我们从最简单的翻译开始。“返回”（注释节点）匹配标记的文本（获取该规则调用匹配的文本）
<code class="cf keyword">Atom</code>的替代方法
。<code class="cf keyword">value</code><code class="cf keyword">Atom</code><code class="cf ic">ctx.getText()</code></p><p>
Let’s start with the easiest translation. The <code class="cf keyword">Atom</code> alternatives of
<code class="cf keyword">value</code> “return” (annotate the <code class="cf keyword">Atom</code> node with) the
text of the matched token (<code class="cf ic">ctx.getText()</code> gets the text matched by that rule
invocation).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitAtom(JSONParser.AtomContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, ctx.getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14B4C">
字符串基本相同，只是我们必须去掉双引号（<code class="cf methodname">stripQuotes</code>是文件中的一个辅助方法）。
</p><p>
Strings are basically the same except we have to strip off the double quotes (<code class="cf methodname">stripQuotes</code> is a helper method in the file).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitString(JSONParser.StringContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, stripQuotes(ctx.getText()));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14B6A">
如果<code class="cf methodname">value</code>规则方法找到对象或数组，它可以将该复合元素的部分翻译复制到其自己的解析树节点。以下是针对对象执行此操作的方法：
</p><p>
If the <code class="cf methodname">value</code> rule method finds an object or array, it can copy the partial
translation for that composite element to its own parse-tree node. Here’s how to do it for
objects:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitObjectValue(JSONParser.ObjectValueContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// analogous to String value() {return object();}</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, getXML(ctx.object()));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14B8D">
一旦我们可以翻译所有值，我们就需要担心名称-值对并将它们转换为标签和文本。生成的 XML 的标签名称来自替代<code class="cf keyword">STRING</code>方案中的<code class="cf ic">STRING ’:’ value</code>。打开和关闭标签之间的文本来自附加到<code class="cf keyword">value</code>子项的文本。
</p><p>
Once we can translate all of the values, we need to worry about name-value pairs and converting them to tags and text. The tag name for the resulting XML is derived from the <code class="cf keyword">STRING</code> in the <code class="cf ic">STRING ’:’ value</code> alternative. The text in between the open and close tags is derived from the text attached to the <code class="cf keyword">value</code> child.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitPair(JSONParser.PairContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> tag = stripQuotes(ctx.STRING().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    JSONParser.ValueContext vctx = ctx.value();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> x = <strong class="prompt">String</strong>.format(<em class="string">"&lt;%s&gt;%s&lt;/%s&gt;\n"</em>, tag, getXML(vctx), tag);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, x);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14BC6">
JSON 对象由名称-值对组成。因此，对于
<code class="cf keyword">object</code>在 标记的替代项中找到的每一对<code class="cf keyword">AnObject</code>，我们都将此处计算的结果附加到解析树中：
</p><p>
JSON objects consist of name-value pairs. So, for every pair found by
<code class="cf keyword">object</code> in the alternative marked by <code class="cf keyword">AnObject</code>, we
append the results computed here in the parse tree:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitAnObject(JSONParser.AnObjectContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">StringBuilder</strong> buf = <strong class="prompt">new</strong> <strong class="prompt">StringBuilder</strong>();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">for</strong> (JSONParser.PairContext pctx : ctx.pair()) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(getXML(pctx));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, buf.toString());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitEmptyObject(JSONParser.EmptyObjectContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, <em class="string">""</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14C16">
处理数组遵循类似的模式，简单地连接来自子节点的结果列表，然后将它们包装在 &lt; <code class="cf keyword">element</code>&gt; 标签中。
</p><p>
Processing arrays follows a similar pattern, simply joining the list of results from child nodes and then wrapping them in &lt;<code class="cf keyword">element</code>&gt; tags.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">StringBuilder</strong> buf = <strong class="prompt">new</strong> <strong class="prompt">StringBuilder</strong>();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">for</strong> (JSONParser.ValueContext vctx : ctx.value()) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"&lt;element&gt;"</em>); <em class="comment">// conjure up element for valid XML</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(getXML(vctx));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"&lt;/element&gt;"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, buf.toString());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitEmptyArray(JSONParser.EmptyArrayContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, <em class="string">""</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14C79">
最后，我们需要用从对象或数组收集的整体翻译来注释解析树的根。
</p><p>
Finally, we need annotate the root of the parse tree with the overall translation, collected from an object or array.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON.g4">听众/JSON.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​json:   object​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   array​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14C8F">
我们可以在监听器中通过一个简单的设置操作来实现这一点。
</p><p>
We can do that in our listener with a simple set operation.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/JSON2XML.java">听众/JSON2XML.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitJson(JSONParser.JsonContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setXML(ctx, getXML(ctx.getChild(0)));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14CAA">
以下是构建和测试顺序：
</p><p>
Here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 JSON.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac JSON*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java JSON2XML t.json</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;description&gt;An imaginary server config file&lt;/description&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;logs&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;level&gt;verbose&lt;/level&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0053.html.N14CE0">
翻译并不总是像 JSON 到 XML 那样简单。但是，这个例子向我们展示了如何通过拼凑部分翻译的短语来解决句子翻译的问题。（如果你查看源代码目录，你还会看到一个使用 StringTemplate <a id="f_0053.html.FNPTR-43" href="#f_0055.html.FOOTNOTE-43">[43]</a>
<code class="cf filename">JSON2XML_ST.java</code>生成输出的版本，以及另一个构建 XML DOM 树的版本<code class="cf filename">JSON2XML_DOM.java</code>。）
</p><p>
Translations are not always as straightforward as JSON to XML. But, this example shows us
how to approach the problem of sentence translation by piecing together partially translated
phrases. (If you look in the source code directory, you’ll also see a version that uses
StringTemplate,<a href="#f_0055.html.FOOTNOTE-43">[43]</a>
<code class="cf filename">JSON2XML_ST.java</code>, to generate output and another that builds XML DOM
trees, <code class="cf filename">JSON2XML_DOM.java</code>.)
</p>
<p id="f_0053.html.N14CEE">
好了，数据玩够了。让我们用编程语言做一些有趣的事情。
</p><p>
OK, enough playing around with data. Let’s do something interesting with a programming language.
</p>

</div></div>
<div id="f_0054.html"><div>

<h2 id="f_0054.html.sec.call-graph">8.3 生成调用图</h2><h2>8.3 Generating a Call Graph</h2>
<p id="f_0054.html.N14D02">
软件很难编写和维护，这就是我们尝试构建工具来提高生产力和效率的原因。例如，在过去十年中，我们看到测试框架、代码覆盖工具和代码分析器呈爆炸式增长。将类层次结构以树的形式直观地显示出来也很不错，大多数开发环境都支持这一点。我喜欢的另一种可视化方式称为<span class="firstuseinline">调用图</span>，其中函数作为节点，函数调用作为节点之间的有向边。
</p><p>
Software is hard to write and maintain, which is why we try to build tools to increase our
productivity and effectiveness. For example, over the past decade we’ve seen an explosion
of testing frameworks, code coverage tools, and code analyzers. It’s also nice to see a
class hierarchy visually as a tree, and most development environments support this. The
other visualization I like is called a <span class="firstuseinline">call graph</span>, which has
functions as nodes and function calls as directed edges between the nodes.
</p>
<p id="f_0054.html.N14D18">
在本节中，我们将使用第 6.4 节<a href="#f_0043.html.sec.Cymbol">“解析<em>Cymbol”</em>中的 Cymbol 语法构建一个调用图生成器。</a>我想您会对它的简单程度感到惊讶，尤其是考虑到结果有多酷。为了让您了解我们试图实现的目标，请考虑以下一组函数和函数调用：
</p><p>
In this section, we’re going to build a call graph generator using the  Cymbol 
grammar from Section 6.4, <a href="#f_0043.html.sec.Cymbol">​<em>Parsing Cymbol</em>​</a>. I think you’ll be surprised at how simple it is,
especially given how cool the results are. To give you an idea of what we’re trying to
achieve, consider the following set of functions and function calls:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/t.cymbol">听众/t.cymbol</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> main() { fact(); a(); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">float</strong> fact(<strong class="prompt">int</strong> n) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  print(n);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  <strong class="prompt">if</strong> ( n==0 ) then <strong class="prompt">return</strong> 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  <strong class="prompt">return</strong> n * fact(n-1);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> a() { <strong class="prompt">int</strong> x = b(); <strong class="prompt">if</strong> false then {c(); d();} }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> b() { c(); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> c() { b(); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> d() { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> e() { }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14D6F">
我们希望将调用图可视化如下：
</p><p>
We’d like to visualize the call graph like this:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/听众/调用图.png">
</div>
<p id="f_0054.html.N14D77">
可视化的好处在于，人眼可以轻松发现异常。例如，该<code class="cf methodname">e</code>节点是孤儿节点，这意味着没有人调用它，因此它是死代码。一眼望去，我们发现了一个要抛弃的函数。我们还可以通过查找图中的循环（例如
<code class="cf methodname">fact</code>→<code class="cf methodname">fact</code>和<code class="cf methodname">b</code>→
 <code class="cf methodname">c</code>→ ）非常轻松地检测递归<code class="cf methodname">b</code>。
</p><p>
The good thing about visualizations is that the human eye can easily pick out
aberrations. For example, the <code class="cf methodname">e</code> node is an orphan, which means that no
one calls it and it is therefore dead code. At a glance, we found a function to jettison. We
can also detect recursion very easily by looking for cycles in the graph such as
<code class="cf methodname">fact</code> → <code class="cf methodname">fact</code> and <code class="cf methodname">b</code> →
<code class="cf methodname">c</code> → <code class="cf methodname">b</code>.
</p>
<p id="f_0054.html.N14D8C">
为了可视化调用图，我们需要读入 Cymbol 程序并创建一个 DOT 文件（然后使用 查看它<code class="cf commandname">graphviz</code>）。例如，这是我们需要<code class="cf filename">t.cymbol</code>从前面的示例中为文件生成的 DOT：
</p><p>
To visualize a call graph, we need to read in a Cymbol program and create a DOT
file (and then view it with <code class="cf commandname">graphviz</code>). For example, here is the
DOT we need to generate for file <code class="cf filename">t.cymbol</code> from the earlier example:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​digraph G {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ranksep=.25;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  edge [arrowsize=.5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  node [shape=circle, fontname=<em class="string">"ArialNarrow"</em>,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        fontsize=12, fixedsize=true, height=.45];​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  main; fact; a; b; c; d; e;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  main -&gt; fact;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  main -&gt; a;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  fact -&gt; print;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  fact -&gt; fact;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  a -&gt; b;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  a -&gt; c;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  a -&gt; d;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  b -&gt; c;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  c -&gt; b;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14DD7">
输出由样板设置语句组成，例如，<code class="cf ic">ranksep=.25;</code>然后是节点和边的列表。要捕获孤立节点，我们需要确保为每个函数名称生成一个节点定义，即使它没有传入或传出边。否则它不会出现在图中。请注意<code class="cf keyword">e</code>节点定义行末尾的。
</p><p>
The output consists of boilerplate setup statements such as <code class="cf ic">ranksep=.25;</code> and then
a list of nodes and edges. To catch orphan nodes, we need to make sure to generate a node
definition for each function name, even if it has no incoming or outgoing edges. It would
not appear in the graph otherwise. Note the <code class="cf keyword">e</code> on the end of the node
definition line.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​main; fact; a; b; c; d; e;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14DEC">
我们的策略很简单。当解析器找到函数声明时，我们的应用程序会将当前函数的名称添加到列表中并设置一个名为的字段
。当解析器看到函数调用时，我们的应用程序将记录从被调用者的函数名称的
<code class="cf variable">currentFunctionName</code>边。<code class="cf variable">currentFunctionName</code></p><p>
Our strategy is straightforward. When the parser finds a function declaration, our application
will add the name of the current function to a list and set a field called
<code class="cf variable">currentFunctionName</code>. When the parser sees a function call, our
application will record an edge from the <code class="cf variable">currentFunctionName</code> to the
callee’s function name.
</p>
<p id="f_0054.html.N14DFA">
首先，让我们标记一些规则替代方案以<code class="cf filename">Cymbol.g4</code>
获得更精确的监听器方法。
</p><p>
To get started, let’s label some rule alternatives in <code class="cf filename">Cymbol.g4</code>
to get more precise listener methods.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/Cymbol.g4">听众/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   ID <em class="string">'('</em> exprList? <em class="string">')'</em>    # Call​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'['</em> expr <em class="string">']'</em>       # Index​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'-'</em> expr                # Negate​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'!'</em> expr                # Not​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'*'</em> expr           # Mult​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr (<em class="string">'+'</em>|<em class="string">'-'</em>) expr     # AddSub​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'=='</em> expr          # Equal​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                      # Var​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT                     # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>            # Parens​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14E59">
然后，作为我们语言应用的基础，让我们将所有与图形相关的内容封装到一个类中。
</p><p>
Then, as a foundation for our language application, let’s encapsulate all of the
graph-related stuff into a class.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">static</strong> <strong class="prompt">class</strong> Graph {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// I'm using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">Set</strong>&lt;<strong class="prompt">String</strong>&gt; nodes = <strong class="prompt">new</strong> OrderedHashSet&lt;<strong class="prompt">String</strong>&gt;(); <em class="comment">// list of functions</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    MultiMap&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt; edges =                  <em class="comment">// caller-&gt;callee</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">new</strong> MultiMap&lt;<strong class="prompt">String</strong>, <strong class="prompt">String</strong>&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> edge(<strong class="prompt">String</strong> source, <strong class="prompt">String</strong> target) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        edges.map(source, target);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14EB0"><code class="cf methodname">toDOT</code>从节点和边的集合中，我们可以使用类
中的一点 Java 代码转储出适当的 DOT 代码<code class="cf class">Graph</code>。
</p><p>
From the collection of nodes and edges, we can dump out the appropriate DOT code using
a little bit of Java in <code class="cf methodname">toDOT</code> of class <code class="cf class">Graph</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">String</strong> toDOT() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">StringBuilder</strong> buf = <strong class="prompt">new</strong> <strong class="prompt">StringBuilder</strong>();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"digraph G {\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"  ranksep=.25;\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"  edge [arrowsize=.5]\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"  node [shape=circle, fontname=\"ArialNarrow\",\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"        fontsize=12, fixedsize=true, height=.45];\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"  "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">for</strong> (<strong class="prompt">String</strong> node : nodes) { <em class="comment">// print all nodes first</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(node);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"; "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">for</strong> (<strong class="prompt">String</strong> src : edges.keySet()) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">for</strong> (<strong class="prompt">String</strong> trg : edges.get(src)) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            buf.append(<em class="string">"  "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            buf.append(src);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            buf.append(<em class="string">" -&gt; "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            buf.append(trg);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            buf.append(<em class="string">";\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    buf.append(<em class="string">"}\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">return</strong> buf.toString();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14F57">
现在我们要做的就是使用监听器填充这些数据结构。监听器需要两个字段用于记账。
</p><p>
Now all we have to do is fill in those data structures using a listener. The listener needs two fields for bookkeeping.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">static</strong> <strong class="prompt">class</strong> FunctionListener <strong class="prompt">extends</strong> CymbolBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Graph graph = <strong class="prompt">new</strong> Graph();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> currentFunctionName = null;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14F7B">
而我们的应用程序只需要监听两个事件。首先，当解析器找到函数声明时，它必须记录当前函数名称。
</p><p>
And our application only needs to listen for two events. First, it has to record the
current function name as the parser finds function declarations.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentFunctionName = ctx.ID().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    graph.nodes.add(currentFunctionName);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14F99">
然后，当解析器检测到函数调用时，应用程序会记录从当前函数到被调用函数的边。
</p><p>
Then, when the parser detects a function call, the application records an edge from the
current function to the invoked function.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitCall(CymbolParser.CallContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> funcName = ctx.ID().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// map current function to the callee</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    graph.edge(currentFunctionName, funcName);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14FBF">
请注意，函数调用不能隐藏在嵌套的代码块或声明中，例如<code class="cf methodname">a</code>。
</p><p>
Notice that the function calls can’t hide inside nested code blocks or declarations
such as in <code class="cf methodname">a</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> a() { <strong class="prompt">int</strong> x = b(); <strong class="prompt">if</strong> false then {c(); d();} }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N14FD9"><code class="cf methodname">exitCall</code>无论在哪里找到函数调用，

树遍历器都会触发监听器方法。</p><p>
The tree walker triggers listener method <code class="cf methodname">exitCall</code> regardless of where
it finds function calls.
</p>
<p id="f_0054.html.N14FDF">
通过解析树和类<code class="cf class">FunctionListener</code>，我们可以用监听器启动遍历器来生成输出。
</p><p>
With the parse tree and class <code class="cf class">FunctionListener</code>, we can launch a walker
with our listener to generate output.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CallGraph.java">听众/CallGraph.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​FunctionListener collector = <strong class="prompt">new</strong> FunctionListener();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(collector, tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(collector.graph.toString());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(collector.graph.toDOT());​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N15008">
在转储 DOT 字符串之前，该代码会打印出函数和边的列表。
</p><p>
Before dumping the DOT string, that code prints out the list of functions and edges.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Cymbol.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Cymbol*.java CallGraph.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java CallGraph t.cymbol</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​edges: {main=[fact, a], fact=[print, fact], a=[b, c, d], b=[c], c=[b]},​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​functions: [main, fact, a, b, c, d, e]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​digraph G {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ranksep=.25;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  edge [arrowsize=.5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0054.html.N15039">
当然，要查看调用图，只需剪切并粘贴以 开头的输出<code class="cf ic">digraph G {</code>。
</p><p>
Naturally, to view the call graph, cut and paste just the output starting with <code class="cf ic">digraph G {</code>.
</p>
<p id="f_0054.html.N1503F">
在这一节中，我们用很少的代码构建了一个调用图生成器。为了证明我们的 Cymbol 语法是可重用的，我们将在下一节中再次使用它，无需修改，以构建一个完全不同的应用程序。不仅如此，我们还将使用两个不同的侦听器对同一棵树进行两次传递。
</p><p>
With very little code, we were able to build a call graph generator in this section. To
demonstrate that our Cymbol grammar is reusable, we’re going to use it again without
modification in the next section to build a totally different application. Not only that, but
we’ll make two passes over the same tree with two different listeners.
</p>

</div></div>
<div id="f_0055.html"><div>

<h2 id="f_0055.html.sec.validating">8.4 验证程序符号的使用</h2><h2>8.4 Validating Program Symbol Usage</h2>
<p id="f_0055.html.N15053">
要为 Cymbol 等编程语言构建解释器、编译器或翻译器，我们需要验证 Cymbol 程序是否正确使用了符号（标识符）。在本节中，我们将构建一个 Cymbol 验证器来检查以下条件：
</p><p>
To build an interpreter, compiler, or translator for a programming language such as
Cymbol, we’d need to verify that Cymbol programs used symbols (identifiers) properly. In
this section, we’re going to build a Cymbol validator that checks the following
conditions:
</p>
<ul>
<li>
<p id="f_0055.html.N15065">变量引用具有相应的、对其可见的定义（在范围内）。</p>
</li><li>
<p>Variable references have corresponding definitions that are visible to them (in scope).</p>
</li>
<li>
<p id="f_0055.html.N15069">
    	函数引用有相应的定义（函数可以以任何顺序出现）。
  </p>
</li><li>
<p>
    	Function references have corresponding definitions (functions can appear in any order).
  </p>
</li>
<li>
<p id="f_0055.html.N1506D">
    	变量不被当作函数使用。
  </p>
</li><li>
<p>
    	Variables are not used as functions.
  </p>
</li>
<li>
<p id="f_0055.html.N15071">
    	函数不作为变量使用。
  </p>
</li><li>
<p>
    	Functions are not used as variables.
  </p>
</li>
</ul>
<p id="f_0055.html.N15074">
为了检查所有这些条件，我们还需要做一些工作，因此这个例子比其他例子需要花更长的时间来理解。但是，我们的回报将是一个构建真正语言工具的良好基础。
</p><p>
To check all these conditions, we have a bit of work to do, so this example is going
to take a little bit longer than the others to absorb. But, our reward will be a great base from which to build real language tools.
</p>
<p id="f_0055.html.N15077">
让我们首先看一些包含大量不同参考资料的 Cymbol 示例代码，其中一些是无效的。
</p><p>
Let’s get started by taking a look at some sample Cymbol code with lots of different
references, some of which are invalid.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/vars.cymbol">听众/vars.cymbol</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> f(<strong class="prompt">int</strong> x, <strong class="prompt">float</strong> y) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    g();   <em class="comment">// forward reference is ok</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    i = 3; <em class="comment">// no declaration for i (error)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    g = 4; <em class="comment">// g is not variable (error)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">return</strong> x + y; <em class="comment">// x, y are defined, so no problem</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> g() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> x = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">float</strong> y;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    y = 9; <em class="comment">// y is defined</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    f();   <em class="comment">// backward reference is ok</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    z();   <em class="comment">// no such function (error)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    y();   <em class="comment">// y is not function (error)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    x = f; <em class="comment">// f is not a variable (error)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N150D8">
为了根据先前的条件验证程序中的一切是否正常，我们应该打印出函数及其局部变量的列表以及全局符号（函数和全局变量）的列表。此外，当我们发现问题时，我们应该发出错误。例如，对于之前的输入，让我们构建一个名为的应用程序，
<code class="cf class">CheckSymbols</code>它会生成以下内容：
</p><p>
To verify that everything is OK within a program according to the previous conditions, we
should print out the list of functions and their local variables plus the list of global
symbols (functions and global variables). Further, we should emit an error when we find a
problem. For example, for the previous input, let’s build an application called
<code class="cf class">CheckSymbols</code> that generates the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java CheckSymbols vars.cymbol</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​locals:[]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​locals:[x, y]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​function&lt;g:tVOID&gt;:[]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​globals:[f, g]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 3:4 no such variable: i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 4:4 g is not a variable​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 13:4 no such function: z​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 14:4 y is not a function​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 15:8 f is not a variable​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N1510A">
实现此类问题的关键是适当的数据结构，称为
<span class="firstuseinline">符号表</span>。我们的应用程序将符号存储在符号表中，然后通过在符号表中查找标识符引用来检查标识符引用的正确性。在下一节中，我们将了解数据结构是什么样子，然后使用它来解决手头的验证问题。
</p><p>
The key to implementing this kind of problem is an appropriate data structure called a
<span class="firstuseinline">symbol table</span>. Our application will store symbols in the symbol table
and then check identifier references for correctness by looking them up in the symbol
table. In the next section, we’ll take a peek at what the data structure looks like and
then use it to solve the validation problem at hand.
</p>
<h3>符号表速成课程</h3><h3>A Crash Course in Symbol Tables</h3>
<p id="f_0055.html.N15118">
语言实现者通常将保存符号的数据结构称为<span class="firstuseinline">符号表</span>。所实现的语言决定了符号表的结构和复杂性。如果编程语言允许同一标识符在不同上下文中表示不同的含义，则符号表会将符号分组到<span class="firstuseinline">作用域中</span>。作用域只是一组符号，例如函数的参数列表或全局作用域中的变量和函数列表。
</p><p>
Language implementers typically call the data structure that holds symbols a <span class="firstuseinline">symbol
table</span>. The language being implemented dictates a symbol table’s structure and
complexity. If a programming language allows the same identifier to mean different things in
different contexts, the symbol table groups symbols into <span class="firstuseinline">scopes</span>. A
scope is just a set of symbols such as a list of parameters for a function or the list of
variables and functions in a global scope.
</p>
<p id="f_0055.html.N15121">
符号表本身只是符号定义的存储库 - 它不进行任何检查。要验证代码，我们需要根据之前设置的规则检查表达式中的变量和函数引用。符号验证有两个基本操作：<span class="firstuseinline">定义</span>符号和<span class="firstuseinline">解析</span>
符号。定义符号意味着将其添加到作用域。解析符号意味着找出符号引用哪个定义。从某种意义上说，解析符号意味着找到“最接近”的匹配定义。最接近的作用域是最接近的封闭作用域。例如，让我们看另一个 Cymbol 示例，其中的符号定义在不同的作用域中（用外接数字标记）。
</p><p>
The symbol table by itself is just a repository of symbol definitions—it doesn’t do any
checking. To validate code, we need to check the variable and function references in
expressions against the rules we set up earlier. There are two fundamental operations for
symbol validation: <span class="firstuseinline">defining</span> symbols and <span class="firstuseinline">resolving</span>
symbols. Defining a symbol means adding it to a scope. Resolving a symbol means figuring out
which definition the symbol refers to. In some sense, resolving a symbol means finding the
“closest” matching definition. The closest scope is the closest enclosing scope. For
example, let’s look at another Cymbol example that has symbol definitions in different
scopes (labeled with circumscribed numbers).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/vars2.cymbol">听众/vars2.cymbol</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">①</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> x; ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> y;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">②</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> a() ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">③</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{ ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> x;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    x = 1;  <em class="comment">// x resolves to current scope, not x in global scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    y = 2;  <em class="comment">// y is not found in current scope, but resolves in global</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">④</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    { <strong class="prompt">int</strong> y = x; } ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">⑤</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> b(<strong class="prompt">int</strong> z) ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">⑥</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{ } ​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N15176">
全局作用域<span style="font-family:DroidFont" class="callout-number">①</span>包含变量<code class="cf variable">x</code>
和<code class="cf variable">y</code>以及函数<code class="cf methodname">a</code>和
<code class="cf methodname">b</code>。函数位于全局作用域中，但它们还构成新的作用域，用于保存函数的参数（如果有）：<span style="font-family:DroidFont" class="callout-number">②</span>和<span style="font-family:DroidFont" class="callout-number">⑤</span>。函数作用域内还嵌套有函数的局部代码块（<span style="font-family:DroidFont" class="callout-number">③</span>和<span style="font-family:DroidFont" class="callout-number">⑥</span> ），它们构成另一个新的作用域。局部变量保存在嵌套在函数作用域内的
局部作用域（<span style="font-family:DroidFont" class="callout-number">③</span>、<span style="font-family:DroidFont" class="callout-number">④</span>和<span style="font-family:DroidFont" class="callout-number">⑥ ）中。</span></p><p>
The global scope, <span style="font-family:DroidFont;" class="callout-number">①</span>, contains variables <code class="cf variable">x</code>
and <code class="cf variable">y</code> as well as the functions <code class="cf methodname">a</code> and
<code class="cf methodname">b</code>. Functions live in the global scope, but they also constitute new scopes
that hold the functions’ parameters, if any: <span style="font-family:DroidFont;" class="callout-number">②</span> and <span style="font-family:DroidFont;" class="callout-number">⑤</span>. Also nested within a function scope is the function’s local code block
(<span style="font-family:DroidFont;" class="callout-number">③</span> and <span style="font-family:DroidFont;" class="callout-number">⑥</span>), which constitutes another new
scope. Local variables are held in local scopes (<span style="font-family:DroidFont;" class="callout-number">③</span>, <span style="font-family:DroidFont;" class="callout-number">④</span>, and <span style="font-family:DroidFont;" class="callout-number">⑥</span>) nested within the function scopes.
</p>
<p id="f_0055.html.N1519D">
因为符号<code class="cf variable">x</code>被定义了两次，所以我们不能将所有标识符塞进一个集合中而不会发生冲突。这就是作用域的作用。我们保留一组作用域，并且只允许作用域中的每个标识符有一个定义。我们还保留一个指向父作用域的指针，以便我们可以在外部作用域中找到符号定义。作用域形成一棵树。
</p><p>
Because symbol <code class="cf variable">x</code> is defined twice, we can’t just stuff all of our
identifiers into a single set without collision. That’s where scopes come in. We keep a
set of scopes and allow only a single definition for each identifier in a scope. We also
keep a pointer to the parent scope so that we can find symbol definitions in outer
scopes. The scopes form a tree.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/听众/symtab.png">
</div>
<p id="f_0055.html.N151A8">
带圆圈的数字表示源代码中的作用域。从任何作用域到根（全局作用域）的路径上的节点形成一个作用域堆栈。要查找符号的定义，我们从引用周围的作用域开始，然后沿着作用域树向上走，直到找到它的定义。
</p><p>
The circled numbers refer to the scope from the source code. The nodes along the
path from any scope to the root (global scope) form a stack of scopes. To find a symbol’s
definition, we start in the scope surrounding the reference and walk up the scope tree until
we find its definition.
</p>
<p id="f_0055.html.N151AB">
我没有为了这个例子重新实现一个合适的符号表，而是从《语言实现模式》第 6 章 [Par09] 中复制了符号表源代码[
 <em>44</em> ] 。<a id="f_0055.html.FNPTR-44" href="#f_0055.html.FOOTNOTE-44">我</a>&nbsp;鼓励您查看、、、、和的源代码，以
了解实现。这些类一起体现了符号表，我们假设它们可以正常工作。有了符号表，我们就可以构建验证器了。
<em></em><code class="cf class">BaseScope</code><code class="cf class">GlobalScope</code><code class="cf class">LocalScope</code><code class="cf class">Symbol</code><code class="cf class">FunctionSymbol</code><code class="cf class">VariableSymbol</code></p><p>
Rather than reimplement an appropriate symbol table just for this example, I’ve copied the
symbol table source code<a href="#f_0055.html.FOOTNOTE-44">[44]</a> from Chapter 6 of <em>Language Implementation Patterns</em>&nbsp;[Par09]. I encourage you to look through
the source for <code class="cf class">BaseScope</code>, <code class="cf class">GlobalScope</code>,
<code class="cf class">LocalScope</code>, <code class="cf class">Symbol</code>, <code class="cf class">FunctionSymbol</code>, and
<code class="cf class">VariableSymbol</code> to get a feel for the implementation. Together, those classes
embody the symbol table, and we’ll assume that they just work. With a symbol table in place,
we’re ready to build our validator.
</p>
<h3>验证者架构</h3><h3>Validator Architecture</h3>
<p id="f_0055.html.N151D5">
在开始构建验证器之前，让我们先从大局着眼，制定一个总体策略。我们可以根据关键操作来分解这个问题：
<span class="emph">定义</span>和<span class="emph">解析</span>。对于定义，我们需要监听变量和函数定义事件，并将<code class="cf class">Symbol</code>对象插入到该定义周围的范围中。在函数开始时，我们需要“推送”一个新范围，然后在该函数定义的末尾弹出它。
</p><p>
To begin building our validator, let’s think about the big picture and form an overall
strategy. We can break this problem down according to the key operations:
<span class="emph">define</span> and <span class="emph">resolve</span>. For definitions, we need to listen for
variable and function definition events and insert <code class="cf class">Symbol</code> objects into the
scope surrounding that definition. At the start of a function, we need to “push” a new scope
and then pop it at the end of that function definition.
</p>
<p id="f_0055.html.N151E1">
为了解析和检查符号引用，我们需要监听表达式中的变量和函数名称引用。对于每个引用，我们将验证是否存在匹配的定义以及引用是否正确使用了符号。
</p><p>
To resolve and check symbol references, we need to listen for variable and function name
references within expressions. For each reference, we’ll verify that there is a matching
definition and that the reference uses the symbol properly.
</p>
<p id="f_0055.html.N151E4">
这看起来很简单，但有一个复杂之处：Cymbol 程序可以调用源文件中在其之后定义的函数。我们称之为<span class="firstuseinline">前向引用</span>。为了支持它们，我们需要对解析树进行两次传递。第一遍或阶段定义包括函数在内的符号，第二遍进行解析。这样，第二遍可以看到文件中的所有函数。以下是测试装置中触发解析树两次传递的代码：
</p><p>
That seems straightforward, but there’s a complication: a Cymbol program can call a function
defined after it in the source file. We call that a <span class="firstuseinline">forward reference</span>.
To support them, we need to make two passes over the parse tree. The first pass, or phase,
defines the symbols including the functions, and the second pass does the resolutions. In
this way, the second pass can see all functions in the file. Here’s the code in the test rig
that triggers both passes over the parse tree:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/CheckSymbols.java">听众/CheckSymbols.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DefPhase def = <strong class="prompt">new</strong> DefPhase();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(def, tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// create next phase and feed symbol table info from def to ref phase</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RefPhase ref = <strong class="prompt">new</strong> RefPhase(def.globals, def.scopes);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(ref, tree);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N15213">
在定义阶段，我们将创建大量作用域。除非我们保留对它们的引用，否则垃圾收集器将丢弃这些作用域。为了使符号表在从定义阶段到解析阶段的过渡中存活下来，我们需要跟踪这些作用域。将它们存放起来最合乎逻辑的地方是解析树本身（或者，从技术上讲，使用将值与树节点相关联的注释图）。然后，引用阶段可以在解析树下降时简单地拾取当前作用域指针。与函数和本地块相关联的树节点将获得指向其作用域的指针。
</p><p>
During the definition phase, we’ll be creating lots of scopes. Unless we keep references to
them, the garbage collector will throw the scopes out. For the symbol table to
survive the transition from the definition to the resolution phase, we need to track those
scopes. The most logical place to squirrel them away is in the parse tree itself (or,
technically, using an annotation map that associates values with tree nodes). The reference
phase can then simply pick up the current scope pointer as it descends the parse tree. Tree
nodes associated with functions and local blocks will get pointers to their scopes.
</p>
<h3>定义和解析符号</h3><h3>Defining and Resolving Symbols</h3>
<p id="f_0055.html.N1522A">
牢记总体策略，让我们从 开始构建验证器
<code class="cf class">DefPhase</code>。我们的阶段类需要三个字段：对全局范围的引用、用于跟踪我们创建的范围的解析树注释器以及指向当前范围的指针。的侦听器代码<code class="cf methodname">enterFile</code>启动活动，创建全局范围。最后，<code class="cf methodname">exitFile</code>负责打印结果。
</p><p>
With our general strategy in mind, let’s build our validator, starting with the
<code class="cf class">DefPhase</code>. Our phase classes need three fields: a reference to a global scope,
a parse tree annotator to track the scopes we create, and a pointer to the current scope.
The listener code for <code class="cf methodname">enterFile</code> starts off the activity, creating the
global scope. At the end, <code class="cf methodname">exitFile</code> is responsible for printing the results.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/DefPhase.java">听众/DefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> DefPhase <strong class="prompt">extends</strong> CymbolBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ParseTreeProperty&lt;Scope&gt; scopes = <strong class="prompt">new</strong> ParseTreeProperty&lt;Scope&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    GlobalScope globals;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Scope currentScope; <em class="comment">// define symbols in this scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> enterFile(CymbolParser.FileContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        globals = <strong class="prompt">new</strong> GlobalScope(null);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        currentScope = globals;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitFile(CymbolParser.FileContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.out.println(globals);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N15282">
当解析器找到函数声明时，我们的应用程序需要创建一个
<code class="cf class">FunctionSymbol</code>对象。<code class="cf class">FunctionSymbol</code>对象既是符号，又是包含参数的作用域。为了将函数作用域嵌套在全局作用域中，我们“推送”函数作用域。我们通过将函数的封闭作用域设置为当前作用域并重置当前作用域来实现这一点。
</p><p>
When the parser finds a function declaration, our application needs to create a
<code class="cf class">FunctionSymbol</code> object. <code class="cf class">FunctionSymbol</code> objects do double duty as a
symbol and as the scope containing the arguments. To nest the function scope within the global
scope, we “push” the function scope. We do that by setting the function’s enclosing scope to
be the current scope and resetting the current scope.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/DefPhase.java">听众/DefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> name = ctx.ID().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> typeTokenType = ctx.type().start.getType();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Symbol.Type type = CheckSymbols.getType(typeTokenType);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// push new scope by making new one that points to enclosing scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    FunctionSymbol function = <strong class="prompt">new</strong> FunctionSymbol(name, type, currentScope);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope.define(function); <em class="comment">// Define function in current scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    saveScope(ctx, function);      <em class="comment">// Push: set function's parent to current</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = function;       <em class="comment">// Current scope is now function scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> saveScope(ParserRuleContext ctx, Scope s) { scopes.put(ctx, s); }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N152D2">
方法用函数作用域<code class="cf methodname">saveScope</code>注释<code class="cf keyword">functionDecl</code>规则节点，以便我们的引用阶段稍后可以拾取它。当我们离开函数时，我们会弹出函数作用域，以便当前作用域再次成为全局作用域。
</p><p>
Method <code class="cf methodname">saveScope</code> annotates the <code class="cf keyword">functionDecl</code> rule node
with the function scope so our reference phase can pick it up later. As we leave a function,
we pop the function scope so that the current scope is again the global scope.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/DefPhase.java">听众/DefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">System</strong>.out.println(currentScope);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = currentScope.getEnclosingScope(); <em class="comment">// pop scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N152FB">
本地作用域的工作方式类似。我们在侦听器方法中推送一个作用域<code class="cf methodname">enterBlock</code>并将其弹出<code class="cf methodname">exitBlock</code>。
</p><p>
Local scopes work in a similar way. We push a scope in listener method <code class="cf methodname">enterBlock</code> and pop it in <code class="cf methodname">exitBlock</code>.
</p>
<p id="f_0055.html.N15304">
现在我们已经处理了范围和函数定义，让我们定义参数和变量。
</p><p>
Now that we’ve taken care of the scopes and function definitions, let’s define the
arguments and variables.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/DefPhase.java">听众/DefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitFormalParameter(CymbolParser.FormalParameterContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    defineVar(ctx.type(), ctx.ID().getSymbol());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitVarDecl(CymbolParser.VarDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    defineVar(ctx.type(), ctx.ID().getSymbol());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> defineVar(CymbolParser.TypeContext typeCtx, Token nameToken) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> typeTokenType = typeCtx.start.getType();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Symbol.Type type = CheckSymbols.getType(typeTokenType);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    VariableSymbol var = <strong class="prompt">new</strong> VariableSymbol(nameToken.getText(), type);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope.define(var); <em class="comment">// Define symbol in current scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N1534D">
定义阶段就此结束。 
</p><p>
That finishes up the definition phase. 
</p>
<p id="f_0055.html.N15350">
为了构建我们的参考阶段，让我们首先将当前范围设置为从定义阶段传递给我们的全局范围。
</p><p>
To build our reference phase, let’s start by setting the current scope to the global scope
passed to us from the definition phase.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/RefPhase.java">听众/RefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> RefPhase(GlobalScope globals, ParseTreeProperty&lt;Scope&gt; scopes) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    this.scopes = scopes;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    this.globals = globals;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterFile(CymbolParser.FileContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = globals;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N15379">
然后，当树遍历器触发 Cymbol 函数和块的进入和退出事件时，我们的监听器方法<code class="cf variable">currentScope</code>通过访问定义阶段存储在树中的值来保持最新状态。
</p><p>
Then, as the tree walker triggers enter and exit events for Cymbol functions and blocks, our
listener methods keep <code class="cf variable">currentScope</code> up-to-date by accessing values
stored in the tree during the definition phase.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/RefPhase.java">听众/RefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = scopes.get(ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = currentScope.getEnclosingScope();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> enterBlock(CymbolParser.BlockContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = scopes.get(ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitBlock(CymbolParser.BlockContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    currentScope = currentScope.getEnclosingScope();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N153CC">
随着遍历器的运行，在适当地设置范围后，我们可以通过实现变量引用和函数调用的侦听器方法来解析符号。当遍历器遇到变量引用时，它会调用<code class="cf methodname">exitVar</code>，它使用
<code class="cf methodname">resolve</code>来尝试在当前范围的符号表中查找名称。如果
<code class="cf methodname">resolve</code>在当前范围中找不到符号，它会查找封闭的范围链。如有必要，<code class="cf methodname">resolve</code>将一直查找到全局范围。如果找不到合适的定义，它将返回 null。但是，如果
<code class="cf methodname">resolve</code>找到一个符号但它是一个函数而不是变量，我们需要生成一条错误消息。</p><p>
With the scopes set appropriately as the walker proceeds, we can resolve symbols by
implementing listener methods for variable references and function calls. When the walker
encounters a variable reference, it calls <code class="cf methodname">exitVar</code>, which uses
<code class="cf methodname">resolve</code> to try to find the name in the current scope’s symbol table. If
<code class="cf methodname">resolve</code> doesn’t find the symbol in the current scope, it looks up the
enclosing scope chain. If necessary, <code class="cf methodname">resolve</code> will look all the way up to
the global scope. It returns null if it can’t find a suitable definition. If, however,
<code class="cf methodname">resolve</code> finds a symbol but it’s a function, not a variable, we need to
generate an error message.</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/listeners/RefPhase.java">听众/RefPhase.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">void</strong> exitVar(CymbolParser.VarContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> name = ctx.ID().getSymbol().getText();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Symbol var = currentScope.resolve(name);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( var==null ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CheckSymbols.error(ctx.ID().getSymbol(), <em class="string">"no such variable: "</em>+name);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( var <strong class="prompt">instanceof</strong> FunctionSymbol ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CheckSymbols.error(ctx.ID().getSymbol(), name+<em class="string">" is not a variable"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N1541F">
处理函数调用基本相同。如果我们找不到定义或找到的是变量而非函数，我们会发出错误。
</p><p>
Handling function calls is basically the same. We emit an error if we can’t find a definition or we find a variable, not a function.
</p>
<p id="f_0055.html.N15422">
最后，这里是显示之前所需输出的构建和测试序列：
</p><p>
Finally, here’s the build and test sequence that shows the desired output from earlier:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Cymbol.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Cymbol*.java CheckSymbols.java *Phase.java *Scope.java *Symbol.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java CheckSymbols vars.cymbol</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​locals:[]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0055.html.N1544A">
完成这两个步骤后，我们就完成了符号验证器。我们不得不涉及很多内容，但这些努力是值得的，因为这个示例是创建您自己的语言工具的一个很好的起点。监听器的实现只有大约 150 行 Java 代码，符号表支持代码又有 100 行。如果您目前没有积极构建需要符号表的工具，请不要在这里纠结细节。重点是，有一个众所周知的跟踪和验证符号的解决方案，这并不是什么难事。要了解有关符号表管理的更多信息，我大胆地建议您购买并深入研究<em>语言实现模式</em>&nbsp;[Par09]。
</p><p>
With both passes complete, we’ve finished our symbol validator. We had to cover a lot
ground, but the effort is worthwhile because this example is a great starting point for
creating your own language tools. The implementation of the listeners is only
about 150 lines of Java, with the symbol table support code coming in at another 100. If
you’re not actively building a tool that needs a symbol table at the moment, don’t sweat
the details here. The takeaway is that there is a well-known solution to tracking and
validating symbols that’s not rocket science. To learn more about symbol table
management, I shamelessly suggest you purchase and dig through <em>Language Implementation Patterns</em>&nbsp;[Par09].
</p>
<p id="f_0055.html.N15456">
如果您到目前为止一直很好地理解了本书的这一部分，那么您就做得很好了！您不仅可以通过查阅语言参考手册来构建语法，还可以通过实现监听器将这些语法变为现实，以执行有用的任务。当然，现在您可能很难理解一些语言问题，但您的功夫很强。
</p><p>
If you’ve been following along pretty well so far in this section of the book, you’re in
great shape! Not only can you build grammars by digging through language reference manuals,
you can bring those grammars to life to perform useful tasks by implementing listeners.
Certainly there are language problems out there you might have difficulty with at this
point, but your kung fu is very strong.
</p>
<p id="f_0055.html.N15459">
本章结束了本书的第二部分。一旦您掌握了使用这些关键 ANTLR 技能的经验，您就会想要跳到下一部分来学习高级 ANTLR 用法。
</p><p>
This chapter finishes Part II of the book. Once you have some experience using these key
ANTLR skills, you’ll want to jump into the next part to learn about advanced ANTLR usage.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0055.html.FOOTNOTE-43" href="#f_0053.html.FNPTR-43">[43]</a>
</td>
<td>
<p id="f_0055.html.N14CE4">
<a href="http://www.stringtemplate.org/">http://www.stringtemplate.org</a>
</p><p>
<a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0055.html.FOOTNOTE-44" href="#f_0055.html.FNPTR-44">[44]</a>
</td>
<td>
<p id="f_0055.html.N151B4">
<a href="http://pragprog.com/book/tpdsl/language-implementation-patterns">http://pragprog.com/book/tpdsl/language-implementation-patterns</a>
</p><p>
<a href="http://pragprog.com/book/tpdsl/language-implementation-patterns">http://pragprog.com/book/tpdsl/language-implementation-patterns</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0056.html"><div>

<h1 class="part-title" id="f_0056.html.N1545C">
<span class="part-number">第 3 部分</span>
<br><br>高级主题</h1><h1 class="part-title">
<span class="part-number">Part 3</span>
<br><br>Advanced Topics</h1>
<blockquote class="pg-partintro">
<p id="f_0056.html.N15460">
在第二部分中，我们学习了如何从语言示例和参考手册中抽象出语言结构（语法），然后学习如何使用 ANTLR 语法正式描述语法。为了开发语言应用程序，我们构建了几个树监听器和访问者，它们对自动生成的解析树进行操作。现在，我们掌握了有效使用 ANTLR 解决大多数问题的关键。
</p>
<p id="f_0056.html.N15463">
第三部分是关于 ANTLR 的高级用法。首先，我们将研究 ANTLR 的自动错误处理机制。然后，我们将探索如何将代码片段直接嵌入语法中，以便在解析过程中生成输出或执行即时计算。然后，我们将了解如何使用<span class="firstuseinline">语义谓词</span>根据运行时信息动态地打开和关闭语法中的替代方案。最后，我们将执行一些词汇黑魔法。
</p>
</blockquote><blockquote class="pg-partintro">
<p>
In Part II,  we learned how to abstract language structure (syntax) from
language samples and reference manuals and then how to formally describe syntax with
ANTLR grammars. To develop language applications, we built several tree listeners and
visitors that operated on automatically generated parse trees. Now we have the
keys to effectively use ANTLR for most problems.
</p>
<p>
Part III is about advanced usages of ANTLR. First, we’ll examine ANTLR’s
automatic error handling mechanism. Then, we’ll explore how to embed code snippets directly
within a grammar in order to generate output or perform computations on-the-fly during the
parse. Then we’ll see how to dynamically turn alternatives in the grammar on and off based
upon runtime information using <span class="firstuseinline">semantic predicates</span>. Finally, we’ll
perform some lexical black magic.
</p>
</blockquote>



</div></div>
<div id="f_0057.html"><div>

<h1 class="chapter-title" id="f_0057.html.chp.errors">
<span class="chapter-number">
	      第九章</span>
<br><br>
<span class="chapter-name">错误报告和恢复</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      9</span>
<br><br>
<span class="chapter-name">Error Reporting and Recovery</span>
</h1>

<p id="f_0057.html.N15472">
在我们开发语法时，就像任何软件一样，会有很多错误需要修复。在我们完成（并调试）语法之前，生成的解析器不会识别所有有效的句子。与此同时，信息丰富的错误消息可帮助我们追踪语法问题。一旦我们有了正确的语法，我们就必须处理用户输入的不合语法的句子，甚至是其他出错的程序生成的不合语法的句子。
</p><p>
As we develop a grammar, there will be lots of mistakes to fix just like any piece
of software. The resulting parser won’t recognize all valid sentences until we
finish (and debug) our grammar. In the meantime, informative error messages help
us track down grammar problems. Once we have a correct grammar, we then have to
deal with ungrammatical sentences entered by users or even ungrammatical sentences
generated by other programs gone awry.
</p>
<p id="f_0057.html.N1547F">
  在这两种情况下，我们的解析器对不合语法的输入的响应方式都是重要的生产力考虑因素。换句话说，如果解析器在第一次出现语法错误时就响应“Eh?”并放弃，那么对于我们开发期间或我们的用户部署期间来说，它都不是很有用。
</p><p>
  In both situations, the manner in which our parser responds to ungrammatical
  input is an important productivity consideration. In other words, a parser that
  responds with “Eh?” and bails out upon the first syntax error isn’t
  very useful for us during development or for our users during deployment.
</p>
<p id="f_0057.html.N15482">
  使用 ANTLR 的开发人员可以免费获得良好的错误报告功能和复杂的错误恢复策略。ANTLR 生成的解析器会在语法错误时自动发出丰富的错误消息，并且大部分时间都能成功重新同步。解析器甚至可以避免为每个语法错误生成多条错误消息。
</p><p>
  Developers using ANTLR get a good error reporting facility and a sophisticated
  error recovery strategy for free. ANTLR generates parsers that automatically
  emit rich error messages upon syntax error and successfully resynchronize much
  of the time. The parsers even avoid generating more than a single error message
  for each syntax error.
</p>
<p id="f_0057.html.N15485">
  在本章中，我们将了解 ANTLR 生成的解析器使用的自动错误报告和恢复策略。我们还将了解如何更改默认错误处理机制以满足非典型需求，以及如何为特定应用程序领域定制错误消息。
</p><p>
  In this chapter, we’ll learn about the automatic error reporting and recovery
  strategy used by ANTLR-generated parsers. We’ll also see how to alter the
  default error handling mechanism to suit atypical needs and how to customize
  error messages for a specific application domain.
</p>

</div></div>
<div id="f_0058.html"><div>

<h2 id="f_0058.html.sec.parade">9.1 错误一览</h2><h2>9.1 A Parade of Errors</h2>
<p id="f_0058.html.N1548D">
描述 ANTLR 错误恢复策略的最佳方式是观察 ANTLR 生成的解析器如何响应错误输入。让我们看一个类似于 Java 的简单语言的语法，其中包含带有字段和方法成员的类定义。这些方法具有简单的语句和表达式。我们将使用它作为本节和本章其余部分示例的核心。
</p><p>
The best way to describe ANTLR’s error recovery strategy is to watch an
ANTLR-generated parser respond to erroneous input. Let’s look at a grammar for a
simple Java-like language containing class definitions with field and method
members. The methods have simple statements and expressions. We’ll use it as the
core of the examples in this section and the remainder of the chapter.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Simple.g4">错误/Simple.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Simple;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   classDef+ ; <em class="comment">// match one or more class definitions</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​classDef​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'class'</em> ID <em class="string">'{'</em> member+ <em class="string">'}'</em> <em class="comment">// a class has one or more members</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"class "</em>+$ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​member​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'int'</em> ID <em class="string">';'</em>                       <em class="comment">// field definition</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"var "</em>+$ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'int'</em> f=ID <em class="string">'('</em> ID <em class="string">')'</em> <em class="string">'{'</em> stat <em class="string">'}'</em> <em class="comment">// method definition</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"method: "</em>+$f.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   expr <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"found expr: "</em>+$stat.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"found assign: "</em>+$stat.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'('</em> INT <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\r\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N1552E">
嵌入的操作会在解析器找到元素时将其打印出来。为了简单和简洁，我们使用嵌入的操作而不是解析树监听器。我们将在第 10 章“<a href="#f_0063.html.chp.actions">属性<em>和操作”</em></a>中了解有关操作的更多信息。
</p><p>
The embedded actions print out elements as the parser finds them. We’re using embedded actions instead of a parse-tree listener for simplicity and brevity. We’ll learn more about actions in Chapter 10, <a href="#f_0063.html.chp.actions">​<em>Attributes and Actions</em>​</a>.
</p>
<p id="f_0058.html.N15534">
首先，让我们用一些有效的输入运行解析器来观察正常输出。
</p><p>
First, let’s run the parser with some valid input to observe the normal output.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Simple.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Simple*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T { int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N1555F">
我们没有从解析器中得到任何错误，并且它执行打印语句来报告对变量<code class="cf ic">i</code>和类定义的正确识别<code class="cf ic">T</code>。
</p><p>
We get no errors from the parser, and it executes the print statements to report
proper recognition of variable <code class="cf ic">i</code> and class definition <code class="cf ic">T</code>.
</p>
<p id="f_0058.html.N15568">
现在，让我们尝试一个方法定义包含伪赋值表达式的类。
</p><p>
Now, let’s try a class with a method definition containing a bogus assignment expression.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int f(x) { a = 3 4 5; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:19 mismatched input '4' expecting ';'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​method: f​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N15596">
在<code class="cf ic">4</code>标记处，解析器找不到它<code class="cf ic">;</code>期望的 并报告错误。<code class="cf ic">line 2:19</code>表示有问题的标记位于第二行的第 20 个字符位置（字符位置从零开始）。由于该<code class="cf commandoption">-gui</code>选项，我们还会看到解析树，其中错误节点突出显示（稍后会详细介绍）。
</p><p>
At the <code class="cf ic">4</code> token, the parser doesn’t find the <code class="cf ic">;</code> it was expecting
and reports an error. The <code class="cf ic">line 2:19</code> indicates that the offending token
was found on the second line at the twentieth character position (character positions
start from zero). Because of the <code class="cf commandoption">-gui</code> option, we
also see the parse tree with error nodes highlighted (more on this in a moment).
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKYAAACvCAMAAABAWVWNAAAAeFBMVEX////u7u7MzMzd3d13d3e7u7uZmZmIiIgRERFVVVWqqqozMzMiIiJERERmZmYAAAD89vb1393p0tHy3Nrkzszt19Xgysf89PPy1NHCqqfSuLWynJkQDg1xY2FAODdhVVMwKinixsOBcW8gHBuRf31QRkWhjYv+/PyQVI/aAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAASAAAAEgARslrPgAAB99JREFUeNrtnQ2bmygQx+U9opD27np72+2m7bV7/f7f8BhAGXxJskmMbNd5Hq1oxN8OIPB3tFW12Wab3d0IZVy4tXArqYjboSRja1ONTOxq3Wi3FqSVsmWw3um1qcaYbVVpA2vFq4pzWFuxNtUY08ACa+4x/bpAzJZUygKmrKuqlrBuS8Q0pmGAWVljrHNlawot9KE1dG2q05iGW7s21NjI0HNMlOfLt2hkbYDzrLz2vWFumBvmhlm2bZgbZqm2YW6Ypdo2uXgHRnmeJoojWUY2cm3AYMMpumiEtk03cduXMIMjkoMio737BKeweGxuvcRZ0Uasz0karoUwRDoPgiCnw+KOsF1FWq2MbPn6YiyomFDoRNTc1ULmF49J9iDQibYy117jBsYDJjXSui3nOVg8pq4rXoPKWQKmNB6TqwBMdrAAJnOVQHqpqwTMyjZGCaNbC4VeGw6L2BnTiHCwDG9uttkbMqZ48SM5x9gabXjJpI5RSu76Rjdk0oWSAiMhXAgFCUtgUFIaqWd0fRInJDxkIRbGG45UrT/uyBmdC13P0w+HoicLIe0YYbDk/hVppK66p9SrkzJlI2NwZUXwdEMm5BVJibTp0t6VrqSzgbrg2c9XIM0vymJFFINoBJpj35l0eDml4n4++qUlx0+9G2PvymGRR3J6MoM7MCZXjos8sk/c4omyy5FOuSG5cqLIg8lJNSHdyBZnxK6cLPLIqab335x0pjoxXKB6PuaI8rkjNySdrfLYlRU5FjBB+TzLjUjF3DBHZvv10UsRdewoU4WIYQvafI2qQtRWFrNFTztkPkN5hQwujukAnLc2w2xO16/5DElzGeKUHDj4ick9gBAIE4owfyooh31SGLQTAignz34N5ZQceDam2HHeWLljQTnsk6KF0MluZ3095qQceBRTononXBG2pOIqKId9Eja0iTvbLDN+9E4wZ5Ny4FFMhr1pvHtcJl457JMhdDLtRFZf1MNPyoFHMatJTK8cJkwfOpl2Tp/9GpuSAy/A9Moh8iaETqad12O+3sw1HYm88IZ0gV2jHND1n3Vs9k6NKVOa6jUyytt9W5u65eW9U9CZ5tbYWipFOIOxny6vTRPtsByaqmwlhBttMi7pMhPKyxlBhBVcwrTOTaXcsA3EOgcKk58SpMSqiiTSCj+tozD8cYuEusnAmyUIyaFcCWjwfoYcZAZYBTRXR0moEeuRUu7rHvPlGmbIQT8Om6FaBlBoX6s0/u6ygsPbV8x6b8Vhv3dpL9B1oN2fdTdL1U1zP1iKwmynLIXhedKZetCl1KRpRhUrmgzzTdK9g9PBRD40CU6gd2n86Bq+3QSPRoJeWeomO+gZAgZduPHjutVflfQz+FTI/XxX4laDQX3dXiK8juLOT/DOTzpdOm2laXnuNOabGya9bePPM5R9guCALuScNMUdyHNEZaA3bPyDikRkQkOudJ5C56Tt8XODAahv/Nc2KTbQO12efZJklSubjKKmM/HEYwg6usprTQzOJrgMs9JiWSXM5LsxAJETu35r2ZNNKT1Z3COZlTCzMjhDDPVZX3Z7Sk0C8WZxj/P3PYa1+ZEYqkYb/o++TGUglFAK7YXu+2DHPO4R5evqX/ZOo0E/y7QYwanPD8RUlPHod2ebAK1StqSS+75xZ3GPFLlMNFWN79TY0SbPVEN+XkxFGV+F2QSNaz9zyexGWWfPYJCEKbOn7qB+QX5eTN1XM+e8DtOcjyn2WbfHU7NhmZdAOnX5BTE1x7xM9jyJyWqUcK6fa115YZId5BfE1Bzz4kKPmCa9K51lhZqQF4unD2XneOnU5RfEVJO9hL2U7Dnfb2T14UwxdDnZk5534LwB8CZ7blaAMdXWxQ/btG2l64Vbu7awdMQot1YRLSqpeMNVka2b+MhUFiYkUrh5pipPVNZuvkPjw2tIu3kgtYKuryoiYyAekDgiiYN74BNutyxEUyYBpK+KXVfq/Si9NLp+4YswudX9GDgFFYTy9pqN4Gu+adT5iaKhHRqXRL3R645ktcLvLkzwyDwLU7KdpCzjH3X3t0tpX4wqE5IyJabXbmjUSPVdC5+lO6Kw+XXz2X3SmET0JBT+fSB16l/Y8GtOQ3UBaWGyc+Q9bqb4GmQ8XZxQvtDBvnroRXtS6A9TSk0EH44VHRynRtIpZLGeVGf632T44pSUmcXTMfR3LlH4g7sJm/bFpDyWx/0xmynTN76ZDrKbKbCxdz58/Pjxjz/dKqbd1l+f3OpDTH76u99e0x7+iRbTXfIBJR/WhoyYj58R5uPT02ORmJ+/PCPMw+HwvBCmPt4b+7fCmRdN+09iIszDV4z5LS/077fDDNGfvQkePs/YH/ZhnCCCpk9iIsznf58x5o/nnwjz6csNvekFy96YAEvp8FY4iKDpk5gJ8/Hlnwzz6ekFF/rj7TBj9OccZngrHETQ9EnMhPny7fDjx0/c0j9/WaZudtGf0YaFHt8KFw1Jn8RMmM4ybzp/viTM70+3wwyC5bxBGKcXQdEnMecwfx4O39AN6b+vK9yQxoHmp27vzzf05oKYj2vc3kefxHxTneWGeZGNu9RfD9E67Gi/UPLX+phF2oa5YZZqG+aGWaptmBtmqbZhvkPMIp5O/ibGRBlv5ZygNLxd/VHvWabr6/NY3Jgwb6GpC24KCpk4Yqy9Po87mHgDmLoxBf6/OZtt9g7sfy/SVBzPD9TyAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjQ2LTA2OjAwQUGRoAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo0Ni0wNjowMDAcKRwAAAAgdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADYxMng3OTIrMCswn519VwAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuNQ1Ag1dMAAAAAElFTkSuQmCC" alt="图片/错误/345.png">
</div>
<p id="f_0058.html.N155AA">
在这种情况下，有两个多余的标记，解析器会给出关于不匹配的一般错误消息。但是，如果只有一个多余的标记，解析器可能会更聪明一些，指出这是一个多余的标记。在以下测试运行中，<code class="cf ic">;</code>类名之后和类主体开始之前有一个多余的标记：
</p><p>
In this case, there are two extra tokens, and the parser gives a generic error
message about the mismatch. If there is just a single extra token, however, the
parser can be a little bit smarter, indicating it’s an extraneous token. In the
following test run, there is an extraneous <code class="cf ic">;</code> after the class name and
before the start of the class body:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T ; { int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:8 extraneous input ';' expecting '{'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N155D1">
解析器会报告错误，<code class="cf ic">;</code>但会给出稍微更详细的答案，因为它知道下一个标记是它实际要查找的标记。此功能称为<span class="emph">单标记删除，</span>因为解析器可以简单地假装无关的标记不存在并继续执行。
</p><p>
The parser reports an error at the <code class="cf ic">;</code> but gives a slightly more informative answer because it knows that the next token is what it was actually looking for. This feature is called <span class="emph">single-token deletion</span> because the parser can simply pretend the extraneous token isn’t there and keep going.
</p>
<div class="sidebar">
<div class="sidebar-title">语言理论幽默</div>
<div class="sidebar-content">
<p id="f_0058.html.N155E3">
显然，伟大的尼克劳斯·维尔特<a id="f_0058.html.FNPTR-45" href="#f_0062.html.FOOTNOTE-45">[45]</a>有极好的幽默感。他曾经开玩笑说，在欧洲，人们用“引用”来称呼他（正确的发音是“Ni-klaus Virt”），而在美国，人们用“价值”来称呼他（正确的发音是“Nickle-less Worth”）。
</p><p>
Apparently, the great Niklaus Wirth<a href="#f_0062.html.FOOTNOTE-45">[45]</a> had an
excellent sense of humor. He used to joke that in Europe people called him by
“reference” (properly pronouncing his name “Ni-klaus
Virt”) and that in America people called him by “value”
(pronouncing his name “Nickle-less Worth”).
</p>
<p id="f_0058.html.N155F1">
在 1994 年的 Compiler Construction 会议上，Kristen Nygaard <a id="f_0058.html.FNPTR-46" href="#f_0062.html.FOOTNOTE-46">[46]</a>（Simula 的发明者）讲了一个故事，他在讲授语言理论课程时评论说“强类型就是法西斯主义”，指的是他偏爱类型松散的语言。课后，一位学生走到他面前，问他为什么用力敲击键盘就是法西斯主义。
</p><p>
At the Compiler Construction 1994 conference, Kristen Nygaard<a href="#f_0062.html.FOOTNOTE-46">[46]</a> (inventor
of Simula) told a story about how, while teaching a language theory course, he
commented that “Strong typing is fascism,” referring to his preference
for languages that are loose with types. A student came up to him afterward and
asked why typing hard on the keyboard was fascism.
</p>
</div>
</div>
<p id="f_0058.html.N155FF">
类似地，当解析器检测到缺失的标记时，它可以执行<span class="emph">单个标记插入</span>。让我们切掉结尾<code class="cf ic">}</code>看看会发生什么。
</p><p>
Similarly, the parser can do <span class="emph">single-token insertion</span> when it detects a
missing token. Let’s chop off the closing <code class="cf ic">}</code> to see what happens.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int f(x) { a = 3; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​found assign: a=3;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​method: f​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 3:0 missing '}' at '&lt;EOF&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N15636">
解析器报告找不到所需的结束<code class="cf ic">}</code>标记。
</p><p>
The parser reports that it couldn’t find the required ending <code class="cf ic">}</code> token.
</p>
<p id="f_0058.html.N1563C">
另一种常见的语法错误发生在解析器处于决策点且剩余输入与该规则或子规则的任何替代方案不一致时。例如，如果我们忘记了字段声明中的变量名称，则规则中的任何替代方案<code class="cf keyword">member</code>都不会匹配。解析器会报告没有可行的替代方案。
</p><p>
Another common syntax error occurs when the parser is at a decision point and the
remaining input isn’t consistent with any of the alternatives of that rule or
subrule. For example, if we forget the variable name in a field declaration,
neither of the alternatives in rule <code class="cf keyword">member</code> will match. The
parser reports that there is no viable alternative.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T { int ; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:14 no viable alternative at input 'int;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N15660"><code class="cf ic">int</code>和
之间没有空格，因为我们在空格规则中<code class="cf ic">;</code>告诉了词法分析器
。
<code class="cf methodname">skip</code><code class="cf methodname">WS</code></p><p>
There is no space between <code class="cf ic">int</code> and <code class="cf ic">;</code> because we told the lexer to
<code class="cf methodname">skip</code> in the whitespace <code class="cf methodname">WS</code> rule.
</p>
<p id="f_0058.html.N1566F">
如果存在词汇错误，ANTLR 还会发出错误消息，指出无法匹配作为标记一部分的字符。例如，如果我们发送一个完全未知的字符，我们会收到标记识别错误。
</p><p>
If there are lexical errors, ANTLR also emits an error message indicating the
character or characters it could not match as part of a token. For example, if we
send in a completely unknown character, we get a token recognition error.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class # { int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:6 token recognition error at: '#'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:8 missing ID at '{'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class &lt;missing ID&gt;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0058.html.N1569B">
由于我们没有给出有效的类名，因此单标记插入机制会生成名称，<code class="cf ic">missing ID</code>以使类名标记不为空。要控制解析器如何生成标记，请重写<code class="cf methodname">getMissingSymbol</code>（
<code class="cf class">DefaultErrorStrategy</code>请参阅第 9.5 节“<a href="#f_0062.html.sec.error-handling">更改<em>ANTLR 的错误处理策略</em>”）</a> 。
</p><p>
Since we did not give a valid class name, the single-token insertion mechanism conjured up
the name <code class="cf ic">missing ID</code> so that the class name token was non-null. To take control
of how the parser conjures up tokens, override <code class="cf methodname">getMissingSymbol</code> in
<code class="cf class">DefaultErrorStrategy</code> (see Section 9.5, <a href="#f_0062.html.sec.error-handling">​<em>Altering ANTLR’s Error Handling Strategy</em>​</a>).
</p>
<p id="f_0058.html.N156AA">
您可能已经注意到，本节中的示例运行显示操作按预期执行，尽管存在错误。除了生成良好的错误消息并通过使用标记重新同步输入外，解析器还必须反弹到生成的代码中的适当位置。
</p><p>
You might have noticed that the sample runs in this section show the actions
executing as expected, despite the presence of errors. Aside from producing good
error messages and resynchronizing the input by consuming tokens, parsers also
have to bounce to an appropriate location in the generated code.
</p>
<p id="f_0058.html.N156AD">
例如，当通过<code class="cf keyword">member</code>规则中的
规则匹配成员时<code class="cf keyword">classDef</code>，解析器不应该因为错误的成员定义而放弃
<code class="cf keyword">classDef</code>。这就是为什么解析器仍然能够执行这些操作的原因——语法错误不会导致解析器退出规则。解析器会非常努力地继续寻找有效的类定义。我们将在第 9.3 节“<a href="#f_0060.html.sec.auto_error">自动<em>错误恢复策略”</em></a>中了解有关此主题的所有信息
<a href="#f_0060.html.sec.auto_error">。</a></p><p>
For example, when matching members via rule <code class="cf keyword">member</code> in rule
<code class="cf keyword">classDef</code>, the parser should not bail out of
<code class="cf keyword">classDef</code> upon a bad member definition. That’s why the parser is
still able to execute those actions—a syntax error does not cause the parser to
exit the rule. The parser tries really hard to keep looking for a valid class
definition. We’ll learn all about this topic in Section 9.3, <a href="#f_0060.html.sec.auto_error">​<em>Automatic Error Recovery Strategy</em>​</a>.
But first, let’s look at altering standard error reporting to help with grammar
debugging and to provide better messages for our users.
</p>

</div></div>
<div id="f_0059.html"><div>

<h2 id="f_0059.html.sec.error-listeners">9.2 改变和重定向 ANTLR 错误消息</h2><h2>9.2 Altering and Redirecting ANTLR Error Messages</h2>
<p id="f_0059.html.N156C7">
默认情况下，ANTLR 将所有错误发送到标准错误，但我们可以通过提供接口的实现来更改目标和内容<code class="cf class">ANTLRErrorListener</code>。该接口有一个<code class="cf methodname">syntaxError</code>适用于词法分析器和解析器的方法。方法<code class="cf methodname">syntaxError</code>接收有关错误位置以及错误消息的各种信息。它还接收对解析器的引用，因此我们可以查询它以了解识别状态。
</p><p>
By default, ANTLR sends all errors to standard error, but we can change the destination and
the content by providing an implementation of interface <code class="cf class">ANTLRErrorListener</code>.
The interface has a <code class="cf methodname">syntaxError</code> method that applies to both lexers and
parsers. Method <code class="cf methodname">syntaxError</code> receives all sorts of information about the
location of the error as well as the error message. It also receives a reference to the
parser, so we can query it about the state of recognition.
</p>
<p id="f_0059.html.N156E3">
例如，这里有一个错误监听器（在测试装置中
<code class="cf filename">TestE_Listener.java</code>），它打印出规则调用堆栈，然后是常见的错误消息以及有问题的令牌信息：
</p><p>
For example, here’s an error listener (in test rig
<code class="cf filename">TestE_Listener.java</code>) that prints out the rule invocation
stack followed by the usual error message augmented with offending token
information:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestE_Listener.java">错误/TestE_Listener.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> VerboseListener <strong class="prompt">extends</strong> BaseErrorListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> syntaxError(Recognizer&lt;?, ?&gt; recognizer,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                            <strong class="prompt">Object</strong> offendingSymbol,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                            <strong class="prompt">int</strong> line, <strong class="prompt">int</strong> charPositionInLine,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                            <strong class="prompt">String</strong> msg,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                            RecognitionException e)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">List</strong>&lt;<strong class="prompt">String</strong>&gt; stack = ((<strong class="prompt">Parser</strong>)recognizer).getRuleInvocationStack();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">Collections</strong>.reverse(stack);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.err.println(<em class="string">"rule stack: "</em>+stack);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.err.println(<em class="string">"line "</em>+line+<em class="string">":"</em>+charPositionInLine+<em class="string">" at "</em>+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                           offendingSymbol+<em class="string">": "</em>+msg);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15766">
通过这个定义，我们的应用程序可以在调用启动规则之前轻松地向解析器添加错误监听器。
</p><p>
With this definition, our application can easily add an error listener to the parser before invoking the start rule.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestE_Listener.java">错误/TestE_Listener.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SimpleParser parser = <strong class="prompt">new</strong> SimpleParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.removeErrorListeners(); <em class="comment">// remove ConsoleErrorListener</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.addErrorListener(<strong class="prompt">new</strong> VerboseListener()); <em class="comment">// add ours</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.prog(); <em class="comment">// parse as usual</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N1578B">
在添加错误监听器之前，我们需要删除标准控制台错误监听器，这样我们就不会收到重复的错误消息。
</p><p>
Right before we add our error listener, we need to remove the standard console error
listener so that we don’t get repeated error messages.
</p>
<p id="f_0059.html.N1578E">
让我们看看对于包含额外的类名和缺少的字段名的类定义，错误消息现在是什么样的。
</p><p>
Let’s see what the error messages look like now for a class definition containing
an extra class name and missing field name.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac TestE_Listener.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestE_Listener</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T T {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int ;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule stack: [prog, classDef]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:8 at [@2,8:8='T',&lt;9&gt;,1:8]: extraneous input 'T' expecting '{'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule stack: [prog, classDef, member]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:6 at [@5,18:18=';',&lt;8&gt;,2:6]: no viable alternative at input 'int;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N157C7">
Stack<code class="cf ic">[prog, classDef]</code>表示解析器处于规则中
<code class="cf keyword">classDef</code>，由 调用<code class="cf keyword">prog</code>。请注意，标记信息包含输入流中的字符位置。这对于像开发环境一样突出显示输入中的错误很有用。例如，token<code class="cf ic">[@2,8:8=’T’,&lt;9&gt;,1:8]</code>表示它是标记流中的第三个标记（索引 2，从 0 开始），范围从字符 8 到 8，标记类型为 9，位于第 1 行，并且位于字符位置 8（将制表符视为一个字符时从 0 开始计数）。
</p><p>
Stack <code class="cf ic">[prog, classDef]</code> indicates that the parser is in rule
<code class="cf keyword">classDef</code>, which was called by <code class="cf keyword">prog</code>. Notice
that the token information contains the character position within the input
stream. This is useful for highlighting errors in the input like development
environments do. For example, token <code class="cf ic">[@2,8:8=’T’,&lt;9&gt;,1:8]</code> indicates
that it is the third token in the token stream (index 2 from 0), ranges from
characters 8 to 8, has token type 9, resides on line 1, and is at character
position 8 (counting from 0 in treating tabs as one character).
</p>
<p id="f_0059.html.N157D6">
通过改变方法，我们可以轻松地使用 Java Swing 将该消息发送到对话框<code class="cf methodname">syntaxError</code>。
</p><p>
We can just as easily send that message to a dialog box using Java Swing by
altering the <code class="cf methodname">syntaxError</code> method.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestE_Dialog.java">错误/TestE_Dialog.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> DialogListener <strong class="prompt">extends</strong> BaseErrorListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">void</strong> syntaxError(Recognizer&lt;?, ?&gt; recognizer,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">Object</strong> offendingSymbol,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">int</strong> line, <strong class="prompt">int</strong> charPositionInLine,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">String</strong> msg,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                RecognitionException e)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">List</strong>&lt;<strong class="prompt">String</strong>&gt; stack = ((<strong class="prompt">Parser</strong>)recognizer).getRuleInvocationStack();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">Collections</strong>.reverse(stack);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">StringBuilder</strong> buf = <strong class="prompt">new</strong> <strong class="prompt">StringBuilder</strong>();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"rule stack: "</em>+stack+<em class="string">" "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        buf.append(<em class="string">"line "</em>+line+<em class="string">":"</em>+charPositionInLine+<em class="string">" at "</em>+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                   offendingSymbol+<em class="string">": "</em>+msg);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">JDialog</strong> dialog = <strong class="prompt">new</strong> <strong class="prompt">JDialog</strong>();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">Container</strong> contentPane = dialog.getContentPane();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        contentPane.add(<strong class="prompt">new</strong> <strong class="prompt">JLabel</strong>(buf.toString()));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        contentPane.setBackground(<strong class="prompt">Color</strong>.white);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        dialog.setTitle(<em class="string">"Syntax error"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        dialog.pack();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        dialog.setLocationRelativeTo(null);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        dialog.setDefaultCloseOperation(<strong class="prompt">JFrame</strong>.DISPOSE_ON_CLOSE);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        dialog.setVisible(true);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N1589A"><code class="cf class">TestE_Dialog</code>在输入上
运行测试装置<code class="cf ic">class T { int int i; }</code>会弹出如下对话框：
</p><p>
Running test rig <code class="cf class">TestE_Dialog</code> on input <code class="cf ic">class T { int int i; }</code> pops up a dialog box such as the following:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/错误对话框.png">
</div>
<p id="f_0059.html.N158A8">
再举一个例子，让我们构建一个错误监听器
<code class="cf filename">TestE_Listener2.java</code>，打印出带有下划线的错误标记的行，如下面的示例运行所示：
</p><p>
As another example, let’s build an error listener,
<code class="cf filename">TestE_Listener2.java</code>, that prints out the line with the
offending token underlined, as in the following sample run:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac TestE_Listener2.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestE_Listener2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T XYZ {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int ;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:8 extraneous input 'XYZ' expecting '{'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T XYZ {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ^^^​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:6 no viable alternative at input 'int;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  int ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      ^​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N158F0">
为了方便起见，我们将忽略制表符——<code class="cf variable">charPositionInLine</code>
不是列号，因为制表符大小没有统一定义。这是一个错误侦听器实现，它像我们刚刚看到的那样在输入中用下划线标出错误位置：
</p><p>
To make things easier, we’ll ignore tabs—<code class="cf variable">charPositionInLine</code>
isn’t the column number because tab size isn’t universally defined. Here’s an
error listener implementation that underlines error locations in the input like we
just saw:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestE_Listener2.java">错误/TestE_Listener2.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> UnderlineListener <strong class="prompt">extends</strong> BaseErrorListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">void</strong> syntaxError(Recognizer&lt;?, ?&gt; recognizer,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">Object</strong> offendingSymbol,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">int</strong> line, <strong class="prompt">int</strong> charPositionInLine,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                <strong class="prompt">String</strong> msg,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                RecognitionException e)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.err.println(<em class="string">"line "</em>+line+<em class="string">":"</em>+charPositionInLine+<em class="string">" "</em>+msg);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        underlineError(recognizer,(Token)offendingSymbol,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                       line, charPositionInLine);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">protected</strong> <strong class="prompt">void</strong> underlineError(Recognizer recognizer,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                  Token offendingToken, <strong class="prompt">int</strong> line,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                  <strong class="prompt">int</strong> charPositionInLine) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CommonTokenStream tokens =​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            (CommonTokenStream)recognizer.getInputStream();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> input = tokens.getTokenSource().getInputStream().toString();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong>
<strong class="prompt">[]</strong> lines = input.split(<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> errorLine = lines[line - 1];​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.err.println(errorLine);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">for</strong> (<strong class="prompt">int</strong> i=0; i&lt;charPositionInLine; i++) <strong class="prompt">System</strong>.err.print(<em class="string">" "</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> start = offendingToken.getStartIndex();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> stop = offendingToken.getStopIndex();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( start&gt;=0 &amp;&amp; stop&gt;=0 ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">for</strong> (<strong class="prompt">int</strong> i=start; i&lt;=stop; i++) <strong class="prompt">System</strong>.err.print(<em class="string">"^"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">System</strong>.err.println();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N159C3">

关于错误监听器，还有最后一点需要了解。当解析器检测到模棱两可的输入序列时，它会通知错误监听器。
<code class="cf class">ConsoleErrorListener</code>但是，默认错误监听器不会将任何内容打印到控制台。正如我们在第 2.3 节“<a href="#f_0017.html.sec.ambiguity">你<em>不能在核反应堆中放入太多的水”中</em></a><code class="cf ic">f();</code>看到的那样，模棱两可的输入可能表示我们的语法存在错误；解析器不应该通知我们的用户。让我们回顾一下该节中的模棱两可的语法，它可以以两种不同的方式
<a href="#f_0017.html.sec.ambiguity">匹配</a>输入
。</p><p>

There’s one final thing to know about error listeners. When the parser detects an
ambiguous input sequence, it notifies the error listener. The default error listener,
<code class="cf class">ConsoleErrorListener</code>, however, doesn’t print anything to the
console. As we saw in Section 2.3, <a href="#f_0017.html.sec.ambiguity">​<em>You Can’t Put Too Much Water into a Nuclear Reactor</em>​</a>, ambiguous input likely
indicates an error in our grammar; the parser should not inform our users. Let’s
look back at the ambiguous grammar from that section that can match input
<code class="cf ic">f();</code> in two different ways.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Ambig.g4">错误/Ambig.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Ambig;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: expr <em class="string">';'</em>        <em class="comment">// expression statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ID <em class="string">'('</em> <em class="string">')'</em> <em class="string">';'</em>  <em class="comment">// function call statement</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: ID <em class="string">'('</em> <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\r\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15A24">
如果我们测试语法，我们不会看到针对歧义输入的警告。
</p><p>
If we test the grammar, we don’t see a warning for the ambiguous input.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Ambig.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Ambig*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Ambig stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f();</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15A48">

当解析器检测到歧义时，要听到它，告诉解析器使用<code class="cf class">DiagnosticErrorListener</code>using
的实例<code class="cf methodname">addErrorListener</code>。
</p><p>

To hear about it when the parser detects an ambiguity, tell the parser to use an
instance of <code class="cf class">DiagnosticErrorListener</code> using
<code class="cf methodname">addErrorListener</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.removeErrorListeners(); <em class="comment">// remove ConsoleErrorListener</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.addErrorListener(<strong class="prompt">new</strong> DiagnosticErrorListener());​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15A65">
您还应该告知解析器，您对所有歧义警告感兴趣，而不仅仅是那些它能快速检测到的警告。为了提高效率，ANTLR 的决策机制并不总是追踪完整的歧义信息。以下是如何让解析器报告所有歧义的方法：
</p><p>
You should also inform the parser that you’re interested in all ambiguity warnings, not just those it can detect quickly. In the interest of efficiency, ANTLR’s decision-making mechanism doesn’t always chase down full ambiguity information. Here’s how to make the parser report all ambiguities:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.getInterpreter()​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    .setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15A7D"><code class="cf class">TestRig</code>如果您通过别名
使用<code class="cf commandname">grun</code>
，请使用选项<code class="cf commandoption">-diagnostics</code>让它
<code class="cf class">DiagnosticErrorListener</code>代替默认控制台错误监听器（并打开<code class="cf variable">LL_EXACT_AMBIG_DETECTION</code>）。
</p><p>
If you’re using <code class="cf class">TestRig</code> via the <code class="cf commandname">grun</code>
alias, use option <code class="cf commandoption">-diagnostics</code> to have it use
<code class="cf class">DiagnosticErrorListener</code> instead of the default console error listener (and turn on <code class="cf variable">LL_EXACT_AMBIG_DETECTION</code>).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Ambig stat -diagnostics</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f();</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:3 reportAttemptingFullContext d=0, input='f();'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:3 reportAmbiguity d=0: ambigAlts={1, 2}, input='f();'​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0059.html.N15AB8">
输出显示解析器还调用。当<span class="emph">SLL(*)</span>解析失败且解析器启用更强大的完整<span class="emph">ALL(*)</span>机制时， <code class="cf methodname">reportAttemptingFullContext</code>ANTLR 会调用此方法。请参阅第 13.7 节<a href="#f_0084.html.sec.maximizing-speed">“最大化</a><a href="#f_0084.html.sec.maximizing-speed"><em>解析器速度”</em></a>。
<span class="emph"></span><span class="emph"></span><a href="#f_0084.html.sec.maximizing-speed"><em></em></a></p><p>
The output shows that the parser also calls <code class="cf methodname">reportAttemptingFullContext</code>. ANTLR calls this method when <span class="emph">SLL(*)</span> parsing fails and the parser engages the more powerful full <span class="emph">ALL(*)</span> mechanism. See Section 13.7, <a href="#f_0084.html.sec.maximizing-speed">​<em>Maximizing Parser Speed</em>​</a>.
</p>
<p id="f_0059.html.N15ACE">
在开发过程中使用诊断错误侦听器是个好主意，因为 ANTLR 工具无法静态地（在生成解析器时）警告您有关歧义语法构造的信息。只有解析器才能在 ANTLR v4 中检测歧义。这就是 Java 中的静态类型与 Python 中的动态类型之间的区别。
</p><p>
It’s a good idea to use the diagnostics error listener during development since the ANTLR
tool can’t warn you about ambiguous grammar constructs statically (when generating parsers).
Only the parser can detect ambiguities in ANTLR v4. It’s the difference between static
typing in Java, say, and the dynamic typing in Python.
</p>
<div class="sidebar" id="f_0059.html.sb.newerrorstuff">
<div class="sidebar-title">ANTLR v4 中的改进</div>
<div class="sidebar-content">
<p id="f_0059.html.N15AE8">
v4 中有两个与错误相关的重要改进：ANTLR 的内联错误恢复功能更加出色，使程序员可以更轻松地更改错误处理策略。当 Sun Microsystems 使用 ANTLR v3 为 JavaFX 构建解析器时，它注意到一个放错位置的分号可能会迫使解析器停止查找类成员列表（通过<code class="cf ic">member+</code>）。现在，v4 解析器会在子规则识别之前和期间尝试重新同步，而不是吞噬标记并退出当前规则。第二个改进使程序员可以按照策略模式指定错误处理机制。
	</p><p>
There are two error-related important improvements in v4: ANTLR does much better inline
error recovery and makes it much easier for programmers to alter the error handling
strategy. When Sun Microsystems was building a parser for JavaFX with ANTLR v3, it
noticed that a single misplaced semicolon could force the parser to stop looking for a list
of, say, class members (via <code class="cf ic">member+</code>). Now, v4 parsers attempt to resynchronize
before and during subrule recognition instead of gobbling tokens and exiting the current
rule. The second improvement lets programmers specify an error handling mechanism following
the Strategy pattern.
	</p>
</div>
</div>
<p id="f_0059.html.N15AEE">
现在我们对 ANTLR 解析器生成的消息类型以及如何调整和重定向它们有了很好的了解，让我们来探索错误恢复。 
</p><p>
Now that we have a good idea about the kinds of messages ANTLR parsers generate
and how to tweak and redirect them, let’s explore error recovery. 
</p>

</div></div>
<div id="f_0060.html"><div>

<h2 id="f_0060.html.sec.auto_error">9.3 自动错误恢复策略</h2><h2>9.3 Automatic Error Recovery Strategy</h2>
<p id="f_0060.html.N15AF6">
错误恢复是让解析器在发现语法错误后继续运行的关键。原则上，最好的错误恢复是人工手动编写递归下降解析器。但根据我的经验，手动进行错误恢复非常困难，因为它非常繁琐，而且很容易搞砸。在最新版本的 ANTLR 中，我结合了我多年来学到的所有技巧，为 ANTLR 语法自动提供良好的错误恢复。
</p><p>
Error recovery is what allows the parser to continue after finding a syntax error.
In principle, the best error recovery would come from the human touch in a
handwritten recursive-descent parser. In my experience, though, it’s really tough
to get good error recovery by hand because it’s so tedious and easy to screw up.
In this latest version of ANTLR, I’ve incorporated every bit of jujitsu I’ve
learned and picked up over the years to provide good error recovery automatically
for ANTLR grammars.
</p>
<p id="f_0060.html.N15AFF">
ANTLR 的错误恢复机制基于 Niklaus Wirth 在
<em>算法 + 数据结构 = 程序</em>&nbsp;[Wir78] 中的早期思想（以及 Rodney Topor 的《<em>关于递归下降解析器中的错误恢复的注释》</em> &nbsp;[Top82]），但也包括 Josef Grosch 在他的 CoCo 解析器生成器中的好主意（《<em>递归下降解析器中的高效和舒适的错误恢复</em>&nbsp;》[Gro90]）。 
</p><p>
ANTLR’s error recovery mechanism is based upon Niklaus Wirth’s early ideas in
<em>Algorithms + Data Structures = Programs</em>&nbsp;[Wir78] (as well as Rodney Topor’s <em>A Note on Error Recovery in Recursive Descent Parsers</em>&nbsp;[Top82])
but also includes Josef Grosch’s good ideas from his CoCo parser generator
(<em>Efficient and Comfortable Error Recovery in Recursive Descent Parsers</em>&nbsp;[Gro90]). 
</p>
<p id="f_0060.html.N15B25">
简而言之，ANTLR 如何将这些想法结合起来：如果可能，解析器会在出现不匹配的标记错误时执行
<span class="firstuseinline">单个标记插入</span>和<span class="firstuseinline">单个标记删除</span>。如果不行，解析器会吞噬标记，直到找到可以合理遵循当前规则的标记，然后返回，继续执行，就像什么都没发生过一样。在本节中，我们将了解这些术语的含义，并探讨 ANTLR 如何在各种情况下从错误中恢复。让我们从 ANTLR 使用的基本恢复策略开始。
</p><p>
Here is how ANTLR uses those ideas together in a nutshell: parsers perform
<span class="firstuseinline">single-token insertion</span> and <span class="firstuseinline">single-token
deletion</span> upon mismatched token errors if possible. If not, parsers
gobble up tokens until they find a token that could reasonably follow the
current rule and then return, continuing as if nothing had happened. In this
section, we’ll see what those terms mean and explore how ANTLR recovers from
errors in various situations. Let’s begin with the fundamental recovery strategy
that ANTLR uses.
</p>
<h3 id="f_0060.html.sec.gobble">通过扫描以下令牌进行恢复</h3><h3>Recovery by Scanning for Following Tokens</h3>
<p id="f_0060.html.N15B33">
当面对真正混乱的输入时，当前规则无法继续，因此解析器通过吞噬标记来恢复，直到它认为它已重新同步，然后返回到调用规则。我们可以将此称为同步
<span class="firstuseinline">和返回</span>策略。有些人称之为“恐慌模式”，但它工作得非常好。解析器知道它无法将当前输入与当前规则匹配。它只能在前瞻与解析器退出规则后应该匹配的内容一致之前抛出标记。例如，如果赋值语句中存在语法错误，则抛出标记直到解析器看到分号或其他语句终止符是非常有意义的。虽然激烈，但有效。正如我们将看到的，ANTLR 尝试在规则内恢复，然后再回到这个基本策略。
</p><p>
When faced with truly borked-up input, the current rule can’t continue, so the
parser recovers by gobbling up tokens until it thinks that it has resynchronized
and then returns to the calling rule. We can call this the
<span class="firstuseinline">sync-and-return</span> strategy. Some people call this “panic
mode,” but it works remarkably well. The parser knows it can’t match the current
input with the current rule. It can  throw out tokens only until the lookahead is
consistent with something that should match after the parser exits from the rule.
For example, if there is a syntax error within an assignment statement, it makes a
great deal of sense to throw out tokens until the parser sees a semicolon or other
statement terminator. Drastic, but effective. As we’ll see, ANTLR tries to
recover within the rule before falling back on this basic strategy.
</p>
<p id="f_0060.html.N15B43">
每个 ANTLR 生成的规则方法都包装在一个<code class="cf ic">try</code>-中<code class="cf ic">catch</code>，它通过报告错误并在返回之前尝试恢复来响应语法错误。
	</p><p>
Each ANTLR-generated rule method is wrapped in a <code class="cf ic">try</code>-<code class="cf ic">catch</code> that
responds to syntax errors by reporting the error and attempting to recover before
returning.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">try</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">catch</strong> (RecognitionException re) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    _errHandler.reportError(this, re);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    _errHandler.recover(this, re);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15B6E"><a href="#f_0062.html.sec.error-handling">我们将在第 9.5 节“改变<em>ANTLR 的错误</em></a>
处理策略”中更详细地介绍错误处理策略<a href="#f_0062.html.sec.error-handling">，</a>但现在，我们可以总结
为消耗标记，直到在<span class="firstuseinline">重新同步集中</span><code class="cf methodname">recover</code>找到一个标记
。重新同步集是调用堆栈上所有规则的规则引用<span class="firstuseinline">后续集的</span>并集。规则引用的后续集是可以在该引用之后立即匹配而无需离开当前规则的标记集。因此，例如，给定替代方案，规则引用的后续集为 {';'}。如果替代方案只是
，则后续集将为空。
	<span class="firstuseinline"></span><span class="firstuseinline"></span><code class="cf ic">assign ’;’</code><code class="cf keyword">assign</code><code class="cf ic">assign</code></p><p>
We’ll look at the error handling strategy in more detail in Section 9.5, <a href="#f_0062.html.sec.error-handling">​<em>Altering ANTLR’s Error Handling Strategy</em>​</a>, but, for now, we can summarize
<code class="cf methodname">recover</code> as consuming tokens until it finds one in the
<span class="firstuseinline">resynchronization set</span>. The resynchronization set is the union
of rule reference <span class="firstuseinline">following sets</span> for all the rules on the
invocation stack. The following set for a rule reference is the set of tokens that
can match immediately following that reference and without leaving the current
rule. So, for example, given alternative <code class="cf ic">assign ’;’</code>, the following set for
rule reference <code class="cf keyword">assign</code> is {’;’}. If the alternative were just
<code class="cf ic">assign</code>, the following set would be empty.
	</p>
<p id="f_0060.html.N15B8A">
通过一个例子来锁定重新同步集包含的内容是值得的。考虑以下语法，并想象在每次规则调用时，解析器都会跟踪每次规则调用的以下集合：
	</p><p>
It’s worthwhile going through an example to lock in what resynchronization sets
contain. Consider the following grammar, and imagine that, at each rule invocation,
the parser tracks the following set for every rule invocation:
	</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/F.g4">错误/F.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> F;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​group​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : <em class="string">'['</em> expr <em class="string">']'</em>      <em class="comment">// Tokens following ref to expr: {']'}</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'('</em> expr <em class="string">')'</em>      <em class="comment">// Tokens following ref to expr: {')'}</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: atom <em class="string">'^'</em> INT ;    <em class="comment">// Tokens following ref to atom: {'^'}</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​atom: ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\r\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15BD4"><code class="cf ic">[1^2]</code>考虑下图中

左侧的输入解析树：</p><p>
Consider the parse tree on the left for input <code class="cf ic">[1^2]</code> in the following
diagram:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/combined-Fgood-F1.png">
</div>
<p id="f_0060.html.N15BDF"><code class="cf ic">1</code>在规则中
匹配标记时<code class="cf keyword">atom</code>，调用堆栈为 [ <code class="cf keyword">group</code>，<code class="cf keyword">expr</code>，<code class="cf keyword">atom</code>]（<code class="cf keyword">group</code>称为<code class="cf keyword">expr</code>，其称为
<code class="cf keyword">atom</code>）。通过查看调用堆栈，我们可以准确地知道可以遵循解析器调用的每个规则以将我们带到当前位置的标记集。以下集合仅考虑当前规则内的标记，因此，在运行时，我们可以仅组合与当前调用堆栈相关联的集合。换句话说，我们不能同时
<code class="cf keyword">expr</code>从 的两个替代方案中
获得规则。<code class="cf keyword">group</code></p><p>
When matching token <code class="cf ic">1</code> in rule <code class="cf keyword">atom</code>, the call stack is
[<code class="cf keyword">group</code>, <code class="cf keyword">expr</code>, <code class="cf keyword">atom</code>]
(<code class="cf keyword">group</code> called <code class="cf keyword">expr</code>, which called
<code class="cf keyword">atom</code>). By looking at the call stack, we know precisely the set
of tokens that can follow every rule the parser has called to get us to the current
position. Following sets consider tokens only within the current rule so that, at
runtime, we can combine just the sets associated with the current call stack. In
other words, we can’t get to rule <code class="cf keyword">expr</code> from both alternatives of
<code class="cf keyword">group</code> at the same time.
</p>
<p id="f_0060.html.N15C00">
结合从语法 中的注释中提取的以下集合<code class="cf class">F</code>，我们得到了一个重新同步集 { <code class="cf ic">’^’</code>，<code class="cf ic">’]’</code>}。要了解为什么这是我们想要的集合，让我们观察一下当解析器遇到错误输入 时会发生什么<code class="cf ic">[]</code>。我们得到了前面并排图表中右侧所示的解析树。在 中<code class="cf keyword">atom</code>，解析器发现当前标记<code class="cf ic">]</code>与 的任何一个替代方案都不一致
<code class="cf keyword">atom</code>。为了重新同步，解析器会使用标记，直到找到来自重新同步集的标记。在这种情况下，当前标记
<code class="cf ic">]</code>开始作为重新同步集的成员，因此解析器实际上并不会使用任何标记来在 中进行重新同步<code class="cf keyword">atom</code>。
</p><p>
Combining the following sets pulled from the comments in grammar <code class="cf class">F</code>,
we get a resynchronization set of {<code class="cf ic">’^’</code>, <code class="cf ic">’]’</code>}. To see why this is
the set we want, let’s watch what happens when the parser encounters erroneous
input <code class="cf ic">[]</code>. We get the parse tree shown on the right in the earlier side-by-side
diagram. In <code class="cf keyword">atom</code>, the parser discovers that the current
token, <code class="cf ic">]</code>, isn’t consistent with either alternative of
<code class="cf keyword">atom</code>. To resynchronize, the parser consumes tokens until it
finds a token from the resynchronization set. In this case, current token
<code class="cf ic">]</code> starts out as a member of the resynchronization set so the parser
doesn’t actually consume any tokens to resynchronize in <code class="cf keyword">atom</code>.
</p>
<p id="f_0060.html.N15C1E">
在规则中完成恢复过程后<code class="cf keyword">atom</code>，解析器返回到规则<code class="cf keyword">expr</code>，但立即发现它没有令牌<code class="cf ic">^</code>。该过程重复进行，解析器使用令牌，直到在规则的重新同步集中找到某些内容
<code class="cf keyword">expr</code>。的重新同步集是第一个替代中引用的<code class="cf keyword">expr</code>以下集合：{ }。同样，解析器不消耗任何内容并退出，返回规则的第一个替代。现在，解析器在引用之后找到了它正在寻找的内容。它成功匹配了中的，并且解析器现在已正确重新同步。
	<code class="cf keyword">expr</code><code class="cf keyword">group</code><code class="cf ic">’]’</code><code class="cf keyword">expr</code><code class="cf keyword">group</code><code class="cf ic">expr</code><code class="cf ic">’]’</code><code class="cf keyword">group</code></p><p>
After finishing the recovery process in rule <code class="cf keyword">atom</code>, the parser
returns to rule <code class="cf keyword">expr</code> but immediately discovers that it doesn’t
have the <code class="cf ic">^</code> token. The process repeats itself, and the parser consumes
tokens until it finds something in the resynchronization set for rule
<code class="cf keyword">expr</code>. The resynchronization set for <code class="cf keyword">expr</code> is
the following set for the <code class="cf keyword">expr</code> reference in the first
alternative of <code class="cf keyword">group</code>: { <code class="cf ic">’]’</code> }. Again, the parser does
not consume anything and exits <code class="cf keyword">expr</code>, returning to the first
alternative of rule <code class="cf keyword">group</code>. Now, the parser finds exactly what
it is looking for following the reference to <code class="cf ic">expr</code>. It successfully
matches the <code class="cf ic">’]’</code> in <code class="cf keyword">group</code>, and the parser is now
properly resynchronized.
	</p>
<p id="f_0060.html.N15C48">
在恢复期间，ANTLR 解析器会避免发出级联错误消息（借用 Grosch 的理念）。也就是说，解析器会针对每个语法错误发出一条错误消息，直到成功从该错误中恢复。通过使用在语法错误时设置的简单布尔变量，解析器会避免发出进一步的错误，直到解析器成功匹配标记并重置变量。（请参阅<code class="cf variable">errorRecoveryMode</code>类中的
字段<code class="cf class">DefaultErrorStrategy</code>。）
</p><p>
During recovery, ANTLR parsers avoid emitting cascading error messages (an idea
borrowed from Grosch). That is, parsers emit a single error message for each
syntax error until they successfully recover from that error. Through the use of a
simple Boolean variable, set upon syntax error, the parser avoids emitting further
errors until the parser successfully matches a token and resets the variable. (See
field <code class="cf variable">errorRecoveryMode</code> in class
<code class="cf class">DefaultErrorStrategy</code>.)
</p>
<div class="sidebar" id="f_0060.html.sb.fOLLOW">
<div class="sidebar-title">关注集与正在关注集</div>
<div class="sidebar-content">
<p id="f_0060.html.N15C58">
熟悉语言理论的人会想知道规则的重新同步集是否<code class="cf keyword">atom</code>只是
<span class="emph">FOLLOW</span> ( <code class="cf keyword">atom</code>)，即在某些上下文中可以跟随对 的引用的所有可行标记的集合。不幸的是，<span class="emph">事情</span><code class="cf keyword">atom</code>并没有那么简单，必须动态计算重新同步集以获取可以在特定上下文而不是所有上下文中遵循规则的标记集。FOLLOW ( ) 是 {
 ， }，它包括可以在两个上下文（的替代方案 1 和 2）中
跟随对 的引用的所有标记。但很明显，在运行时，解析器
一次只能从一个位置调用。请注意，
 <span class="emph">FOLLOW</span> ( ) 是，如果解析器重新同步到该标记而不是重新同步集 { ，
 }，它将消耗直到文件末尾，因为输入流上
	没有
。<span class="emph"></span><code class="cf keyword">expr</code><code class="cf ic">’)’</code><code class="cf ic">’]’</code><code class="cf keyword">expr</code><code class="cf keyword">group</code><code class="cf keyword">expr</code><span class="emph"></span><code class="cf keyword">atom</code><code class="cf ic">’^’</code><code class="cf ic">’^’</code><code class="cf ic">’]’</code><code class="cf ic">’^’</code></p><p>
Those familiar with language theory will wonder whether the resynchronization set
for rule <code class="cf keyword">atom</code> is just
<span class="emph">FOLLOW</span>(<code class="cf keyword">atom</code>), the set of all viable tokens that
can follow references to <code class="cf keyword">atom</code> in some context. It isn’t that
simple, unfortunately, and the resynchronization sets must be computed dynamically
to get the set of tokens that can follow the rule in a particular context rather
than in all contexts. <span class="emph">FOLLOW</span>(<code class="cf keyword">expr</code>) is {
<code class="cf ic">’)’</code>, <code class="cf ic">’]’</code> }, which includes all tokens that can follow references
to <code class="cf keyword">expr</code> in both contexts (alternatives 1 and 2 of
<code class="cf keyword">group</code>). Clearly, though, at runtime the parser can call
<code class="cf keyword">expr</code> from only one location at a time. Note that
<span class="emph">FOLLOW</span>(<code class="cf keyword">atom</code>) is <code class="cf ic">’^’</code>, and if the parser
resynchronized to that token instead of resynchronization set {<code class="cf ic">’^’</code>,
<code class="cf ic">’]’</code>}, it would consume until the end of file because there is no
<code class="cf ic">’^’</code> on the input stream.
	</p>
</div>
</div>
<p id="f_0060.html.N15C95">
在许多情况下，ANTLR 可以更智能地恢复，而不是消耗直到重新同步设置并从当前规则返回。尝试“修复”输入并继续在同一规则内是值得的。在接下来的几节中，我们将研究解析器如何从不匹配的标记和子规则中的错误中恢复。
</p><p>
In many cases, ANTLR can recover more intelligently than consuming until the
resynchronization set and returning from the current rule. It pays to attempt to
“repair” the input and continue within the same rule. Over the next few
sections, we’ll look at how the parser recovers from mismatched tokens and errors
within subrules.
</p>
<h3 id="f_0060.html.sec.mismatched-tokens">从不匹配的令牌中恢复</h3><h3>Recovering from Mismatched Tokens</h3>
<p id="f_0060.html.N15CA0">
解析过程中最常见的操作之一是“匹配标记”。对于<code class="cf variable">T</code>语法中的每个标记引用，解析器都会调用
<code class="cf ic">match(T)</code>。如果当前标记不是<code class="cf variable">T</code>，
<code class="cf methodname">match</code>则通知错误侦听器并尝试重新同步。要重新同步，它有三个选择。它可以删除一个标记，可以召唤一个标记，或者可以放弃并抛出异常以启用基本的同步和返回机制。
</p><p>
One of the most common operations during parsing is “match token.” For every
token reference, <code class="cf variable">T</code>, in the grammar, the parser invokes
<code class="cf ic">match(T)</code>. If the current token isn’t <code class="cf variable">T</code>,
<code class="cf methodname">match</code> notifies the error listener(s) and attempts to
resynchronize. To resynchronize, it has three choices. It can delete a token, it
can conjure one up, or it can punt and throw an exception to engage the basic
sync-and-return mechanism.
</p>
<p id="f_0060.html.N15CAF">
如果有意义的话，删除当前标记是重新同步的最简单方法。让我们<code class="cf keyword">classDef</code>从语法中的简单类定义语言重新审视规则<code class="cf class">Simple</code>。
</p><p>
Deleting the current token is the easiest way to resynchronize, if it makes sense
to do so. Let’s revisit rule <code class="cf keyword">classDef</code> from our simple class
definition language in grammar <code class="cf class">Simple</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Simple.g4">错误/Simple.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​classDef​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'class'</em> ID <em class="string">'{'</em> member+ <em class="string">'}'</em> <em class="comment">// a class has one or more members</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"class "</em>+$ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15CE1">
	 给定输入<code class="cf ic">class 9 T { int i; }</code>，解析器将删除<code class="cf ic">9</code>
     并继续在规则内匹配类主体。下图说明了解析器使用 后输入的状态
     <code class="cf ic">class</code>：
</p><p>
	 Given input <code class="cf ic">class 9 T { int i; }</code>, the parser will delete <code class="cf ic">9</code>
     and keep going within the rule to match the class body. The following image
     illustrates the state of the input after the parser has consumed
     <code class="cf ic">class</code>:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAAA5CAAAAADIRzxeAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAI4SURBVFjD7dSxauMwGABgDUehHE0pLl1qD+3ig9BgWig4tEOL4LZu9c0FEygebgipx9Ch4M3gzUs6dQl9Az2BwXsmv4JfQSfFDrYbCeTWdtJD//DH/oXQF+m3AN6SAJsGSIgI5BkIRY838ENsfiliNuQRBiJxbi/YATj1AW/CFZIQCfmPIFO4JRAHCEB807RZENNUVdPsDoLUKOrPmDtil9f+LGRiKAaBeIaiT4IAakae1iB0NdtqDTJVnMCjOzINHrTA0egLTeuQMUGMzdYgcJgfjQN1olHuvCytQ6K+Zant7QiEGeRBmwSkUaZDxcsS46uZIfO5NYizXNMBBJR1rO6s0vrnO+4vxCHRe/ROknCzwl1dJ4aJokMQ/NHIyzIxILZqRTUgfs/vkSQM2a6bVUIkREK+F2ToiMTAmrEDcOq/eBPOOJC3K6EYGDfsOOHU+7wJtwkbstH4KuRvzXpbkNef7Lq/0zHkGrww62fgtVNIegAuWfXkEFx0CvGPjvcSRv3p6Hg/7RKCsVuzLiESsjFIUrPeGqSx+MaQOFz+eLQL5iFOvQS7tQ+iCQjK+hDSOxxifH+KcDr66FwxQ3cuyPwsJB6RJWL6CNESVB3OmShEF3GZ2TzEncf32SOFuHF1uGBi1yszm4ecQgjSAoKqwwUTw6TMbBwSk+12Q8Q7moI5CivMRiFkFdqDmPxpyIYUTOpo62jKkW96OK86f6+Y3gFBdwHJb3JODzCYrUG+wOwSUick5GP8A+/5lYpjpV40AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjQ3LTA2OjAw5zaaFAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo0Ny0wNjowMJZrIqgAAAAfdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADEzNng3MCswKzB2sovWAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS41DUCDV0wAAAAASUVORK5CYII=" alt="图片/错误/额外令牌.png">
</div>
<p id="f_0060.html.N15CF2"><code class="cf ic">LA(1)</code>和
标签<code class="cf ic">LA(2)</code>标记了前瞻的第一个标记（当前标记）和前瞻的第二个标记。 期望<code class="cf ic">match(ID)</code>
是<code class="cf ic">LA(1)</code>，<code class="cf keyword">ID</code>但事实并非如此。但是，下一个标记<code class="cf ic">LA(2)</code>实际上是<code class="cf keyword">ID</code>。要恢复，我们只需删除当前标记（作为噪声），使用
<code class="cf keyword">ID</code>我们期望的 ，然后退出<code class="cf methodname">match</code>。
</p><p>
The <code class="cf ic">LA(1)</code> and <code class="cf ic">LA(2)</code> labels mark the first token of lookahead
(the current token) and the second token of lookahead. The <code class="cf ic">match(ID)</code>
expects <code class="cf ic">LA(1)</code> to be an <code class="cf keyword">ID</code>, but it’s not. However, the
next token, <code class="cf ic">LA(2)</code>, is in fact an <code class="cf keyword">ID</code>. To recover, we
just have to delete the current token (as noise), consume the
<code class="cf keyword">ID</code> we were expecting, and exit <code class="cf methodname">match</code>.
</p>
<p id="f_0060.html.N15D10">
  如果解析器无法通过删除标记来重新同步，它会尝试插入标记。假设我们忘记了看到输入的<code class="cf keyword">ID</code>so
   。匹配后  ，输入状态如下所示：
<code class="cf keyword">classDef</code><code class="cf ic">class { int i; }</code><code class="cf ic">class</code></p><p>
  If the parser can’t resynchronize by deleting a token, it attempts to insert a token
  instead. Let’s say we forgot the <code class="cf keyword">ID</code> so that
  <code class="cf keyword">classDef</code> sees input <code class="cf ic">class { int i; }</code>. After matching  <code class="cf ic">class</code>, the input state looks like this:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAAA5CAAAAAAdeSpWAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAGxSURBVFjD7dSxagIxGAfwQIfiYocb7S0OzSCFgy5VdLAEupUOFcciHC4Z2yOjazYh2y0WOh4une8JhOyd7hV8hTRnLLUlQqK5UOH+w3eHZ+5HviQHhN+A2qvMe+wbpdUbanN7pf99eFfoPYCNAhb6PHX2PLjO93jMKOBTn9fungf92qs9t94MmXlLRx4GRl4c+/UuXfQziYJIejQKYMIYCqNt0XhdB94swIyW85uxSchwyKgqVXmot+0nRhBI/YGqovFiJx5S3iRMWDnLXkBV0cyv48DD5aulJ121ayD+Lmb9XC1XS1mM9wtqQCilJIAIsHEIoSrG+3PenDdlsToPht+X+xcH58HCWy38er9Se7VXqXcBjHJm9redcL3nI0d6RWE54Ehv/OzXa7W8em+N89xuxHHeAICBT+89jj98eiK3bGft/S/P9/fFOrX3JzzdXCiRJUvFmhaCWCyitZeTzQXdlEWIUTsX62nlHp+STPDyFuUbt2KPZHykbkuPcOPhB3pthMD6xzM/9Yd5XK4YSXMv/ZRTS+XiCdlQ5MHbzXbd0syTJ9TBM98tJ/B9OTHvC4nn+gW5lrTSAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjQ3LTA2OjAw5zaaFAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo0Ny0wNjowMJZrIqgAAAAfdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADExMXg3MCswKzBSgapJAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS41DUCDV0wAAAAASUVORK5CYII=" alt="图片/错误/丢失令牌.png">
</div>
<p id="f_0060.html.N15D2C">
解析器调用，<code class="cf ic">match(ID)</code>但找到的不是标识符，而是<code class="cf ic">{</code>。在这种情况下，解析器知道 是它<code class="cf ic">{</code>接下来需要的，因为它跟<code class="cf keyword">ID</code>在 中的引用后面<code class="cf keyword">classDef</code>。要重新同步，<code class="cf methodname">match</code>可以假装看到标识符并返回，从而允许下一个<code class="cf ic">match(’{’)</code>调用成功。
</p><p>
The parser invokes <code class="cf ic">match(ID)</code> but instead of an identifier finds <code class="cf ic">{</code>. In
this situation, the parser knows that the <code class="cf ic">{</code> is what it will need next since that
is what follows the <code class="cf keyword">ID</code> reference in <code class="cf keyword">classDef</code>. To resynchronize, the <code class="cf methodname">match</code> can pretend to see the identifier and return, thus allowing the next <code class="cf ic">match(’{’)</code> call to succeed.
</p>
<p id="f_0060.html.N15D44">
如果我们忽略嵌入的操作（例如引用类名标识符的 print 语句），效果会很好。print 语句通过 引用缺失的标记，<code class="cf ic">$ID.text</code>如果标记是空的，将引发异常。错误处理程序不会简单地假装标记存在，而是会召唤一个标记；请参阅<code class="cf methodname">getMissingSymbol</code>。<code class="cf class">DefaultErrorStrategy</code>召唤的标记具有解析器期望的标记类型，并从当前输入标记中获取行和字符位置信息，<code class="cf ic">LA(1)</code>。这个召唤的标记还可以防止引用缺失标记的侦听器和访问者出现异常。
</p><p>
That works great if we ignore embedded actions, such as the print statement that
references the class name identifier. The print statement references the missing
token via <code class="cf ic">$ID.text</code> and will cause an exception if the token is null.
Rather than simply pretending the token exists, the error handler conjures one up;
see <code class="cf methodname">getMissingSymbol</code> in <code class="cf class">DefaultErrorStrategy</code>. The
conjured token has the token type that the parser expected and takes line and
character position information from the current input token, <code class="cf ic">LA(1)</code>. This
conjured token also prevents exceptions in listeners and visitors that reference
the missing token.
</p>
<p id="f_0060.html.N15D53">
要了解发生了什么，最简单的方法是查看解析树，它显示了解析器如何识别所有标记。在出现错误的情况下，解析树会用红色突出显示解析器在重新同步期间删除或生成的标记。对于输入<code class="cf ic">class { int i; }</code>和语法
<code class="cf class">Simple</code>，我们得到以下解析树：
</p><p>
The easiest way to see what’s going on is to look at the parse tree, which shows
how the parser recognizes all the tokens. In the case of errors, the parse tree
highlights in red the tokens that the parser deletes or conjures up during
resynchronization. For input <code class="cf ic">class { int i; }</code> and grammar
<code class="cf class">Simple</code>, we get the following parse tree:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/E-missing-ID.png">
</div>
<p id="f_0060.html.N15D61">
解析器还执行嵌入的打印操作而不会引发异常，因为错误恢复会为 生成一个有效的<code class="cf class">Token</code>对象<code class="cf ic">$ID</code>。
</p><p>
The parser also executes the embedded print actions without throwing an exception since error recovery conjures up a valid <code class="cf class">Token</code> object for <code class="cf ic">$ID</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class { int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:6 missing ID at '{'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class &lt;missing ID&gt;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15D8B">
当然，带有文本的标识符<code class="cf ic">&lt;missing ID&gt;</code>对于我们试图实现的任何目标都没有用，但至少错误恢复不会引起一堆空指针异常。
</p><p>
Naturally, an identifier with text <code class="cf ic">&lt;missing ID&gt;</code> isn’t really useful for whatever
goal we’re trying to accomplish, but at least error recovery doesn’t induce a bunch of null
pointer exceptions.
</p>
<p id="f_0060.html.N15D91">
现在我们知道了 ANTLR 如何对简单标记引用进行规则内恢复，让我们来探索一下它如何在子规则识别之前和期间从错误中恢复。
</p><p>
Now that we know how ANTLR does in-rule recovery for simple token references,
let’s explore how it recovers from errors before and during subrule recognition.
</p>
<h3>从子规则中的错误中恢复</h3><h3>Recovering from Errors in Subrules</h3>
<p id="f_0060.html.N15D9B">
几年前，Sun 的 JavaFX 小组联系了我，因为他们的 ANTLR 生成的解析器在某些情况下恢复得不好。事实证明，解析器<code class="cf ic">member+</code>在第一次出现问题时就退出了子规则循环，从而强制对周围规则进行同步和返回恢复。成员声明中的小错误<code class="cf ic">var width Number;</code>（例如后面缺少冒号
<code class="cf variable">width</code>）将强制解析器跳过所有剩余成员。
</p><p>
Years ago the JavaFX group at Sun contacted me because their ANTLR-generated
parser didn’t recover well in certain cases. It turns out that the parser was
bailing out of subrule loops like <code class="cf ic">member+</code> at the first whiff of trouble,
forcing sync-and-return recovery for the surrounding rule. A small error in a
member declaration like <code class="cf ic">var width Number;</code> (missing a colon after
<code class="cf variable">width</code>) would force the parser to skip all of the remaining
members.
</p>
<p id="f_0060.html.N15DAD">
ANTLR 邮件列表贡献者和顾问 Jim Idle 提出了我称之为“Jim Idle 的魔法同步”错误恢复的方法。他的解决方案是手动将对空规则的引用插入到语法中，该语法包含一个特殊操作，可在必要时触发错误恢复。ANTLR v4 现在会在开始和循环继续测试时自动插入同步检查，以避免这种剧烈的恢复。该机制如下所示：
</p><p>
Jim Idle, an ANTLR mailing list contributor and consultant, came up with what I call “Jim
Idle’s magic sync” error recovery. His solution was to manually insert references to an
empty rule into the grammar that contained a special action that triggered error recovery
when necessary. ANTLR v4 now automatically inserts synchronization checks at the start and
at the loop continuation test to avoid such drastic recovery. The mechanism looks like this:
</p>
<dl>
<dt>
<span class="emph">子规则开始</span>
</dt><dt>
<span class="emph">Subrule start</span>
</dt>
<dd>
<p id="f_0060.html.N15DB7">
在任何子规则的开头，解析器都会尝试删除单个标记。但是，与标记匹配不同，解析器不会尝试插入单个标记。ANTLR 很难想出一个标记，因为它必须猜测几个替代方案中的哪一个最终会成功。 
  </p>
</dd><dd>
<p>
At the start of any subrule, parsers attempt single-token deletion. But, unlike
token matches, parsers don’t attempt single-token insertion. ANTLR would have a
hard time conjuring up a token because it would have to guess which of several
alternatives would ultimately be successful. 
  </p>
</dd>
<dt>
<span class="emph">循环子规则延续测试</span>
</dt><dt>
<span class="emph">Looping subrule continuation test</span>
</dt>
<dd>
<p id="f_0060.html.N15DC5">
如果子规则是循环结构，<code class="cf ic">(...)*</code>或<code class="cf ic">(...)+</code>，解析器会在出现错误时尝试积极恢复以保持在循环中。成功匹配循环的替代方案后，解析器会一直使用，直到找到与以下集合之一一致的标记： 
</p>
<dl>
<dt>
<span class="emph">（一个）</span>
</dt>
<dd>
<p id="f_0060.html.N15DD5">
循环的另一次迭代</p>
</dd>
<dt>
<span class="emph">（二）</span>
</dt>
<dd>
<p id="f_0060.html.N15DDE">
 循环之后的内容
</p>
</dd>
<dt>
<span class="emph">（三）</span>
</dt>
<dd>
<p id="f_0060.html.N15DE7">
当前重新同步集 
</p>
</dd>
</dl>
</dd><dd>
<p>
If the subrule is a looping construct, <code class="cf ic">(...)*</code> or <code class="cf ic">(...)+</code>, the
parser tries to recover aggressively upon error to stay in the loop. After
successfully matching an alternative of the loop, the parser consumes until it
finds a token consistent with one of these sets: 
</p>
<dl>
<dt>
<span class="emph">(a)</span>
</dt>
<dd>
<p>
Another iteration of the loop</p>
</dd>
<dt>
<span class="emph">(b)</span>
</dt>
<dd>
<p>
 What follows the loop
</p>
</dd>
<dt>
<span class="emph">(c)</span>
</dt>
<dd>
<p>
The resynchronization set of the current 
</p>
</dd>
</dl>
</dd>
</dl>
<p id="f_0060.html.N15DEA">
我们先来看看子规则前面的单个标记删除。考虑语法规则
<code class="cf ic">member+</code>中的循环结构。如果我们结结巴巴地输入了一个多余的标记，
子规则将在跳转到之前删除多余的标记，如下面的解析树所示：
<code class="cf keyword">classDef</code><code class="cf class">Simple</code><code class="cf ic">{</code><code class="cf ic">member+</code><code class="cf keyword">member</code></p><p>
Let’s look at single-token deletion in front of a subrule first. Consider the
looping <code class="cf ic">member+</code> construct in rule <code class="cf keyword">classDef</code> of grammar
<code class="cf class">Simple</code>. If we stutter and type an extra <code class="cf ic">{</code>, the <code class="cf ic">member+</code>
subrule will delete the extra token before jumping into <code class="cf keyword">member</code>,
as shown in the following parse tree:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/E-delete-before-loop.png">
</div>
<p id="f_0060.html.N15E04">
以下会话确认恢复正确，因为它正确识别了变量<code class="cf variable">i</code>：
</p><p>
The following session confirms proper recovery because it correctly identifies variable <code class="cf variable">i</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {{ int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:9 extraneous input '{' expecting 'int'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var i​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15E2B">
现在让我们尝试一些真正混乱的输入，看看循环是否<code class="cf ic">member+</code>可以恢复并继续寻找成员。
</p><p>
Now let’s try some really messed up input and see whether the <code class="cf ic">member+</code> loop
can recover and continue looking for members.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {{</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int x;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  y;;;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int z;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:9 extraneous input '{' expecting 'int'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 3:2 extraneous input 'y' expecting {'int', '}'}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var z​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15E6C">
我们知道解析器重新同步并停留在循环中，因为它识别了变量<code class="cf variable">z</code>。解析器会吞噬<code class="cf ic">y;;;</code>
直到看到另一个成员的开头（之前的集合<span class="emph">(c)</span>），然后循环回到<code class="cf keyword">member</code>。如果输入不包含<code class="cf ic">int z;</code>，解析器会吞噬直到看到<code class="cf ic">}</code>（上面的集合<span class="emph">(b)</span> 
）并退出循环。解析树突出显示已删除的标记，并说明解析器仍将其解释<code class="cf ic">int z;</code>为有效成员。
</p><p>
We know that the parser resynchronized and stayed within the loop because it
identified variable <code class="cf variable">z</code>. The parser gobbles up <code class="cf ic">y;;;</code>
until it sees the start of another member (set <span class="emph">(c)</span> earlier) and then loops
back to <code class="cf keyword">member</code>. If the input did not include <code class="cf ic">int z;</code>,
the parser would have gobbled until it had seen <code class="cf ic">}</code> (set <span class="emph">(b)</span>
above) and exited the loop. The parse tree highlights the deleted tokens and illustrates that
the parser still interpreted <code class="cf ic">int z;</code> as a valid member.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/E-loop-recover.png">
</div>
<p id="f_0060.html.N15E8C">
如果用户提供的规则<code class="cf keyword">member</code>语法错误，并且忘记了类的关闭
<code class="cf ic">}</code>，我们不希望解析器扫描直到找到
<code class="cf ic">}</code>。解析器重新同步可能会抛出整个以下类定义来寻找。相反，如果解析器在集合<span class="emph">(c)</span><code class="cf ic">}</code>中看到一个标记，它会停止吞噬，如以下会话所示：
<span class="emph"></span></p><p>
If the user provides rule <code class="cf keyword">member</code> with bad syntax and also forgets the closing
<code class="cf ic">}</code> of a class, we wouldn’t want the parser to scan until it finds
<code class="cf ic">}</code>. Parser resynchronization could throw out an entire following class
definition looking for <code class="cf ic">}</code>. Instead, the parser stops gobbling if it sees a
token in set <span class="emph">(c)</span>, as shown the following session:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int x;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  ;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class U { int y; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 3:2 extraneous input ';' expecting {'int', '}'}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var y​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class U​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15ED7"><code class="cf keyword">class</code>正如我们从解析树中看到的那样，

当解析器看到关键字时，它会停止重新同步。</p><p>
The parser stops resynchronization when it sees keyword <code class="cf keyword">class</code>, as we can see from the parse tree.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/错误/E-loop-exit-on-follow.png">
</div>
<p id="f_0060.html.N15EE2">
除了识别标记和子规则之外，解析器还可能无法匹配语义谓词。
</p><p>
Besides the recognition of tokens and subrules, parsers can also fail to match semantic predicates.
</p>
<h3 id="f_0060.html.sec.failed-preds">捕获失败的语义谓词</h3><h3>Catching Failed Semantic Predicates</h3>
<p id="f_0060.html.N15EF3">
到目前为止，我们只是对语义谓词有了初步的了解，但在本章错误处理中讨论谓词失败时会发生什么是合适的。我们将在第 11 章“<a href="#f_0067.html.chp.predicates"><em>使用语义谓词</em></a><a href="#f_0067.html.chp.predicates">改变中深入研究谓词。<em></em></a>现在，让我们将语义谓词视为断言。它们指定在运行时必须为真的条件，解析器才能通过它们。如果谓词的计算结果为假，解析器将抛出异常<code class="cf class">FailedPredicateException</code>，该异常被<code class="cf keyword">catch</code>当前规则的捕获。解析器报告错误并执行通用的同步和返回恢复。
</p><p>
We’ve  gotten only a taste of semantic predicates at this point, but it’s
appropriate to discuss what happens upon failed predicates in this error handling
chapter. We’ll look at predicates in depth in Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>. For
now, let’s treat semantic predicates like assertions. They specify conditions that
must be true at runtime for the parser to get past them. If a predicate evaluates
to false, the parser throws a <code class="cf class">FailedPredicateException</code> exception,
which is caught by the <code class="cf keyword">catch</code> of the current rule. The parser
reports an error and does the generic sync-and-return recovery.
</p>
<p id="f_0060.html.N15F0B">
让我们看一个使用语义谓词来限制向量中整数数量的例子，这与使用<a href="#f_0029.html.sec.tour-preds"><em>语义谓词</em></a><a href="#f_0029.html.sec.tour-preds">改变中的语法非常相似。<em></em></a>规则<code class="cf keyword">ints</code>匹配
<code class="cf variable">max</code>整数。
</p><p>
Let’s look at an example that uses a semantic predicate to restrict the number of
integers in a vector, very similar to the grammar in <a href="#f_0029.html.sec.tour-preds">​<em>Altering the Parse with Semantic Predicates</em>​</a>. Rule <code class="cf keyword">ints</code> matches up to
<code class="cf variable">max</code> integers.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Vec.g4">错误/Vec.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​vec4:   <em class="string">'['</em> ints[4] <em class="string">']'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ints[int max]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   INT ( <em class="string">','</em> {$i++;} {$i&lt;=$max}? INT )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15F3B">
给定太多的整数，如在下面的会话中，我们会看到一条错误消息，并得到抛出多余的逗号和整数的错误恢复：
</p><p>
Given one too many integers, as in the following session, we see an error message
and get error recovery that throws out the extra comma and integers:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Vec.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Vec*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Vec vec4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">[1,2,3,4,5,6]</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:9 rule ints failed predicate: {$i&lt;=$max}?​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15F63">
解析树显示解析器在第五个整数处检测到错误。
</p><p>
The parse tree shows that the parser detected the error at the fifth integer.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAABPCAMAAAAz8LxwAAAAZlBMVEX////MzMzd3d0RERF3d3fu7u67u7uIiIiZmZlERERmZmYiIiKqqqozMzNVVVUAAAD46Oby1NH139389PPCqqeynJnSuLVAODdxY2EwKilQRkXixsMgHBuRf31hVVMQDg2hjYuBcW9yprW/AAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAASAAAAEgARslrPgAABCZJREFUaN7tmg17myAQgAGPQxRNu8WkSdeu+/9/cseHCrGkaddKtuWePql4CK9wwB3C2E3WFS5KE6QiKihZPZeMIWNS1fRTAzWObooCgWKiZbI1SssODNINKAokOqYUUw1iqywI71lZINaJTjDowQol+063bV0SqG56+2OvtL9TuIXkxtBv02mwP6o80E1u8g9L2SVjIRIUB1maIuJpJNqf0hyj2MZBdj1E3JoP2ivgpVmsGLtieKCrIKr96o5JqqAow2Kg4kRTH41A3qJKiZxtZgIqSRSP8xmIiVLDP5mbI6BSE1LaNTFQ3JXriUlNBVPt+kSnwxvf0K/NswBamWjZIwsghisOf7G0kFfGFb+Sxb+ERNGgUNlcbjtkHdHzpZjYlmSAF5X2uUCS0x+ntuAbJL8xsfYiQKgZVlC3st6AQI3mGoA6uoNsQ1bTJVZTDEiPQKxu48nnCoCYrK4HSHe87nWZFmovWhVqvRoQXlQTx/947bjJOwVBb9peXUEcHWCqSivTVVVVGgqhqXTXA5gamaJU33UtFIJCAJoGoVHYIPkgNBGARED7kUE3amUoV61tF6jtFyHZ+K9UwKRSkm4ap14JysIYqpELRc4PWq8Q/GczFzpydxMk5bBcXwxlYZCaQNlKlaQ2sbGOq9TN3cYlwSpoHePEJL4OysGQCw1K2K+H1hEzLrhHF4D5xcTVLYOylj67/HwoD+NeWVo32nnvonEQwakOq5vff0CfweUjeOrFT4QKMPTG7sVZDT4kBe/UW4OOgKTHI+N2/3xLWhrOPgNqhLFFheYIXjyOIc64JTOu/+OeCJ8y+hzhff4AaoQJbe5vKRnaYQzc1WJLz0wqGDOHx0OPfwSKjzDBiKPm9287Ojo47SjMHtJUl4weCPmm4t4BxZVSOHHVoepgyO6ymSqfo8R4s2HeWMP5oel5P2tcCBXB2C6bYqwa5r0VmCPU0aBPgOSMGYz7pIWDkb8BFcOw0Yh9+VE4inG8nttjjDf7ePKwklENMd8JVAIzG/FpIZExW0kKSbxsk2RLCoiKjiziFCopTSTRZ7qZmXjtSb7Un09UYtLd3Xv55pPfXSK+npIryaVAMruPIzGrEnhm9ydzioiAtsOwzQLtdi6psnEf15A7yiFIZTKPZU8REdB+v3/IAG0Px8El8dzxCNFmVabPaXKniAjokO2yx8N2TJ4D4jqjsJtBGVX2FBEB/Xh4ygA9HZ9DC50F6nP9QtFGZpbNnyIioGE4Zrrs4fi4/fH4FlDzgd7MnyJyo2z3MwP0QhY2LIFk3BFNw3IqaqM2q8qU6ICG4wz0OERd9kwdulsCmYhBbbTWr6tMpzv+uipf4t39035/iIb9y3M0yp73h1+vTIxndpk+pop0i4nxYXh7pj7jD3xMFekWQNu/ZOm4AZ0D+g2rUTEa6SpqWgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0Njo0OC0wNjowMBF+6v0AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDY6NDgtMDY6MDBgI1JBAAAAIHRFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAA2MTJ4NzkyKzArMJ+dfVcAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/错误/Vec-6-ints.png">
</div>
<p id="f_0060.html.N15F6B">
错误消息<code class="cf ic">{$i&lt;=$max}</code>可能对我们这些语法设计者有帮助，但对我们的用户来说肯定没有帮助。我们可以通过使用
<code class="cf keyword">fail</code>语义谓词上的选项将消息从一段代码更改为更易读的内容。例如，下面
<code class="cf keyword">ints</code>再次是规则，但带有计算可读字符串的操作：
</p><p>
The <code class="cf ic">{$i&lt;=$max}</code> error message might be helpful to us as grammar
designers, but it’s certainly not helpful to our users. We can change the message
from a chunk of code to something a little more readable by using the
<code class="cf keyword">fail</code> option on the semantic predicate. For example, here is the
<code class="cf keyword">ints</code> rule again but with an action that computes a readable
string:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/VecMsg.g4">错误/VecMsg.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ints[int max]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   INT ( <em class="string">','</em> {$i++;} {$i&lt;=$max}?&lt;fail={<em class="string">"exceeded max "</em>+$max}&gt; INT )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15F95">
现在，对于相同的输入，我们可以得到更好的消息。
</p><p>
Now we get a better message for the same input.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 VecMsg.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac VecMsg*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun VecMsg vec4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">[1,2,3,4,5,6]</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:9 rule ints exceeded max 4​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N15FBD">
该<code class="cf keyword">fail</code>选项采用双引号中的字符串文字或计算结果为字符串的操作。如果您想在谓词失败时执行函数，该操作非常方便。只需使用调用函数的操作，例如<code class="cf ic">{...}?&lt;fail={failedMaxTest()}&gt;</code>。
</p><p>
The <code class="cf keyword">fail</code> option takes either a string literal in double quotes
or an action that evaluates to a string. The action is handy if you’d like to
execute a function when a predicate fails. Just use an action that calls a
function such as <code class="cf ic">{...}?&lt;fail={failedMaxTest()}&gt;</code>.
</p>
<p id="f_0060.html.N15FCD">
	关于使用语义谓词测试输入有效性的注意事项。在向量示例中，谓词强制执行语法规则，因此可以抛出异常并尝试恢复。另一方面，如果我们有一个语法有效但语义无效的构造，则使用语义谓词不是一个好主意。
</p><p>
	A word of caution about using semantic predicates to test for input validity. In the vector example, the predicate enforces syntactic rules, so it’s OK to throw an exception and try to recover. If, on the other hand, we have a syntactically valid but semantically invalid construct, it’s not a good idea to use a semantic predicate.
</p>
<p id="f_0060.html.N15FD0">
想象一下，在某些语言中，我们可以为变量分配除 0 之外的任何值。这意味着赋值<code class="cf ic">x = 0;</code>在语法上有效，但在语义上无效。当然，我们必须向用户发出错误，但我们不应该触发错误恢复。在<code class="cf ic">x = 0;</code>语法上是完全合法的。从某种意义上说，解析器将自动从错误中“恢复”。以下是演示该问题的简单语法：
</p><p>
Imagine that, in some language, we can assign any value to a variable except 0.
That means assignment <code class="cf ic">x = 0;</code> is syntactically valid but semantically
invalid. Certainly we have to emit an error to the user, but we should not trigger
error recovery. <code class="cf ic">x = 0;</code> is perfectly legal syntactically. In a sense, the
parser will automatically “recover” from the error. Here’s a simple grammar that
demonstrates the issue:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Pred.g4">错误/Pred.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​assign​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : ID <em class="string">'='</em> v=INT {$v.int&gt;0}? <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {System.out.println(<em class="string">"assign "</em>+$ID.text+<em class="string">" to "</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N16004">
	如果规则中的谓词<code class="cf keyword">assign</code>抛出异常，则同步并返回行为将在谓词后抛出<code class="cf ic">;</code>。这可能运行良好，但我们冒着不完美的重新同步的风险。更好的解决方案是手动发出错误并让解析器继续匹配正确的语法。因此，我们应该使用带有条件的简单操作，而不是谓词。
</p><p>
	If the predicate in rule <code class="cf keyword">assign</code> throws an exception, the
sync-and-return behavior will throw out the <code class="cf ic">;</code> after the predicate. This
might work out just fine, but we risk an imperfect resynchronization. A better
solution is to emit an error manually and let the parser continue matching the
correct syntax. So, instead of the predicate, we should use a simple action with a
conditional.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{<strong class="prompt">if</strong> ($v.int==0) notifyListeners(<em class="string">"values must be &gt; 0"</em>);}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N1601F">
现在我们已经了解了所有可能触发错误恢复的情况，值得指出该机制的一个潜在缺陷。考虑到解析器有时在一次恢复尝试期间不会使用任何标记，因此整个恢复可能会陷入无限循环。如果我们在不消耗标记的情况下进行恢复并返回到解析器中的同一位置，我们将再次进行恢复而不消耗标记。在下一节中，我们将看到 ANTLR 如何避免这个陷阱。
</p><p>
Now that we’ve looked at all the situations that can trigger error recovery, it’s
worth pointing out a potential flaw in the mechanism. Given that the parser
sometimes doesn’t consume any tokens during a single recovery attempt, it’s
possible that overall recovery could go into an infinite loop. If we recover
without consuming a token and get back to the same location in the parser, we will
recover again without consuming a token. In the next section, we’ll see how ANTLR
avoids this pitfall.
</p>
<h3>错误恢复故障安全</h3><h3>Error Recovery Fail-Safe</h3>
<p id="f_0060.html.N1602C">
ANTLR 解析器具有内置的故障保护功能，可确保错误恢复终止。如果我们到达相同的解析器位置并具有相同的输入位置，解析器将在尝试恢复之前强制使用令牌。回到
<code class="cf class">Simple</code>本章开头的简单语法，让我们看一个触发故障保护的示例输入。如果我们<code class="cf ic">int</code>在字段定义中添加额外的令牌，解析器将检测到错误并尝试恢复。正如我们将在下一次测试运行中看到的那样，解析器将调用<code class="cf methodname">recover</code>并尝试多次重新启动解析，然后才能正确重新同步（图 9，<a href="#f_0060.html.code.recover">解析器<em>重新同步</em>）</a> 。
</p><p>
ANTLR parsers have a built-in fail-safe to guarantee error recovery terminates. If
we reach the same parser location and have the same input position, the parser
forces a token consumption before attempting recovery. Returning to the simple
<code class="cf class">Simple</code> grammar from the start of this chapter, let’s look at a
sample input that trips the fail-safe. If we add an extra <code class="cf ic">int</code> token in a
field definition, the parser detects an error and tries to recover. As we’ll see
in the next test run, the parser will call <code class="cf methodname">recover</code> and try to
restart parsing multiple times before correctly resynchronizing (Figure 9, <a href="#f_0060.html.code.recover">​<em>Parser resynchronization</em>​</a>).
</p>
<div class="figure" id="f_0060.html.code.recover">
<div>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Simple prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class T {</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int int x;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:6 no viable alternative at input 'intint'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​var x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​class T​</code></div>
</td>
</tr>
</tbody></table>
</div>
<div class="figurecaption">
<hr>图 9. 解析器重新同步</div>
</div>
<p id="f_0060.html.N16079">
  图 10 中的图表<a href="#f_0060.html.fig.gobbling-good-bad"><em>​正确语法和错误语法的</em></a><a href="#f_0060.html.fig.gobbling-good-bad">解析树​中右侧的解析显示<em></em></a>有三次<code class="cf keyword">member</code>from调用<code class="cf keyword">classDef</code>。
</p><p>
  The right parse tree in the diagram in Figure 10, <a href="#f_0060.html.fig.gobbling-good-bad">​<em>Parse trees for good and bad syntax</em>​</a> shows that there are three
invocations of <code class="cf keyword">member</code> from <code class="cf keyword">classDef</code>.
</p>
<div class="figure" id="f_0060.html.fig.gobbling-good-bad">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/错误/gobbling-good-bad.png">
</div>
<div class="figurecaption">
<hr>图 10. 正确语法和错误语法的解析树</div>
</div>
<p id="f_0060.html.N16091">
第一个引用不匹配任何内容，但第二个引用匹配了无关的<code class="cf ic">int</code>标记。第三次尝试匹配成员时匹配了正确的<code class="cf ic">int x;</code>序列。
</p><p>
The first reference doesn’t match anything, but the second one matches the
extraneous <code class="cf ic">int</code> token. The third attempt at matching a member matches the
proper <code class="cf ic">int x;</code> sequence.
</p>
<p id="f_0060.html.N1609A">
让我们来看看事件的确切顺序。当解析器
<code class="cf keyword">member</code>检测到第一个错误时，它就处于规则之中。
</p><p>
Let’s walk through the exact sequence of events. The parser is in rule
<code class="cf keyword">member</code> when it detects the first error.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Simple.g4">错误/Simple.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​member​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'int'</em> ID <em class="string">';'</em>                       <em class="comment">// field definition</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"var "</em>+$ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'int'</em> f=ID <em class="string">'('</em> ID <em class="string">')'</em> <em class="string">'{'</em> stat <em class="string">'}'</em> <em class="comment">// method definition</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"method: "</em>+$f.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0060.html.N160DB">
输入<code class="cf ic">int int</code>不符合 的任一替代方案<code class="cf keyword">member</code>，因此解析器采用同步并返回错误恢复策略。它发出第一条错误消息并消耗，直到它在调用堆栈 [ <code class="cf keyword">prog</code>, <code class="cf keyword">classDef</code>,
 <code class="cf keyword">member</code>] 的重新同步集中看到一个标记。
</p><p>
Input <code class="cf ic">int int</code> doesn’t fit either alternative of <code class="cf keyword">member</code>,
so the parser engages the sync-and-return error recovery strategy. It emits the
first error message and consumes until it sees a token in the resynchronization
set for call stack [<code class="cf keyword">prog</code>, <code class="cf keyword">classDef</code>,
<code class="cf keyword">member</code>].
</p>
<p id="f_0060.html.N160ED">
由于语法中有<code class="cf ic">classDef+</code>和<code class="cf ic">member+</code>循环，计算重新同步集有点复杂。在调用 之后
<code class="cf keyword">member</code>，解析器可以循环回来并找到另一个成员，或者退出循环并找到<code class="cf ic">’}’</code>关闭类定义的 。在调用 之后<code class="cf keyword">classDef</code>，解析器可以循环回来查看另一个类的开头，或者直接退出<code class="cf keyword">prog</code>。因此，对于调用堆栈 [ <code class="cf keyword">prog</code>, <code class="cf keyword">classDef</code>,
 <code class="cf keyword">member</code>]，重新同步集为 { <code class="cf ic">’int’</code>,
 <code class="cf ic">’}’</code>, <code class="cf ic">’class’</code>}。
</p><p>
Because of the <code class="cf ic">classDef+</code> and <code class="cf ic">member+</code> loops in the grammar,
computing the resynchronization set is a little complicated. Following the call to
<code class="cf keyword">member</code>, the parser could loop back and find another member or
exit the loop and find the <code class="cf ic">’}’</code> that closes the class definition.
Following the call to <code class="cf keyword">classDef</code>, the parser could loop back to
see the start of another class or simply exit <code class="cf keyword">prog</code>. So, for
call stack [<code class="cf keyword">prog</code>, <code class="cf keyword">classDef</code>,
<code class="cf keyword">member</code>], the resynchronization set is {<code class="cf ic">’int’</code>,
<code class="cf ic">’}’</code>, <code class="cf ic">’class’</code>}.
</p>
<p id="f_0060.html.N16116">
此时，解析器无需消耗任何标记即可恢复，因为当前输入标记<code class="cf ic">int</code>位于重新同步集中。它只是返回到调用者：<code class="cf ic">member+</code>中的循环<code class="cf ic">classDef</code>。然后，循环尝试匹配另一个成员。不幸的是，由于它没有消耗任何标记，解析器在返回 时检测到另一个错误<code class="cf keyword">member</code>（尽管它利用 标志隐藏了虚假的错误消息
<code class="cf variable">errorRecovery</code>）。
</p><p>
At this point, the parser recovers without consuming a token because the current
input token, <code class="cf ic">int</code>, is in the resynchronization set. It simply returns to
the caller: the <code class="cf ic">member+</code> loop in <code class="cf ic">classDef</code>. The loop then tries to
match another member. Unfortunately, since it has not consumed any tokens, the
parser detects another error when it returns to <code class="cf keyword">member</code> (though
it hushes the spurious error message, by virtue of the
<code class="cf variable">errorRecovery</code> flag).
</p>
<p id="f_0060.html.N16128">
在恢复第二个错误期间，解析器触发故障保护，因为它已到达相同的解析器位置和输入位置。故障保护在尝试重新同步之前强制使用令牌。由于<code class="cf ic">int</code>在重新同步集中，它不会消耗第二个令牌。幸运的是，这正是我们想要的，因为解析器现在已正确重新同步。接下来的三个令牌代表有效的成员定义：<code class="cf ic">int x;</code>。解析器再次从返回<code class="cf keyword">member</code>到中的循环
<code class="cf keyword">classDef</code>。第三次，我们回到
<code class="cf keyword">member</code>，但现在解析将成功。
</p><p>
During recovery for this second error, the parser trips the fail-safe because it
has arrived at the same parser location and input position. The fail-safe forces a
token consumption before attempting resynchronization. Since <code class="cf ic">int</code> is in
the resynchronization set, it doesn’t consume a second token. Fortunately, that’s
exactly what we want because the parser is now properly resynchronized. The next
three tokens represent a valid member definition: <code class="cf ic">int x;</code>. The parser
returns once again from <code class="cf keyword">member</code> to the loop in
<code class="cf keyword">classDef</code>. For the third time, we go back to
<code class="cf keyword">member</code>, but now parsing will succeed.
</p>
<p id="f_0060.html.N1613A">
这就是 ANTLR 自动错误恢复机制的故事。现在让我们看看有时可以提供更好错误恢复的手动机制。
</p><p>
So, that’s the story with ANTLR’s automatic error recovery mechanism. Now let’s look at a manual mechanism that can sometimes provide better error recovery.
</p>

</div></div>
<div id="f_0061.html"><div>

<h2 id="f_0061.html.sec.error-alts">9.4 错误替代方案</h2><h2>9.4 Error Alternatives</h2>
<p id="f_0061.html.N1614B">
有些语法错误非常常见，值得特殊处理。例如，程序员经常在带有嵌套参数的函数调用末尾使用错误数量的括号。要特殊处理这些情况，我们所要做的就是添加替代方案以匹配错误但常见的语法。以下语法识别具有单个参数的函数调用，参数中可能带有嵌套括号。规则有<code class="cf keyword">fcall</code>两个所谓的
<span class="firstuseinline">错误替代方案</span>。
	</p><p>
Some syntax errors are so common that it’s worth treating them specially. For
example, programmers often have the wrong number of parentheses at the end of a
function call with nested arguments. To handle these cases specially, all we have
to do is add alternatives to match the erroneous but common syntax. The following
grammar recognizes function calls with a single argument, possibly with nested
parentheses in the argument. Rule <code class="cf keyword">fcall</code> has two so-called
<span class="firstuseinline">error alternatives</span>.
	</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/Call.g4">错误/Call.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   fcall <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​fcall​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   ID <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="string">')'</em> {notifyErrorListeners(<em class="string">"Too many parentheses"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'('</em> expr         {notifyErrorListeners(<em class="string">"Missing closing ')'"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0061.html.N161A4">
虽然这些错误替代方案可能会使 ANTLR 生成的解析器在替代方案之间做出选择时更加困难，但它们不会以任何方式混淆解析器。就像任何其他替代方案一样，如果它们与当前输入一致，解析器就会匹配它们。例如，让我们尝试一些与错误替代方案匹配的输入序列，从有效的函数调用开始。
</p><p>
While these error alternatives can make an ANTLR-generated parser work a little
harder to choose between alternatives, they don’t in any way confuse the parser.
Just like any other alternative, the parser matches them if they are consistent
with the current input. For example, let’s try some input sequences that match
the error alternatives, starting with a valid function call.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Call.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Call*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Call stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f(34); </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Call stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f((34);</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:6 Missing closing ')'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Call stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f((34)));</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:8 Too many parentheses​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0061.html.N161EE">
到目前为止，我们已经了解了很多有关 ANTLR 解析器可以生成的错误消息以及解析器如何在许多不同情况下从错误中恢复的知识。我们还了解了如何自定义错误消息并将其重定向到不同的错误侦听器。所有这些功能都由一个指定 ANTLR 错误处理策略的对象控制和封装。在下一节中，我们将详细研究该策略，以了解有关自定义解析器如何响应错误的更多信息。
</p><p>
At this point, we’ve learned quite a bit about the error messages that ANTLR
parsers can generate and also how parsers recover from errors in lots of different
situations. We’ve also seen how to customize error messages and redirect them to
different error listeners. All of this functionality is controlled and
encapsulated in an object that specifies ANTLR’s error handling strategy. In the
next section, we’ll look at that strategy in detail to learn more about
customizing how parsers respond to errors.
</p>

</div></div>
<div id="f_0062.html"><div>

<h2 id="f_0062.html.sec.error-handling">9.5 改变ANTLR的错误处理策略</h2><h2>9.5 Altering ANTLR’s Error Handling Strategy</h2>
<p id="f_0062.html.N161F6">
默认的错误处理机制工作得很好，但在一些不典型的情况下，我们可能需要改变它。首先，我们可能希望禁用一些内联错误处理，因为它的运行时开销很大。其次，我们可能希望在第一次出现语法错误时退出解析器。例如，在解析 shell 的命令行时<code class="cf commandname">bash</code>，尝试从错误中恢复是没有意义的。无论如何，我们也不能冒险执行该命令，因此解析器可以在第一次出现问题时退出。
</p><p>
The default error handling mechanism works very well, but there are a few atypical
situations in which we might want to alter it. First, we might want to disable
some of the in-line error handling because of its runtime overhead. Second, we
might want to bail out of the parser upon the first syntax error. For example,
when parsing a command line for a shell like <code class="cf commandname">bash</code>,
there’s no point in trying to recover from errors. We can’t risk executing that
command anyway, so the parser can bail out at the first sign of trouble.
</p>
<p id="f_0062.html.N16207">
要探索错误处理策略，请查看接口
<code class="cf class">ANTLRErrorStrategy</code>及其具体实现类
<code class="cf class">DefaultErrorStrategy</code>。该类包含与默认错误处理行为相关的所有内容。ANTLR 解析器会向该对象发出信号以报告错误并进行恢复。例如，这是
<code class="cf keyword">catch</code>每个 ANTLR 生成的规则函数内部的块：
</p><p>
To explore the error handling strategy, take a look at interface
<code class="cf class">ANTLRErrorStrategy</code> and its concrete implementation class
<code class="cf class">DefaultErrorStrategy</code>. That class holds everything
associated with the default error handling behavior. ANTLR parsers signal that
object to report errors and recover. For example, here’s the
<code class="cf keyword">catch</code> block inside of each ANTLR-generated rule function:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​_errHandler.reportError(this, re);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​_errHandler.recover(this, re);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16229">
<code class="cf variable">_errHandler</code>是一个保存对 实例的引用的变量<code class="cf class">DefaultErrorStrategy</code>。方法<code class="cf methodname">reportError</code>和<code class="cf methodname">recover</code>体现了错误报告和同步返回功能。<code class="cf methodname">reportError</code>根据抛出的异常类型，将错误报告委托给三种方法之一。</p><p>
<code class="cf variable">_errHandler</code> is a variable holding a reference to an instance of <code class="cf class">DefaultErrorStrategy</code>.  Methods <code class="cf methodname">reportError</code> and <code class="cf methodname">recover</code> embody the error reporting and sync-and-return functionality. <code class="cf methodname">reportError</code> delegates error reporting to one of three methods, according to the type of exception thrown.</p>
<p id="f_0062.html.N1623A">
转向我们的第一个非典型情况，让我们减少错误处理给解析器带来的运行时负担。看一下 ANTLR 为<code class="cf ic">member+</code>语法中的子规则生成的代码<code class="cf class">Simple</code>：
</p><p>
Turning to our first atypical situation, let’s decrease the runtime burden that
error handling places on the parser. Take a look at this code that ANTLR generates
for the <code class="cf ic">member+</code> subrule in grammar <code class="cf class">Simple</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​_errHandler.sync(this);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​_la = _input.LA(1);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">do</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setState(22); member();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    setState(26);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    _errHandler.sync(this);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    _la = _input.LA(1);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​} <strong class="prompt">while</strong> ( _la==6 );​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16269">
对于可以安全地假设输入在语法上正确的应用程序（例如网络协议），我们不妨避免检测和恢复子规则中的错误的开销。我们可以通过使用空方法进行子类化
<code class="cf class">DefaultErrorStrategy</code>和覆盖来实现这一点<code class="cf methodname">sync</code>。然后，Java 编译器可能会内联并消除这些
<code class="cf ic">_errHandler.sync(this)</code>调用。我们将通过下一个示例了解如何通知解析器使用不同的错误策略。
</p><p>
For applications where it’s safe to assume the input is syntactically correct,
such as network protocols, we might as well avoid the overhead of detecting and
recovering from errors in subrules. We can do that by subclassing
<code class="cf class">DefaultErrorStrategy</code> and overriding <code class="cf methodname">sync</code> with an
empty method. The Java compiler would likely then inline and eliminate the
<code class="cf ic">_errHandler.sync(this)</code> calls. We’ll see how to notify the parser to use a
different error strategy through the next example.
</p>
<p id="f_0062.html.N16275">
另一种不典型的情况是第一次出现语法错误时就退出解析器。为了实现这一点，我们必须重写三个关键的恢复方法，如以下代码所示：
</p><p>
The other atypical situation is bailing out of the parser upon the first syntax
error. To make this work, we have to override three key recovery methods, as shown
in the following code:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/BailErrorStrategy.java">错误/BailErrorStrategy.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> BailErrorStrategy <strong class="prompt">extends</strong> DefaultErrorStrategy {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Instead of recovering from exception e, rethrow it wrapped</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     *  in a generic RuntimeException so it is not caught by the</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     *  rule function catches.  Exception e is the "cause" of the</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     *  RuntimeException.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> recover(<strong class="prompt">Parser</strong> recognizer, RecognitionException e) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">throw</strong> <strong class="prompt">new</strong> RuntimeException(e);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Make sure we don't attempt to recover inline; if the parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     *  successfully recovers, it won't throw an exception.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">     */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> Token recoverInline(<strong class="prompt">Parser</strong> recognizer)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">throws</strong> RecognitionException​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">throw</strong> <strong class="prompt">new</strong> RuntimeException(<strong class="prompt">new</strong> InputMismatchException(recognizer));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** Make sure we don't attempt to recover from problems in subrules. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> sync(<strong class="prompt">Parser</strong> recognizer) { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16312">
对于测试装置，我们可以重用典型的样板代码。除了创建和启动解析器之外，我们还需要创建一个新<code class="cf class">BailErrorStrategy</code>
实例并告诉解析器使用它而不是默认策略。
</p><p>
For a test rig, we can reuse our typical boilerplate code. In addition to creating
and launching the parser, we need to create a new <code class="cf class">BailErrorStrategy</code>
instance and tell the parser to use it instead of the default strategy.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestBail.java">错误/TestBail.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.setErrorHandler(<strong class="prompt">new</strong> BailErrorStrategy());​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16328">
在我们这样做的同时，我们还应该在第一次出现词汇错误时就放弃。为此，我们必须重写<code class="cf methodname">recover</code>中的方法<code class="cf class">Lexer</code>。
</p><p>
While we’re at it, we should also bail out at the first lexical error. To do that,
we have to override method <code class="cf methodname">recover</code> in <code class="cf class">Lexer</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/TestBail.java">错误/TestBail.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> BailSimpleLexer <strong class="prompt">extends</strong> SimpleLexer {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> BailSimpleLexer(CharStream input) { super(input); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> recover(LexerNoViableAltException e) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">throw</strong> <strong class="prompt">new</strong> RuntimeException(e); <em class="comment">// Bail out</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16369">
首先，让我们通过<code class="cf ic">#</code>在输入开头插入一个奇怪的字符来尝试词汇错误。词法分析器会抛出一个异常，将控制流一路发送到主程序。
</p><p>
Let’s try a lexical error first by inserting a wacky <code class="cf ic">#</code> character at the
beginning of the input. The lexer throws an exception that blasts control flow all
the way out to the main program.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Simple.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Simple*.java TestBail.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestBail</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt"># class T { int i; }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:1 token recognition error at: '#'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Exception in thread "main"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​java.lang.RuntimeException: LexerNoViableAltException('#')​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at TestBail$BailSimpleLexer.recover(TestBail.java:9)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.Lexer.nextToken(Lexer.java:165)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.BufferedTokenStream.fetch(BufferedT...Stream.java:139)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.BufferedTokenStream.sync(BufferedT...Stream.java:133)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.CommonTokenStream.setup(CommonTokenStream.java:129)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.CommonTokenStream.LT(CommonTokenStream.java:111)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at org.antlr.v4.runtime.Parser.enterRule(Parser.java:424)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at SimpleParser.prog(SimpleParser.java:68)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​at TestBail.main(TestBail.java:23)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N163B8">
解析器也会在出现第一个语法错误（在本例中是缺少类名）时退出。
</p><p>
The parser also bails out at the first syntax error (a missing class name, in this
case).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestBail</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">class { }  </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Exception in thread "main" java.lang.RuntimeException: ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  org.antlr.v4.runtime.InputMismatchException​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N163DC">
为了展示接口的灵活性<code class="cf class">ANTLRErrorStrategy</code>，我们最后来改变一下解析器报告错误的方式。为了改变标准消息“输入 X 处没有可行的替代方案”，我们可以覆盖
<code class="cf methodname">reportNoViableAlternative</code>该消息并将其更改为其他消息。
</p><p>
To demonstrate the flexibility of the <code class="cf class">ANTLRErrorStrategy</code> interface,
let’s finish up by altering how the parser reports errors. To alter the standard
message, “no viable alternative at input X,” we can override
<code class="cf methodname">reportNoViableAlternative</code> and change the message to something
different.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/MyErrorStrategy.java">错误/MyErrorStrategy.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> MyErrorStrategy <strong class="prompt">extends</strong> DefaultErrorStrategy {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> reportNoViableAlternative(<strong class="prompt">Parser</strong> parser,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                                          NoViableAltException e)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">throws</strong> RecognitionException​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// ANTLR generates Parser subclasses from grammars and</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// Parser extends Recognizer. Parameter parser is a</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// pointer to the parser that detected the error</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> msg = <em class="string">"can't choose between alternatives"</em>; <em class="comment">// nonstandard msg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.notifyErrorListeners(e.getOffendingToken(), msg, e);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0062.html.N16445">
不过请记住，如果我们只想更改错误消息<span class="emph">的去向</span>，我们可以指定一个，<code class="cf class">ANTLRErrorListener</code>就像我们在 9.2 节“<a href="#f_0059.html.sec.error-listeners">更改<em>和重定向 ANTLR 错误消息”</em>中所做的那样。</a>要了解如何完全覆盖 ANTLR 生成捕获异常的代码的方式，请参阅“<a href="#f_0093.html.sec.catch-exceptions">捕获<em>异常”</em></a>。
</p><p>
Remember, though, that if all we want to do is change <span class="emph">where</span> error
messages go, we can specify an <code class="cf class">ANTLRErrorListener</code> as we did in Section 9.2, <a href="#f_0059.html.sec.error-listeners">​<em>Altering and Redirecting ANTLR Error Messages</em>​</a>. To learn how to completely override how ANTLR generates code for catching exceptions, see <a href="#f_0093.html.sec.catch-exceptions">​<em>Catching Exceptions</em>​</a>.
</p>
<p id="f_0062.html.N16454">
我们已经介绍了 ANTLR 中所有重要的错误报告和恢复功能。有了<code class="cf class">ANTLRErrorListener</code>和<code class="cf class">ANTLRErrorStategy</code>
接口，我们可以灵活地决定错误消息的去向、错误消息的内容以及解析器如何从错误中恢复。
</p><p>
We’ve covered all of the important error reporting and recovery facilities within ANTLR.
Because of <code class="cf class">ANTLRErrorListener</code> and <code class="cf class">ANTLRErrorStategy</code>
interfaces, we have great flexibility over where error messages go, what those messages are,
and how the parser recovers from errors.
</p>
<p id="f_0062.html.N16463">
在下一章中，我们将学习如何直接在语法中
嵌入称为<span class="emph">动作的代码片段。</span></p><p>
In the next chapter, we’re going to learn how to embed code snippets called <span class="emph">actions</span> directly within the grammar.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0062.html.FOOTNOTE-45" href="#f_0058.html.FNPTR-45">[45]</a>
</td>
<td>
<p id="f_0062.html.N155EA">请参阅
<a href="http://en.wikipedia.org/wiki/Niklaus_Wirth">http://en.wikipedia.org/wiki/Niklaus_Wirth</a>。</p><p> See
<a href="http://en.wikipedia.org/wiki/Niklaus_Wirth">http://en.wikipedia.org/wiki/Niklaus_Wirth</a>. </p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0062.html.FOOTNOTE-46" href="#f_0058.html.FNPTR-46">[46]</a>
</td>
<td>
<p id="f_0062.html.N155F8">请参阅
<a href="http://en.wikipedia.org/wiki/Kristen_Nygaard">http://en.wikipedia.org/wiki/Kristen_Nygaard</a>。</p><p> See
<a href="http://en.wikipedia.org/wiki/Kristen_Nygaard">http://en.wikipedia.org/wiki/Kristen_Nygaard</a>. </p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0063.html"><div>

<h1 class="chapter-title" id="f_0063.html.chp.actions">
<span class="chapter-number">
	      第十章</span>
<br><br>
<span class="chapter-name">属性和动作</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      10</span>
<br><br>
<span class="chapter-name">Attributes and Actions</span>
</h1>

<p id="f_0063.html.N16472">
到目前为止，我们已经将特定于应用程序的代码隔离到解析树遍历器中，这意味着我们的代码始终在解析完成后执行。正如我们将在接下来的几章中看到的那样，一些语言应用程序需要在解析时执行特定于应用程序的代码。为此，我们需要能够将代码片段（称为
<span class="firstuseinline">操作</span>）直接注入到 ANTLR 生成的代码中。那么，我们的第一个目标是学习如何将操作嵌入解析器和词法分析器中，并弄清楚我们可以将什么放入这些操作中。
</p><p>
So far, we’ve isolated our application-specific code to parse-tree walkers, which means that
our code has always executed after parsing is complete. As we’ll see in the next few
chapters, some language applications require executing application-specific code while
parsing. To do that, we need the ability to inject code snippets, called
<span class="firstuseinline">actions</span>, directly into the code ANTLR generates. Our first goal, then,
is to learn how to embed actions in parsers and lexers and to figure out what we can put in
those actions.
</p>
<p id="f_0063.html.N16478">
请记住，一般来说，避免将语法和特定于应用程序的代码混在一起是个好主意。没有动作的语法更容易阅读，不依赖于特定的目标语言，也不依赖于特定的应用程序。不过，嵌入式动作仍然很有用，原因有三个。
</p><p>
Keep in mind that, in general, it’s a good idea to avoid entangling grammars and
application-specific code. Grammars without actions are easier to read, aren’t tied
to a particular target language, and aren’t tied to a specific application. Still,
embedded actions can be useful for three reasons.
</p>
<ul>
<li>
<p id="f_0063.html.N16483">
<span class="emph">简单</span>：有时只需坚持几个动作并避免创建树监听器或访问者会更容易。
	</p>
</li><li>
<p>
<span class="emph">Simplicity</span>: Sometimes it’s easier just to stick in a few actions and avoid creating
a tree listener or visitor.
	</p>
</li>
<li>
<p id="f_0063.html.N16489">
<span class="emph">效率</span>：在资源关键型应用程序中，我们可能不想浪费构建解析树所需的时间或内存。
  </p>
</li><li>
<p>
<span class="emph">Efficiency</span>: In resource-critical applications, we might not want to
waste the time or memory needed to build a parse tree.
  </p>
</li>
<li>
<p id="f_0063.html.N1648F">
<span class="emph">谓词解析</span>：在极少数情况下，如果不引用先前在输入流中收集的数据，我们就无法正确解析。某些语法需要构建一个符号表，然后根据标识符是类型还是方法以不同的方式识别未来的输入。我们将在第 11 章“<a href="#f_0067.html.chp.predicates"><em>使用语义谓词</em></a><a href="#f_0067.html.chp.predicates">改变<em></em></a>中探讨这一点。
  </p>
</li><li>
<p>
<span class="emph">Predicated parsing</span>: In rare cases, we can’t parse properly without referencing data collected previously in the input stream. Some grammars need to build up a symbol table and then recognize future input differently, depending on whether an identifier is, say, a type or a method. We’ll explore this in Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>.
  </p>
</li>
</ul>
<p id="f_0063.html.N16497">
操作是用目标语言（ANTLR 生成代码的语言）编写的任意代码块，包含在 中<code class="cf ic">{...}</code>。只要这些操作是有效的目标语言语句，我们就可以在这些操作中执行任何操作。通常，操作对标记和规则引用的属性进行操作。例如，我们可以要求标记的文本或整个规则调用匹配的文本。使用从标记和规则引用中派生的数据，我们可以打印出来并执行任意计算。规则还允许参数和返回值，因此我们可以在规则之间传递数据。
</p><p>
Actions are arbitrary chunks of code written in the target language (the language in
which ANTLR generates code) enclosed in <code class="cf ic">{...}</code>. We can do whatever we want in
these actions as long as they are valid target language statements. Typically, actions
operate on the attributes of tokens and rule references. For example, we can ask for the
text of a token or the text matched by an entire rule invocation. Using data derived from
token and rule references, we can print things out and perform arbitrary computations.
Rules also allow parameters and return values so we can pass data around between
rules.
</p>
<p id="f_0063.html.N1649D">
我们将通过探索三个示例来了解语法操作。首先，我们将构建一个计算器，其功能与第 7.4 节“<a href="#f_0049.html.sec.labeling-alts">标记<em>精确事件方法的规则替代方案”</em>中相同。</a>其次，我们将向 CSV 语法添加一些操作（来自第 6.1 节“<a href="#f_0040.html.sec.CSV">解析<em>逗号分隔值</em>”）</a>以探索规则和标记属性。在第三个示例中，我们将通过为直到运行时才知道关键字的语言构建语法来了解词法分析器规则中的操作。
</p><p>
We’re going to learn about grammar actions by exploring three examples. First, we’re
going to build a calculator with the same functionality as that in Section 7.4, <a href="#f_0049.html.sec.labeling-alts">​<em>Labeling Rule Alternatives for Precise Event Methods</em>​</a>. Second, we’ll add some actions to the CSV grammar (from Section 6.1, <a href="#f_0040.html.sec.CSV">​<em>Parsing Comma-Separated Values</em>​</a>) to explore rule and token attributes. In the
third example, we’ll learn about actions in lexer rules by building a grammar for a
language whose keywords aren’t known until runtime.
</p>
<p id="f_0063.html.N164A6">
现在是时候开始行动了，从基于行动的计算器实现开始。
</p><p>
It’s time to get our hands dirty, starting with an action-based calculator implementation.
</p>

</div></div>
<div id="f_0064.html"><div>

<h2 id="f_0064.html.N164A9">10.1 使用语法操作构建计算器</h2><h2>10.1 Building a Calculator with Grammar Actions</h2>
<p id="f_0064.html.N164AD"><a href="#f_0027.html.sec.calc-visitor"><em>让我们重新回顾第 4.2 节“使用访问者</em></a><a href="#f_0027.html.sec.calc-visitor">构建<em></em></a>
中的表达式语法，<a href="#f_0027.html.sec.calc-visitor">以</a>了解操作。在该部分中，我们使用树访问者构建了一个计算器，该计算器评估了以下表达式：
</p><p>
Let’s revisit the expression grammar from Section 4.2, <a href="#f_0027.html.sec.calc-visitor">​<em>Building a Calculator Using a Visitor</em>​</a> to learn
about actions. In that section, we built a calculator using a tree visitor that evaluated
expressions such as the following:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/t.expr">动作/t.expr</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​x = 1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​x+2*3​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N164CC">
我们的目标是重现相同的功能，但不使用访问者，甚至不构建解析树。此外，我们将使用一个小技巧使其具有交互性，这意味着我们在按下<span style="background-color:rgb(230,230,250);font-family:&quot;DroidSans&quot;;color:#227">Return</span>时而不是在输入结束时获得结果。到目前为止，我们的示例已经处理了整个输入，然后处理了生成的解析树。
</p><p>
Our goal here is to reproduce that same functionality, but without using a visitor and
without even building a parse tree. Moreover, we’ll employ a little trick to make it
interactive, meaning we get results when we hit <span style="background-color:rgb(230,230,250); font-family:'DroidSans';color:#227">Return</span>, not at the end of the input. Our
examples so far have scarfed up the entire input and then processed the resulting parse
trees.
</p>
<p id="f_0064.html.N164D2">
在学习本节的过程中，我们将学习如何将生成的解析器放入包中、定义解析器字段和方法、在规则替代方案中插入操作、标记要在操作中使用的语法元素以及定义规则返回值。
</p><p>
As we go through this section, we’re going to learn how to put generated parsers
into packages, define parser fields and methods, insert actions within rule
alternatives, label grammar elements for use within actions, and define rule return
values.
</p>
<h3 id="f_0064.html.sec.grammar-actions">使用语法规则之外的动作</h3><h3>Using Actions Outside of Grammar Rules</h3>
<p id="f_0064.html.N164DA">
除了语法规则之外，我们还希望将两种东西注入到生成的解析器和词法分析器中：包/导入语句和类成员（如字段和方法）。</p><p>
Outside of grammar rules, there are two kinds of things we want to inject into
generated parsers and lexers: package/import statements and class members like
fields and methods.</p>
<p id="f_0064.html.N164E3">这是一个理想化的代码生成模板，它说明了我们想要在何处注入代码片段，比如说，解析器：
</p><p>Here is an idealized code generation template that illustrates
where we want to inject code snippets for, say, the parser:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;header&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> &lt;grammarName&gt;<strong class="prompt">Parser</strong> <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        &lt;members&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N1650F">
要指定标头操作，我们<code class="cf ic">@header {...}</code>在语法中使用。要将字段或方法注入生成的代码，我们使用<code class="cf keyword">@members
{...}</code>。在组合解析器/词法分析器语法中，这些命名的操作适用于解析器和词法分析器。（ANTLR 选项
<code class="cf commandoption">-package</code>让我们可以设置没有操作的包
<code class="cf keyword">header</code>。）要将操作限制为生成的解析器或词法分析器，我们使用<code class="cf ic">@parser::</code>
<span class="standin">name</span>或
<code class="cf ic">@lexer::</code>
<span class="standin">name</span>。
</p><p>
To specify a header action, we use <code class="cf ic">@header {...}</code> in our grammar. To inject
fields or methods into the generated code, we use <code class="cf keyword">@members
{...}</code>. In a combined parser/lexer grammar, these named actions apply to
both the parser and the lexer. (ANTLR option
<code class="cf commandoption">-package</code> lets us set the package without a
<code class="cf keyword">header</code> action.) To restrict an action to the generated parser or
lexer, we use <code class="cf ic">@parser::</code>
<span class="standin">name</span> or
<code class="cf ic">@lexer::</code>
<span class="standin">name</span>.
</p>
<p id="f_0064.html.N16532">
让我们看看这些对于我们的计算器来说是什么样子的。表达式语法像以前一样以语法声明开始，但现在我们要声明生成的代码位于 Java 包中。我们还需要导入一些标准 Java 实用程序类。
</p><p>
Let’s see what these look like for our calculator. The expression grammar starts with a
grammar declaration like before, but now we’re going to declare that the generated code
lives in a Java package. We’ll also need to import some standard Java utility classes.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Expr.g4">动作/工具/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Expr;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@header</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​package tools;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N16556">
上一个计算器的<code class="cf class">EvalVisitor</code>类有一个
<code class="cf variable">memory</code>字段，用于存储名称-值对以实现变量赋值和引用。我们将把它放在我们的
<code class="cf keyword">members</code>操作中。为了减少语法中的混乱，我们还定义一个名为的便捷方法，<code class="cf methodname">eval</code>该方法对两个操作数执行操作。完整的<code class="cf keyword">members</code>操作如下所示：
</p><p>
The previous calculator’s <code class="cf class">EvalVisitor</code> class had a
<code class="cf variable">memory</code> field that stored name-value pairs to implement
variable assignments and references. We’ll put that in our
<code class="cf keyword">members</code> action. To reduce clutter in the grammar, let’s also
define a convenience method called <code class="cf methodname">eval</code> that performs an operation
on two operands. Here’s what the complete <code class="cf keyword">members</code> action looks
like:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Expr.g4">动作/工具/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@parser</strong>::members {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">/** "memory" for our calculator; variable/value pairs go here */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    Map&lt;String, Integer&gt; memory = new HashMap&lt;String, Integer&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    int eval(int left, int op, int right) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        switch ( op ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            case MUL : return left * right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            case DIV : return left / right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            case ADD : return left + right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            case SUB : return left - right;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        return 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N1659F">
有了这个基础结构，让我们看看如何在规则元素中的操作中使用这些解析器类成员。
</p><p>
With that infrastructure in place, let’s see how to use these parser class members inside
actions among the rule elements.
</p>
<h3>在规则中嵌入操作</h3><h3>Embedding Actions Within Rules</h3>
<p id="f_0064.html.N165A9">
在本节中，我们将学习如何在语法中嵌入操作，以便生成一些输出、更新数据结构和设置规则返回值。我们还将了解 ANTLR 如何将规则参数、返回值和规则调用的其他属性包装到<code class="cf class">ParserRuleContext</code>子类的实例中。
</p><p>
In this section, we’re going to learn how to embed actions in the grammar in order to
generate some output, update data structures, and set rule return values. We’ll also look at
how ANTLR wraps up rule parameters, return values, and other attributes of a rule invocation
into instances of <code class="cf class">ParserRuleContext</code> subclasses.
</p>
<h4>基础知识</h4><h4>The Basics</h4>
<p id="f_0064.html.N165BF">
规则<code class="cf keyword">stat</code>可识别表达式、变量赋值和空行。由于我们不对空行执行任何操作，因此<code class="cf keyword">stat</code>  只需要两个操作。
</p><p>
Rule <code class="cf keyword">stat</code> recognizes expressions, variable assignments, and blank
lines. Because we do nothing upon a blank line, <code class="cf keyword">stat</code>  needs only two
actions.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Expr.g4">动作/工具/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   e NEWLINE           {System.out.println($e.v);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> e NEWLINE    {memory.put($ID.text, $e.v);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N165E1">
操作在前一个语法元素之后和下一个语法元素之前执行。在这种情况下，操作出现在备选项的末尾，因此它们在解析器匹配整个语句之后执行。当<code class="cf keyword">stat</code>看到后跟 的表达式时<code class="cf keyword">NEWLINE</code>，它应该打印表达式的值。当
<code class="cf keyword">stat</code>看到变量赋值时，它应该将名称-值对存储在字段 中<code class="cf variable">memory</code>。
</p><p>
Actions execute after the preceding grammar element and before the next one. In this
case, the actions appear at the end of the alternatives, so they execute after the
parser matches the entire statement. When <code class="cf keyword">stat</code> sees an expression
followed by <code class="cf keyword">NEWLINE</code>, it should print the value of the expression. When
<code class="cf keyword">stat</code> sees a variable assignment, it should store the name-value pair
in field <code class="cf variable">memory</code>.
</p>
<p id="f_0064.html.N165F0">
这些操作中唯一不熟悉的语法是<code class="cf ic">$e.v</code>和
<code class="cf ic">$ID.text</code>。通常，<code class="cf ic">$</code>
<span class="standin">x</span> . <span class="standin">y</span>
指的是元素<span class="standin">x的属性</span><span class="standin">y</span>，其中
<span class="standin">x</span>是标记引用或规则引用。这里，
指的是调用规则的返回值。（我们稍后会看到为什么这样调用它。）
指的是引用匹配的文本。 
<span class="standin"></span><span class="standin"></span><code class="cf ic">$e.v</code><code class="cf keyword">e</code><code class="cf variable">v</code><code class="cf ic">$ID.text</code><code class="cf keyword">ID</code></p><p>
The only unfamiliar syntax in those actions are <code class="cf ic">$e.v</code> and
<code class="cf ic">$ID.text</code>. In general, <code class="cf ic">$</code>
<span class="standin">x</span>.<span class="standin">y</span>
refers to attribute <span class="standin">y</span> of element <span class="standin">x</span>, where
<span class="standin">x</span> is either a token reference or a rule reference. Here,
<code class="cf ic">$e.v</code> refers to the return value from calling rule <code class="cf keyword">e</code>.
(We’ll see why it’s called <code class="cf variable">v</code> in a second.) <code class="cf ic">$ID.text</code>
refers to the text matched by the <code class="cf keyword">ID</code> reference. 
</p>
<p id="f_0064.html.N16629">
如果 ANTLR 无法识别<span class="standin">y</span>组件，则不会对其进行转换。在这种情况下，<code class="cf ic">text</code>是标记的已知属性，ANTLR 将其转换为<code class="cf ic">getText()</code>。我们也可以使用<code class="cf ic">$ID.getText()</code>来获得相同的东西。有关规则和标记的属性的完整列表，请参阅第 15.4 节“<a href="#f_0094.html.sec.actions">操作<em>和属性”</em></a>。
</p><p>
If ANTLR doesn’t recognize the <span class="standin">y</span> component, it doesn’t translate
it. In this case, <code class="cf ic">text</code> is a known attribute of a token, and ANTLR
translates it to <code class="cf ic">getText()</code>. We could also use <code class="cf ic">$ID.getText()</code> to
get the same thing.  For a complete list of the attributes for rules and tokens, see Section 15.4, <a href="#f_0094.html.sec.actions">​<em>Actions and Attributes</em>​</a>.
</p>
<p id="f_0064.html.N1663B">
现在转向规则<code class="cf keyword">e</code>，让我们看看嵌入操作后是什么样子。基本思想是<code class="cf class">EvalVisitor</code>
通过将代码片段作为操作直接插入语法中来模拟功能。
</p><p>
Turning to rule <code class="cf keyword">e</code> now, let’s see what it looks like with
embedded actions. The basic idea is to mimic the <code class="cf class">EvalVisitor</code>
functionality by inserting code snippets directly into the grammar as actions.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Expr.g4">动作/工具/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e <strong class="prompt">returns</strong> [int v]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : a=e op=(<em class="string">'*'</em>|<em class="string">'/'</em>) b=e  {$v = eval($a.v, $op.type, $b.v);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | a=e op=(<em class="string">'+'</em>|<em class="string">'-'</em>) b=e  {$v = eval($a.v, $op.type, $b.v);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT                   {$v = $INT.int;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      String id = $ID.text;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      $v = memory.containsKey(id) ? memory.get(id) : 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'('</em> e <em class="string">')'</em>             {$v = $e.v;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N16687">
本例中发生了许多有趣的事情。我们看到的第一件事是整数的返回值规范，<code class="cf variable">v</code>。这就是为什么
<code class="cf keyword">stat</code>的操作引用<code class="cf ic">$e.v</code>。ANTLR 返回值与 Java 返回值的不同之处在于我们可以命名它们，并且可以有多个。
</p><p>
A number of interesting things are going on in this example. The first thing we see
is the return value specification for an integer, <code class="cf variable">v</code>. That’s why
<code class="cf keyword">stat</code>’s actions refer to <code class="cf ic">$e.v</code>. ANTLR return values differ from
Java return values in that we get to name them and we can have more than one.
</p>
<p id="f_0064.html.N16693">
接下来，我们看到<code class="cf keyword">e</code>规则引用和操作符子规则上的标签，例如<code class="cf ic">op=(’*’|’/’)</code>。标签引用<code class="cf class">Token</code>或
<code class="cf class">ParserRuleContext</code>派生自匹配标记或调用规则的对象。 
</p><p>
Next, we see labels on <code class="cf keyword">e</code> rule references and on the operator
subrules such as <code class="cf ic">op=(’*’|’/’)</code>. Labels refer to <code class="cf class">Token</code> or
<code class="cf class">ParserRuleContext</code> objects derived from matching a token or invoking a rule. 
</p>
<p id="f_0064.html.N166A2">
在转到操作内容之前，值得一看的是 ANTLR 存储返回值和标签等内容的位置。这将使在源代码级调试时更容易跟踪 ANTLR 生成的代码。
</p><p>
Before turning to the action contents, it’s worth looking at where ANTLR stores things
like return values and labels. It’ll make following the ANTLR-generated code easier when
source-level debugging.
</p>
<h4>一个规则上下文对象来绑定所有规则</h4><h4>One Rule Context Object to Bind Them All</h4>
<p id="f_0064.html.N166AC">
在第 2.4 节“<a href="#f_0018.html.sec.parse-trees"><em>使用解析树</em></a><a href="#f_0018.html.sec.parse-trees">构建中，<em></em></a>我们了解到 ANTLR 使用规则上下文对象实现解析树节点。每次规则调用都会创建并返回一个规则上下文对象，该对象包含有关在输入流中的特定位置识别规则的所有重要信息。例如，规则
<code class="cf keyword">e</code>会创建并返回<code class="cf class">EContext</code>对象。
</p><p>
In Section 2.4, <a href="#f_0018.html.sec.parse-trees">​<em>Building Language Applications Using Parse Trees</em>​</a>, we learned that ANTLR implements parse-tree
nodes with rule context objects. Each rule invocation creates and returns a
rule context object, which holds all of the important information about the
recognition of a rule at a specific location in the input stream. For example, rule
<code class="cf keyword">e</code> creates and returns <code class="cf class">EContext</code> objects.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">final</strong> EContext e(...) <strong class="prompt">throws</strong> RecognitionException {...}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N166CF">
当然，规则上下文对象是放置规则特定实体的非常方便的地方。第一部分<code class="cf class">EContext</code>如下所示：
</p><p>
Naturally, a rule context object is a very handy place to put rule-specific
entities. The first part of <code class="cf class">EContext</code> looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> EContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">int</strong> v;       <em class="comment">// rule e return value from "returns [int v]"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> EContext a;  <em class="comment">// label a on (recursive) rule reference to e</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> Token op;    <em class="comment">// label on operator sub rules like ('*'|'/')</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> EContext b;  <em class="comment">// label b on (recursive) rule reference to e</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> Token INT;   <em class="comment">// reference to INT matched by 3rd alternative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> Token ID;    <em class="comment">// reference to ID matched by 4th alternative</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> EContext e;  <em class="comment">// reference to context object from e invocation</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N1672D">
标签始终会成为规则上下文对象中的字段，但 ANTLR 并不总是会为替代元素（例如 、 和 ）生成字段<code class="cf keyword">ID</code>。<code class="cf keyword">INT</code>仅<code class="cf keyword">e</code>当它们被语法中的动作引用时（就像<code class="cf keyword">e</code>的动作一样），ANTLR 才会为它们生成字段。ANTLR 会尝试减少上下文对象字段的数量。
</p><p>
Labels always become fields in the rule context object, but ANTLR doesn’t always generate
fields for alternative elements such as <code class="cf keyword">ID</code>, <code class="cf keyword">INT</code>,
and <code class="cf keyword">e</code>. ANTLR  generates fields for them only if they’re referenced by
actions in the grammar (as <code class="cf keyword">e</code>’s actions do). ANTLR tries to reduce the
number of context object fields.
</p>
<p id="f_0064.html.N16741">
现在我们已经准备好了所有部分，让我们来分析规则的替代方案中操作的内容<code class="cf keyword">e</code>。
</p><p>
Now we have all the pieces in place, so let’s analyze the contents of the actions
among the alternatives of rule <code class="cf keyword">e</code>.
</p>
<h4>计算返回值</h4><h4>Computing Return Values</h4>
<p id="f_0064.html.N1674B">
所有操作都使用<code class="cf keyword">e</code>赋值来设置返回值<code class="cf ic">$v =
...;</code>。这会设置返回值，但不执行规则函数的返回。（不要<code class="cf keyword">return</code>在操作中使用语句，因为它会使解析器失灵。）以下是前两种替代方案使用的操作：
</p><p>
All of the actions in <code class="cf keyword">e</code> set the return value with assignment <code class="cf ic">$v =
...;</code>. This sets the return value but does not perform a return from the rule
function. (Don’t use a <code class="cf keyword">return</code> statement in your actions because it
will make the parser go insane.) Here is the action used by the first two alternatives:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$v = eval($a.v, $op.type, $b.v);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N16768">
此操作计算子表达式的值并设置 的返回值
<code class="cf keyword">e</code>。 的参数是、和<code class="cf methodname">eval</code>的两个引用的返回值，而替代方案匹配的运算符的标记类型。
将始终是算术运算符之一的标记类型。请注意，我们可以重用标签（只要它们引用同一类型的东西）。第二种替代方案重用标签、和。
<code class="cf keyword">e</code><code class="cf ic">$a.v</code><code class="cf ic">$b.v</code><code class="cf ic">$op.type</code><code class="cf ic">$op.type</code><code class="cf variable">a</code><code class="cf variable">b</code><code class="cf variable">op</code></p><p>
This action computes the value of the subexpression and sets the return value for
<code class="cf keyword">e</code>. The arguments to <code class="cf methodname">eval</code> are the return values
from the two references to <code class="cf keyword">e</code>, <code class="cf ic">$a.v</code> and <code class="cf ic">$b.v</code>,
and the token type of the operator matched by the alternative, <code class="cf ic">$op.type</code>.
<code class="cf ic">$op.type</code> will always be the token type for one of the arithmetic
operators. Notice that we can reuse labels (as long as they refer to the same kind
of thing). The second alternative reuses labels <code class="cf variable">a</code>, <code class="cf variable">b</code>, and <code class="cf variable">op</code>.
</p>
<p id="f_0064.html.N16789">
第三种替代方案的操作使用<code class="cf ic">$INT.int</code>来访问与标记匹配的文本的整数值<code class="cf keyword">INT</code>。这只是 的简写
<code class="cf ic">Integer.valueOf($INT.text)</code>。嵌入的操作比等效的访问者方法简单得多<code class="cf methodname">visitInt</code>（但代价是将特定于应用程序的代码与语法纠缠在一起）。
</p><p>
The third alternative’s action uses <code class="cf ic">$INT.int</code> to access the integer value of the
text matched by the <code class="cf keyword">INT</code> token. This is just shorthand for
<code class="cf ic">Integer.valueOf($INT.text)</code>. The embedded action is much simpler than the equivalent visitor <code class="cf methodname">visitInt</code> method (but at the cost of entangling application-specific code with the grammar).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/EvalVisitor.java">旅游/EvalVisitor.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** INT */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​@Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">Integer</strong> visitInt(LabeledExprParser.IntContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">return</strong> <strong class="prompt">Integer</strong>.valueOf(ctx.INT().getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N167BD">
第四种选择识别变量引用，并将
<code class="cf keyword">e</code>的返回值设置为 中存储的值<code class="cf variable">memory</code>（如果我们已存储该名称的值）。此操作使用 Java<code class="cf ic">?:</code>运算符，但我们也可以同样轻松地使用 if-then-else Java 语句。我们可以将任何内容放入可作为 Java 方法主体的操作中。
</p><p>
The fourth alternative recognizes a variable reference and sets
<code class="cf keyword">e</code>’s return value to the value stored in <code class="cf variable">memory</code>,
if we’ve stored a value for that name. This action uses the Java <code class="cf ic">?:</code> operator,
but we could’ve just as easily used an if-then-else Java statement. We can put anything
into an action that would work as a body of a Java method.
</p>
<p id="f_0064.html.N167C9">
最后，<code class="cf ic">$v = $e.v;</code>最后一个选项中的操作将返回值设置为括号中匹配的表达式的结果。我们只是传递返回值。的值为<code class="cf ic">(3)</code>3。
</p><p>
Finally, the <code class="cf ic">$v = $e.v;</code> action in the last alternative sets the return
value to the result of the expression matched in parentheses. We’re just passing the return value through. The value of <code class="cf ic">(3)</code> is 3.
</p>
<p id="f_0064.html.N167D8">
这就是语法和动作代码。现在，让我们弄清楚如何为我们的计算器构建一个交互式驱动程序。
</p><p>
That’s it for the grammar and action code. Now, let’s figure out how to build an
interactive driver for our calculator.
</p>
<h3>构建交互式计算器</h3><h3>Building an Interactive Calculator</h3>
<p id="f_0064.html.N167DF">
在探索构建交互式工具的细节之前，让我们先尝试一下构建和测试语法和<code class="cf filename">Calc.java</code>测试装置。因为我们<code class="cf ic">package tools;</code>在<code class="cf keyword">header</code>操作中放入了语句，所以我们需要将生成的 Java 代码放在名为的目录中<code class="cf dir">tools</code>。（这反映了包和目录结构之间的标准 Java 关系。）这意味着我们需要从运行 ANTLR<code class="cf dir">tools</code>或从上面的目录运行它，而不是只使用<code class="cf dir">tools</code>  路径
。
<code class="cf filename">tools/Expr.g4</code><code class="cf filename">Expr.g4</code></p><p>
Before exploring the details of building an interactive tool, let’s give it a whirl by
building and testing the grammar and <code class="cf filename">Calc.java</code> test rig. Because we
put statement <code class="cf ic">package tools;</code> in the <code class="cf keyword">header</code> action, we need
to put the generated Java code in a directory called <code class="cf dir">tools</code>. (This reflects the
standard Java relationship between package and directory structure.) That means we need
to either run ANTLR from <code class="cf dir">tools</code> or run it from the directory above <code class="cf dir">tools</code>  with path
<code class="cf filename">tools/Expr.g4</code> instead of just <code class="cf filename">Expr.g4</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -no-listener tools/Expr.g4  </strong>
<em class="comment"># gen parser w/o listener into tools</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac -d . tools/*.java            </strong>
<em class="comment"># compile, put .class files in tools</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N16819">
为了尝试它，我们<code class="cf class">Calc</code>使用其完全限定名称来运行。
</p><p>
To try it, we run <code class="cf class">Calc</code> using its fully qualified name.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java tools.Calc</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">x = 1</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">x </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">x+2*3</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​7​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N16848"><span style="background-color:rgb(230,230,250);font-family:&quot;DroidSans&quot;;color:#227">您会注意到，当您按下Return 键</span>
时，计算器会立即给出答案。由于 ANTLR 默认读取整个输入（通常读入一个大缓冲区），因此我们必须逐行将输入传递给解析器以使其具有交互性。每行代表一个完整的表达式。（如果您需要处理可以跨越多行的表达式，请参阅《<a href="#f_0073.html.sec.python-newlines">Fun<em> with Python Newlines</em></a>》 <a href="#f_0073.html.sec.python-newlines">。</a><code class="cf methodname">main</code>方法中，我们得到第一个表达式的方法如下：
</p><p>
You’ll notice that the calculator immediately responds with an answer when you hit <span style="background-color:rgb(230,230,250); font-family:'DroidSans';color:#227">Return</span>.
Because ANTLR reads the entire input (usually into a big buffer) by default, we have to pass
input line by line to the parser to make it interactive. Each line represents a complete
expression. (If you need to handle expressions that can span multiple lines, see <a href="#f_0073.html.sec.python-newlines">​<em>Fun with Python Newlines</em>​</a>.) In the <code class="cf methodname">main</code> method, here’s how we get the first expression:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Calc.java">动作/工具/Calc.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">BufferedReader</strong> br = <strong class="prompt">new</strong> <strong class="prompt">BufferedReader</strong>(<strong class="prompt">new</strong> <strong class="prompt">InputStreamReader</strong>(is));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">String</strong> expr = br.readLine();              <em class="comment">// get first expression</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> line = 1;                             <em class="comment">// track input expr line numbers</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N1687D">
为了<code class="cf variable">memory</code>在表达式中维护字段值，我们需要为所有输入行共享一个解析器。
</p><p>
To maintain <code class="cf variable">memory</code> field values across expressions, we need a
single shared parser for all input lines.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Calc.java">动作/工具/Calc.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ExprParser parser = <strong class="prompt">new</strong> ExprParser(null); <em class="comment">// share single parser instance</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.setBuildParseTree(false);          <em class="comment">// don't need trees</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N1689A">
当我们读一行时，我们将创建一个新的标记流并将其传递给共享解析器。
</p><p>
As we read in a line, we’ll create a new token stream and pass it to the shared
parser.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/tools/Calc.java">动作/工具/Calc.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">while</strong> ( expr!=null ) {             <em class="comment">// while we have more expressions</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// create new lexer and token stream for each line (expression)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRInputStream(expr+<em class="string">"\n"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ExprLexer lexer = <strong class="prompt">new</strong> ExprLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    lexer.setLine(line);           <em class="comment">// notify lexer of input position</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    lexer.setCharPositionInLine(0);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    parser.setInputStream(tokens); <em class="comment">// notify parser of new token stream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    parser.stat();                 <em class="comment">// start the parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    expr = br.readLine();          <em class="comment">// see if there's another line</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    line++;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0064.html.N168E5">
现在，我们知道如何构建交互式工具，并且对如何放置和使用嵌入式操作有了很好的了解。我们的计算器使用一个<code class="cf keyword">header</code>操作来指定包，使用一个<code class="cf keyword">members</code>操作来定义两个解析器类成员。我们使用规则内的操作来计算并返回子表达式值作为标记和规则属性的函数。在下一节中，我们将看到更多属性并确定更多操作位置。
</p><p>
So, now we know how to build an interactive tool, and we have a pretty good idea about how
to place and use embedded actions. Our calculator used a <code class="cf keyword">header</code> action
to specify a package and a <code class="cf keyword">members</code> action to define two parser class
members. We used actions within the rules to compute and return subexpression values as a
function of token and rule attributes. In the next section, we’re going to see some more
attributes and identify a few more action locations.
</p>

</div></div>
<div id="f_0065.html"><div>

<h2 id="f_0065.html.sec.token-rule-attributes">10.2 访问令牌和规则属性</h2><h2>10.2 Accessing Token and Rule Attributes</h2>
<p id="f_0065.html.N168F9">
让我们使用第 6.1 节<a href="#f_0040.html.sec.CSV">“解析<em>逗号分隔值”</em>中的 CSV 语法作为</a>探索更多与操作相关的功能的基础。我们将构建一个应用程序，为每行创建从列名到字段的映射，并打印出从解析数据中获得的信息。我们的目标实际上只是了解有关规则相关操作和属性的更多信息。
</p><p>
Let’s use the CSV grammar from Section 6.1, <a href="#f_0040.html.sec.CSV">​<em>Parsing Comma-Separated Values</em>​</a> as a foundation for exploring some
more action-related features. We’re going to build an application that creates a map from 
column name to field for each row and prints out information gained from parsing the
data. Our goal here is really just to learn more about rule-related actions and
attributes.
</p>
<p id="f_0065.html.N168FF">
首先，让我们看看如何使用
<code class="cf keyword">locals</code>部分定义局部变量。与参数和返回值一样，部分中的声明<code class="cf keyword">locals</code>将成为规则上下文对象中的字段。由于我们每次调用规则时都会获得一个新的规则上下文对象，因此我们会获得局部变量的新副本，正如我们预期的那样。以下增强版规则<code class="cf keyword">file</code>
可以做很多有趣的事情，但让我们首先关注它对局部变量的作用。
</p><p>
First, let’s take a look at how to define local variables using the
<code class="cf keyword">locals</code> section. As with parameters and return values, the declarations
in a <code class="cf keyword">locals</code> section become fields in the rule context object. Because
we get a new rule context object for every rule invocation, we get a new copy of the
locals as we’d expect. The following augmented version of rule <code class="cf keyword">file</code>
does a number of interesting things, but let’s start by focusing on what it does with
locals.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/CSV.g4">动作/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Derived from rule "file : hdr row+ ;" */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     : hdr ( rows+=row[$hdr.text.split(<em class="string">","</em>)] {$i++;} )+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       System.out.println($i+<em class="string">" rows"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       for (RowContext r : $rows) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​           System.out.println(<em class="string">"row token interval: "</em>+r.getSourceInterval());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N1694C">
规则<code class="cf keyword">file</code>定义了一个局部变量，<code class="cf variable">i</code>并使用它计算使用操作的输入中有多少行<code class="cf ic">$i++;</code>。要引用局部变量，请不要忘记<code class="cf ic">$</code>字符前缀，否则编译器会抱怨未定义的变量。ANTLR 转换<code class="cf ic">$i</code>为<code class="cf ic">_localctx.i</code>；为生成的规则函数中没有<code class="cf variable">i</code>局部变量<code class="cf keyword">file</code>。
</p><p>
Rule <code class="cf keyword">file</code> defines a local variable, <code class="cf variable">i</code>, and
uses it to count how many rows there are in the input using action <code class="cf ic">$i++;</code>.
To reference local variables, don’t forget the <code class="cf ic">$</code> character prefix, or the compiler will complain about undefined variables. ANTLR translates <code class="cf ic">$i</code> to <code class="cf ic">_localctx.i</code>; there is no <code class="cf variable">i</code> local variable in the rule function generated for <code class="cf keyword">file</code>.
</p>
<p id="f_0065.html.N16967">
接下来我们看一下规则的调用<code class="cf keyword">row</code>。规则调用
<code class="cf ic">row[$hdr.text.split(",")]</code>说明我们使用方括号而不是圆括号来向规则传递参数（ANTLR 使用圆括号来表示子规则语法）。参数表达式将规则调用<code class="cf ic">$hdr.text.split(",")</code>匹配的文本拆分<code class="cf keyword">hdr</code>为所需的字符串数组
<code class="cf keyword">row</code>。  
</p><p>
Next, let’s take a look at the call to rule <code class="cf keyword">row</code>. Rule invocation
<code class="cf ic">row[$hdr.text.split(",")]</code> illustrates that we use square brackets instead
of parentheses to pass parameters to rules (ANTLR uses parentheses for subrule
syntax). Argument expression <code class="cf ic">$hdr.text.split(",")</code> splits the text matched
by the <code class="cf keyword">hdr</code> rule invocation to get an array of strings needed by
<code class="cf keyword">row</code>.  
</p>
<p id="f_0065.html.N1697E">
让我们将其分开。<code class="cf ic">$hdr</code>是对唯一<code class="cf keyword">hdr</code>
调用的引用，并对其对象进行求值。在这种情况下，<code class="cf class">HdrContext</code>我们不需要标记引用（如），因为
是唯一的。然后，是与标题行匹配的文本。我们使用标准 Java .方法拆分逗号分隔的标题列
，该方法返回一个字符串数组。我们很快就会看到规则采用字符串数组参数。
<code class="cf keyword">hdr</code><code class="cf ic">h=hdr</code><code class="cf ic">$hdr</code><code class="cf ic">$hdr.text</code><code class="cf class">String</code><code class="cf methodname">split</code><code class="cf keyword">row</code></p><p>
Let’s break that apart. <code class="cf ic">$hdr</code> is a reference to the sole <code class="cf keyword">hdr</code>
invocation and evaluates to its <code class="cf class">HdrContext</code> object. We don’t need to label
the <code class="cf keyword">hdr</code> reference in this case (like <code class="cf ic">h=hdr</code>) because
<code class="cf ic">$hdr</code> is unique. <code class="cf ic">$hdr.text</code>, then, is the text matched for the header
row. We split the comma-separated header columns using the standard Java
<code class="cf class">String</code>.<code class="cf methodname">split</code> method, which returns an array of strings.
We’ll see shortly that rule <code class="cf keyword">row</code> takes an array-of-string parameter.
</p>
<p id="f_0065.html.N1699F">
调用<code class="cf keyword">row</code>还引入了一种新的标签，它使用
<code class="cf ic">+=</code>而不是<code class="cf ic">=</code>标签运算符。标签不是跟踪单个值，而是所有调用返回的<code class="cf variable">rows</code>所有对象的列表。在打印出行数后， 中的最后一个操作有一个循环，该循环遍历对象
。每次循环时，它都会打印出与调用匹配的标记索引范围（使用
）。
<code class="cf class">RowContext</code><code class="cf keyword">row</code><code class="cf keyword">file</code><code class="cf class">RowContext</code><code class="cf keyword">row</code><code class="cf methodname">getSourceInterval</code></p><p>
The call to <code class="cf keyword">row</code> also introduces a new kind of label that uses
<code class="cf ic">+=</code> instead of the <code class="cf ic">=</code> label operator. Rather than tracking a single
value, label <code class="cf variable">rows</code> is a list of all <code class="cf class">RowContext</code> objects
returned from all <code class="cf keyword">row</code> invocations. After printing out the number of
rows, the final action in <code class="cf keyword">file</code> has a loop that iterates through the
<code class="cf class">RowContext</code> objects. Each time through the loop, it prints out the range of
token indexes matched by the <code class="cf keyword">row</code> invocation (using
<code class="cf methodname">getSourceInterval</code>).
</p>
<p id="f_0065.html.N169C5">
该循环使用<code class="cf ic">r</code>，而不是<code class="cf ic">$r</code>，因为<code class="cf variable">r</code>是在 Java 操作中创建的局部变量。ANTLR 只能看到用关键字定义的局部变量
<code class="cf keyword">locals</code>，而不能看到任意用户定义的嵌入式操作中的局部变量。不同之处在于规则的解析树节点<code class="cf keyword">file</code>将定义字段
<code class="cf variable">i</code>，但不会定义<code class="cf variable">r</code>。
</p><p>
That loop uses <code class="cf ic">r</code>, not <code class="cf ic">$r</code>, because <code class="cf variable">r</code> is a local variable
created within a Java action. ANTLR can  see only those local variables defined with the
<code class="cf keyword">locals</code> keyword, not in arbitrary user-defined embedded actions. The
difference is that the parse tree node for rule <code class="cf keyword">file</code> would define field
<code class="cf variable">i</code> but not <code class="cf variable">r</code>.
</p>
<p id="f_0065.html.N169DD">
现在转到规则<code class="cf keyword">hdr</code>，让我们只打印出标题行。我们可以通过引用 来做到这一点<code class="cf ic">$row.text</code>，这是规则引用匹配的文本<code class="cf keyword">row</code>。或者，我们可以用 来请求周围规则的文本<code class="cf ic">$text</code>。
</p><p>
Turning to rule <code class="cf keyword">hdr</code> now, let’s just print out the header row. We could do that by referencing <code class="cf ic">$row.text</code>, which is the text matched by the <code class="cf keyword">row</code> rule reference. Alternatively, we can ask for the text of the surrounding rule with <code class="cf ic">$text</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/CSV.g4">动作/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​hdr : row[null] {System.out.println(<em class="string">"header: '"</em>+$text.trim()+<em class="string">"'"</em>);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16A05">
在这种情况下，它也将是匹配的文本，<code class="cf keyword">row</code>因为这就是该规则中的全部内容。
</p><p>
In this case, it will also be the text matched by <code class="cf keyword">row</code> because that is all there is in that rule.
</p>
<p id="f_0065.html.N16A0B">
现在让我们弄清楚如何使用规则中的操作将每行数据转换为从列名到值的映射<code class="cf keyword">row</code>。首先
<code class="cf keyword">row</code>，将列名数组作为参数并返回映射。接下来，要遍历列名数组，我们需要一个局部变量。<code class="cf variable">col</code>在解析行之前，我们需要初始化返回值映射，并且，为了好玩，让我们在完成后打印出映射<code class="cf keyword">row</code>
。所有这些都进入规则的标题。
</p><p>
Now let’s figure out how to convert every row of data into a map from column
name to value with actions in rule <code class="cf keyword">row</code>. To begin with,
<code class="cf keyword">row</code> takes the array of column names as a parameter and returns
the map. Next, to move through the column names array, we’ll need a local variable, <code class="cf variable">col</code>. Before parsing the row, we need to initialize the
return value map, and, for fun, let’s print out the map after <code class="cf keyword">row</code>
finishes. All of that goes into the header for the rule.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/CSV.g4">动作/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Derived from rule "row : field (',' field)* '\r'? '\n' ;" */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row[String[] columns] <strong class="prompt">returns</strong> [Map&lt;String,String&gt; values]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int col=0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@init</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    $values = new HashMap&lt;String,String&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@after</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    if ($values!=null &amp;&amp; $values.size()&gt;0) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        System.out.println(<em class="string">"values = "</em>+$values);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16A52"><code class="cf keyword">init</code>无论有多少个备选方案，操作都会在规则中匹配任何内容之前发生。同样，操作
也会在规则匹配其中一个备选方案之后发生。在这种情况下，我们可以通过将 print 语句放在 的外部备选方案
末尾的操作中来<code class="cf keyword">after</code>
表达操作功能。<code class="cf keyword">after</code><code class="cf keyword">row</code></p><p>
The <code class="cf keyword">init</code> action happens before anything is matched in the rule,
regardless of how many alternatives there are. Similarly, the <code class="cf keyword">after</code>
action happens after the rule matches one of the alternatives. In this case, we could
express the <code class="cf keyword">after</code> action functionality by putting the print statement
in an action at the end of <code class="cf keyword">row</code>’s outer alternative.
</p>
<p id="f_0065.html.N16A6B">
一切设置完毕后，我们就可以收集数据并填充地图。
</p><p>
With everything set up, we can collect the data and fill the map.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/CSV.g4">动作/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// rule row cont'd...</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        if ($columns!=null) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            $values.put($columns[$col++].trim(), $field.text.trim());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        (   <em class="string">','</em> field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            if ($columns!=null) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                $values.put($columns[$col++].trim(), $field.text.trim());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )* <em class="string">'\r'</em>? <em class="string">'\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16AAE">
操作的主要部分是
<code class="cf variable">values</code>使用 将字段值存储在映射中的列名中<code class="cf ic">$values.put(...)</code>。第一个参数获取列名，增加列数，并修剪名称中的空格：<code class="cf ic">$columns[$col++].trim()</code>。第二个参数修剪最近匹配字段的文本：<code class="cf ic">$field.text.trim()</code>。（ 中的两个操作
<code class="cf keyword">row</code>是相同的，因此将其考虑为<code class="cf keyword">members</code>操作中的方法可能是个好主意。）
</p><p>
The meaty parts of the actions store the field value at the column name in the
<code class="cf variable">values</code> map using <code class="cf ic">$values.put(...)</code>. The first parameter gets
the column name, increments the column count, and trims away the whitespace from the
name: <code class="cf ic">$columns[$col++].trim()</code>. The second parameter trims the text of the
most recently matched field: <code class="cf ic">$field.text.trim()</code>. (Both actions in
<code class="cf keyword">row</code> are identical, so it might be a good idea to factor that out into
a method in a <code class="cf keyword">members</code> action.)
</p>
<p id="f_0065.html.N16AC3">
中的其他所有内容<code class="cf filename">CSV.g4</code>我们都很熟悉，所以让我们继续构建这个东西并尝试一下。由于 ，我们不需要编写特殊的测试装置，<code class="cf commandname">grun</code>因此我们只需生成解析器并进行编译即可。
</p><p>
Everything else in <code class="cf filename">CSV.g4</code> is familiar to us, so let’s move on
to building this thing and giving it a try. We don’t need to write a special test
rig because of <code class="cf commandname">grun</code>, so we can just generate the parser
and compile it.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -no-listener CSV.g4   </strong>
<em class="comment"># again, we won't use a listener</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac CSV*.java</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16AE3">
以下是我们可以使用的一些 CSV 数据：
</p><p>
Here’s some CSV data we can use:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/users.csv">操作/用户.csv</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​User,  Name,    Dept​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parrt, Terence, 101​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tombu, Tom,     020​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​bke, Kevin,     008​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16AFC">
输出如下：
</p><p>
And, here is the output:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun CSV file users.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​header: 'User,  Name,    Dept'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​values = {Name=Terence, User=parrt, Dept=101}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​values = {Name=Tom, User=tombu, Dept=020}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​values = {Name=Kevin, User=bke, Dept=008}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​3 rows​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row token interval: 6..11​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row token interval: 12..17​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row token interval: 18..23​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0065.html.N16B26">
Rule<code class="cf keyword">hdr</code>打印出第一行输出，以及<code class="cf keyword">row</code>打印出行的三个调用<code class="cf ic">values = ...</code>。回到规则中<code class="cf keyword">file</code>，操作打印出行数以及与每行数据关联的标记间隔。
</p><p>
Rule <code class="cf keyword">hdr</code> prints out the first line of output, and the three calls to <code class="cf keyword">row</code> print out the <code class="cf ic">values = ...</code> lines. Back in rule <code class="cf keyword">file</code>, the action prints out the number of rows and the token intervals associated with each row of data.
</p>
<p id="f_0065.html.N16B35">
至此，我们已经很好地掌握了规则内部和外部嵌入操作的使用。我们还对规则属性了解颇多。另一方面，计算器和 CSV 示例都专门在解析器规则中使用操作。事实证明，操作在词法分析器规则中也非常有用。接下来，我们将通过了解如何处理大量或动态的关键字集来探索这一点。
</p><p>
At this point, we have a very good handle on the use of embedded actions, both inside and
outside of rules. We also know quite a bit about rule attributes. On the other hand, both
the calculator and CSV example use actions exclusively in the parser rules. It turns out
actions can be very useful in lexer rules as well. We’ll explore that next by seeing how
to handle a large or dynamic set of keywords.
</p>

</div></div>
<div id="f_0066.html"><div>

<h2 id="f_0066.html.sec.dynamic-keywords">10.3 识别关键字不固定的语言</h2><h2>10.3 Recognizing Languages Whose Keywords Aren’t Fixed</h2>
<p id="f_0066.html.N16B3D">
为了探索词法分析器规则中嵌入的操作，让我们为一种人为设计的编程语言构建一个语法，该语言的关键字可以动态变化（从运行到运行）。这并不像听起来那么不寻常。例如，在版本 5 中，Java 添加了关键字
<code class="cf keyword">enum</code>，因此同一个编译器必须能够根据选项启用和禁用关键字<code class="cf commandoption">-version</code>。
</p><p>
To explore actions embedded in lexer rules, let’s build a grammar for a contrived
programming language whose keywords can change dynamically (from run to run). This is not as
unusual as it sounds. For example, in version 5, Java added the keyword
<code class="cf keyword">enum</code>, so the same compiler must be able to enable and disable a
keyword depending on the <code class="cf commandoption">-version</code> option.
</p>
<p id="f_0066.html.N16B4C">
也许更常见的用途是处理具有大量关键字集的语言。与其让词法分析器单独匹配所有关键字（作为单独的规则），我们可以制定一个包罗万象的<code class="cf keyword">ID</code>规则，然后在关键字表中查找标识符。如果词法分析器找到一个关键字，我们可以将标记类型从通用类型专门设置<code class="cf keyword">ID</code>为该关键字的标记类型。
</p><p>
Perhaps a more common use would be dealing with languages that have huge keyword sets.
Rather than making the lexer match all of the keywords individually (as separate rules),
we can make a catchall <code class="cf keyword">ID</code> rule and then look up the identifier in a
keywords table. If the lexer finds a keyword, we can specifically set the token type from
a generic <code class="cf keyword">ID</code> to the token type for that keyword.
</p>
<p id="f_0066.html.N16B58">
在了解<code class="cf keyword">ID</code>规则和关键字查找机制之前，我们先来看一下引用关键字的语句规则。
</p><p>
Before we get to the <code class="cf keyword">ID</code> rule and the keyword lookup mechanism, let’s take a look at a statement rule that references keywords.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   BEGIN stat* END​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   IF expr THEN stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   WHILE expr stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'='</em> expr <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   INT | CHAR ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16B81">
ANTLR 会隐式地为关键字<code class="cf keyword">BEGIN</code>、
<code class="cf keyword">END</code>等定义标记类型。但是，ANTLR 会警告我们这些标记类型没有相应的词汇定义。
</p><p>
ANTLR will implicitly define token types for the keywords <code class="cf keyword">BEGIN</code>,
<code class="cf keyword">END</code>, and so on. But, ANTLR will warn us that there is no
corresponding lexical definition for these token types.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Keywords.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​warning(125): Keywords.g4:31:8: implicit definition of token BEGIN in parser​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16BA0">
 为了平息这个警告，我们要明确一点。
</p><p>
 To hush this warning, let’s be explicit.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// explicitly define keyword token types to avoid implicit def warnings</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> { BEGIN, END, IF, THEN, WHILE }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16BB6">
在生成的中<code class="cf class">KeywordsParser</code>，ANTLR 定义标记类型如下：
</p><p>
In the generated <code class="cf class">KeywordsParser</code>, ANTLR defines token types like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">int</strong> ID=3, BEGIN=4, END=5, IF=6, ... ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16BD3">
现在我们已经定义了我们的标记类型，让我们看一下语法声明和动作
<code class="cf keyword">header</code>，它导入<code class="cf class">Map</code>和
<code class="cf class">HashMap</code>。
</p><p>
Now that we’ve defined our token types, let’s look at the grammar declaration and a
<code class="cf keyword">header</code> action, which imports <code class="cf class">Map</code> and
<code class="cf class">HashMap</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Keywords;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::<strong class="prompt">header</strong> {    <em class="comment">// place this header action only in lexer, not the parser</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16C05">
我们将使用<code class="cf class">Map</code>从关键字名称到整数标记类型的关键字表，并且我们可以使用 Java 实例初始化器（花括号的内部集合）内联定义映射。
</p><p>
We’ll use a <code class="cf class">Map</code> from keyword name to integer token type for the
keywords table, and we can define the mappings inline using a Java instance
initializer (the inner set of curly braces).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::members {   <em class="comment">// place this class member only in lexer</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Map&lt;String,Integer&gt; keywords = new HashMap&lt;String,Integer&gt;() {{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"begin"</em>, KeywordsParser.BEGIN);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"end"</em>,   KeywordsParser.END);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"if"</em>,    KeywordsParser.IF);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"then"</em>,  KeywordsParser.THEN);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"while"</em>, KeywordsParser.WHILE);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}};​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16C43">
在所有基础设施都到位后，让我们像以前多次做过的那样匹配标识符，但要采取适当翻转令牌类型的操作。
</p><p>
With all of our infrastructure in place, let’s match identifiers as we’ve done many times before, but with an action that flips the token type appropriately.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        if ( keywords.containsKey(getText()) ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            setType(keywords.get(getText())); <em class="comment">// reset token type</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16C67">
这里我们使用 的<code class="cf class">Lexer</code>方法<code class="cf methodname">getText</code>来获取当前标记的文本。我们使用它来查看标识符是否存在于 中
<code class="cf variable">keywords</code>。如果存在，那么我们将标记类型从 重置
<code class="cf keyword">ID</code>为关键字的标记类型值。
</p><p>
Here we use <code class="cf class">Lexer</code>’s <code class="cf methodname">getText</code> method to get the text
of the current token. We use it to see whether the identifier exists within
<code class="cf variable">keywords</code>. If it does, then we reset the token type from
<code class="cf keyword">ID</code> to the keyword’s token type value.
</p>
<p id="f_0066.html.N16C76">
在我们玩词法分析器时，让我们弄清楚如何更改标记的文本。这对于从字符和字符串文字中剥离单引号和双引号很有用。通常，语言应用程序只需要引号内的文本。以下是使用 覆盖标记文本的方法<code class="cf methodname">setText</code>：
</p><p>
While we’re having fun in the lexer, let’s figure out how to change the text of a token.
This is useful for stripping single and double quotes from character and string literals.
Usually, a language application would want just the text inside the quotes. Here’s how
to override the text of a token using <code class="cf methodname">setText</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/Keywords.g4">动作/关键词.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Convert 3-char 'x' input sequence to string x */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CHAR:   <em class="string">'\''</em> . <em class="string">'\''</em> {setText( String.valueOf(getText().charAt(1)) );} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16C93">
如果我们真的想疯狂一点，我们甚至可以<code class="cf class">Token</code>使用 指定从词法分析器返回的对象<code class="cf methodname">setToken</code>。这是返回自定义标记实现的一种方法。另一种方法是重写 的<code class="cf class">Lexer</code>方法<code class="cf methodname">emit</code>
。
</p><p>
If we wanted to get really crazy, we could even specify the <code class="cf class">Token</code> object to
return from the lexer using <code class="cf methodname">setToken</code>. This is a way to return custom token
implementations. Another way is to override <code class="cf class">Lexer</code>’s <code class="cf methodname">emit</code>
method.
</p>
<p id="f_0066.html.N16CA2">
我们已准备好尝试我们的小语言。我们期望的行为是将关键字与常规标识符区分开来。换句话说，<code class="cf ic">x = 34;</code>应该可以工作，但<code class="cf ic">if = 34;</code>不应该，因为<code class="cf ic">if</code>是关键字。让我们运行 ANTLR，编译生成的代码，并在有效分配上尝试它。
</p><p>
We’re ready to try our little language. The behavior we expect is to have keywords differentiated from regular identifiers.  In other words, <code class="cf ic">x = 34;</code> should work, but <code class="cf ic">if = 34;</code> should not because <code class="cf ic">if</code> is a keyword. Let’s run ANTLR, compile the generated code, and try it on the valid assignment.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener Keywords.g4 </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Keywords*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Keywords stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">x = 34;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16CCF">
没问题；没有错误。但是，解析器对试图用作<code class="cf ic">if</code>标识符的赋值给出语法错误。它还接受有效的<code class="cf ic">if</code>语句而没有错误。
</p><p>
No problem; there are no errors. However, the parser gives a syntax error for the assignment that tries to use <code class="cf ic">if</code> as an identifier. It also accepts a valid <code class="cf ic">if</code> statement without error.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Keywords stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">if = 34;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:3 extraneous input '=' expecting {CHAR, INT}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 2:0 mismatched input '&lt;EOF&gt;' expecting THEN​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Keywords stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">if 1 then i = 4;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0066.html.N16D05">
如果您不幸地为某种语言构建了一个解析器，而在某些情况下，该语言允许使用关键字作为标识符，请参阅<a href="#f_0073.html.sec.keywords-as-ids">将<em>关键字视为标识符</em></a>。
</p><p>
If you are unlucky enough to be building a parser for a language that, in some
contexts, allows keywords as identifiers, see <a href="#f_0073.html.sec.keywords-as-ids">​<em>Treating Keywords As Identifiers</em>​</a>.
</p>
<p id="f_0066.html.N16D0B">
与解析器相比，词法分析器中很少需要操作，但在需要更改标记类型或标记文本的情况下，它们仍然很有用。我们还可以通过事后查看标记流来更改标记，而不是在对输入进行标记时使用操作。
</p><p>
Actions are less commonly needed in the lexer than the parser, but they are still useful in
situations like this where we need to alter token types or the token text. We could also
alter tokens by looking at the token stream after the fact instead of with actions while
tokenizing the input.
</p>
<p id="f_0066.html.N16D0E">
在本章中，我们学习了如何使用规则元素之间的动作将应用程序代码嵌入语法中，以及使用命名动作（例如
<code class="cf keyword">header</code>和）将应用程序代码嵌入规则外部<code class="cf keyword">members</code>。我们还了解了如何定义和引用规则参数和返回值。在此过程中，我们还使用了标记属性（例如<code class="cf variable">text</code>和 ）<code class="cf variable">type</code>。总之，这些与动作相关的功能使我们能够自定义 ANTLR 生成的代码。
</p><p>
In this chapter, we learned how to embed application code within grammars using
actions among the rule elements and outside rules using named actions such as
<code class="cf keyword">header</code> and <code class="cf keyword">members</code>. We also saw how to define
and reference rule parameters and return values. Along the way, we also used token
attributes such as <code class="cf variable">text</code> and <code class="cf variable">type</code>. Taken
together, these action-related features let us customize the code ANTLR generates.
</p>
<p id="f_0066.html.N16D20">
再次强调，尽量避免使用语法动作，因为动作会将语法与特定的编程语言目标联系起来。动作还会将语法与特定的应用程序联系起来。话虽如此，您可能并不关心这些问题，因为您的公司总是使用一种语言编程，而且您的语法无论如何都是特定于特定应用程序的。在这种情况下，出于简单或效率的原因（不构造解析树），将动作直接嵌入语法中是有意义的。最重要的是，一些解析问题需要运行时测试才能正确识别输入。在下一章中，我们将探讨称为<span class="firstuseinline">语义谓词</span>的任意布尔表达式，它可以动态地打开和关闭替代方案。
</p><p>
Again, try to avoid grammar actions when you can because actions tie a grammar to a
particular programming language target. Actions also tie a grammar to a specific
application. That said, you might not care about these issues because your company always
programs in a single language and your grammar is specific to a particular application
anyway. In that situation, it could make sense to embed actions directly in the grammar for
simplicity or efficiency reasons (no parse tree construction). Most importantly, some
parsing problems require runtime tests to recognize the input properly. In the next chapter,
we’re going to explore arbitrary Boolean expressions called <span class="firstuseinline">semantic
predicates</span> that can dynamically turn alternatives on and off.
</p>

<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0067.html"><div>

<h1 class="chapter-title" id="f_0067.html.chp.predicates">
<span class="chapter-number">
	      第十一章</span>
<br><br>
<span class="chapter-name">使用语义谓词改变解析</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      11</span>
<br><br>
<span class="chapter-name">Altering the Parse with Semantic Predicates</span>
</h1>

<p id="f_0067.html.N16D2F">
在上一章中，我们学习了如何在语法中嵌入操作，以便在解析过程中即时执行特定于应用程序的代码。这些操作不会以任何方式影响解析器的操作，就像日志语句不会影响周围的程序一样。我们嵌入的操作只是计算值或打印出内容。然而，在极少数情况下，使用嵌入代码更改解析是合理识别语言输入句子的唯一方法。
</p><p>
In the previous chapter, we learned how to embed actions within a grammar in order to
execute application-specific code on-the-fly during the parse. Those actions did not
affect the operation of the parser in any way, much as log statements do not affect
the surrounding program. Our embedded actions just computed values or printed things
out. In rare cases, however, altering the parse with embedded code is the only way
to reasonably recognize the input sentences of a language.
</p>
<p id="f_0067.html.N16D3A">
在本章中，我们将学习一种<code class="cf ic">{...}?</code>称为
<span class="firstuseinline">语义谓词</span>的特殊操作，它让我们可以在运行时有选择地停用部分语法。谓词是布尔表达式，可以减少解析器看到的选择数量。信不信由你，有选择地减少选择实际上会提高解析器的功能！
</p><p>
In this chapter, we’re going to learn about special actions, <code class="cf ic">{...}?</code>, called
<span class="firstuseinline">semantic predicates</span> that let us selectively deactivate portions
of a grammar at runtime. Predicates are Boolean expressions that have the effect of
reducing the number of choices that the parser sees. Believe it or not, selectively
reducing choice actually increases the power of the parser!
</p>
<p id="f_0067.html.N16D4D">
语义谓词有两种常见用例。首先，我们可能需要一个解析器来处理同一语言的多个略有不同的版本（方言）。例如，数据库供应商的 SQL 语法会随着时间的推移而发展。要为该供应商构建数据库前端，我们需要支持同一 SQL 的不同版本。同样，Gnu C 编译器<code class="cf commandname">gcc</code>必须处理 ANSI C 以及其自己的方言，这些方言添加了诸如出色的计算 goto 之类的功能。此外，语义谓词让我们可以在运行时使用命令行开关或其他动态机制在方言之间进行选择。
</p><p>
There are two common use cases for semantic predicates. First, we might need a parser to
handle multiple, slightly different versions (dialects) of the same language. For example,
the syntax of a database vendor’s SQL evolves over time. To build a database front end for
that vendor, we’d need to support different versions of the same SQL. Similarly, the Gnu C
compiler, <code class="cf commandname">gcc</code>, has to deal with ANSI C as well as its own dialect
that adds things like the awesome computed goto. Moreover, semantic predicates let us choose
between dialects at runtime with a command-line switch or other dynamic mechanism.
</p>
<p id="f_0067.html.N16D53">
第二个用例涉及解决语法歧义（在第 2.2 节“<a href="#f_0016.html.sec.parsing-terminology">实现<em>解析器”</em>中讨论）</a> 。在某些语言中，相同的语法结构可能意味着不同的东西，而谓词让我们能够在同一输入短语的多种解释之间进行选择。例如，在 Fortran 中，<code class="cf ic">f(i)</code>可以是数组引用或函数调用，具体取决于<code class="cf variable">f</code>定义的内容 - 语法是相同的。编译器必须在符号表中查找标识符才能正确解释输入。语义谓词让我们能够根据在符号表中找到的内容关闭不正确的解释。这使得解析器只有一个选择，即正确的解释。
</p><p>
The second use case involves resolving grammar ambiguities (discussed in Section 2.2, <a href="#f_0016.html.sec.parsing-terminology">​<em>Implementing Parsers</em>​</a>). In some languages, the same syntactic
construct can mean different things, and predicates give us a way to choose between
multiple interpretations of the same input phrase. For example, in good ol’
Fortran, <code class="cf ic">f(i)</code> could be an array reference or a function call, depending on
what <code class="cf variable">f</code> was defined to be—the syntax was the same. A compiler
had to look up the identifier in a symbol table to properly interpret the input.
Semantic predicates give us a way to turn off improper interpretations based upon
what we find in a symbol table. This leaves the parser with only a single choice,
the proper interpretation.
</p>
<p id="f_0067.html.N16D5F">
我们将通过 Java 和 C++ 中的示例来学习语义谓词。在此过程中，我们将了解大部分细节，但您可以查看参考章节中的第 15.7 节“<a href="#f_0097.html.sec.pred-fine-print">语义<em>谓词”，</em>以</a>了解细节。有了嵌入式动作和谓词，我们将有足够的准备来解决下一章中一些棘手的语言问题。
</p><p>
We’re going to learn about semantic predicates by working through examples taken from Java
and C++. Along the way, we’ll pick up most of the details, but you can check Section 15.7, <a href="#f_0097.html.sec.pred-fine-print">​<em>Semantic Predicates</em>​</a> in the reference chapter for a discussion of the fine print.
Armed with embedded actions and predicates, we’ll be sufficiently prepared to tackle some
formidable language problems in the next chapter.
</p>

</div></div>
<div id="f_0068.html"><div>

<h2 id="f_0068.html.N16D65">11.1 识别多种语言方言</h2><h2>11.1 Recognizing Multiple Language Dialects</h2>
<p id="f_0068.html.N16D69">
在我们的第一课中，我们将学习如何使用语义谓词来停用 Java 语法的某些部分。其效果是根据动态评估布尔表达式的结果来识别不同的方言。特别是，我们将看到同一个解析器如何在允许和禁止枚举类型之间切换。
</p><p>
For our first lesson, we’re going to learn how to use semantic predicates to
deactivate parts of a Java grammar. The effect will be to recognize different
dialects, according to results of evaluating Boolean expressions on-the-fly. In
particular, we’re going to see how the same parser can switch between allowing and disallowing enumerated types.
</p>
<p id="f_0068.html.N16D7E">
多年来，Java 语言不断扩展，包含新的构造。例如，在 Java 5 之前，以下声明是无效的：
</p><p>
The Java language has been extended over the years to include new constructs. For
example, prior to Java 5, the following declaration was invalid:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Temp.java">谓词/Temp.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum</strong> Temp { HOT, COLD }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16D90"><code class="cf commandname">javac</code>Java 编译器有一个
选项
，即不必为略有不同的方言构建单独的编译器<code class="cf commandoption">-source</code>。当我们尝试<code class="cf keyword">enum</code>使用 Java 1.4 版进行编译时，会发生以下情况：
</p><p>
Rather than building separate compilers for the slightly different dialects, the
Java compiler <code class="cf commandname">javac</code> has a
<code class="cf commandoption">-source</code> option. Here’s what happens when we try to
compile that <code class="cf keyword">enum</code> with Java version 1.4:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac -source 1.4 Temp.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Temp.java:1: enums are not supported in -source 1.4​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(use -source 5 or higher to enable enums)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum Temp { HOT, COLD }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​^​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​1 error​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Temp.java  </strong>
<em class="comment"># javac assumes the latest dialect; compiles fine.</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16DC3">
引入枚举类型会将<code class="cf keyword">enum</code>标识符转换为关键字，从而导致向后兼容性问题。许多遗留代码使用
<code class="cf keyword">enum</code>这样的变量：<code class="cf ic">int enum;</code>。如果编译器有选项可以识别早期的方言，我们就不必为了再次编译而修改古老的代码。
</p><p>
Introducing enumerated types flipped <code class="cf keyword">enum</code> from an identifier to a
keyword, causing a backward-compatibility issue.  Lots of legacy code uses
<code class="cf keyword">enum</code> as a variable like this: <code class="cf ic">int enum;</code>. With an option
on the compiler to recognize the earlier dialect, we don’t have to alter ancient
code just to compile it again.
</p>
<p id="f_0068.html.N16DCF">
为了了解如何<code class="cf commandname">javac</code>处理多种方言，让我们构建一个可以识别一小部分 Java 的语法：仅
<code class="cf keyword">enum</code>声明和赋值语句。目标是创建一个可以正确识别 Java 5 之前和之后语言的语法，但
<span class="emph">不能</span>同时识别这两种语言。例如，<code class="cf keyword">enum</code>同时使用作为关键字和标识符应该是无效的。
</p><p>
To get a taste for how <code class="cf commandname">javac</code> handles multiple dialects,
let’s build a grammar that recognizes a tiny piece of Java: just
<code class="cf keyword">enum</code> declarations and assignment statements. The goal is to
create a grammar that properly recognizes pre-- and post--Java 5 languages, but
<span class="emph">not both</span> at the same time. For example, using <code class="cf keyword">enum</code> as both a keyword and an identifier should be invalid.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum</strong> <strong class="prompt">enum</strong> { HOT, COLD }    <em class="comment">// syntax error in any Java version</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16DF1">
让我们通过查看识别最小 Java 子集的语法核心来开始我们的解决方案，然后找出如何处理关键字<code class="cf keyword">enum</code>
。
</p><p>
Let’s start our solution by looking at the core of a grammar that recognizes our
minimal Java subset and then figure out how to handle the <code class="cf keyword">enum</code>
keyword.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum.g4">谓词/Enum.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Enum;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@parser</strong>::members {<strong class="prompt">public</strong> static boolean java5;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   (   stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        |   enumDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   id <em class="string">'='</em> expr <em class="string">';'</em> {System.out.println($id.text+<em class="string">"="</em>+$expr.text);} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   id​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16E38">
我们已经熟悉这些语法结构和动作，所以让我们继续讨论<code class="cf keyword">enum</code>声明。
</p><p>
We’re already familiar with these grammatical constructs and actions, so let’s move
on to <code class="cf keyword">enum</code> declarations.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enumDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'enum'</em> name=id <em class="string">'{'</em> id (<em class="string">','</em> id)* <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"enum "</em>+$name.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16E61">
该规则识别枚举类型的（简化）语法，但没有任何迹象表明<code class="cf keyword">enum</code>s 有时是非法的。这就引出了问题的核心：使用语义谓词打开或关闭替代方案。
</p><p>
That rule recognizes the (simplified) syntax of an enumerated type, but there’s
nothing to suggest that <code class="cf keyword">enum</code>s are sometimes illegal. And that
brings us to the heart of the matter: turning alternatives on and off with
semantic predicates.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum.g4">谓词/Enum.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enumDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   {java5}? <em class="string">'enum'</em> name=id <em class="string">'{'</em> id (<em class="string">','</em> id)* <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"enum "</em>+$name.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16E8B">
谓词<code class="cf ic">{java5}?</code>在运行时计算为真或假，当<code class="cf variable">java5</code>其为假时，停用该替代方案。
</p><p>
Predicate <code class="cf ic">{java5}?</code> evaluates to true or false at runtime, deactivating that alternative when <code class="cf variable">java5</code> is false.
</p>
<p id="f_0068.html.N16E94">
您会注意到，我们使用规则，<code class="cf keyword">id</code>而不是像通常那样只使用标记
。这是因为在识别 Java 5 之前的版本时，<code class="cf keyword">ID</code>标识符的概念已经包括进去。（我们的词法分析器返回的是关键字，而不是标识符。）为了表达这种选择，我们需要一个带有语义谓词的规则。
<code class="cf keyword">enum</code><code class="cf keyword">enum</code></p><p>
You’ll notice that we’re using rule <code class="cf keyword">id</code> instead of just token
<code class="cf keyword">ID</code> like we usually do. That’s because the notion of an identifier
includes <code class="cf keyword">enum</code> when recognizing pre--Java 5. (Our lexer
returns <code class="cf keyword">enum</code> as a keyword, not an identifier.) To express that
choice, we need a rule with a semantic predicate.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum.g4">谓词/Enum.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​id  :   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {!java5}? <em class="string">'enum'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16EB8">
仅当不处于 Java 5 模式时，谓词才<code class="cf ic">{!java5}?</code>允许<code class="cf keyword">enum</code>充当标识符。当<code class="cf variable">java5</code>为真时，它实际上会停用第二个替代方案。在内部，ANTLR 解析器<code class="cf keyword">id</code>使用图形数据结构查看规则，有点像这样：
</p><p>
The <code class="cf ic">{!java5}?</code> predicate allows <code class="cf keyword">enum</code> to act as an
identifier only when not in Java 5 mode. It literally deactivates the second
alternative when <code class="cf variable">java5</code> is true. Internally, ANTLR parsers view
rule <code class="cf keyword">id</code> using a graph data structure, sort of like this:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/谓词/id-atn.png">
</div>
<p id="f_0068.html.N16ECB"><code class="cf ic">!java5</code>剪刀图标表示当计算结果为假时（当为真时） 
，解析器会从图中剪掉该分支
<code class="cf variable">java5</code>。请注意，由于谓词是互斥的，因此<code class="cf keyword">enum</code>
声明和<code class="cf keyword">enum</code>-as-identifiers 是互斥的构造。
</p><p>
The scissors icon indicates that the parser snips that branch from the graph when
<code class="cf ic">!java5</code> evaluates to false (when <code class="cf variable">java5</code> is true). Notice
that because the predicates are  mutually exclusive, <code class="cf keyword">enum</code>
declarations and <code class="cf keyword">enum</code>-as-identifiers are mutually exclusive
constructs.
</p>
<p id="f_0068.html.N16EDA">
我们可以用来<code class="cf commandname">grun</code>测试语法，但我们需要一个可以在 Java 方言之间切换的测试装置。以下是
<code class="cf class">TestEnum</code>支持<code class="cf commandoption">-java5</code>打开 Java 5 模式选项的相关内容：
</p><p>
We could use <code class="cf commandname">grun</code> to test the grammar, but we need a
test rig that can flip between Java dialects. Here are the relevant bits from
<code class="cf class">TestEnum</code> that support a <code class="cf commandoption">-java5</code> option
for turning on Java 5 mode:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/TestEnum.java">谓词/TestEnum.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> i = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EnumParser.java5 = false; <em class="comment">// assume non-Java5 mode by default</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">if</strong> ( args.length&gt;0 &amp;&amp; args[i].equals(<em class="string">"-java5"</em>) ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        EnumParser.java5 = true;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        i++;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16F0B">
现在让我们构建并编译一切。
</p><p>
Now let’s build and compile everything.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -no-listener Enum.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Enum*.java TestEnum.java</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16F23">
让我们从 Java 5 之前的模式开始，并确保它允许
<code class="cf keyword">enum</code>作为标识符并且不允许枚举类型。
</p><p>
Let’s start with pre--Java 5 mode and make sure it allows
<code class="cf keyword">enum</code> as an identifier and that it doesn’t allow enumerated types.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum = 0;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum=0​</code></div>
</td>
</tr>
</tbody></table>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum Temp { HOT, COLD }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:0 no viable alternative at input 'enum'​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16F5F">
相比之下，Java 5 模式不应被视为<code class="cf keyword">enum</code>标识符，但它应该允许枚举类型。
</p><p>
Java 5 mode, in contrast, shouldn’t consider <code class="cf keyword">enum</code> to be an
identifier, but it should allow enumerated types.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum -java5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum = 0;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:0 no viable alternative at input 'enum'​</code></div>
</td>
</tr>
</tbody></table>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum -java5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum Temp { HOT, COLD }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum Temp​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16F9E">
一切都已检查无误，但在继续之前，让我们先看看谓词的位置。谓词的工作方式是激活或停用通过谓词后可以匹配的所有内容。这意味着从技术上讲，我们不需要将谓词放在<code class="cf ic">{java5}?</code>适当<code class="cf keyword">enumDecl</code>的位置。我们可以将其拖出并放在对该规则的调用之前。
</p><p>
Everything checks out, but let’s take a look at predicate placement before
moving on. Predicates work by activating or deactivating everything that could be
matched after passing through the predicate. That means we don’t technically
need to put the <code class="cf ic">{java5}?</code> predicate in <code class="cf keyword">enumDecl</code> proper.
We could drag it out and put it in front of the call to that rule instead.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   (   {java5}? enumDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        |   stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0068.html.N16FBC">
它们在功能上是等价的，在本例中它们的位置取决于风格。关键在于，解析器必须在到达中的标记<code class="cf ic">(...)+</code>引用之前，在子规则的第一个替代中的某个地方遇到谓词。
<code class="cf ic">’enum’</code><code class="cf keyword">enumDecl</code></p><p>
They are functionally equivalent, and their placement in this case is a matter of
style. The key is that the parser must encounter a predicate somewhere in the first alternative of the <code class="cf ic">(...)+</code> subrule before reaching the <code class="cf ic">’enum’</code> token reference in <code class="cf keyword">enumDecl</code>.
</p>
<p id="f_0068.html.N16FC8">
	这就是如何使用运行时布尔开关构建支持多种方言的语法。要构建真正的 Java 语法，您可以将这些谓词合并到语法的适当规则中，我们在此处将其称为
<code class="cf keyword">enumDecl</code>和<code class="cf keyword">id</code>。

</p><p>
	And that’s how to build a grammar that supports multiple dialects
using a runtime Boolean switch. To build a real Java grammar, you could incorporate these
predicates into the appropriate rules of a grammar, which we’ve called
<code class="cf keyword">enumDecl</code> and <code class="cf keyword">id</code> here.

</p>
<p id="f_0068.html.N16FD1">
与嵌入式动作一样，语义谓词在词法分析器中有时也很有用。
</p><p>
As with embedded actions, semantic predicates are also occasionally useful in the lexer.
</p>

</div></div>
<div id="f_0069.html"><div>

<h2 id="f_0069.html.N16FD4">11.2 停用代币</h2><h2>11.2 Deactivating Tokens</h2>
<p id="f_0069.html.N16FD8">
在本节中，我们将再次解决同样的问题，但这次使用词法分析器中的谓词而不是解析器中的谓词。这个想法是，词法分析器中的谓词激活和停用
语言中的<span class="emph">标记</span>而不是<span class="emph">短语</span><code class="cf keyword">enum</code>。我们的方法是将其停用为关键字，并在 Java 5 之前的模式下将其匹配为常规标识符。在 Java 5 模式下，我们希望将其分离为自己的关键字标记。这大大简化了解析器，因为它只需引用通常的标记而不是规则
<code class="cf keyword">enum</code>就可以匹配标识符。
<code class="cf keyword">ID</code><code class="cf keyword">id</code></p><p>
In this section, we’re going to solve the same problem again, but this time using
predicates in the lexer instead of the parser. The idea is that predicates in the
lexer activate and deactivate <span class="emph">tokens</span> rather than <span class="emph">phrases</span>
in the language. Our approach will be to deactivate <code class="cf keyword">enum</code> as a
keyword and match it as a regular identifier in pre--Java 5 mode. In Java 5 mode, we
want to separate <code class="cf keyword">enum</code> out as its own keyword token. This
simplifies the parser considerably because it can match an identifier just by
referencing the usual <code class="cf keyword">ID</code> token, rather than an
<code class="cf keyword">id</code> rule.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum2.g4">谓词/Enum2.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   ID <em class="string">'='</em> expr <em class="string">';'</em> {System.out.println($ID.text+<em class="string">"="</em>+$expr.text);} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N17023">
词法分析器<code class="cf keyword">ID</code>仅在适合当前方言时才发送 。要实现这一点，我们只需要词汇规则中一个与 匹配的谓词
<code class="cf keyword">enum</code>。
</p><p>
The lexer  sends an <code class="cf keyword">ID</code> only when it’s appropriate for the current
dialect. To pull this off, we need just one predicate in a lexical rule that matches
<code class="cf keyword">enum</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum2.g4">谓词/Enum2.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENUM:   <em class="string">'enum'</em> {java5}? ; <em class="comment">// must be before ID</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+ ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N17041">
请注意，谓词出现在词汇规则的右侧，而不是像解析器备选方案那样出现在左侧。这是因为解析器会预测接下来会发生什么，并且需要在匹配备选方案之前测试谓词。</p><p>
Notice that the predicate appears on the right edge of the lexical rule instead of
on the left, like we did for parser alternatives. That’s because parsers predict
what’s coming down the road and need to test the predicates before matching
alternatives.</p>
<p id="f_0069.html.N17044">
    另一方面，词法分析器不会预测替代方案。它们只是寻找最长的匹配，并在看到整个标记后做出决定。（我们将在参考章节中详细了解这一点，具体来说，在第 15.7 节<a href="#f_0097.html.sec.pred-fine-print">“语义<em>谓词”</em>中。</a> ）
</p><p>
    Lexers, on the other hand, don’t predict alternatives. They just look
for the longest match and make decisions after they’ve seen the entire token.
(We’ll learn more about this in the reference chapter, specifically, in Section 15.7, <a href="#f_0097.html.sec.pred-fine-print">​<em>Semantic Predicates</em>​</a>.)
</p>
<p id="f_0069.html.N1704A">
当<code class="cf variable">java5</code>为假时，谓词将停用规则
<code class="cf keyword">ENUM</code>。但是，当为真时，<code class="cf keyword">ENUM</code>和
<code class="cf keyword">ID</code>都匹配字符序列枚举。这两个规则对于该输入是模棱两可的。ANTLR 始终根据首先指定的规则（在本例中为）来解决词汇歧义。<code class="cf keyword">ENUM</code>如果我们反转规则，词法分析器将始终将枚举匹配为。是否激活或停用都
<code class="cf keyword">ID</code>无关紧要
。<code class="cf keyword">ENUM</code></p><p>
When <code class="cf variable">java5</code> is false, the predicate deactivates rule
<code class="cf keyword">ENUM</code>. When it’s true, however, both <code class="cf keyword">ENUM</code> and
<code class="cf keyword">ID</code> match character sequence e-n-u-m. Those two rules are ambiguous for
that input. ANTLR always resolves lexical ambiguities in favor of the rule specified
first, in this case <code class="cf keyword">ENUM</code>. If we had reversed the rules, the lexer
would always match e-n-u-m as an <code class="cf keyword">ID</code>. It wouldn’t matter whether
<code class="cf keyword">ENUM</code> was activated or deactivated.
</p>
<p id="f_0069.html.N17062"><code class="cf keyword">enum</code>这种谓词词法分析器解决方案的优点在于，当不处于 Java 5 模式时，

我们不需要在解析器中使用谓词来停用构造。</p><p>
The beauty of this predicated lexer solution is that we don’t need a predicate
in the parser for deactivating the <code class="cf keyword">enum</code> construct when not in
Java 5 mode.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/Enum2.g4">谓词/Enum2.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// No predicate needed here because 'enum' token undefined if !java5</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enumDecl​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'enum'</em> name=ID <em class="string">'{'</em> ID (<em class="string">','</em> ID)* <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"enum "</em>+$name.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N17090"><code class="cf ic">’enum’</code>替代方法开头引用的

Token正在寻找特定的关键字标记。词法分析器只能在 Java 5 模式下将其呈现给解析器，因此除非为真，
<code class="cf keyword">enumDecl</code>否则永远不会匹配。<code class="cf variable">java5</code></p><p>
Token <code class="cf ic">’enum’</code>, referenced at the start of the alternative, is looking for a specific
keyword token. The lexer can  present that to the parser only in Java 5 mode, so
<code class="cf keyword">enumDecl</code> will never match unless <code class="cf variable">java5</code> is true.
</p>
<p id="f_0069.html.N1709C">
现在让我们验证一下基于词法分析器的解决方案是否能正确识别两种方言中的结构。在非 Java-5 模式下，<code class="cf keyword">enum</code>是一个标识符。
</p><p>
Let’s verify now that our lexer-based solution correctly recognizes constructs in the two dialects. In non-Java-5 mode, <code class="cf keyword">enum</code> is an identifier.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 -no-listener Enum2.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Enum2*.java TestEnum2.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum = 0;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum=0​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N170CA">
由于<code class="cf keyword">enum</code>是标识符，而不是关键字标记，因此解析器永远不会尝试匹配<code class="cf keyword">enumDecl</code>。它别无选择，只能将其<code class="cf ic">enum Temp { HOT, COLD }</code>视为赋值，从而导致语法错误。
</p><p>
Because <code class="cf keyword">enum</code> is an identifier, not a keyword token, the parser
will never attempt to match <code class="cf keyword">enumDecl</code>. It has no choice but to
treat <code class="cf ic">enum Temp { HOT, COLD }</code> as an assignment, leading to syntax errors.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum2</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum Temp { HOT, COLD }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:5 missing '=' at 'Temp'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:15 mismatched input ',' expecting '='​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:22 mismatched input '}' expecting '='​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N170F7">
在这种情况下，ANTLR 的错误恢复会意识到它没有有效的分配，并将标记围巾直到找到可以开始分配的东西。
</p><p>
In this case, ANTLR’s error recovery realizes it doesn’t have a valid assignment and scarfs tokens until it finds something that can start an assignment.
</p>
<p id="f_0069.html.N170FA">
在 Java 5 模式下，赋值给<code class="cf keyword">enum</code>是无效的，但枚举类型是有效的。
</p><p>
In Java 5 mode, an assignment to <code class="cf keyword">enum</code> is invalid, but an
enumerated type is valid.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum2 -java5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum = 0;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:5 mismatched input '=' expecting ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ java TestEnum2 -java5</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum Temp { HOT, COLD }</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum Temp​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N1712E">
如果我们想避免使用谓词（因为谓词会减慢词法分析器的速度），我们可以<code class="cf keyword">ENUM</code>完全废除该规则，并始终将匹配作为标识符。然后，我们会像在第 10.3 节<a href="#f_0066.html.sec.dynamic-keywords">“识别</a><a href="#f_0066.html.sec.dynamic-keywords"><em>关键字未固定的语言”</em></a><code class="cf keyword">enum</code>
中所做的那样，适当地翻转标记类型。
<a href="#f_0066.html.sec.dynamic-keywords"><em></em></a></p><p>
If we wanted to avoid predicates, which can slow down the lexer, we could do away
with the <code class="cf keyword">ENUM</code> rule altogether and match <code class="cf keyword">enum</code>
always as an identifier. Then we’d flip the token type appropriately like we did in
Section 10.3, <a href="#f_0066.html.sec.dynamic-keywords">​<em>Recognizing Languages Whose Keywords Aren’t Fixed</em>​</a>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z]+​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {if (java5 &amp;&amp; getText().equals(<em class="string">"enum"</em>)) setType(Enum2Parser.ENUM);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N1714F">
我们还需要一个令牌定义<code class="cf keyword">ENUM</code>。
</p><p>
We would also need a token definition for <code class="cf keyword">ENUM</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> { ENUM }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0069.html.N17163">
出于效率和清晰度的原因，最好尽可能避免在解析器中嵌入谓词。相反，我建议选择本节中基于词法分析器的解决方案之一来支持与 相关的 Java 方言<code class="cf keyword">enum</code>。请注意，谓词也会降低词法分析器的速度，因此请尝试完全不使用它们。
</p><p>
It’s a good idea to avoid embedding predicates in the parser when possible for efficiency
and clarity reasons. Instead, I recommend choosing one of the lexer-based solutions in this
section to support the Java dialects related to <code class="cf keyword">enum</code>. Note that
predicates slow the lexer down as well, so try to do without them entirely.
</p>
<p id="f_0069.html.N1717B">
这就是解析器和词法分析器中语义谓词的基本语法和用法。谓词提供了一种直接的方式来选择性地停用部分语法，这让我们能够使用相同的语法识别同一语言的方言。此外，我们可以通过翻转布尔表达式的值来动态切换方言。现在让我们研究第二个主要用例：使用谓词来解决解析器中的歧义输入短语。
</p><p>
That’s it for the basic syntax and usage of semantic predicates in the parser
and the lexer. Predicates offer a straightforward way to selectively deactivate
parts of a grammar, which lets us recognize dialects of the same language using the
same grammar. Moreover, we can switch between dialects dynamically by flipping the
value of a Boolean expression. Now let’s investigate the second major use case:
using predicates to resolve ambiguous input phrases in the parser.
</p>

</div></div>
<div id="f_0070.html"><div>

<h2 id="f_0070.html.sec.recog-ambig-phrases">11.3 识别歧义短语</h2><h2>11.3 Recognizing Ambiguous Phrases</h2>
<p id="f_0070.html.N17183">
我们刚刚看到了如何基于一个简单的布尔变量来剥离语法的某些部分。这并不是说语法以多种方式匹配相同的输入；我们只是想关闭某些语言结构。现在我们的目标是强制解析器停用对模糊输入短语的所有解释，只保留一种解释。使用我们的迷宫类比，当我们可以使用单个密码短语沿着迷宫中的多条路径到达出口时，迷宫和密码短语就是模糊的。谓词就像岔路口上的门，我们可以打开和关闭它们来引导迷宫中的移动。
</p><p>
We’ve just seen how to strip away parts of a grammar based upon a simple Boolean
variable. It wasn’t that the grammar matched the same input in multiple ways; we
simply wanted to turn off certain language constructs. Now our goal is to force the
parser to deactivate all but one interpretation of an ambiguous input phrase. Using
our maze analogy, a maze and passphrase are ambiguous when we can follow multiple
paths through the maze to the exit using that single passphrase. Predicates are like
doors on path forks that we can open and close to direct movement through the maze.
</p>
<div class="sidebar" id="f_0070.html.sb.ambig-bad">
<div class="sidebar-title">语言模糊性很糟糕...好吗？</div>
<div class="sidebar-content">
<p id="f_0070.html.N17195">
明智的语言设计者会刻意避免使用模棱两可的结构，因为它们会使代码难以阅读。例如，<code class="cf ic">f[0]</code>在 Ruby 中，要么是数组第一个元素的引用<code class="cf variable">f</code>，要么是返回数组的函数调用
<code class="cf methodname">f</code>，然后我们对其进行索引。为了让事情变得更有趣，在传递一个包含 0 的数组作为参数<code class="cf ic">f [0]</code>之前加上一个空格。之所以发生这种情况，是因为在 Ruby 中，括号对于函数调用是可选的。由于这些歧义，Ruby 爱好者目前建议使用括号。
<code class="cf ic">[0]</code><code class="cf methodname">f</code></p><p>
Wise language designers deliberately avoid ambiguous constructs because they make it
hard to read code. For example, <code class="cf ic">f[0]</code> in Ruby is either a reference to the
first element of array <code class="cf variable">f</code> or a function call to
<code class="cf methodname">f</code> that returns an array, which we then index. To make things even
more fun, <code class="cf ic">f [0]</code> with a space before <code class="cf ic">[0]</code> passes an array with 0 in
it to function <code class="cf methodname">f</code> as an argument. This all happens because
parentheses are optional in Ruby for function calls. Ruby aficionados currently
recommend using parentheses because of these very ambiguities.
</p>
</div>
</div>
<p id="f_0070.html.N171AF">
在我们开始之前，让我指出，在语法中，如果输入短语有多种匹配方式，那么几乎总是语法错误。在大多数语言中，语法本身就决定了如何解释所有有效句子。（请参阅侧栏“<a href="#f_0070.html.sb.ambig-bad">语言<em>歧义很糟糕……好吗？</em></a> ”）
<a href="#f_0070.html.sb.ambig-bad">。</a></p><p>
Before we begin, let me point out that having more than one way to match an input phrase in
a grammar is almost always a grammar bug. In most languages, the syntax alone uniquely
dictates how to interpret all valid sentences. (See the sidebar <a href="#f_0070.html.sb.ambig-bad">​<em>Language Ambiguities Are Bad...Umkay?</em>​</a>.) That means our grammars should match each input stream in just
one way. If we find multiple interpretations, we should rewrite the grammar to strip out the
invalid interpretation(s).
</p>
<p id="f_0070.html.N171B5">
话虽如此，但有些语言中的短语仅靠语法不足以识别其含义。这些语言的语法必然是模棱两可的，但只要有足够的上下文，比如标识符的定义方式（例如，类型或方法），语法上模棱两可的短语的含义就会很清楚。我们需要谓词通过询问上下文问题来正确地为每个模棱两可的短语选择解释。如果谓词成功解决了输入短语的语法歧义，那么我们就说这个短语是<span class="firstuseinline">上下文敏感的</span>。
</p><p>
That said, there are phrases in some languages where syntax alone just isn’t enough to
identify the meaning. Grammars for these languages will necessarily be ambiguous, but the
meaning of syntactically ambiguous phrases will be clear given sufficient context, such as
how identifiers are defined (for example, as types or methods). We’ll need predicates to properly
select an interpretation for each ambiguous phrase by asking context questions. If a
predicate successfully resolves a grammar ambiguity for an input phrase, then we say that
the phrase is <span class="firstuseinline">context-sensitive</span>.
</p>
<p id="f_0070.html.N171BB">
在本节中，我们将探讨 C++ 中一些隐晦的歧义。据我所知，C++ 是最难准确解析的编程语言。我们将从函数调用与构造函数式类型转换开始，然后研究声明与表达式。
</p><p>
In this section, we’re going to explore some ambiguities in the nooks and crannies
of C++. As far as I can tell, C++ is the most difficult programming language to
parse accurately and precisely. We’ll start with function calls vs.
constructor-style type casts and then look at declarations vs. expressions.
</p>
<h3>正确识别 C++ 中的 T(0)</h3><h3>Properly Recognizing T(0) in C++</h3>
<p id="f_0070.html.N171C2">
在 C++ 中，表达式<code class="cf ic">T(0)</code>要么是函数调用，要么是构造函数样式的类型转换，具体取决于是<code class="cf variable">T</code>函数名称还是类型名称。表达式具有歧义性，因为相同的短语语法适用于这两种解释。为了获得正确的解释，解析器需要根据<code class="cf variable">T</code>程序中的定义方式停用其中一种替代方案。以下大大简化的 C++ 表达式规则有两个谓词，用于检查<code class="cf keyword">ID</code>它是函数名称还是类型名称：
</p><p>
In C++, expression <code class="cf ic">T(0)</code> is either a function call or a constructor-style
typecast depending on whether <code class="cf variable">T</code> is a function or type name. The
expression is ambiguous because the same phrase syntax applies to both
interpretations. To get the right interpretation, the parser needs to deactivate one
of the alternatives according to how <code class="cf variable">T</code> is defined in the
program. The following grossly simplified C++ expression rule has two predicates
that check the <code class="cf keyword">ID</code> to see whether it’s a function or type name:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/CppExpr.g4">谓词/CppExpr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Distinguish between alts 1, 2 using idealized predicates as demo */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   {isfunc(ID)}? ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// func call with 1 arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {istype(ID)}? ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// ctor-style type cast of expr</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT                       <em class="comment">// integer literal</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                        <em class="comment">// identifier</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N17214">
从视觉上看，规则<code class="cf keyword">expr</code>如下图所示，其中切点位于前两个替代方案前面：
</p><p>
Visually, rule <code class="cf keyword">expr</code> looks like the following graph with cut points in front of the first two alternatives:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/谓词/Cpp-expr-atn.png">
</div>
<p id="f_0070.html.N1721E">
您可能想知道为什么我们不将这两个替代方案合并为一个可以处理两种情况（函数调用和类型转换）的替代方案。原因之一是它使解析树遍历器的工作变得复杂。不再使用两个特定方法（每种情况一个），而是使用一个<code class="cf methodname">enterCallOrTypecast</code>。在该方法中，我们必须手动拆分这两种情况。不过，这并不是世界末日。
</p><p>
You might be wondering why we simply don’t collapse those two alternatives into a
single one that handles both cases (function calls and type casts). One reason is
that it complicates the job of the parse-tree walker. Instead of two specific
methods, one for each case, there is a single <code class="cf methodname">enterCallOrTypecast</code>.
Inside that method we’d have to split the two cases manually. That’s not the end of
the world, though.
</p>
<p id="f_0070.html.N17224">
更大的问题是，歧义替代方案很少像这里一样相同。例如，函数调用替代方案还必须处理没有参数的情况，例如<code class="cf ic">T()</code>。这不是有效的类型转换，因此在实践中合并这两个替代方案是行不通的。歧义替代方案也可能存在于相距甚远的规则中，我们将在下一个示例中考虑这一点。
</p><p>
The bigger problem is that the ambiguous alternatives are rarely identical like they
are here. For example, the function call alternative would also have to handle the
case where there are no arguments, such as <code class="cf ic">T()</code>. That would not be a valid
typecast, so collapsing the two alternatives wouldn’t work in practice. It’s also
the case that the ambiguous alternatives can be in widely separated rules, which
we’ll consider in the next example.
</p>
<h3 id="f_0070.html.sec.decl-vs-call">正确识别 C++ 中的 T(i)</h3><h3>Properly Recognizing T(i) in C++</h3>
<p id="f_0070.html.N17232">
考虑一下我们的表达式的一个细微变化：<code class="cf ic">T(i)</code>。为了简单起见，我们假设我们的 C++ 子集中没有构造函数样式的类型转换。那么，作为表达式，<code class="cf ic">T(i)</code>必须是函数调用。不幸的是，它在语法上也是一个有效的声明。它与<code class="cf ic">T i</code>定义
<code class="cf variable">i</code>类型变量的短语相同<code class="cf class">T</code>。区分它们的唯一方法还是通过上下文。如果<code class="cf variable">T</code>是类型名称，那么<code class="cf ic">T(i)</code>就是变量的声明<code class="cf variable">i</code>。否则，它是一个以
<code class="cf variable">i</code>作为参数的函数调用。
</p><p>
Consider a slight variation of our expression: <code class="cf ic">T(i)</code>. To keep things simple, let’s
assume that there are no constructor-style type casts in our C++ subset. As an expression,
then, <code class="cf ic">T(i)</code> must be a function call. Unfortunately, it is also syntactically a valid
declaration. It’s the same as phrase <code class="cf ic">T i</code>, which defines variable
<code class="cf variable">i</code> of type <code class="cf class">T</code>. The only way to tell the difference is
again with context. If <code class="cf variable">T</code> is a type name, then <code class="cf ic">T(i)</code> is a
declaration of variable <code class="cf variable">i</code>. Else, it’s a function call with
<code class="cf variable">i</code> as an argument.
</p>
<p id="f_0070.html.N17250">
我们可以用一个与 C++ 的几部分相匹配的小语法来演示不同规则中的歧义替代方案。假设 C++ 语句可以只是声明或表达式。
</p><p>
We can demonstrate ambiguous alternatives in separate rules with a small grammar
that matches a few bits of C++. Let’s say C++ statements can be just declarations or
expressions.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/CppStat.g4">谓词/CppStat.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   decl <em class="string">';'</em>  {System.out.println(<em class="string">"decl "</em>+$decl.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">';'</em>  {System.out.println(<em class="string">"expr "</em>+$expr.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N17272">
从语法上讲，声明可以是<code class="cf ic">T i</code>或<code class="cf ic">T(i)</code>。
</p><p>
Syntactically, a declaration can be either <code class="cf ic">T i</code> or <code class="cf ic">T(i)</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/CppStat.g4">谓词/CppStat.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl:   ID ID           <em class="comment">// E.g., "Point p"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'('</em> ID <em class="string">')'</em>   <em class="comment">// E.g., "Point (p)", same as ID ID</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N17298">
假设表达式可以是整数字面量、简单标识符或者带有一个参数的函数调用。
</p><p>
And let’s say that an expression can be an integer literal, a simple identifier, or a
function call with one argument.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/CppStat.g4">谓词/CppStat.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   INT             <em class="comment">// integer literal</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID              <em class="comment">// identifier</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// function call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N172BD">
如果我们构建并测试语法<code class="cf ic">f(i);</code>，我们会从解析器收到歧义警告（当使用该<code class="cf commandoption">-diagnostics</code>
选项时）。
</p><p>
If we build and test the grammar on, say, <code class="cf ic">f(i);</code>, we get an ambiguity
warning from the parser (when using the <code class="cf commandoption">-diagnostics</code>
option).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 CppStat.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac CppStat*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun CppStat stat -diagnostics</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f(i);</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:4 reportAttemptingFullContext d=0, input='f(i);'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:4 reportAmbiguity d=0: ambigAlts={1, 2}, input='f(i);'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl f(i)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N172F4">
解析器首先通知我们，它在尝试使用简单的<span class="emph">SLL(*)</span>解析策略解析输入时检测到问题。由于该策略失败，解析器使用更强大的<span class="emph">ALL(*)</span>机制重试。请参见第 13.7 节<a href="#f_0084.html.sec.maximizing-speed">“最大化<em>解析器速度”</em>。</a>在启用完整语法分析算法后，解析器再次发现问题。此时，它知道输入确实存在歧义。如果解析器没有发现问题，它会打印一条
<code class="cf ic">reportContextSensitivity</code>消息；我们将在添加谓词后详细了解这一点。
</p><p>
The parser starts out by notifying us that it detected a problem trying to parse the input
with the simple <span class="emph">SLL(*)</span> parsing strategy. Since that strategy failed, the
parser retried with the more powerful <span class="emph">ALL(*)</span> mechanism. See Section 13.7, <a href="#f_0084.html.sec.maximizing-speed">​<em>Maximizing Parser Speed</em>​</a>. With the full grammar analysis algorithm engaged, the
parser again found a problem. At that point, it knew that the input was truly ambiguous. If
the parser had not found the problem, it would have printed a
<code class="cf ic">reportContextSensitivity</code> message; we’ll learn more about that after we add predicates.
</p>
<p id="f_0070.html.N17303">
该输入与 的第二个选项<code class="cf keyword">decl</code>和 的第三个选项都匹配<code class="cf keyword">expr</code>。解析器必须在规则 中在它们之间进行选择<code class="cf keyword">stat</code>。给定两个可行的替代方案，解析器通过选择第一个指定的替代方案（ ）来解决歧义<code class="cf keyword">decl</code>。这就是解析器将其解释<code class="cf ic">f(i);</code>为声明而不是表达式的原因。
</p><p>
That input matches both the second alternative of <code class="cf keyword">decl</code> and the
third alternative of <code class="cf keyword">expr</code>. The parser must choose between them in
rule <code class="cf keyword">stat</code>. Given two viable alternatives, the parser resolves the
ambiguity by choosing the alternative specified first (<code class="cf keyword">decl</code>).
That’s why the parser interprets <code class="cf ic">f(i);</code> as a declaration instead of an
expression.
</p>
<p id="f_0070.html.N17315">
如果我们有一个“神谕”能够告诉我们一个标识符是否是一个类型名称，我们就可以在歧义替代方案前面使用谓词来解决歧义。
</p><p>
If we had an “oracle” that could tell us whether  an identifier was a type
name, we could resolve the ambiguity with predicates in front of the ambiguous
alternatives.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/PredCppStat.g4">谓词/PredCppStat.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl:   ID ID                         <em class="comment">// E.g., "Point p"</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {istype()}? ID <em class="string">'('</em> ID <em class="string">')'</em>     <em class="comment">// E.g., "Point (p)", same as ID ID</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   INT                           <em class="comment">// integer literal</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                            <em class="comment">// identifier</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {!istype()}? ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// function call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N1734F">
谓词中的辅助<code class="cf methodname">istype</code>方法向解析器询问当前标记，获取其文本，并在我们预定义的<code class="cf variable">types</code>表中查找它。
</p><p>
The <code class="cf methodname">istype</code> helper method in the predicates asks the parser for the current token, gets its text, and looks it up in our predefined <code class="cf variable">types</code> table.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/predicates/PredCppStat.g4">谓词/PredCppStat.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@parser</strong>::members {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Set&lt;String&gt; types = new HashSet&lt;String&gt;() {{add(<em class="string">"T"</em>);}};​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​boolean istype() { return types.contains(getCurrentToken().getText()); }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N17373">
当我们测试这个语法的谓词版本时，输入<code class="cf ic">f(i);</code>被正确地解释为函数调用表达式，而不是声明。输入
<code class="cf ic">T(i);</code>被明确地解释为声明。
</p><p>
When we test this predicated version of our grammar, input <code class="cf ic">f(i);</code> is
interpreted properly as a function call expression, not a declaration. Input
<code class="cf ic">T(i);</code> is unambiguously interpreted as a declaration.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 PredCppStat.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac PredCppStat*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun PredCppStat stat -diagnostics</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">f(i);</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr f(i)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun PredCppStat stat -diagnostics</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">T(i);</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl T(i)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0070.html.N173B4">
以下解析树（使用该<code class="cf commandname">grun</code>&nbsp;<code class="cf commandoption">-ps file.ps</code>选项创建）清楚地说明了解析器正确地解释了输入的短语：
</p><p>
The following parse trees (created using the <code class="cf commandname">grun</code>&nbsp;<code class="cf commandoption">-ps file.ps</code> option) illustrate clearly that the parser properly interprets the input phrases:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAABiCAAAAACgi3hAAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAP8SURBVGje7ZnNldwgDICnhW1hWnALtOAWuOaoFrjnRAu+pAAOaYAWaEEtEMA/CAMejHez++ZZhxm/zUgfCP0g52G/RR43dhVIvjoFbMFKDYvjaOCDGT5O7quTSIzY1EoNC9J9MIsWn7aXmhhJrdSwZgT0Gpx99GOpkTasW6pwv+TKDv1YaqQNK4EZO8A08qf76oRSI6mVn5hAN/a/YKfPYJiz2AnUdSq6LDqFRbhYj4MAimy/h1iB1gh7UbQsNJMjbEAKY68JLOhmLJDPbpmX7fzWip10+FKXogrnQ8Ld4utYLPbns7Iq7xZ/0IFWv1yJqkhLF1/FkijojyriW0wWX8VC5fmU0EhKFl/tt5q6qrNGpnnT0G93kQdoeyQ1QhdRwe442BVV+5ggRstYPb2w0CLZWokLy1jZ8JeXkqtM2+J/TJuPntAdW+zGxvus+oRm24YFJpkF7niSjQSrT2SuVwdt+V8xjtpqGAtWUqzkVjApLEwTT3Z7YuNB3QwS1IB6sOqJBSsp1o0NlnEOIP1Tn5ODuhXPoM4qRlKs+71mMM1PiYa2rRLUkfFJOYcNKXazkmKRATD3wREHTs9WtpepoA4TDn8GzmSCjVYa85Z3FOXcvdFKI7an4+bYaIViEQrS13teyWdj5SOX5zE28i/fyb0RebDiEtbAMF727cQ41EtbAatB6qtnagC0kQpqoZhjlbCuvPmq2i9CSFduRD3fM6wMk5Ir2v1ct0nle6Y0ftvFoWKPle48lA5dV/a1W3SguVOjnBdROK994/NbhGWlsueeKoSPjsXavA7xYqxGERwrVhV9ugVpH0Rb/i3Dm/P0/sCScjHXTBN8Ey70J7k4dx8et74+yJ2nCdYs/yQJHM/0gMU2IZARKE3iiNW7wXI5mOYEXj1JFehdSNMk3rBqc8jysM6IbYm0xU368+SQSGit2JgtaxxsKqKBu2WJTH+cvjzALYkXLMkVkam8TOBYE+SuOJid6louH5lnNr/EPjQdJ3CsgFO2wCwVZk8HrKKeic9x5frIzyRU8uXlfzFgv3MG8neI6BzySiWGvzjKInfXzHXrEmw9/I8H4mXySj9izUG10qykW5foZIqiV/Log7Fuhn9AQddPQn4QQu0nIToIBVt7rCKxSG6cB1jFSrp+EvrtBiEbJiE6CBWxghwPwXJblYilumEScoPQPAklV2Ze2i0Unw9OjeyW6PrK7wchGyahBMsKWCTuPLtbqusnoV9uEELlJ6HybqkUL3uy7S1rSTcbSYKtDIslbONtDluwwdaPeVPzFtjKWPDV2Eos3tgbe2Nv7I29sV+M/abGV5Gvxlb+S+VdseU3AV8eyeVZ8ca+AbYiN/Z9sf8AY6+N/URULDEAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTMtMDEtMTVUMjI6NDY6NDktMDY6MDC3CeFJAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEzLTAxLTE1VDIyOjQ2OjQ5LTA2OjAwxlRZ9QAAAB90RVh0cGRmOkhpUmVzQm91bmRpbmdCb3gAMTE4eDk4KzArMEe0m9MAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/谓词/Cpp-parse-tree.png">
</div>
<p id="f_0070.html.N173C1">
解析树中的关键节点是<code class="cf class">T</code>和
的下划线父节点<code class="cf variable">f</code>。这些内部节点告诉我们解析器匹配了什么类型的东西。请记住，识别背后的想法是，我们可以区分一个短语和另一个短语，并可以识别其组成部分。我们可以将任何可能的输入文件与语法片段进行匹配<code class="cf ic">.+</code>（匹配一个或多个任何符号），但它不会告诉我们有关输入的任何信息。从输入中获取正确的结构对于构建语言应用程序至关重要。
</p><p>
The key nodes in the parse tree are the underlined parents of <code class="cf class">T</code> and
<code class="cf variable">f</code>. Those internal nodes tell us what kind of thing the parser
matched. Remember that the idea behind recognition is that we can distinguish one
phrase from the other and can identify the constituent components. We could match
any possible input file with grammar fragment <code class="cf ic">.+</code> (match one or more of any
symbol), but it wouldn’t tell us anything about the input. Getting the correct
structure from the input is crucial to building a language application.
</p>
<p id="f_0070.html.N173CD">
这些 C++ 示例中的歧义消失了，因为谓词消除了不正确的解释。不幸的是，有些歧义没有谓词可以解决。让我们再处理一个 C++ 示例，看看这是如何发生的。
</p><p>
The ambiguities in these C++ examples disappear because the predicates cut out the
improper interpretation. Unfortunately, there are some ambiguities for which no predicate exists to resolve them. Let’s tackle one more C++ example to see how this can happen.
</p>
<h3>在 C++ 中正确识别 T(i)[5]</h3><h3>Properly Recognizing T(i)[5] in C++</h3>
<p id="f_0070.html.N173D4">
C++ 之所以令人兴奋，是因为有些短语具有两种有效含义。考虑 C++ 短语<code class="cf ic">T(i)[5]</code>。从语法上讲，这看起来既像声明又像表达式，<span class="emph">即使我们知道 是<code class="cf class">T</code>类型名称</span>。这意味着我们无法测试标识符和 switch 解释，因为当是类型名称 
<code class="cf ic">T</code>时有两种解释。<code class="cf ic">T</code></p><p>
C++ is exciting because some phrases have two valid meanings. Consider the C++
phrase <code class="cf ic">T(i)[5]</code>. Syntactically this looks like both a declaration and an
expression <span class="emph">even if we know that <code class="cf class">T</code> is a type name</span>.  That means we can’t test identifier <code class="cf ic">T</code> and switch interpretations because there are two interpretations when <code class="cf ic">T</code> is a type name. 
</p>
<p id="f_0070.html.N173E6">
声明解释为一个由五个<code class="cf class">T</code>元素组成的数组：<code class="cf ic">T
i[5]</code>。表达式解释是的类型转换<code class="cf variable">i</code>为
<code class="cf class">T</code>，然后对结果数组进行索引操作。 
</p><p>
The declaration interpretation is as an array of five <code class="cf class">T</code> elements: <code class="cf ic">T
i[5]</code>. The expression interpretation is a typecast of <code class="cf variable">i</code> to
<code class="cf class">T</code> and then an index operation on the resulting array. 
</p>
<p id="f_0070.html.N173F5">
C++ 语言规范文档通过始终选择声明而不是表达式来解决这种歧义。语言规范明确地告诉我们人类如何解释<code class="cf ic">T(i)[5]</code>，但即使我们添加语义谓词，也不可能构建一个明确的常规语法。
</p><p>
The C++ language specification document resolves this ambiguity by always choosing
declarations over expressions. The language specification unambiguously tells us humans how
to interpret <code class="cf ic">T(i)[5]</code>, but it’s impossible to build a conventional grammar that is
unambiguous even if we add semantic predicates.
</p>
<p id="f_0070.html.N173FB">
幸运的是，解析器会自动解决这种歧义，因此它的行为很自然。解析器通过首先选择指定的替代方案来解决歧义。因此，我们只需确保将替代方案放在中的替代方案<code class="cf keyword">decl</code>之前即可。
<code class="cf keyword">expr</code><code class="cf keyword">stat</code></p><p>
Fortunately, the parser resolves this ambiguity automatically so that it behaves
naturally. Parsers resolve ambiguities by choosing the alternative specified first.
So, we just have to make sure we put the <code class="cf keyword">decl</code> alternative
before the <code class="cf keyword">expr</code> alternative in <code class="cf keyword">stat</code>.
</p>
<p id="f_0070.html.N17413">
解析 C++ 时还有最后一个复杂因素需要考虑。
</p><p>
There’s one final complication to consider when parsing C++.
</p>
<h3>解析前向引用</h3><h3>Resolving Forward References</h3>
<p id="f_0070.html.N1741A">
为了<code class="cf variable">types</code>根据上一节或其他表计算出我们的表以区分函数和类型名称，真正的 C++ 解析器必须在解析过程中跟踪遇到的名称。在 C++ 中跟踪符号有点棘手，但从概念上讲不是问题。我们在上一章中学习了如何为我们的计算器跟踪名称-值对。问题是 C++ 有时允许对方法和变量名称等符号进行前向引用。这意味着我们可能<code class="cf class">T</code>直到解析器看到表达式后才知道这是一个函数名称<code class="cf ic">T(i)</code>。Gulp。
</p><p>
To compute our <code class="cf variable">types</code> table from the previous section or some
other table to distinguish functions from type names, a real C++ parser would have
to track names as it encountered them during the parse. Tracking symbols in C++ is a
bit tricky but conceptually not a problem. We learned how to track name-value pairs
for our calculator in the previous chapter. The problem is that C++ sometimes allows
forward references to symbols like method and variable names. That means we might
not know that <code class="cf class">T</code> is a function name until after the parser has seen
expression <code class="cf ic">T(i)</code>. Gulp.
</p>
<p id="f_0070.html.N17429">
这应该能让你明白为什么 C++ 如此难以解析。唯一的解决方案是对输入或输入的内部表示（如解析树）进行多次传递。 
</p><p>
This should give you some idea of why C++ is so hard to parse. The only solution is
to make multiple passes over the input or over an internal representation of the
input such as a parse tree. 
</p>
<p id="f_0070.html.N1742C">
使用 ANTLR，最简单的方法可能是对输入进行标记，快速扫描以查找并记录所有符号定义，然后“带着感觉”再次解析这些标记以获得正确的解析树。
</p><p>
Using ANTLR, the simplest approach would probably be to tokenize the input, scan it
quickly to find and record all of the symbol definitions, and then parse those
tokens again “with feeling” to get the proper parse tree.
</p>
<p id="f_0070.html.N1742F">
虽然大多数语言没有这种可怕的歧义相关问题，但几乎每种语言都具有歧义性，仅仅是因为它包含算术表达式。例如，在第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em>中，</a>我们看到了<code class="cf ic">1+2*3</code>具有歧义性，因为我们可以将其解释为<code class="cf ic">(1+2)*3</code>或<code class="cf ic">1+(2*3)</code>。
</p><p>
While most languages don’t have such diabolical ambiguity-related issues, just about every
language is ambiguous simply because it contains arithmetic expressions. For example, in
Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>, we saw that <code class="cf ic">1+2*3</code> is ambiguous because we can
interpret it as <code class="cf ic">(1+2)*3</code> or <code class="cf ic">1+(2*3)</code>.
</p>
<p id="f_0070.html.N1743E">
如果我们将语义谓词视为打开或关闭选项的简单布尔表达式，则语义谓词的行为或多或少是直截了当的。不幸的是，在具有多个谓词和嵌入操作的语法中，事情会变得相当复杂。参考章节详细介绍了 ANTLR 何时以及如何使用谓词。如果您不打算在语法中使用大量与操作混合的谓词，则可以跳过第 15.7 节“<a href="#f_0097.html.sec.pred-fine-print">语义<em>谓词”</em>。</a>稍后这些细节可能有助于解释一些令人困惑的语法行为。
</p><p>
The behavior of semantic predicates is more or less straightforward if we think of them as simple Boolean expressions that turn alternatives on and off. Unfortunately, things can get fairly complicated in grammars with multiple predicates and embedded actions.  The reference chapter goes over the details of when and how ANTLR uses predicates. If you don’t plan on using lots of predicates mixed with actions in your grammar, you can probably skip Section 15.7, <a href="#f_0097.html.sec.pred-fine-print">​<em>Semantic Predicates</em>​</a>.  Later these details might help explain some perplexing grammar behavior.
</p>
<p id="f_0070.html.N17444">
现在我们知道了如何使用动作和语义谓词自定义生成的解析器，我们掌握了一些可怕的技能。在下一章中，我们将利用我们在第三部分中学到的知识解决一些非常困难的识别问题。
</p><p>
Now that we know how to customize generated parsers using actions and semantic predicates,
we have some fearsome skills. In the next chapter, we’re going to solve some very
difficult recognition problems using what we’ve learned so far in Part III.
</p>

<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0071.html"><div>

<h1 class="chapter-title" id="f_0071.html.chp.lexmagic">
<span class="chapter-number">
	      第十二章</span>
<br><br>
<span class="chapter-name">运用词汇黑魔法</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      12</span>
<br><br>
<span class="chapter-name">Wielding Lexical Black Magic</span>
</h1>

<p id="f_0071.html.N17450">
在本书的这一部分，我们学习了一些高级技能。我们知道了如何在解析时执行任意代码，并且可以使用语义谓词改变语法识别。现在是时候运用这些技能来解决一些具有挑战性的语言识别问题了，但这次是在词法分析器中，而不是解析器中。
</p><p>
In this part of the book, we’ve learned some advanced skills. We know how to execute
arbitrary code while parsing, and we can alter syntax recognition with semantic predicates.
Now it’s time to put those skills to work solving some challenging language recognition
problems but in the lexer this time, not the parser.
</p>
<p id="f_0071.html.N17453">
根据我的经验，如果语言问题难以解决，那么大部分令人头疼的问题都发生在词法分析器中（当然，C++ 除外，它从头到尾都很难）。这是违反直觉的，因为到目前为止我们看到的词法分析器规则都非常简单，例如标识符、整数和算术表达式运算符。但是，考虑一下看似无害的双字符 Java 序列：<code class="cf ic">&gt;&gt;</code>。Java 词法分析器可以将其匹配为右移位运算符或两个<code class="cf ic">&gt;</code>运算符，解析器可以使用它们来关闭嵌套的泛型类型，例如<code class="cf ic">List&lt;List&lt;String&gt;&gt;</code>。
</p><p>
In my experience, if a language problem is hard to solve, most of the head-scratching occurs
in the lexer (well, with the exception of C++, which is hard all over). That’s
counterintuitive because the lexer rules we’ve seen so far have been pretty simple, such as
identifiers, integers, and arithmetic expression operators. But, consider the harmless-looking two-character Java sequence: <code class="cf ic">&gt;&gt;</code>. A Java lexer could match it either as the
right shift operator or as two <code class="cf ic">&gt;</code> operators, which the parser could use to close a
nested generic type like <code class="cf ic">List&lt;List&lt;String&gt;&gt;</code>.
</p>
<p id="f_0071.html.N1745F">
根本问题是词法分析器执行标记化，但有时只有解析器才具有做出标记化决策所需的上下文信息。我们将在第 12.2 节“<a href="#f_0073.html.sec.context-sensitive-lexers">上下文<em>敏感的词汇问题”</em>中探讨这个问题。</a>在该讨论中，我们还将研究“关键字可以是标识符”问题，并构建一个词法分析器来处理 Python 的上下文敏感换行符处理。
</p><p>
The fundamental problem is that the lexer does the tokenizing, but sometimes only the parser
has the context information needed to make tokenizing decisions. We’ll explore this issue in
Section 12.2, <a href="#f_0073.html.sec.context-sensitive-lexers">​<em>Context-Sensitive Lexical Problems</em>​</a>. During that discussion, we’ll also look at the
“keywords can be identifiers” problem and build a lexer to deal with Python’s
context-sensitive newline handling.
</p>
<p id="f_0071.html.N17465">
我们要研究的下一个问题涉及<span class="firstuseinline">岛屿语言</span>，其句子中有趣的部分被我们不关心的内容包围。示例包括 XML 和 StringTemplate 等模板语言。要解析这些，我们需要
<span class="firstuseinline">岛屿语法</span>和<span class="firstuseinline">词汇模式，我们将在第 12.3 节</span><a href="#f_0074.html.sec.islands"><em>“流中的</em></a><a href="#f_0074.html.sec.islands">岛屿”<em></em></a>中探讨它们。
</p><p>
The next problem we’ll look at involves <span class="firstuseinline">island languages</span> whose sentences
have islands of interesting bits surrounded by a sea of stuff we don’t care about. Examples
include XML and template languages like StringTemplate. To parse these, we need
<span class="firstuseinline">island grammars</span> and <span class="firstuseinline">lexical modes</span>, which we’ll
explore in Section 12.3, <a href="#f_0074.html.sec.islands">​<em>Islands in the Stream</em>​</a>.
</p>
<p id="f_0071.html.N17474">
最后，我们将根据 XML 规范构建一个 ANTLR XML 解析器和词法分析器。它是一个很好的示例，展示了如何处理包含不同上下文（区域）的输入流、如何在解析器和词法分析器之间划一条线以及如何接受非 ASCII 输入字符。
</p><p>
Finally, we’ll build an ANTLR XML parser and lexer from the XML specification. It’s a great
example of how to deal with input streams containing different contexts (regions), how to
draw a line between the parser and lexer, and how to accept non-ASCII input characters.
</p>
<p id="f_0071.html.N17477">
为了热身，让我们学习如何忽略但不丢弃特殊输入区域，例如注释和空格。该技术可用于解决许多语言翻译问题，我们将在此演示最常见的用例。
</p><p>
To get warmed up, let’s learn how to ignore but not throw out special input regions such as
comments and whitespace. The technique can be used to solve lots of language translation
problems, and we’ll demonstrate the most common use case here.
</p>

</div></div>
<div id="f_0072.html"><div>

<h2 id="f_0072.html.sec.token-channels">12.1 在不同频道上广播代币</h2><h2>12.1 Broadcasting Tokens on Different Channels</h2>
<p id="f_0072.html.N1747F">
大多数编程语言都会忽略标记之间的空格和注释，这意味着它们可以出现在任何地方。这给解析器带来了问题，因为它必须不断检查可选的空格和注释标记。常见的解决方案是让词法分析器匹配这些标记但将它们丢弃，这就是我们迄今为止在本书中所做的。例如，第 6.4 节“<a href="#f_0043.html.sec.Cymbol">解析<em>Cymbol”</em></a>中的 Cymbol 语法使用词法分析器命令<a href="#f_0043.html.sec.Cymbol">丢弃</a><code class="cf keyword">skip</code>。
</p><p>
Most programming languages ignore whitespace and comments in between tokens, which means
they can appear anywhere. That presents a problem for a parser since it has to constantly
check for optional whitespace and comment tokens. The common solution is to simply have the
lexer match those tokens but throw them out, which is what we’ve done so far in this book.
For example, our  Cymbol grammar from Section 6.4, <a href="#f_0043.html.sec.Cymbol">​<em>Parsing Cymbol</em>​</a> threw out
whitespace and comments using the <code class="cf keyword">skip</code> lexer command.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/examples/Cymbol.g4">示例/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\n\r]+ -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SL_COMMENT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'//'</em> .*? <em class="string">'\n'</em> -&gt; skip​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N174B8">
这对于许多应用程序（例如编译器）来说效果很好，因为注释不会影响代码生成。另一方面，如果我们试图构建一个翻译器来将遗留代码转换为现代语言，我们确实应该保留注释，因为它们是程序的一部分。这带来了一个难题：我们想保留注释和空格，但我们不想让解析器在标记之间不断检查它们。
</p><p>
That works great for many applications, such as compilers, because the comments don’t affect
code generation. If, on the other hand, we’re trying to build a translator to convert legacy
code into a modern language, we really should keep the comments around because they’re part
of the program. This presents a conundrum: we want to keep the comments and whitespace, but
we don’t want to burden the parser with constant checks for them in between tokens.
</p>
<h3>填充代币通道</h3><h3>Filling Token Channels</h3>
<p id="f_0072.html.N174BF">
ANTLR 的解决方案是将实际的语言标记（如标识符）通过一个
<span class="firstuseinline">通道</span>发送到解析器，将其他所有内容通过另一个通道发送到解析器。通道就像不同的无线电频率。解析器会调到一个通道，而忽略其他通道上的标记。词法分析器规则负责将标记放在不同的通道上，而类<code class="cf class">CommonTokenStream</code>负责只向解析器呈现一个通道。<code class="cf class">CommonTokenStream</code>在执行此操作的同时保留原始的相对标记顺序，以便我们可以请求特定语言标记之前或之后的注释。下图表示<code class="cf class">CommonTokenStream</code>C 词法分析器发出的标记的视图，该词法分析器将注释和空格放在隐藏通道上：
</p><p>
ANTLR’s solution is to send the actual language tokens like identifiers to the parser on one
<span class="firstuseinline">channel</span> and everything else on a different channel. Channels are like
different radio frequencies. The parser tunes to exactly one channel and ignores tokens on
the other channels. Lexer rules are responsible for putting tokens on different channels, and
class <code class="cf class">CommonTokenStream</code> is responsible for presenting only one channel to the
parser. <code class="cf class">CommonTokenStream</code> does this while preserving the original relative
token order so we can request the comments before or after a particular language token. The
following image represents <code class="cf class">CommonTokenStream</code>’s view of the tokens emitted by a
C lexer that puts comments and whitespace on a hidden channel:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/lexmagic/split.png">
</div>
<p id="f_0072.html.N174D5">
我们可以轻松地隔离一个通道上的注释和另一个通道上的空格，而将真正的标记留在默认通道 0 上。
</p><p>
We can just as easily isolate the comments on one channel and the whitespace on another, leaving the real tokens on the default channel 0.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/lexmagic/split3.png">
</div>
<p id="f_0072.html.N174DC">
这样，我们就可以分别请求注释和空格。
</p><p>
That way, we can ask for the comments and whitespace separately.
</p>
<p id="f_0072.html.N174DF">
要在不同通道上传输标记，我们
<code class="cf keyword">channel(...)</code>在相应的词法分析器规则中使用词法分析器命令。让我们通过改变 Cymbol 语法来演示这种技术，将注释放在隐藏通道 2 上，将空格放在隐藏通道 1 上，就像最后一张图一样。
</p><p>
To transmit tokens on a different channel, we use lexer command
<code class="cf keyword">channel(...)</code> in the appropriate lexer rule. Let’s demonstrate this
technique by altering our Cymbol grammar to put comments on hidden channel 2
and whitespace on hidden channel 1, like the last image.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/Cymbol.g4">lexmagic/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\n\r]+ -&gt; channel(WHITESPACE) ;  <em class="comment">// channel(1)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SL_COMMENT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'//'</em> .*? <em class="string">'\n'</em> -&gt; channel(COMMENTS)   <em class="comment">// channel(2)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N1750C">
常量<code class="cf variable">WHITESPACE</code>来自<code class="cf variable">COMMENTS</code>我们语法中的声明。
</p><p>
Constants <code class="cf variable">WHITESPACE</code> and <code class="cf variable">COMMENTS</code> come from a declaration in our grammar.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/Cymbol.g4">lexmagic/Cymbol.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::members {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> static final int WHITESPACE = 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> static final int COMMENTS = 2;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N17533">
ANTLR 将其转换<code class="cf ic">channel(HIDDEN)</code>为 Java 形式<code class="cf ic">_channel = HIDDEN</code>，将类<code class="cf class">Lexer</code>的<code class="cf variable">_channel</code>字段设置为常量
<code class="cf variable">HIDDEN</code>。我们可以使用任何有效的 Java 限定标识符作为命令的参数<code class="cf methodname">channel</code>。
</p><p>
ANTLR translates <code class="cf ic">channel(HIDDEN)</code> to Java as <code class="cf ic">_channel = HIDDEN</code>, which sets
class <code class="cf class">Lexer</code>’s <code class="cf variable">_channel</code> field to constant
<code class="cf variable">HIDDEN</code>. We can use any valid Java qualified identifier as an argument to
command <code class="cf methodname">channel</code>.
</p>
<p id="f_0072.html.N17548">
用测试语法<code class="cf commandname">grun</code>表明，注释出现在通道 2 上，空格出现在通道 1 上，其他标记出现在默认通道上。
</p><p>
Testing the grammar with <code class="cf commandname">grun</code> shows that the comments appear on
channel 2, whitespace appears on channel 1, and the other tokens appear on the default
channel.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Cymbol.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Cymbol*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Cymbol file -tokens -tree</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int i = 3; // testing</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:2='int',&lt;10&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,3:3=' ',&lt;24&gt;,channel=1,1:3]                 &lt;-- HIDDEN channel 1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,4:4='i',&lt;22&gt;,1:4]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,5:5=' ',&lt;24&gt;,channel=1,1:5]                 &lt;-- HIDDEN channel 1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,6:6='=',&lt;11&gt;,1:6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,7:7=' ',&lt;24&gt;,channel=1,1:7]                 &lt;-- HIDDEN channel 1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,8:8='3',&lt;23&gt;,1:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,9:9=';',&lt;13&gt;,1:9]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,10:10=' ',&lt;24&gt;,channel=1,1:10]              &lt;-- HIDDEN channel 1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,11:21='// testing\n',&lt;25&gt;,channel=2,1:11]   &lt;-- HIDDEN channel 2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,22:21='&lt;EOF&gt;',&lt;-1&gt;,2:22]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(file (varDecl (type int) i = (expr 3) ;))      &lt;-- parse tree​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N17597">
解析树看起来也正确，这意味着解析器正确地解释了输入。没有语法错误表明解析器没有深入到注释标记。现在让我们弄清楚如何从语言应用程序中访问隐藏的注释。
</p><p>
The parse tree also looks right, which means that the parser correctly interpreted the
input. The lack of syntax error indicates that the parser didn’t plow into a comment token.
Now let’s figure out how to access hidden comments from a language application.
</p>
<h3>访问隐藏频道</h3><h3>Accessing Hidden Channels</h3>
<p id="f_0072.html.N175A1">
为了说明如何从语言应用程序访问隐藏通道，让我们构建一个解析树侦听器，将声明后的注释移到声明之前，并对其进行调整以使用<code class="cf ic">/*...*/</code>-style 注释。例如，给定以下输入：
</p><p>
To illustrate how to access the hidden channels from a language application, let’s build a
parse-tree listener that shifts comments following declarations to precede the declarations,
tweaking them to use <code class="cf ic">/*...*/</code>-style comments. For example, given the following input:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/t.cym">lexmagic/t.cym</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int n = 0; // define a counter​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int i = 9;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N175C3">
我们希望生成以下输出：
</p><p>
we want to generate the following output:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/* define a counter */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> n = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">int</strong> i = 9;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N175DD">
我们的基本策略是使用 重写标记流
<code class="cf class">TokenStreamRewriter</code>，就像我们在<a href="#f_0030.html.sec.rewriting-input">重写<em>输入流</em></a>中所做的那样
<a href="#f_0030.html.sec.rewriting-input">。</a><code class="cf class">Cymbol</code>名为 的解析树侦听器<code class="cf class">CommentShifter</code>，位于名为 的测试装置类中<code class="cf class">ShiftVarComments</code>：
</p><p>
Our basic strategy will be to rewrite the token stream using a
<code class="cf class">TokenStreamRewriter</code>, as we did in <a href="#f_0030.html.sec.rewriting-input">​<em>Rewriting the Input Stream</em>​</a>. Upon
seeing a variable declaration, our application will grab the comment, if any, to the right of
the semicolon and insert it before the first token of the declaration. Here’s a
<code class="cf class">Cymbol</code> parse-tree listener called <code class="cf class">CommentShifter</code> that sits
inside a test rig class called <code class="cf class">ShiftVarComments</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/ShiftVarComments.java">lexmagic/ShiftVarComments.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">1号线&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> CommentShifter <strong class="prompt">extends</strong> CymbolBaseListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    BufferedTokenStream tokens;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    TokenStreamRewriter rewriter;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <em class="comment">/** Create TokenStreamRewriter attached to token stream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">5&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">             *  sitting between the Cymbol lexer and parser.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">             */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> CommentShifter(BufferedTokenStream tokens) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        this.tokens = tokens;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        rewriter = <strong class="prompt">new</strong> TokenStreamRewriter(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">10&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> exitVarDecl(CymbolParser.VarDeclContext ctx) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        Token semi = ctx.getStop(); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">15&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">int</strong> i = semi.getTokenIndex();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">List</strong>&lt;Token&gt; cmtChannel =​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            tokens.getHiddenTokensToRight(i, CymbolLexer.COMMENTS); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( cmtChannel!=null ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            Token cmt = cmtChannel.get(0); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">20&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">if</strong> ( cmt!=null ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                <strong class="prompt">String</strong> txt = cmt.getText().substring(2);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                <strong class="prompt">String</strong> newCmt = <em class="string">"/* "</em> + txt.trim() + <em class="string">" */\n"</em>;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                rewriter.insertBefore(ctx.start, newCmt); ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                rewriter.replace(cmt, <em class="string">"\n"</em>);                          ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">二十五&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">-&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N176B0">
所有工作都发生在 中<code class="cf methodname">exitVarDecl</code>。首先，我们获取声明分号的标记索引（第 14 行），因为我们正在寻找该标记后的注释。第 17 行询问标记流，<code class="cf variable">COMMENTS</code>分号右侧的通道上是否有任何隐藏的标记。为简单起见，代码假设只有一个，因此第 19 行从列表中获取第一个注释。然后，我们从旧注释中派生出新样式的注释，并在 
<code class="cf class">TokenStreamRewriter</code>变量声明开始之前使用 将其注入（第 23 行）。最后，我们用换行符替换现有的后续注释（第 24 行），从而有效地将其删除。
</p><p>
All of the work happens in <code class="cf methodname">exitVarDecl</code>. First we get the token index of the
declaration semicolon (line 14) because we’re looking
for comments after that token. Line 17 asks the
token stream if there are any hidden tokens on channel <code class="cf variable">COMMENTS</code> to the
right of the semicolon. For simplicity, the code assumes there is only one, so line 19 grabs the first comment from the list. Then we derive the
new style comment from the old comment and inject it using 
<code class="cf class">TokenStreamRewriter</code> before the start of the variable declaration (line 23). Finally, we replace the existing following comment
with a newline (line 24), effectively erasing it.
</p>
<p id="f_0072.html.N176CB">
测试台本身还是老一套，但最后我们要求<code class="cf class">TokenStreamRewriter</code>全班同学给我们提供重写的输入<code class="cf methodname">getText</code>。
</p><p>
The test rig itself is the same old story, but at the end, we ask the <code class="cf class">TokenStreamRewriter</code> class to give us the rewritten input with <code class="cf methodname">getText</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/ShiftVarComments.java">lexmagic/ShiftVarComments.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CymbolLexer lexer = <strong class="prompt">new</strong> CymbolLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CymbolParser parser = <strong class="prompt">new</strong> CymbolParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RuleContext tree = parser.file();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommentShifter shifter = <strong class="prompt">new</strong> CommentShifter(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(shifter, tree);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.print(shifter.rewriter.getText());​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N1770A">
以下是构建和测试顺序：
</p><p>
Here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Cymbol.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Cymbol*.java ShiftVarComments.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java ShiftVarComments t.cym</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​/* define a counter */​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int n = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int i = 9;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0072.html.N17731">
请注意，如果我们扔掉空格，而不是将其发送到隐藏通道，那么输出将全部聚集在一起，就像<code class="cf ic">intn=0;</code>。
</p><p>
Note that if we had thrown out whitespace, rather than sending it on a hidden channel, that
output would be all bunched together like <code class="cf ic">intn=0;</code>.
</p>
<p id="f_0072.html.N17737">
标记通道通过对输入标记进行分类来解决棘手的语言翻译问题。现在，我们将重点讨论与标记本身的构造相关的问题。
</p><p>
Token channels solve a tricky language translation problem by categorizing input tokens. Now,
we’re going to focus on problems related to the construction of the tokens themselves.
</p>

</div></div>
<div id="f_0073.html"><div>

<h2 id="f_0073.html.sec.context-sensitive-lexers">12.2 上下文相关词汇问题</h2><h2>12.2 Context-Sensitive Lexical Problems</h2>
<p id="f_0073.html.N1774E">
以“秋天的棕色树叶”这个短语为例。它的含义很模糊，因为有两种解释。如果我们谈论的是树木，这个短语指的是大自然的光合作用引擎。另一方面，如果我们谈论的是某位简·布朗女士，那么上下文就会完全改变这些词的功能。“树叶”从名词变成了动词。
</p><p>
Consider the phrase “Brown leaves in the fall.” It’s ambiguous because there are two
interpretations. If we’re talking about trees, the phrase refers to nature’s photosynthesis
engine. If, on the other hand, we’re discussing a certain Ms. Jane Brown, the context
totally changes the function of those words. “Leaves” shifts from a noun to a verb.
</p>
<p id="f_0073.html.N17757"><a href="#f_0070.html.sec.recog-ambig-phrases">这种情况类似于我们在第 11.3 节“识别<em>歧义短语</em></a>
”中解决的问题，<a href="#f_0070.html.sec.recog-ambig-phrases">其中</a>
上下文敏感的 C++ 短语（如）<code class="cf ic">T(0)</code>可能是函数调用或类型转换，具体取决于<code class="cf ic">T</code>在程序中其他地方的定义方式。出现这种句法歧义是因为我们的 C++ 词法分析器<code class="cf keyword">ID</code>向解析器发送了模糊的通用标记。我们需要解析器规则中的语义谓词来在备选解释之间进行选择。
</p><p>
This situation resembles the problems we solved in Section 11.3, <a href="#f_0070.html.sec.recog-ambig-phrases">​<em>Recognizing Ambiguous Phrases</em>​</a>
where context-sensitive C++ phrases like <code class="cf ic">T(0)</code> could be function calls or type casts
depending on how <code class="cf ic">T</code> was defined elsewhere in the program. Such syntactic ambiguities
arose because our C++ lexer sent vague generic <code class="cf keyword">ID</code> tokens to the parser. We
needed semantic predicates in the parser rules to choose between alternative interpretations.
</p>
<p id="f_0073.html.N17766">
为了摆脱解析器规则中的谓词，我们可以让词法分析器根据上下文向解析器发送更精确的标记，例如<code class="cf keyword">FUNCTION_NAME</code>vs.
 <code class="cf keyword">TYPE_NAME</code>。（对于输入“Brown leaves”，我们会让词法分析器发送标记序列<code class="cf keyword">ADJECTIVE</code>&nbsp;<code class="cf keyword">NOUN</code>
vs. <code class="cf keyword">PROPER_NAME</code>&nbsp;<code class="cf keyword">VERB</code>。）不幸的是，这只是将上下文敏感性问题转移到词法分析器，而词法分析器所拥有的上下文信息远不及解析器。这就是为什么我们在上一章中对解析器规则进行谓词，而不是尝试使用词法分析器上下文向解析器发送更精确的标记。
</p><p>
To get rid of the predicates in the parser rules, we could have the lexer send more precise
tokens to the parser such as <code class="cf keyword">FUNCTION_NAME</code> vs.
<code class="cf keyword">TYPE_NAME</code>, depending on context. (For input “Brown leaves,” we’d have
the lexer send token sequence <code class="cf keyword">ADJECTIVE</code>&nbsp;<code class="cf keyword">NOUN</code>
vs. <code class="cf keyword">PROPER_NAME</code>&nbsp;<code class="cf keyword">VERB</code>.) Unfortunately, that
just shifts the context-sensitivity problem to the lexer, and the lexer has nowhere near as
much context information as the parser. That’s why we predicated parser rules in the previous
chapter instead of trying to use lexer context to send more precise tokens to the parser.
</p>
<div class="sidebar">
<div class="sidebar-title">黑客警报：解析器反馈</div>
<div class="sidebar-content">
<p id="f_0073.html.N1777F">
一种一直存在的常见做法是将解析器的反馈发送到词法分析器，以便词法分析器可以向解析器发送精确的标记。由于谓词减少，解析器可以变得更简单。不幸的是，这在 ANTLR 语法中是不可能的，因为 ANTLR 生成的解析器通常会在标记流中提前很久做出解析决策。这意味着在解析器有机会执行向词法分析器提供上下文信息的操作之前，词法分析器可能会被要求对输入字符进行标记。
</p><p>
A common practice that’s been around forever involves sending feedback from the parser to
the lexer so that the lexer can send precise tokens to the parser. The parser can then be
simpler because of the reduction in predicates. Unfortunately, this is not possible with
ANTLR grammars because ANTLR-generated parsers often look very far ahead in the token stream
to make parsing decisions. That means the lexer could be asked to tokenize input
characters long before the parser has had a chance to execute actions that provide context
information to the lexer.
</p>
</div>
</div>
<p id="f_0073.html.N1778A">
我们无法总是避免与输入字符标记相关的上下文敏感性问题。在本节中，我们将研究属于上下文敏感性类别的三个词汇问题。
</p><p>
We can’t always escape context-sensitivity issues related to tokenizing input characters. In
this section, we’re going to look at three lexical problems that fit into the
context-sensitivity bucket.
</p>
<ul>
<li>
<p id="f_0073.html.N17790">
<span class="emph">相同的标记字符序列对解析器来说可能意味着不同的东西。</span>我们将解决众所周知的“关键字也可以是标识符”问题。
	</p>
</li><li>
<p>
<span class="emph">The same token character sequence can mean different things to the parser.</span> We’ll tackle the well-known “keywords can also be identifiers” problem.
	</p>
</li>
<li>
<p id="f_0073.html.N17796">
<span class="emph">相同的字符序列可以是一个或多个标记。</span>我们将了解如何将 Java 字符序列<code class="cf ic">&gt;&gt;</code>视为两个闭合类型参数标记或单个右移运算符标记。
  </p>
</li><li>
<p>
<span class="emph">The same character sequence can be one token or multiple.</span> We’ll see how to
    treat Java character sequence <code class="cf ic">&gt;&gt;</code> either as two close-type-parameter tokens or as a
    single right shift operator token.
  </p>
</li>
<li>
<p id="f_0073.html.N1779F">
<span class="emph">相同的标记有时必须被忽略，有时必须被解析器识别。</span>我们将学习如何区分 Python 的物理输入行和逻辑输入行。解决方案需要词汇动作和语义谓词，这是我们在前两章中学到的技术。
  </p>
</li><li>
<p>
<span class="emph">The same token must sometimes be ignored and sometimes be recognized by the
    parser.</span> We’ll learn how to distinguish between Python’s physical and logical input
    lines. The solution requires both lexical actions and semantic predicates, techniques we
    learned in the previous two chapters.
  </p>
</li>
</ul>
<p id="f_0073.html.N177A4"></p>
<h3 id="f_0073.html.sec.keywords-as-ids">将关键字视为标识符</h3><h3>Treating Keywords As Identifiers</h3>
<p id="f_0073.html.N177AB">
许多语言（无论新旧）都允许使用关键字作为标识符，具体取决于上下文。在 Fortran 中，我们可以这样说<code class="cf ic">end = goto + if/while</code>。C# 使用其语言集成查询 (LINQ) 功能支持 SQL 查询。查询以关键字开头<code class="cf keyword">from</code>，但我们也可以将其用作<code class="cf keyword">from</code>变量：
 <code class="cf ic">x = from + where;</code>。从语法上讲，这无疑是一个表达式，而不是查询，因此词法分析器应将其视为标识符，而<code class="cf keyword">from</code>不是关键字。问题是词法分析器不解析输入。它不知道是否要将 发送
给解析器。
	<code class="cf keyword">KEYWORD_FROM</code><code class="cf keyword">ID</code></p><p>
Lots of languages, both old and new, allow keywords as identifiers, depending on the
context. In Fortran, we could say things like <code class="cf ic">end = goto + if/while</code>. C# supports
SQL queries with its Language-Integrated Query (LINQ) feature. Queries begin with
keyword <code class="cf keyword">from</code>, but we can also use <code class="cf keyword">from</code> as a variable:
<code class="cf ic">x = from + where;</code>. That’s unambiguously an expression, not a query syntactically, so
the lexer should treat <code class="cf keyword">from</code> as an identifier, not a keyword. The problem is
that the lexer doesn’t parse the input. It doesn’t know whether to send, say,
<code class="cf keyword">KEYWORD_FROM</code> or <code class="cf keyword">ID</code> to the parser.
	</p>
<div class="sidebar" id="f_0073.html.sb.wheninParis">
<div class="sidebar-title">在巴黎时...</div>
<div class="sidebar-content">
<p id="f_0073.html.N177D4">20 世纪 80 年代末，我在法国工作，很快发现打电话时有个问题。当接电话的人问是谁打来的，我会回答<span class="emph">“帕尔先生”</span>，但“帕尔”听起来就像“离开”的第三人称单数形式的<span class="emph">一部分</span>。听起来就像我在说我要挂断电话。太搞笑了。</p><p>I worked in France in the late 1980s and quickly found a problem when calling people on the phone. When the receiving end asked who was calling, I’d reply <span class="emph">Monsieur Parr</span>, but Parr sounds just like <span class="emph">part</span>, the third-person singular of the verb “to leave.”  It sounds like I’m saying that I’m going to hang up. Hilarious.</p>
<p id="f_0073.html.N177DD">
这是一句有趣的法语绕口令，其中每个单词都需要大量上下文才能破译：“Si six cent scies scient six cent saucisses, six cent six scies scieront six cent six saucissons。”书面形式重复但很清晰。然而，说出来时，英语的发音大致如下：“See see saw, see see see saw, sawcease, see saw see seeron see saw see sawcease。”翻译过来就是“如果六百把锯子锯了六百根香肠，那么六百零六把锯子就会锯六百六根香肠。”不要因为<span class="emph">si</span>、<span class="emph">six</span>、
 <span class="emph">scies</span>和<span class="emph">scient</span>发音一模一样而取笑法语。英语中有些单词写得一样，但发音不同，比如 read（现在时）和 read（过去时）！
</p><p>
Here’s a fun tongue twister in French where each word requires heavy context to decipher:
“Si six cent scies scient six cent saucisses, six cent six scies scieront six cent six
saucissons.” The written form is repetitive but clear. When spoken, however, the
pronunciation in English is something like this: “See see saw, see see see saw, sawcease, see
saw see see seeron see saw see sawcease.” The translation is “If six hundred saws saw
six hundred sausages, six hundred and six saws will saw six hundred six sausages.” Don’t
make fun of the French for the fact that <span class="emph">si</span>, <span class="emph">six</span>,
<span class="emph">scies</span>, and <span class="emph">scient</span> all sound exactly the same. English has words
that are written the same but pronounced differently, like read (present tense) and read
(past tense)!
</p>
</div>
</div>
<p id="f_0073.html.N177EC">
有两种方法可以让关键字在某些语法上下文中充当标识符。第一种方法是让词法分析器将所有关键字作为关键字标记类型传递给解析器，然后我们创建一个与任何关键字<code class="cf keyword">id</code>匹配的解析器规则
<code class="cf keyword">ID</code>。第二种方法是让词法分析器将关键字作为标识符传递，然后我们使用谓词在解析器中测试标识符名称，如下所示：
</p><p>
There are two approaches to allowing keywords to act as identifiers in some syntactic
contexts. The first approach has the lexer pass all keywords to the parser as keyword token
types, and then we create a parser <code class="cf keyword">id</code> rule that matches
<code class="cf keyword">ID</code> and any of the keywords. The second approach has the lexer pass
keywords as identifiers, and then we use predicates to test identifier names in the parser
like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​keyIF : {_input.LT(1).getText().equals(<em class="string">"if"</em>)}? ID ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17804">
这很丑陋，而且可能很慢，所以我们将坚持使用第一种方法。（为了完整起见，我在 中留下了一个虽小但有效的谓词关键字示例
<code class="cf filename">PredKeyword.g4</code>。）
</p><p>
That’s pretty ugly, and likely slow, so we’ll stick with the first approach. (For
completeness, I’ve left a small but working predicated keyword example in
<code class="cf filename">PredKeyword.g4</code>.)
</p>
<p id="f_0073.html.N1780A">
为了说明推荐的方法，这里有一个简单的语法，可以匹配如下的疯狂陈述<code class="cf ic">if if then call call;</code>：
</p><p>
To illustrate the recommended approach, here’s a simple grammar that matches nutty statements
like <code class="cf ic">if if then call call;</code>:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/IDKeyword.g4">lexmagic/ID关键字.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> IDKeyword;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog: stat+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'if'</em> expr <em class="string">'then'</em> stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'call'</em> id <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: id ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​id  :   <em class="string">'if'</em> | <em class="string">'call'</em> | <em class="string">'then'</em> | ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS : [ \r\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N1785A">
简而言之，该方法<code class="cf keyword">ID</code>用对规则的引用替换了对 token 的所有引用<code class="cf keyword">id</code>。如果您面对的语言允许不同的关键字集在不同的上下文中作为标识符，那么您将需要多个<code class="cf keyword">id</code>规则（每个上下文一个）。
</p><p>
In a nutshell, the approach replaces all references to token <code class="cf keyword">ID</code> with
references to rule <code class="cf keyword">id</code>. If you’re faced with a language that allows
different sets of keywords to be identifiers in different contexts, you’ll need more than
one <code class="cf keyword">id</code> rule (one per context).
</p>
<p id="f_0073.html.N17866">
以下是语法的构建和测试顺序<code class="cf class">IDKeyword</code>：
</p><p>
Here’s the build and test sequence for grammar <code class="cf class">IDKeyword</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 IDKeyword.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac IDKeyword*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun IDKeyword prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">if if then call call;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N1788D">
解析树显示语法将第二个<code class="cf ic">if</code>和第二个<code class="cf ic">call</code>符号视为标识符。
</p><p>
The parse tree shows that the grammar treats the second <code class="cf ic">if</code> and second <code class="cf ic">call</code> symbols as identifiers.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGoAAACPCAMAAAAldr6UAAAANlBMVEX////w8PDT0tLi4eGKiIjEw8SnpaaYlpcyLi9samq2tLVPTE26ublAPT5eW1t7eXkjHyDW1dVsiAP9AAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAASAAAAEgARslrPgAABCxJREFUaN7tm4GWoyAMRQkGqLpi9/9/dhNoKyIq2NLd2UPOjGXawBWIlGccIZo1u2AgO1T8ohRoA1QyuuuqoNStH8aBX35NWk8d0PE21EFNQgyWXwwKgcjHWdVBWfdLP+hQ7lgJNYEwM6N0L0Sv+TjVQlk7dq5zs7UzdWmyFQcwtlF+B2VxnquQ6IKK3uhUnT79LauzRiStTtw1VEM1VEM1VEN91v6vL/pvm9kUqphCKe8KxECbdVeoR7Jq0HfsQKtRcaEeStOeXdypAKpHV6jImhxBWj3XRgm4MQENa6yqKN1bFHaUwzT3rlC3X82aJQ1MrysuSYtJUsASseai5E2jlkiLugKNdW76eOsMSlrcuYjAy7ypNI6+Za3dH+BuIwDi5xcMMP520oNE4EdhQH2xyZ2RQ+OjQC/tvuKi+2CI6NeJr26ULXdiPhQiLhSepNXEyHBv8X6IrFqIQ8Csdp7dOyGyHhfYtoRRR/TFEIlmG+btAMG8rWSKQyQ+wRRpifj1UJTs6LfDniYFEb86gewQSXhK3HNO33sMw3bXkpfIPmkd8aGdhUj6wj8gxRG/rnYQIip9IscrwcGnUB6OH7fO8Ka84CI8HNhjFNW8Zy9kJn3jPXKJCk8DKeS4SCYw1EHZ0ds+m8TJpKBHJK6U7TiK2BGkXAUU6TDnwjosIcQ42TG9KsA0GCvUKPrBZ5PoGKBYXKkJzQ2co7qhniBoSg3s8pt1mNgKMR6PZUjMrDiLhP38yCbxMbC74PMQVjlHX1xOhHUYuzgdtpUsaxT2Lmuk7sMjmxTNzP1RQTlHXww6PTmC12FnKO2XHKtG8NmkPZRzjFGsw8jF67AzlJhH0lLkiL3PJkUoEleP9tkxQjkdRi7G6bACIXYW1B+0L6Kg6dD37Pr4aSzcHF6+0YikxcpYV1G05CKUsS6ieCeDoox1CQWGp5i+d3yhIurRGTBiu9f/LOo1bF7NZrPKUcsE+e/6bFYxSi6X02OnozN3R6WocCf1zL1nsgpRqz0bPBF5rDJUtDt8bcyGHFYRKj77ZQ+Ys0MtQW3GKWg/g1WA2s5I+EzGOSsfZbayBEJ4d/alko1KXqmrnpwtvrlLc3oPIjN8vm2dC9bcdYUmfjX1vnZm9c4vzbmiLdra+9qZ1WlsST+d+YImWcNaKkLxzETV9ydeWX42bzpGwYiDcjmtCEV/RNXV7QDlns07Rhn3MWupLSquvh+Byvon9A5R7mOnpbaojOovZ342zx77am7eaaktKqoO++sBOdvR9ienRRLLuJzWFhVVHyo9EJewSo9JpuyfWJf+Y3tvJotqN1RDNVRDNVRD/QTUe7nlrzwEUmrFWa2tkeTKSnWVZbWS5v8759yirFaBBaIrD7XOapWQAtGVjRKXEhWh6KqMCkVXZVQouiqjQtH1zWRRsx9qfwDL5R3tLr0u+wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0Njo0OS0wNjowMLcJ4UkAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDY6NDktMDY6MDDGVFn1AAAAIHRFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAA2MTJ4NzkyKzArMJ+dfVcAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/lexmagic/ifif.png">
</div>
<p id="f_0073.html.N1789B">
在这个问题中，词法分析器必须决定是否返回关键字或标识符标记，但它不必担心哪些字符构成标记。现在我们要解决一个问题，其中词法分析器不知道每个标记要消耗多少输入。
</p><p>
In this problem, the lexer has to decide whether to return keyword or identifier tokens, but
it doesn’t have to worry about which characters constitute the tokens. Now we’re going to
work on a problem where the lexer doesn’t know how much input to consume for each token.
</p>
<h3 id="f_0073.html.sec.maximal-munch">避免最大 Munch 歧义</h3><h3>Avoiding the Maximal Munch Ambiguity</h3>
<p id="f_0073.html.N178A9">
词法分析器生成器工具通常假设词法分析器应在每个输入位置匹配最长的标记。该假设通常会使词法分析器表现出最自然的行为。例如，给定 C 输入<code class="cf ic">+=</code>，C 词法分析器应匹配单个标记<code class="cf ic">+=</code>，而不是两个单独的标记，如<code class="cf ic">+</code>和<code class="cf ic">=</code>。不幸的是，有些情况下我们需要以不同的方式处理。
</p><p>
There is a general assumption made by lexer-generator tools that lexers should match the
longest possible token at each input position. That assumption usually gives lexers the most
natural behavior. For example, given C input <code class="cf ic">+=</code>, a C lexer should match the single
token <code class="cf ic">+=</code>, not two separate tokens, as in <code class="cf ic">+</code> and <code class="cf ic">=</code>. Unfortunately, there
are a few cases we need to handle differently.
</p>
<p id="f_0073.html.N178C7">
在 C++ 中，我们不能用双尖括号来关闭嵌套的参数化类型，就像这样：
 <code class="cf ic">A&lt;B&lt;C&gt;&gt;</code>。我们必须在最后的尖括号之间使用空格，，
<code class="cf ic">A&lt;B&lt;C&gt; &gt;</code>这样词法分析器就不会将双尖括号与右移位运算符混淆，
 <code class="cf ic">&gt;&gt;</code>。<a id="f_0073.html.FNPTR-47" href="#f_0075.html.FOOTNOTE-47">[47]</a>
这个问题相当难，C++ 的设计者们改变了语言来克服这个棘手的词法实现问题。
</p><p>
In C++, we can’t close nested parameterized types with a double angle bracket like this:
<code class="cf ic">A&lt;B&lt;C&gt;&gt;</code>. We have to use a space in between the final angle brackets,
<code class="cf ic">A&lt;B&lt;C&gt; &gt;</code>, so the lexer doesn’t confuse the double angle brackets with
the right shift operator,
<code class="cf ic">&gt;&gt;</code>.<a href="#f_0075.html.FOOTNOTE-47">[47]</a>
It was considered a hard enough problem that the designers of C++ altered the language to
overcome a nasty lexical implementation problem.
</p>
<p id="f_0073.html.N178DE">
此后出现了许多合适的解决方案，但最简单的方法是永远不要让词法分析器将<code class="cf ic">&gt;&gt;</code>字符序列匹配为右移运算符。相反，词法分析器将两个<code class="cf ic">&gt;</code>标记发送到解析器，解析器可以使用上下文将标记适当地打包在一起。例如，C++ 解析器表达式规则将匹配连续的两个右尖括号，而不是单个标记。如果回顾第 4.3 节“<a href="#f_0028.html.sec.tour-java"><em>使用侦听器</em></a><a href="#f_0028.html.sec.tour-java">构建中的 Java 语法，<em></em></a>您将看到这种方法的一个示例实现。以下是将<code class="cf keyword">expr</code>单字符标记组合成多字符运算符的两种规则替代方案：
</p><p>
A number of suitable solutions have since popped up, but the simplest is to never have the
lexer match the <code class="cf ic">&gt;&gt;</code> character sequence as a right shift operator. Instead, the lexer
sends two <code class="cf ic">&gt;</code> tokens to the parser, which can use context to pack the tokens together
appropriately. For example, a C++ parser expression rule would match two right angle
brackets in a row instead of a single token. If you look back at the Java of grammar from
Section 4.3, <a href="#f_0028.html.sec.tour-java">​<em>Building a Translator with a Listener</em>​</a>, you’ll see an example implementation of this approach. Here
are two <code class="cf keyword">expr</code> rule alternatives that combine single-character tokens into
multicharacter operators:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/tour/Java.g4">游览/Java.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   expression (<em class="string">'&lt;'</em> <em class="string">'&lt;'</em> | <em class="string">'&gt;'</em> <em class="string">'&gt;'</em> <em class="string">'&gt;'</em> | <em class="string">'&gt;'</em> <em class="string">'&gt;'</em>) expression​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​|   expression (<em class="string">'&lt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em>) expression​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17924">
让我们看一下词法分析器传递给解析器的移位运算符的标记。
</p><p>
Let’s look at the tokens passed by the lexer to the parser for the shift operator.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Java.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Java*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Java tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">i = 1 &gt;&gt; 5;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:0='i',&lt;98&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,1:1=' ',&lt;100&gt;,channel=1,1:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,2:2='=',&lt;25&gt;,1:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,3:3=' ',&lt;100&gt;,channel=1,1:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,4:4='1',&lt;91&gt;,1:4]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,5:5=' ',&lt;100&gt;,channel=1,1:5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,6:6='&gt;',&lt;81&gt;,1:6]               &lt;-- two '&gt;' tokens not one '&gt;&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,7:7='&gt;',&lt;81&gt;,1:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,8:8=' ',&lt;100&gt;,channel=1,1:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,9:9='5',&lt;91&gt;,1:9]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,10:10=';',&lt;77&gt;,1:10]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,11:11='\n',&lt;100&gt;,channel=1,1:11]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@12,12:11='&lt;EOF&gt;',&lt;-1&gt;,2:12]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17970">
以下是嵌套泛型类型引用的标记流：
</p><p>
And here’s what the token stream looks like for a nested generic type reference:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Java tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">List&lt;List&lt;String&gt;&gt; x;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:3='List',&lt;98&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,4:4='&lt;',&lt;5&gt;,1:4]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,5:8='List',&lt;98&gt;,1:5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,9:9='&lt;',&lt;5&gt;,1:9]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,10:15='String',&lt;98&gt;,1:10]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,16:16='&gt;',&lt;81&gt;,1:16]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,17:17='&gt;',&lt;81&gt;,1:17]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,18:18=' ',&lt;100&gt;,channel=1,1:18]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,19:19='x',&lt;98&gt;,1:19]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,20:20=';',&lt;77&gt;,1:20]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,21:21='\n',&lt;100&gt;,channel=1,1:21]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,22:21='&lt;EOF&gt;',&lt;-1&gt;,2:22]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N179AF">
现在让我们为这些短语生成解析树，因为它们清楚地表明了语法如何使用标记<code class="cf ic">&gt;</code>。
</p><p>
Now let’s generate the parse trees for those phrases because they make it clear how the grammar uses the <code class="cf ic">&gt;</code> tokens.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Java statement -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">i = 1 &gt;&gt; 5;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Java localVariableDeclarationStatement -gui</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">List&lt;List&lt;String&gt;&gt; x;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N179DB">
以下是并排的解析树，以规则为根<code class="cf keyword">statement</code>，并
<code class="cf keyword">localVariableDeclarationStatement</code>突出显示了尖括号：
</p><p>
Here are the parse trees side by side, rooted at rules <code class="cf keyword">statement</code> and
<code class="cf keyword">localVariableDeclarationStatement</code> with the angle brackets highlighted:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/lexmagic/shift-type-combined.png">
</div>
<p id="f_0073.html.N179E8">
拆分移位运算符的两个右尖括号的唯一问题是，解析器也会接受用空格字符分隔的尖括号。<code class="cf ic">&gt; &gt;</code>为了解决这个问题，我们可以向语法添加语义谓词，也可以在之后使用侦听器或访问者检查解析树，以确保<code class="cf ic">&gt;</code>移位运算符的标记列号相邻。在解析过程中使用谓词效率低下，因此最好在解析后检查正确的移位运算符。大多数语言应用程序无论如何都需要遍历解析树。（表达式规则中的谓词也会破坏 ANTLR 的左递归规则模式，它知道如何将其转换为非左递归版本。请参阅第 14 章“<a href="#f_0087.html.chp.left-recursion-removal">删除<em>直接左递归</em></a>”
<a href="#f_0087.html.chp.left-recursion-removal">。</a></p><p>
The only problem with splitting the two right angle brackets of the shift operator is that
the parser will also accept angle brackets separated by a space character, <code class="cf ic">&gt; &gt;</code>. To
address this, either we can  add semantic predicates to the grammar or we can check the parse
tree afterward using a listener or visitor to ensure that the <code class="cf ic">&gt;</code> token column
numbers are adjacent for shift operators. It’d be inefficient to use predicates during the
parse, so it’s better to check the right shift operators after the parse. Most language
applications need to walk the parse tree anyway. (Predicates in an expression rule would also
break ANTLR’s left-recursive rule pattern that it knows how to convert to a non-left-recursive version. See Chapter 14, <a href="#f_0087.html.chp.left-recursion-removal">​<em>Removing Direct Left Recursion</em>​</a>.)
</p>
<p id="f_0073.html.N179FA">
到目前为止，我们已经了解了如何将标记放在不同的通道上，以及如何将上下文敏感的标记拆分为最小的有效标记组件。现在，我们将弄清楚如何根据上下文将相同的字符序列视为两种不同的标记类型。
</p><p>
At this point, we’ve seen how to put tokens on different channels and how to split
context-sensitive tokens into their smallest valid token components. Now we’re going to
figure out how to treat the same character sequence as two different token types, depending
on  the context.
</p>
<h3 id="f_0073.html.sec.python-newlines">Python 换行符的乐趣</h3><h3>Fun with Python Newlines</h3>
<p id="f_0073.html.N17A02">
Python 的换行符处理对程序员来说非常自然。换行符会终止语句，而不是使用分号。我们大多数人每行都写一个语句，因此不断输入分号很麻烦。同时，我们不想在同一行上写很长的表达式，因此 Python 在某些情况下会忽略换行符。例如，Python 允许我们将方法调用拆分为多行，如下所示：
</p><p>
Python’s newline handling is very natural for the programmer. Rather than using a semicolon,
newlines terminate statements. Most of us put one statement per line anyway, so typing the
semicolon constantly is a nuisance. At the same time, we don’t want to put really long
expressions on the same physical line, so Python ignores newlines in certain contexts. For
example, Python lets us split method calls over multiple lines like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​f(1,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​2,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​3)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17A29">
为了弄清楚何时忽略换行符，让我们把 Python 参考手册中有关换行符的所有文档放在一起。<a id="f_0073.html.FNPTR-48" href="#f_0075.html.FOOTNOTE-48">[48]</a>
最重要的规则如下：
</p><p>
To figure out when to ignore newlines, let’s put together all of the bits of
documentation concerning newlines from the Python reference
manual.<a href="#f_0075.html.FOOTNOTE-48">[48]</a>
The most important rule is as follows:
</p>
<blockquote>
<p id="f_0073.html.N17A33">
括号、方括号或花括号中的表达式可以分成多行物理行 [...]。
</p>
</blockquote><blockquote>
<p>
Expressions in parentheses, square brackets, or curly braces can
be split over more than one physical line [...].
</p>
</blockquote>
<p id="f_0073.html.N17A36">
因此，如果我们尝试<code class="cf ic">1+2</code>在后面<code class="cf ic">+</code>用换行符拆分表达式，Python 会发出错误。但是，我们可以<code class="cf ic">(1+2)</code>跨行拆分。手册还说“隐式续行可以带有注释”和“允许空白续行”，如下所示：
</p><p>
So, if we try to split expression <code class="cf ic">1+2</code> after the <code class="cf ic">+</code> with a newline, Python
emits an error. We can, however, split <code class="cf ic">(1+2)</code> across lines.

The manual also says that “Implicitly continued lines can carry comments” and “Blank continuation lines are allowed,” like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​f(1,  <em class="comment"># first arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​2,    <em class="comment"># second arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      <em class="comment"># blank line with a comment</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​3)    <em class="comment"># third arg</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17A61">
我们还可以使用反斜杠明确地将物理行合并为一个逻辑行。
</p><p>
We can also explicitly join physical lines into one logical line using a backslash.
</p>
<blockquote>
<p id="f_0073.html.N17A65">
可以使用反斜杠字符 (\) 将两个或多个物理行连接成逻辑行，如下所示：当物理行以不是字符串文字或注释一部分的反斜杠结尾时，它将与后续行连接起来，形成单个逻辑行，删除反斜杠和后续的行尾字符。
</p>
</blockquote><blockquote>
<p>
Two or more physical lines may be joined into logical lines using backslash characters (\), as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it is joined with the following, forming a single logical line, deleting the backslash and the following end-of-line character.
</p>
</blockquote>
<p id="f_0073.html.N17A68">
这意味着我们甚至可以在分组符号之外分割线，如下所示：
</p><p>
That means we can split lines even outside of grouping symbols like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​1+\​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​2​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17A7A"><code class="cf ic">\</code>手册中没有明确说明，但“行以反斜杠结尾”条款暗示和换行符

之间不能有注释。</p><p>
The manual does not explicitly say so, but the “line ends in a backslash” clause implies that there can’t be a comment between the <code class="cf ic">\</code> and the newline character.
</p>
<p id="f_0073.html.N17A80">
结果是，解析器或词法分析器需要丢弃一些换行符，但不需要丢弃其他换行符。正如我们之前在标记通道中看到的那样，让解析器一直检查可选空格并不是一个好的解决方案。这意味着 Python 词法分析器需要处理可选的换行符。这是语法上下文决定词法分析器行为的另一种情况。
</p><p>
The upshot is that either the parser or the lexer needs to toss out some newlines but not
others. As we saw earlier with token channels, having the parser check all the time for
optional whitespace isn’t a good solution. That means that a Python lexer needs to handle
the optional newlines. This then is another case of syntactic context dictating lexer
behavior.
</p>
<p id="f_0073.html.N17A83">
记住所有这些规则后，让我们为一个匹配赋值和简单表达式的简单版本的 Python 构建一个语法。我们将忽略字符串，以便只关注正确的注释和换行符处理。以下是语法规则：
</p><p>
With all of these rules in mind, let’s build a grammar for a trivial version of Python that
matches assignments and simple expressions. We’ll ignore strings in order to focus solely on
proper comments and newline handling. Here are the syntax rules:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file:   stat+ <strong class="prompt">EOF</strong> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   assign NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   NEWLINE         <em class="comment">// ignore blank lines</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​assign: ID <em class="string">'='</em> expr ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr <em class="string">'+'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'('</em> expr <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   call​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   list​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​call:   ID <em class="string">'('</em> ( expr (<em class="string">','</em> expr)* )? <em class="string">')'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​list:   <em class="string">'['</em> expr (<em class="string">','</em> expr)* <em class="string">']'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17AE9">
要构建词法分析器，我们首先要了解熟悉的规则。
<code class="cf keyword">INT</code>整数的规则是通常的规则，根据参考，标识符如下所示：
</p><p>
To build the lexer, let’s get the familiar rules out of the way first. The
<code class="cf keyword">INT</code> rule for integers is the usual one, and, according to the reference,
identifiers look like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​identifier ::=  (letter|<em class="string">"_"</em>) (letter | digit | <em class="string">"_"</em>)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​letter     ::=  lowercase | uppercase​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17B04">
用 ANTLR 符号表示如下：
</p><p>
In ANTLR notation, that’s as follows:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-zA-Z_] [a-zA-Z_0-9]* ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17B14">
然后，我们需要通常的空格规则和匹配换行符的规则，将
<code class="cf keyword">NEWLINE</code>标记发送到解析器。
</p><p>
Then, we need the usual whitespace rule and a rule to match newlines, which sends
<code class="cf keyword">NEWLINE</code> tokens to the parser.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** A logical newline that ends a statement */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'\r'</em>? <em class="string">'\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Warning: doesn't handle INDENT/DEDENT Python rules */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t]+ -&gt; skip​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17B42">
为了处理 Python 的行注释，我们需要一条删除注释部分但不触及换行符的规则。
</p><p>
To  handle Python’s line comments, we need a rule that strips out the comment part but doesn’t touch the newline.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match comments. Don't match \n here; we'll send NEWLINE to the parser. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :    <em class="string">'#'</em> ~[\r\n]* -&gt; skip​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17B5F">
我们希望<code class="cf keyword">NEWLINE</code>处理所有换行符，以便执行以下操作：
</p><p>
We want <code class="cf keyword">NEWLINE</code> to handle all newlines so that the following:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​i = 3 <em class="comment"># assignment</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17B73">
看起来像是一个赋值操作，后面跟着<code class="cf keyword">NEWLINE</code>。
</p><p>
looks like an assignment followed by <code class="cf keyword">NEWLINE</code>.
</p>
<p id="f_0073.html.N17B79">
现在该处理特殊的换行符了。让我们从显式换行开始。我们添加一条规则，匹配<code class="cf ic">\</code>紧接着的换行符，并将其丢弃。
</p><p>
Now it’s time to handle the special newline stuff. Let’s start with explicit line
joining. We add a rule to match <code class="cf ic">\</code> immediately followed by a newline, tossing it
out.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Ignore backslash newline sequences. This disallows comments</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  after the backslash because newline must occur next.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LINE_ESCAPE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'\\'</em> <em class="string">'\r'</em>? <em class="string">'\n'</em> -&gt; skip​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17BA7">
这意味着解析器将看不到<code class="cf ic">\</code>或换行符。
</p><p>
That means the parser won’t see either the <code class="cf ic">\</code> or the newline character(s).
</p>
<p id="f_0073.html.N17BAD">
现在我们必须让词法分析器忽略括号和方括号等分组符号内的换行符。这意味着我们需要一个词法分析器规则，<code class="cf keyword">IGNORE_NEWLINE</code>该规则匹配换行符，<code class="cf keyword">NEWLINE</code>但如果标记在分组符号内，则跳过该标记。由于这两个规则匹配相同的字符序列，因此它们是模棱两可的，我们需要一个语义谓词来区分它们。如果我们暂时想象当词法分析器看到一个开放的分组符号但没有看到结束符号时，有一个大于零的魔法变量，我们可以这样
<code class="cf keyword">nesting</code>写
：<code class="cf keyword">IGNORE_NEWLINE</code></p><p>
Now we have to make the lexer ignore newlines inside grouping symbols like parentheses and
brackets. That means we need a lexer rule called <code class="cf keyword">IGNORE_NEWLINE</code> that
matches newlines like <code class="cf keyword">NEWLINE</code> but skips the token if it’s within grouping
symbols. Because those two rules match the same character sequence, they’re ambiguous, and we
need a semantic predicate to differentiate them. If we imagine for the moment that there’s a
magic <code class="cf keyword">nesting</code> variable that is greater than zero when the lexer has seen
an open grouping symbol but not the closing symbol, we can write
<code class="cf keyword">IGNORE_NEWLINE</code> like this:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Nested newline within a (..) or [..] are ignored. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​IGNORE_NEWLINE​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'\r'</em>? <em class="string">'\n'</em> {nesting&gt;0}? -&gt; skip​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17BE5">
该规则必须出现在规则之前<code class="cf keyword">NEWLINE</code>，以便当谓词为真时，词法分析器通过选择规则来解决歧义<code class="cf keyword">IGNORE_NEWLINE</code>。我们还可以放入<code class="cf ic">{nesting==0}?</code>谓词<code class="cf keyword">NEWLINE</code>来解决顺序依赖性。
</p><p>
That rule must appear before rule <code class="cf keyword">NEWLINE</code> so that when the predicate is
true, the lexer resolves the ambiguity by choosing rule <code class="cf keyword">IGNORE_NEWLINE</code>.
We could also put a <code class="cf ic">{nesting==0}?</code> predicate in <code class="cf keyword">NEWLINE</code> to
resolve the order dependency.
</p>
<p id="f_0073.html.N17BF4">
现在让我们根据开括号和闭括号的情况适当地摆动这个变量。（我们的语法不允许使用花括号。）首先，让我们定义魔法
<code class="cf variable">nesting</code>变量。
</p><p>
Now let’s wiggle this variable appropriately as we see opening and closing parentheses and
brackets. (Our syntax does not allow curly braces.) First, let’s define the magic
<code class="cf variable">nesting</code> variable.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::members {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    int nesting = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17C0F">
然后，我们需要执行<code class="cf variable">nesting</code>看到分组符号时上下移动的操作。以下规则可以解决问题：
</p><p>
Then, we need to execute actions that bump <code class="cf variable">nesting</code> up and down as we
see the grouping symbols. The following rules do the trick:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/SimplePy.g4">lexmagic/SimplePy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LPAREN    : <em class="string">'('</em> {nesting++;} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RPAREN    : <em class="string">')'</em> {nesting--;} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​LBRACK    : <em class="string">'['</em> {nesting++;} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​RBRACK    : <em class="string">']'</em> {nesting--;} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17C3D">
为了严格正确，我们应该对圆括号和方括号使用不同的变量，以确保它们平衡。但我们实际上不必担心不平衡，<code class="cf ic">[1,2)</code>因为解析器会检测到错误。在存在这样的语法错误的情况下，忽略换行符的任何不精确行为都无关紧要。
</p><p>
To be strictly correct, we should use a different variable for parentheses and for brackets
so that we can make sure they balance. But we don’t really have to worry about imbalances
like <code class="cf ic">[1,2)</code> because the parser will detect an error. Any inexact behavior with
ignored newlines is not important in the presence of such a syntax error.
</p>
<p id="f_0073.html.N17C43">
为了测试我们的<code class="cf class">SimplePy</code>语法，以下测试文件练习了 Python 换行符和注释处理的关键元素：忽略空格、忽略分组符号内的换行符、反斜杠隐藏下一个换行符、注释不影响分组符号内的换行符处理。
</p><p>
To test our <code class="cf class">SimplePy</code> grammar, the following test file exercises the key
elements of Python newline and comment processing: blanks are ignored, newlines are ignored
within grouping symbols, backslashes hide the next newline, and comments don’t affect newline
processing inside grouping symbols.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/f.py">lexmagic/f.py</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"># a test</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​f(1, <em class="comment"># first arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  2, <em class="comment"># second arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     <em class="comment"># blank line with a comment</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  3) <em class="comment"># third arg</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​g() <em class="comment"># on end</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​1+\​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​2+\​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​3​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17C83">
以下是构建和测试序列，显示了发送到解析器的带有突出显示的标记的标记流<code class="cf keyword">NEWLINE</code>：
</p><p>
Here’s the build and test sequence showing the token stream sent to the parser with
highlighted <code class="cf keyword">NEWLINE</code> tokens:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 SimplePy.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac SimplePy*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun SimplePy file -tokens f.py</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,8:8='\n',&lt;11&gt;,1:8]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,9:9='f',&lt;4&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,10:10='(',&lt;6&gt;,2:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,11:11='1',&lt;5&gt;,2:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,12:12=',',&lt;1&gt;,2:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,29:29='2',&lt;5&gt;,4:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,30:30=',',&lt;1&gt;,4:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,80:80='3',&lt;5&gt;,6:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,81:81=')',&lt;7&gt;,6:3]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,94:94='\n',&lt;11&gt;,6:16]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,95:95='\n',&lt;11&gt;,7:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,96:96='g',&lt;4&gt;,8:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@12,97:97='(',&lt;6&gt;,8:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@13,98:98=')',&lt;7&gt;,8:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@14,108:108='\n',&lt;11&gt;,8:12]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@15,109:109='\n',&lt;11&gt;,9:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@16,110:110='1',&lt;5&gt;,10:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@17,111:111='+',&lt;2&gt;,10:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@18,114:114='2',&lt;5&gt;,11:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@19,115:115='+',&lt;2&gt;,11:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@20,118:118='3',&lt;5&gt;,12:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@21,119:119='\n',&lt;11&gt;,12:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@22,120:119='&lt;EOF&gt;',&lt;-1&gt;,13:2]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0073.html.N17CE9">
需要注意的关键一点是，<code class="cf keyword">NEWLINE</code>流中有六个标记，但文件中有十二个换行符<code class="cf filename">f.py</code>。我们的词法分析器成功剔除了六个换行符。带有突出显示的换行符的解析树如图 11<a href="#f_0073.html.fig.lexmagic.f.py"><em>所示</em></a>。
<a href="#f_0073.html.fig.lexmagic.f.py"><em></em></a></p><p>
The key thing to notice is that there are six <code class="cf keyword">NEWLINE</code> tokens in the stream
but twelve newlines in file <code class="cf filename">f.py</code>. Our lexer successfully chucks out six
  newlines. The parse tree with highlighted newline tokens looks like Figure 11, <a href="#f_0073.html.fig.lexmagic.f.py">​<em>Parse tree with highlighted newline tokens</em>​</a>.
</p>
<div class="figure" id="f_0073.html.fig.lexmagic.f.py">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/lexmagic/f.py.png">
</div>
<div class="figurecaption">
<hr>图 11. 突出显示换行符的解析树</div>
</div>
<p id="f_0073.html.N17D01">
第一个换行符是空白行，
<code class="cf keyword">stat</code>解析器将其匹配为空语句（规则）。第三和第五个换行符也是空语句。其他三个换行符终止表达式语句。运行<code class="cf filename">f.py</code>Python 解释器（带有合适的<code class="cf methodname">f</code>
和<code class="cf methodname">g</code>定义）确认这<code class="cf filename">f.py</code>是有效的 Python。
</p><p>
The first newline is a blank line and matched as an empty statement (rule
<code class="cf keyword">stat</code>) by the parser. The third and fifth newlines are also empty statements. The three other newlines terminate expression statements.
Running <code class="cf filename">f.py</code> into a Python interpreter (with suitable <code class="cf methodname">f</code>
and <code class="cf methodname">g</code> definitions) confirms that <code class="cf filename">f.py</code> is valid Python.
</p>
<p id="f_0073.html.N17D1F">
我们刚刚解决了与标记相关的三种上下文敏感性问题。我们考虑的上下文是由语法而不是输入文件的区域定义的。接下来，我们将研究具有孤立感兴趣区域并被我们不关心的区域包围的输入文件。
</p><p>
We’ve just worked through three kinds of context-sensitivity problems associated with tokens.
The contexts we considered were defined by the syntax, not a region of the input
file. Next, we’re going to look at input files that have isolated regions of interest
surrounded by regions we don’t care about.
</p>

</div></div>
<div id="f_0074.html"><div>

<h2 id="f_0074.html.sec.islands">12.3 海流中的岛屿</h2><h2>12.3 Islands in the Stream</h2>
<p id="f_0074.html.N17D2A">
到目前为止，我们讨论过的输入文件都包含一种语言。例如，DOT、CSV、Python 和 Java 文件只包含符合这些语言的文本。但是，有些文件格式包含围绕结构化区域或
<span class="firstuseinline">岛屿的</span>随机文本。我们将此类格式称为<span class="firstuseinline">岛屿语言，并使用</span><span class="firstuseinline">岛屿语法</span>来描述它们。示例包括模板引擎语言（如 StringTemplate）和 LaTeX 文档准备语言，但 XML 是典型的岛屿语言。XML 文件包含结构化标签和<code class="cf ic">&amp;</code>实体，周围是大量我们不关心的内容。（由于标签本身之间存在某种结构，因此我们可以将 XML 称为<span class="firstuseinline">群岛语言</span>。）
</p><p>
The input files we’ve discussed so far all contain a single language. For example, DOT, CSV,
Python, and Java files contain nothing but text conforming to those languages. But, there are
file formats that contain random text surrounding structured regions or
<span class="firstuseinline">islands</span>. We call such formats <span class="firstuseinline">island languages</span> and
describe them with <span class="firstuseinline">island grammars</span>. Examples include template engine
languages such as StringTemplate and the LaTeX document preparation language, but XML is the
quintessential island language. XML files contain structured tags and <code class="cf ic">&amp;</code> entities
surrounded by a sea of stuff we don’t care about. (Because there is some structure between
the tags themselves, we might call XML an <span class="firstuseinline">archipelago language</span>.)
</p>
<p id="f_0074.html.N17D46">
将某种语言归类为孤岛语言通常取决于我们的观点。如果我们要构建 C 预处理器，预处理器命令将形成一种孤岛语言，其中 C 代码是海洋。另一方面，如果我们要构建适用于 IDE 的 C 解析器，解析器必须忽略预处理器命令的海洋。
</p><p>
Classifying something as an island language often depends on our perspective. If we’re
building a C preprocessor, the preprocessor commands form an island language where the C code
is the sea. On the other hand, if we’re building a C parser suitable for an IDE, the parser
must ignore the sea of preprocessor commands.
</p>
<p id="f_0074.html.N17D49">
本节的目标是学习如何忽略海洋并标记岛屿，以便解析器可以验证这些岛屿内的语法。在下一节中，我们将需要这两种技术来构建真正的 XML 解析器。让我们首先学习如何区分 XML 岛屿和海洋。
</p><p>
Our goal in this section is to learn how to ignore the sea and tokenize the islands so the
parser can verify syntax within those islands. We’ll need both of those techniques to build
a real XML parser in the next section. Let’s start by learning how to distinguish XML
islands from the sea.
</p>
<h3>将 XML 孤岛与文本海洋分离</h3><h3>Separating XML Islands from a Sea of Text</h3>
<p id="f_0074.html.N17D50">
要将 XML 标签与文本分开，我们首先想到的可能是构建一个输入字符流过滤器，以删除标签之间的所有内容。这可能使词法分析器能够轻松识别孤岛，但过滤器会丢弃所有文本数据，这不是我们想要的。例如，给定输入<code class="cf ic">&lt;name&gt;John&lt;/name&gt;</code>，我们不想丢弃
<code class="cf ic">John</code>。
</p><p>
To separate XML tags from text, our first thought might be to build an input character stream
filter that strips everything between tags. This might make it easy for the lexer to identify
the islands, but the filter would throw out all of the text data, which is not what we want.
For example, given input <code class="cf ic">&lt;name&gt;John&lt;/name&gt;</code>, we don’t want to throw out
<code class="cf ic">John</code>.
</p>
<p id="f_0074.html.N17D5A">
相反，让我们构建一个小型 XML 语法，将标签内的文本集中在一起作为一个标记，将标签外的文本集中在一起作为另一个标记。由于我们在这里关注的是词法分析器，我们将使用一个匹配一堆标签、<code class="cf ic">&amp;</code>实体、
<code class="cf keyword">CDATA</code>部分和文本（海洋）的语法规则。
</p><p>
Instead, let’s build a baby XML grammar that lumps the text inside of tags together as one
token and the text outside of tags as another token. Since we’re focusing on the lexer here,
we’ll use a single syntactic rule that matches a bunch of tags, <code class="cf ic">&amp;</code> entities,
<code class="cf keyword">CDATA</code> sections, and text (the sea).
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/Tags.g4">lexmagic/标签.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Tags;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : (TAG|ENTITY|TEXT|CDATA)* ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17D75">
规则<code class="cf keyword">file</code>并不试图确保文档格式正确 — — 它仅指示在 XML 文件中找到的标记类型。
</p><p>
Rule <code class="cf keyword">file</code> makes no attempt to ensure the document is well formed—it
just indicates the kinds of tokens found in an XML file.
</p>
<p id="f_0074.html.N17D7B">
要使用词法分析器规则拆分 XML 文件，我们可以只给出岛屿的规则，然后<code class="cf keyword">TEXT</code>在最后调用一个捕获所有规则来匹配其他所有内容。
</p><p>
To split up an XML file with lexer rules, we can just give rules for the islands and then a
catchall rule called <code class="cf keyword">TEXT</code> at the end to match everything else.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/Tags.g4">lexmagic/标签.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT : <em class="string">'&lt;!--'</em> .*? <em class="string">'--&gt;'</em> -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CDATA : <em class="string">'&lt;![CDATA['</em> .*? <em class="string">']]&gt;'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TAG : <em class="string">'&lt;'</em> .*? <em class="string">'&gt;'</em> ; <em class="comment">// must come after other tag-like structures</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENTITY : <em class="string">'&amp;'</em> .*? <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT : ~[&lt;&amp;]+ ;     <em class="comment">// any sequence of chars except &lt; and &amp; chars</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17DB6">
这些规则大量使用非贪婪<code class="cf ic">.*?</code>运算符（参见<a href="#f_0037.html.sec.string_literals">匹配<em>字符串文字</em>）</a> ，该运算符会一直扫描直到看到规则中该操作后面的内容。 
</p><p>
Those rules make heavy use of the nongreedy <code class="cf ic">.*?</code> operator (see <a href="#f_0037.html.sec.string_literals">​<em>Matching String Literals</em>​</a>) that scans until it sees what follows that operation in the
rule. 
</p>
<p id="f_0074.html.N17DBF">
规则<code class="cf keyword">TEXT</code>匹配一个或多个字符，只要该字符不是标签或实体的开头。很想用 代替<code class="cf ic">.+</code>，
但一旦进入循环，就会消耗到输入结束为止。后面<code class="cf ic">~[&lt;&amp;]+</code>没有要匹配的字符串来告诉循环何时停止。
<code class="cf ic">.+</code><code class="cf keyword">TEXT</code></p><p>
Rule <code class="cf keyword">TEXT</code> matches one or more characters, as long as the character isn’t
the start of a tag or entity. It’s tempting to put <code class="cf ic">.+</code> instead of
<code class="cf ic">~[&lt;&amp;]+</code>, but that would consume until the end of the input once it got into
the loop. There’s no string to match following <code class="cf ic">.+</code> in <code class="cf keyword">TEXT</code> that
would tell the loop when to stop.
</p>
<p id="f_0074.html.N17DD1">
这里有一个重要但微妙的歧义解决机制。在第 2.3 节“<a href="#f_0017.html.sec.ambiguity"><em>核反应堆中水</em></a><a href="#f_0017.html.sec.ambiguity">不能中，<em></em></a>我们了解到 ANTLR 词法分析器会根据语法文件中首先指定的规则来解决歧义。例如，规则<code class="cf keyword">TAG</code>会匹配尖括号中的任何内容，包括注释和<code class="cf keyword">CDATA</code>部分。因为我们首先指定了<code class="cf keyword">COMMENT</code>和<code class="cf keyword">CDATA</code>，所以规则
<code class="cf keyword">TAG</code>仅匹配那些无法匹配其他标签规则的标签。
</p><p>
An important but subtle ambiguity-resolving mechanism is in play here. In Section 2.3, <a href="#f_0017.html.sec.ambiguity">​<em>You Can’t Put Too Much Water into a Nuclear Reactor</em>​</a>, we learned that ANTLR lexers resolve ambiguities in favor of the
rule specified first in the grammar file. For example, rule <code class="cf keyword">TAG</code> matches
anything in angle brackets, which includes comments and <code class="cf keyword">CDATA</code> sections.
Because we specified <code class="cf keyword">COMMENT</code> and <code class="cf keyword">CDATA</code> first, rule
<code class="cf keyword">TAG</code> matches only those tags that failed to match the other tag rules.
</p>
<p id="f_0074.html.N17DE6">
附注：从技术上讲，XML 不允许以 结尾的注释<code class="cf ic">—&gt;</code>或包含 的注释<code class="cf ic">--</code>。利用我们在第 9.4 节“<a href="#f_0061.html.sec.error-alts">错误<em>替代方案”</em>中学到的知识，</a>我们可以添加词汇规则来查找错误注释并提供具体且有用的错误消息。
</p><p>
As a side note, XML technically doesn’t allow comments that end with <code class="cf ic">—&gt;</code> or
comments that contain <code class="cf ic">--</code>. Using what we learned in Section 9.4, <a href="#f_0061.html.sec.error-alts">​<em>Error Alternatives</em>​</a>,
we could add lexical rules to look for bad comments and give specific and informative error
messages.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​BAD_COMMENT1:   <em class="string">'&lt;!--'</em> .*? <em class="string">'---&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                {System.err.println(<em class="string">"Can't have ---&gt; end comment"</em>);} -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​BAD_COMMENT2:   <em class="string">'&lt;!--'</em> (<em class="string">'--'</em>|.)*? <em class="string">'--&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                {System.err.println(<em class="string">"Can't have -- in comment"</em>);}    -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17E1A">
为了简单起见，我在语法中省略了它们<code class="cf class">Tags</code>。 
</p><p>
I’ve left them out of grammar <code class="cf class">Tags</code> for simplicity. 
</p>
<p id="f_0074.html.N17E20">
现在让我们看看我们的婴儿 XML 语法对以下输入做了什么：
</p><p>
Now let’s see what our baby XML grammar does with the following input:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XML-inputs/cat.xml">lexmagic/XML 输入/cat.xml</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;?xml version="1.0" encoding="UTF-8"?&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">&lt;?do not care?&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;CATALOG&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;PLANT</strong> id=<em class="string">"45"</em>
<strong class="prompt">&gt;</strong>Orchid<strong class="prompt">&lt;/PLANT&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/CATALOG&gt;</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17E48">
以下是构建和测试序列，用于<code class="cf commandname">grun</code>打印出令牌：
</p><p>
Here’s the build and test sequence, using <code class="cf commandname">grun</code> to print out the tokens:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Tags.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Tags*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun Tags file -tokens XML-inputs/cat.xml</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:37='&lt;?xml version="1.0" encoding="UTF-8"?&gt;',&lt;3&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,38:38='\n',&lt;5&gt;,1:38]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,39:53='&lt;?do not care?&gt;',&lt;3&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,54:54='\n',&lt;5&gt;,2:15]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,55:63='&lt;CATALOG&gt;',&lt;3&gt;,3:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,64:64='\n',&lt;5&gt;,3:9]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,65:79='&lt;PLANT id="45"&gt;',&lt;3&gt;,4:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,80:85='Orchid',&lt;5&gt;,4:15]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,86:93='&lt;/PLANT&gt;',&lt;3&gt;,4:21]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,94:94='\n',&lt;5&gt;,4:29]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,95:104='&lt;/CATALOG&gt;',&lt;3&gt;,5:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@11,105:105='\n',&lt;5&gt;,5:10]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@12,106:105='&lt;EOF&gt;',&lt;-1&gt;,6:11]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17E90">
这个小 XML 语法可以正确读取 XML 文件并匹配各种岛和文本的序列。它不会将标签拆分并将这些部分传递给解析器以检查语法。
</p><p>
This baby XML grammar properly reads in XML files and matches a sequence of the various
islands and text. What it doesn’t do is pull apart the tags and pass the pieces to a parser
so it can check the syntax.
</p>
<h3 id="f_0074.html.sec.modes-for-tags">使用词汇模式发布上下文相关标记</h3><h3>Issuing Context-Sensitive Tokens with Lexical Modes</h3>
<p id="f_0074.html.N17E98">
标签内外的文本符合不同的语言。例如，
<code class="cf ic">id="45"</code>只是标签外的一块文本，但标签内有三个标记。从某种意义上说，我们希望 XML 词法分析器根据上下文匹配不同的规则集。ANTLR 提供了<span class="firstuseinline">词汇模式</span>，让词法分析器可以在上下文（模式）之间切换。在本节中，我们将学习如何使用词汇模式，方法是改进上一节中的初级 XML 语法，以便它将标签组件传递给解析器。
</p><p>
The text inside and outside of tags conform to different languages. For example,
<code class="cf ic">id="45"</code> is just a lump of text outside of a tag, but it’s three tokens inside of a
tag. In a sense, we want an XML lexer to match different sets of rules depending on the
context. ANTLR provides <span class="firstuseinline">lexical modes</span> that let lexers switch between
contexts (modes). In this section, we’ll learn to use lexical modes by improving the baby
XML grammar from the previous section so that it passes tag components to the parser.
</p>
<p id="f_0074.html.N17EA5">
词汇模式允许我们将单个词法分析器语法拆分为多个子词法分析器。词法分析器可以仅返回与当前模式中输入规则相匹配的标记。模式切换最重要的要求之一是语言具有明确的词汇标记，可以触发来回切换，例如左尖括号和右尖括号。明确地说，模式依赖于这样一个事实：词法分析器不需要句法上下文来区分输入中的不同区域。
</p><p>
Lexical modes allow us to split a single lexer grammar into multiple sublexers. The lexer can
 return only those tokens matched by entering a rule in the current mode. One of the most important
requirements for mode switching is that the language have clear lexical sentinels that can
trigger switching back and forth, such as left and right angle brackets. To be clear, modes
rely on the fact that the lexer doesn’t need syntactic context to distinguish between
different regions in the input.
</p>
<p id="f_0074.html.N17EA8">
为简单起见，让我们为 XML 子集构建一个语法，其中标签包含标识符但不包含属性。我们将使用默认模式匹配标签外部的海，并使用另一种模式匹配标签内部的海。当词法分析器<code class="cf ic">&lt;</code>在默认模式下匹配时，它应该切换到岛屿模式（标签内部模式）并向解析器返回标签起始标记。当内部模式看到时<code class="cf ic">&gt;</code>，它应该切换回默认模式并返回标签终止标记。内部模式还需要规则来匹配标识符和
<code class="cf ic">/</code>。以下词法分析器对该策略进行编码：
</p><p>
To keep things simple, let’s build a grammar for an XML subset where tags contain an
identifier but no attributes. We’ll use the default mode to match the sea outside of tags and
another mode to match the inside of tags. When the lexer matches <code class="cf ic">&lt;</code> in default
mode, it should switch to island mode (inside tag mode) and return a tag start token to the
parser. When the inside mode sees <code class="cf ic">&gt;</code>, it should switch back to default mode and
return a tag stop token. The inside mode also needs rules to match identifiers and
<code class="cf ic">/</code>. The following lexer encodes that strategy:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/ModeTagsLexer.g4">lexmagic/ModeTagsLexer.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> ModeTagsLexer;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// Default mode rules (the SEA)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​OPEN  : <em class="string">'&lt;'</em>     -&gt; mode(ISLAND) ;       <em class="comment">// switch to ISLAND mode</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT  : ~<em class="string">'&lt;'</em>+ ;                         <em class="comment">// clump all text together</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode ISLAND;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CLOSE : <em class="string">'&gt;'</em>     -&gt; mode(DEFAULT_MODE) ; <em class="comment">// back to SEA mode</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SLASH : <em class="string">'/'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID    : [a-zA-Z]+ ;                     <em class="comment">// match/send ID in tag to parser</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17EF4">
规则<code class="cf keyword">OPEN</code>和<code class="cf keyword">TEXT</code>处于默认模式。
<code class="cf keyword">OPEN</code>匹配单个<code class="cf ic">&lt;</code>并使用词法命令
<code class="cf ic">mode(ISLAND)</code>切换模式。在解析器的下一个标记请求中，词法分析器将仅考虑<code class="cf variable">ISLAND</code>模式下的规则。<code class="cf keyword">TEXT</code>匹配任何不以标记开头的字符序列。由于此语法中的任何词汇规则均不使用词汇命令<code class="cf keyword">skip</code>，因此当它们匹配时，它们都会向解析器返回一个标记。
</p><p>
Rules <code class="cf keyword">OPEN</code> and <code class="cf keyword">TEXT</code> are in the default mode.
<code class="cf keyword">OPEN</code> matches a single <code class="cf ic">&lt;</code> and uses lexer command
<code class="cf ic">mode(ISLAND)</code> to switch modes. Upon the next token request from the parser, the lexer
will consider only those rules in <code class="cf variable">ISLAND</code> mode. <code class="cf keyword">TEXT</code> matches
any sequence of characters that doesn’t start a tag. Because none of the lexical rules in
this grammar uses lexical command <code class="cf keyword">skip</code>, all of them return a token to the
parser when they match.
</p>
<p id="f_0074.html.N17F14">
在<code class="cf variable">ISLAND</code>模式下，词法分析器匹配结束的<code class="cf ic">&gt;</code>、<code class="cf ic">/</code>和
<code class="cf keyword">ID</code>标记。当词法分析器看到 时<code class="cf ic">&gt;</code>，它将执行 lexer 命令以切换回默认模式，该模式由
<code class="cf variable">DEFAULT_MODE</code>类 中的常量标识<code class="cf class">Lexer</code>。这就是词法分析器在模式之间来回切换的方式。
</p><p>
In <code class="cf variable">ISLAND</code> mode, the lexer matches closing <code class="cf ic">&gt;</code>, <code class="cf ic">/</code>, and
<code class="cf keyword">ID</code> tokens. When the lexer sees <code class="cf ic">&gt;</code>, it will execute the lexer
command to switch back to the default mode, identified by constant
<code class="cf variable">DEFAULT_MODE</code> in class <code class="cf class">Lexer</code>. This is how the lexer
ping-pongs back and forth between modes.
</p>
<p id="f_0074.html.N17F2F">
我们的稍微扩充的 XML 子集的解析器像语法中一样匹配标签和文本块
<code class="cf class">Tags</code>，但现在我们使用规则<code class="cf keyword">tag</code>来匹配各个标签元素，而不是单个集中的标记。
</p><p>
The parser for our slightly augmented XML subset matches tags and text chunks as in grammar
<code class="cf class">Tags</code>, but now we’re using rule <code class="cf keyword">tag</code> to match the individual
tag elements instead of a single lumped token.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/ModeTagsParser.g4">lexmagic/ModeTagsParser.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">parser</strong> <strong class="prompt">grammar</strong> ModeTagsParser;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> { tokenVocab=ModeTagsLexer; } <em class="comment">// use tokens from ModeTagsLexer.g4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file: (tag | TEXT)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tag : <em class="string">'&lt;'</em> ID <em class="string">'&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'&lt;'</em> <em class="string">'/'</em> ID <em class="string">'&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17F70">
解析器中唯一不熟悉的语法是<code class="cf keyword">tokenVocab</code>选项。当我们将解析器和词法分析器放在不同的文件中时，我们需要确保两个文件中的标记类型和标记名称是同步的。例如，词法分析器标记
<code class="cf keyword">OPEN</code>在解析器中的标记类型必须与在词法分析器中的标记类型相同。
</p><p>
The only unfamiliar syntax in the parser is the <code class="cf keyword">tokenVocab</code> option. When we
have the parser and lexer in separate files, we need to make sure that the token types and
token names from the two files are synchronized. For example, lexer token
<code class="cf keyword">OPEN</code> must have the same token type in the parser as it does in the lexer.
</p>
<p id="f_0074.html.N17F7E">
让我们构建语法并在一些简单的 XML 输入上尝试它。
</p><p>
Let’s build the grammar and try it on some simple XML input.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 ModeTagsLexer.g4   # must be done first to get ModeTagsLexer.tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 ModeTagsParser.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac ModeTags*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun ModeTags file -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">Hello &lt;name&gt;John&lt;/name&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:5='Hello ',&lt;2&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,6:6='&lt;',&lt;1&gt;,1:6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@2,7:10='name',&lt;5&gt;,1:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@3,11:11='&gt;',&lt;3&gt;,1:11]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@4,12:15='John',&lt;2&gt;,1:12]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@5,16:16='&lt;',&lt;1&gt;,1:16]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@6,17:17='/',&lt;4&gt;,1:17]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@7,18:21='name',&lt;5&gt;,1:18]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@8,22:22='&gt;',&lt;3&gt;,1:22]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@9,23:23='\n',&lt;2&gt;,1:23]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@10,24:23='&lt;EOF&gt;',&lt;-1&gt;,2:24]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0074.html.N17FC9">
词法分析器将<code class="cf ic">&lt;name&gt;</code>索引 1、2 和 3 处的三个标记发送给解析器。还要注意<code class="cf ic">Hello</code>，位于海中的 会匹配规则
<code class="cf keyword">ID</code>，但仅限于<code class="cf variable">ISLAND</code>模式。由于词法分析器以默认模式启动，因此<code class="cf ic">Hello</code>匹配为标记<code class="cf keyword">TEXT</code>。您可以看到索引 0 处的标记和索引 2 处的标记之间的标记类型差异，其中<code class="cf ic">name</code>匹配为标记<code class="cf keyword">ID</code>（标记类型 5）。
</p><p>
The lexer sends <code class="cf ic">&lt;name&gt;</code> to the parser as the three tokens at indexes 1, 2, and 3.
Also notice that <code class="cf ic">Hello</code>, which lives in the sea, would match rule
<code class="cf keyword">ID</code> but only in <code class="cf variable">ISLAND</code> mode. Since the lexer starts
out in default mode, <code class="cf ic">Hello</code> matches as token <code class="cf keyword">TEXT</code>. You can see the
difference in the token types between tokens at index 0 and 2 where <code class="cf ic">name</code> matches as
token <code class="cf keyword">ID</code> (token type 5).
</p>
<p id="f_0074.html.N17FE4">
我们之所以希望在解析器而不是词法分析器中匹配标签语法，另一个原因是解析器在执行操作方面具有更大的灵活性。此外，解析器会自动为我们构建解析树。
</p><p>
Another reason that we want to match tag syntax in the parser instead of the lexer is that
the parser has much more flexibility to execute actions. Furthermore, the parser
automatically builds a parse tree for us.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJwAAABPBAAAAAD+iR4RAAAACXBIWXMAAABIAAAASABGyWs+AAAETUlEQVRYw+2YPYwbRRTHlyZoqyVNEE0AUYTuEB0SEhSUFEBJk0RJAbnkOAnB+JzcOaLxFSQ5HYUVKcnSQCRQcgUSlgDJSEgxnVPl4gZ3uY8iu8oVvvV+PN7Mzuy+Ga/t5W5REMrINzM7783P782sb/+zFlRarKeAe9dxqsQ5UCXOtxwnsOzqonMc312rFGeV8iyNK+P31JKtcivKl2e4fxvXP/NJrzLciJ397YePlgaV4KLmpXYHGvEXtbp3aFzcqnsPXIAGQOtG89LhcMltTHETaXAT/zaXR+zmIXDdWg9ga4V3+7zaqUOf3T0grs82sN6+Ki6Gog7ZAP5kvQPgdtO8hitAcJA0OwDt2uAf4iL2tWiDZTkwUiG1MdqkNWmTC3Fxsy4h57Oxhuo85NsbNS+WxeF2yu8OyZwMB4Ewh+xKKVy7pvKKzpHhqyR4JtZup2CTTdxD1slmLVFDn8bfck3nQtwuu5XPYZppqF11r5ipjONCuZ0pbdWbgoPti+ZCGzh9sxKm0/I7RX13TTrEdJ7CmbdSa2CsSnLNGIizhSNZKdy+Pj0yaQC9sZE7WW+3Y+AqKhZqLS4Y/KmqgRudidbgs6k4vwyOXCbHdRwqBsStWa4csy07sC5THNrso679qpuNWEHu9Km//pLCWZaFegZxdiC/0efX7iLFoe3IaO7IzlweHXH6yV9YJ9GheENcJln9mC36Wso+2tJPjiNOT+4r7xQn1i7HPWHf+nCfrFwRjjgNF3WcmeytyzRZv7OONhNHnOIXNJyxFXv2c1/a1qls5uiVt9Fm4N4IiNMHOa64+O7nMLOMO03CBdb7s3HjTv8HQXZY3Hcrs6eG77klcVu/bm3MpJ3tPhjjFeKClRDa3nRaXFsY9VD4zcbF8xBCUptOW3rk4aP8585s3Cpmgp8LU2gJe7yQasjBLNxmT+Bg/9pk2qrXxcX4BUzeOE5QOA66g0m45iDCyMSzN1EPyGJcJERTmM6aQMOIuiBxKPm8KbgUERL0WPm+B6FYiGiD11TLmDiZYEgSNwu/O66n3QYYPAOn5kuc2Baj3MOQAjftS5UWzhfjQqVdFY7fNHoRxwIZXKbSMl2p4fJbN8PF8waN5zdUMWeyKrhQgGsPxnCwr/0zSI8F2eEnVzZSk1Mc+dmHZLRD+oKdBUdlVXpiILiQxEFwcNvTQ0iWc1vDCDzHJXUoxiVqneUCPfJyGz2ibTU0nEcRdMFi2UZp85iYaB/++k88Kz6uFJe8XAq38w6vUcOhgnje/tBV74n21Fkj+UY0+w2sUNFxO/V7y6O4e8d6vEENh/rG/v3HOfUWKzp9Xmv3uB8qOm6nfhyQ4fZe90SLsmaT8Rds+Su75CsR95vyB/8Hr3yhAkHz236tEHeinuKyxdJxNYlDgQeaH8WpZBFnb6e4CckelzgUeED9tGTVViBu7cVT3G3CVoxOShwKPIf66VtRSXmGO3j5G5eMlw9BM9n+AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjUwLTA2OjAw7jukBAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo1MC0wNjowMJ9mHLgAAAAgdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADYxMng3OTIrMCswn519VwAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuMyBTBqy/AAAAAElFTkSuQmCC" alt="图片/lexmagic/标签.png">
</div>
<p id="f_0074.html.N17FEC">
要将我们的语法用于应用程序，我们可以使用通常的侦听器或访问者机制，也可以向语法添加操作。例如，要实现 XML SAX 事件机制，我们可以关闭自动树构建并嵌入语法操作以触发 SAX 方法调用。
</p><p>
To use our grammar for an application, we could either use the usual listener or visitor
mechanism or add actions to the grammar. For example, to implement an XML SAX event
mechanism, we could shut off the automatic tree construction and embed grammar actions to
trigger SAX method calls.
</p>
<p id="f_0074.html.N17FF5">
现在我们知道了如何将 XML 岛从海洋中分离出来以及如何将标签组件发送到解析器，让我们构建一个真正的 XML 解析器。
</p><p>
Now that we know how to separate the XML islands from the sea and how to send tag components
to a parser, let’s build a real XML parser.
</p>

</div></div>
<div id="f_0075.html"><div>

<h2 id="f_0075.html.sec.XML">12.4 解析和词法分析 XML</h2><h2>12.4 Parsing and Lexing XML</h2>
<p id="f_0075.html.N17FFF">
由于 XML 是一种定义明确的语言，因此最好先查看 W3C XML 语言定义，然后开始我们的 XML 项目。<a id="f_0075.html.FNPTR-49" href="#f_0075.html.FOOTNOTE-49">[49]</a>
不幸的是，XML 规范（以下简称为<span class="firstuseinline">规范</span>）非常庞大，我们很容易迷失在各种细节中。为了让我们的生活更轻松，让我们摆脱解析 XML 文件时不需要的东西：<code class="cf ic">&lt;!DOCTYPE..&gt;</code>文档类型定义 (DTD)、<code class="cf ic">&lt;!ENTITY..&gt;</code>实体声明和
<code class="cf ic">&lt;!NOTATION..&gt;</code>符号声明。此外，处理这些标签不会教会我们处理其他构造所需的任何东西。
</p><p>
Because XML is a well-defined language, it’s a good idea to start our XML project by
reviewing the W3C XML language
definition.<a href="#f_0075.html.FOOTNOTE-49">[49]</a>
Unfortunately, the XML specification (henceforth <span class="firstuseinline">the spec</span>) is huge,
and it’s very easy to get lost in all of the details. To make our lives easier, let’s get rid
of stuff we don’t need in order to parse XML files: <code class="cf ic">&lt;!DOCTYPE..&gt;</code> document type
definitions (DTDs), <code class="cf ic">&lt;!ENTITY..&gt;</code> entity declarations, and
<code class="cf ic">&lt;!NOTATION..&gt;</code> notation declarations. Besides, handling those tags wouldn’t teach
us anything beyond what we need to handle the other constructs.
</p>
<p id="f_0075.html.N18019">
我们将从构建 XML 的语法规则开始。好消息是，我们可以通过将规范中的非正式语法规则更改为 ANTLR 符号来几乎逐字重复使用它们。
</p><p>
We’re going to start out by building the syntactic rules for XML. The good news is that we
can reuse the informal grammar rules from the spec almost verbatim by changing them to ANTLR
notation.
</p>
<h3>XML 规范到 ANTLR 解析器语法</h3><h3>XML Spec to ANTLR Parser Grammar</h3>
<p id="f_0075.html.N18020">
根据我们在 XML 方面的经验，我们可能能够得出一个相当完整和准确的 XML 语法。但是为了确保我们不会遗漏任何内容，让我们过滤并压缩该规范以保留其关键语法规则。
</p><p>
Using our experience with XML, we could probably come up with a reasonably complete and
accurate XML grammar. To make sure we don’t forget anything, however, let’s filter and
condense the spec to its key grammatical rules.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​document     ::=  prolog element Misc*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prolog       ::=  XMLDecl? Misc*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​content      ::=  CharData?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                  ((element | Reference | CDSect | PI | Comment) CharData?)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​element      ::=  EmptyElemTag​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​             |    STag content ETag​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EmptyElemTag ::=  '&lt;' Name (S Attribute)* S? '/&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STag         ::=  '&lt;' Name (S Attribute)* S? '&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ETag         ::=  '&lt;/' Name S? '&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​XMLDecl      ::=  '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Attribute    ::=  Name Eq AttValue​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Reference    ::=  EntityRef | CharRef​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Misc         ::=  Comment | PI | S​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18058">
我们还需要很多其他规则，但它们将进入我们的词法分析器。根据我们在第 5.6 节“在<a href="#f_0038.html.sec.lexer_parser_line"><em>词法分析器和解析器之间</em></a><a href="#f_0038.html.sec.lexer_parser_line">划界<em></em></a>中的讨论，这是一个很好的例子，说明了在哪里划界<a href="#f_0038.html.sec.lexer_parser_line">。</a><code class="cf keyword">PI</code>，因此我们可以让词法分析器将它们作为块进行匹配。
</p><p>
There are lots of other rules we’ll need, but they’ll go into our lexer. This is a good
example of where to draw the line, per our discussion in Section 5.6, <a href="#f_0038.html.sec.lexer_parser_line">​<em>Drawing the Line Between Lexer and Parser</em>​</a>. The key criterion to follow is whether we need
to see inside the element’s structure. For example, we don’t care about the inside of
comments or processing instructions (<code class="cf keyword">PI</code>), so we can have the lexer match
them as lumps.
</p>
<p id="f_0075.html.N18061">
让我们将这些非正式规范规则与以下完整的 ANTLR 解析器语法进行比较。相对于我们为 JSON 和 Cymbol 等语言构建的语法，XML 解析器规则非常简单。
</p><p>
Let’s compare these informal spec rules with the following complete ANTLR parser grammar.
Relative to the grammars we’ve built for languages like JSON and Cymbol, the XML parser rules
are pretty simple.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XMLParser.g4">lexmagic/XMLParser.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">parser</strong> <strong class="prompt">grammar</strong> XMLParser;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> { tokenVocab=XMLLexer; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​document    :   prolog? misc* element misc*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prolog      :   XMLDeclOpen attribute* SPECIAL_CLOSE ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​content     :   chardata?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                ((element | reference | CDATA | PI | COMMENT) chardata?)* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​element     :   <em class="string">'&lt;'</em> Name attribute* <em class="string">'&gt;'</em> content <em class="string">'&lt;'</em> <em class="string">'/'</em> Name <em class="string">'&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'&lt;'</em> Name attribute* <em class="string">'/&gt;'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​reference   :   EntityRef | CharRef ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​attribute   :   Name <em class="string">'='</em> STRING ; <em class="comment">// Our STRING is AttValue in spec</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** ``All text that is not markup constitutes the character data of</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  the document.''</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​chardata    :   TEXT | SEA_WS ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​misc        :   COMMENT | PI | SEA_WS ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N180CE">
规范的规则和我们的规则之间存在许多重要差异。首先，规范规则<code class="cf keyword">XMLDecl</code>可以匹配三个特定属性（<code class="cf keyword">version</code>、<code class="cf keyword">encoding</code>和<code class="cf keyword">standalone</code>），而我们的规则可以匹配 内的任何一组属性<code class="cf ic">&lt;?xml ...?&gt;</code>。稍后，语义阶段必须检查属性名称是否正确。或者，我们可以将谓词放在语法中，但这会使语法难以阅读，并会降低生成的解析器的速度。
</p><p>
There are a number of important differences between the spec’s rules and ours. First, the
spec rule <code class="cf keyword">XMLDecl</code> can match three specific attributes
(<code class="cf keyword">version</code>, <code class="cf keyword">encoding</code>, and <code class="cf keyword">standalone</code>),
whereas ours matches any set of attributes inside <code class="cf ic">&lt;?xml ...?&gt;</code>. Later, a semantic
phase would have to check that the attribute names were correct. Alternatively, we could put
predicates inside the grammar, but it makes the grammar hard to read and would slow down the
generated parser.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prolog       : XMLDecl versionInfo encodingDecl? standalone? SPECIAL_CLOSE ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​versionInfo  : {_input.LT(1).getText().equals(<em class="string">"version"</em>)}? Name <em class="string">'='</em> STRING ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​encodingDecl : {_input.LT(1).getText().equals(<em class="string">"encoding"</em>)}? Name <em class="string">'='</em> STRING ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​standalone   : {_input.LT(1).getText().equals(<em class="string">"standalone"</em>)}? Name <em class="string">'='</em> STRING ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18107">
下一个区别是我们的词法分析器将匹配并丢弃属性之间标签内的空格，因此我们不需要检查
<code class="cf keyword">element</code>规则内的空格。 （是上一节<code class="cf keyword">element</code>规则的扩展版本
。）我们的词法分析器还区分标签外的空格（ ）和非空格文本（），但将两者都作为标记返回给解析器。（前两节将标签外的所有文本归为一个标记。）这是因为规范允许空格但不允许某些位置（例如根元素之前）的文本。因此，是解析器规则，而不是我们语法中的标记。
<code class="cf keyword">tag</code><code class="cf keyword">SEA_WS</code><code class="cf keyword">TEXT</code><code class="cf keyword">TEXT</code><code class="cf keyword">chardata</code></p><p>
The next difference is that our lexer will match and discard whitespace inside of tags
between the attributes, so we don’t need to check for whitespace inside of our
<code class="cf keyword">element</code> rule. (<code class="cf keyword">element</code> is an expanded version of rule
<code class="cf keyword">tag</code> from the previous section.) Our lexer also differentiates between
whitespace (<code class="cf keyword">SEA_WS</code>) and nonwhitespace text (<code class="cf keyword">TEXT</code>)
outside of tags but returns both to the parser as tokens. (The previous two sections lumped
all text outside of tags into a single <code class="cf keyword">TEXT</code> token.) That’s because the
spec allows whitespace but not text in certain locations such as before the root element.
Therefore, <code class="cf keyword">chardata</code> is a parser rule, not a token in our grammar.
</p>
<p id="f_0075.html.N1811F">
XML 解析器还不错，但是我们将通过构建词法分析器来赚取危险工作报酬。
</p><p>
The XML parser is not too bad, but we’re going to earn hazardous-duty pay building the
lexer.
</p>
<h3 id="f_0075.html.sec.tokenizing-xml">XML 标记化</h3><h3>Tokenizing XML</h3>
<p id="f_0075.html.N18127">
让我们通过从规范中提取相关规则来启动我们的 XML 词法分析器，看看我们正在处理什么。
</p><p>
Let’s start our XML lexer by extracting the relevant rules from the spec to see what
we’re dealing with.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Comment   ::=  '&lt;!--' ((Char - '-') | ('-' (Char - '-')))* '--&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CDSect    ::=  '&lt;![CDATA[' CData ']]&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CData     ::=  (Char* - (Char* ']]&gt;' Char*)) // anything but ']]&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PI        ::=  '&lt;?' PITarget (S (Char* - (Char* '?&gt;' Char*)))? '?&gt;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​/** Any name except 'xml' */​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PITarget  ::=  Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​/** Spec: ``CharData is any string of characters which does not contain the​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ *  start-delimiter of any markup and does not include the​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ *  CDATA-section-close delimiter, "]]&gt;".''​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ */​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CharData  ::=  [^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EntityRef ::=  '&amp;' Name ';'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CharRef   ::=  '&amp;#' [0-9]+ ';'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    '&amp;#x' [0-9a-fA-F]+ ';'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Name      ::=  NameStartChar (NameChar)*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameChar  ::=  NameStartChar | "-" | "." | [0-9] | #xB7​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    [#x0300-#x036F] | [#x203F-#x2040]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameStartChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          ::=  ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    [#x10000-#xEFFFF]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​AttValue  ::=  '"' ([^&lt;&amp;"] | Reference)* '"'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​          |    "'" ([^&lt;&amp;'] | Reference)* "'"​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​S         ::=  (#x20 | #x9 | #xD | #xA)+​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18180">
哎呀！这看起来有点复杂，但我们会将其分解为三种不同的模式并逐一构建它们。我们需要模式来处理外部标签、内部标签和特殊标签内部<code class="cf ic">&lt;?...?&gt;</code>，就像我们在<a href="#f_0074.html.sec.modes-for-tags"><em>使用词汇模式</em></a><a href="#f_0074.html.sec.modes-for-tags">发出<em></em></a>中所做的那样。
</p><p>
Blech! That looks kind of complicated, but we’ll break it down into three different modes
and build them one by one. We’ll need modes to handle outside tags, inside tags, and inside
of the special <code class="cf ic">&lt;?...?&gt;</code> tags, very much like we did in <a href="#f_0074.html.sec.modes-for-tags">​<em>Issuing Context-Sensitive Tokens with Lexical Modes</em>​</a>.
</p>
<p id="f_0075.html.N18189">
当您将规范规则与我们的 ANTLR 词法分析器规则进行比较时，您会发现我们可以重用大多数相同的规则名称。规范符号与 ANTLR 的符号完全不同，但我们可以重用大多数规则右侧的精神。让我们从匹配标签外部海洋的默认模式开始。这是我们的词法分析器语法的一部分：
</p><p>
When you compare the spec rules to our ANTLR lexer rules, you’ll see that we can reuse most
of the same rule names. The specs notation is quite different from ANTLR’s, but we can reuse
the spirit of most rule right sides. Let’s start with the default mode that matches the
sea outside of tags. Here’s that piece of our lexer grammar:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XMLLexer.g4">lexmagic/XMLLexer.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> XMLLexer;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// Default "mode": Everything OUTSIDE of a tag</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT     :   <em class="string">'&lt;!--'</em> .*? <em class="string">'--&gt;'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CDATA       :   <em class="string">'&lt;![CDATA['</em> .*? <em class="string">']]&gt;'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Scarf all DTD stuff, Entity Declarations like &lt;!ENTITY ...&gt;,</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  and Notation Declarations &lt;!NOTATION ...&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DTD         :   <em class="string">'&lt;!'</em> .*? <em class="string">'&gt;'</em>            -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EntityRef   :   <em class="string">'&amp;'</em> Name <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CharRef     :   <em class="string">'&amp;#'</em> DIGIT+ <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'&amp;#x'</em> HEXDIGIT+ <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SEA_WS      :   (<em class="string">' '</em>|<em class="string">'\t'</em>|<em class="string">'\r'</em>? <em class="string">'\n'</em>) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​OPEN        :   <em class="string">'&lt;'</em>                     -&gt; pushMode(INSIDE) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​XMLDeclOpen :   <em class="string">'&lt;?xml'</em> S               -&gt; pushMode(INSIDE) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SPECIAL_OPEN:   <em class="string">'&lt;?'</em> Name               -&gt; more, pushMode(PROC_INSTR) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT        :   ~[&lt;&amp;]+ ;        <em class="comment">// match any 16 bit char other than &lt; and &amp;</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18211">
词法分析器语法首先处理所有可以视为完整标记的词汇结构。首先，我们给出<code class="cf keyword">COMMENT</code>和
<code class="cf keyword">CDATA</code>标记的规则。接下来，我们匹配并丢弃与以下形式的文档、实体和符号声明相关的任何内容：<code class="cf ic">&lt;!...&gt;</code>。对于这个项目，我们不关心这些东西。然后，我们需要规则来匹配各种实体和空格标记。向前跳一秒钟，规则<code class="cf keyword">TEXT</code>匹配输入中的任何其他内容，直到标记或实体引用的开始。这有点像“else 子句”。
</p><p>
The lexer grammar starts by dealing with all of the lexical structures that we can treat
as complete tokens. First, we give rules for <code class="cf keyword">COMMENT</code> and
<code class="cf keyword">CDATA</code> tokens. Next, we match and discard anything related to document,
entity, and notation declarations of the following form: <code class="cf ic">&lt;!...&gt;</code>. We don’t care about that
stuff for this project. We then need rules to match the various entities and
the whitespace token. Jumping ahead for a second, rule <code class="cf keyword">TEXT</code> matches
anything else in the input until the start of a tag or entity reference. This is sort of the
“else clause.”
</p>
<p id="f_0075.html.N18220">
现在来看看有趣的东西。当词法分析器看到标签的开头时，它需要切换上下文，以便下一个词法分析器标记匹配将找到在标签内有效的标记。这就是规则的作用<code class="cf keyword">OPEN</code>。与<code class="cf class">ModeTagsLexer</code>
仅使用<code class="cf keyword">mode</code>命令的语法不同，我们正在使用
<code class="cf keyword">pushMode</code>（<code class="cf keyword">popMode</code>稍后）。通过推送模式，词法分析器可以弹出模式以返回“调用”模式。这对于嵌套模式切换很有用，尽管我们在这里不这样做。
</p><p>
And now for the fun stuff. When the lexer sees the start of the tag, it needs to switch
contexts so that the next lexer token match will find a token that’s valid within a tag.
That’s what rule <code class="cf keyword">OPEN</code> does. Unlike the <code class="cf class">ModeTagsLexer</code>
grammar that used just the <code class="cf keyword">mode</code> command, we’re using
<code class="cf keyword">pushMode</code> (and <code class="cf keyword">popMode</code> in a moment). By pushing the mode, the
lexer can pop the mode to return to the “invoking” mode. This is useful for nested mode
switches, though we’re not doing that here.
</p>
<p id="f_0075.html.N18240">
接下来的两条规则区分了特殊<code class="cf ic">&lt;?xml...?&gt;</code>标记和常规<code class="cf ic">&lt;?...?&gt;</code>处理指令。因为我们希望解析器
<code class="cf keyword">prolog</code>规则匹配<code class="cf ic">&lt;?xml...?&gt;</code>
标记内的属性，所以我们需要词法分析器返回一个<code class="cf keyword">XMLDeclOpen</code>标记，然后切换到
<code class="cf variable">INSIDE</code>标记模式，该模式将匹配属性标记。规则
<code class="cf keyword">SPECIAL_OPEN</code>匹配任何其他标记的开头<code class="cf ic">&lt;?...?&gt;</code>，然后切换到模式<code class="cf variable">PROC_INSTR</code>（我们很快就会看到）。它还使用一个不熟悉的词法分析器命令，<code class="cf keyword">more</code>该命令指示词法分析器查找另一个标记并保留刚刚匹配的标记的文本。 
</p><p>
The next two rules distinguish between the special <code class="cf ic">&lt;?xml...?&gt;</code> tag and the
regular <code class="cf ic">&lt;?...?&gt;</code> processing instruction. Because we want the parser
<code class="cf keyword">prolog</code> rule to match the attributes inside the <code class="cf ic">&lt;?xml...?&gt;</code>
tag, we need the lexer to return an <code class="cf keyword">XMLDeclOpen</code> token and then switch to the
<code class="cf variable">INSIDE</code> tag mode, which will match the attribute tokens. Rule
<code class="cf keyword">SPECIAL_OPEN</code> matches the start of any other <code class="cf ic">&lt;?...?&gt;</code> tag and
then switches to the <code class="cf variable">PROC_INSTR</code> mode (which we’ll see shortly). It also
uses an unfamiliar lexer command called <code class="cf keyword">more</code> that instructs the lexer to
look for another token and keep the text of the just-matched token. 
</p>
<p id="f_0075.html.N18261">
一旦进入模式<code class="cf variable">PROC_INSTR</code>，我们希望词法分析器继续通过规则消耗和堆积字符，<code class="cf keyword">IGNORE</code>直到看到处理指令的结尾<code class="cf ic">?&gt;</code>。
</p><p>
Once inside mode <code class="cf variable">PROC_INSTR</code>, we want the lexer to keep consuming and
piling up characters via rule <code class="cf keyword">IGNORE</code> until it sees the end of the
processing instruction, <code class="cf ic">?&gt;</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XMLLexer.g4">lexmagic/XMLLexer.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode PROC_INSTR;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​PI          :   <em class="string">'?&gt;'</em>                    -&gt; popMode ; <em class="comment">// close &lt;?...?&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​IGNORE      :   .                       -&gt; more ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18285"><code class="cf ic">’&lt;?’ .*? ’?&gt;’</code>这是一种除了标签之外的所有处理指令的
奇特匹配方式<code class="cf ic">&lt;?xml...?&gt;</code>。<code class="cf keyword">SPECIAL_OPEN</code>规则也会匹配
<code class="cf ic">&lt;?xml</code>，但词法分析器会优先考虑规则，<code class="cf keyword">XMLDeclOpen</code>
因为根据我们在第 2.3 节“<a href="#f_0017.html.sec.ambiguity">你<em>不能在核反应堆中放入太多的水”中的</em>讨论，规则排在第一位。</a>不幸的是，我们不能只制定一个简单的规则，例如，<code class="cf ic">’&lt;?’ .*? ’?&gt;’</code>并取消模式
<code class="cf variable">PROC_INSTR</code>。由于<code class="cf ic">’&lt;?’ .*? ’?&gt;’</code>匹配的字符序列比长<code class="cf ic">’&lt;?xml’ S</code>，因此词法分析器永远不会匹配
<code class="cf keyword">XMLDeclOpen</code>。这类似于<a href="#f_0073.html.sec.maximal-munch">避免<em>最大 Munch 歧义</em>中的情况，</a>其中词法分析器更喜欢一个<code class="cf ic">&gt;&gt;</code>标记而不是两个
<code class="cf ic">&gt;</code>标记。
</p><p>
This is all a fancy way to match <code class="cf ic">’&lt;?’ .*? ’?&gt;’</code> for every processing instruction
except for the <code class="cf ic">&lt;?xml...?&gt;</code> tag. The <code class="cf keyword">SPECIAL_OPEN</code> rule matches
<code class="cf ic">&lt;?xml</code> also, but the lexer gives precedence to rule <code class="cf keyword">XMLDeclOpen</code>
since it’s listed first per our discussion in Section 2.3, <a href="#f_0017.html.sec.ambiguity">​<em>You Can’t Put Too Much Water into a Nuclear Reactor</em>​</a>. Unfortunately,
we can’t just have a simple rule like <code class="cf ic">’&lt;?’ .*? ’?&gt;’</code> and do away with the
<code class="cf variable">PROC_INSTR</code> mode. Since <code class="cf ic">’&lt;?’ .*? ’?&gt;’</code> matches a longer
character sequence than <code class="cf ic">’&lt;?xml’ S</code>, the lexer would never match
<code class="cf keyword">XMLDeclOpen</code>. This is similar to the situation in <a href="#f_0073.html.sec.maximal-munch">​<em>Avoiding the Maximal Munch Ambiguity</em>​</a>, where the lexer favored one <code class="cf ic">&gt;&gt;</code> token over two
<code class="cf ic">&gt;</code> tokens.
</p>
<p id="f_0075.html.N182B2">
请注意，<code class="cf keyword">SPECIAL_OPEN</code>引用规则<code class="cf keyword">Name</code>在我们查看的两种模式中均未出现。它出现在<code class="cf variable">INSIDE</code>
我们接下来要查看的模式中。模式只是告诉词法分析器在被要求输入标记时应该考虑匹配哪组规则。一个规则可以调用不同模式下的另一个规则作为辅助规则。但是，请记住，词法分析器只能从当前词法分析器模式中定义的标记类型返回给解析器。
</p><p>
Notice that <code class="cf keyword">SPECIAL_OPEN</code> references rule <code class="cf keyword">Name</code>, which
doesn’t appear in either mode we’ve looked at. It appears in the <code class="cf variable">INSIDE</code>
mode we’ll look at next. Modes just tell the lexer which set of rules it should consider
matching when asked for a token. It’s OK for one rule to call another in a different mode
as a helper. But, keep in mind that the lexer can return token types to the parser only  from
those defined within the current lexer mode.
</p>
<p id="f_0075.html.N182BE">
我们的最终模式是<code class="cf variable">INSIDE</code>模式，它可以识别标签内的所有元素，如下所示：
</p><p>
Our final mode is the <code class="cf variable">INSIDE</code> mode, which recognizes all of the elements
within tags like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​title id="chap2", center="true"​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N182D0"><a href="#f_0035.html.sec.common-lex-structures"><em>标签内的词汇结构强化了第 5.3 节“使用 ANTLR 语法</em></a><a href="#f_0035.html.sec.common-lex-structures">识别<em></em></a>
中的观点<a href="#f_0035.html.sec.common-lex-structures">，</a>即从词汇角度来看，许多语言看起来都一样。例如，C 的词法分析器可以毫无问题地标记该标签内容。
</p><p>
The lexical structure within tags reinforces the idea from Section 5.3, <a href="#f_0035.html.sec.common-lex-structures">​<em>Recognizing Common Language Patterns with ANTLR Grammars</em>​</a>, that many languages look the same from a lexical
perspective. For example, a lexer for C would have no problem tokenizing that tag content.
</p>
<p id="f_0075.html.N182D6">
这是我们处理标签内的结构的（最终）模式：
</p><p>
Here’s our (final) mode that handles the structures within tags:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XMLLexer.g4">lexmagic/XMLLexer.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode INSIDE;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CLOSE       :   <em class="string">'&gt;'</em>                     -&gt; popMode ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SPECIAL_CLOSE:  <em class="string">'?&gt;'</em>                    -&gt; popMode ; <em class="comment">// close &lt;?xml...?&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SLASH_CLOSE :   <em class="string">'/&gt;'</em>                    -&gt; popMode ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SLASH       :   <em class="string">'/'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​EQUALS      :   <em class="string">'='</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING      :   <em class="string">'"'</em> ~[&lt;<em class="string">"]* '"'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="string">            |   '</em>\<em class="string">''</em> ~[&lt;<em class="string">']* '</em>\<em class="string">''</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Name        :   NameStartChar NameChar* ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​S           :   [ \t\r\n]               -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​HEXDIGIT    :   [a-fA-F0-9] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DIGIT       :   [0-9] ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameChar    :   NameStartChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'-'</em> | <em class="string">'.'</em> | DIGIT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u00B7'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u0300'</em>..<em class="string">'\u036F'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u203F'</em>..<em class="string">'\u2040'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameStartChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            :   [:a-zA-Z]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u2070'</em>..<em class="string">'\u218F'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u2C00'</em>..<em class="string">'\u2FEF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\u3001'</em>..<em class="string">'\uD7FF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\uF900'</em>..<em class="string">'\uFDCF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            |   <em class="string">'\uFDF0'</em>..<em class="string">'\uFFFD'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18399">
前三条规则与结束标记序列匹配。这里
<code class="cf keyword">popMode</code>词汇命令就派上用场了。我们不必指定要切换到的模式；规则只需说“弹出”。前一个模式位于模式堆栈中。
</p><p>
The first three rules match the end tag sequences. Here is where the
<code class="cf keyword">popMode</code> lexical command comes in handy. We don’t have to specify the mode
to switch to; the rules can just say “pop.” The previous mode is on a mode stack.
</p>
<p id="f_0075.html.N1839F">
规则与规范中的<code class="cf keyword">STRING</code>规则相匹配，唯一的不同之处在于它不专门匹配字符串内的实体。我们不关心字符串的内部，因此没有必要仔细匹配这些字符。我们只需确保根据规范不允许在字符串内部使用或引号。
<code class="cf keyword">AttValue</code><code class="cf keyword">STRING</code><code class="cf ic">&lt;</code></p><p>
Rule <code class="cf keyword">STRING</code> matches rule <code class="cf keyword">AttValue</code> from the spec and
differs only in that <code class="cf keyword">STRING</code> does not specifically match
entities inside strings. We don’t care about the inside of strings, so
there’s no point in carefully matching those characters. We just have to make sure that we
don’t allow <code class="cf ic">&lt;</code> or quotes inside of strings, per the spec.
</p>
<p id="f_0075.html.N183B2">
现在我们有了解析器和词法分析器语法，让我们构建并测试它们。
</p><p>
Now that we have a parser and lexer grammar, let’s build and test them.
</p>
<h3>测试我们的 XML 语法</h3><h3>Testing Our XML Grammar</h3>
<p id="f_0075.html.N183B9">
与往常一样，我们需要对这两个语法运行 ANTLR，注意首先处理词法分析器，因为解析器依赖于 ANTLR 为其生成的标记类型
<code class="cf filename">XMLLexer.g4</code>。
</p><p>
As usual, we need to run ANTLR on the two grammars, being careful to process the lexer first
because the parser depends on the token types generated by ANTLR for
<code class="cf filename">XMLLexer.g4</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 XMLLexer.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 XMLParser.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac XML*.java</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N183DA">
以下是一个示例 XML 输入文件：
</p><p>
Here’s a sample XML input file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XML-inputs/entity.xml">lexmagic/XML 输入/entity.xml</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">&lt;!-- a comment</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">--&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;root&gt;</strong>
<em class="comment">&lt;!-- comment --&gt;</em>
<strong class="prompt">&lt;message&gt;</strong>if salary &amp;lt; 1000<strong class="prompt">&lt;/message&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&amp;apos; <strong class="prompt">&lt;a&gt;</strong>hi<strong class="prompt">&lt;/a&gt;</strong>  <strong class="prompt">&lt;foo</strong>
<strong class="prompt">/&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/root&gt;</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N1840B">
让我们用<code class="cf commandname">grun</code>它生成一棵解析树。
</p><p>
Let’s use <code class="cf commandname">grun</code> to generate a parse tree.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun XML document -gui XML-inputs/entity.xml</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18420">
解析树表明我们的解析器正确处理注释、实体、标签和文本。
</p><p>
The parse tree indicates that our parser correctly handles comments, entities, tags, and text.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/lexmagic/entity.png">
</div>
<p id="f_0075.html.N18427">
现在，让我们检查一下，以确保我们的解析器能够正确处理<code class="cf ic">&lt;?xml...?&gt;</code>与其他处理指令标签。以下是示例输入文件：
</p><p>
Now, let’s check to make sure that our parser correctly handles <code class="cf ic">&lt;?xml...?&gt;</code> vs. other processing instruction tags. Here’s a sample input file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/lexmagic/XML-inputs/cat.xml">lexmagic/XML 输入/cat.xml</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​&lt;?xml version="1.0" encoding="UTF-8"?&gt;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">&lt;?do not care?&gt;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;CATALOG&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;PLANT</strong> id=<em class="string">"45"</em>
<strong class="prompt">&gt;</strong>Orchid<strong class="prompt">&lt;/PLANT&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;/CATALOG&gt;</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18452">
我们可以用这个来生成一个解析树：
</p><p>
We can generate a parse tree with this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun XML document -ps /tmp/t.ps XML-inputs/cat.xml</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18464">
下面的树显示 XML 声明标签被正确地分块发送到解析器，而<code class="cf ic">&lt;?do not care?&gt;</code>作为一个<code class="cf keyword">PI</code>块发送。
</p><p>
The following tree shows that the XML declaration tag is properly sent in pieces to the
parser, whereas <code class="cf ic">&lt;?do not care?&gt;</code> comes as one <code class="cf keyword">PI</code> chunk.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/lexmagic/cat.png">
</div>
<p id="f_0075.html.N18471">
模式中的大多数词法分析器规则<code class="cf variable">INSIDE</code>都使用所有有效的 Unicode 代码点来正确匹配标记名称。这使我们能够识别例如带有日语标记名称的 XML 文件。<a id="f_0075.html.FNPTR-50" href="#f_0075.html.FOOTNOTE-50">[50]</a>
将示例文件运行<code class="cf filename">weekly-euc-jp.xml</code>到我们的解析器中需要正确的日语编码选项<code class="cf commandname">grun</code>。
</p><p>
Most of the lexer rules in mode <code class="cf variable">INSIDE</code> deal with properly matching tag
names, using all of the valid Unicode code points. That allows us to recognize, for example,
XML files with Japanese tag
names.<a href="#f_0075.html.FOOTNOTE-50">[50]</a>
Running sample file <code class="cf filename">weekly-euc-jp.xml</code> into our parser requires the
proper Japanese encoding option for <code class="cf commandname">grun</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun XML document -gui -encoding euc-jp XML-inputs/weekly-euc-jp.xml</strong>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0075.html.N18492">图 12，<a href="#f_0075.html.fig.lexmagic.euc-jp"><em>​对话框中的</em></a><a href="#f_0075.html.fig.lexmagic.euc-jp">窗口​显示了<em></em></a>一个更大的对话框中的窗口。
</p><p>Figure 12, <a href="#f_0075.html.fig.lexmagic.euc-jp">​<em>A window into a dialog box</em>​</a> shows a window into the much larger dialog box.
</p>
<div class="figure" id="f_0075.html.fig.lexmagic.euc-jp">
<div>
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/lexmagic/euc-jp.png">
</div>
<div class="figurecaption">
<hr>图 12. 进入对话框的窗口</div>
</div>
<p id="f_0075.html.N184A3">
此 XML 语法很好地说明了复杂性通常存在于词法分析器中。解析器通常很大，但通常并不那么困难。当一种语言难以识别时，通常是因为很难将字符分组为标记。这要么是因为词法分析器确实需要语法上下文来做出决定，要么是因为文件中的不同区域具有不同的词汇规则。
</p><p>
This XML grammar is a great example of how complexity often resides in the lexer. Parsers can
often be big, but they’re usually not that difficult. When a language is hard to recognize,
it’s usually because it’s hard to group the characters into tokens. This is either because
the lexer really needs syntactic context to make decisions or because there are different
regions in the file with different lexical rules.
</p>
<p id="f_0075.html.N184A9">
这一章很长，我们讲了很多内容，但当你遇到具有挑战性的识别问题时，它将是一个很好的资源。我们开始学习如何在不同的渠道上发送不同的标记，这样我们就可以忽略但不会丢弃关键标记，例如注释和空格。接下来，我们研究了如何解决一些上下文相关的词汇问题，例如令人讨厌的关键字作为标识符问题。然后，我们学习了如何使用词汇模式以不同的方式标记输入的多个区域，将岛屿与海洋分开。在我们的大结局中，我们使用词汇模式构建了一个精确的 XML 词法分析器。
</p><p>
This chapter is big, and we went through a lot of material, but it will serve as a good
resource when you run into challenging recognition problems. We started out learning how to
send different tokens on different channels so that we can ignore but not throw out key
tokens such as comments and whitespace. Next, we looked at how to solve some
context-sensitive lexical problems such as the pesky keywords-as-identifiers problem. Then,
we learned how to tokenize multiple regions of the input differently using lexical modes,
separating the islands from the sea. In our grand finale, we used lexical modes to build a
precise XML lexer.
</p>
<p id="f_0075.html.N184AC">
到目前为止，我们已经学习了很多有关如何使用 ANTLR 的知识。本书的下一部分是参考部分，其中介绍了本书前面为了清晰起见而避免提及的大量细节。
</p><p>
At this point, we’ve learned a great deal about how to use ANTLR. The next part of the book is a reference section that fills in a lot of details we avoided for clarity earlier in the book.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0075.html.FOOTNOTE-47" href="#f_0073.html.FNPTR-47">[47]</a>
</td>
<td>
<p id="f_0075.html.N178D9">
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html</a>
</p><p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0075.html.FOOTNOTE-48" href="#f_0073.html.FNPTR-48">[48]</a>
</td>
<td>
<p id="f_0075.html.N17A2D">
<a href="http://docs.python.org/reference/lexical_analysis.html">http://docs.python.org/reference/lexical_analysis.html</a>
</p><p>
<a href="http://docs.python.org/reference/lexical_analysis.html">http://docs.python.org/reference/lexical_analysis.html</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0075.html.FOOTNOTE-49" href="#f_0075.html.FNPTR-49">[49]</a>
</td>
<td>
<p id="f_0075.html.N18008">
<a href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>
</p><p>
<a href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0075.html.FOOTNOTE-50" href="#f_0075.html.FNPTR-50">[50]</a>
</td>
<td>
<p id="f_0075.html.N18478">
<a href="http://people.apache.org/~edwingo/jaxp-ri-1.2.0-fcs/samples/data/weekly-euc-jp.xml">http://people.apache.org/~edwingo/jaxp-ri-1.2.0-fcs/samples/data/weekly-euc-jp.xml</a>
</p><p>
<a href="http://people.apache.org/~edwingo/jaxp-ri-1.2.0-fcs/samples/data/weekly-euc-jp.xml">http://people.apache.org/~edwingo/jaxp-ri-1.2.0-fcs/samples/data/weekly-euc-jp.xml</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0076.html"><div>

<h1 class="part-title" id="f_0076.html.N184B1">
<span class="part-number">第 4 部分</span>
<br><br>ANTLR 参考</h1><h1 class="part-title">
<span class="part-number">Part 4</span>
<br><br>ANTLR Reference</h1>
<blockquote class="pg-partintro">
<p id="f_0076.html.N184B5">
本书的前三部分是使用 ANTLR 的指南，而最后一部分主要是参考资料。我们将首先总结运行时 API，并研究 ANTLR 如何处理左递归规则。最后，我们将看到巨大的参考章节。
</p>
</blockquote><blockquote class="pg-partintro">
<p>
The first three parts of this book were a guide to using ANTLR, whereas this final part is
primarily reference material. We’ll start by summarizing the runtime API and looking at
how ANTLR handles left-recursive rules. And, finally, we’ll see the giant reference
chapter.
</p>
</blockquote>



</div></div>
<div id="f_0077.html"><div>

<h1 class="chapter-title" id="f_0077.html.chp.api">
<span class="chapter-number">
	      第十三章</span>
<br><br>
<span class="chapter-name">探索运行时 API</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      13</span>
<br><br>
<span class="chapter-name">Exploring the Runtime API</span>
</h1>

<p id="f_0077.html.N184C1">
本章概述了 ANTLR 运行时 API，旨在帮助您开始探索运行时库。它描述了面向程序员的类，但没有重现 Javadoc 中的详细信息。<a id="f_0077.html.FNPTR-51" href="#f_0086.html.FOOTNOTE-51">[51]</a>有关类和各个方法的用法的详细信息，请参阅类和各个方法的注释。
</p><p>
This chapter gives an overview of the ANTLR runtime API and is meant to kick-start your
exploration of the runtime library. It describes the programmer-facing classes but does not
reproduce the details from the
Javadoc.<a href="#f_0086.html.FOOTNOTE-51">[51]</a> Please see the
comments on the classes and individual methods for detailed information on their usage.
</p>

</div></div>
<div id="f_0078.html"><div>

<h2 id="f_0078.html.N184CA">13.1 库包概述</h2><h2>13.1 Library Package Overview</h2>
<p id="f_0078.html.N184CE">
ANTLR 的运行时由六个包组成，主包中包含大多数面向应用程序的类。到目前为止，最常见的类是用于在某些输入上启动解析器的类。以下是实现的语法文件和解析树监听器
<code class="cf class">org.antlr.v4.runtime</code>的典型代码片段：
<code class="cf filename">X.g</code><code class="cf class">MyListener</code><code class="cf class">XListener</code></p><p>
ANTLR’s runtime consists of six packages, with most of the application-facing classes in the
main <code class="cf class">org.antlr.v4.runtime</code> package. By far the most common classes are the
ones used to launch a parser on some input. Here is the typical code snippet for a grammar
file called <code class="cf filename">X.g</code> and a parse-tree listener called
<code class="cf class">MyListener</code> that implements <code class="cf class">XListener</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​XLexer lexer = <strong class="prompt">new</strong> XLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​XParser parser = <strong class="prompt">new</strong> XParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree tree = parser.XstartRule();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTreeWalker walker = <strong class="prompt">new</strong> ParseTreeWalker();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​MyListener listener = <strong class="prompt">new</strong> MyListener(parser);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​walker.walk(listener, tree);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0078.html.N18518">
我们第一次遇到这种情况是在第 3.3 节“<a href="#f_0023.html.sec.boilerplate"><em>将生成的解析器</em></a><a href="#f_0023.html.sec.boilerplate">集成<em></em></a>中。
</p><p>
We first encountered this in Section 3.3, <a href="#f_0023.html.sec.boilerplate">​<em>Integrating a Generated Parser into a Java Program</em>​</a>.
</p>
<p id="f_0078.html.N1851E">
以下是这些软件包的摘要：
</p><p>
Here is a summary of the packages:
</p>
<dl>
<dt>
<code class="cf ic">org.antlr.v4.runtime</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime</code>
</dt>
<dd>
<p id="f_0078.html.N18528">
	 该包包含最常用的类和接口，例如输入流、字符和标记缓冲区、错误处理、标记构造、词法分析和解析的层次结构。
	</p>
</dd><dd>
<p>
	 This package contains the most commonly used classes and interfaces, such as the hierarchies for input streams, character and token buffers, error handling, token construction, lexing, and parsing.
	</p>
</dd>
<dt>
<code class="cf ic">org.antlr.v4.runtime.atn</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime.atn</code>
</dt>
<dd>
<p id="f_0078.html.N18531"><span class="emph">这在 ANTLR 的自适应LL(*)</span>词法分析和解析策略
	 中内部使用。术语<span class="emph">atn</span>表示<span class="firstuseinline">增强转换网络</span>
<a id="f_0078.html.FNPTR-52" href="#f_0086.html.FOOTNOTE-52">[52]</a>   ，是一种可以表示语法的状态机，其中边表示语法元素。ANTLR 在词法分析和解析过程中遍历 ATN，以根据前瞻符号进行预测。
	</p>
</dd><dd>
<p>
	 This is used internally for ANTLR’s  Adaptive <span class="emph">LL(*)</span> lexing and parsing strategy. The <span class="emph">atn</span> term means <span class="firstuseinline">augmented transition network</span>
<a href="#f_0086.html.FOOTNOTE-52">[52]</a>  and is a state machine that can represent a grammar where edges represent grammar elements. ANTLR walks the ATN during lexing and parsing to make predictions based upon lookahead symbols.
	</p>
</dd>
<dt>
<code class="cf ic">org.antlr.v4.runtime.dfa</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime.dfa</code>
</dt>
<dd>
<p id="f_0078.html.N18548">
	 使用 ATN 进行预测的成本很高，因此运行时会将预测结果缓存在<span class="firstuseinline">确定性有限自动机</span>(DFA) 中。<a id="f_0078.html.FNPTR-53" href="#f_0086.html.FOOTNOTE-53">[53]</a>此包包含所有 DFA 实现类。
	</p>
</dd><dd>
<p>
	 Using the ATN to make predictions is expensive, so the runtime caches prediction results in <span class="firstuseinline">deterministic finite automata</span> (DFA).<a href="#f_0086.html.FOOTNOTE-53">[53]</a> This package holds all of the DFA implementation classes.
	</p>
</dd>
<dt>
<code class="cf ic">org.antlr.v4.runtime.misc</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime.misc</code>
</dt>
<dd>
<p id="f_0078.html.N1855A">
 这个包包含各种数据结构，也包含<code class="cf class">TestRig</code>我们在本书中通过命令行别名使用的常用类<code class="cf commandname">grun</code>。
	</p>
</dd><dd>
<p>
 This package holds miscellaneous data structures but also the commonly used <code class="cf class">TestRig</code> class that we’ve used throughout this book via command-line alias <code class="cf commandname">grun</code>.
	</p>
</dd>
<dt>
<code class="cf ic">org.antlr.v4.runtime.tree</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime.tree</code>
</dt>
<dd>
<p id="f_0078.html.N18569">
	ANTLR 生成的解析器默认构建解析树，此包包含实现解析树所需的所有类和接口。它还包含基本的解析树监听器、遍历器和访问者机制。
	</p>
</dd><dd>
<p>
	ANTLR-generated parsers build parse trees by default, and this package holds all of the classes and interfaces needed to implement them. It also contains the basic parse-tree listener, walker, and visitor mechanisms.
	</p>
</dd>
<dt>
<code class="cf ic">org.antlr.v4.runtime.tree.gui</code>
</dt><dt>
<code class="cf ic">org.antlr.v4.runtime.tree.gui</code>
</dt>
<dd>
<p id="f_0078.html.N18572">
	ANTLR 附带了一个基本的解析树查看器，可通过树方法访问<code class="cf methodname">inspect</code>。您还可以通过以 PostScript 格式保存树<code class="cf methodname">save</code>。<code class="cf class">TestRig</code>的<code class="cf commandoption">-gui</code>选项启动此查看器。
	</p>
</dd><dd>
<p>
	ANTLR ships with a basic parse tree viewer accessible via tree method <code class="cf methodname">inspect</code>. You can also save trees in PostScript form via <code class="cf methodname">save</code>. <code class="cf class">TestRig</code>’s <code class="cf commandoption">-gui</code> option launches this viewer.
	</p>
</dd>
</dl>
<p id="f_0078.html.N18581">
其余部分按功能分组描述运行时 API。
</p><p>
The remaining sections describe the runtime API grouped by functionality.
</p>

</div></div>
<div id="f_0079.html"><div>

<h2 id="f_0079.html.N18587">13.2 识别器</h2><h2>13.2 Recognizers</h2>
<p id="f_0079.html.N1858B">
ANTLR 生成的词法分析器和解析器是<code class="cf class">Lexer</code>和的子类<code class="cf class">Parser</code>。超类<code class="cf class">Recognizer</code>抽象了识别字符或标记序列内结构的概念。识别器以<code class="cf class">IntStream</code>s 为依据，我们将在后面讨论。以下是继承和接口实现关系（接口以斜体表示）。
</p><p>
ANTLR generates lexers and parsers that are subclasses of <code class="cf class">Lexer</code> and <code class="cf class">Parser</code>.
  Superclass <code class="cf class">Recognizer</code> abstracts the notion of recognizing structure within a sequence of characters or tokens. 
  Recognizers feed off of <code class="cf class">IntStream</code>s, which we’ll look at later. 
  Here is the inheritance and interface implementation relationships (interfaces are in italics).
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPUAAAA/CAAAAAAdqdFrAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAP9SURBVGje7ZqxkRshFIYJ7MQZLVCBxyRXAJFzAjdA7ojI45QWiJw4ooXXAjOugBZoAT8e8pxGWun2TiyLT2LmGG5Bq/fB218I/azcY2G1crZ7cQNij28LLR6oWX9qNoDaqrdEpuw/6v4RDaG2b33Vg/pBfU/UiZ732oqnIuytn5s6rYzvnDqDlwDnd8T/Dbzqw2g8Nai3UpcSbP1LxUBB+uByidmHUvihN2Ea4Lymehk/MA9jlqlzHE+dHS55TPW9azPHtogvUGMeGxtEktnUltNFmiBiMQbZqKdOAI4SxhsNoY1Zog7f2MYLvkCdRXCqgCw6UBO4XkOtwBvscQiFj3JGIp7xIl7iqfUkvLuKhWV6mzZmgfrTB8Y22P0cl6dzamcABEapTWvWf1ZQi2Ixn80PjqRWWpcBmWSm0dQTwNR8x8skbzRmHmqrSY2BhdZceNgXqLOsMEn8tFE1LGfrVNTRjnoyvgqTCC/TXvuSsu+U4TUdKWNlpuY6alzIJLWsMqUgCq0yLjC+VCulMvWUyJUxNSOiUKrQmEXq4WrGMcZiJO6zscNqaq6j7lb+p13Kg3p26hSe7ow6Oi2Y+Hw/1DlYxZiyId9LhkdvJOPawXP8t1D330F0pwarOZPWp6P4bztBmvy0MAWLS4wfvicbgxtPCycuTbeM67vhmZj6SLd6l0mpT3TrDqibbplj3Xrf1OmQ1NA/qSeljs5soFsTU2c46NaGST0XdWq6ZTfSrQmpB+jWXNSjdGse6pG6NQV10y05Trd2p95Ft3alBtd0a7+kHky94ZeI2aihPbdNt/SOuvUSdbejBVfyV6aqbvFtdavHqUK3YyTmPn1kHwbo1o0nSCerfmNhVH5vS0zUt50Wdqb+9kUwNuBRnot6e94HdSfq7Ky7Lrzp6rnvHtQYs1+5H7hADRK8uIqdrk7yHtQvx/witarGBDLzlOxtwqqaMPBCSjlGSwafBACJxpzZfEb8YH9Grcg2EfDDkuIB2zxICyaky9RZ/CEzT8ZdBmThcR5rzQNw60X14YC1/Fcz/JzafFgJX7c2ZyxRK8ge17zGAwpCXo7uIjVX3DczTzWlUIU7Lqzxmqx3b8YX28ac2XxGGHGoHP1+jTELW7/I4tYI4/EylQvRXVnrxJuZh2bTEjXV0Oa01kEdDD9n1o9dqCmIqLxpVhQv7IXorj3X6juZeTzdQZeifa3FM3US+WD4OafeKcOrGpV/ZqvML0R3Vc0smXmqj8cVo1T11wllnqm1UDixdcwC9T5qhvknjCZqrzGw5ehev0uRq1j+z13KhaKsMatu+66oE6zM2ndFvbo8qB/Uc1L32jyMo+5wgtTxtHBQeb8epG3KfVL/BdNzagZW3Y2jAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjU4LTA2OjAw3dTqYwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo1OC0wNjowMKyJUt8AAAAfdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADI0NXg2MyswKzD7l/OKAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS41DUCDV0wAAAAASUVORK5CYII=" alt="图片/api/Recognizer.png">
</div>
<p id="f_0079.html.N185A9">
<code class="cf class">Lexer</code>  实现接口<code class="cf class">TokenSource</code>，它指定核心词法分析器功能：<code class="cf methodname">nextToken</code>、<code class="cf methodname">getLine</code>和
<code class="cf methodname">getCharPositionInLine</code>。将我们自己的词法分析器与 ANTLR 解析器语法一起使用并不需要太多工作。让我们构建一个词法分析器，它可以标记简单的标识符和整数，如以下输入文件：
</p><p>
<code class="cf class">Lexer</code>  implements interface <code class="cf class">TokenSource</code>, which specifies the
core lexer functionality: <code class="cf methodname">nextToken</code>, <code class="cf methodname">getLine</code>, and
<code class="cf methodname">getCharPositionInLine</code>. Rolling our own lexer to use with an ANTLR parser grammar
is not too much work. Let’s build a lexer that tokenizes simple identifiers and integers
like the following input file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/Simple-input">api/简单输入</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a 343x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​abc 9 ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0079.html.N185CF">
以下是手工制作的词法分析器的核心：
</p><p>
Here’s the core of a handbuilt lexer:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/SimpleLexer.java">api/SimpleLexer.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​@Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> Token nextToken() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">while</strong> (true) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( c==(<strong class="prompt">char</strong>)CharStream.EOF ) <strong class="prompt">return</strong> createToken(Token.EOF);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">while</strong> ( <strong class="prompt">Character</strong>.isWhitespace(c) ) consume(); <em class="comment">// toss out whitespace</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        startCharIndex = input.index();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        startLine = getLine();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        startCharPositionInLine = getCharPositionInLine();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( c==<em class="string">';'</em> ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            consume();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">return</strong> createToken(SEMI);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">else</strong> <strong class="prompt">if</strong> ( c&gt;=<em class="string">'0'</em> &amp;&amp; c&lt;=<em class="string">'9'</em> ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">while</strong> ( c&gt;=<em class="string">'0'</em> &amp;&amp; c&lt;=<em class="string">'9'</em> ) consume();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">return</strong> createToken(INT);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">else</strong> <strong class="prompt">if</strong> ( c&gt;=<em class="string">'a'</em> &amp;&amp; c&lt;=<em class="string">'z'</em> ) { <em class="comment">// VERY simple ID</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">while</strong> ( c&gt;=<em class="string">'a'</em> &amp;&amp; c&lt;=<em class="string">'z'</em> ) consume();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            <strong class="prompt">return</strong> createToken(ID);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// error; consume and try again</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        consume();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">protected</strong> Token createToken(<strong class="prompt">int</strong> ttype) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">String</strong> text = null; <em class="comment">// we use start..stop indexes in input</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            Pair&lt;TokenSource, CharStream&gt; source =​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                    <strong class="prompt">new</strong> Pair&lt;TokenSource, CharStream&gt;(this, input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">return</strong> factory.create(source, ttype, text, Token.DEFAULT_CHANNEL,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                          startCharIndex, input.index()-1,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                          startLine, startCharPositionInLine);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">protected</strong> <strong class="prompt">void</strong> consume() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( c==<em class="string">'\n'</em> ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        line++;  <em class="comment">// \r comes back as a char, but \n means line++</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        charPositionInLine = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> ( c!=(<strong class="prompt">char</strong>)CharStream.EOF ) input.consume();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    c = (<strong class="prompt">char</strong>)input.LA(1);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    charPositionInLine++;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0079.html.N186D4">
对于手工构建的词法分析器，我们需要一种方法来在 ANTLR 解析器语法中共享相同的标记名称。对于解析器代码生成，我们还需要告知 ANTLR 词法分析器源中建立的标记类型整数值。这就是文件的作用<code class="cf fileextension">tokens</code>。
</p><p>
With a handbuilt lexer, we need a way to share the same token names in the ANTLR parser grammar. For parser code generation, we also need to inform ANTLR of the token type integer values established in the lexer source. This is the role of the <code class="cf fileextension">tokens</code> file.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/SimpleLexer.tokens">api/SimpleLexer.tokens</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID=1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT=2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SEMI=3​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0079.html.N186ED">
下面是基于这些标记定义的简单语法：
</p><p>
Here’s a simple grammar that feeds off of those token definitions:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/SimpleParser.g4">api/SimpleParser.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">parser</strong> <strong class="prompt">grammar</strong> SimpleParser;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  <em class="comment">// get token types from SimpleLexer.tokens; don't name it</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  <em class="comment">// SimpleParser.tokens as ANTLR will overwrite!</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  tokenVocab=SimpleLexer;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​s : ( ID | INT )* SEMI ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0079.html.N1871C">
以下是构建和测试顺序：
</p><p>
And here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 SimpleParser.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Simple*.java TestSimple.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java TestSimple Simple-input</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(s a 343 x abc 9 ;)​</code></div>
</td>
</tr>
</tbody></table>

</div></div>
<div id="f_0080.html"><div>

<h2 id="f_0080.html.N18740">13.3 字符和标记的输入流</h2><h2>13.3 Input Streams of Characters and Tokens</h2>
<p id="f_0080.html.N18744">
在最抽象的层面上，词法分析器和解析器都会检查整数流的语法。词法分析器处理字符（短整数），解析器处理标记类型（整数）。这就是为什么 ANTLR 输入流类层次结构的根被称为
<code class="cf class">IntStream</code>。
</p><p>
At the most abstract level, both lexers and parsers check the syntax of integer streams.
Lexers process characters (short integers), and parsers process token types (integers). That
is why the root of the ANTLR input stream class hierarchy is called
<code class="cf class">IntStream</code>.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAb4AAACOCAAAAABr6zIsAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAwaSURBVHja7Z29yuy4GcdNPsgh28RZlkCagIrUS0TYF9KkUHHYahvDhjSnMinfTtUh1YKvIKB6Oze5ABV7A4a9ApM70C0oeh7JH+PReDwz/px5/pzz4pHH0mP9xh55/OjvxJIOrGTrAEiP6Kj4KrmyqpFgirWDARVHxifFup0l5EgwyRb4kkPjk4/XMVt7m3Qi4ZurPcJ3qwgf4ZurPcJ3q6A7TSEL0xQorty/8zcqhV/0GparMwb1+JDytL2LSpq61LSqmnjOA5oczxPg01yrtOGXGPgXe6OULPfdpcVgZc3K0q0pprV3UdiJ7sOjJ+Jr4jkLaHo8z4DP7bzQxn1cK1Nx/RPXxhSuB02lNS6441PBG4W2RrkD1W0A74Z1pqpkbRVCqRL9P7cJltsSetbUujB16OO2PVvXl3uyYvjhwXbazbt6fDk2ivH0A4rEY7p9KE/qeSZ8XEsRIComf2DyZ1YWriTN/osLhilXjoxhqdbCCNdbsE6nUjFTM+k6XSXyxzTTWG6Uq9XVICXPVVr32qsLlnxzGZ8/PEM7zebtQluugDJ8nLqAYvHU3T5AQOfxPAM+JnNhPD4Lf22Ra81ceVgo3JtyxAdL7gtHiNL6dZrjVrVkCjrBvTlsY3QmLax1/Sy7s9inPya/SZI/Xb6C9vhCO83m7UJXDkee+98LKBZPtw8Y0Hk8z4DPIXNd1MMnM9eZUO4XpPRvFNov6US4zsF1YSs46SE+EcoroXLpj+iTL7x/XcNXyCasUPnJQq/c4+sFFIun2wcM6DyeJ8GXFbC/LOBTOazTzYLKXCHig6VMuXMVq/y6trvqFh+Wuw+4jOG7evKsWRVahHaG+HrlHl8voFg83T5gQM+JLxXc7WLGRRbw2ZwL3/m4YIVb5YcuuRA5rNDc4DrfXSUXDLqT/weGgFBesjyL47PjQxd32Agh2nYG+HrlHl8/oEg8VbsPGNBT4ttNe3TZfqsIH+Gbqz3Cd6sIH+Gbqz3Cd6sI37HxRZMlvvu0VGoCJUvMqvNUpfePX3/48HGx3qJUpQVlVJYwWW4dxup6Bnx1wR27qbc5n0qHx1dJnvCifryiQ+rY+LRkSfay7Oyh8ZV5mmbKPF7RgXVQfG6okqb56w1VhjoivrqAYaZ+vKLj63D4YJjJX3OYGdGx8L32MDOiA+Gr3DBTELsTHQUfsHv1YWZEh8BX5sQurv3jg8u7nNjFtV981d/qwI4u7y5qt/iK5Bf/zBJiN66d4jPf/ipJvqRL82taAN8MNy/ff5+AohcJq3tK9LW3nwsWwDdH6sDf397e/hqdr7e6p0RfYuUMm03wLVvR2klKe2k7KsJ3iwjfwxURvp4I3y16FXw1ftPDq2o4z15N81+wY/hqqEKFgempPcMFhwmleo4OdztMvAo+oxXXOrbHMteFW31/bM3ETD+b0Q7tGS44TOBc2ysOE9cNHV4FHxgiwP/a5tq6LisLYyujSmtTt87keQUvsdjWhXtbZQoNh8hZRWege/i8HYMWaOKABhO25zBhWreIYDAxcJgILhSto8MEQ4fXwedOkbksWc1NDktFZnlessrmuXEfdgeV5QqLlSiz0r0qU1my6rSi6v2LZMivh8/bMWiWlbwMM1d7DhO6dYsIBhOnDhMmuFC0jg4TDB1eB5/QMDdbFo6S+3Abxyk1eL6Trje4gbMcFtdgqVDDSo6Har+ir5Ik+fL7waXzxx4+3vwtRTvxuHWYaN0iGoOJU4eJ4ELRc3S4bujwOviYhZz1/HMKNgpcFq47LGKDPnDd415isTtKTQqvoFCc/Ex2GV/FPT7R/NWn+FqzBlxoDCZOHSZaF4rW0eG6ocPL4DMcTp81+7eshMWxJnzwGfYBenm4l1icu+NAwKsq81+M/YounTxtCu46wdJFuwOkyIPBRM9honWLaAwmTh0mWheK1tHhuqHDy+DTua15xiv3vS90xTJh3MHouiMTQpgqVXBsYnHJMukAaxg+VCJS0bB67ELFhLs6aI4+IdyJ1xtM9BwmdOMW0RhMDBwmWheKxtHhuqHDy+BbriK6bO+J8N0iwvdwRYSvJ8J3i54fny4I33rCLrozvWH4G2FdSpEkgvCtJ+9PcB8+vLXQ/OxfZCxhWaFn9Fm4gI+SJYb47t5WfvjGGn/QyTKQnM1nIX4HgFKV5sKn//zLJGkOOtIGeggf6jPN+dlOD+H7C3P4pt47Jy2gDl/dS0efltDgb6vT5JEN1eErwqjKaJ/QcD2jYacJ9q+kDl+uMZsBEhnwvg0sjCc0EL7N1eHjNWYzQCIDJDRgRsN4QgPh21wdvjRkM8AdcUhogIXxhAbCt7lafFqEbAZ/RxxvjV9JaCB8m6vFp6TPZvA5kLKAhSsJDYRvc7X4ZOmzGapUYUIDLFxJaCB8m+vB3zxJ2+pRfNPS3UkLiX40O7ToJ+tDi24YHVoL3K61s9yxnfT43VUc+CdFslJEw1geTpYINxx6yRL3Vzis/PoHaNnOuiGSlSIaxrJAqpIszQyXFNPwPd7OzI0sHFFy5fXD0nAYEr6VYlmkuZrwrRTLMs0RvpViWRRfKWU9dJaYaixxA75a+v9Wa/xO1mg8YQpZ1N6DIqqJZhJ34RuNyL1WddHZW0wOxK6Kz3Cpy2qQmDzZWOIGfJKVVifSPx8d3CPwronmGqexx7YrpptJ3IVvNCIG+GRrbzE9ELsqPoG5T3kJfhIh2UK1xhKw3OVhRHwl4nMzo9GzAmZc8hrvUsJUWd9ZIkzk9eYRpur8J8BDYqqZRPNY74kZWZMiAkMLfAXtngTi7S4gkFgka+LD+efW8qxkVZNsoVpjCdb4TeCqiK9EYst//DbR19uxVQb3koUSZ51l8OgL/hNp5z8BHhJTzST8HO2vkonp8RMico1gWPDKtdsPJDhhQCA2Esma+ELmGmRg/OiTLdAuJxhLuOVeHkbEVyL54tdJ8rvvx688MXr3ZZoBF6FOOysVqfLzoP0M+J7/hDd+mmQm4SL5A/y0+3bDdfV4RKkQyuPz7fYCCSUQiI1Esj4+zMB4b5MtbDCWgOUuDyPmKzEdHxOC564z6nT4Wa9T6/tp6D/h93qSmcQ9+K5FZENYvt1eIL4EA7GRSNbEVzMTILI22QLxFT4No5eHEfOVmHzyhJO0+wTAnqbDbxqkFvGfCOPDKWYSd5w8r0bU4PPt9gLxJRjI1vjA/UEozMAIyRZuCNMYS8Byl4cR85WYPHTBs0v2GTZmTWe58xMeaIijwdfznxC8mmomccfQ5WpEDT5s9yQQXwKBbI5vhSpuaCd+BTH7zjzTZfviVRC+VVpZqoob2jF3z6wkfEtVQb95br/HD1RB+Lbf4weqIHzLtPJoUsDbm6tCXB2sU7LEIvgeTtgZeQjOrO1M0e5TlfYnegTVNO0UHz0Abpp2i89W39LjF69qv/ga0cNPR7R/fJYePXxZh8Bn6cHfF3QUfNYTFAXNZ+rrQPgsEOQJJ4KdjoXPQmKaI7g7Y8atdDh8FghmCaNLetAR8TkZldEFoT0sPhBcEL76YPTA+Jw0XE688lDm2Pjsqw9GD4/P+sEoe83B6DPgsziUcQRfbyhzRHzxRwG8f/z6w4ePi94s3d8BfkR8lx/E8d2nJent7iEcB8W3UTfu7hE4hO8I7Y6I8O2/3RERvv23O6Kj4kOrBtU8vuykXxVX7t/ZVjh1vpZSVQMKk50dCN8sgm7ECUMi3HU4nT2UGD8NO7KVw6rVYK7RdGcHwjeLevi8a4QWnWuErbj+iWsDFg2dV4P7A9OfccIvvLsOPhLuDRecHSLGDoRvFvXwBdcI1rlGWMXkD0z+DBYNnVcDU6449L9mskhN8JHI9AVnh4ixA+GbRX18vPnbukZYnFSMFg2tVwNMpc9bfLiN95GAh1bEnR0ixg6EbxZBN6JrjJ/nP3CN8PjQoqH1apBocNSYXeD7Wh8JG3d2iEwtJ3yzCLsxraxxp81z1wiPDy0aWq8Glbky6UYplW3wtT4SNu7sQPiWEnajYoKr1muj5xrh8aFFQ+vVYIVbBccsCwYPQrc+EhecHQjfUqLL9laEb//tjojw7b/dERG+/bc7IsK3/3ZHRPj23+6IDolPPJTzQMkS26p6nMR9olQl0qwifIcW4Tu0CN+h9X9rs7tgLTacFQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0Njo1OC0wNjowMN3U6mMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDY6NTgtMDY6MDCsiVLfAAAAIHRFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAA0NDZ4MTQyKzArMKN6eDoAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/api/IntStream.png">
</div>
<p id="f_0080.html.N1875F">
接口<code class="cf class">IntStream</code>定义了流的大多数关键操作，包括使用符号和获取前瞻符号的方法，即<code class="cf methodname">consume</code>和<code class="cf methodname">LA</code>。由于 ANTLR 识别器需要扫描并倒回输入，因此<code class="cf class">IntStream</code>定义了<code class="cf methodname">mark</code>和<code class="cf methodname">seek</code>方法。
</p><p>
Interface <code class="cf class">IntStream</code> defines most of the key operations for a stream, including methods to consume symbols and fetch lookahead symbols, namely, <code class="cf methodname">consume</code> and <code class="cf methodname">LA</code>. Because ANTLR recognizers need to scan ahead and rewind the input, <code class="cf class">IntStream</code> defines  the <code class="cf methodname">mark</code> and <code class="cf methodname">seek</code> methods.
</p>
<p id="f_0080.html.N18774">
和子接口添加了从流中提取文本的方法。实现这些接口的类通常会一次性读取所有输入并对其进行缓冲。这是因为构建这些类更容易，它提供了对输入的便捷访问，并且适合常见情况。如果您的输入太大而无法缓冲或无限大（例如，通过套接字），您可以<code class="cf class">CharStream</code>使用
和。
<code class="cf class">TokenStream</code><code class="cf class">UnbufferedCharStream</code><code class="cf class">UnbufferedTokenStream</code></p><p>
The <code class="cf class">CharStream</code> and <code class="cf class">TokenStream</code> subinterfaces add methods to
extract text from the streams. The classes implementing those interfaces typically read all
of the input in one go and buffer it. That’s because it is easier to build those classes,
it provides ready access to the input, and it suits the common case. If your input is too big to
buffer or is infinite (for example, via a socket), you can use <code class="cf class">UnbufferedCharStream</code>
and <code class="cf class">UnbufferedTokenStream</code>.
</p>
<p id="f_0080.html.N18793">
执行解析的通常代码序列是创建一个输入流、将一个词法分析器附加到它、创建附加到词法分析器的标记流，然后创建附加到标记流的解析器。
</p><p>
The usual code sequence to perform a parse is to create an input stream, attach a lexer to
it, create a token stream attached to the lexer, and then create a parser attached to the
token stream.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRFileStream(<em class="string">"an-input-file"</em>);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">//ANTLRInputStream input = new ANTLRInputStream(System.in); // or read stdin</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SimpleLexer lexer = <strong class="prompt">new</strong> SimpleLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SimpleParser parser = <strong class="prompt">new</strong> SimpleParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree t = parser.s();​</code></div>
</td>
</tr>
</tbody></table>

</div></div>
<div id="f_0081.html"><div>

<h2 id="f_0081.html.N187CA">13.4 令牌和令牌工厂</h2><h2>13.4 Tokens and Token Factories</h2>
<p id="f_0081.html.N187CE">
词法分析器将字符流分解为<code class="cf class">Token</code>对象，而解析器将语法结构应用于标记流。通常，我们认为标记在词法分析器中构造后是不可变的，但有时我们需要在创建标记字段后更改它们。例如，标记流喜欢在经过时设置标记的标记索引。为了支持这一点，ANTLR 使用了接口<code class="cf class">WritableToken</code>，它是一种<code class="cf class">Token</code>具有“setter”方法的。最后，我们有
<code class="cf class">CommonToken</code>一个实现全功能标记的接口。 
</p><p>
Lexers break up character streams into <code class="cf class">Token</code> objects, and parsers apply
grammatical structure to the stream of tokens. Generally, we think of tokens as immutable
after construction in the lexer, but sometimes we need to alter token fields after we’ve
created them. For example, the token streams like to set the token index of the tokens as
they go by. To support this, ANTLR uses interface <code class="cf class">WritableToken</code>, which is a
kind of <code class="cf class">Token</code> with “setter” methods. Finally, we have
<code class="cf class">CommonToken</code> that implements a full-featured token. 
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATYAAAAcCAAAAADOl8yRAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAALhSURBVGje7Zk9ztwgEIYpUqVzF6XkChTJAeYKLtKlQrnBVFFarsAVuAJNDoCUE6DcgCtMBlizzu7KxiRfflYeCQmMd17mYcB4Lei0ARNckh+y1OE+jLnetvC3oVVsKGHAJPa4H/G8Z6JD2L2EcDW3YOsBcGddv+qJcGiqd0enXyLPs2l8ZmxDMXXHfWIbivvENhT3iW0o7hPbUNx32CJmK9VgfnlgLUK+OXGJtjh27QZfL+CN9qb0v4gteau875AuvTF2YpuIDDewUHI2+cWLXSldtTelyxF958y7csCTYTuBsBX5gFt30cNF6jAX5qE9sRNnEoVk3f3Po5HiXSc2IFJASWZXFL5rzWFHgxG88UWp6DTtTWlB7oPYSblrTFZZ34tN6orNw3FsPDcanYykks5VM5PSTt5O78e34pUQb3DTVtgsAhkkyT7VN8lcLLjZTcgJxkpVp2lvSovXLCy2hd8vMQVZXgKT5SlI0ZsUM5lVrXSEkPOEwNc2Y+N0TsZS69rFBt5qvmhKhBYTj31K2ePP9ukYNiYBifEIjkJmTlHx1a/smeWni07T3pQ+hK0Gl6S1MvoJUWk7RWq11mEzXvCXNiQISToDtHTtYpOEvCy08xOPFxWa5DkgdfvmfnCRouaClF1xkSWx0uR0UYKq07Q/b0ofWqS1wmnONc8zxQg4I1rt2pEnh7eM2s5vnobfzyQtXXvYksoRRZkMBqhbdvYlHw6s+5Ew86IHnubsymDeOzQPLIMMMl+su/ai/WVT+tAjweDSxCILpdFqq46C7dIWYAlnXO7swOY1r59ZBeKVDz7IGRJnwP0mefAAoi/F5RImS07OCE7qOeSLRadpb0sfOoDEsjNaTtrZPsC26ijYlnaSIW8X1I2t1/6X427If4uRBtD0ANuqo2Brbc9PJQX92fZs2H63ndiG7MQ2ZCe2IXtubH/gT/HzE8zIJ5jzg99he5FV9Px2YhuyE9uQ/QCKWLfbysyAYgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0Njo1OC0wNjowMN3U6mMAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDY6NTgtMDY6MDCsiVLfAAAAH3RFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAAzMTB4MjgrMCsw+mOgmAAAABR0RVh0cGRmOlZlcnNpb24AUERGLTEuNQ1Ag1dMAAAAAElFTkSuQmCC" alt="图片/api/Token.png">
</div>
<p id="f_0081.html.N187E6">
我们通常不需要定义自己的 token 类型，但这是一个很有用的功能。下面是一个示例专门<code class="cf class">Token</code>实现，它向每个 token 对象添加一个字段：
</p><p>
We usually don’t need to define our own kind of tokens, but it’s a useful capability. Here’s
a sample specialized <code class="cf class">Token</code> implementation that adds a field to every token
object:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/MyToken.java">api/MyToken.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CharStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CommonToken;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenSource;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.misc.Pair;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** A Token that tracks the TokenSource name in each token. */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> MyToken <strong class="prompt">extends</strong> CommonToken {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">String</strong> srcName;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> MyToken(<strong class="prompt">int</strong> type, <strong class="prompt">String</strong> text) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        super(type, text);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> MyToken(Pair&lt;TokenSource, CharStream&gt; source, <strong class="prompt">int</strong> type,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                   <strong class="prompt">int</strong> channel, <strong class="prompt">int</strong> start, <strong class="prompt">int</strong> stop)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        super(source, type, channel, start, stop);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">String</strong> toString() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> t = super.toString();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> srcName +<em class="string">":"</em>+t;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0081.html.N18879">
为了让词法分析器创建这些特殊标记，我们需要创建一个工厂并将其传递给词法分析器。我们还会告诉解析器，以便其错误处理程序可以在必要时调用正确类型的标记。
</p><p>
To get the lexer to create these special tokens, we need to create a factory and pass it to the lexer. We also tell the parser so that its error handler can conjure up the right kind of tokens if necessary.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASUAAAAfCAAAAACEmoTUAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAALxSURBVGje7ZnBrSMhDEC5bAFz2AZogcsW4MM2MC1w3xOn1Z5WogVaoAW3gLQV0IJb8BqY5M/PTPLJz0RfkbCUBMYGm4dxZhLFQz4W9dUBvIQMSj0yKPXIoNQjJ0rePUH8Q6GlZ4R0j6QNJfUMN48lqoOvhQRuS+mZifpJSu6h4Q+LG5Tu8z8o9fgflHr8byjlWrlKK118RRUN3uXnMEriOnSOOQWZLhmX8Psm6aBEGAzihVUVbxHzqk8fIjuKUjABeylp2yghXKhQX1D66D7l9omLrrwyW2TxFz1xohC59EWyF5XsFJK1qdqJ+q+87zCrkyZ6lFLSdQoKEgpl9JQLiFWrKlIqsTBg6wslSkxewDRVwxYrQwouJ4W0jEQsQeI1/7uUhLh1UWdDtrT8zMZGnRgCJg4Q58h2xpi1xWrH2v6ynGG7TiVp/l19tryco2wN0iHojJNzxoZJVn1qnRWh0ARc+kCQSEcP3FQoRyRTkA8m4yIG5f4tI2e0npO5ixJgsGLjtUAKjoTSRGWLJoCQZSrIbVsMNTtWRGbJtAtKWn1T6ucn7+p+vKfkXWmhBCAwxOu59aaQIOW19AFiLRKamwpL/FImZlenKkteLDUXRJuidZuSZlfO1+9JnDrjvExckCRoeUbTMuFiF4ta76XSUZTaotyyeFlx7ZxbK0WltPSVMHGzO1li3doEwbpl/Wo1JZvlWPdSooo16z9OuFQeJUotacWFCUsK1wc0hGZHRT3DXik/6MRlXZ6ogmzGHHYorRSV0qlPOpVk5zUliVyGBmjRvY2US/aq/z1KKDXGzEbqs0yd9AwkKVOQSOJw1LMDKacgb1OodlXh9lLpqOpd/QFbkJXsUFopKqVzH6WyGniXS1FbOXEslz2DSeeRckLwuv+D7irJpL3LL3RXmbbbfDSlbPbvZl6HEurtNh9OKe9ffx1KaWcF4znuTv+DUo//QanH//hF96rs/KI7/h3YyvbfgSG3ZFDqkUGpRwalHvkPn4yW41iRATwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTMtMDEtMTVUMjI6NDY6NTgtMDY6MDDd1OpjAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEzLTAxLTE1VDIyOjQ2OjU4LTA2OjAwrIlS3wAAAB90RVh0cGRmOkhpUmVzQm91bmRpbmdCb3gAMjkzeDMxKzArMOa634kAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/api/TokenFactory.png">
</div>
<p id="f_0081.html.N18881">
这是一个创建对象的令牌工厂<code class="cf class">MyToken</code>：
</p><p>
Here’s a token factory that creates <code class="cf class">MyToken</code> objects:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/MyTokenFactory.java">api/MyTokenFactory.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CharStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenFactory;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenSource;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.misc.Interval;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.misc.Pair;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** A TokenFactory that creates MyToken objects */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> MyTokenFactory <strong class="prompt">implements</strong> TokenFactory&lt;MyToken&gt; {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    CharStream input;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> MyTokenFactory(CharStream input) { this.input = input; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> MyToken create(<strong class="prompt">int</strong> type, <strong class="prompt">String</strong> text) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> <strong class="prompt">new</strong> MyToken(type, text);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    @Override​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> MyToken create(Pair&lt;TokenSource, CharStream&gt; source, <strong class="prompt">int</strong> type,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                         <strong class="prompt">String</strong> text,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                         <strong class="prompt">int</strong> channel, <strong class="prompt">int</strong> start, <strong class="prompt">int</strong> stop, <strong class="prompt">int</strong> line,​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                         <strong class="prompt">int</strong> charPositionInLine)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        MyToken t = <strong class="prompt">new</strong> MyToken(source, type, channel, start, stop);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        t.setLine(line);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        t.setCharPositionInLine(charPositionInLine);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        t.srcName = input.getSourceName();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">return</strong> t;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0081.html.N18926">
下面是一些通知词法分析器和解析器工厂的示例代码：
</p><p>
And here’s some sample code that notifies the lexer and parser of the factory:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/TestSimpleMyToken.java">api/TestSimpleMyToken.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLRInputStream input = <strong class="prompt">new</strong> ANTLRFileStream(args[0]);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SimpleLexer lexer = <strong class="prompt">new</strong> SimpleLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​MyTokenFactory factory = <strong class="prompt">new</strong> MyTokenFactory(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​lexer.setTokenFactory(factory);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CommonTokenStream tokens = <strong class="prompt">new</strong> CommonTokenStream(lexer);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// now, print all tokens</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tokens.fill();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">List</strong>&lt;Token&gt; alltokens = tokens.getTokens();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">for</strong> (Token t : alltokens) <strong class="prompt">System</strong>.out.println(t.toString());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// now parse</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​SimpleParser parser = <strong class="prompt">new</strong> SimpleParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.setTokenFactory(factory);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ParseTree t = parser.s();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">System</strong>.out.println(t.toStringTree(parser));​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0081.html.N1897B">
它重用了<code class="cf filename">SimpleParser.g4</code>之前的语法。以下是构建和测试序列：
</p><p>
It reuses the <code class="cf filename">SimpleParser.g4</code> grammar from before. Here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 SimpleParser.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac Simple*.java MyToken*.java TestSimpleMyToken.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java TestSimpleMyToken Simple-input</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@0,0:0='a',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@1,2:4='343',&lt;2&gt;,1:2]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@2,5:5='x',&lt;1&gt;,1:5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@3,7:9='abc',&lt;1&gt;,2:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@4,11:11='9',&lt;2&gt;,2:5]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@5,13:13=';',&lt;3&gt;,2:7]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Simple-input:[@6,15:14='&lt;EOF&gt;',&lt;-1&gt;,3:1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​(s a 343 x abc 9 ;)​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0081.html.N189B4"><code class="cf methodname">toString</code>中的方法
将前缀<code class="cf class">MyToken</code>添加
<code class="cf ic">Simple-input:</code>到正常的标记字符串表示中。
</p><p>
The <code class="cf methodname">toString</code> method in <code class="cf class">MyToken</code> adds the
<code class="cf ic">Simple-input:</code> prefix to the normal token string representation.
</p>

</div></div>
<div id="f_0082.html"><div>

<h2 id="f_0082.html.N189C3">13.5 分析树</h2><h2>13.5 Parse Trees</h2>
<p id="f_0082.html.N189C7">
接口<code class="cf class">Tree</code>定义了具有有效负载和子节点的树的基本概念。<code class="cf class">SyntaxTree</code>是一棵树，它知道如何将树节点与 中的标记关联起来<code class="cf class">TokenStream</code>。更具体地说，接口
<code class="cf class">ParseTree</code>表示解析树中的节点。它知道如何返回与树中其下方的所有叶节点关联的文本。我们在第 2.4 节“<a href="#f_0018.html.sec.parse-trees"><em>使用解析树</em></a><a href="#f_0018.html.sec.parse-trees">构建中看到了示例解析树，<em></em></a>以及节点如何与此类层次结构中的类型相对应。<code class="cf class">ParseTree</code>还为 提供了常用的访问者模式双分派
<code class="cf methodname">accept</code>方法<code class="cf class">ParseTreeVisitor</code>，我们在第 2.5 节<a href="#f_0019.html.sec.listeners-and-visitors">“解析<em>树监听器和访问者”</em></a>中进行了介绍。
</p><p>
Interface <code class="cf class">Tree</code> defines the basic notion of a tree that has a payload and
children. A <code class="cf class">SyntaxTree</code> is a tree that knows how to associate tree nodes with
tokens in a <code class="cf class">TokenStream</code>. Getting more specific, interface
<code class="cf class">ParseTree</code> represents a node in a parse tree. It knows how to return the text
associated with all leaf nodes below it in the tree. We saw sample parse trees in Section 2.4, <a href="#f_0018.html.sec.parse-trees">​<em>Building Language Applications Using Parse Trees</em>​</a>, and how the nodes correspond to the types in this class
hierarchy. <code class="cf class">ParseTree</code> also provides the usual visitor pattern double-dispatch
<code class="cf methodname">accept</code> method for <code class="cf class">ParseTreeVisitor</code>, which we looked at in
Section 2.5, <a href="#f_0019.html.sec.listeners-and-visitors">​<em>Parse-Tree Listeners and Visitors</em>​</a>.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/api/Tree.png">
</div>
<p id="f_0082.html.N189EF">
类<code class="cf class">RuleNode</code>和<code class="cf class">TerminalNode</code>对应于子树根和叶节点。ANTLR<code class="cf class">ErrorNodeImpl</code>在单标记插入恢复期间创建节点（请参阅<a href="#f_0060.html.sec.mismatched-tokens"><em>从不匹配的标记中</em></a><a href="#f_0060.html.sec.mismatched-tokens">恢复）<em></em></a> 。
</p><p>
Classes <code class="cf class">RuleNode</code> and <code class="cf class">TerminalNode</code> correspond to
subtree roots and leaf nodes. ANTLR creates <code class="cf class">ErrorNodeImpl</code> nodes during
single-token-insertion recovery (see <a href="#f_0060.html.sec.mismatched-tokens">​<em>Recovering from Mismatched Tokens</em>​</a>).
</p>
<p id="f_0082.html.N189FE">
A<code class="cf class">RuleContext</code>是单个规则调用的记录，通过遍历链来了解哪个上下文调用了它（如果有）<code class="cf methodname">getParent</code>。  <code class="cf class">ParserRuleContext</code>如果解析器正在创建树，则有一个字段用于跟踪解析树子项。这些主要是实现类，因此您可以专注于 ANTLR 为语法中的每条规则生成的专门子类。
</p><p>
A <code class="cf class">RuleContext</code> is a record of a single rule invocation and knows which context
invoked it, if any, by walking up the <code class="cf methodname">getParent</code> chain.  <code class="cf class">ParserRuleContext</code> has a field to track parse-tree children, if the parser is creating trees. These are primarily implementation classes so you can focus on the specialized subclasses that ANTLR generates for each rule in your grammar.
</p>

</div></div>
<div id="f_0083.html"><div>

<h2 id="f_0083.html.N18A0D">13.6 错误监听器和策略</h2><h2>13.6 Error Listeners and Strategies</h2>
<p id="f_0083.html.N18A11">
有两个关键接口与 ANTLR 的语法错误机制相关：<code class="cf class">ANTLRErrorListener</code>和。我们在 9.2 节“<a href="#f_0059.html.sec.error-listeners">更改</a><a href="#f_0059.html.sec.error-listeners"><em>和重定向 ANTLR 错误消息”</em></a><code class="cf class">ANTLRErrorStrategy</code>中了解了前者，在 9.5 节<a href="#f_0062.html.sec.error-handling">“更改</a><a href="#f_0062.html.sec.error-handling"><em>ANTLR 的错误处理策略”</em></a>中了解了后者<a href="#f_0062.html.sec.error-handling">。</a>侦听器让我们可以更改错误消息及其去向。策略实现会更改解析器对错误的反应方式。
<a href="#f_0059.html.sec.error-listeners"><em></em></a><a href="#f_0062.html.sec.error-handling"><em></em></a></p><p>
There are two key interfaces associated with ANTLR’s syntax error mechanism: <code class="cf class">ANTLRErrorListener</code> and <code class="cf class">ANTLRErrorStrategy</code>. We learned about the former in Section 9.2, <a href="#f_0059.html.sec.error-listeners">​<em>Altering and Redirecting ANTLR Error Messages</em>​</a>, and the latter in Section 9.5, <a href="#f_0062.html.sec.error-handling">​<em>Altering ANTLR’s Error Handling Strategy</em>​</a>. Listeners let us alter error messages and where they go. Strategy implementations alter how parsers react to errors.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/api/ANTLRErrorListener.png">
</div>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcoAAAAjCAAAAAAxyxX+AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAARvSURBVGje7ZrPrewmFMa9SDbJJk4JtIDSAYs0gJTs3gqlA1ZRtigd0AKbVwAtIL0KaIEWTr4D4/tn7njujO145lkc2R4wGL7hdzjYlgfqdhAbHi2g21bWUR7GOsrDWEd5GOsoD2Md5WGsozyMvaB09iHm7hGbHqEwrRjdXQRPAl9QDo8YJmvvigpW7S9Q2RUo9xD8IvAV5QrFK+w+lGuGdaGt6nMPwbaj3KPPjvJT1TtaR3mrdZSbCbyIMnqijJ18ritrDkiXeq/EJ+KH5rz1C4UsQ1ncWxVevuk9tTqs84KmfPcd6TYoIdiVkwQHjTPyFuj7BKVSeDgZM5Eo0csYHdd2JirHx5g/tGaio/KWcIl0my1DGWUMRpapjfKmTmTt+BGXxiqLECK9ewD67GloG5QQ7McmM1tovCxvib7rKK0XREZbSpoooKZhMDhE3ZKpeGxcljlNI84VY1I9mZ3NnKHAfpisLxns59DWbm/l/joyinMGzo4Ok4wlYJKWxMpQlIZYao2SYqy7hxROeG6AiznD17QMt8Jt5ZzKuZraZyo3KrwmWEU6yQRKlseSvkIIrdF3FWWRJIlkHolbZudR/E9ULjKS8jGRMB4bGRtErglT4FAmctqroANnjHWarI4qRENZzaIMf/403MjyPco8FhGcIi/sNw+3b8OFox9s5nyKo47YvwrvReZMFra0YpzlazjzrbZSUGkMBtFPnvWZnRi+rEUpo0UfJ5lAyfIIKv6FqrJG31WUgKeAi7Rnt4Av1VlHoxox2UcODIho2LxBXVejm0U0lvVklgwdGW+L03V0E3zDzM7Kn38chl/+uO1p+Pd3KMvA0R4BRHFA1/YFJf+XGsG4EDuvD1hbBeO3wrfidg3Xba24Gn0wTmeB78uvww/D8Nuyx/dXwcIaTIiTzCnAolsWskrfNZRFKCUiYmvQipdLTHIeOByCbknEWWxkcTNk/tZTe6Kd9FRGvspKLPTcLedmJ+UalEFbbfmPIKQqb85QqlM17LYNVdOQxKm4XsN1Wyu1UiSZxPtg+tc2KBW7/SRzCrA1Sev0XUPJww+XQQUha7StcZYP4FiTcBDXQm8W/7SGrEPn1XECuSqwOg8CLnKk1WwEXR5gM+4kTM2hM4cyDAKJSyg9XEz701DlaajqNVy3tcKVBAKaMud9bhJgeRRc7fIjylX6rqBkdiDGsZUpRI6imKeJ56CoyYgk57LUsp7WSqmSRs/pIDQWBWSS0DgpNHuWnZ2US297RqWwkJCRqs7KIPguTUul24opE9dQJ5RkFAaAE0Ei4NTi6RrOtFbw17AMlPHSXcX6255RSdO6bChZ3oRylb4dXxFgmhY5/6z0VK8IoDOde90zvSK4pG8vlNYajdl75f3B86BU1mBqiHOvexqUM/r2QpkjvyDKV2o8D8qqNX18/fEsKGf09Xew+/T5+HewO1pHuZnAjvL/7PNBKDf7QuEu6x+EbCawf6b1mX1/n2l1+96tozyMdZSHsY7yMNZRHsb+A9JaPNsscoLRAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDEzLTAxLTE1VDIyOjQ2OjU5LTA2OjAwe6Ph1wAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxMy0wMS0xNVQyMjo0Njo1OS0wNjowMAr+WWsAAAAfdEVYdHBkZjpIaVJlc0JvdW5kaW5nQm94ADQ1OHgzNSswKzCleuZMAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS41DUCDV0wAAAAASUVORK5CYII=" alt="图片/api/ANTLRErrorStrategy.png">
</div>
<p id="f_0083.html.N18A3C">
ANTLR<code class="cf class">RecognitionException</code>根据错误抛出特定的异常。请注意，它们是未经检查的运行时异常，因此您不必<code class="cf keyword">throws</code>  在方法中一直指定子句。
</p><p>
ANTLR throws specific <code class="cf class">RecognitionException</code>s according to the error. Note that they are unchecked runtime exceptions, so you don’t have to specify <code class="cf keyword">throws</code>  clauses all the time in your methods.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/api/RuntimeException.png">
</div>

</div></div>
<div id="f_0084.html"><div>

<h2 id="f_0084.html.sec.maximizing-speed">13.7 最大化解析器速度</h2><h2>13.7 Maximizing Parser Speed</h2>
<p id="f_0084.html.N18A4F">
ANTLR v4 的自适应解析策略比 v3 的更强大，但是是以牺牲一点速度为代价的。如果您需要最快的速度和尽可能最小的内存占用，您可以采用两步解析策略。第一步使用稍微弱一点的解析策略<span class="emph">SLL(*)</span>，它几乎总是有效。（它与 v3 的策略非常相似，只是不需要回溯。）如果第一步解析失败，您必须尝试完整的<span class="emph">LL(*)</span>解析。第一步失败后，我们不知道这是真正的语法错误还是因为<span class="emph">SLL(*)</span>策略不够强大。通过<span class="emph">SLL(*)</span>步骤的输入保证通过完整的
<span class="emph">LL(*)</span>，因此尝试这种更昂贵的策略是没有意义的。
</p><p>
ANTLR v4’s adaptive parsing strategy is more powerful than v3’s, but it comes at the cost of
a little bit of speed. If you need the most speed and the smallest memory footprint
possible, you can do a two-step parsing strategy. The first step uses a slightly weaker
parsing strategy, <span class="emph">SLL(*)</span>, that almost always works. (It’s very similar to v3’s
strategy, except it doesn’t need to backtrack.) If the first parsing step fails, you have to
try the full <span class="emph">LL(*)</span> parse. After failing the first step, we don’t know whether
it’s a true syntax error or whether it’s because the <span class="emph">SLL(*)</span> strategy wasn’t strong enough.
Input that passes the <span class="emph">SLL(*)</span> step is guaranteed to pass the full
<span class="emph">LL(*)</span>, so there’s no point in trying out that more expensive strategy.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.getInterpreter().setSLL(true); <em class="comment">// try with simpler/faster SLL(*)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// we don't want error messages or recovery during first try</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.removeErrorListeners();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​parser.setErrorHandler(<strong class="prompt">new</strong> BailErrorStrategy());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">try</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    parser.startRule();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// if we get here, there was no syntax error and SLL(*) was enough;</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// there is no need to try full LL(*)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">catch</strong> (RuntimeException ex) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">if</strong> (ex.getClass() == RuntimeException.class &amp;&amp;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ex.getCause() <strong class="prompt">instanceof</strong> RecognitionException)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// The BailErrorStrategy wraps the RecognitionExceptions in</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// RuntimeExceptions so we have to make sure we're detecting</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// a true RecognitionException not some other kind</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        tokens.reset(); <em class="comment">// rewind input stream</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// back to standard listeners/handlers</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.addErrorListener(ConsoleErrorListener.INSTANCE);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.setErrorHandler(<strong class="prompt">new</strong> DefaultErrorStrategy());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.getInterpreter().setSLL(false); <em class="comment">// try full LL(*)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.startRule();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0084.html.N18AE6">
未通过第二步的输入确实在语法上无效。
</p><p>
Input that fails the second step is truly syntactically invalid.
</p>

</div></div>
<div id="f_0085.html"><div>

<h2 id="f_0085.html.N18AE9">13.8 无缓冲字符和标记流</h2><h2>13.8 Unbuffered Character and Token Streams</h2>
<p id="f_0085.html.N18AED">
由于 ANTLR 识别器默认缓冲整个输入字符流和所有输入标记，因此它们无法处理大于计算机内存的输入文件，也无法处理套接字连接等无限流。为了解决这个问题，您可以使用字符和标记流的非缓冲版本，这些版本只会在流中保留一个小的滑动窗口：<code class="cf class">UnbufferedCharStream</code>和<code class="cf class">UnbufferedTokenStream</code>。
</p><p>
Because ANTLR recognizers buffer up the entire input character stream and all input tokens by default, they can’t handle input files that are bigger than a computer’s memory and can’t handle infinite streams like socket connections. To overcome this, you can use unbuffered versions of the character and token streams, which keep just a small sliding window into the streams: <code class="cf class">UnbufferedCharStream</code> and <code class="cf class">UnbufferedTokenStream</code>.
</p>
<p id="f_0085.html.N18B15"><a href="#f_0040.html.sec.CSV">为了演示，下面是对第 6.1 节“解析<em>逗号</em></a>
分隔值”中逗号分隔值语法的修改，<a href="#f_0040.html.sec.CSV">该语法</a>对两列文件中的浮点值进行求和：
</p><p>
As a demonstration, here’s a modification of the comma-separated-value grammar from Section 6.1, <a href="#f_0040.html.sec.CSV">​<em>Parsing Comma-Separated Values</em>​</a> that sums the floating-point values in a two-column file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/CSV.g4">api/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Rows are two real numbers:</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">    0.9962269825793676, 0.9224608616182103</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">    0.91673278673353,  -0.6374985722530822</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">    0.9841464019977713, 0.03539546030010776</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">    ...</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> CSV;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@members</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​double x, y; <em class="comment">// keep column sums in these fields</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file: row+ {System.out.printf(<em class="string">"%f, %f\n"</em>, x, y);} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row : a=field <em class="string">','</em> b=field <em class="string">'\r'</em>? <em class="string">'\n'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      x += Double.valueOf($a.start.getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      y += Double.valueOf($b.start.getText());​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : TEXT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TEXT : ~[,\n\r]+ ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0085.html.N18B85">
如果您只关心列的总和，则一次只需在内存中保留一个或两个标记。为了防止完全缓冲，有三件事要做。首先，使用无缓冲流而不是通常的<code class="cf class">ANTLFileStream</code>和
<code class="cf class">CommonTokenStream</code>。其次，将一个标记工厂传递给词法分析器，该工厂将字符从输入流复制到标记的文本中。否则，
标记的方法将尝试访问输入字符流，而该流可能不再可用。（请参见第 2.4 节“<a href="#f_0018.html.sec.parse-trees"><em>使用解析树</em></a><a href="#f_0018.html.sec.parse-trees">构建</a><code class="cf methodname">getText</code>中的图表，<a href="#f_0018.html.sec.parse-trees">其中</a>显示了标记和字符流之间的关系。）最后，要求解析器不要创建解析树。以下测试装置突出显示了关键行：
<a href="#f_0018.html.sec.parse-trees"><em></em></a></p><p>
If all you care about are the sums of the columns, you  need to keep only one or two tokens
in memory at once. To prevent complete buffering, there are three things to do. First, use
the unbuffered streams instead of the usual <code class="cf class">ANTLFileStream</code> and
<code class="cf class">CommonTokenStream</code>. Second, pass the lexer a token factory that copies
characters from the input stream into the text of the tokens. Otherwise, the
<code class="cf methodname">getText</code> method for tokens would try to access the input character stream,
which probably would no longer be available. (See the diagram in Section 2.4, <a href="#f_0018.html.sec.parse-trees">​<em>Building Language Applications Using Parse Trees</em>​</a> that shows the relationship between tokens and the character
stream.) Finally, ask the parser not to create parse trees. The following test rig has the
key lines highlighted:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/api/TestCSV.java">api/TestCSV.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CharStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CommonToken;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.CommonTokenFactory;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.Token;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.TokenStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.UnbufferedCharStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> org.antlr.v4.runtime.UnbufferedTokenStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.io.FileInputStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.io.InputStream;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> TestCSV {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">void</strong> main(<strong class="prompt">String</strong>
<strong class="prompt">[]</strong> args) <strong class="prompt">throws</strong> Exception {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">String</strong> inputFile = null;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( args.length&gt;0 ) inputFile = args[0];​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">InputStream</strong> is = <strong class="prompt">System</strong>.in;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">if</strong> ( inputFile!=null ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            is = <strong class="prompt">new</strong> <strong class="prompt">FileInputStream</strong>(inputFile);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CharStream input = <strong class="prompt">new</strong> UnbufferedCharStream(is);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CSVLexer lex = <strong class="prompt">new</strong> CSVLexer(input);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// copy text out of sliding buffer and store in tokens</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        lex.setTokenFactory(<strong class="prompt">new</strong> CommonTokenFactory(true));​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        TokenStream tokens = <strong class="prompt">new</strong> UnbufferedTokenStream&lt;CommonToken&gt;(lex);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        CSVParser parser = <strong class="prompt">new</strong> CSVParser(tokens);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">*&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.setBuildParseTree(false);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        parser.file();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0085.html.N18C42">
以下是使用 1,000 行示例文件的示例构建和测试序列：
</p><p>
Here’s a sample build and test sequence using a 1,000-line sample file:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 CSV.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac TestCSV.java CSV*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">wc sample.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    1000    2000   39933 sample.csv # 1000 lines, 2000 words, 39933 char​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">java TestCSV sample.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​1000.542053, 1005.587845​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0085.html.N18C6C">
为了验证识别器没有缓冲所有内容，我将一个包含 7.8M 个值对的 310M CSV 输入文件运行到测试装置中，同时将 Java VM 限制为仅 10M RAM。
</p><p>
To verify that the recognizer is not buffering up everything, I ran a 310M CSV input file with 7.8M value pairs into the test rig while restricting the Java VM to just 10M RAM.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">wc big.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ 7800000 15600000 310959090 big.csv # 7800000 lines, ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">time java -Xmx10M TestCSV big.csv</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​11695395.953785, 7747174.349207​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​real    0m43.415s # wall clock duration to compute the sums​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​user    0m51.186s​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​sys     0m6.195s​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0085.html.N18C95">
当效率是首要考虑因素时，这些无缓冲流非常有用。（您甚至可以将它们与上一节中的技术相结合。）它们的缺点是您必须手动缓冲。例如，您不能<code class="cf ic">$text</code>在规则中嵌入的操作中使用，因为它会转到输入流并请求文本（并且文本没有被缓冲）。

</p><p>
These unbuffered streams are useful when efficiency is the top concern. (You can even
combine them with the technique from the previous section.) Their disadvantage is that you
are forced to buffer things up manually. For example, you can’t use <code class="cf ic">$text</code> in an
action embedded within a rule because it goes to the input stream and asks for the text
(and the text isn’t being buffered).

</p>

</div></div>
<div id="f_0086.html"><div>

<h2 id="f_0086.html.N18CA4">13.9 改变ANTLR的代码生成</h2><h2>13.9 Altering ANTLR’s Code Generation</h2>
<p id="f_0086.html.N18CA8">
ANTLR 使用两个东西来生成代码：StringTemplate <a id="f_0086.html.FNPTR-54" href="#f_0086.html.FOOTNOTE-54">[54]</a>组文件（包含模板）和一个<code class="cf class">Target</code>名为<span class="standin">Language</span>
<code class="cf ic">Target</code>的子类，其中
<span class="standin">Language</span>是语法<code class="cf keyword">language</code>选项。StringTemplate 组文件是
  <code class="cf dir">org/antlr/v4/</code>
<code class="cf dir">tool/templates/codegen/</code>
<span class="standin">Language</span>
<code class="cf ic">.stg</code>。如果您想要调整代码生成模板（例如 Java），您所要做的就是复制和修改<code class="cf filename">org/antlr/v4/tool/</code>
<code class="cf filename">templates/codegen/Java.stg</code>。然后，将其放入ANTLR<code class="cf variable">CLASSPATH</code>&nbsp;<span class="emph">之前</span>的 jar 中。ANTLR 使用资源加载器来获取这些模板，因此它会首先看到您修改后的版本。
</p><p>
ANTLR uses two things to generate code: a StringTemplate<a href="#f_0086.html.FOOTNOTE-54">[54]</a> group file (containing templates)
and a <code class="cf class">Target</code> subclass called <span class="standin">Language</span>
<code class="cf ic">Target</code> where
<span class="standin">Language</span> is the grammar <code class="cf keyword">language</code> option. The
StringTemplate group file is
  <code class="cf dir">org/antlr/v4/</code>
<code class="cf dir">tool/templates/codegen/</code>
<span class="standin">Language</span>
<code class="cf ic">.stg</code>. If
you would like to tweak the code generation templates for, say, Java, all you have to do is
copy and modify <code class="cf filename">org/antlr/v4/tool/</code>
<code class="cf filename">templates/codegen/Java.stg</code>. Then, put
it in the <code class="cf variable">CLASSPATH</code>&nbsp;<span class="emph">before</span> ANTLR’s jar. ANTLR uses a
resource loader to get those templates so it’ll see your modified version first.
</p>
<p id="f_0086.html.N18CE0">
模板仅生成特定于语法的代码。大多数常用功能已被分解到运行时库中。因此，<code class="cf class">Lexer</code>等等<code class="cf class">Parser</code>
都是运行时库的一部分，而不是由 ANTLR 生成的。
</p><p>
The templates just generate code specific to a grammar. Most of the common functionality has
been factored out into the runtime library. So, <code class="cf class">Lexer</code>, <code class="cf class">Parser</code>
and so on are all part of the runtime library, not generated by ANTLR.
</p>
<p id="f_0086.html.N18CE9">
要为语言<span class="standin">L</span>添加新目标，您可能需要创建类
<span class="standin">L。</span>
<code class="cf ic">Target</code>如果是这样，请将其放在包中
<code class="cf dir">org.antlr.v4.codegen</code>，并将其放在 中 ANTLR 的 jar 之前
<code class="cf variable">CLASSPATH</code>。只有当您的目标需要更改 中的某些默认功能时，才需要此类<code class="cf class">Target</code>。如果未
找到
<span class="standin">L</span>
类，ANTLR 将使用基类。（这是它对 Java 语言目标所做的。）
<code class="cf ic">Target</code><code class="cf class">Target</code></p><p>
To add a new target for language <span class="standin">L</span>, you might need to create class
<span class="standin">L</span>
<code class="cf ic">Target</code>. If so, place it in package
<code class="cf dir">org.antlr.v4.codegen</code> and put it before ANTLR’s jar in the
<code class="cf variable">CLASSPATH</code>. You need this class only if your target needs to alter some
of the default functionality in <code class="cf class">Target</code>. If no
<span class="standin">L</span>
<code class="cf ic">Target</code> class is found, ANTLR uses the
<code class="cf class">Target</code> base class. (This is what it does for the Java language target.)
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0086.html.FOOTNOTE-51" href="#f_0077.html.FNPTR-51">[51]</a>
</td>
<td>
<p id="f_0086.html.N184C5">
<a href="http://www.antlr.org/api">http://www.antlr.org/api</a>
</p><p>
<a href="http://www.antlr.org/api">http://www.antlr.org/api</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0086.html.FOOTNOTE-52" href="#f_0078.html.FNPTR-52">[52]</a>
</td>
<td>
<p id="f_0086.html.N1853D">
<a href="http://en.wikipedia.org/wiki/Augmented_transition_network">http://en.wikipedia.org/wiki/Augmented_transition_network</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Augmented_transition_network">http://en.wikipedia.org/wiki/Augmented_transition_network</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0086.html.FOOTNOTE-53" href="#f_0078.html.FNPTR-53">[53]</a>
</td>
<td>
<p id="f_0086.html.N1854F">
<a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">http://en.wikipedia.org/wiki/Deterministic_finite_automaton</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">http://en.wikipedia.org/wiki/Deterministic_finite_automaton</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0086.html.FOOTNOTE-54" href="#f_0086.html.FNPTR-54">[54]</a>
</td>
<td>
<p id="f_0086.html.N18CB1">
<a href="http://www.stringtemplate.org/">http://www.stringtemplate.org</a>
</p><p>
<a href="http://www.stringtemplate.org">http://www.stringtemplate.org</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0087.html"><div>

<h1 class="chapter-title" id="f_0087.html.chp.left-recursion-removal">
<span class="chapter-number">
	      第十四章</span>
<br><br>
<span class="chapter-name">删除直接左递归</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      14</span>
<br><br>
<span class="chapter-name">Removing Direct Left Recursion</span>
</h1>

<p id="f_0087.html.N18D14">
在第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em>中，</a>我们看到，在语法上指定算术表达式的自然方式是模棱两可的。例如，以下内容<code class="cf keyword">expr</code>
可以解释<code class="cf ic">1+2*3</code>为<code class="cf ic">(1+2)*3</code>或<code class="cf ic">1+(2*3)</code>。但是，通过优先考虑首先指定的替代方案，ANTLR 巧妙地避开了歧义。
</p><p>
In Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>, we saw that the natural way to specify arithmetic
expressions grammatically is ambiguous. For example, the following <code class="cf keyword">expr</code>
can interpret <code class="cf ic">1+2*3</code> as <code class="cf ic">(1+2)*3</code> or <code class="cf ic">1+(2*3)</code>. By giving precedence to
the alternatives specified first, however, ANTLR neatly sidesteps the ambiguity.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/left-recursion-removal/Expr.g4">左递归消除/Expr.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: expr <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   expr <em class="string">'*'</em> expr       <em class="comment">// precedence 4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   expr <em class="string">'+'</em> expr       <em class="comment">// precedence 3</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   INT                 <em class="comment">// primary (precedence 2)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ID                  <em class="comment">// primary (precedence 1)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0087.html.N18D55">
不过，规则<code class="cf keyword">expr</code>仍然是左递归的，传统的自上而下的语法（例如 ANTLR v3）无法处理。在本章中，我们将探讨 ANTLR 如何处理左递归以及它如何处理运算符优先级。简而言之，ANTLR 用比较<code class="cf ic">(...)*</code>前一个和下一个运算符的优先级的运算符替换了左递归。 
</p><p>
Rule <code class="cf keyword">expr</code> is still left-recursive, though, which traditional top-down
grammars (for example, ANTLR v3) cannot handle. In this chapter, we’re going to explore how ANTLR
deals with left recursion and how it handles operator precedence.  In a nutshell, ANTLR
replaces left recursion with a <code class="cf ic">(...)*</code> that compares the precedence of the previous
and next operators. 
</p>
<p id="f_0087.html.N18D64">
熟悉规则转换很重要，因为生成的代码反映的是转换后的规则，而不是原始规则。更重要的是，当语法没有为运算符提供预期的分组或结合性时，我们需要知道原因。大多数用户可以在下一节展示有效的递归替代模式后停止阅读；对实现细节感兴趣的高级用户可以继续阅读第二节。
</p><p>
It’s important to get familiar with the rule transformation because the generated code
reflects the transformed rule, not the original. More importantly, when a grammar doesn’t give
the expected grouping or associativity for operators, we need to know why. Most users can
stop reading after the next section that shows the valid recursive alternative patterns;
advanced users interested in the implementation details can continue to the second section.
</p>
<p id="f_0087.html.N18D67">
我们首先来看一下 ANTLR 所进行的转换，然后通过一个例子来观察<span class="firstuseinline">优先级攀升的</span>实际过程。<a id="f_0087.html.FNPTR-55" href="#f_0089.html.FOOTNOTE-55">[55]</a>
</p><p>
Let’s start by looking at the transformations that ANTLR performs and then walk through
an example to see the <span class="firstuseinline">precedence climbing</span> in
action.<a href="#f_0089.html.FOOTNOTE-55">[55]</a>
</p>

</div></div>
<div id="f_0088.html"><div>

<h2 id="f_0088.html.N18D7D">14.1 直接左递归替代模式</h2><h2>14.1 Direct Left-Recursive Alternative Patterns</h2>
<p id="f_0088.html.N18D81">
		
		ANTLR 检查任何左递归规则，寻找四个子表达式运算符模式之一。
		</p><p>
		
		ANTLR examines any left-recursive rule looking for one of four subexpression operator
        patterns.
		</p>
<dl>
<dt>
<span class="emph">二进制</span>
</dt><dt>
<span class="emph">binary</span>
</dt>
<dd>
<p id="f_0088.html.N18D8B">
		任何形式为<code class="cf keyword">expr</code>&nbsp;<span class="standin">op</span>&nbsp;<code class="cf keyword">expr</code>或
<code class="cf keyword">expr</code>&nbsp;<code class="cf ic">(</code>
<span class="standin">op1</span> | <span class="standin">op2</span> |...| <span class="standin">opN</span>
<code class="cf ic">)</code>&nbsp;<code class="cf keyword">expr</code>的替代方法。
 <span class="standin">op</span>可以是单标记或多标记运算符。 例如，Java 语法可能会单独处理尖括号，而不是将运算符<code class="cf ic">&lt;=&gt;</code>和<code class="cf ic">&gt;=</code>视为单个标记。 以下是处理相同优先级的比较运算符的替代方法：
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | expr (<em class="string">'&lt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0088.html.N18DDA">
<span class="standin">op</span>也可以是规则引用。例如，我们可以将这些标记分解到另一条规则中。
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | expr compareOps expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​compareOps : (<em class="string">'&lt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em>) ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
		Any alternative of the form <code class="cf keyword">expr</code>&nbsp;<span class="standin">op</span>&nbsp;<code class="cf keyword">expr</code> or
<code class="cf keyword">expr</code>&nbsp;<code class="cf ic">(</code>
<span class="standin">op1</span>|<span class="standin">op2</span>|...|<span class="standin">opN</span>
<code class="cf ic">)</code>&nbsp;<code class="cf keyword">expr</code>.
<span class="standin">op</span> can be a single-token or multitoken operator. For example, a Java grammar might treat angle brackets individually instead of treating operators <code class="cf ic">&lt;=&gt;</code> and <code class="cf ic">&gt;=</code> as single tokens. Here’s an alternative that handles comparison operators at the same precedence level:
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr: ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | expr (<em class="string">'&lt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em>) expr​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
</tbody></table>
<p>
<span class="standin">op</span> can also be a rule reference. For example, we can factor out those tokens into another rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr: ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | expr compareOps expr​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​compareOps : (<em class="string">'&lt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> <em class="string">'='</em> | <em class="string">'&gt;'</em> | <em class="string">'&lt;'</em>) ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<span class="emph">三元</span>
</dt><dt>
<span class="emph">ternary</span>
</dt>
<dd>
<p id="f_0088.html.N18E0F">
		  任何形式为<code class="cf keyword">expr</code>&nbsp;<span class="standin">op1 </span>&nbsp;<code class="cf keyword">expr</code>&nbsp;<span class="standin">op2</span>&nbsp;<code class="cf keyword">expr</code>的替代项。<span class="standin">op1</span>和<span class="standin">op2</span>必须是单标记引用。此模式处理<code class="cf ic">?:</code>C 派生语言中的运算符：  
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | expr <em class="string">'?'</em> expr <em class="string">':'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
		  Any alternative of the form <code class="cf keyword">expr</code>&nbsp;<span class="standin">op1</span>&nbsp;<code class="cf keyword">expr</code>&nbsp;<span class="standin">op2</span>&nbsp;<code class="cf keyword">expr</code>. <span class="standin">op1</span> and <span class="standin">op2</span> must be single-token references.  This pattern handles the <code class="cf ic">?:</code> operator in C-derived languages:  
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr: ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | expr <em class="string">'?'</em> expr <em class="string">':'</em> expr​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<span class="emph">一元前缀</span>
</dt><dt>
<span class="emph">unary prefix</span>
</dt>
<dd>
<p id="f_0088.html.N18E4B">
		任何形式为<span class="standin">元素</span>&nbsp;<code class="cf keyword">expr</code>的替代项。只要替代项不符合二进制或三元模式，ANTLR 就会将任何后跟尾部递归规则引用的元素序列识别为一元前缀运算。以下是两个带有前缀运算符的替代项：
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | <em class="string">'('</em> type <em class="string">')'</em> expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | (<em class="string">'+'</em>|<em class="string">'-'</em>|<em class="string">'++'</em>|<em class="string">'--'</em>) expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
		Any alternative of the form <span class="standin">elements</span>&nbsp;<code class="cf keyword">expr</code>. ANTLR recognizes any sequence of elements followed by a tail-recursive rule reference as a unary prefix operation, as long as the alternative does not fit the binary or ternary pattern.  Here are two alternatives with prefix operators:
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr: ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | <em class="string">'('</em> type <em class="string">')'</em> expr​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | (<em class="string">'+'</em>|<em class="string">'-'</em>|<em class="string">'++'</em>|<em class="string">'--'</em>) expr​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<span class="emph">一元后缀</span>
</dt><dt>
<span class="emph">unary suffix</span>
</dt>
<dd>
<p id="f_0088.html.N18E8D">
		  任何形式为<code class="cf keyword">expr</code>
<span class="standin">元素</span>的替代方案。与前缀模式一样，只要不符合二进制或三元模式，ANTLR 就可以识别具有直接左递归规则引用的替代方案，后跟任何元素序列。以下是两个带有后缀运算符的替代方案：</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | expr <em class="string">'.'</em> Identifier​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    | expr <em class="string">'.'</em> <em class="string">'super'</em> <em class="string">'('</em> exprList? <em class="string">')'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
		  Any alternative of the form <code class="cf keyword">expr</code>
<span class="standin">elements</span>. As with the prefix pattern, ANTLR recognizes alternatives with
          a direct left-recursive rule reference followed by any sequence of elements, as
          long as it doesn’t fit the binary or ternary pattern. Here are two alternatives with suffix operators:</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr: ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | expr <em class="string">'.'</em> Identifier​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    | expr <em class="string">'.'</em> <em class="string">'super'</em> <em class="string">'('</em> exprList? <em class="string">')'</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​   ...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
</dl>
<p id="f_0088.html.N18EC0">任何其他替代模式都被视为
        <span class="firstuseinline">主表达式</span>元素，如标识符或整数，但包括以下内容，<code class="cf ic">’(’ expr ’)’</code>因为它不适合运算符模式。这是有道理的，因为括号的整个目的是将封闭的表达式视为单个原子元素。这些“其他”替代方案实际上可以按任何顺序出现。ANTLR 会正确收集和处理它们。所有其他替代方案的顺序都很重要。以下是一些示例主表达式替代方案：
		</p><p> Any other alternative pattern is considered a
        <span class="firstuseinline">primary expression</span> element like an identifier or an integer
        but includes things like <code class="cf ic">’(’ expr ’)’</code> because it doesn’t fit an operator
        pattern. This makes sense because the whole point of parentheses is to treat the
        enclosed expression as a single atomic element. These “other” alternatives can
        actually appear in any order. ANTLR collects and deals with them properly. The
        order of all other alternatives matters. Here are a few sample primary expression
        alternatives:
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   literal​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   Identifier​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   type <em class="string">'.'</em> <em class="string">'class'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0088.html.N18EEC">
除非另有说明，ANTLR 假定所有运算符都是左结合的。换句话说，<code class="cf ic">1+2+3</code>像这样的组：<code class="cf ic">(1+2)+3</code>。但是，有些运算符是右结合的，例如赋值和指数运算，正如我们在第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em>中看到的那样。</a>要指定右结合性，请使用<code class="cf keyword">assoc</code>token 选项。
</p><p>
Unless otherwise specified, ANTLR assumes that all operators are left associative. In other words, <code class="cf ic">1+2+3</code> groups like this: <code class="cf ic">(1+2)+3</code>. Some operators, however, are right associative, such as assignment and exponentiation, as we saw in Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>.  To specify right associativity, use the <code class="cf keyword">assoc</code> token option.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: expr <em class="string">'^'</em>&lt;assoc=right&gt; expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | expr <em class="string">'='</em>&lt;assoc=right&gt; expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0088.html.N18F1F">
在下一节中，我们将了解 ANTLR 如何转换这些模式。
</p><p>
In the next section, we’ll take a look at how ANTLR translates these patterns.
</p>

</div></div>
<div id="f_0089.html"><div>

<h2 id="f_0089.html.N18F22">14.2 左递归规则变换</h2><h2>14.2 Left-Recursive Rule Transformations</h2>
<p id="f_0089.html.N18F26">
如果您打开ANTLR 命令行选项，您可以在日志文件中找到转换后的左递归规则。以下是前面显示的
规则和的<code class="cf commandoption">-Xlog</code>情况：<code class="cf keyword">stat</code><code class="cf keyword">expr</code><code class="cf filename">Expr.g4</code></p><p>
If you turn on the <code class="cf commandoption">-Xlog</code> ANTLR command-line option, you can find the transformed left-recursive rules in the log file. Here’s what happens to rules <code class="cf keyword">stat</code> and <code class="cf keyword">expr</code> from <code class="cf filename">Expr.g4</code> shown earlier:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// use "antlr4 -Xlog Expr.g4" to see transformed rules</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   expr[0] <em class="string">';'</em> ;  <em class="comment">// match an expr whose operators have any precedence</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr[int _p]           <em class="comment">// _p is expected minimum precedence level</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   ( INT          <em class="comment">// match primaries (non-operators)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        | ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// match operators as long as their precedence is at or higher than</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// expected minimum</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ( {4 &gt;= $_p}? <em class="string">'*'</em> expr[5]  <em class="comment">// * has precedence 4</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        | {3 &gt;= $_p}? <em class="string">'+'</em> expr[4]  <em class="comment">// + has precedence 3</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0089.html.N18F86">
哇哦！这真是一次巨大的转变。不必担心 ANTLR 如何将所有这些参数组合起来<code class="cf keyword">expr</code>。我们主要想了解一下这些谓词如何测试运算符优先级以指导解析并获得正确的分组。
</p><p>
Whoa! That’s quite a transformation.  Don’t worry about how ANTLR conjures up all of those parameters to <code class="cf keyword">expr</code>.  We’re mainly interested in learning a bit about how those predicates test operator precedence to direct the parse and get the right groupings.
</p>
<p id="f_0089.html.N18F8C">
关键在于决定是否匹配当前调用的下一个运算符
<code class="cf keyword">expr</code>，或者让调用的调用<code class="cf keyword">expr</code>匹配下一个运算符。<code class="cf ic">(...)*</code>循环匹配运算符和右操作数对。对于输入
<code class="cf ic">1+2*3</code>，循环将匹配<code class="cf ic">+2</code>和<code class="cf ic">*3</code>。循环替代方案中的谓词的目的是决定解析器是否应立即匹配运算符/操作数对或退出当前的调用
<code class="cf keyword">expr</code>。例如，如果加法运算符的优先级 3 低于当前子表达式的
<code class="cf ic">{3 &gt;= $_p}?</code>预期最小优先级，则谓词将停用加法替代方案。<code class="cf variable">_p</code></p><p>
The key is deciding whether to match the next operator in the current invocation of
<code class="cf keyword">expr</code> or to let the calling invocation of <code class="cf keyword">expr</code> match the
next operator. The <code class="cf ic">(...)*</code> loop matches operator and right operand pairs. For input
<code class="cf ic">1+2*3</code>, the loop would match <code class="cf ic">+2</code> and <code class="cf ic">*3</code>. The purpose of the
predicates in the loop alternatives is to decide whether the parser should match the
operator/operand pair immediately or fall out of the current invocation of
<code class="cf keyword">expr</code>.  For example, predicate <code class="cf ic">{3 &gt;= $_p}?</code> deactivates the addition
alternative if the addition operator’s precedence, 3, is below the expected minimum
precedence, <code class="cf variable">_p</code>, for the current subexpression.
</p>
<div class="sidebar" id="f_0089.html.sb.thisAintOperatorPrecedenceParsing">
<div class="sidebar-title">这不是运算符优先级解析</div>
<div class="sidebar-content">
<p id="f_0089.html.N18FAF">
不要将此机制与<span class="firstuseinline">运算符优先级解析</span>相混淆，不管你在维基百科上读到的是什么。<a id="f_0089.html.FNPTR-56" href="#f_0089.html.FOOTNOTE-56">[56]</a>
运算符优先级解析无法处理具有两个不同优先级的减号之类的东西，一个用于一元否定，一个用于二元减法运算符。它也无法处理具有两个相邻规则引用的替代方案，例如
<code class="cf ic">expr ops expr</code>。请参阅<em>编译器：原理、技术和工具</em>&nbsp;[ALSU06] 以获取真正的定义。
</p><p>
Don’t confuse this mechanism with <span class="firstuseinline">operator precedence parsing</span>, despite
what you read on Wikipedia.<a href="#f_0089.html.FOOTNOTE-56">[56]</a>
Operator precedence parsing can’t handle things like the minus sign that has two different
precedences, one for unary negation and one for binary subtraction operators. It
 also can’t handle alternatives that have two adjacent rule references like
<code class="cf ic">expr ops expr</code>. See <em>Compilers: Principles, Techniques, and Tools </em>&nbsp;[ALSU06] to get the real definition.
</p>
</div>
</div>
<p id="f_0089.html.N18FCD">
参数<code class="cf variable">_p</code>的值始终来自前一个运算符的优先级。<code class="cf variable">_p</code>从 0 开始，因为非递归调用传递
<code class="cf keyword">expr</code>0，例如<code class="cf keyword">stat</code>：<code class="cf keyword">expr[0]</code>。要查看<code class="cf variable">_p</code>实际操作，让我们查看一些从转换后的规则派生的解析树（在方括号中显示参数的值<code class="cf variable">_p</code>）。请注意，这些解析树不是 ANTLR 从原始左递归规则为我们构建的。这些是转换后的规则的解析树，而不是原始规则的解析树。以下是一些示例输入和关联的解析树：
</p><p>
Parameter <code class="cf variable">_p</code>’s value is always derived from the precedence of the
previous operator. <code class="cf variable">_p</code> starts at 0, since nonrecursive calls to
<code class="cf keyword">expr</code> pass 0, like <code class="cf keyword">stat</code> does: <code class="cf keyword">expr[0]</code>. To see <code class="cf variable">_p</code> in
action, let’s look at some parse trees derived from the
transformed rule (showing the value of parameter <code class="cf variable">_p</code> in square
brackets). Note that these parse trees are not what ANTLR would build for us from the
original left-recursive rule. These are the parse trees for the transformed rule, not the
original. Here are some sample inputs and associated parse trees:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/谓词/prec-parse-trees.png">
</div>
<p id="f_0089.html.N18FE9">
在第一棵树中，对 的初始调用<code class="cf keyword">expr</code>为<code class="cf variable">_p</code>0，并<code class="cf keyword">expr</code>立即将<code class="cf ic">1</code>与<code class="cf ic">(INT|ID)</code>
子规则匹配。现在<code class="cf keyword">expr</code>必须决定是匹配<code class="cf ic">+</code>还是完全跳过循环并返回。谓词的计算结果为<code class="cf ic">{3&gt;=0}?</code>，因此我们进入循环以匹配<code class="cf ic">+</code>，然后<code class="cf keyword">expr</code>使用参数 4 进行递归调用。该调用匹配<code class="cf ic">2</code>并立即返回，因为没有更多输入。<code class="cf ic">expr[0]</code>然后返回对 的原始<code class="cf keyword">expr</code>调用
<code class="cf keyword">stat</code>。
</p><p>
In the first tree, the initial call to <code class="cf keyword">expr</code> has <code class="cf variable">_p</code> of
0, and <code class="cf keyword">expr</code> immediately matches the <code class="cf ic">1</code> to the <code class="cf ic">(INT|ID)</code>
subrule. Now <code class="cf keyword">expr</code> has to decide whether it will match the <code class="cf ic">+</code> or
skip the loop entirely and return. The predicate evaluates as <code class="cf ic">{3&gt;=0}?</code> and so we
enter the loop to match <code class="cf ic">+</code> and then call <code class="cf keyword">expr</code> recursively with an
argument of 4. That invocation matches <code class="cf ic">2</code> and immediately returns because there is no
more input. <code class="cf ic">expr[0]</code> then returns to the original call to <code class="cf keyword">expr</code> in
<code class="cf keyword">stat</code>.
</p>
<p id="f_0089.html.N19016">
第二棵树说明了如何<code class="cf ic">expr[0]</code>匹配<code class="cf ic">1</code>，并再次
<code class="cf ic">{3&gt;=0}?</code>允许我们匹配<code class="cf ic">+</code>运算符和后面的第二个操作数
<code class="cf ic">expr[4]</code>。对匹配的递归调用<code class="cf ic">expr[4]</code>然后<code class="cf ic">2</code>计算<code class="cf ic">{4 &gt;= 4}?</code>，这让解析器继续<code class="cf ic">*</code>通过调用来匹配运算符和后面的最后一个操作<code class="cf ic">3</code>数<code class="cf ic">expr[5]</code>。
</p><p>
The second tree illustrates how <code class="cf ic">expr[0]</code> matches <code class="cf ic">1</code>, and again
<code class="cf ic">{3&gt;=0}?</code> allows us to match the <code class="cf ic">+</code> operator followed by the second operand,
<code class="cf ic">expr[4]</code>. The recursive call to <code class="cf ic">expr[4]</code> matches the <code class="cf ic">2</code> and then
evaluates <code class="cf ic">{4 &gt;= 4}?</code>, which lets the parser proceed to match the <code class="cf ic">*</code> operator
followed by the last operand, <code class="cf ic">3</code>, via a call to <code class="cf ic">expr[5]</code>.
</p>
<p id="f_0089.html.N1903A">
第三棵解析树最有趣。初始调用<code class="cf ic">expr[0]</code>匹配，<code class="cf ic">1</code>然后决定匹配<code class="cf ic">*</code>操作，因为
<code class="cf ic">{4&gt;=0}?</code>为真。然后该循环递归调用<code class="cf ic">expr[5]</code>，它立即匹配<code class="cf ic">2</code>。现在，在 的调用中<code class="cf ic">expr[5]</code>，解析器不应匹配 ，<code class="cf ic">+</code>因为否则<code class="cf ic">2+3</code>会在乘法之前求值。（在解析树中，我们会看到<code class="cf ic">expr[5]</code>为<code class="cf ic">2+3</code>子代，而不仅仅是<code class="cf ic">2</code>。）谓词<code class="cf ic">{3 &gt;= 5}?</code>停用该替代方案，因此<code class="cf ic">expr[5]</code>返回而不匹配<code class="cf ic">+</code>。返回后，
<code class="cf ic">expr[0]</code>匹配<code class="cf ic">+3</code>，因为<code class="cf ic">{3&gt;=0}?</code>为真。
</p><p>
The third parse tree is the most interesting. The initial invocation, <code class="cf ic">expr[0]</code>,
matches <code class="cf ic">1</code> and then decides to match the <code class="cf ic">*</code> operation because
<code class="cf ic">{4&gt;=0}?</code> is true. That loop then recursively calls <code class="cf ic">expr[5]</code>, which
immediately matches <code class="cf ic">2</code>. Now, inside the call to <code class="cf ic">expr[5]</code>, the parser should
not match the <code class="cf ic">+</code> because otherwise the <code class="cf ic">2+3</code> would evaluate before the
multiply. (In the parse tree, we would see <code class="cf ic">expr[5]</code> with <code class="cf ic">2+3</code> as children
instead of just the <code class="cf ic">2</code>.) Predicate <code class="cf ic">{3 &gt;= 5}?</code> deactivates that alternative
and so <code class="cf ic">expr[5]</code> returns without matching the <code class="cf ic">+</code>. After returning,
<code class="cf ic">expr[0]</code> matches <code class="cf ic">+3</code> since <code class="cf ic">{3&gt;=0}?</code> is true.
</p>
<p id="f_0089.html.N19073">
我希望这能让您对优先级攀升机制有个大致了解。如果您想了解更多信息，Norvell 的描述<a id="f_0089.html.FNPTR-57" href="#f_0089.html.FOOTNOTE-57">[57]</a>
非常详细。
</p><p>
I hope this gives you a good feel for the precedence climbing mechanism. If you’d like to
learn more, Norvell’s
description<a href="#f_0089.html.FOOTNOTE-57">[57]</a>
goes into a lot of detail.
</p>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0089.html.FOOTNOTE-55" href="#f_0087.html.FNPTR-55">[55]</a>
</td>
<td>
<p id="f_0089.html.N18D6E">
Theodore Norvell 创造了这一术语（<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>），但最初的工作是由 Keith Clarke 完成的（<a href="http://antlr.org/papers/Clarke-expr-parsing-1986.pdf">http://antlr.org/papers/Clarke-expr-parsing-1986.pdf</a>）。
</p><p>
Theodore Norvell coined the term
(<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>), but the original work was done
by Keith Clarke (<a href="http://antlr.org/papers/Clarke-expr-parsing-1986.pdf">http://antlr.org/papers/Clarke-expr-parsing-1986.pdf</a>).
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0089.html.FOOTNOTE-56" href="#f_0089.html.FNPTR-56">[56]</a>
</td>
<td>
<p id="f_0089.html.N18FBE">
<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a>
</p><p>
<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0089.html.FOOTNOTE-57" href="#f_0089.html.FNPTR-57">[57]</a>
</td>
<td>
<p id="f_0089.html.N19077">
<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>
</p><p>
<a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</a>
</p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0090.html"><div>

<h1 class="chapter-title" id="f_0090.html.chp.ref">
<span class="chapter-number">
	      第十五章</span>
<br><br>
<span class="chapter-name">语法参考</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Chapter
	      15</span>
<br><br>
<span class="chapter-name">Grammar Reference</span>
</h1>

<p id="f_0090.html.N1908E">
本书的大部分内容都是关于如何使用 ANTLR 的指南。本章是参考，总结了语法和 ANTLR 语法的关键语义。它并不是关于如何使用 ANTLR 的孤立而完整的描述。本书中所有示例的源代码都是很好的资源，可在网站上找到。<a id="f_0090.html.FNPTR-58" href="#f_0099.html.FOOTNOTE-58">[58]</a>
</p><p>
Most of this book is a guide to using ANTLR. This chapter is a reference and summarizes
grammar syntax and the key semantics of ANTLR grammars. It is not meant as an isolated and
complete description of how to use ANTLR. The source code for all examples in this book is a
good resource and is available at the
website.<a href="#f_0099.html.FOOTNOTE-58">[58]</a>
</p>

</div></div>
<div id="f_0091.html"><div>

<h2 id="f_0091.html.sec.lexicon">15.1 语法词典</h2><h2>15.1 Grammar Lexicon</h2>
<p id="f_0091.html.N1909B">
  ANTLR 的词汇表对大多数程序员来说都很熟悉，因为它遵循 C 及其衍生语言的语法，并对语法描述进行了一些扩展。
</p><p>
  The lexicon of ANTLR is familiar to most programmers because it
  follows the syntax of C and its derivatives with some extensions for
  grammatical descriptions.
</p>
<h3 id="f_0091.html.sec.comments">评论</h3><h3>Comments</h3>
<p id="f_0091.html.N190B5">
  有单行、多行和 Javadoc 风格的注释。
</p><p>
  There are single-line, multiline, and Javadoc-style comments.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** This grammar is an example illustrating the three kinds</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  of comments.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> T;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/* a multi-line</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">   comment</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** This rule matches a declarator for my language */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl : ID ; <em class="comment">// match a variable name</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0091.html.N190F0">
Javadoc 注释将发送到解析器，不会被忽略。这些注释仅允许出现在语法和任何规则的开头。
</p><p>
The Javadoc comments are sent to the parser and are not ignored. These are allowed only at the start of the grammar and any rule.
</p>
<h3 id="f_0091.html.sec.identifiers">标识符</h3><h3>Identifiers</h3>
<p id="f_0091.html.N190FB">
  标记名称始终以大写字母开头，Java 方法定义的词法分析器规则也是如此
  <code class="cf methodname">Character.isUpperCase</code>。解析器规则名称始终以小写字母开头（失败的那些<code class="cf methodname">Character.isUpperCase</code>）。首字符后面可以跟大写和小写字母、数字和下划线。以下是一些示例名称：
</p><p>
  Token names always start with a capital letter and so do lexer rules as defined by Java’s
  <code class="cf methodname">Character.isUpperCase</code> method. Parser rule names always start with a
  lowercase letter (those that fail <code class="cf methodname">Character.isUpperCase</code>). The initial
  character can be followed by uppercase and lowercase letters, digits, and underscores.
  Here are some sample names:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID, LPAREN, RIGHT_CURLY <em class="comment">// token names/rules</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr, simpleDeclarator, d2, header_file <em class="comment">// rule names</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0091.html.N19126">
与 Java 类似，ANTLR 在 ANTLR 名称中接受 Unicode 字符。
</p><p>
Like Java, ANTLR accepts Unicode characters in ANTLR names.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAAoCAAAAABoEq0dAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAAAEgAAABIAEbJaz4AAAE7SURBVEjH7ZTRbcQgDIZvlq5wD7cAK/DWZ1b4V2AFVmAFr+AVWIEVXBuSCzldkzSVqqt0loJkyBcb238u8hu7vOkDlvXhepIu0AVnY0fgep4OIh5P6BrCZ4isRykEBOpr9+M9dCwMvtrd84pGTjf7qBOkDEJfm7/EyjU4FpAWgFe0E7qRkP/QQwK5vnZ/yLQ6DQSUh8xBWWlnsQa6++PFyWpOVeqK5qtXGljT3V9gzB1L6aHm88aGUaufvYd17OJ83aUXmy/+f1TyB3SxquSzdLRBxM/p1AbYQ6WB2TtOtxEuUXJgTN4B2rQoOUsLFpJytmEe533aVCbcE63EzutGH77C+7Rpcby+DrN3aXd47/p2w2b1reY957pPmxb1zzPBbujYpvae9bu1WyYKB2J/b5tNezmVvOkXpr8A0ZoLA0CwQm0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTMtMDEtMTVUMjI6NDc6MDAtMDY6MDBJGcFeAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDEzLTAxLTE1VDIyOjQ3OjAwLTA2OjAwOER54gAAACB0RVh0cGRmOkhpUmVzQm91bmRpbmdCb3gANjEyeDc5MiswKzCfnX1XAAAAFHRFWHRwZGY6VmVyc2lvbgBQREYtMS41DUCDV0wAAAAASUVORK5CYII=" alt="图片/参考/nonascii.png">
</div>
<p id="f_0091.html.N19134">
为了支持 Unicode 解析器和词法分析器规则名称，ANTLR 使用以下规则：
</p><p>
To support Unicode parser and lexer rule names, ANTLR uses the following rule:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   a=NameStartChar NameChar*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        if ( Character.isUpperCase(getText().charAt(0)) ) setType(TOKEN_REF);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        else setType(RULE_REF);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0091.html.N19152">
<code class="cf keyword">NameChar</code>标识有效的标识符字符。
</p><p>
<code class="cf keyword">NameChar</code> identifies the valid identifier characters.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   NameStartChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'0'</em>..<em class="string">'9'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'_'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u00B7'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u0300'</em>..<em class="string">'\u036F'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u203F'</em>..<em class="string">'\u2040'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0091.html.N1918F">
<code class="cf keyword">NameStartChar</code>是可以启动标识符（规则、标记或标签名称）的字符列表。
</p><p>
<code class="cf keyword">NameStartChar</code> is the list of characters that can start an identifier (rule, token, or label name).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​NameStartChar​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'A'</em>..<em class="string">'Z'</em> | <em class="string">'a'</em>..<em class="string">'z'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u00C0'</em>..<em class="string">'\u00D6'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u00D8'</em>..<em class="string">'\u00F6'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u00F8'</em>..<em class="string">'\u02FF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u0370'</em>..<em class="string">'\u037D'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u037F'</em>..<em class="string">'\u1FFF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u200C'</em>..<em class="string">'\u200D'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u2070'</em>..<em class="string">'\u218F'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u2C00'</em>..<em class="string">'\u2FEF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\u3001'</em>..<em class="string">'\uD7FF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\uF900'</em>..<em class="string">'\uFDCF'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'\uFDF0'</em>..<em class="string">'\uFFFD'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0091.html.N1920D">
这些或多或少与Java 类中的<code class="cf methodname">isJavaIdentifierPart</code>和
相对应。如果您的语法文件不是 UTF-8 格式，
请确保使用ANTLR 工具上的选项，以便 ANTLR 正确读取字符。<code class="cf methodname">isJavaIdentifierStart</code><code class="cf class">Character</code><code class="cf commandoption">-encoding</code></p><p>
These more or less correspond to <code class="cf methodname">isJavaIdentifierPart</code> and
<code class="cf methodname">isJavaIdentifierStart</code> in Java’s <code class="cf class">Character</code> class. Make sure
to use the <code class="cf commandoption">-encoding</code> option on the ANTLR tool if your grammar
file is not in UTF-8 format so that ANTLR reads characters properly.
</p>
<h3 id="f_0091.html.sec.literals">文字</h3><h3>Literals</h3>
<p id="f_0091.html.N1922A">
  ANTLR 不像大多数语言那样区分字符和字符串文字。所有长度为一个或多个字符的文字字符串都括在单引号中，例如
  <code class="cf ic">’;’</code>、<code class="cf ic">’if’</code>、
  <code class="cf ic">’&gt;=’</code>和<code class="cf ic">’\</code>
<code class="cf ic">’</code>
<code class="cf ic">’</code>
  （指包含单引号字符的单字符字符串）。文字从不包含正则表达式。
</p><p>
  ANTLR does not distinguish between character and string literals like
  most languages do.  All literal strings that are one or more
  characters in length are enclosed in single quotes such as
  <code class="cf ic">’;’</code>, <code class="cf ic">’if’</code>,
  <code class="cf ic">’&gt;=’</code>, and <code class="cf ic">’\</code>
<code class="cf ic">’</code>
<code class="cf ic">’</code>
  (refers to the one-character string containing the single quote
  character).  Literals never contain regular
  expressions.
</p>
<p id="f_0091.html.N19240">
  文字可以包含 形式的 Unicode 转义序列<code class="cf ic">\uXXXX</code>，其中
  <code class="cf ic">XXXX</code>是十六进制 Unicode 字符值。例如，是带重音符的<code class="cf ic">’\u00E8’</code>法语字母<span class="emph">e</span><code class="cf ic">’è’</code> ： 。ANTLR 还可以理解常见的特殊转义序列：<code class="cf ic">’\n’</code>（换行符）、<code class="cf ic">’\r’</code>
  （回车符）、<code class="cf ic">’\t’</code>（制表符）、<code class="cf ic">’\b’</code>（退格符）和<code class="cf ic">’\f’</code>（换页符）。您可以在文字中直接使用 Unicode 字符，也可以使用 Unicode 转义序列。请参阅<code class="cf filename">code/reference/Foreign.g4</code>。
</p><p>
  Literals can contain Unicode escape sequences of the form <code class="cf ic">\uXXXX</code>, where
  <code class="cf ic">XXXX</code> is the hexadecimal Unicode character value. For example, <code class="cf ic">’\u00E8’</code> is
  the French letter <span class="emph">e</span> with a grave accent: <code class="cf ic">’è’</code>. ANTLR also
  understands the usual special escape sequences: <code class="cf ic">’\n’</code> (newline), <code class="cf ic">’\r’</code>
  (carriage return), <code class="cf ic">’\t’</code> (tab), <code class="cf ic">’\b’</code> (backspace), and <code class="cf ic">’\f’</code> (form
  feed). You can use Unicode characters directly within literals or use the Unicode escape
  sequences. See <code class="cf filename">code/reference/Foreign.g4</code>.
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAqBAAAAABUIBcYAAAACXBIWXMAAABIAAAASABGyWs+AAABq0lEQVRIx+3SMUjDQBgFYDeHUjI4OKi4dFCQFlzEpaIRuwjZHO3STVFaUyIK3iJuIg7i2KE6OJmWgkOHQlE6lm5ChQjiZKEBtbG9xN+7a9oGkebi4GJvuORBPu4u94bgN0MfGrA/Zho/05dXO69Y8MD6r9aaPS8ln0fKpfjmUopNNCQpay1umUr0Ys6U0tOoFF//RD1W0WIZZLUW1GuxNskmEjIIdAVVNBmPWsG3vH+iIampNTPUYwrkVMCyoJI3P5tYAD1fUOARC0ZE3h9GWFIh59wkY+kyYz42sUA3qYBO2Ea++gPL1mXyMXYwFijL1g+xgMOAfUGDMcfZjEBMhWLEwVigzAjMkH+fEF+ExAplWHJewBnHhTejdIWUY7WrMXe1d1qg1nE2c1dzZ6Xjvi2xOPb7nb3WQfLIrDLAHWgSPHhiGAHsiNsS3Hhm4Y95fkb6DvdgFcBA77chqILdcxdG+g5FmhqXT+Y4edo9d2Gk752NToF4wPsnSd87OQxSkpeRvkONReOkfW9cZyN9hwyLR8CY3XMX1h1N1GZ2z3lZl3OdzfsYsP/FvgCvsUnK//JvvQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0NzowMC0wNjowMEkZwV4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDc6MDAtMDY6MDA4RHniAAAAIHRFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAA2MTJ4NzkyKzArMJ+dfVcAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/参考/外国.png">
</div>
<p id="f_0091.html.N1928C">
ANTLR 生成的识别器假定字符词汇表包含所有 Unicode 字符。运行时库假定的输入文件编码取决于目标语言。对于 Java 目标，运行时库假定文件采用 UTF-8 编码。使用构造函数，您可以指定不同的编码。例如，请参阅 ANTLR 的<code class="cf class">ANTLRFileStream</code>。
</p><p>
The recognizers that ANTLR generates assume a character vocabulary containing all Unicode
characters. The input file encoding assumed by the runtime library depends on the target language. For the Java target, the runtime library assumes files are in UTF-8. Using the constructors, you can specify a different encoding. See, for example, ANTLR’s <code class="cf class">ANTLRFileStream</code>.
</p>
<h3 id="f_0091.html.sec.actiontoken">操作</h3><h3>Actions</h3>
<p id="f_0091.html.N19297">
  动作是用目标语言编写的代码块。您可以在语法中的多个位置使用动作，但语法始终相同：用花括号括起来的任意文本。如果结束的花括号位于字符串或注释中，则无需对其进行转义：<code class="cf ic">{"}"}</code>或<code class="cf ic">{/*}*/;}</code>。如果花括号是匹配的，则也无需对 : 进行转义<code class="cf ic">}</code>。<code class="cf ic">{{...}}</code>否则，使用反斜杠对多余的花括号进行转义：<code class="cf ic">{\{}</code>或<code class="cf ic">{\}}</code>。动作文本应符合选项指定的目标语言<code class="cf keyword">language</code>。
</p><p>
  Actions are code blocks written in the target language. You can use actions in a number of
  places within a grammar, but the syntax is always the same: arbitrary text surrounded by
  curly braces. You don’t need to escape a closing curly character if it’s in a string or
  comment: <code class="cf ic">{"}"}</code> or <code class="cf ic">{/*}*/;}</code>. If the curlies are balanced, you also don’t
  need to escape <code class="cf ic">}</code>: <code class="cf ic">{{...}}</code>. Otherwise, escape extra curlies with a
  backslash: <code class="cf ic">{\{}</code> or <code class="cf ic">{\}}</code>. The action text should conform to the target language as
  specified with the <code class="cf keyword">language</code> option.
</p>
<p id="f_0091.html.N192C0">
嵌入代码可以出现在<code class="cf ic">@header</code>命名<code class="cf ic">@members</code>的操作、解析器和词法分析器规则、异常捕获规范、解析器规则的属性部分（返回值、参数和本地变量）以及一些规则元素选项（当前谓词）中。
</p><p>
Embedded code can appear in <code class="cf ic">@header</code> and <code class="cf ic">@members</code> named actions,  parser and lexer rules, exception catching specifications, attribute sections for parser rules (return values, arguments, and locals), and some rule element options (currently predicates).
</p>
<p id="f_0091.html.N192C9">
ANTLR 在操作中所做的唯一解释与语法属性有关；请参阅<a href="#f_0094.html.sec.token-attributes">​标记<em>属性</em>​，</a>以及第 10 章<a href="#f_0063.html.chp.actions">​属性<em>和操作</em>​。</a>嵌入在词法分析器规则中的操作无需任何解释或翻译即可发出到生成的词法分析器中。
</p><p>
The only interpretation ANTLR does inside actions relates to grammar attributes; see <a href="#f_0094.html.sec.token-attributes">​<em>Token Attributes</em>​</a>, as well as Chapter 10, <a href="#f_0063.html.chp.actions">​<em>Attributes and Actions</em>​</a>. Actions embedded within lexer rules are emitted without any interpretation or translation into generated lexers.
</p>
<h3>关键词</h3><h3>Keywords</h3>
<p id="f_0091.html.N192DC">
以下是 ANTLR 语法中的保留字列表：<code class="cf keyword">import</code>，
 <code class="cf keyword">fragment</code>，<code class="cf keyword">lexer</code>，<code class="cf keyword">parser</code>，
 <code class="cf keyword">grammar</code>，<code class="cf keyword">returns</code>，<code class="cf keyword">locals</code>，
 <code class="cf keyword">throws</code>，<code class="cf keyword">catch</code>，<code class="cf keyword">finally</code>，
 <code class="cf keyword">mode</code>，<code class="cf keyword">options</code>。<code class="cf keyword">tokens</code>此外，尽管它不是关键字，但不要将该词<code class="cf keyword">rule</code>用作规则或替代标签名称，因为它会导致<code class="cf class">RuleContext</code>上下文对象；
<code class="cf class">RuleContext</code>与内置类冲突。此外，不要将目标语言的任何关键字用作标记、标签或规则名称。例如，规则
<code class="cf keyword">if</code>将导致生成一个名为的函数<code class="cf methodname">if</code>。
</p><p>
Here’s a list of the reserved words in ANTLR grammars: <code class="cf keyword">import</code>,
<code class="cf keyword">fragment</code>, <code class="cf keyword">lexer</code>, <code class="cf keyword">parser</code>,
<code class="cf keyword">grammar</code>, <code class="cf keyword">returns</code>, <code class="cf keyword">locals</code>,
<code class="cf keyword">throws</code>, <code class="cf keyword">catch</code>, <code class="cf keyword">finally</code>,
<code class="cf keyword">mode</code>, <code class="cf keyword">options</code>, <code class="cf keyword">tokens</code>. Also,
although it is not a keyword, do not use the word <code class="cf keyword">rule</code> as a rule or
alternative label name since it results in <code class="cf class">RuleContext</code> as a context object;
<code class="cf class">RuleContext</code> clashes with the built-in class. Further, do not use any keyword
of the target language as a token, label, or rule name. For example, rule
<code class="cf keyword">if</code> would result in a generated function called <code class="cf methodname">if</code>.
</p>

</div></div>
<div id="f_0092.html"><div>

<h2 id="f_0092.html.N19325">15.2 语法结构</h2><h2>15.2 Grammar Structure</h2>
<p id="f_0092.html.N19329">
语法本质上是一个语法声明，后跟一系列规则，但具有以下一般形式：
</p><p>
A grammar is essentially a grammar declaration followed by a list of rules but has the following
general form:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Optional Javadoc-style comment */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">
<span style="font-family:DroidFont" class="callout-number">①</span>&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Name; ​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> {...}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> ... ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> {...}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@actionName</strong> {...}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rule1 <em class="comment">// parser and lexer rules, possibly intermingled</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ruleN​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N1936A"><span class="standin">包含语法X</span>
的文件名必须为
<span class="standin">X</span>
<code class="cf fileextension">g4</code>。您可以按任意顺序指定选项、导入、标记规范和操作。选项、导入和标记规范最多各有一个。除标题
<span style="font-family:DroidFont" class="callout-number">①</span>和至少一条规则外，所有这些元素都是可选的。规则采用以下基本形式：
</p><p>
The filename containing grammar <span class="standin">X</span> must be called
<span class="standin">X</span>
<code class="cf fileextension">g4</code>. You can specify options, imports,
token specifications, and actions in any order. There can be at most one each of options,
imports, and token specifications. All of those elements are optional except for the header
<span style="font-family:DroidFont;" class="callout-number">①</span> and at least one rule. Rules take the following basic form:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ruleName : alternative1 | ... | alternativeN ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N1938F">
解析器规则名称必须以小写字母开头，词法分析器规则名称必须以大写字母开头。
</p><p>
Parser rule names must start with a lowercase letter, and lexer rules must start with a capital letter.
</p>
<p id="f_0092.html.N19392">
标题中未使用前缀定义的语法<code class="cf keyword">grammar</code>是
<span class="emph">组合</span>语法，可以同时包含词汇规则和解析器规则。要创建仅允许解析器规则的解析器语法，请使用以下标题：
</p><p>
Grammars defined without a prefix on the <code class="cf keyword">grammar</code> header are
<span class="emph">combined</span> grammars that can contain both lexical and parser rules. To make a
parser grammar that  allows only parser rules, use the following header:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">parser</strong> <strong class="prompt">grammar</strong> Name;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N193B4">
当然，纯粹的词法分析器语法如下所示：
</p><p>
And, naturally, a pure lexer grammar looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> Name;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N193D0">
只有词法分析器语法可以包含<code class="cf keyword">mode</code>规范。
</p><p>
Only lexer grammars can contain <code class="cf keyword">mode</code> specifications.
</p>
<p id="f_0092.html.N193D6">第 15.5 节“<a href="#f_0095.html.sec.lexers">词法分析器<em>规则”</em>和</a>第 15.3 节<a href="#f_0093.html.sec.parsers">“解析器<em>规则”</em>包含</a>有关规则语法的详细信息。第 15.8 节<a href="#f_0098.html.sec.options"><em>“选项”</em></a><a href="#f_0098.html.sec.options">描述了</a>语法选项，第 15.4 节“<a href="#f_0094.html.sec.actions">操作</a><a href="#f_0094.html.sec.actions"><em>和属性”</em></a><a href="#f_0094.html.sec.actions">包含</a>有关语法级操作的信息。接下来我们将介绍语法导入、标记规范和命名操作。
<a href="#f_0098.html.sec.options"><em></em></a><a href="#f_0094.html.sec.actions"><em></em></a></p><p>Section 15.5, <a href="#f_0095.html.sec.lexers">​<em>Lexer Rules</em>​</a> and Section 15.3, <a href="#f_0093.html.sec.parsers">​<em>Parser Rules</em>​</a> contain details on
rule syntax.  Section 15.8, <a href="#f_0098.html.sec.options">​<em>Options</em>​</a> describes grammar options, and Section 15.4, <a href="#f_0094.html.sec.actions">​<em>Actions and Attributes</em>​</a> has information on grammar-level actions. We’ll look at grammar imports, token specifications, and named actions next.
</p>
<h3>语法导入</h3><h3>Grammar imports</h3>
<p id="f_0092.html.N193E8">
语法<code class="cf keyword">import</code>可让您将语法分解为逻辑上可重用的块，如我们在<a href="#f_0026.html.sec.tour-importing">导入<em>语法</em></a>中看到的那样<a href="#f_0026.html.sec.tour-importing">。ANTLR</a><code class="cf keyword">tokens</code>从导入的语法中继承所有规则、规范和命名操作。“主语法”中的规则覆盖导入语法中的规则以实现继承。
</p><p>
Grammar <code class="cf keyword">import</code>s let you break up a grammar into logical and reusable chunks, as we saw in <a href="#f_0026.html.sec.tour-importing">​<em>Importing Grammars</em>​</a>. ANTLR treats imported grammars very much like object-oriented programming languages treat superclasses.  A grammar inherits all of the rules, <code class="cf keyword">tokens</code> specifications, and named actions from the imported grammar.  Rules in the “main grammar” override rules from imported grammars to implement inheritance.
</p>
<p id="f_0092.html.N19403">
可以将其视为<code class="cf keyword">import</code>更像智能包含语句（不包含已定义的规则）。所有导入的结果都是一个组合语法；ANTLR 代码生成器看到的是完整的语法，但并不知道有导入的语法。
</p><p>
Think of <code class="cf keyword">import</code> as more like a smart include statement (which does not include rules that are already defined). The result of all imports is a single combined grammar; the ANTLR code generator sees a complete grammar and has no idea there were imported grammars.
</p>
<p id="f_0092.html.N1940F">
为了处理主语法，ANTLR 工具会将所有导入的语法加载到从属语法对象中。然后，它将导入语法中的规则、标记类型和命名操作合并到主语法中。在下图中，右侧的语法说明了语法<code class="cf class">MyELang</code>导入语法的效果<code class="cf class">ELang</code>：
</p><p>
To process a main grammar, the ANTLR tool loads all of the imported grammars into
subordinate grammar objects. It then merges the rules, token types, and named actions from
the imported grammars into the main grammar. In the following diagram, the grammar on the right illustrates the effect of grammar <code class="cf class">MyELang</code> importing grammar <code class="cf class">ELang</code>:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/参考/combined.png">
</div>
<p id="f_0092.html.N1941D">
<code class="cf class">MyELang</code>继承了规则<code class="cf keyword">stat</code>、<code class="cf keyword">WS</code>和
<code class="cf keyword">ID</code>，但它会覆盖规则<code class="cf keyword">expr</code>并添加
<code class="cf keyword">INT</code>。以下是示例构建和测试运行，表明<code class="cf class">MyELang</code>
可以识别整数表达式，而原始版本<code class="cf class">ELang</code>不能。第三个错误的输入语句会触发错误消息，这也表明解析器正在寻找<code class="cf class">MyELang</code>，<code class="cf keyword">expr</code>而不是<code class="cf class">ELang</code>。
</p><p>
<code class="cf class">MyELang</code> inherits rules <code class="cf keyword">stat</code>, <code class="cf keyword">WS</code>, and
<code class="cf keyword">ID</code>, but it overrides rule <code class="cf keyword">expr</code> and adds
<code class="cf keyword">INT</code>. Here’s a sample build and test run that shows <code class="cf class">MyELang</code>
can recognize integer expressions whereas the original <code class="cf class">ELang</code> can’t. The
third, erroneous input statement triggers an error message that also demonstrates the parser
was looking for <code class="cf class">MyELang</code>’s <code class="cf keyword">expr</code>, not <code class="cf class">ELang</code>’s.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 MyELang.g4 </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac MyELang*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun MyELang stat</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">34;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">a;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 3:0 extraneous input ';' expecting {&lt;EOF&gt;, INT, ID}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N1946F">
如果有任何<code class="cf keyword">tokens</code>规范，主语法将合并标记集。任何命名的操作（例如）都<code class="cf ic">@members</code>将被合并。一般来说，您应该避免在导入的语法中使用命名操作和规则内的操作，因为这会限制它们的重用。ANTLR 还会忽略导入的语法中的任何选项。

</p><p>
If there were any <code class="cf keyword">tokens</code> specifications, the main grammar would merge the token sets. Any named actions such as <code class="cf ic">@members</code> would be merged. In general, you should avoid named actions and actions within rules in imported grammars since that limits their reuse. ANTLR also ignores any options in imported grammars.

</p>
<p id="f_0092.html.N19478">
导入的语法也可以导入其他语法。ANTLR 以深度优先的方式查找所有导入的语法。如果两个或多个导入的语法定义了规则<code class="cf keyword">r</code>，ANTLR 将选择它找到的第一个版本。在下图中， ANTLR
按以下顺序检查语法<code class="cf keyword">r</code>：<code class="cf keyword">Nested</code>、、、：<code class="cf keyword">G1</code><code class="cf keyword">G3</code><code class="cf keyword">G2</code></p><p>
Imported grammars can also import other grammars. ANTLR pursues all imported grammars in a depth-first fashion. If two or more imported grammars define rule <code class="cf keyword">r</code>, ANTLR chooses the first version of <code class="cf keyword">r</code> it finds. In the following diagram, ANTLR examines grammars in the following order: <code class="cf keyword">Nested</code>, <code class="cf keyword">G1</code>, <code class="cf keyword">G3</code>, <code class="cf keyword">G2</code>:
</p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/参考/嵌套.png">
</div>
<p id="f_0092.html.N19492">
<code class="cf class">Nested</code>包括<code class="cf keyword">r</code>  来自的规则，<code class="cf class">G3</code>因为它在<code class="cf keyword">r</code>in之前看到了该版本<code class="cf class">G2</code>。
</p><p>
<code class="cf class">Nested</code> includes the <code class="cf keyword">r</code>  rule from <code class="cf class">G3</code> because it sees that version before the <code class="cf keyword">r</code> in <code class="cf class">G2</code>.
</p>
<p id="f_0092.html.N194A6">
并非每种语法都能导入其他每种语法。
</p><p>
Not every kind of grammar can import every other kind of grammar.
</p>
<ul>
<li>
<p id="f_0092.html.N194AC">词法分析器语法可以导入词法分析器语法。
	</p>
</li><li>
<p>Lexer grammars can import lexer grammars.
	</p>
</li>
<li>
<p id="f_0092.html.N194B0">解析器语法可以导入解析器语法。
	</p>
</li><li>
<p>Parser grammars can import parser grammars.
	</p>
</li>
<li>
<p id="f_0092.html.N194B4">组合语法可以导入词法分析器或解析器语法。
	</p>
</li><li>
<p>Combined grammars can import lexer or parser grammars.
	</p>
</li>
</ul>
<p id="f_0092.html.N194B7">
ANTLR 将导入的规则添加到主词法分析器语法中的规则列表末尾。这意味着主语法中的词法分析器规则优先于导入的规则。例如，如果主语法定义了规则<code class="cf ic">IF : ’if’ ;</code>，而导入的语法定义了规则<code class="cf ic">ID :
[a-z]+ ;</code>（也识别<code class="cf ic">if</code>），则导入的规则<code class="cf keyword">ID</code>不会隐藏主语法的<code class="cf keyword">IF</code>标记定义。
</p><p>
ANTLR adds imported rules to the end of the rule list in a main lexer grammar. That means
lexer rules in the main grammar get precedence over imported rules. For example, if a main
grammar defines rule <code class="cf ic">IF : ’if’ ;</code> and an imported grammar defines rule <code class="cf ic">ID :
[a-z]+ ;</code> (which also recognizes <code class="cf ic">if</code>), the imported <code class="cf keyword">ID</code> won’t
hide the main grammar’s <code class="cf keyword">IF</code> token definition.
</p>
<h3>tokens 部分</h3><h3>tokens Section</h3>
<p id="f_0092.html.N194D3">
本节的目的<code class="cf keyword">tokens</code>是定义没有相关词汇规则的语法所需的标记类型。基本语法如下：
</p><p>
The purpose of the <code class="cf keyword">tokens</code> section is to define token types needed by a
grammar for which there is no associated lexical rule. The basic syntax is as follows:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> { Token1, ..., TokenN }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N194F4">
大多数情况下，该<code class="cf keyword">tokens</code>部分用于定义语法中动作所需的标记类型（正如我们在第 10.3 节“<a href="#f_0066.html.sec.dynamic-keywords">识别<em>关键字未固定的语言</em>”中所做的那样）</a> 。
</p><p>
Most of the time, the <code class="cf keyword">tokens</code> section is used to define token types needed by actions in the grammar (as we did in Section 10.3, <a href="#f_0066.html.sec.dynamic-keywords">​<em>Recognizing Languages Whose Keywords Aren’t Fixed</em>​</a>).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// explicitly define keyword token types to avoid implicit definition warnings</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> { BEGIN, END, IF, THEN, WHILE }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::members {   <em class="comment">// keywords map used in lexer to assign token types</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Map&lt;String,Integer&gt; keywords = new HashMap&lt;String,Integer&gt;() {{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"begin"</em>, KeywordsParser.BEGIN);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    put(<em class="string">"end"</em>,   KeywordsParser.END);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}};​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N1952E">
该<code class="cf keyword">tokens</code>部分实际上只是定义了一组要添加到整体集合中的标记。
</p><p>
The <code class="cf keyword">tokens</code> section really just defines a set of tokens to add to the overall set.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat Tok.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​grammar Tok;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​tokens { A, B, C }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a : X ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Tok.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​warning(125): Tok.g4:3:4: implicit definition of token X in parser​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat Tok.tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​A=1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​B=2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​C=3​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​X=4​</code></div>
</td>
</tr>
</tbody></table>
<h3>语法层面的动作</h3><h3>Actions at the Grammar Level</h3>
<p id="f_0092.html.N1956B">
<a href="#f_0064.html.sec.grammar-actions">使用<em>语法规则之外的操作</em>​，</a>说明了在语法文件的顶层使用命名操作。目前只有两个定义的操作（针对 Java 目标）：<code class="cf keyword">header</code>和<code class="cf keyword">members</code>。前者在识别器类定义之前将代码注入生成的识别器类文件中，后者将代码作为字段和方法注入识别器类定义中。
</p><p>
<a href="#f_0064.html.sec.grammar-actions">​<em>Using Actions Outside of Grammar Rules</em>​</a>, illustrates the use of named actions at the top level of the grammar file. Currently there are only two defined actions (for the Java target): <code class="cf keyword">header</code> and <code class="cf keyword">members</code>.  The former injects code into the generated recognizer class file, before the recognizer class definition, and the latter injects code into the recognizer class definition, as fields and methods.
</p>
<p id="f_0092.html.N1958D">
对于组合语法，ANTLR 将操作注入解析器和词法分析器。要将操作限制到生成的解析器或词法分析器，请使用
<code class="cf ic">@parser::</code>
<span class="standin">name</span>或<code class="cf ic">@lexer::</code>
<span class="standin">name</span>。
</p><p>
For combined grammars, ANTLR injects the actions into both the parser and the lexer. To
restrict an action to the generated parser or lexer, use
<code class="cf ic">@parser::</code>
<span class="standin">name</span> or <code class="cf ic">@lexer::</code>
<span class="standin">name</span>.
</p>
<p id="f_0092.html.N1959A">
下面是语法为生成的代码指定包的示例：
</p><p>
Here’s an example where the grammar specifies a package for the generated code:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/foo/Count.g4">参考/foo/Count.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Count;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@header</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​package foo;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@members</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​int count = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​list​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@after</strong> {System.out.println(count+<em class="string">" ints"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    : INT {count++;} (<em class="string">','</em> INT {count++;} )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT : [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N195E4">
语法本身应该在目录中，<code class="cf dir">foo</code>以便 ANTLR 在同一<code class="cf dir">foo</code>目录中生成代码（至少在不使用
<code class="cf commandoption">-o</code>ANTLR 工具选项时）。
</p><p>
The grammar itself should be in directory <code class="cf dir">foo</code> so that ANTLR generates code
in that same <code class="cf dir">foo</code> directory (at least when not using the
<code class="cf commandoption">-o</code> ANTLR tool option).
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ cd foo</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Count.g4   # generates code in the current directory (foo)</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ ls</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Count.g4                CountLexer.java         CountParser.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Count.tokens            CountLexer.tokens​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CountBaseListener.java  CountListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac *.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ cd ..</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun foo.Count list</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">9, 10, 11</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​3 ints​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0092.html.N19633">
Java 编译器要求包中的类<code class="cf class">foo</code>位于目录中<code class="cf dir">foo</code>。
</p><p>
The Java compiler expects classes in package <code class="cf class">foo</code> to be in directory <code class="cf dir">foo</code>.
</p>
<p id="f_0092.html.N19645">
现在我们已经了解了语法的整体结构，让我们深入研究解析器和词法分析器规则。
</p><p>
Now that we’ve seen the overall structure of a grammar, let’s dig into the parser and lexer rules.
</p>

</div></div>
<div id="f_0093.html"><div>

<h2 id="f_0093.html.sec.parsers">15.3 解析器规则</h2><h2>15.3 Parser Rules</h2>
<p id="f_0093.html.N19650">
解析器由一组解析器规则组成，这些规则可以是单一语法，<code class="cf keyword">parser</code>也可以是组合语法。Java 应用程序通过调用由 ANTLR 生成的与所需起始规则关联的规则函数来启动解析器。最基本的规则只是一个规则名称，后面跟着一个以分号结尾的备选规则。
</p><p>
Parsers consist of a set of parser rules  in either a <code class="cf keyword">parser</code> or a combined grammar.  A Java application launches a parser by invoking the rule function, generated by ANTLR, associated with the desired start rule. The most basic rule is just a rule name followed by a single alternative terminated with a semicolon.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Javadoc comment can precede rule */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​retstat : <em class="string">'return'</em> expr <em class="string">';'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19672">
规则还可以有由<code class="cf ic">|</code>操作员分隔的替代方案。
</p><p>
Rules can also have alternatives separated by the <code class="cf ic">|</code> operator.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   retstat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'break'</em> <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'continue'</em> <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N1969C">
备选方案要么是规则元素列表，要么是空的。例如，下面是一条带有空备选方案的规则，该备选方案使整个规则成为可选的：
</p><p>
Alternatives are either a list of rule elements or empty. For example, here’s a rule with
an empty alternative that makes the entire rule optional:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​superClass​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'extends'</em> ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |                    <em class="comment">// empty means other alternative(s) are optional</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<h3>替代标签</h3><h3>Alternative Labels</h3>
<p id="f_0093.html.N196BD">
正如我们在 7.4 节“<a href="#f_0049.html.sec.labeling-alts"><em>为精确事件方法</em></a><a href="#f_0049.html.sec.labeling-alts">标记中看到的，<em></em></a>我们可以通过使用<code class="cf ic">#</code>运算符标记规则的最外层替代方案来获得更精确的解析树侦听器事件。规则内的所有替代方案都必须标记，否则都不应标记。以下是两个带有标记替代方案的规则：
</p><p>
As we saw in Section 7.4, <a href="#f_0049.html.sec.labeling-alts">​<em>Labeling Rule Alternatives for Precise Event Methods</em>​</a>, we can get more precise parse-tree listener events by labeling the outermost alternatives of a rule using the <code class="cf ic">#</code> operator. All alternatives within a rule must be labeled, or none of them should be. Here are two rules with labeled alternatives:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/AltLabels.g4">参考/AltLabels.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> AltLabels;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'return'</em> e <em class="string">';'</em> # Return​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'break'</em>    <em class="string">';'</em> # Break​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e   : e <em class="string">'*'</em> e        # Mult​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | e <em class="string">'+'</em> e        # Add​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT            # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19707">
替代标签不必位于行尾，并且符号后也不必有空格<code class="cf ic">#</code>。
</p><p>
Alternative labels do not have to be at the end of the line, and there does not have to be a space after the <code class="cf ic">#</code> symbol.
</p>
<p id="f_0093.html.N1970D">
ANTLR 为每个标签生成一个规则上下文类定义。例如，这是 ANTLR 生成的监听器：
</p><p>
ANTLR generates a rule context class definition for each label. For example, here is the
listener that ANTLR generates:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">interface</strong> AltLabelsListener <strong class="prompt">extends</strong> ParseTreeListener {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterMult(AltLabelsParser.MultContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitMult(AltLabelsParser.MultContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterBreak(AltLabelsParser.BreakContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitBreak(AltLabelsParser.BreakContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterReturn(AltLabelsParser.ReturnContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitReturn(AltLabelsParser.ReturnContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterAdd(AltLabelsParser.AddContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitAdd(AltLabelsParser.AddContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> enterInt(AltLabelsParser.IntContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">void</strong> exitInt(AltLabelsParser.IntContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19763">
每个标记的替代方案都有进入和退出方法。这些方法的参数特定于替代方案。
</p><p>
There are enter and exit methods associated with each labeled alternative. The parameters to those methods are specific to alternatives.
</p>
<p id="f_0093.html.N19766">
您可以在多个替代方案上重复使用相同的标签，以指示解析树遍历器应针对这些替代方案触发相同的事件。例如，以下是<code class="cf keyword">e</code>重复使用标签的规则的变体<code class="cf keyword">BinaryOp</code>：
</p><p>
You can reuse the same label on multiple alternatives to indicate that the parse-tree walker should trigger the same event for those alternatives. For example, here’s a variation on rule <code class="cf keyword">e</code> that reuses label <code class="cf keyword">BinaryOp</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e   : e <em class="string">'*'</em> e        # BinaryOp​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | e <em class="string">'+'</em> e        # BinaryOp​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT            # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N1978A">
ANTLR 将生成以下监听器方法<code class="cf keyword">e</code>：
</p><p>
ANTLR would generate the following listener methods for <code class="cf keyword">e</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> enterBinaryOp(AltLabelsParser.BinaryOpContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> exitBinaryOp(AltLabelsParser.BinaryOpContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> enterInt(AltLabelsParser.IntContext ctx);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> exitInt(AltLabelsParser.IntContext ctx);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N197AD">
如果替代名称与规则名称冲突，ANTLR 会给出错误。以下是规则的另一个重写，<code class="cf keyword">e</code>其中两个替代标签与规则名称冲突：
</p><p>
ANTLR gives errors if an alternative name conflicts with a rule name. Here’s another rewrite of rule <code class="cf keyword">e</code> where two alternative labels conflict with rule names:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Conflict.g4">参考/冲突.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​e   : e <em class="string">'*'</em> e        # e​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | e <em class="string">'+'</em> e        # Stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | INT            # Int​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N197CF">
从规则名称和标签生成的上下文对象大写，因此标签<code class="cf keyword">Stat</code>与规则冲突<code class="cf keyword">stat</code>。

</p><p>
The context objects generated from rule names and labels get capitalized, so label <code class="cf keyword">Stat</code> conflicts with rule <code class="cf keyword">stat</code>.

</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 Conflict.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​error(124): Conflict.g4:6:23: rule alt label e conflicts with rule e​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​error(124): Conflict.g4:7:23: rule alt label Stat conflicts with rule stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​warning(125): Conflict.g4:2:13: implicit definition of token INT in parser​</code></div>
</td>
</tr>
</tbody></table>
<h3>规则上下文对象</h3><h3>Rule Context Objects</h3>
<p id="f_0093.html.N197F7">
ANTLR 生成方法来访问与每个规则引用关联的规则上下文对象（解析树节点）。对于具有单个规则引用的规则，ANTLR 会生成一个不带参数的方法。请考虑以下规则：
</p><p>
ANTLR generates methods to access the rule context objects (parse-tree nodes) associated with each rule reference.  For rules with a single rule reference, ANTLR generates a method with no arguments. Consider the following rule:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​inc : e <em class="string">'++'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N1980C">
ANTLR 生成此上下文类：
</p><p>
ANTLR generates this context class:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> IncContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> EContext e() { ... } <em class="comment">// return context object associated with e</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19834">
当对一条规则有多个引用时，ANTLR 还提供访问上下文对象的支持。
</p><p>
ANTLR also provides support to access context objects when there is more than a single reference to a rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​field : e <em class="string">'.'</em> e ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19846">
ANTLR 生成一个带有索引的方法来访问第<span class="standin">i</span>个元素，以及一个方法来获取对该规则的所有引用的上下文。
</p><p>
ANTLR generates a method with an index to access the <span class="standin">i</span>th element as well as a method to get context for all references to that rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> FieldContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> EContext e(<strong class="prompt">int</strong> i) { ... }    <em class="comment">// get ith e context</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">List</strong>&lt;EContext&gt; e() { ... }   <em class="comment">// return ALL e contexts</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N1987F">
如果我们有另一条规则，<code class="cf keyword">s</code>引用，则嵌入的操作可以访问执行的规则匹配
<code class="cf keyword">field</code>列表。
<code class="cf keyword">e</code><code class="cf keyword">field</code></p><p>
If we had another rule, <code class="cf keyword">s</code>, that references <code class="cf keyword">field</code>, an
embedded action could access the list of <code class="cf keyword">e</code> rule matches performed by
<code class="cf keyword">field</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​s : field​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    List&lt;EContext&gt; x = $field.ctx.e();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N198A9">
侦听器或访问者可以做同样的事情。给定一个指向<code class="cf class">FieldContext</code>对象的指针，<code class="cf variable">f</code>将<code class="cf ic">f.e()</code>返回<code class="cf ic">List&lt;EContext&gt;</code>。
</p><p>
A listener or visitor could do the same thing. Given a pointer to a <code class="cf class">FieldContext</code> object, <code class="cf variable">f</code>, <code class="cf ic">f.e()</code> would return <code class="cf ic">List&lt;EContext&gt;</code>.
</p>
<h3>规则元素标签</h3><h3>Rule Element Labels</h3>
<p id="f_0093.html.N198BC">
您可以使用<code class="cf keyword">=</code>运算符标记规则元素，以将字段添加到规则上下文对象。
</p><p>
You can label rule elements using the <code class="cf keyword">=</code> operator to add fields to the rule context objects.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'return'</em> value=e <em class="string">';'</em> # Return​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'break'</em>          <em class="string">';'</em> # Break​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N198EC">
这<code class="cf variable">value</code>是规则的返回值的标签<code class="cf keyword">e</code>，它在其他地方定义。
</p><p>
Here <code class="cf variable">value</code> is the label for the return value of rule <code class="cf keyword">e</code>, which is defined elsewhere.
</p>
<p id="f_0093.html.N198F5">
标签成为相应解析树节点类中的字段。在本例中，
由于有
替代标签，标签<code class="cf keyword">value</code>成为 中的一个字段。
<code class="cf class">ReturnContext</code><code class="cf keyword">Return</code></p><p>
Labels become fields in the appropriate parse-tree node class. In this case, label
<code class="cf keyword">value</code> becomes a field in <code class="cf class">ReturnContext</code> because of the
<code class="cf keyword">Return</code> alternative label.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> ReturnContext <strong class="prompt">extends</strong> StatContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> EContext value;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19924">
跟踪多个标记通常很方便，您可以使用<code class="cf keyword">+=</code>“列表标签”运算符来实现。例如，以下规则<code class="cf class">Token</code>为简单数组构造创建匹配的对象列表：
</p><p>
It’s often handy to track a number of tokens, which you can do with the <code class="cf keyword">+=</code> “list label” operator. For example, the following rule creates a list of the <code class="cf class">Token</code> objects matched for a simple array construct:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​array : <em class="string">'{'</em> el+=INT (<em class="string">','</em> el+=INT)* <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19942">
ANTLR<code class="cf class">List</code>在适当的规则上下文类中生成一个字段。
</p><p>
ANTLR generates a <code class="cf class">List</code> field in the appropriate rule context class.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> ArrayContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">List</strong>&lt;Token&gt; el = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;Token&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19974">
这些列表标签也适用于规则参考。
</p><p>
These list labels also work for rule references.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​elist : exprs+=e (<em class="string">','</em> exprs+=e)* ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19986">
ANTLR 生成一个保存上下文对象列表的字段。
</p><p>
ANTLR generates a field holding the list of context objects.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">class</strong> ElistContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">List</strong>&lt;EContext&gt; exprs = <strong class="prompt">new</strong> <strong class="prompt">ArrayList</strong>&lt;EContext&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<h3>规则元素</h3><h3>Rule Elements</h3>
<p id="f_0093.html.N199BF">
规则元素指定解析器在特定时刻应该做什么，就像编程语言中的语句一样。元素可以是规则、标记或字符串文字，如
<code class="cf keyword">expression</code>、<code class="cf keyword">ID</code>和<code class="cf keyword">’return’</code>。以下是规则元素的完整列表（我们稍后将更详细地介绍动作和谓词）：
</p><p>
Rule elements specify what the parser should do at a given moment just like statements in a
programming language. The elements can be a rule, a token, or a string literal like
<code class="cf keyword">expression</code>, <code class="cf keyword">ID</code>, and <code class="cf keyword">’return’</code>.
Here’s a complete list of the rule elements (we’ll look at actions and predicates in more
detail later):
</p>
<table class="simpletable ">
<thead>
<tr>
<th>句法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<span class="standin">电视</span>
</p><p class="last-para-in-cell">
<span class="standin">T</span>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
        在当前输入位置匹配标记
        <span class="standin">T。</span>标记始终以大写字母开头。
      </p><p class="last-para-in-cell">
        Match token
        <span class="standin">T</span> at the current input position. Tokens always
        begin with a capital letter.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">'<span class="standin">字面意思</span>'</p><p class="last-para-in-cell">’<span class="standin">literal</span>’</p>
</td>
<td style="">
<p class="last-para-in-cell">
        匹配当前输入位置的字符串文字。字符串文字只是一个具有固定字符串的标记。
      </p><p class="last-para-in-cell">
        Match the string literal at the current input position.  A string literal is simply a token with
        a fixed string.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<span class="standin">r</span>
</p><p class="last-para-in-cell">
<span class="standin">r</span>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
        在当前输入位置匹配规则<span class="standin">r</span>，相当于像函数调用一样调用该规则。解析器规则名称始终以小写字母开头。
      </p><p class="last-para-in-cell">
        Match rule <span class="standin">r</span> at the current input position, which amounts
        to invoking the rule just like a function call. Parser rule names always begin with a lowercase letter.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<span class="standin">r</span>
<code class="cf ic">[</code> «<span class="elide emph">参数</span>»<code class="cf ic">]</code>
</p><p class="last-para-in-cell">
<span class="standin">r</span>
<code class="cf ic">[</code>«<span class="elide emph">args</span>»<code class="cf ic">]</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
	在当前输入位置匹配规则<span class="standin">r</span>，传入一个参数列表，就像函数调用一样。方括号内的参数符合目标语言的语法，通常是以逗号分隔的表达式列表。
      </p><p class="last-para-in-cell">
	Match rule <span class="standin">r</span> at the current
	input position, passing in a list of arguments just like a function
	call. The arguments inside the square brackets are in the syntax of
	the target language and are usually a comma-separated list of
	expressions.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">{“<span class="elide emph">行动</span>”}</p><p class="last-para-in-cell">{«<span class="elide emph">action</span>»}</p>
</td>
<td style="">
<p class="last-para-in-cell">
	在前一个替代元素之后和后一个替代元素之前立即执行操作。该操作符合目标语言的语法。ANTLR 将操作代码逐字复制到生成的类中，但替换属性和标记引用（如<code class="cf ic">$x</code>和 ）<code class="cf ic">$x.y</code>。
      </p><p class="last-para-in-cell">
	Execute an action immediately after the preceding
	alternative element and immediately before the following alternative
	element. The action conforms to the syntax of the target language.
    ANTLR copies the action code to the generated class verbatim, except for substituting attribute and token references such as <code class="cf ic">$x</code> and <code class="cf ic">$x.y</code>.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">{«<span class="elide emph">頁</span>»}？</p><p class="last-para-in-cell">{«<span class="elide emph">p</span>»}?</p>
</td>
<td style="">
<p class="last-para-in-cell">
	 评估语义谓词“ <span class="elide emph">p ”。如果“ </span><span class="elide emph">p</span> ”在运行时评估为假，则不要继续解析谓词。当 ANTLR 区分备选方案时，预测期间遇到的谓词，启用或禁用谓词周围的备选方案。
      </p><p class="last-para-in-cell">
	 Evaluate semantic
	predicate «<span class="elide emph">p</span>».  Do not continue parsing past a predicate if «<span class="elide emph">p</span>» evaluates to false at runtime. Predicates encountered during prediction, when ANTLR distinguishes between alternatives, enable or disable the alternative(s) surrounding the predicate(s).
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">。</p><p class="last-para-in-cell">.</p>
</td>
<td style="">
<p class="last-para-in-cell">
匹配除文件结尾标记之外的任何单个标记。“点”运算符称为<span class="emph">通配符</span>。
      </p><p class="last-para-in-cell">
Match any single token except for the end-of-file token. The “dot” operator is called the <span class="emph">wildcard</span>.
      </p>
</td>
</tr>
</tbody>
</table>
<p id="f_0093.html.N19A48">
当您想要匹配除特定标记或标记集之外的所有内容时，请使用
<code class="cf ic">~</code>“not”运算符。此运算符在解析器中很少使用，但可用。
<code class="cf ic">~INT</code>匹配除<code class="cf keyword">INT</code>标记之外的任何标记。<code class="cf ic">~’,’</code>
匹配除逗号之外的任何标记。<code class="cf ic">~(INT|ID)</code>匹配除
<code class="cf keyword">INT</code>或之外的任何标记<code class="cf keyword">ID</code>。
</p><p>
When you want to match everything but a particular token or set of tokens, use the
<code class="cf ic">~</code> “not” operator. This operator is rarely used in the parser but is available.
<code class="cf ic">~INT</code> matches any token except the <code class="cf keyword">INT</code> token. <code class="cf ic">~’,’</code>
matches any token except the comma. <code class="cf ic">~(INT|ID)</code> matches any token except an
<code class="cf keyword">INT</code> or an <code class="cf keyword">ID</code>.
</p>
<p id="f_0093.html.N19A6A">
标记、字符串文字和语义谓词规则元素可以采用选项。请参阅<a href="#f_0098.html.sec.element-options">规则<em>元素选项</em></a>。
</p><p>
Token, string literal, and semantic predicate rule elements can take options. See <a href="#f_0098.html.sec.element-options">​<em>Rule Element Options</em>​</a>.
</p>
<h3>子规则</h3><h3>Subrules</h3>
<p id="f_0093.html.N19A74">
规则可以包含称为<span class="firstuseinline">子规则</span>的替代块（如扩展 BNF 表示法 [EBNF] 所允许的）。子规则类似于没有名称并括在括号中的规则。子规则可以在括号内有一个或多个替代项。子规则不能定义属性，<code class="cf keyword">locals</code>而<code class="cf keyword">returns</code>规则可以。子规则有四种类型（x、y 和 z 表示语法片段）。
</p><p>
A rule can contain alternative blocks called <span class="firstuseinline">subrules</span> (as allowed in
Extended BNF Notation [EBNF]). A subrule is like a rule that lacks a name and is enclosed in
parentheses. Subrules can have one or more alternatives inside the parentheses. Subrules
cannot define attributes with <code class="cf keyword">locals</code> and <code class="cf keyword">returns</code> like
rules can. There are four kinds of subrules (x, y, and z represent grammar fragments).
</p>
<table class="simpletable ">
<tbody>
<tr class="tr ">
<td style="width:30%">
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOgAAACfCAMAAADEUGUzAAAAsVBMVEX///+7vLx4eHnu7+9FRUYBAgNnZ2jd3t7Nts5pI2qvirCbbJyZmpqIiYnMzM25mLqle6ZzMXQEBQYWFxhaWluqq6vu7u718fbDp8SHT4jh0+IICQozNDQGBwh9QH6Ki4sZGhtZWVoVFhcLDA0bHB0FBgc4OTlxcXLd3d3r4uyRXpICAwQYGRrXxdikpaVKSkshIiMDBAXAwMFzc3QHCAk5OjpdXV4QERIPEBFWVlcjJCWrf6A5AAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAASAAAAEgARslrPgAAA/NJREFUeNrt3V1bmzAYBmBAUgvqCpstbad2Ot3WdvUbXfv/f9gS2oPhhJDyNknN8xxwIhd5b6FQSWI8D0EQBEEQRHv8oG1804QmOQhZp6Wzw8ID0wx5wvCw9TEOw9A0QxqftXdyKbP+6g06JIfpBKYhUihNhUSHAdSaCgG1JoC6Bu1GPN2Yb472DXp88kmhwp6A9hK+SXcDLZdDmeAz+3LaHzSsMBuOomjMufF4N9ByOaRQxvOVna1/k/IKs1GURtFQctDtoaVyyKE858VvskGF2QU/n7KDqkAnk8py3tl7678iQ/ZvvskrHIoP6Lh+nyB828zlZWUFV1eV5bxzYquhYRjUpXTk79dSKHfGqUyqBL25qSznR+A3/7hKLqNgc6Wws5/Hv6TX3HTGT2fGHy8p3eNlPq8sRylS6Dn7fXriN6twIR4vi1mxJYLeMnZbVQ4l9Lh0dUgfLzFP1uWbXos2S7lj7K6qHEpoi51pDnPP2L32Rk1AHxh7cAH6KG4+jw5An+aMzZ8cgJ4VXwwcgD4L6LMD0PV3oI8PncyFcz5puj8ZVPcL7Hx9RnPdUO1dEi95/vqa5y+6oSY6mXKK06kMNdBtaAZqoCPYFFR7AAUUULsDKKCA2h1AAQXU7gAKKKB2B1BAaaCOvDNy5i2gK+91TUweMAI1MXnADNTAeF1AAQUUUEAB3V+o2ujOYlxnNi3GeFK1qQmqNl43KkbqinkvtePqldrUBlUZgS1mvFxMuxd826VqkwxaPaZeDHRXHFM/LKaCJFGaqbVZGlNfbvPP/dZjkXcIzdJo5E1lE0KUoNc5EZTy0vW8uPiM1p9Q6jaJoCo3I0+czaM0SrS2SQJVe7x46/tRNNXbJgVUeecxdyaa2zQC9cR8QyegaTTT3qZ+6Fh8LZJNNvwA0GHxHbB+3jOg+wTll65I1vYw9kPtbdP+F9hGoCa6JIxATXQymYEa6DY0AzXQEWwKqj2AAgqo3QEUUEDtDqCAAmp3AAUUULsDKKCAKsWRl2POvO505QW2M10SznQyudNtCKj1bQJqCzRgVNCl3dBlSLTcj88URsPKK+ytB+BEIyLogG5Zo1Vtq2pLLHje0QZKtcRCsKJy8lPar2tIaYkFAU0WXdnaA82hfcp1qvjHfVDzQ7UlFnqcOJOtsdAUOiC7E63jr9iy6oDKSywUQ5NJ1pIIlmxFve6Y/+4Ugv8mDzRZYkE4Y69X/+/bG608wKjut2+oDaANllgQzkSMrG8P1bsI4hazJNI4TiRQC1/fqM5YmG0eL3sHVZ2xIKbhFdk36E4qBNSaAAoooHYH0A8HdWWNYGdWfXZmHW93VmY30BGMIAiCIAhClL+z5FIQsILO3gAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wMS0xNVQyMjo0NzowMC0wNjowMEkZwV4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDEtMTVUMjI6NDc6MDAtMDY6MDA4RHniAAAAIHRFWHRwZGY6SGlSZXNCb3VuZGluZ0JveAAyMzJ4MTU5KzArMEhzGrgAAAAUdEVYdHBkZjpWZXJzaW9uAFBERi0xLjUNQINXTAAAAABJRU5ErkJggg==" alt="图片/参考/xyz.png">
</td>
<td style="">
<p>
<code class="cf ic">(x|y|z)</code>
</p><p>
<code class="cf ic">(x|y|z)</code>
</p>
<p>
          匹配子规则中的任何替代方案一次。以下是示例：
        </p><p>
          Match any alternative within the subrule exactly once. Here’s an example:
        </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​returnType : (type | <em class="string">'void'</em>) ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/参考/xyz_opt.png">
</td>
<td style="">
<p>
<code class="cf ic">(x|y|z)?</code>
</p><p>
<code class="cf ic">(x|y|z)?</code>
</p>
<p>
          不匹配任何内容或子规则内的任何替代内容。以下是示例：
        </p><p>
          Match nothing or any alternative within the subrule. Here’s an example:
        </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​classDeclaration​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​    :   <em class="string">'class'</em> ID (typeParameters)? (<em class="string">'extends'</em> type)?​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​        (<em class="string">'implements'</em> typeList)?​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​        classBody​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/参考/xyz_star.png">
</td>
<td style="">
<p>
<code class="cf ic">(x|y|z)*</code>
</p><p>
<code class="cf ic">(x|y|z)*</code>
</p>
<p>
          匹配子规则中的替代项零次或多次。以下是示例：
        </p><p>
          Match an alternative within the subrule zero or more times. Here’s an example:
        </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​annotationName : ID (<em class="string">'.'</em> ID)* ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<img xmlns:str="http://exslt.org/strings" src="data:image/png;base64,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" alt="图片/参考/xyz_plus.png">
</td>
<td style="">
<p>
<code class="cf ic">(x|y|z)+</code>
</p><p>
<code class="cf ic">(x|y|z)+</code>
</p>
<p>
          匹配子规则中的替代方案一次或多次。以下是示例：
        </p><p>
          Match an alternative within the subrule one or more times. Here’s an example:
        </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​annotations : (annotation)+ ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody>
</table>
<p id="f_0093.html.N19B19">
您可以在<code class="cf ic">?</code>、<code class="cf ic">*</code>和<code class="cf ic">+</code>子规则运算符后面加上非贪婪运算符（也是问号）：、<code class="cf ic">??</code>和<code class="cf ic">*?</code>。<code class="cf ic">+?</code>请参见第 15.6 节“<a href="#f_0096.html.sec.nongreedy"><em>通配符</em></a><a href="#f_0096.html.sec.nongreedy">运算<em></em></a>。
</p><p>
You can suffix the <code class="cf ic">?</code>, <code class="cf ic">*</code>, and <code class="cf ic">+</code> subrule operators with the nongreedy operator, which is also a question mark: <code class="cf ic">??</code>, <code class="cf ic">*?</code>, and <code class="cf ic">+?</code>. See Section 15.6, <a href="#f_0096.html.sec.nongreedy">​<em>Wildcard Operator and Nongreedy Subrules</em>​</a>.
</p>
<p id="f_0093.html.N19B51">
作为一种简写，您可以省略由单个替代项和单个规则元素引用组成的子规则的括号。例如，<code class="cf ic">annotation+</code>与 相同<code class="cf ic">(annotation)+</code>，并且<code class="cf ic">ID+</code>与 相同<code class="cf ic">(ID)+</code>。标签也适用于简写。制作一个标记对象
<code class="cf ic">ids+=INT+</code>列表。<code class="cf keyword">INT</code></p><p>
As a shorthand, you can omit the parentheses for subrules composed of a single alternative with a single-rule element reference.  For example, <code class="cf ic">annotation+</code> is the same as <code class="cf ic">(annotation)+</code>, and <code class="cf ic">ID+</code> is the same as <code class="cf ic">(ID)+</code>. Labels also work with the shorthand. <code class="cf ic">ids+=INT+</code> make a list of <code class="cf keyword">INT</code> token objects.
</p>
<h3 id="f_0093.html.sec.catch-exceptions">捕获异常</h3><h3>Catching Exceptions</h3>
<p id="f_0093.html.N19B74">
  当规则中出现语法错误时，ANTLR 会捕获异常、报告错误、尝试恢复（可能通过消耗更多标记），然后从规则返回。每条规则都包含在
  //<code class="cf keyword">try</code>语句中。
<code class="cf keyword">catch</code><code class="cf keyword">finally</code></p><p>
  When a syntax error occurs within a rule, ANTLR catches the exception, reports the error,
  attempts to recover (possibly by consuming more tokens), and then returns from the rule.
  Every rule is wrapped in a
  <code class="cf keyword">try</code>/<code class="cf keyword">catch</code>/<code class="cf keyword">finally</code> statement.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> r() <strong class="prompt">throws</strong> RecognitionException {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">try</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        rule-body​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">catch</strong> (RecognitionException re) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        _errHandler.reportError(this, re);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        _errHandler.recover(this, re);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">finally</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        exitRule();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19BD6">
在第 9.5 节“<a href="#f_0062.html.sec.error-handling">更改<em>ANTLR 的错误处理策略”</em>中，</a>我们了解了如何使用策略对象来更改 ANTLR 的错误处理。但是，替换策略会更改所有规则的策略。要更改单个规则的异常处理，请在规则定义后指定异常。
</p><p>
In Section 9.5, <a href="#f_0062.html.sec.error-handling">​<em>Altering ANTLR’s Error Handling Strategy</em>​</a>, we saw how to use a strategy object to alter ANTLR’s
error handling. Replacing the strategy changes the strategy for all rules, however. To alter
the exception handling for a single rule, specify an exception after the rule definition.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r   :   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">catch</strong>[RecognitionException e] { throw e; }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19BF6">
该示例演示了如何避免默认的错误报告和恢复。<code class="cf keyword">r</code>
重新抛出异常，这在更高级别的规则报告错误更有意义时很有用。指定任何异常子句都会阻止 ANTLR 生成子句来处理<code class="cf class">RecognitionException</code>。
</p><p>
That example demonstrates how to avoid default error reporting and recovery. <code class="cf keyword">r</code>
rethrows the exception, which is useful when it makes more sense for a higher-level rule to
report the error. Specifying any exception clause prevents ANTLR from generating a clause to
handle <code class="cf class">RecognitionException</code>.
</p>
<p id="f_0093.html.N19BFF">
您也可以指定其他例外情况。
</p><p>
You can specify other exceptions as well.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r   :   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">catch</strong>[FailedPredicateException fpe] { ... }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">catch</strong>[RecognitionException e] { ... }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19C1D">
在这种情况下，花括号内的代码片段和异常“参数”操作必须用目标语言（Java）编写。
</p><p>
The code snippets inside curly braces and the exception “argument” actions must be written in the target language, Java, in this case.
</p>
<p id="f_0093.html.N19C20">
当即使发生异常也需要执行某个操作时，请将其放入该
<code class="cf keyword">finally</code>子句中。
</p><p>
When you need to execute an action even if an exception occurs, put it into the
<code class="cf keyword">finally</code> clause.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r   :   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <em class="comment">// catch blocks go first</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">finally</strong> { System.out.println(<em class="string">"exit rule r"</em>); }​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19C43">
  该<code class="cf keyword">finally</code>子句在规则触发之前执行，
  <code class="cf methodname">exitRule</code>然后返回。如果您想在规则完成匹配替代方案之后但在执行清理工作之前执行操作，请使用操作
  <code class="cf keyword">after</code>。
  </p><p>
  The <code class="cf keyword">finally</code> clause executes right before the rule triggers
  <code class="cf methodname">exitRule</code> before returning. If you want to execute an action after the
  rule finishes matching the alternatives but before it does its cleanup work, use an
  <code class="cf keyword">after</code> action.
  </p>
<p id="f_0093.html.N19C55">
以下是完整的例外列表：
</p><p>
Here’s a complete list of exceptions:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="width:30%">
<p class="last-para-in-cell">
<code class="cf class">RecognitionException</code>
</p><p class="last-para-in-cell">
<code class="cf class">RecognitionException</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
ANTLR 生成的识别器抛出的所有异常的超类。它是的子类，<code class="cf class">RuntimeException</code>可避免受检异常带来的麻烦。此异常记录识别器（词法分析器或解析器）在输入中的位置、在 ATN（表示语法的内部图形数据结构）中的位置、规则调用堆栈以及发生了哪种问题。
    </p><p class="last-para-in-cell">
The superclass of all exceptions thrown by an ANTLR-generated
recognizer.  It’s a subclass of <code class="cf class">RuntimeException</code> to avoid the hassles of checked exceptions.  This exception records where the recognizer (lexer or parser) was in the input, where it was in the ATN (internal graph data structure representing the grammar), the rule invocation stack, and what kind of problem occurred.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<p class="last-para-in-cell">
<code class="cf class">NoViableAltException</code>
</p><p class="last-para-in-cell">
<code class="cf class">NoViableAltException</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
表示解析器无法通过查看剩余输入来决定采用两条或多条路径中的哪一条。此异常会跟踪有问题的输入的起始标记，并且还会知道发生错误时解析器在各个路径中的位置。
    </p><p class="last-para-in-cell">
Indicates that the parser could not decide which of two or more paths
to take by looking at the remaining input.  This exception tracks the starting token
of the offending input and also knows where the parser was
in the various paths when the error occurred.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<p class="last-para-in-cell">
<code class="cf class">LexerNoViableAltException</code>
</p><p class="last-para-in-cell">
<code class="cf class">LexerNoViableAltException</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
    	但仅适用<code class="cf class">NoViableAltException</code>于词法分析器。
    </p><p class="last-para-in-cell">
    	The equivalent of <code class="cf class">NoViableAltException</code> but for lexers only.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<p class="last-para-in-cell">
<code class="cf class">InputMismatchException</code>
</p><p class="last-para-in-cell">
<code class="cf class">InputMismatchException</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
     当前输入与<code class="cf class">Token</code>解析器的预期不匹配。
    </p><p class="last-para-in-cell">
     The current input <code class="cf class">Token</code> does not match what the parser expected.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="width:30%">
<p class="last-para-in-cell">
<code class="cf class">FailedPredicateException</code>
</p><p class="last-para-in-cell">
<code class="cf class">FailedPredicateException</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
	在预测过程中求值为假的语义谓词将导致周围的替代方案不可行。当规则预测要采取哪种替代方案时，就会发生预测。如果所有可行路径都消失了，解析器将抛出<code class="cf class">NoViableAltException</code>。在匹配标记和调用规则的正常解析过程中，当语义谓词在预测之外求值为假时，解析器会抛出此异常。
    </p><p class="last-para-in-cell">
	A semantic predicate that evaluates to false during prediction renders the surrounding alternative nonviable. Prediction occurs when a rule is predicting which alternative to take.  If all  viable paths disappear, the parser will throw <code class="cf class">NoViableAltException</code>.  This exception gets thrown by the parser when a semantic predicate  evaluates to false outside of prediction, during the normal parsing process of matching tokens and calling rules.
    </p>
</td>
</tr>
</tbody>
</table>
<h3>规则属性定义</h3><h3>Rule Attribute Definitions</h3>
<p id="f_0093.html.N19CBB">
规则中有许多与动作相关的语法元素需要注意。规则可以具有参数、返回值和局部变量，就像编程语言中的函数一样。（规则可以在规则元素中嵌入动作，我们将在第 15.4 节“动作<a href="#f_0094.html.sec.actions">和<em>属性”</em>中看到。</a> ）ANTLR 收集您定义的所有变量并将它们存储在规则上下文对象中。这些变量通常称为
<span class="firstuseinline">属性</span>。以下是显示所有可能的属性定义位置的一般语法：
</p><p>
There are a number of action-related syntax elements associated with rules to be aware of.
Rules can have arguments, return values, and local variables just like functions in a
programming language. (Rules can have actions embedded among the rule elements, as we’ll see
in Section 15.4, <a href="#f_0094.html.sec.actions">​<em>Actions and Attributes</em>​</a>.) ANTLR collects all of the variables you define and stores
them in the rule context object. These variables are usually called
<span class="firstuseinline">attributes</span>. Here’s the general syntax showing all possible attribute
definition locations:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rulename[args] <strong class="prompt">returns</strong> [retvals] <strong class="prompt">locals</strong> [localvars] : ... ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19CEB">
其中定义的属性<code class="cf ic">[...]</code>可以像任何其他变量一样使用。以下是将参数复制到返回值的示例规则：
</p><p>
The attributes defined within those <code class="cf ic">[...]</code> can be used like any other variable.  Here is a sample rule that copies parameters to return values:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">// Return the argument plus the integer value of the INT token</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​add[int x] <strong class="prompt">returns</strong> [int result] : <em class="string">'+='</em> INT {$result = $x + $INT.int;} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19D07">
与语法级别一样，您可以指定规则级别的命名操作。对于规则，有效名称为<code class="cf keyword">init</code>和<code class="cf keyword">after</code>。顾名思义，解析器<code class="cf keyword">init</code>在尝试匹配相关规则之前立即执行操作，并<code class="cf keyword">after</code>在匹配规则后立即执行操作。ANTLR
<code class="cf keyword">after</code>操作不作为<code class="cf keyword">finally</code>
生成的规则函数的代码块的一部分执行。使用 ANTLR<code class="cf keyword">finally</code>操作将代码放置在生成的规则函数<code class="cf keyword">finally</code>代码块中。
</p><p>
As with the grammar level, you can specify rule-level named actions. For rules, the valid
names are <code class="cf keyword">init</code> and <code class="cf keyword">after</code>. As the names imply, parsers
execute <code class="cf keyword">init</code> actions immediately before trying to match the associated
rule and execute <code class="cf keyword">after</code> actions immediately after matching the rule. ANTLR
<code class="cf keyword">after</code> actions do not execute as part of the <code class="cf keyword">finally</code>
code block of the generated rule function. Use the ANTLR <code class="cf keyword">finally</code> action to
place code in the generated rule function <code class="cf keyword">finally</code> code block.
</p>
<p id="f_0093.html.N19D31">
这些操作位于任何参数、返回值或本地属性定义操作之后。
<code class="cf keyword">row</code>第 10.2 节“<a href="#f_0065.html.sec.token-rule-attributes">访问<em>令牌和规则属性”</em></a>中的规则前言
很好地
<a href="#f_0065.html.sec.token-rule-attributes">说明了</a></p><p>
The actions come after any argument, return value, or local attribute definition actions. The
<code class="cf keyword">row</code> rule preamble from Section 10.2, <a href="#f_0065.html.sec.token-rule-attributes">​<em>Accessing Token and Rule Attributes</em>​</a>
illustrates the syntax nicely.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/actions/CSV.g4">动作/CSV.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Derived from rule "row : field (',' field)* '\r'? '\n' ;" */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​row[String[] columns] <strong class="prompt">returns</strong> [Map&lt;String,String&gt; values]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int col=0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@init</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    $values = new HashMap&lt;String,String&gt;();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@after</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    if ($values!=null &amp;&amp; $values.size()&gt;0) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        System.out.println(<em class="string">"values = "</em>+$values);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19D72">
规则<code class="cf keyword">row</code>接受参数<code class="cf variable">columns</code>，返回<code class="cf variable">values</code>并定义局部变量<code class="cf variable">col</code>。方括号中的“操作”直接复制到生成的代码中。
</p><p>
Rule <code class="cf keyword">row</code> takes argument <code class="cf variable">columns</code>, returns <code class="cf variable">values</code>, and defines local variable <code class="cf variable">col</code>. The “actions” in square brackets are copied directly into the generated code.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> CSVParser <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    public <strong class="prompt">static</strong> <strong class="prompt">class</strong> RowContext <strong class="prompt">extends</strong> ParserRuleContext {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">String</strong>
<strong class="prompt">[]</strong> columns;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt; values;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <strong class="prompt">public</strong> <strong class="prompt">int</strong> col=0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19DD6">
生成的规则函数也将规则参数指定为函数参数，但它们很快就会被复制到本地<code class="cf class">RowContext</code>对象中。
</p><p>
The generated rule functions also specify the rule arguments as function arguments, but they are quickly copied into the local <code class="cf class">RowContext</code> object.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> CSVParser <strong class="prompt">extends</strong> <strong class="prompt">Parser</strong> {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    public <strong class="prompt">final</strong> RowContext row(<strong class="prompt">String</strong>
<strong class="prompt">[]</strong> columns) <strong class="prompt">throws</strong> RecognitionException {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        RowContext _localctx = <strong class="prompt">new</strong> RowContext(_ctx, 4, columns);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        enterRule(_localctx, RULE_row);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19E19">
ANTLR 跟踪<code class="cf ic">[...]</code>动作中的嵌套，以便<code class="cf ic">String[] columns</code>正确解析。它还跟踪尖括号，以便通用类型参数中的逗号不表示另一个属性的开始。<code class="cf ic">Map&lt;String,String&gt; values</code>是一个属性定义。
</p><p>
ANTLR tracks nested <code class="cf ic">[...]</code> within the action so that <code class="cf ic">String[] columns</code> is
parsed properly. It also tracks angle brackets so that commas within generic type parameters
do not signify the start of another attribute. <code class="cf ic">Map&lt;String,String&gt; values</code> is one
attribute definition.
</p>
<p id="f_0093.html.N19E25">
每个操作中可以有多个属性，甚至返回值也可以。使用逗号分隔同一操作中的属性。
</p><p>
There can be multiple attributes in each action, even for return values. Use a comma to
separate attributes within the same action.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a[Map&lt;String,String&gt; x, int y] : ... ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19E34">
ANTLR 将该操作解释为定义两个参数，<code class="cf variable">x</code>和<code class="cf variable">y</code>。
</p><p>
ANTLR interprets that action to define two arguments, <code class="cf variable">x</code> and <code class="cf variable">y</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">final</strong> AContext a(<strong class="prompt">Map</strong>&lt;<strong class="prompt">String</strong>,<strong class="prompt">String</strong>&gt; x, <strong class="prompt">int</strong> y)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">throws</strong> RecognitionException​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    AContext _localctx = <strong class="prompt">new</strong> AContext(_ctx, 0, x, y);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    enterRule(_localctx, RULE_a);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<h3>开始规则和 EOF</h3><h3>Start Rules and EOF</h3>
<p id="f_0093.html.N19E7C"><span class="firstuseinline">起始规则</span>
是解析器首先使用的规则；它是语言应用程序调用的规则函数。例如，解析 Java 代码的语言应用程序可能会调用名为的对象<code class="cf ic">parser.compilationUnit()</code>。语法中的任何规则都可以充当起始规则。
<code class="cf class">JavaParser</code><code class="cf variable">parser</code></p><p>
A <span class="firstuseinline">start rule</span> is the rule engaged first by the parser; it’s the rule function called by the language application. For example, a language application that parses Java code might call <code class="cf ic">parser.compilationUnit()</code> on a <code class="cf class">JavaParser</code> object called <code class="cf variable">parser</code>. Any rule in the grammar can act as a start rule.
</p>
<p id="f_0093.html.N19E93">
开始规则不一定会使用所有输入。它们仅使用匹配规则替代方案所需的输入量。例如，请考虑以下匹配一个、两个或三个标记的规则，具体取决于输入：
</p><p>
Start rules don’t necessarily consume all of the input.  They consume only as much input as needed to match an alternative of the rule. For example, consider the following rule that matches one, two, or three tokens, depending on the input:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​s : ID​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | ID <em class="string">'+'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  | ID <em class="string">'+'</em> INT​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19EB0">
当 时<code class="cf ic">a+3</code>，规则<code class="cf keyword">s</code>匹配第三个备选方案。当 时
<code class="cf ic">a+b</code>，它匹配第二个备选方案并忽略最后一个<code class="cf ic">b</code>标记。当 时
<code class="cf ic">a b</code>，它匹配第一个备选方案并忽略<code class="cf ic">b</code>标记。在后两种情况下，解析器不会使用完整的输入，因为规则
<code class="cf keyword">s</code>没有明确说明文件结尾必须出现在匹配规则的备选方案之后。 
</p><p>
Upon <code class="cf ic">a+3</code>, rule <code class="cf keyword">s</code> matches the third alternative. Upon
<code class="cf ic">a+b</code>, it matches the second alternative and ignores the final <code class="cf ic">b</code> token. Upon
<code class="cf ic">a b</code>, it matches the first alternative, ignoring the <code class="cf ic">b</code> token. The parser
does not consume the complete input in the latter two cases because rule
<code class="cf keyword">s</code> doesn’t explicitly say that the end of file must occur after matching
an alternative of the rule. 
</p>
<p id="f_0093.html.N19EC8">
此默认功能对于构建诸如 IDE 之类的东西非常有用。想象一下，IDE 想要解析大型 Java 文件中某个方法。调用规则<code class="cf keyword">methodDeclaration</code>应该尝试仅匹配一个方法，而忽略接下来的内容。
</p><p>
This default functionality is very useful for building things such as
IDEs. Imagine the IDE wanting to parse a method somewhere in the middle of a big Java file.
Calling rule <code class="cf keyword">methodDeclaration</code> should try to match just a method and
ignore whatever comes next.
</p>
<p id="f_0093.html.N19ECE">
另一方面，描述整个输入文件的规则应该引用特殊的预定义标记<code class="cf keyword">EOF</code>。如果没有，您可能会绞尽脑汁想为什么启动规则不会报告任何输入的错误，无论您输入什么。以下是读取配置文件语法的一部分规则：
</p><p>
On the other hand, rules that describe entire input files should reference special
predefined-token <code class="cf keyword">EOF</code>. If they don’t, you might scratch your head for a
while wondering why the start rule doesn’t report errors for any input no matter what you
give it. Here’s a rule that’s part of a grammar for reading configuration files:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​config : element*; <em class="comment">// can "match" even with invalid input.</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0093.html.N19EEC">
无效输入会导致<code class="cf keyword">config</code>立即返回，不匹配任何输入，也不报告错误。以下是正确的规范：
</p><p>
Invalid input would cause <code class="cf keyword">config</code> to return immediately without matching any input and without reporting  an error. Here’s the proper specification:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : element* <strong class="prompt">EOF</strong>; <em class="comment">// don't stop early. must match all input</em>​</code></div>
</td>
</tr>
</tbody></table>

</div></div>
<div id="f_0094.html"><div>

<h2 id="f_0094.html.sec.actions">15.4 动作和属性</h2><h2>15.4 Actions and Attributes</h2>
<p id="f_0094.html.N19F0B">
在第 10 章<a href="#f_0063.html.chp.actions">“属性<em>和动作”</em>中，</a>我们学习了如何在语法中嵌入动作，并研究了最常见的标记和规则属性。本节总结了该章中的重要语法和语义，并提供了所有可用属性的完整列表。
</p><p>
In Chapter 10, <a href="#f_0063.html.chp.actions">​<em>Attributes and Actions</em>​</a>, we learned how to embed actions within grammars and looked at the most common token and rule attributes.  This section summarizes the important syntax and semantics from that chapter and provides a complete list of all available attributes.
</p>
<p id="f_0094.html.N19F11">
  动作是用目标语言编写的文本块，并用花括号括起来。识别器根据它们在语法中的位置触发它们。例如，
  <code class="cf ic">found a decl</code>解析器看到有效声明后会发出以下规则：
</p><p>
  Actions are blocks of text written in the target language and enclosed
  in curly braces.  The recognizer triggers them according to their
  locations within the grammar. For example, the following rule emits
  <code class="cf ic">found a decl</code> after the parser has seen a valid declaration:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl: type ID <em class="string">';'</em> {System.out.println(<em class="string">"found a decl"</em>);} ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​type: <em class="string">'int'</em> | <em class="string">'float'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N19F37">
大多数情况下，动作访问令牌和规则引用的属性。
</p><p>
Most often, actions access the attributes of tokens and rule references.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl: type ID <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {System.out.println(<em class="string">"var "</em>+$ID.text+<em class="string">":"</em>+$type.text+<em class="string">";"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | t=ID id=ID <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {System.out.println(<em class="string">"var "</em>+$id.text+<em class="string">":"</em>+$t.text+<em class="string">";"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<h3 id="f_0094.html.sec.token-attributes">代币属性</h3><h3>Token Attributes</h3>
<p id="f_0094.html.N19F6D">
  所有标记都具有一组预定义的只读属性。这些属性包括有用的标记属性，例如标记类型和与标记匹配的文本。操作可以通过
  <code class="cf ic">$</code>
<span class="standin">标签</span>访问这些属性。<span class="standin">属性</span>，其中
  <span class="standin">标签</span>标记标记引用的特定实例（在下面的示例中<code class="cf variable">a</code>，和<code class="cf variable">b</code>在操作代码中用作<code class="cf ic">$a</code>和<code class="cf ic">$b</code>）。通常，特定标记在规则中仅被引用一次，在这种情况下，标记名称本身可以在操作代码中明确使用（标记<code class="cf keyword">INT</code>可以在操作中用作<code class="cf ic">$INT</code>）。以下示例说明了标记属性表达式语法：
</p><p>
  All tokens have a collection of predefined, read-only attributes. The attributes include
  useful token properties such as the token type and text matched for a token. Actions can
  access these attributes via
  <code class="cf ic">$</code>
<span class="standin">label</span>.<span class="standin">attribute</span> where
  <span class="standin">label</span> labels a particular instance of a token reference
  (<code class="cf variable">a</code> and <code class="cf variable">b</code> in the following example are used in the
  action code as <code class="cf ic">$a</code> and <code class="cf ic">$b</code>). Often, a particular token is  referenced only
  once in the rule, in which case the token name itself can be used unambiguously in the
  action code (token <code class="cf keyword">INT</code> can be used as <code class="cf ic">$INT</code> in the action). The
  following example illustrates token attribute expression syntax:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r   :   INT {int x = $INT.line;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        ( ID {if ($INT.line == $ID.line) ...;} )?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        a=FLOAT b=FLOAT {if ($a.line == $b.line) ...;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N19FB1">
  子规则内的操作<code class="cf ic">(...)?</code>可以看到
  <code class="cf keyword">INT</code>外层中在它之前匹配的标记。
</p><p>
  The action within the <code class="cf ic">(...)?</code> subrule can see the
  <code class="cf keyword">INT</code> token matched before it in the outer level.
</p>
<p id="f_0094.html.N19FBA">
  由于对该令牌有两个引用，因此操作中
<code class="cf keyword">FLOAT</code>
  的引用不是唯一的；您必须使用标签来指定您感兴趣的令牌引用。<code class="cf ic">$FLOAT</code></p><p>
  Because there are two references to the <code class="cf keyword">FLOAT</code>
  token, a reference to <code class="cf ic">$FLOAT</code> in an action is not unique;
  you must use labels to specify which token reference you’re
  interested in.
</p>
<p id="f_0094.html.N19FC3">
  不同备选方案中的标记引用是唯一的，因为对于规则的任何调用，只能匹配其中一个。例如，在下面的规则中，两个备选方案中的操作都可以<code class="cf ic">$ID</code>直接引用，而无需使用标签。
</p><p>
  Token references within different alternatives are unique because
  only one of them can be matched for any invocation of the rule.  For
  example, in the following rule, actions in both alternatives can
  reference <code class="cf ic">$ID</code> directly without using a label.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​r   :   ... ID {System.out.println($ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ... ID {System.out.println($ID.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N19FDB">
  要访问与文字匹配的标记，必须使用标签。
</p><p>
  To access the tokens matched for literals, you must use a label.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   r=<em class="string">'return'</em> expr <em class="string">';'</em> {System.out.println(<em class="string">"line="</em>+$r.line);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N19FF3">
  大多数情况下，您会访问令牌的属性，但有时访问对象<code class="cf class">Token</code>本身也很有用，因为它会聚合所有属性。此外，您还可以使用它来测试可选子规则是否与令牌匹配。
</p><p>
  Most of the time you access the attributes of the token, but sometimes it is useful to
  access the <code class="cf class">Token</code> object itself because it aggregates all the attributes.
  Further, you can use it to test whether an optional subrule matched a token.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'if'</em> expr <em class="string">'then'</em> stat (el=<em class="string">'else'</em> stat)?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​      {if ( $el!=null ) System.out.println(<em class="string">"found an else"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A01A">
<code class="cf ic">$</code>
<span class="standin">T</span>和<code class="cf ic">$</code>
<span class="standin">l</span>计算结果
<code class="cf class">Token</code>为标记名称<span class="standin">T</span>和标记标签
<span class="standin">l</span>的对象。<code class="cf ic">$</code>
<span class="standin">ll</span>计算结果
<code class="cf class">List&lt;Token&gt;</code>为列表标签<span class="standin">ll 的</span>对象。
 <code class="cf ic">$</code>
<span class="standin">T </span>
<code class="cf ic">.</code>
<span class="standin">attr计算结果为属性</span><span class="standin">attr</span>下表中指定的类型和值：
</p><p>
<code class="cf ic">$</code>
<span class="standin">T</span> and <code class="cf ic">$</code>
<span class="standin">l</span> evaluate to
<code class="cf class">Token</code> objects for token name <span class="standin">T</span> and token label
<span class="standin">l</span>. <code class="cf ic">$</code>
<span class="standin">ll</span> evaluates to
<code class="cf class">List&lt;Token&gt;</code> for list label <span class="standin">ll</span>.
<code class="cf ic">$</code>
<span class="standin">T</span>
<code class="cf ic">.</code>
<span class="standin">attr</span> evaluates to the type and
value specified in the following table for attribute <span class="standin">attr</span>:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">text</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">text</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">String</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">String</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">与标记匹配的文本；转换为对 的调用<code class="cf methodname">getText</code>。例如：<code class="cf ic">$ID.text</code>。
    </p><p class="last-para-in-cell">The text matched for the token; translates to a call to <code class="cf methodname">getText</code>. Example: <code class="cf ic">$ID.text</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">type</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">type</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      标记的标记类型（非零正整数）如
      <code class="cf keyword">INT</code>; 转换为对 的调用
      <code class="cf methodname">getType</code>。例如：<code class="cf ic">$ID.type</code>。
    </p><p class="last-para-in-cell">
      The token type (nonzero positive integer) of the token such as
      <code class="cf keyword">INT</code>; translates to a call to
      <code class="cf methodname">getType</code>.  Example: <code class="cf ic">$ID.type</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">line</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">line</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      标记出现的行号从 1 开始计数；转换为对 的调用<code class="cf methodname">getLine</code>。例如：<code class="cf ic">$ID.line</code>。
    </p><p class="last-para-in-cell">
      The line number on which the token
      occurs, counting from 1; translates to a call to <code class="cf methodname">getLine</code>.  Example: <code class="cf ic">$ID.line</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">pos</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">pos</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      标记的第一个字符在行中出现的字符位置（从零开始计算）；转换为对 的调用<code class="cf methodname">getCharPositionInLine</code>。例如：<code class="cf ic">$ID.pos</code>。
    </p><p class="last-para-in-cell">
      The character position within the line at which the token’s
      first character occurs counting from zero; translates to a call
      to <code class="cf methodname">getCharPositionInLine</code>.  Example: <code class="cf ic">$ID.pos</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">index</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">index</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      此标记在标记流中的总体索引，从零开始计数；转换为对 的调用
      <code class="cf methodname">getTokenIndex</code>。例如：<code class="cf ic">$ID.index</code>。
    </p><p class="last-para-in-cell">
      The overall index of this token in the token stream, counting
      from zero; translates to a call to
      <code class="cf methodname">getTokenIndex</code>.  Example: <code class="cf ic">$ID.index</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">channel</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">channel</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      标记的通道号。解析器仅调整到一个通道，从而有效地忽略了通道外的标记。默认通道为 0 ( <code class="cf ic">Token.DEFAULT_CHANNEL</code>)，默认隐藏通道为<code class="cf ic">Token.HIDDEN_CHANNEL</code>。转换为对 的调用<code class="cf methodname">getChannel</code>。示例：<code class="cf ic">$ID.channel</code>。
    </p><p class="last-para-in-cell">
      The token’s channel number. The parser tunes to only one
      channel, effectively ignoring off-channel tokens.  The default
      channel is 0 (<code class="cf ic">Token.DEFAULT_CHANNEL</code>), and the default
      hidden channel is <code class="cf ic">Token.HIDDEN_CHANNEL</code>. Translates to a call to <code class="cf methodname">getChannel</code>.  Example: <code class="cf ic">$ID.channel</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">int</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      此标记所保存的文本的整数值；它假定文本是有效的数字字符串。对于构建计算器等很方便。转换为<code class="cf ic">Integer.valueOf(text-of-token)</code>。示例：<code class="cf ic">$INT.int</code>。
    </p><p class="last-para-in-cell">
      The integer value of the text held by this token; it assumes that the text is a valid numeric string. Handy for building calculators and so on.  Translates to <code class="cf ic">Integer.valueOf(text-of-token)</code>. Example: <code class="cf ic">$INT.int</code>.
    </p>
</td>
</tr>
</tbody>
</table>
<h3 id="f_0094.html.sec.rule-attributes">解析器规则属性</h3><h3>Parser Rule Attributes</h3>
<p id="f_0094.html.N1A11D">
ANTLR 预定义了许多与解析器规则引用相关的只读属性，这些属性可供操作使用。操作只能访问操作之前的引用的规则属性。语法为<code class="cf ic">$</code>
<span class="standin">r</span> . <span class="standin">attr</span>，表示规则名称<span class="standin">r</span>或分配给规则引用的标签。例如，
<code class="cf ic">$expr.text</code>返回与先前调用规则匹配的完整文本
<code class="cf keyword">expr</code>。
</p><p>
ANTLR predefines a number of read-only attributes associated with parser rule references
that are available to actions. Actions can access rule attributes only for references that
precede the action. The syntax is <code class="cf ic">$</code>
<span class="standin">r</span>.<span class="standin">attr</span> for
rule name <span class="standin">r</span> or a label assigned to a rule reference. For example,
<code class="cf ic">$expr.text</code> returns the complete text matched by a preceding invocation of rule
<code class="cf keyword">expr</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​returnStat : <em class="string">'return'</em> expr {System.out.println(<em class="string">"matched "</em>+$expr.text);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A14F">
使用规则标签如下所示：
</p><p>
Using a rule label looks like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​returnStat : <em class="string">'return'</em> e=expr {System.out.println(<em class="string">"matched "</em>+$e.text);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A164">
您还可以使用<code class="cf ic">$</code>后跟属性名称来访问与当前正在执行的规则关联的值。例如，<code class="cf ic">$start</code>是当前规则的起始标记。
</p><p>
You can also use <code class="cf ic">$</code> followed by the name of the attribute
to access the value associated with the currently executing rule. For example, <code class="cf ic">$start</code> is the starting token of the current rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​returnStat : <em class="string">'return'</em> expr {System.out.println(<em class="string">"first token "</em>+$start.getText());} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A17F">
<code class="cf ic">$</code>
<span class="standin"></span>对于规则名称<span class="standin">r</span>和规则标签<span class="standin">rl ，</span><span class="standin">r</span>和<code class="cf ic">$</code>
<span class="standin">rl</span>计算结果为
类型<span class="standin">R</span><code class="cf class">ParserRuleContext</code>的对象 
。对于规则列表标签<span class="standin">rll ， </span><span class="standin">rll</span>计算结果为
<span class="standin">R</span>。
对于属性<span class="standin">attr ，</span><span class="standin">r </span><span class="standin">attr</span>计算结果为下表中指定的类型和值：
<span class="standin"></span>
<code class="cf class">Context</code><span class="standin"></span><span class="standin"></span><code class="cf ic">$</code>
<span class="standin"></span><code class="cf ic">List&lt;</code>
<span class="standin"></span>
<code class="cf class">Context</code>
<code class="cf ic">&gt;</code><span class="standin"></span><code class="cf ic">$</code>
<span class="standin"></span>
<code class="cf ic">.</code>
<span class="standin"></span><span class="standin"></span></p><p>
<code class="cf ic">$</code>
<span class="standin">r</span> and <code class="cf ic">$</code>
<span class="standin">rl</span> evaluate to
<code class="cf class">ParserRuleContext</code> objects of type 
<span class="standin">R</span>
<code class="cf class">Context</code> for rule name <span class="standin">r</span> and rule
label <span class="standin">rl</span>. <code class="cf ic">$</code>
<span class="standin">rll</span> evaluates to
<code class="cf ic">List&lt;</code>
<span class="standin">R</span>
<code class="cf class">Context</code>
<code class="cf ic">&gt;</code> for rule list
label <span class="standin">rll</span>.
<code class="cf ic">$</code>
<span class="standin">r</span>
<code class="cf ic">.</code>
<span class="standin">attr</span> evaluates to the type and
value specified in the following table for attribute <span class="standin">attr</span>:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">text</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">text</code>
</p>
</td>
<td style="width:25%">
<p class="last-para-in-cell">
<code class="cf keyword">String</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">String</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
 规则匹配的文本或从规则开始到表达式<code class="cf ic">$text</code>求值点匹配的文本。请注意，这包括所有标记的文本（包括隐藏通道上的标记），这正是您想要的，因为通常其中包含所有空格和注释。引用当前规则时，此属性在任何操作（包括任何异常操作）中都可用。
      </p><p class="last-para-in-cell">
 The text matched for a rule or	the text matched from the start of the rule up until the point
	of the <code class="cf ic">$text</code> expression evaluation. Note that this
	includes the text for all tokens including those on hidden
	channels, which is what you want because usually that has all
	the whitespace and comments.  When referring to the current
	rule, this attribute is available in any action including any
	exception actions.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">start</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">start</code>
</p>
</td>
<td style="width:25%">
<p class="last-para-in-cell">
<code class="cf keyword">Token</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">Token</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
	主令牌通道上规则可能匹配的第一个令牌；换句话说，此属性绝不是隐藏令牌。对于最终不匹配任何令牌的规则，此属性指向此规则可能匹配的第一个令牌。当引用当前规则时，此属性可用于规则内的任何操作。
      </p><p class="last-para-in-cell">
	The first token to be potentially matched by the rule that is
	on the main token channel; in other words, this attribute is
	never a hidden token. For rules that end up matching no
	tokens, this attribute points at the first token that could
	have been matched by this rule.  When referring to the current
	rule, this attribute is available to any action within the
	rule.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">stop</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">stop</code>
</p>
</td>
<td style="width:25%">
<p class="last-para-in-cell">
<code class="cf keyword">Token</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">Token</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
	规则要匹配的最后一个非隐藏通道标记。引用当前规则时，此属性仅适用于<code class="cf keyword">after</code>和<code class="cf keyword">finally</code>操作。
      </p><p class="last-para-in-cell">
	The last nonhidden channel token to be matched by the rule.
	When referring to the current rule, this attribute is
	available only to the <code class="cf keyword">after</code> and <code class="cf keyword">finally</code> actions.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf keyword">ctx</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">ctx</code>
</p>
</td>
<td style="width:25%">
<p class="last-para-in-cell">
<code class="cf keyword">ParserRuleContext</code>
</p><p class="last-para-in-cell">
<code class="cf keyword">ParserRuleContext</code>
</p>
</td>
<td style="">
<p class="last-para-in-cell">
      与规则调用关联的规则上下文对象。所有其他属性都可以通过此属性获得。例如，<code class="cf ic">$ctx.start</code>访问<code class="cf variable">start</code>当前规则上下文对象中的字段。它与相同<code class="cf ic">$start</code>。
      </p><p class="last-para-in-cell">
      The rule context object associated with a rule invocation. All of the other attributes are available through this attribute. For example, <code class="cf ic">$ctx.start</code> accesses the <code class="cf variable">start</code> field within the current rules context object. It’s the same as <code class="cf ic">$start</code>.
      </p>
</td>
</tr>
</tbody>
</table>
<h3>动态范围属性</h3><h3>Dynamically Scoped Attributes</h3>
<p id="f_0094.html.N1A22F">
您可以使用参数和返回值向规则传递信息，就像通用编程语言中的函数一样。但是，编程语言不允许函数访问调用函数的局部变量或参数。</p><p>
You can pass information to and from rules using parameters and return values, just like
functions in a general-purpose programming language. Programming languages don’t allow
functions to access the local variables or parameters of invoking functions, however.</p>
<p id="f_0094.html.N1A23C">例如，<code class="cf variable">x</code>在 Java 中，以下从嵌套方法调用对局部变量的引用是非法的：
</p><p>For example, the following reference to local variable <code class="cf variable">x</code> from a 
nested method call is illegal in Java:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> f() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> x = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    g();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> g() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    h();​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">void</strong> h() {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">int</strong> y = x; <em class="comment">// INVALID reference to f's local variable x</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A277">
  变量<code class="cf variable">x</code>仅在 的范围内可用<code class="cf methodname">f</code>，该范围是用大括号在词法上分隔的文本。因此，Java 被称为使用<span class="firstuseinline">词法作用域</span>。词法作用域是大多数编程语言的标准。<a id="f_0094.html.FNPTR-59" href="#f_0099.html.FOOTNOTE-59">[59]</a>允许调用链中下游的方法访问先前定义的局部变量的语言被称为使用<span class="firstuseinline">动态作用域</span>。术语<span class="emph">“动态”</span>指的是编译器无法静态确定可见变量集。这是因为方法可见的变量集会根据调用该方法的人而变化。
</p><p>
  Variable <code class="cf variable">x</code> is available only within the scope of <code class="cf methodname">f</code>,
  which is the text lexically delimited by curly brackets. For this reason, Java is said to
  use <span class="firstuseinline">lexical scoping</span>. Lexical scoping is the norm for most programming
  languages.<a href="#f_0099.html.FOOTNOTE-59">[59]</a> Languages that allow methods further down in the call chain to access
  local variables defined earlier are said to use <span class="firstuseinline">dynamic scoping</span>. The
  term <span class="emph">dynamic</span> refers to the fact that a compiler cannot statically determine
  the set of visible variables. This is because the set of variables visible to a method
  changes depending on who calls that method.
</p>
<p id="f_0094.html.N1A291">
事实证明，在语法领域，远距离规则有时需要相互通信，主要是为了向规则调用链中下方匹配的规则提供上下文信息。（当然，这假设您直接在语法中使用操作，而不是使用解析树侦听器事件机制。）ANTLR 允许动态作用域，即操作可以使用语法访问调用规则的属性，<code class="cf ic">$r::x</code>其中
<code class="cf keyword">r</code>是规则名称，<code class="cf variable">x</code>是该规则内的属性。程序员需要确保实际上是当前规则的调用规则。如果访问时不在当前调用链中，<code class="cf keyword">r</code>则会发生运行时异常。
<code class="cf keyword">r</code><code class="cf ic">$r::x</code></p><p>
It turns out that, in the grammar realm, distant rules sometimes need to communicate with
each other, mostly to provide context information to rules matched below in the rule
invocation chain. (Naturally, this assumes you are using actions directly in the
grammar instead of the parse-tree listener event mechanism.) ANTLR allows dynamic scoping in
that actions can access attributes from invoking rules using syntax <code class="cf ic">$r::x</code> where
<code class="cf keyword">r</code> is a rule name and <code class="cf variable">x</code> is an attribute within that
rule. It is up to the programmer to ensure that <code class="cf keyword">r</code> is in fact an invoking
rule of the current rule. A runtime exception occurs if <code class="cf keyword">r</code> is not in the current call chain when you access <code class="cf ic">$r::x</code>.
</p>
<p id="f_0094.html.N1A2A6">
  为了说明动态作用域的使用，请考虑定义变量并确保表达式中的变量已定义的实际问题。以下语法
  <code class="cf variable">symbols</code>在
  <code class="cf keyword">block</code>规则中定义了属性，但在规则中为其添加了变量名称
  <code class="cf keyword">decl</code>。然后规则<code class="cf keyword">stat</code>查询列表以查看变量是否已定义。
</p><p>
  To illustrate the use of dynamic scoping, consider the real problem
  of defining variables and ensuring that variables in expressions are
  defined. The following grammar defines the
  <code class="cf variable">symbols</code> attribute where it belongs in the
  <code class="cf keyword">block</code> rule but adds variable names to it in rule
  <code class="cf keyword">decl</code>.  Rule <code class="cf keyword">stat</code> then consults
  the list to see whether variables have been defined.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/DynScope.g4">参考/DynScope.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> DynScope;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   block​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​block​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/* List of symbols defined within this block */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    List&lt;String&gt; symbols = new ArrayList&lt;String&gt;()​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   <em class="string">'{'</em> decl* stat+ <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// print out all symbols found in block</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        <em class="comment">// $block::symbols evaluates to a List as defined in scope</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"symbols="</em>+$symbols);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match a declaration and add identifier name to list of symbols */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl:   <em class="string">'int'</em> ID {$block::symbols.add($ID.text);} <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match an assignment then test list of symbols to verify</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  that it contains the variable on the left side of the assignment.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  Method contains() is List.contains() because $block::symbols</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  is a List.</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   ID <em class="string">'='</em> INT <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        if ( !$block::symbols.contains($ID.text) ) {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​            System.err.println(<em class="string">"undefined variable: "</em>+$ID.text);​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   block​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT :   [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  :   [ \t\r\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A34F">
以下是一个简单的构建和测试序列：
</p><p>
Here’s a simple build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 DynScope.g4 </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac DynScope*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun DynScope prog</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  int i;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  i = 0;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">  j = 3;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​undefined variable: j​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​symbols=[i]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A38E"><code class="cf ic">@members</code>
操作中的简单字段声明和动态作用域
之间存在重要区别  。<code class="cf variable">symbols</code>是一个局部变量，因此每次调用规则时都会有一个副本<code class="cf keyword">block</code>。这正是我们对嵌套块的需求，以便我们可以在内部块中重用相同的输入变量名。例如，以下嵌套代码块<code class="cf variable">i</code>在内部作用域中重新定义。这个新定义必须隐藏外部作用域中的定义。
</p><p>
There’s an important difference between a simple field declaration in an  <code class="cf ic">@members</code>
action and dynamic scoping. <code class="cf variable">symbols</code> is a local variable, so there is
a copy for each invocation of rule <code class="cf keyword">block</code>. That’s exactly what we want for
nested blocks so that we can reuse the same input variable name in an inner block. For
example, the following nested code block redefines <code class="cf variable">i</code> in the inner
scope. This new definition must hide the definition in the outer scope.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/nested-input">引用/嵌套输入</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​{​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  int i;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  int j;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  i = 0;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    int i;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    int x;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    x = 5;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  x = 3;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A3CA">
以下是针对该输入生成的输出<code class="cf keyword">DynScope</code>：
</p><p>
Here’s the output generated for that input by <code class="cf keyword">DynScope</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun DynScope prog nested-input</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​symbols=[i, x]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​undefined variable: x​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​symbols=[i, j]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0094.html.N1A3E8">
引用访问最近调用的规则上下文对象的字段<code class="cf ic">$block::symbols</code>。如果您需要访问调用链上更上层的规则调用实例，则可以从当前上下文开始向后走。使用
沿链向上走。
<code class="cf variable">symbols</code><code class="cf keyword">block</code><code class="cf variable">symbols</code><code class="cf ic">$ctx</code><code class="cf methodname">getParent</code></p><p>
Referencing <code class="cf ic">$block::symbols</code> accesses the <code class="cf variable">symbols</code> field of the
most recently invoked <code class="cf keyword">block</code>’s rule context object. If you need access to
a <code class="cf variable">symbols</code> instance from a rule invocation further up the call chain,
you can walk backward starting at the current context, <code class="cf ic">$ctx</code>. Use
<code class="cf methodname">getParent</code> to walk up the chain.
</p>

</div></div>
<div id="f_0095.html"><div>

<h2 id="f_0095.html.sec.lexers">15.5 词法分析器规则</h2><h2>15.5 Lexer Rules</h2>
<p id="f_0095.html.N1A40B">
词法分析器语法由词法分析器规则组成，可以随意分解为多个
<code class="cf keyword">mode</code>规则，如我们在<a href="#f_0074.html.sec.modes-for-tags"><em>​使用词法模式</em></a><a href="#f_0074.html.sec.modes-for-tags">发布<em></em></a>​ 中看到的那样 
<a href="#f_0074.html.sec.modes-for-tags">。</a></p><p>
A lexer grammar is composed of lexer rules, optionally broken into multiple
<code class="cf keyword">mode</code>s, as we saw in <a href="#f_0074.html.sec.modes-for-tags">​<em>Issuing Context-Sensitive Tokens with Lexical Modes</em>​</a>. Lexical modes
allow us to split a single lexer grammar into multiple sublexers. The lexer can  return only
those tokens matched by rules from the current mode. 
</p>
<p id="f_0095.html.N1A41A">
词法分析器规则指定标记定义，并且或多或少遵循解析器规则的语法，但词法分析器规则不能包含参数、返回值或局部变量。词法分析器规则名称必须以大写字母开头，以区别于解析器规则名称。
</p><p>
Lexer rules specify token definitions and more or less follow the syntax of parser rules except that lexer rules cannot have arguments, return values, or local variables. Lexer rule names must begin with an uppercase letter, which distinguishes them from parser rule names.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Optional document comment */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​TokenName : alternative1 | ... | alternativeN ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A433">
您还可以定义不是标记而是有助于识别标记的规则。这些<code class="cf ic">fragment</code>规则不会导致解析器看到标记。
</p><p>
You can also define rules that are not tokens but rather aid in the recognition of tokens. These <code class="cf ic">fragment</code> rules do not result in tokens visible to the parser.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> HelperTokenRule : alternative1 | ... | alternativeN ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A452">
例如，<code class="cf keyword">DIGIT</code>是一个相当常见的<code class="cf keyword">fragment</code>规则。
</p><p>
For example, <code class="cf keyword">DIGIT</code> is a pretty common <code class="cf keyword">fragment</code> rule.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT : DIGIT+ ;           <em class="comment">// references the DIGIT helper rule</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong> DIGIT : [0-9] ; <em class="comment">// not a token by itself</em>​</code></div>
</td>
</tr>
</tbody></table>
<h3>词汇模式</h3><h3>Lexical Modes</h3>
<p id="f_0095.html.N1A474">
模式允许您按上下文（例如 XML 标记的内部和外部）对词汇规则进行分组。这就像拥有多个子词法分析器，其中一个用于上下文。词法分析器只能返回那些通过在当前模式下输入规则而匹配的标记。词法分析器以所谓的默认模式开始。除非您指定命令，否则所有规则都被视为在默认模式中。
<code class="cf keyword">mode</code>组合语法中不允许使用模式，只有
<code class="cf keyword">lexer</code>语法才允许使用模式。（请参阅<a href="#f_0075.html.sec.tokenizing-xml">Tokenizing</a><a href="#f_0075.html.sec.tokenizing-xml"><em> XML</em></a><code class="cf class">XMLLexer</code>中的语法<a href="#f_0075.html.sec.tokenizing-xml">。</a> ）
<a href="#f_0075.html.sec.tokenizing-xml"><em></em></a></p><p>
Modes allow you to group lexical rules by context, such as inside and outside of XML tags.
It’s like having multiple sublexers, with one for context. The lexer can  return only those tokens
matched by entering a rule in the current mode. Lexers start out in the so-called default
mode. All rules are considered to be within the default mode unless you specify a
<code class="cf keyword">mode</code> command. Modes are not allowed within combined grammars, just
<code class="cf keyword">lexer</code> grammars. (See grammar <code class="cf class">XMLLexer</code> from <a href="#f_0075.html.sec.tokenizing-xml">​<em>Tokenizing XML</em>​</a>.)
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rules in default mode​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode MODE1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rules in MODE1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode MODEN;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rules in MODEN​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
</tbody></table>
<h3>词法分析器规则元素</h3><h3>Lexer Rule Elements</h3>
<p id="f_0095.html.N1A4AE">
词法分析器规则允许使用两种解析器规则无法使用的构造：<code class="cf ic">..</code>范围运算符和用方括号 [ <span class="standin">characters</span> ] 括起来的字符集表示法。不要将字符集与解析器规则的参数混淆。[ <span class="standin">characters</span> ] 仅表示词法分析器中的字符集。以下是所有词法分析器规则元素的摘要：
</p><p>
Lexer rules allow two constructs that are unavailable to parser rules: the <code class="cf ic">..</code> range
operator and the character set notation enclosed in square brackets, [<span class="standin">characters</span>]. Don’t confuse character
sets with arguments to parser rules. [<span class="standin">characters</span>] only means character set in a lexer.
Here’s a summary of all lexer rule elements:
</p>
<table class="simpletable ">
<thead>
<tr>
<th>句法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">'<span class="standin">字面意思</span>'</p><p class="last-para-in-cell">’<span class="standin">literal</span>’</p>
</td>
<td style="">
<p class="last-para-in-cell">
	 匹配该字符或字符序列。以下是示例：<code class="cf ic">’while’</code>或<code class="cf ic">’=’</code>。
    </p><p class="last-para-in-cell">
	 Match that character or sequence of characters. Here’s an example: <code class="cf ic">’while’</code> or <code class="cf ic">’=’</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">[<span class="standin">字符集</span>]</p><p class="last-para-in-cell">[<span class="standin">char set</span>]</p>
</td>
<td style="">
<p>
   匹配字符集中指定的一个字符。将<span class="standin">x</span> - <span class="standin">y解释为范围</span><span class="standin">x</span>和<span class="standin">y</span>之间的一组字符（含）。以下转义字符被解释为单个特殊字符：<code class="cf ic">\n</code>、<code class="cf ic">\r</code>、<code class="cf ic">\b</code>、<code class="cf ic">\t</code>和<code class="cf ic">\f</code>。要获得<code class="cf ic">]</code>、<code class="cf ic">\</code>、 或<code class="cf ic">-</code>，您必须使用 对其进行转义<code class="cf ic">\</code>。您还可以使用 Unicode 字符规范：<code class="cf ic">\uXXXX</code>。以下是几个示例：
  </p><p>
   Match one of the characters specified in the character set. Interpret <span class="standin">x</span>-<span class="standin">y</span> as a set of characters between range <span class="standin">x</span> and <span class="standin">y</span>, inclusively. The following escaped characters are interpreted as single special characters: <code class="cf ic">\n</code>, <code class="cf ic">\r</code>, <code class="cf ic">\b</code>, <code class="cf ic">\t</code>, and <code class="cf ic">\f</code>. To get <code class="cf ic">]</code>, <code class="cf ic">\</code>, or <code class="cf ic">-</code>, you must escape them with <code class="cf ic">\</code>. You can also use Unicode character specifications: <code class="cf ic">\uXXXX</code>. Here are a few examples:
  </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​WS : [ \n\u000D] -&gt; skip ;   <em class="comment">// same as [ \n\r]</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​ID : [a-zA-Z] [a-zA-Z0-9]* ; <em class="comment">// match usual identifier spec</em>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​DASHBRACK : [\-\]]+ ;        <em class="comment">// match - or ] one or more times</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">‘ <span class="standin">x</span> ’..‘ <span class="standin">y</span> ’</p><p class="last-para-in-cell">’<span class="standin">x</span>’..’<span class="standin">y</span>’</p>
</td>
<td style="">
<p class="last-para-in-cell"><span class="standin">匹配范围x</span>
      和<span class="standin">y</span>
      之间的任意单个字符（含）。以下是示例：<code class="cf ic">’a’..’z’</code>.<code class="cf ic">’a’..’z’</code>与 相同<code class="cf ic">[a-z]</code>。
    </p><p class="last-para-in-cell">
      Match any single character between range <span class="standin">x</span>
      and <span class="standin">y</span>, inclusively. Here’s an example: <code class="cf ic">’a’..’z’</code>. <code class="cf ic">’a’..’z’</code> is identical to <code class="cf ic">[a-z]</code>.
    </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<span class="standin">电视</span>
</p><p class="last-para-in-cell">
<span class="standin">T</span>
</p>
</td>
<td style="">
<p>
调用词法分析器规则<span class="standin">T</span>；通常允许递归，但不允许左递归。T<span class="standin">可以</span>是常规标记或<code class="cf keyword">fragment</code>规则。
    </p><p>
Invoke lexer rule <span class="standin">T</span>; recursion is allowed in general but not left recursion. <span class="standin">T</span> can be a regular token or <code class="cf keyword">fragment</code> rule.
    </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​ID          :   LETTER (LETTER|<em class="string">'0'</em>..<em class="string">'9'</em>)* ;​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​<strong class="prompt">fragment</strong>​</code></div>
</td>
</tr>
<tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​LETTER      :   [a-zA-Z\u0080-\u00FF_] ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">
<code class="cf ic">.</code>
</p><p class="last-para-in-cell">
<code class="cf ic">.</code>
</p>
</td>
<td style="">
<p>
      点是单字符通配符，可匹配任意单个字符。以下是示例：</p><p>
      The dot is a single-character wildcard that matches any single character. Here’s an example:</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​ESC : <em class="string">'\\'</em> . ; <em class="comment">// match any escaped \x character</em>​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">{“<span class="elide emph">行动</span>”}</p><p class="last-para-in-cell">{«<span class="elide emph">action</span>»}</p>
</td>
<td style="">
<p>
	  词法分析器操作必须出现在最外层替代方案的末尾。如果词法分析器规则有多个替代方案，请将它们括在括号中，然后将操作放在后面。
	</p><p>
	  Lexer actions must appear at the end of the outermost alternative. If a lexer rule has more than one alternative, enclose them in parentheses and put the action afterward.
	</p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​END : (<em class="string">'endif'</em>|<em class="string">'end'</em>) {System.out.println(<em class="string">"found an end"</em>);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p class="last-para-in-cell">
       该操作符合目标语言的语法。ANTLR 将操作的内容逐字复制到生成的代码中；不会翻译诸如<code class="cf ic">$x.y</code>解析器操作中的表达式。
      </p><p class="last-para-in-cell">
       The action conforms to the syntax of the target language.
ANTLR copies the action’s contents into the generated code verbatim; there is no translation of expressions such as <code class="cf ic">$x.y</code> like there is in parser actions.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">{«<span class="elide emph">頁</span>»}？</p><p class="last-para-in-cell">{«<span class="elide emph">p</span>»}?</p>
</td>
<td style="">
<p class="last-para-in-cell">
         评估语义谓词“ <span class="elide emph">p</span> ”。如果“ <span class="elide emph">p</span> ”在运行时评估为 false，则周围的规则将变为“不可见”（不可行）。表达式“ <span class="elide emph">p</span> ”符合目标语言语法。虽然语义谓词可以出现在词法分析器规则中的任何位置，但将它们放在规则末尾是最有效的。需要注意的是，语义谓词必须位于词法分析器操作之前。请参阅词法<a href="#f_0097.html.sec.preds-in-lexer"><em>分析器规则中的</em></a><a href="#f_0097.html.sec.preds-in-lexer">谓词<em></em></a>。
      </p><p class="last-para-in-cell">
         Evaluate semantic
        predicate «<span class="elide emph">p</span>».  If
        «<span class="elide emph">p</span>» evaluates to false at runtime, the surrounding rule becomes    
       “invisible” (nonviable).  Expression «<span class="elide emph">p</span>» conforms to the target
        language syntax.  While semantic predicates can appear anywhere within a lexer rule, it is most efficient to have them at the end of the rule.  The one caveat is that semantic predicates must precede lexer actions. See <a href="#f_0097.html.sec.preds-in-lexer">​<em>Predicates in Lexer Rules</em>​</a>.
      </p>
</td>
</tr>
<tr class="tr ">
<td style="">
<p class="last-para-in-cell">~<span class="standin">十</span>
</p><p class="last-para-in-cell">~<span class="standin">x</span>
</p>
</td>
<td style="">
<p><span class="standin">匹配任何不在x</span>
      描述的集合中的单个字符。集合<span class="standin">x</span>可以是单个字符文字、范围或子规则集（如<code class="cf ic">~(’x’|’y’|’z’)</code>或 ） 。以下是用于匹配除使用 的字符之外的任何字符<code class="cf ic">~[xyz]</code>的规则：
    <code class="cf ic">~</code><code class="cf ic">~[\r\n]*</code></p><p>
      Match any single character not in the set described by <span class="standin">x</span>. Set <span class="standin">x</span> can be a single character literal, a range, or a subrule set like <code class="cf ic">~(’x’|’y’|’z’)</code> or <code class="cf ic">~[xyz]</code>. Here is a rule that uses <code class="cf ic">~</code> to match any character other than characters using <code class="cf ic">~[\r\n]*</code>:
    </p>
<table class="processedcode" style="border:0px none">
<tbody><tr style="border:0px none">
<td class="codeprefix" valign="top" style="border:0px none">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top" style="border:0px none">
<div style="font-size:-2;text-indent:-1em;padding-left:1em;word-wrap:break-word">​​<code style="white-space:pre-wrap">​COMMENT :   <em class="string">'#'</em> ~[\r\n]* <em class="string">'\r'</em>? <em class="string">'\n'</em> -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody>
</table>
<p id="f_0095.html.N1A627">
与解析器规则一样，词法分析器规则允许在括号和 EBNF 运算符中使用子规则：
 <code class="cf ic">?</code>、<code class="cf ic">*</code>、<code class="cf ic">+</code>。该<code class="cf keyword">COMMENT</code>规则说明了
<code class="cf ic">*</code>和<code class="cf ic">?</code>运算符。 的一个常见用途<code class="cf ic">+</code>是<code class="cf ic">[0-9]+</code>匹配整数。词法分析器子规则还可以在这些 EBNF 运算符上使用非贪婪<code class="cf ic">?</code>后缀。
</p><p>
Just as with parser rules, lexer rules allow subrules in parentheses and EBNF operators:
<code class="cf ic">?</code>, <code class="cf ic">*</code>, <code class="cf ic">+</code>. The <code class="cf keyword">COMMENT</code> rule illustrates the
<code class="cf ic">*</code> and <code class="cf ic">?</code> operators. A common use of <code class="cf ic">+</code> is <code class="cf ic">[0-9]+</code> to match
integers.  Lexer subrules can also use the nongreedy <code class="cf ic">?</code> suffix on those EBNF operators.
</p>
<h3>递归词法分析器规则</h3><h3>Recursive Lexer Rules</h3>
<p id="f_0095.html.N1A659">
与大多数词汇语法工具不同，ANTLR 词法分析器规则可以递归。当您想要匹配嵌套标记（如嵌套动作块）时，这非常有用：<code class="cf ic">{...{...}...}</code>。
</p><p>
ANTLR lexer rules can be recursive, unlike most lexical grammar tools. This comes in handy when you want to match nested tokens like nested action blocks: <code class="cf ic">{...{...}...}</code>.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Recur.g4">参考/Recur.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> Recur;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ACTION : <em class="string">'{'</em> ( ACTION | ~[{}] )* <em class="string">'}'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS     : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<h3>冗余字符串字面量</h3><h3>Redundant String Literals</h3>
<p id="f_0095.html.N1A697">
请注意，不要在多个词法分析器规则的右侧指定相同的字符串文字。这样的文字具有歧义，可能匹配多个标记类型。ANTLR 使解析器无法使用此文字。跨模式的规则也是如此。例如，以下词法分析器语法定义了两个具有相同字符序列的标记：
</p><p>
Be careful that you don’t specify the same string literal on the right  side of multiple
lexer rules. Such literals are ambiguous and could match multiple token types. ANTLR makes
this literal unavailable to the parser. The same is true for rules across modes. For
example, the following lexer grammar defines two tokens with the same character sequence:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/L.g4">参考/L.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> L;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​AND : <em class="string">'&amp;'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​mode STR;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​MASK : <em class="string">'&amp;'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A6BE">
解析器语法不能引用文字<code class="cf ic">’&amp;’</code>，但可以引用标记的名称。
</p><p>
A parser grammar cannot reference literal <code class="cf ic">’&amp;’</code>, but it can reference the name of the tokens.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/P.g4">参考/P.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">parser</strong> <strong class="prompt">grammar</strong> P;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> { tokenVocab=L; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​a : <em class="string">'&amp;'</em> <em class="comment">// results in a tool error: no such token</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    AND <em class="comment">// no problem</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    MASK <em class="comment">// no problem</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​  ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A6F0">
以下是构建和测试序列：
</p><p>
Here’s a build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 L.g4   # yields L.tokens file needed by tokenVocab option in P.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 P.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​error(126): P.g4:3:4: cannot create implicit token for string literal '&amp;'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​                      in non-combined grammar​</code></div>
</td>
</tr>
</tbody></table>
<h3>词法分析器规则操作</h3><h3>Lexer Rule Actions</h3>
<p id="f_0095.html.N1A710">
ANTLR 词法分析器<code class="cf class">Token</code>在匹配词法规则后创建一个对象。每个对标记的请求都以 开始<code class="cf methodname">Lexer.nextToken</code>，
<code class="cf methodname">emit</code>一旦识别出标记，它就会调用 。<code class="cf methodname">emit</code>从词法分析器的当前状态收集信息以构建标记。它访问字段
<code class="cf variable">_type</code>、<code class="cf variable">_text</code>、<code class="cf variable">_channel</code>、
 <code class="cf variable">_tokenStartCharIndex</code>、<code class="cf variable">_tokenStartLine</code>和<code class="cf variable">_tokenStartCharPositionInLine</code>。您可以使用各种设置器方法（例如 ）设置这些字段的状态<code class="cf methodname">setType</code>。例如，如果 为 false，则以下规则将变为<code class="cf keyword">enum</code>标识符<code class="cf variable">enumIsKeyword</code>：
</p><p>
An ANTLR lexer creates a <code class="cf class">Token</code> object after matching a lexical rule. Each
request for a token starts in <code class="cf methodname">Lexer.nextToken</code>, which calls
<code class="cf methodname">emit</code> once it has identified a token. <code class="cf methodname">emit</code> collects
information from the current state of the lexer to build the token. It accesses fields
<code class="cf variable">_type</code>, <code class="cf variable">_text</code>, <code class="cf variable">_channel</code>,
<code class="cf variable">_tokenStartCharIndex</code>, <code class="cf variable">_tokenStartLine</code>,
and <code class="cf variable">_tokenStartCharPositionInLine</code>. You can set the state of these with the various setter methods such as <code class="cf methodname">setType</code>. For example, the following rule turns <code class="cf keyword">enum</code> into an identifier if <code class="cf variable">enumIsKeyword</code> is false:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENUM : <em class="string">'enum'</em> {if (!enumIsKeyword) setType(Identifier);} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A749">
ANTLR 在词法分析器操作中不执行特殊的<code class="cf ic">$</code>
<span class="standin">x</span>属性翻译（与 v3 不同）。
</p><p>
ANTLR does no special <code class="cf ic">$</code>
<span class="standin">x</span> attribute translations in lexer
actions (unlike v3).
</p>
<p id="f_0095.html.N1A751">
一个词汇规则最多只能有一个动作，不管该规则中有多少个替代方案。
</p><p>
There can be at most a single action for a lexical rule, regardless of how many alternatives there are in that rule.
</p>
<h3>词法分析器命令</h3><h3>Lexer Commands</h3>
<p id="f_0095.html.N1A758">
为了避免将语法与特定的目标语言绑定在一起，ANTLR 支持<span class="firstuseinline">词法分析器命令</span>。与任意嵌入操作不同，这些命令遵循特定语法，并且仅限于一些常用命令。词法分析器命令出现在词法分析器规则定义最外层替代项的末尾。与任意操作一样，每个标记规则只能有一个词法分析器命令。词法分析器命令由运算符和<code class="cf ic">-&gt;</code>后跟一个或多个命令名（可选地接受参数）组成。
</p><p>
To avoid tying a grammar to a particular target language, ANTLR supports <span class="firstuseinline">lexer
commands</span>. Unlike arbitrary embedded actions, these commands follow specific
syntax and are limited to a few common commands. Lexer commands appear at the end of the
outermost alternative of a lexer rule definition. Like arbitrary actions, there can  be only
one per token rule. A lexer command consists of the <code class="cf ic">-&gt;</code> operator followed by one or
more command names that can optionally take parameters.
</p>
<p id="f_0095.html.N1A76C">
<code class="cf ic">TokenName :</code>&nbsp;«<span class="elide emph">替代</span>»&nbsp;<code class="cf ic">-&gt;</code>&nbsp;<span class="standin">命令名称</span>
</p><p>
<code class="cf ic">TokenName :</code>&nbsp;«<span class="elide emph">alternative</span>»&nbsp;<code class="cf ic">-&gt;</code>&nbsp;<span class="standin">command-name</span>
</p>
<p id="f_0095.html.N1A779">
<code class="cf ic">TokenName :</code>&nbsp;«<span class="elide emph">替代</span>»&nbsp;<code class="cf ic">-&gt;</code>&nbsp;<span class="standin">命令名称</span>
<code class="cf ic">(</code>«<span class="elide emph">标识符或整数</span>»<code class="cf ic">)</code>
</p><p>
<code class="cf ic">TokenName :</code>&nbsp;«<span class="elide emph">alternative</span>»&nbsp;<code class="cf ic">-&gt;</code>&nbsp;<span class="standin">command-name</span>
<code class="cf ic">(</code>«<span class="elide emph">identifier or integer</span>»<code class="cf ic">)</code>
</p>
<p id="f_0095.html.N1A78C">
备选方案可以包含多个命令，每个命令之间用逗号分隔。以下是有效的命令名称：
</p><p>
An alternative can have more than one command separated by commas. Here are the valid
command names:
</p>
<dl>
<dt>
<code class="cf keyword">skip</code>
</dt><dt>
<code class="cf keyword">skip</code>
</dt>
<dd>
<p id="f_0095.html.N1A796">
 不向此规则的解析器返回标记。这通常用于空格：
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​WS : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
 Do not return a token to the parser for this rule. This is typically used for whitespace:
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​WS : [ \r\t\n]+ -&gt; skip ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">more</code>
</dt><dt>
<code class="cf keyword">more</code>
</dt>
<dd>
<p id="f_0095.html.N1A7B0">
匹配此规则但继续查找标记。下一个匹配的标记规则将包含此规则匹配的文本。这通常与模式一起使用。以下是使用模式匹配字符串文字的示例：
  </p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Strings.g4">参考/Strings.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> Strings;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​LQUOTE : <em class="string">'"'</em> -&gt; more, mode(STR) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​WS     : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​mode STR;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> -&gt; mode(DEFAULT_MODE) ; <em class="comment">// token we want parser to see</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​TEXT   : .   -&gt; more ;               <em class="comment">// collect more text for string</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A7E7">
以下是一个示例运行：
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Strings.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Strings.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Strings tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">"hi"</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">"mom"</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@0,0:3='"hi"',&lt;2&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@1,5:9='"mom"',&lt;2&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@2,11:10='&lt;EOF&gt;',&lt;-1&gt;,3:0]​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
Match this rule but continue looking for a token.  The token rule that matches next will include the text matched for this rule. This is typically used with modes. Here’s an example that matches string literals with a mode:
  </p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Strings.g4">reference/Strings.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> Strings;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​LQUOTE : <em class="string">'"'</em> -&gt; more, mode(STR) ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​WS     : [ \r\t\n]+ -&gt; skip ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​mode STR;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​STRING : <em class="string">'"'</em> -&gt; mode(DEFAULT_MODE) ; <em class="comment">// token we want parser to see</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​TEXT   : .   -&gt; more ;               <em class="comment">// collect more text for string</em>​</code>​</div>
</td>
</tr>
</tbody></table>
<p>
Here’s a sample run:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ antlr4 Strings.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ javac Strings.java</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ grun Strings tokens -tokens</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">"hi"</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">"mom"</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@0,0:3='"hi"',&lt;2&gt;,1:0]​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@1,5:9='"mom"',&lt;2&gt;,2:0]​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@2,11:10='&lt;EOF&gt;',&lt;-1&gt;,3:0]​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">type</code>（<span class="standin">吨</span>）</dt><dt>
<code class="cf keyword">type</code>(<span class="standin">T</span>)</dt>
<dd>
<p id="f_0095.html.N1A824">
 设置当前 token 的 token 类型。下面是一个强制两个不同 token 使用相同 token 类型的示例：
  </p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/SetType.g4">参考/SetType.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> SetType;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">tokens</strong> { STRING }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​DOUBLE : <em class="string">'"'</em> .*? <em class="string">'"'</em>   -&gt; type(STRING) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​SINGLE : <em class="string">'\''</em> .*? <em class="string">'\''</em> -&gt; type(STRING) ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​WS     : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0095.html.N1A85C">
以下是示例运行。您可以看到两个令牌都作为令牌类型 1 返回。
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 SetType.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac SetType.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun SetType tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">"double"</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">'single'</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@0,0:7='"double"',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@1,9:16=''single'',&lt;1&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​[@2,18:17='&lt;EOF&gt;',&lt;-1&gt;,3:0]​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
 Set the token type for the current token.  Here’s an example that forces two different tokens to use the same token type:
  </p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/SetType.g4">reference/SetType.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">lexer</strong> <strong class="prompt">grammar</strong> SetType;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">tokens</strong> { STRING }​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​DOUBLE : <em class="string">'"'</em> .*? <em class="string">'"'</em>   -&gt; type(STRING) ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​SINGLE : <em class="string">'\''</em> .*? <em class="string">'\''</em> -&gt; type(STRING) ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​WS     : [ \r\t\n]+ -&gt; skip ;​</code>​</div>
</td>
</tr>
</tbody></table>
<p>
Here’s a sample run. You can see that both tokens come back as token type 1.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ antlr4 SetType.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ javac SetType.java</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">$ grun SetType tokens -tokens</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">"double"</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">'single'</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@0,0:7='"double"',&lt;1&gt;,1:0]​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@1,9:16=''single'',&lt;1&gt;,2:0]​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​[@2,18:17='&lt;EOF&gt;',&lt;-1&gt;,3:0]​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">channel</code>（<span class="standin">三</span>）</dt><dt>
<code class="cf keyword">channel</code>(<span class="standin">C</span>)</dt>
<dd>
<p id="f_0095.html.N1A899">
	 设置当前 token 的通道。默认值为
     <code class="cf variable">Token.DEFAULT_CHANNEL</code>。您可以定义常量，然后使用它或上面的整数文字<code class="cf variable">Token.DEFAULT_CHANNEL</code>作为值 (0)。有一个通用隐藏通道，其<code class="cf variable">Token.HIDDEN_CHANNEL</code>值为 1。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​<strong class="prompt">@lexer</strong>::members { <strong class="prompt">public</strong> static final int WHITESPACE = 1; }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​WS  :   [ \t\n\r]+ -&gt; channel(WHITESPACE) ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
	 Set the channel for the current token. The default is
     <code class="cf variable">Token.DEFAULT_CHANNEL</code>. You can define constants and then use it or an
     integer literal above <code class="cf variable">Token.DEFAULT_CHANNEL</code> in value (0). There’s
     a generic hidden channel called <code class="cf variable">Token.HIDDEN_CHANNEL</code> with value 1.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​<strong class="prompt">@lexer</strong>::members { <strong class="prompt">public</strong> static final int WHITESPACE = 1; }​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​...​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​WS  :   [ \t\n\r]+ -&gt; channel(WHITESPACE) ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">mode</code>（<span class="standin">男</span>）</dt><dt>
<code class="cf keyword">mode</code>(<span class="standin">M</span>)</dt>
<dd>
<p id="f_0095.html.N1A8CE">
 匹配此标记后，将词法分析器切换到模式<span class="standin">M</span>。下次词法分析器尝试匹配标记时，它将仅查看模式<span class="standin">M</span>中的规则。<span class="standin">M</span>可以是来自同一语法的模式名称或整数文字。请参阅<code class="cf class">Strings</code>前面的语法。
  </p>
</dd><dd>
<p>
 After matching this token, switch the lexer to mode <span class="standin">M</span>. The next time the lexer tries to match a token, it will look only at rules in mode <span class="standin">M</span>. <span class="standin">M</span> can be a mode name from the same grammar or an integer literal. See grammar <code class="cf class">Strings</code> earlier.
  </p>
</dd>
<dt>
<code class="cf keyword">pushMode</code>（<span class="standin">男</span>）</dt><dt>
<code class="cf keyword">pushMode</code>(<span class="standin">M</span>)</dt>
<dd>
<p id="f_0095.html.N1A8EC">
这与 相同，<code class="cf keyword">mode</code>只是它将当前模式推送到堆栈并设置模式<span class="standin">M</span>。它应与 一起使用<code class="cf keyword">popMode</code>。
  </p>
</dd><dd>
<p>
This is the same as <code class="cf keyword">mode</code> except that it pushes the current mode onto a stack as well as setting the mode <span class="standin">M</span>. It should be used in conjunction with <code class="cf keyword">popMode</code>.
  </p>
</dd>
<dt>
<code class="cf keyword">popMode</code>
</dt><dt>
<code class="cf keyword">popMode</code>
</dt>
<dd>
<p id="f_0095.html.N1A903">
	 从模式堆栈顶部弹出一个模式，并将词法分析器的当前模式设置为该模式。这与一起使用<code class="cf keyword">pushMode</code>。
	 </p>
</dd><dd>
<p>
	 Pop a mode from the top of the mode stack and set the current mode of the lexer to that. This is used in conjunction with <code class="cf keyword">pushMode</code>.
	 </p>
</dd>
</dl>

</div></div>
<div id="f_0096.html"><div>

<h2 id="f_0096.html.sec.nongreedy">15.6 通配符和非贪婪子规则</h2><h2>15.6 Wildcard Operator and Nongreedy Subrules</h2>
<p id="f_0096.html.N1A919">
EBNF 子规则（例如<code class="cf ic">(...)?</code>、<code class="cf ic">(...)*</code>和 ）<code class="cf ic">(...)+</code>是
<span class="firstuseinline">贪婪的</span>— 它们会消耗尽可能多的输入，但有时这并不是所需要的。诸如 之类的构造<code class="cf ic">.*</code>会一直消耗到词法分析器中输入的末尾，有时也会在解析器中消耗。我们希望该循环是非<span class="firstuseinline">贪婪的</span>，因此我们需要使用不同的语法：<code class="cf ic">.*?</code>借用正则表达式表示法。我们可以通过添加另一个后缀使任何具有<code class="cf ic">?</code>、<code class="cf ic">*</code>或后缀的子规则变为非贪婪的。这种非贪婪子规则在解析器和词法分析器中都是允许的，但它们在词法分析器中的使用频率要高得多。
<code class="cf ic">+</code><code class="cf ic">?</code></p><p>
EBNF subrules like <code class="cf ic">(...)?</code>, <code class="cf ic">(...)*</code>, and <code class="cf ic">(...)+</code> are
<span class="firstuseinline">greedy</span>—they consume as much input as possible, but sometimes that’s
not what’s needed. Constructs like <code class="cf ic">.*</code> consume until the end of the input in the
lexer and sometimes in the parser. We want that loop to be <span class="firstuseinline">nongreedy</span>, so
we need to use different syntax: <code class="cf ic">.*?</code> borrowed from regular expression notation. We
can make any subrule that has a <code class="cf ic">?</code>, <code class="cf ic">*</code>, or <code class="cf ic">+</code> suffix nongreedy by
adding another <code class="cf ic">?</code> suffix. Such nongreedy subrules are allowed in both the parser and
the lexer, but they are used much more frequently in the lexer.
</p>
<h3>非贪婪词法分析器子规则</h3><h3>Nongreedy Lexer Subrules</h3>
<p id="f_0096.html.N1A955">
这是非常常见的 C 风格注释词法分析器规则，它会使用任何字符，直到看到尾随的<code class="cf ic">’*/’</code>：
</p><p>
Here’s the very common C-style comment lexer rule that consumes any characters until it sees
the trailing <code class="cf ic">’*/’</code>:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​COMMENT : <em class="string">'/*'</em> .*? <em class="string">'*/'</em> -&gt; skip ; <em class="comment">// .*? matches anything until the first */</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1A96F">
这是另一个匹配允许<code class="cf ic">\"</code>作为转义引号字符的字符串的示例：
</p><p>
Here’s another example that matches strings that allow <code class="cf ic">\"</code> as an escaped quote
character:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Nongreedy.g4">参考/Nongreedy.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> Nongreedy;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​s : STRING+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> ( <em class="string">'\\"'</em> | . )*? <em class="string">'"'</em> ; <em class="comment">// match "foo", "\"", "x\"\"y", ...</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS     : [ \r\t\n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Nongreedy.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Nongreedy*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Nongreedy s -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">"quote:\""</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:9='"quote:\""',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,11:10='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1A9C0">
非贪婪子规则应谨慎使用，因为它们会使识别问题复杂化，有时甚至会使词法分析器难以理解如何匹配文本。以下是词法分析器选择标记规则的方式：
</p><p>
Nongreedy subrules should be used sparingly because they complicate the recognition problem
and sometimes make it tricky to decipher how the lexer will match text. Here is how the
lexer chooses token rules:
</p>
<ul>
<li>
<p id="f_0096.html.N1A9C6">
	主要目标是匹配能够识别最多输入字符的词法分析器规则。
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT   : [0-9]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DOT   : <em class="string">'.'</em> ;         <em class="comment">// match period</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​FLOAT : [0-9]+ <em class="string">'.'</em> ;  <em class="comment">// match FLOAT upon '34.' not INT then DOT</em>​</code></div>
</td>
</tr>
</tbody></table>
</li><li>
<p>
	The primary goal is to match the lexer rule that recognizes the
most input characters.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​INT   : [0-9]+ ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​DOT   : <em class="string">'.'</em> ;         <em class="comment">// match period</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​FLOAT : [0-9]+ <em class="string">'.'</em> ;  <em class="comment">// match FLOAT upon '34.' not INT then DOT</em>​</code>​</div>
</td>
</tr>
</tbody></table>
</li>
<li>
<p id="f_0096.html.N1A9E6">
    如果多个词法分析器规则与相同的输入序列匹配，则优先考虑语法文件中首先出现的规则。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​DOC : <em class="string">'/**'</em> .*? <em class="string">'*/'</em> ; <em class="comment">// both rules match /** foo */,  resolve to DOC</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​CMT : <em class="string">'/*'</em> .*? <em class="string">'*/'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</li><li>
<p>
    If more than one lexer rule matches the same input sequence, the priority goes to the
    rule occurring first in the grammar file.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​DOC : <em class="string">'/**'</em> .*? <em class="string">'*/'</em> ; <em class="comment">// both rules match /** foo */,  resolve to DOC</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​CMT : <em class="string">'/*'</em> .*? <em class="string">'*/'</em> ;​</code>​</div>
</td>
</tr>
</tbody></table>
</li>
<li>
<p id="f_0096.html.N1AA07">
    非贪婪子规则匹配最少的字符，但仍然允许周围的词汇规则匹配。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match anything except \n inside of double angle brackets */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'&lt;&lt;'</em> ~<em class="string">'\n'</em>*? <em class="string">'&gt;&gt;'</em> ; <em class="comment">// Input '&lt;&lt;foo&gt;&gt;&gt;&gt;' matches STRING then END</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​END    : <em class="string">'&gt;&gt;'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
</li><li>
<p>
    Nongreedy subrules match the fewest  characters that still allow the surrounding lexical rule to match.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​<em class="comment">/** Match anything except \n inside of double angle brackets */</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​STRING : <em class="string">'&lt;&lt;'</em> ~<em class="string">'\n'</em>*? <em class="string">'&gt;&gt;'</em> ; <em class="comment">// Input '&lt;&lt;foo&gt;&gt;&gt;&gt;' matches STRING then END</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;">
​<code style="white-space: pre-wrap;">​END    : <em class="string">'&gt;&gt;'</em> ;​</code>​</div>
</td>
</tr>
</tbody></table>
</li>
<li>
<p id="f_0096.html.N1AA2C"><span class="emph">在词汇规则中</span>
   穿过非贪婪子规则之后，从那时起的所有决策都是“先匹配获胜”。 
  </p>
<p id="f_0096.html.N1AA32">
例如，<code class="cf ic">’ab’</code>规则右侧的替代项<code class="cf ic">.*? (’a’|’ab’)</code>是死代码，永远无法匹配。如果输入是<code class="cf ic">ab</code>，则第一个替代项
<code class="cf ic">’a’</code>匹配第一个字符，因此成功。<code class="cf ic">(’a’|’ab’)</code>规则右侧的本身可以正确匹配输入的第二个替代项
<code class="cf ic">ab</code>。这个怪癖源于非贪婪的设计决策，这里无法详述。
</p>
</li><li>
<p>
   After crossing through a nongreedy subrule <span class="emph">within</span> a lexical rule, all
   decision making from then on is “first match wins.” 
  </p>
<p>
For example, alternative <code class="cf ic">’ab’</code> in the rule right-side <code class="cf ic">.*? (’a’|’ab’)</code> is
dead code and can never be matched. If the input is <code class="cf ic">ab</code>, the first alternative,
<code class="cf ic">’a’</code>, matches the first character and therefore succeeds. <code class="cf ic">(’a’|’ab’)</code> by
itself on the right side of a rule properly matches the second alternative for input
<code class="cf ic">ab</code>. This quirk arises from a nongreedy design decision that’s too complicated to go
into here.
</p>
</li>
</ul>
<p id="f_0096.html.N1AA47">
为了说明在词法分析器规则中使用循环的不同方法，请考虑以下语法，它具有三个不同的动作类标记（使用不同的分隔符，以便它们都适合一个示例语法）：
</p><p>
To illustrate the different ways to use loops within lexer rules, consider the following
grammar, which has three different action-like tokens (using different delimiters so that
they all fit within one example grammar):
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Actions.g4">参考/Actions.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ACTION1 : <em class="string">'{'</em> ( STRING | . )*? <em class="string">'}'</em> ;    <em class="comment">// Allows {"foo}</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ACTION2 : <em class="string">'['</em> ( STRING | ~<em class="string">'"'</em> )*? <em class="string">']'</em> ; <em class="comment">// Doesn't allow ["foo]; nongreedy *?</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ACTION3 : <em class="string">'&lt;'</em> ( STRING | ~[<em class="string">"&gt;] )* '&gt;' ; // Doesn't allow &lt;"</em>foo&gt;; greedy *​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​STRING : <em class="string">'"'</em> ( <em class="string">'\\"'</em> | . )*? <em class="string">'"'</em> ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1AA82">
规则<code class="cf keyword">ACTION1</code>允许未终止的字符串，例如<code class="cf ic">{"foo}</code>，因为输入<code class="cf ic">"foo</code>与循环的通配符部分匹配。它不必进入规则<code class="cf keyword">STRING</code>来匹配引号。为了解决这个问题，规则<code class="cf keyword">ACTION2</code>使用<code class="cf ic">~’"’</code>匹配除引号之外的任何字符。表达式<code class="cf ic">~’"’</code>仍然带有<code class="cf ic">’]’</code>结束规则的歧义，但子规则是非贪婪的事实意味着词法分析器将在右方括号上退出循环。要避免非贪婪子规则，请明确替代项。表达式<code class="cf ic">~["&gt;]</code>匹配除引号和右尖括号之外的任何内容。这是一个示例运行：
</p><p>
Rule <code class="cf keyword">ACTION1</code> allows unterminated strings, such as <code class="cf ic">{"foo}</code>, because input <code class="cf ic">"foo</code> matches to the wildcard part of the loop. It doesn’t have to go into rule <code class="cf keyword">STRING</code> to match a quote. To fix that, rule <code class="cf keyword">ACTION2</code> uses <code class="cf ic">~’"’</code> to match any character but the quote. Expression <code class="cf ic">~’"’</code> is still ambiguous with the <code class="cf ic">’]’</code> that ends the rule, but the fact that the subrule is nongreedy means that the lexer will exit the loop upon a right square bracket.  To avoid a nongreedy subrule, make the alternatives explicit. Expression <code class="cf ic">~["&gt;]</code> matches anything but the quote and right angle bracket. Here’s a sample run:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Actions.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Actions*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Actions tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">{"foo}</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,0:5='{"foo}',&lt;1&gt;,1:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@1,7:6='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Actions tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">["foo]</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:0 token recognition error at: '["foo]\n'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,7:6='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Actions tokens -tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">&lt;"foo&gt;</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​line 1:0 token recognition error at: '&lt;"foo&gt;\n'​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​[@0,7:6='&lt;EOF&gt;',&lt;-1&gt;,2:0]​</code></div>
</td>
</tr>
</tbody></table>
<h3>非贪婪解析器子规则</h3><h3>Nongreedy Parser Subrules</h3>
<p id="f_0096.html.N1AAF8">
非贪婪子规则和通配符在解析器中也很有用，可以进行“模糊解析”，其目标是从输入文件中提取信息，而无需指定完整的语法。与非贪婪词法分析器决策相比，解析器始终做出全局正确的决策。解析器永远不会做出最终导致有效输入在解析过程中失败的决策。这是中心思想：<span class="emph">非贪婪解析器子规则匹配最短的标记序列，以保留对有效输入句子的成功解析。</span>
</p><p>
Nongreedy subrules and wildcards are also useful within parsers to do “fuzzy parsing” where
the goal is to extract information from an input file without having to specify the full
grammar. In contrast to nongreedy lexer decision making, parsers always make globally
correct decisions. A parser never makes a decision that will ultimately cause valid input to
fail later during the parse. Here is the central idea: <span class="emph">nongreedy parser subrules
match the shortest sequence of tokens that preserves a successful parse for a valid input
sentence.</span>
</p>
<p id="f_0096.html.N1AAFD">
例如，以下是演示如何从任意 Java 文件中提取整数常量的关键规则：
</p><p>
For example, here are the key rules that demonstrate how to pull integer constants out of an
arbitrary Java file:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/FuzzyJava.g4">参考/FuzzyJava.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> FuzzyJava;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match anything in between constant rule matches */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​file : .*? (constant .*?)+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Faster alternate version (Gets an ANTLR tool warning about</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> *  a subrule like .* in parser that you can ignore.)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment"> */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​altfile : (constant | .)* ; <em class="comment">// match a constant or any token, 0-or-more times</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<em class="comment">/** Match things like "public static final SIZE" followed by anything */</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​constant​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     : <em class="string">'public'</em> <em class="string">'static'</em> <em class="string">'final'</em> <em class="string">'int'</em> Identifier​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​       {System.out.println(<em class="string">"constant: "</em>+$Identifier.text);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​Identifier : [a-zA-Z_$] [a-zA-Z_$0-9]* ; <em class="comment">// simplified</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1AB4F">
语法包含一组大大简化的词法分析器规则，这些规则来自真正的 Java 词法分析器；整个文件大约 60 行。识别器仍然需要处理字符串和字符常量以及注释，以便它不会不同步，例如尝试匹配字符串内的常量。唯一不寻常的词法分析器规则执行“匹配其他词法分析器规则未匹配的任何字符”功能。
</p><p>
The grammar contains a greatly simplified set of lexer rules from a real Java lexer; the
whole file about 60 lines. The recognizer still needs to handle string and character
constants as well as comments so it doesn’t get out of sync, trying to match a constant
inside of the string, for example. The only unusual lexer rule performs the “match any character
not matched by another lexer rule” functionality.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/FuzzyJava.g4">参考/FuzzyJava.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​OTHER : . -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1AB5F">
这个包罗万象的词法分析器规则和<code class="cf ic">.*?</code>解析器中的子规则是模糊解析的关键因素。
</p><p>
This catchall lexer rule and the <code class="cf ic">.*?</code> subrule  in the parser are the critical ingredients for fuzzy parsing.
</p>
<p id="f_0096.html.N1AB65">
下面是我们可以在模糊解析器中运行的示例文件：
</p><p>
Here’s a sample file that we can run into the fuzzy parser:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/C.java">参考/C.java</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">import</strong> java.util.*;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">public</strong> <strong class="prompt">class</strong> C {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">int</strong> A = 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">int</strong> B = 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">void</strong> foo() { }​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    <strong class="prompt">public</strong> <strong class="prompt">static</strong> <strong class="prompt">final</strong> <strong class="prompt">int</strong> C = 1;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​}​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1ABB8">
以下是构建和测试顺序：
</p><p>
And here’s the build and test sequence:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 FuzzyJava.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">javac FuzzyJava*.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grun FuzzyJava file C.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​constant: A​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​constant: B​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​constant: C​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0096.html.N1ABDF">
注意，它完全忽略了声明之外的所有内容<code class="cf ic">public static final int</code>。这一切只发生在两个解析器规则中。
</p><p>
Notice that it totally ignores everything except for the <code class="cf ic">public static final int</code> declarations. This all happens with only two parser rules.
</p>

</div></div>
<div id="f_0097.html"><div>

<h2 id="f_0097.html.sec.pred-fine-print">15.7 语义谓词</h2><h2>15.7 Semantic Predicates</h2>
<p id="f_0097.html.N1ABF6">
语义谓词<code class="cf ic">{...}?</code>是用目标语言编写的布尔表达式，表示沿着谓词“保护”的路径继续解析的有效性。谓词可以像动作一样出现在解析器规则中的任何位置，但只有出现在备选项左侧的谓词才能影响预测（在备选项之间进行选择）。我们在第 11 章“使用<a href="#f_0067.html.chp.predicates"><em>语义谓词</em></a><a href="#f_0067.html.chp.predicates">改变解析中详细讨论了谓词。<em></em></a>本节提供了有关在解析器和词法分析器规则中使用语义谓词的所有细节。让我们首先深入研究解析器如何将谓词纳入解析决策。
</p><p>
Semantic predicates, <code class="cf ic">{...}?</code>, are Boolean expressions written in the target language that indicate the validity of continuing the parse along the path “guarded” by the predicate. Predicates can appear anywhere within a parser rule just like actions can, but only those appearing on the left edge of alternatives can affect prediction (choosing between alternatives). We discussed predicates in detail in Chapter 11, <a href="#f_0067.html.chp.predicates">​<em>Altering the Parse with Semantic Predicates</em>​</a>. This section provides all of the fine print  regarding the use of semantic predicates in parser and lexer rules. Let’s start by digging deeper into how the parser incorporates predicates into parsing decisions.
</p>
<h3>做出预测解析决策</h3><h3>Making Predicated Parsing Decisions</h3>
<p id="f_0097.html.N1AC07">
ANTLR 的一般决策策略是找到所有<span class="firstuseinline">可行的替代方案</span>，然后忽略当前评估为假的谓词保护的替代方案。（可行的替代方案是与当前输入相匹配的替代方案。）如果剩余多个可行的替代方案，则解析器选择决策中首先指定的替代方案。
	</p><p>
ANTLR’s general decision-making strategy is to find all <span class="firstuseinline">viable
alternatives</span> and then ignore the alternatives guarded with predicates
that currently evaluate to false. (A viable alternative is one that matches the
current input.) If more than one viable alternative remains, the parser chooses the
alternative specified first in the decision.
	</p>
<p id="f_0097.html.N1AC19">
考虑 C++ 的一个变体，其中数组引用也使用圆括号而不是方括号。如果我们只预测其中一个替代方案，我们仍然会做出模棱两可的决定<code class="cf keyword">expr</code>。
</p><p>
Consider a variant of C++ where array references also use parentheses instead of
square brackets. If we  predicate only one of the alternatives, we still have an
ambiguous decision in <code class="cf keyword">expr</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:               ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// array reference (ANTLR picks this one)</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {istype()}? ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// ctor-style typecast</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |               ID <em class="string">'('</em> expr <em class="string">')'</em> <em class="comment">// function call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AC4C">
在这种情况下，对于输入 ，所有三个替代方案都是可行的<code class="cf ic">x(i)</code>。当
<code class="cf variable">x</code>不是类型名称时，谓词的计算结果为 false，只留下第一个和第三个替代方案作为 的可能匹配<code class="cf keyword">expr</code>。ANTLR 自动选择与数组引用匹配的第一个替代方案来解决歧义。由于谓词太少而使 ANTLR 留下多个可行替代方案可能不是一个好主意。最好用至少<span class="standin">n -1 个谓词覆盖</span><span class="standin">n 个</span>可行替代方案。换句话说，不要
用太少的谓词构建规则。
	<span class="standin"></span><code class="cf keyword">expr</code></p><p>
In this case, all three alternatives are viable for input <code class="cf ic">x(i)</code>. When
<code class="cf variable">x</code> is not a type name, the predicate evaluates to false, leaving only
the first and third alternatives as possible matches for <code class="cf keyword">expr</code>. ANTLR
automatically chooses the first alternative matching the array reference to resolve the
ambiguity. Leaving ANTLR with more than one viable alternative because of too few predicates
is probably not a good idea. It’s best to cover <span class="standin">n</span> viable alternatives
with at least <span class="standin">n</span>-1 predicates. In other words, don’t build rules like
<code class="cf keyword">expr</code> with too few predicates.
	</p>
<p id="f_0097.html.N1AC61">
有时，解析器会发现与单个选择相关的<span class="emph">多个</span>可见谓词。不用担心。ANTLR 只需将谓词与适当的逻辑运算符组合起来，即可即时生成单个元谓词。
</p><p>
Sometimes, the parser finds <span class="emph">multiple</span> visible predicates associated with a
single choice. No worries. ANTLR just combines the predicates with appropriate logical
operators to conjure up a single meta-predicate on-the-fly.
</p>
<p id="f_0097.html.N1AC67">
例如，规则中的决策<code class="cf keyword">stat</code>将两个替代方案的谓词<code class="cf keyword">expr</code>与<code class="cf ic">||</code>运算符结合起来以保护第二个<code class="cf keyword">stat</code>替代方案。
</p><p>
For example, the decision in rule <code class="cf keyword">stat</code> joins the predicates from both alternatives of <code class="cf keyword">expr</code> with the <code class="cf ic">||</code> operator to guard the second <code class="cf keyword">stat</code> alternative.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   decl | expr ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl:   ID ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr:   {istype()}? ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// ctor-style typecast</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   {isfunc()}? ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// function call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AC9E">
仅当求值为真时
，解析器才会预测<code class="cf keyword">expr</code>from 。这是有道理的，因为解析器应该只在即将到来的
是类型名称或函数名称时才选择匹配表达式。在这种情况下，只测试其中一个谓词是没有意义的。请注意，当解析器到达
自身时，解析决策会分别测试谓词，每个替代方案一个。
<code class="cf keyword">stat</code><code class="cf ic">istype()||isfunc()</code><code class="cf keyword">ID</code><code class="cf keyword">expr</code></p><p>
The parser will predict an <code class="cf keyword">expr</code> from <code class="cf keyword">stat</code>
only when <code class="cf ic">istype()||isfunc()</code> evaluates to true. This makes sense because the
parser should  choose to match an expression only if the upcoming
<code class="cf keyword">ID</code> is a type name or function name. It wouldn’t make sense to
test just  one of the predicates in this case. Note that when the parser gets to
<code class="cf keyword">expr</code> itself, the parsing decision tests the predicates
individually, one for each alternative.
</p>
<p id="f_0097.html.N1ACB0">
如果序列中出现多个谓词，解析器会用运算符将​​它们连接起来<code class="cf ic">&amp;&amp;</code>。例如，考虑更改<code class="cf keyword">stat</code>为在调用之前包含一个谓词<code class="cf keyword">expr</code>。
	</p><p>
If multiple predicates occur in a sequence, the parser joins them with the <code class="cf ic">&amp;&amp;</code> operator. For example,  consider changing <code class="cf keyword">stat</code> to include a predicate before the call to <code class="cf keyword">expr</code>.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat:   decl | {java5}? expr ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1ACC8">
在这种情况下，只有评估结果为真时，解析器才会预测第二种选择
<code class="cf ic">java5&amp;&amp;(istype()||isfunc())</code>。
</p><p>
In this case, the parser would predict the second alternative only if
<code class="cf ic">java5&amp;&amp;(istype()||isfunc())</code> evaluated to true.
</p>
<p id="f_0097.html.N1ACCE">
现在转到谓词本身内的代码，请记住以下准则：
</p><p>
Turning to the code inside the predicates themselves now, keep in mind the following
guidelines:
</p>
<dl>
<dt class="force-newline">
<span class="emph">使用有意义的谓词。</span>
</dt><dt class="force-newline">
<span class="emph">Use meaningful predicates.</span>
</dt>
<dd>
<p id="f_0097.html.N1ACD9">
		ANTLR 假设您的谓词确实解决了歧义问题。例如，ANTLR 不知道以下谓词无法有效解决两个替代方案之间的歧义问题：
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​expr:   {isTuesday()}?  ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// ctor-style typecast</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    |   {isHotOutside}? ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// function call</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
		ANTLR assumes that your predicates actually resolve the ambiguity.  For example, ANTLR has no idea that the following predicates don’t meaningfully resolve the ambiguity between the two alternatives:
		</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​expr:   {isTuesday()}?  ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// ctor-style typecast</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    |   {isHotOutside}? ID <em class="string">'('</em> expr <em class="string">')'</em>  <em class="comment">// function call</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    ;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<span class="emph">谓词必须没有副作用。</span>
</dt><dt>
<span class="emph">Predicates must be free from side effects.</span>
</dt>
<dd>
<p id="f_0097.html.N1AD05">
		 ANTLR 假设它可以无序甚至多次评估您的谓词，因此不要使用这样的谓词<code class="cf ic">{$i++ &lt; 10}?</code>。几乎可以肯定，这样的谓词不会像您希望的那样运行。
		</p>
</dd><dd>
<p>
		 ANTLR assumes that it can evaluate your predicates out of order or even
         multiple times, so don’t use predicates like <code class="cf ic">{$i++ &lt; 10}?</code>. It’s
         almost certain that such predicates won’t behave like you want.
		</p>
</dd>
</dl>
<p id="f_0097.html.N1AD0B">
即使解析器没有做出决定，谓词也可能使替代方案失效，从而导致规则失败。当规则只有一个替代方案时，就会发生这种情况。没有选择，但 ANTLR 会将谓词作为正常解析过程的一部分进行评估，就像它对操作所做的那样。这意味着以下规则总是无法匹配：
</p><p>
Even when the parser isn’t making decisions, predicates can deactivate alternatives,
causing rules to fail. This happens when a rule has only a single alternative. There
is no choice to make, but ANTLR evaluates the predicate as part of the normal
parsing process, just like it does for actions. That means the following rule
always fails to match:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   {false}? <em class="string">'return'</em> INT ; <em class="comment">// throws FailedPredicateException</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AD1F">
ANTLR<code class="cf ic">{false}?</code>在生成的解析器中将语法转换为条件。
</p><p>
ANTLR converts <code class="cf ic">{false}?</code> in the grammar to a conditional in the generated
parser.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">if</strong> ( !false ) <strong class="prompt">throw</strong> <strong class="prompt">new</strong> FailedPredicateException(...);​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AD39">
到目前为止，我们看到的所有谓词在预测过程中都是可见的并且可用，但情况并非总是如此。
</p><p>
So far, all of the predicates we’ve seen have been visible and available to the
prediction process, but that’s not always the case.
</p>
<h3>寻找可见谓词</h3><h3>Finding Visible Predicates</h3>
<p id="f_0097.html.N1AD40">
解析器不会在动作或标记引用之后发生的预测过程中评估谓词。让我们首先思考一下动作和谓词之间的关系。
</p><p>
The parser will not evaluate predicates during prediction that occur after an action or token reference. Let’s think about the relationship between actions and predicates first.
</p>
<p id="f_0097.html.N1AD49">
ANTLR 不知道操作的原始代码中有什么，因此它必须假设任何谓词都可能依赖于该操作的副作用。想象一个计算值的操作<code class="cf variable">x</code>和一个测试的谓词
<code class="cf variable">x</code>。在执行创建操作之前评估该谓词<code class="cf variable">x</code>将违反语法中隐含的操作顺序。
</p><p>
ANTLR has no idea what’s inside the raw code of an action,  so it must assume any
predicate could depend on side effects of that action. Imagine an action that
computed value <code class="cf variable">x</code> and a predicate that tested
<code class="cf variable">x</code>. Evaluating that predicate before the action executed to
create <code class="cf variable">x</code> would violate the implied order of operations within
the grammar.
</p>
<p id="f_0097.html.N1AD55">
更重要的是，解析器在决定匹配哪个替代方案之前无法执行操作。这是因为操作有副作用，我们无法撤消诸如打印语句之类的操作。例如，在以下规则中，解析器在<code class="cf ic">{java5}?</code>提交该替代方案之前无法执行谓词前面的操作：
</p><p>
More importantly, the parser can’t execute actions until it has decided which
alternative to match. That’s because actions have side effects and we can’t undo
things like print statements.  For example, in the following rule, the parser can’t  execute the action in front of the <code class="cf ic">{java5}?</code> predicate before committing to that alternative:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">@members</strong> {boolean allowgoto=false;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: {System.out.println(<em class="string">"goto"</em>); allowgoto=true;} {java5}? <em class="string">'goto'</em> ID <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AD7A">
如果我们不能在预测期间执行动作，我们就不应该评估谓词，
<code class="cf ic">{java5}?</code>因为它依赖于该动作。 
</p><p>
If we can’t execute the action during prediction, we shouldn’t evaluate the
<code class="cf ic">{java5}?</code> predicate because it depends on that action. 
</p>
<p id="f_0097.html.N1AD80">
预测过程也无法看透标记引用。标记引用具有将输入推进一个符号的副作用。如果解析器将测试当前输入符号的谓词移到标记引用上，则该谓词会发现自己不同步。例如，在以下语法中，谓词期望
<code class="cf methodname">getCurrentToken</code>返回一个<code class="cf keyword">ID</code>标记：
</p><p>
The prediction process also can’t see through token references. Token references
have the side effect of advancing the input one symbol. A predicate that tested the
current input symbol would find itself out of sync if the parser shifted it over the
token reference. For example, in the following grammar, the predicates expect
<code class="cf methodname">getCurrentToken</code> to return an <code class="cf keyword">ID</code> token:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat: <em class="string">'{'</em> decl <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    | <em class="string">'{'</em> stat <em class="string">'}'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​decl: {istype(getCurrentToken().getText())}? ID ID <em class="string">';'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr: {isvar(getCurrentToken().getText())}?  ID ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1ADAE">
中的决策<code class="cf keyword">stat</code>无法测试这些谓词，因为在 的开头<code class="cf keyword">stat</code>，当前标记是左花括号。为了保留语义，ANTLR 不会测试该决策中的谓词。 
</p><p>
The decision in <code class="cf keyword">stat</code> can’t test those predicates because, at the start of <code class="cf keyword">stat</code>, the current token is a left curly. To preserve the semantics, ANTLR won’t test the predicates in that decision. 
</p>
<p id="f_0097.html.N1ADB7">
<span class="firstuseinline">可见谓词</span>是预测在遇到动作或标记之前遇到的谓词。预测过程会忽略不可见谓词，将其视为不存在。
</p><p>
<span class="firstuseinline">Visible predicates</span> are those that prediction encounters before encountering an action or token. The prediction process ignores nonvisible predicates, treating them as if they don’t exist.
</p>
<p id="f_0097.html.N1ADBC">
在极少数情况下，解析器无法使用谓词，即使它对特定决策可见。这就引出了我们的下一个细则主题。
</p><p>
In rare cases, the parser won’t be able to use a predicate, even if it’s visible to a particular decision. That brings us to our next fine print topic.
</p>
<h3>使用上下文相关谓词</h3><h3>Using Context-Dependent Predicates</h3>
<p id="f_0097.html.N1ADC6">
依赖于周围规则的参数或局部变量的谓词被视为<span class="firstuseinline">上下文相关谓词</span>。显然，我们只能在定义这些谓词的规则内评估它们。例如，下面的决策<code class="cf keyword">prog</code>测试上下文相关谓词是没有意义的<code class="cf ic">{$i&lt;=5}?</code>。该<code class="cf variable">$i</code>局部变量甚至没有在中定义<code class="cf keyword">prog</code>。
</p><p>
A predicate that depends on a parameter or local variable of the surrounding rule is considered
a <span class="firstuseinline">context-dependent predicate</span>. Clearly, we can evaluate
such predicates only  within the rules in which they’re defined. For example, it makes
no sense for the decision in the following <code class="cf keyword">prog</code> to test the context-dependent
predicate <code class="cf ic">{$i&lt;=5}?</code>. That <code class="cf variable">$i</code> local variable is not
even defined in <code class="cf keyword">prog</code>.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   vec5​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​vec5​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   ( {$i&lt;=5}? INT {$i++;} )* <em class="comment">// match 5 INTs</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AE00"><span class="emph">ANTLR 会忽略无法在正确上下文中求值的上下文相关谓词。通常，正确上下文只是定义谓词的规则，但有时解析器甚至无法在同一规则中求值上下文相关谓词！在自适应LL(*)</span>
预测期间，会在运行时动态检测这些情况。
</p><p>
ANTLR ignores context-dependent predicates that it can’t evaluate in the proper
context. Normally the proper context is simply the rule defining the predicate, but
sometimes the parser can’t even evaluate a context-dependent predicate from within
the same rule! Detecting these cases is done on-the-fly at runtime during adaptive <span class="emph">LL(*)</span> prediction.
</p>
<p id="f_0097.html.N1AE06">
例如，<code class="cf keyword">else</code>
此处子规则的可选分支的预测<code class="cf keyword">stat</code>“落下”
<code class="cf keyword">stat</code>并继续在调用规则中寻找符号
<code class="cf keyword">prog</code>：
</p><p>
For example, prediction for the optional branch of the <code class="cf keyword">else</code>
subrule in <code class="cf keyword">stat</code> here “falls off” the end of
<code class="cf keyword">stat</code> and continues looking for symbols in the invoking
<code class="cf keyword">prog</code> rule:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​prog:   stat+ ; <em class="comment">// stat can follow stat</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​stat​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=0]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   {$i==0}? <em class="string">'if'</em> expr <em class="string">'then'</em> stat {$i=5;} (<em class="string">'else'</em> stat)?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    |   <em class="string">'break'</em> <em class="string">';'</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AE42">
预测过程试图找出<code class="cf keyword">if</code>
除了<code class="cf keyword">else</code>子句之外，语句后面还可以跟什么。由于输入可以
<code class="cf keyword">stat</code>连续包含多个 s，
因此<code class="cf keyword">else</code>子规则的可选分支的预测会重新输入<code class="cf keyword">stat</code>。当然，这一次它会得到一个新的 副本，<code class="cf variable">$i</code>其值为 0，而不是 5。ANTLR 会忽略上下文相关谓词，<code class="cf ic">{$i==0}?</code>因为它知道解析器不在原始<code class="cf keyword">stat</code>调用中。谓词将测试 的不同版本
<code class="cf variable">$i</code>，因此解析器无法对其进行求值。
</p><p>
The prediction process is trying to figure out what can follow an <code class="cf keyword">if</code>
statement other than an <code class="cf keyword">else</code> clause. Since the input can have multiple
<code class="cf keyword">stat</code>s in a row, the prediction for the optional branch of the
<code class="cf keyword">else</code> subrule reenters <code class="cf keyword">stat</code>. This time, of course, it
gets a new copy of <code class="cf variable">$i</code> with a value of 0, not 5. ANTLR ignores
context-dependent predicate <code class="cf ic">{$i==0}?</code> because it knows that the parser isn’t in the
original <code class="cf keyword">stat</code> call. The predicate would test a different version of
<code class="cf variable">$i</code>, so the parser can’t evaluate it.
</p>
<p id="f_0097.html.N1AE60">
词法分析器中谓词的细则或多或少遵循了相同的准则，当然，词法分析器规则不能有参数和局部变量。让我们在下一节中查看所有特定于词法分析器的准则。
</p><p>
The fine print for predicates in the lexer more or less follows these same guidelines, except of course lexer rules can’t have parameters and local variables. Let’s look at all of the lexer-specific guidelines in the next section.
</p>
<h3 id="f_0097.html.sec.preds-in-lexer">词法分析器规则中的谓词</h3><h3>Predicates in Lexer Rules</h3>
<p id="f_0097.html.N1AE74">
在解析器规则中，谓词必须出现在备选方案的左侧，以帮助进行备选方案预测。另一方面，词法分析器更喜欢将谓词放在词法分析器规则的右侧，因为它们会在查看标记的整个文本后选择规则。从技术上讲，词法分析器规则中的谓词可以位于规则中的任何位置。某些位置可能比其他位置更有效或更不高效；ANTLR 不保证最佳位置。即使在单个标记匹配期间，词法分析器规则中的谓词也可能被执行多次。您可以在每个词法分析器规则中嵌入多个谓词，并在词法分析器在匹配过程中到达它们时对其进行评估。
</p><p>
In parser rules, predicates must appear on the left edge of alternatives to aid in
alternative prediction. Lexers, on the other hand, prefer predicates on the right edge of
lexer rules because they choose rules after seeing a token’s entire text. Predicates in
lexer rules can technically be anywhere within the rule. Some positions might be more or
less efficient than others; ANTLR makes no guarantees about the optimal spot. A predicate in
a lexer rule might be executed multiple times even during a single token match. You can
embed multiple predicates per lexer rule, and they are evaluated as the lexer reaches them
during matching.
</p>
<p id="f_0097.html.N1AE86">
粗略地说，词法分析器的目标是选择与最多输入字符匹配的规则。对于每个字符，词法分析器都会决定哪些规则仍然可行。最终，只有一条规则仍然可行。此时，词法分析器会根据规则的标记类型和匹配的文本创建一个标记对象。
</p><p>
Loosely speaking, the lexer’s goal is to choose the rule that matches the most input
characters. At each character, the lexer decides which rules are still viable. Eventually,
only a single rule will be still viable. At that point, the lexer creates a token object
according the rule’s token type and matched text.
</p>
<p id="f_0097.html.N1AE89">
有时，词法分析器会面临多个可行的匹配规则。例如，输入<code class="cf ic">enum</code>将匹配一个<code class="cf keyword">ENUM</code>规则和一个<code class="cf keyword">ID</code>
规则。如果后面的下一个字符<code class="cf ic">enum</code>是空格，则两条规则都无法继续。词法分析器通过选择语法中首先指定的可行规则来解决歧义。这就是为什么我们必须将关键字规则放在标识符规则之前，如下所示：
</p><p>
Sometimes the lexer is faced with more than a single viable matching rule. For example,
input <code class="cf ic">enum</code> would match an <code class="cf keyword">ENUM</code> rule and an <code class="cf keyword">ID</code>
rule. If the next character after <code class="cf ic">enum</code> is a space, neither rule can continue. The
lexer resolves the ambiguity by choosing the viable rule specified first in the grammar.
That’s why we have to place keyword rules before an identifier rule like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENUM : <em class="string">'enum'</em> ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID   : [a-z]+ ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AEAA">
另一方面，如果输入后的下一个字符<code class="cf ic">enum</code>是字母，那么才可
<code class="cf keyword">ID</code>行。
</p><p>
If, on the other hand, the next character after input <code class="cf ic">enum</code> is a letter, then only
<code class="cf keyword">ID</code> is viable.
</p>
<p id="f_0097.html.N1AEB3">
谓词通过修剪可行的词法分析器规则集来发挥作用。当词法分析器遇到错误谓词时，它会停用该规则，就像解析器停用具有错误谓词的替代方案一样。
</p><p>
Predicates come into play by pruning the set of viable lexer rules. When the lexer
encounters a false predicate, it deactivates that rule just like parsers deactivate alternatives with false predicates.
</p>
<p id="f_0097.html.N1AEB6">
与解析器谓词一样，词法分析器谓词不能依赖于词法分析器操作的副作用。这是因为只有在词法分析器明确识别要匹配的规则后，操作才能执行。由于谓词是规则选择过程的一部分，因此它们不能依赖于操作副作用。词法分析器操作必须出现在词法分析器规则中的谓词之后。例如，以下是<code class="cf keyword">enum</code>在词法分析器中作为关键字匹配的另一种方法：
</p><p>
Like parser predicates, lexer predicates can’t depend on side effects from lexer actions.
That’s because actions can  execute only after the lexer positively identifies the rule to
match. Since predicates are part of the rule selection process, they can’t rely on action
side effects. Lexer actions must appear after predicates in lexer rules. As an example,
here’s another way to match <code class="cf keyword">enum</code> as a keyword in the lexer:
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/Enum3.g4">参考/Enum3.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENUM:   [a-z]+ {getText().equals(<em class="string">"enum"</em>)}?​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​        {System.out.println(<em class="string">"enum!"</em>);}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID  :   [a-z]+ {System.out.println(<em class="string">"ID "</em>+getText());} ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AEDB">
中的打印操作<code class="cf keyword">ENUM</code>最后出现，并且仅当当前输入匹配<code class="cf ic">[a-z]+</code>且谓词为真时才执行。让我们构建并测试一下，
<code class="cf class">Enum3</code>看看它是否区分<code class="cf keyword">enum</code>和标识符。
</p><p>
The print action in <code class="cf keyword">ENUM</code> appears last and executes only if the current
input matches <code class="cf ic">[a-z]+</code> and the predicate is true. Let’s build and test
<code class="cf class">Enum3</code> to see whether it distinguishes between <code class="cf keyword">enum</code> and an
identifier.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ antlr4 Enum3.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ javac Enum3.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">$ grun Enum3 tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">enum abc     </strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">=&gt;&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">​<small>​<sup>E</sup>​<small>O</small>​<sub>F</sub>​</small>​</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&lt;=&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​enum!​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ID abc​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0097.html.N1AF12"><code class="cf keyword">enum</code>效果很好，但实际上只是为了指导目的。使用如下简单规则

匹配关键字更容易理解，也更有效：</p><p>
That works great, but it’s really just for instructional purposes. It’s easier to understand
and more efficient to match <code class="cf keyword">enum</code> keywords with a simple rule like this:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ENUM : <em class="string">'enum'</em> ;​</code></div>
</td>
</tr>
</tbody></table>

</div></div>
<div id="f_0098.html"><div>

<h2 id="f_0098.html.sec.options">15.8 选项</h2><h2>15.8 Options</h2>
<p id="f_0098.html.N1AF32">
	您可以在语法和规则元素级别指定多个选项。（目前没有规则选项。）这些选项会改变 ANTLR 从语法生成代码的方式。一般语法如下：
	</p><p>
	You can specify a number of options at the grammar and rule element
     levels. (There are currently no rule options.) These change how ANTLR generates code from
     your grammar. The general syntax is as follows:
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> { name1=value1; ... nameN=valueN; } <em class="comment">// ANTLR not target language syntax</em>​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0098.html.N1AF45">
其中值可以是标识符、限定标识符（例如<code class="cf ic">a.b.c</code>）、字符串、大括号内的多行字符串<code class="cf ic">{...}</code>和整数。
</p><p>
where a value can be an identifier, a qualified identifier (for example, <code class="cf ic">a.b.c</code>), a string, a multiline string in curly braces <code class="cf ic">{...}</code>, and an integer.
</p>
<h3>语法选项</h3><h3>Grammar Options</h3>
<p id="f_0098.html.N1AF52">
	  所有语法都可以使用以下选项。在组合语法中，除 之外的所有选项
      <code class="cf keyword">language</code>仅与生成的解析器有关。可以使用选项语法（前面已介绍）在语法文件中设置选项，也可以在命令行上调用 ANTLR 时使用选项设置<code class="cf commandoption">-D</code>
      选项（请参阅第 15.9 节“ <a href="#f_0099.html.sec.tool-options">ANTLR<em>工具命令行选项</em></a>”） <a href="#f_0099.html.sec.tool-options">。</a><code class="cf commandoption">-D</code>覆盖语法中的选项：
	</p><p>
	  All grammars can use the following options. In combined grammars, all options except
      <code class="cf keyword">language</code> pertain only to the generated parser. Options may be set
      either within the grammar file using the options syntax (described earlier) or when
      invoking ANTLR on the command line, using the <code class="cf commandoption">-D</code>
      option (see Section 15.9, <a href="#f_0099.html.sec.tool-options">​<em>ANTLR Tool Command-Line Options</em>​</a>.) The following examples demonstrate
      both mechanisms; note that <code class="cf commandoption">-D</code> overrides options within
      the grammar:
	</p>
<dl>
<dt>
<code class="cf keyword">superClass</code>
</dt><dt>
<code class="cf keyword">superClass</code>
</dt>
<dd>
<p id="f_0098.html.N1AF6E">
	设置生成的解析器或词法分析器的超类。对于组合语法，它设置解析器的超类。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat Hi.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​grammar Hi;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​a : 'hi' ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -DsuperClass=XX Hi.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grep 'public class' HiParser.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​public class HiParser extends XX {​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grep 'public class' HiLexer.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​public class HiLexer extends Lexer {​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
	Set the superclass of the generated parser or lexer. For combined grammars, it sets the superclass of the parser.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat Hi.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​grammar Hi;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​a : 'hi' ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -DsuperClass=XX Hi.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">grep 'public class' HiParser.java</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​public class HiParser extends XX {​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">grep 'public class' HiLexer.java</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​public class HiLexer extends Lexer {​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">language</code>
</dt><dt>
<code class="cf keyword">language</code>
</dt>
<dd>
<p id="f_0098.html.N1AFA9">
   如果 ANTLR 能够生成代码，则使用指定语言生成代码。否则，您将看到如下错误消息：
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -Dlanguage=C MyGrammar.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​error(31):  ANTLR cannot generate C code as of version 4.0​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
   Generate code in the indicated language, if ANTLR is able to do so. Otherwise, you will see an error message like this:
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -Dlanguage=C MyGrammar.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​error(31):  ANTLR cannot generate C code as of version 4.0​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">tokenVocab</code>
</dt><dt>
<code class="cf keyword">tokenVocab</code>
</dt>
<dd>
<p id="f_0098.html.N1AFC9">
  ANTLR 在文件中遇到标记时会为标记分配标记类型编号。要使用不同的标记类型值（例如使用单独的词法分析器），请使用此选项让 ANTLR 提取文件<code class="cf fileextension">tokens</code>。ANTLR<code class="cf fileextension">tokens</code>根据每个语法生成一个文件。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat SomeLexer.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​lexer grammar SomeLexer;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​ID : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat R.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​parser grammar R;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​options {tokenVocab=SomeLexer;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​tokens {A,B,C} // normally, these would be token types 1, 2, 3​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​a : ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 SomeLexer.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat SomeLexer.tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​ID=1​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 R.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat R.tokens</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​A=2​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​B=3​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​C=4​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​ID=1​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
  ANTLR assigns token type numbers to the tokens as it encounters them in a file. To use different token type values, such as with a separate lexer, use this option to have ANTLR pull in the <code class="cf fileextension">tokens</code> file. ANTLR generates a <code class="cf fileextension">tokens</code> file from each grammar.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat SomeLexer.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​lexer grammar SomeLexer;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​ID : [a-z]+ ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat R.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​parser grammar R;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​options {tokenVocab=SomeLexer;}​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​tokens {A,B,C} // normally, these would be token types 1, 2, 3​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​a : ID ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 SomeLexer.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat SomeLexer.tokens</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​ID=1​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 R.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat R.tokens</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​A=2​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​B=3​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​C=4​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​ID=1​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt>
<code class="cf keyword">TokenLabelType</code>
</dt><dt>
<code class="cf keyword">TokenLabelType</code>
</dt>
<dd>
<p id="f_0098.html.N1B02B">
	ANTLR 通常<code class="cf class">Token</code>在生成引用标记的变量时使用类型。如果您已将 传递<code class="cf class">TokenFactory</code>给解析器和词法分析器以便它们创建自定义标记，则应将此选项设置为您的特定类型。这可确保上下文对象知道字段和方法返回值的类型。
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat T2.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​grammar T2;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​options {TokenLabelType=MyToken;}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​a : x=ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 T2.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">grep MyToken T2Parser.java</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​    public MyToken x;​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
	ANTLR normally uses type <code class="cf class">Token</code> when it generates variables referencing tokens. If you have passed a <code class="cf class">TokenFactory</code> to your parser and lexer so that they create custom tokens, you should set this option to your specific type. This ensures that the context objects know your type for fields and method return values.
	</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat T2.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​grammar T2;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​options {TokenLabelType=MyToken;}​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​a : x=ID ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 T2.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">grep MyToken T2Parser.java</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​    public MyToken x;​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
</dl>
<h3>规则选项</h3><h3>Rule Options</h3>
<p id="f_0098.html.N1B067">
目前没有有效的规则级选项，但该工具仍然支持以下语法以供将来使用：
</p><p>
There are currently no valid rule-level options, but the tool still supports the following
syntax for future use:
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​rulename​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">options</strong> {...}​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   ...​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<h3 id="f_0098.html.sec.element-options">规则元素选项</h3><h3>Rule Element Options</h3>
<p id="f_0098.html.N1B08B">
		标记选项的形式为
        <span class="emph">T </span>
<code class="cf ic">&lt;</code>
<span class="emph">name</span> = <span class="emph">value</span> &gt;，如我们在第 5.4 节“<a href="#f_0036.html.sec.precedence">处理<em>优先级、左递归和结合性”</em></a>中看到的那样<a href="#f_0036.html.sec.precedence">。</a><code class="cf keyword">assoc</code>，它接受值<code class="cf keyword">left</code>和<code class="cf keyword">right</code>。图 13 <a href="#f_0098.html.code.reference.ExprLR.g4"><em>“示例语法</em></a><a href="#f_0098.html.code.reference.ExprLR.g4">”显示了<em></em></a>一个示例语法，其中有一个左递归表达式规则，该规则在
        <code class="cf ic">’^’</code>指数运算符标记上指定了一个标记选项。
	</p><p>
		Token options have the form
        <span class="emph">T</span>
<code class="cf ic">&lt;</code>
<span class="emph">name</span>=<span class="emph">value</span>&gt;, as we saw in Section 5.4, <a href="#f_0036.html.sec.precedence">​<em>Dealing with Precedence, Left Recursion, and Associativity</em>​</a>. The only token option is <code class="cf keyword">assoc</code>, and it
	  accepts values <code class="cf keyword">left</code> and <code class="cf keyword">right</code>. Figure 13, <a href="#f_0098.html.code.reference.ExprLR.g4">​<em>A sample grammar</em>​</a> shows a sample
        grammar with a left-recursive expression rule that specifies a token option on the
        <code class="cf ic">’^’</code> exponent operator token.
	</p>
<div class="figure" id="f_0098.html.code.reference.ExprLR.g4">
<div>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/reference/ExprLR.g4">参考/ExprLR.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">grammar</strong> ExprLR;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​expr : expr <em class="string">'^'</em>&lt;assoc=right&gt; expr​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'*'</em> expr  <em class="comment">// match subexpressions joined with '*' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | expr <em class="string">'+'</em> expr  <em class="comment">// match subexpressions joined with '+' operator</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     | INT            <em class="comment">// matches simple integer atom</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​     ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​INT : <em class="string">'0'</em>..<em class="string">'9'</em>+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​WS  : [ \n]+ -&gt; skip ;​</code></div>
</td>
</tr>
</tbody></table>
</div>
<div class="figurecaption">
<hr>图 13. 示例语法</div>
</div>
<p id="f_0098.html.N1B0FD">
语义谓词还接受一个选项，即“<a href="#f_0060.html.sec.failed-preds">捕获<em>失败的语义谓词”</em>。</a>唯一有效的选项是<code class="cf keyword">fail</code>选项，它采用双引号中的字符串文字或计算结果为字符串的操作。操作的字符串文字或字符串结果应该是谓词失败时发出的消息。
</p><p>
Semantic predicates also accept an option, per <a href="#f_0060.html.sec.failed-preds">​<em>Catching Failed Semantic Predicates</em>​</a>.
The only valid option is the <code class="cf keyword">fail</code> option, which takes either a string
literal in double quotes or an action that evaluates to a string. The string literal or string result from the action should be the message to emit upon predicate failure.
</p>
<table class="processedcode">
<tbody><tr class="livecodelozenge">
<td colspan="2">
<a href="http://media.pragprog.com/titles/tpantlr2/code/errors/VecMsg.g4">错误/VecMsg.g4</a>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ints[int max]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​<strong class="prompt">locals</strong> [int i=1]​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    :   INT ( <em class="string">','</em> {$i++;} {$i&lt;=$max}?&lt;fail={<em class="string">"exceeded max "</em>+$max}&gt; INT )*​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​    ;​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0098.html.N1B12B">
当谓词失败时，动作可以执行函数以及计算字符串：
 <code class="cf ic">{...}?&lt;fail={doSomethingAndReturnAString()}&gt;</code>。
</p><p>
The action can execute a function as well as compute a string when a predicate fails:
<code class="cf ic">{...}?&lt;fail={doSomethingAndReturnAString()}&gt;</code>.
</p>

</div></div>
<div id="f_0099.html"><div>

<h2 id="f_0099.html.sec.tool-options">15.9 ANTLR 工具命令行选项</h2><h2>15.9 ANTLR Tool Command-Line Options</h2>
<p id="f_0099.html.N1B13C">
如果您在没有命令行参数的情况下调用 ANTLR 工具，您将收到一条帮助消息。
</p><p>
If you invoke the ANTLR tool without command-line arguments, you’ll get a help message.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ANTLR Parser Generator  Version 4.0​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -o ___              specify output directory where all output is generated​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -lib ___            specify location of grammars, tokens files​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -atn                generate rule augmented transition network diagrams​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -encoding ___       specify grammar file encoding; e.g., euc-jp​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -message-format ___ specify output style for messages in antlr, gnu, vs2005​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -listener           generate parse tree listener (default)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -no-listener        don't generate parse tree listener​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -visitor            generate parse tree visitor​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -no-visitor         don't generate parse tree visitor (default)​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -package ___        specify a package/namespace for the generated code​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -depend             generate file dependencies​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -D&lt;option&gt;=value    set/override a grammar-level option​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -Werror             treat warnings as errors​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -XdbgST             launch StringTemplate visualizer on generated code​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -Xforce-atn         use the ATN simulator for all predictions​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2">​​<code style="white-space:pre-wrap">​ -Xlog               dump lots of logging info to antlr-timestamp.log​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0099.html.N1B192">
以下是有关这些选项的更多详细信息：
</p><p>
Here are more details on the options:
</p>
<dl>
<dt class="force-newline">
<code class="cf commandoption">-o</code>
<span class="standin">外目录</span>
</dt><dt class="force-newline">
<code class="cf commandoption">-o</code>
<span class="standin">outdir</span>
</dt>
<dd>
<p id="f_0099.html.N1B19E">
  ANTLR 默认在当前目录中生成输出文件。此选项指定 ANTLR 应在哪个输出目录中生成解析器、侦听器、访问者和<code class="cf fileextension">tokens</code>文件。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -o /tmp T.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls /tmp/T*</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​/tmp/T.tokens             /tmp/TListener.java​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​/tmp/TBaseListener.java   /tmp/TParser.java​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
  ANTLR generates output files in the current directory by default. This option specifies the output directory where ANTLR should generate parsers, listeners, visitors, and <code class="cf fileextension">tokens</code> files.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -o /tmp T.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">ls /tmp/T*</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​/tmp/T.tokens             /tmp/TListener.java​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​/tmp/TBaseListener.java   /tmp/TParser.java​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-lib</code>
<span class="standin">库目录</span>
</dt><dt class="force-newline">
<code class="cf commandoption">-lib</code>
<span class="standin">libdir</span>
</dt>
<dd>
<p id="f_0099.html.N1B1CD">在查找<code class="cf fileextension">tokens</code>文件和导入的语法时，ANTLR 通常会在当前目录中查找。此选项指定要查找的目录。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat /tmp/B.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​parser grammar B;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​x : ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat A.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​grammar A;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​import B;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​s : x ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​ID : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -lib /tmp A.g4</strong>​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>When looking for <code class="cf fileextension">tokens</code> files and imported grammars, ANTLR normally looks in the current directory. This option specifies which directory to look in instead.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat /tmp/B.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​parser grammar B;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​x : ID ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat A.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​grammar A;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​import B;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​s : x ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​ID : [a-z]+ ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -lib /tmp A.g4</strong>​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-atn</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-atn</code>
</dt>
<dd>
<p id="f_0099.html.N1B20C"><span class="emph">这将生成 DOT 图形文件，这些文件表示 ANTLR 用于表示语法的内部增强转换网络 (ATN) 数据结构。文件以Grammar</span> . <span class="emph">rule</span>
的形式输出<code class="cf ic">.dot</code>。如果语法是组合语法，则词法分析器规则名为<span class="emph">Grammar</span>
<code class="cf ic">Lexer</code> . <span class="emph">rule</span>
<code class="cf ic">.dot</code>。
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">cat A.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​grammar A;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​s : b ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​b : ID ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​ID : [a-z]+ ;​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -atn A.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">ls *.dot</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​A.b.dot         A.s.dot         ALexer.ID.dot​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>This generates DOT graph files that represent the internal augmented transition network (ATN) data structures that ANTLR uses to represent grammars. The files come out as <span class="emph">Grammar</span>.<span class="emph">rule</span>
<code class="cf ic">.dot</code>. If the grammar is a combined grammar, the lexer rules are named <span class="emph">Grammar</span>
<code class="cf ic">Lexer</code>.<span class="emph">rule</span>
<code class="cf ic">.dot</code>.
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">cat A.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​grammar A;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​s : b ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​b : ID ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​ID : [a-z]+ ;​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -atn A.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">ls *.dot</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​A.b.dot         A.s.dot         ALexer.ID.dot​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-encoding</code>
<span class="standin">编码名称</span>
</dt><dt class="force-newline">
<code class="cf commandoption">-encoding</code>
<span class="standin">encodingname</span>
</dt>
<dd>
<p id="f_0099.html.N1B259">默认情况下，ANTLR 使用 UTF-8 编码加载语法文件，这是一种非常常见的字符文件编码，对于适合一个字节的字符，它会退化为 ASCII。世界各地有许多字符文件编码。如果该语法文件不是您所在地区的默认编码，则需要此选项，以便 ANTLR 可以正确解释语法文件（例如下面的文件）。这不会影响生成的解析器的输入，只会影响语法本身的编码。 
  </p>
<div xmlns:str="http://exslt.org/strings">
<img src="data:image/png;base64,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" alt="图片/参考/编码.png">
</div>
</dd><dd>
<p>By default ANTLR loads grammar files using the UTF-8 encoding, which is a very common character file encoding that degenerates to ASCII for characters that fit in one byte. There are many  character file encodings from around the world. If that grammar file is not the default encoding for your locale, you need this option so that ANTLR can properly interpret grammar files (such as the one below). This does not affect the input to the generated parsers, just the encoding of the grammars themselves. 
  </p>
<div xmlns:str="http://exslt.org/strings">

</div>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-message-format</code>
<span class="standin">格式</span>
</dt><dt class="force-newline">
<code class="cf commandoption">-message-format</code>
<span class="standin">format</span>
</dt>
<dd>
<p id="f_0099.html.N1B26E">
    ANTLR 使用目录 中的模板生成警告和错误消息<code class="cf dir">tool/resources/org/antlr/v4/tool/templates/messages/formats</code>。默认情况下，ANTLR 使用<code class="cf filename">antlr.stg</code>(StringTemplate group) 文件。您可以将其更改为<code class="cf ic">gnu</code>或 ，<code class="cf ic">vs2005</code>让 ANTLR 生成适合 Emacs 或 Visual Studio 的消息。要制作您自己的名为<span class="standin">X 的</span>资源，请创建资源<code class="cf dir">org/antlr/v4/tool/</code>
<code class="cf dir">templates/messages/formats/</code>
<span class="standin">X</span>并将其放置在 中<code class="cf variable">CLASSPATH</code>。
  </p>
</dd><dd>
<p>
    ANTLR generates warning and error messages using templates from directory<code class="cf dir">tool/resources/org/antlr/v4/tool/templates/messages/formats</code>. By default, ANTLR uses the <code class="cf filename">antlr.stg</code> (StringTemplate group) file. You can change this to <code class="cf ic">gnu</code> or <code class="cf ic">vs2005</code> to have ANTLR generate messages appropriate for Emacs or Visual Studio. To make your own called <span class="standin">X</span>, create resource <code class="cf dir">org/antlr/v4/tool/</code>
<code class="cf dir">templates/messages/formats/</code>
<span class="standin">X</span> and place it in the <code class="cf variable">CLASSPATH</code>.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-listener</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-listener</code>
</dt>
<dd>
<p id="f_0099.html.N1B29D">
   该选项告诉 ANTLR 生成一个解析树监听器，这是默认选项。
  </p>
</dd><dd>
<p>
   This option tells ANTLR to generate a parse-tree listener and is the default.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-no-listener</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-no-listener</code>
</dt>
<dd>
<p id="f_0099.html.N1B2AC">
此选项告诉 ANTLR 不要生成解析树监听器。
  </p>
</dd><dd>
<p>
This option tells ANTLR not to generate a parse-tree listener.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-visitor</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-visitor</code>
</dt>
<dd>
<p id="f_0099.html.N1B2BB">
	ANTLR 默认不生成解析树访问者。此选项可启用该功能。ANTLR 可以同时生成解析树监听器和访问者；此选项和<code class="cf commandoption">-listener</code>并不互相排斥。
  </p>
</dd><dd>
<p>
	ANTLR does not generate parse-tree visitors by default. This option turns that feature on. ANTLR can generate both parse-tree listeners and visitors; this option and <code class="cf commandoption">-listener</code> aren’t mutually exclusive.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-no-visitor</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-no-visitor</code>
</dt>
<dd>
<p id="f_0099.html.N1B2CD">告诉 ANTLR 不要生成解析树访问者；这是默认设置。
  </p>
</dd><dd>
<p>Tell ANTLR not to generate a parse-tree visitor; this is the default.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-package</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-package</code>
</dt>
<dd>
<p id="f_0099.html.N1B2DC">
  使用此选项可为 ANTLR 生成的文件指定包或命名空间。或者，您可以添加操作<code class="cf ic">@header {...}</code>，但会将语法与特定语言联系起来。如果您使用此选项和<code class="cf ic">@header</code>，请确保标头操作不包含包规范；否则，生成的代码将有两个包规范。
  </p>
</dd><dd>
<p>
  Use this option to specify a package or namespace for ANTLR-generated files. Alternatively, you can add an <code class="cf ic">@header {...}</code> action, but that ties the grammar to a specific language. If you use this option and <code class="cf ic">@header</code>, make sure that the header action does not contain a package specification; otherwise, the generated code will have two of them.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-depend</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-depend</code>
</dt>
<dd>
<p id="f_0099.html.N1B2F1">
不生成解析器和/或词法分析器，而是生成文件依赖项列表，每行一个。输出显示每个语法所依赖的内容以及它所生成的内容。这对于需要了解 ANTLR 语法依赖项的构建工具很有用。以下是示例：
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -depend T.g</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​T.g: A.tokens​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​TParser.java : T.g​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​T.tokens : T.g​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​TLexer.java : T.g​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​TListener.java : T.g​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​TBaseListener.java : T.g​</code></div>
</td>
</tr>
</tbody></table>
<p id="f_0099.html.N1B31B">
如果使用<code class="cf commandoption">-lib libdir</code>with<code class="cf commandoption">-depend</code>和语法选项<code class="cf ic">tokenVocab=A</code>，则依赖项也包括库路径：<code class="cf ic">T.g: libdir/A.tokens</code>。输出也对<code class="cf commandoption">-o outdir</code>选项敏感：<code class="cf ic">outdir/TParser.java : T.g</code>。
</p>
</dd><dd>
<p>
Instead of generating a parser and/or lexer, generate a list of file dependencies, one per line. The output shows what  each grammar depends on and what it generates. This is useful for build tools that need to know ANTLR grammar dependencies. Here’s an example:
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -depend T.g</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​T.g: A.tokens​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​TParser.java : T.g​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​T.tokens : T.g​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​TLexer.java : T.g​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​TListener.java : T.g​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​TBaseListener.java : T.g​</code>​</div>
</td>
</tr>
</tbody></table>
<p>
If you use <code class="cf commandoption">-lib libdir</code> with <code class="cf commandoption">-depend</code> and grammar option <code class="cf ic">tokenVocab=A</code>, then the dependencies include the library path as well: <code class="cf ic">T.g: libdir/A.tokens</code>. The output is also sensitive to the <code class="cf commandoption">-o outdir</code> option: <code class="cf ic">outdir/TParser.java : T.g</code>.
</p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-D&lt;option&gt;=value</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-D&lt;option&gt;=value</code>
</dt>
<dd>
<p id="f_0099.html.N1B336">
   使用此选项可覆盖或设置指定语法中的语法级选项。此选项对于生成不同语言的解析器而不改变语法很有用。（我希望在不久的将来有其他目标。）
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -Dlanguage=Java T.g4  </strong>
<em class="comment"># default</em>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -Dlanguage=C T.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​error(31):  ANTLR cannot generate C code as of version 4.0​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
   Use this option to override or set a grammar-level option in the specified grammar or grammars. This option is useful for generating parsers in different languages without altering the grammar. (I expect to have other targets in the near future.)
  </p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -Dlanguage=Java T.g4  </strong>
<em class="comment"># default</em>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -Dlanguage=C T.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​error(31):  ANTLR cannot generate C code as of version 4.0​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
<dt class="force-newline">-W错误
</dt><dt class="force-newline">-Werror
</dt>
<dd>
<p id="f_0099.html.N1B35E">
作为大型构建的一部分，ANTLR 警告消息可能会被忽视。启用此选项可将警告视为错误，从而使 ANTLR 工具将失败报告回调用的命令行 shell。
</p>
</dd><dd>
<p>
As part of a large build, ANTLR warning messages could go unnoticed. Turn on this option to have warnings treated as errors, causing the ANTLR tool to report failure back to the invoking command-line shell.
</p>
</dd>
</dl>
<p id="f_0099.html.N1B367">
还有一些扩展选项主要用于调试 ANTLR 本身。
</p><p>
There are also some extended options that are useful mainly for debugging ANTLR itself.
</p>
<dl>
<dt class="force-newline">
<code class="cf commandoption">-XdbgST</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-XdbgST</code>
</dt>
<dd>
<p id="f_0099.html.N1B371">
	 对于构建代码生成目标的用户，此选项会弹出一个窗口，其中显示生成的代码以及用于生成该代码的模板。它会调用 StringTemplate 检查器窗口。
  </p>
</dd><dd>
<p>
	 For those building a code generation target, this option brings up a window showing the generated code and the templates used to generate that code. It invokes the StringTemplate inspector window.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-Xforce-atn</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-Xforce-atn</code>
</dt>
<dd>
<p id="f_0099.html.N1B37F">
  ANTLR 通常会尽可能构建传统的“根据标记类型切换”决策（一个前瞻标记足以区分决策中的所有替代方案）。要将这些简单的决策强制纳入自适应<span class="emph">LL(*)</span>机制，请使用此选项。
  </p>
</dd><dd>
<p>
  ANTLR normally builds traditional “switch on token type” decisions where possible (one token of lookahead is sufficient to distinguish between all alternatives in a decision). To force even these simple decisions into the adaptive <span class="emph">LL(*)</span> mechanism, use this option.
  </p>
</dd>
<dt class="force-newline">
<code class="cf commandoption">-Xlog</code>
</dt><dt class="force-newline">
<code class="cf commandoption">-Xlog</code>
</dt>
<dd>
<p id="f_0099.html.N1B391">
  此选项会创建一个日志文件，其中包含 ANTLR 在处理语法时发出的大量信息消息。如果您想了解 ANTLR 如何翻译左递归规则，请打开此选项并查看生成的日志文件。
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​$ <strong class="prompt">antlr4 -Xlog T.g4</strong>​</code></div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left:1em">​​<code style="white-space:pre-wrap">​wrote ./antlr-2012-09-06-17.56.19.log​</code></div>
</td>
</tr>
</tbody></table>
</dd><dd>
<p>
  This option creates a log file containing lots of information messages from ANTLR as it processes your grammar.  If you would like to see how ANTLR translates your left-recursive rules, turn on this option and look in the resulting log file.
</p>
<table class="processedcode">
<tbody><tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​$ <strong class="prompt">antlr4 -Xlog T.g4</strong>​</code>​</div>
</td>
</tr>
<tr>
<td class="codeprefix" valign="top">
<span class="codespan">&nbsp;</span>
</td>
<td class="codeline" valign="top">
<div style="font-size:-2;padding-left: 1em;">
​<code style="white-space: pre-wrap;">​wrote ./antlr-2012-09-06-17.56.19.log​</code>​</div>
</td>
</tr>
</tbody></table>
</dd>
</dl>

<div class="footnotes">
<h4>脚注</h4><h4>Footnotes</h4>
<table cellspacing="3">
<tbody><tr valign="top">
<td class="footnote-number">
<a id="f_0099.html.FOOTNOTE-58" href="#f_0090.html.FNPTR-58">[58]</a>
</td>
<td>
<p id="f_0099.html.N19092">
<a href="http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference">http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference</a>
</p><p>
<a href="http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference">http://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference</a>
</p>
</td>
</tr>
<tr valign="top">
<td class="footnote-number">
<a id="f_0099.html.FOOTNOTE-59" href="#f_0094.html.FNPTR-59">[59]</a>
</td>
<td>
<p id="f_0099.html.N1A284">请参阅
  <a href="http://en.wikipedia.org/wiki/Scope_(programming)#Static_scoping">http://en.wikipedia.org/wiki/Scope_(programming)#Static_scoping</a>。
  </p><p> See
  <a href="http://en.wikipedia.org/wiki/Scope_(programming)#Static_scoping">http://en.wikipedia.org/wiki/Scope_(programming)#Static_scoping</a>.
  </p>
</td>
</tr>
</tbody></table>
</div>
<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>





</div></div>
<div id="f_0100.html"><div>

<h1 class="chapter-title" id="f_0100.html.N1B3B3">
<span class="chapter-number">
	      附录 1</span>
<br><br>
<span class="chapter-name">参考书目</span>
</h1><h1 class="chapter-title">
<span class="chapter-number">
	      Appendix
	      1</span>
<br><br>
<span class="chapter-name">Bibliography</span>
</h1>
<dl class="bibliography">
<dt>[ALSU06]</dt><dt>[ALSU06]</dt>
<dd>Alfred V. Aho、Monica S. Lam、Ravi Sethi 和 Jeffrey D. Ullman。<em>编译器：原理、技术和工具</em>。Addison-Wesley Longman，马萨诸塞州雷丁，第二版，2006 年。</dd><dd>Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. <em>Compilers: Principles, Techniques, and Tools </em>. Addison-Wesley Longman, Reading, MA, Second, 2006.</dd>
<dt>[Gro90]</dt><dt>[Gro90]</dt>
<dd>Josef Grosch。递归下降解析器中高效而舒适的错误恢复。<em>结构化编程</em>。11[3]:129–140，1990 年。</dd><dd>Josef Grosch. Efficient and Comfortable Error Recovery in Recursive Descent Parsers. <em>Structured Programming</em>. 11[3]:129–140, 1990.</dd>
<dt>[Par09]</dt><dt>[Par09]</dt>
<dd>Terence Parr。<em>语言实现模式</em>。The Pragmatic Bookshelf，北卡罗来纳州罗利和德克萨斯州达拉斯，2009 年。</dd><dd>Terence Parr. <em>Language Implementation Patterns</em>. The Pragmatic Bookshelf, Raleigh, NC and Dallas, TX, 2009.</dd>
<dt>[前82名]</dt><dt>[Top82]</dt>
<dd>Rodney W. Topor。递归下降解析器中的错误恢复说明。SIGPLAN<em>通知</em>。17[2]:37–40，1982 年。</dd><dd>Rodney W. Topor. A note on error recovery in recursive descent parsers. <em>SIGPLAN Notices</em>. 17[2]:37–40, 1982.</dd>
<dt>[Wir78]</dt><dt>[Wir78]</dt>
<dd>Niklaus Wirth。<em>算法 + 数据结构 = 程序</em>。Prentice Hall，新泽西州恩格尔伍德克利夫斯，1978 年。</dd><dd>Niklaus Wirth. <em>Algorithms + Data Structures = Programs</em>. Prentice Hall, Englewood Cliffs, NJ, 1978.</dd>
</dl>

<div class="copyright">版权所有 © 2013，The Pragmatic Bookshelf。</div>


</div></div>
<div id="f_0101.html"><div>

<h2 xmlns:str="http://exslt.org/strings">你可能感兴趣…</h2><h2 xmlns:str="http://exslt.org/strings">You May Be Interested In…</h2>
<p xmlns:str="http://exslt.org/strings">
<em>单击封面获取更多信息</em>
</p><p xmlns:str="http://exslt.org/strings">
<em>Click a cover for more information</em>
</p>
<div xmlns:str="http://exslt.org/strings" class="backmatter-covers">
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/bhtmux">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/dccar">
<img alt="" src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/7QAsUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQAB/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1QYWNrYXJkIENvbXBhbnkAAGRlc2MAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAAAAAAAAAAAAAABYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9kZXNjAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRlc2MAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAACxSZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2aWV3AAAAAAATpP4AFF8uABDPFAAD7cwABBMLAANcngAAAAFYWVogAAAAAABMCVYAUAAAAFcf521lYXMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAKPAAAAAnNpZyAAAAAAQ1JUIGN1cnYAAAAAAAAEAAAAAAUACgAPABQAGQAeACMAKAAtADIANwA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCGAIsAkACVAJoAnwCkAKkArgCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEBAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGhAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJxAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNyA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSoBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYWBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/B9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmkCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvIC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4uDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDXEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPFE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6Fx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3Gp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5AHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJVIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3JugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitpK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBsMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXCNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtrO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFqQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fASAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5uTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1VcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzWXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSUZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yvbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUodYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4BfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7h5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDWkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrVm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4pammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AAsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsuu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbDx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv77IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf///9sAQwABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgEBAgEBAQICAgICAgICAgECAgICAgICAgIC/9sAQwEBAQEBAQEBAQEBAgEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC/8AAEQgAmAB/AwERAAIRAQMRAf/EAB8AAAEEAgMBAQAAAAAAAAAAAAAGBwgJBQoBBAsDAv/EAEQQAAEEAgECBAEGCgkCBwAAAAMCBAUGAQcIABEJEhMUIRUWMTh4txcYUVVYh5WX1NYKIjJBV3GRltUjoSQnYWLR4fD/xAAdAQEAAQUBAQEAAAAAAAAAAAAABAMFBgcIAQIJ/8QARREAAgEDAgQDAwUNBwQDAAAAAQIDAAQRBSEGEhMxB0FRImHRU2JxkvAUFRYjMlJWcoGVobHTCBczQkNzgiQlNJF1suH/2gAMAwEAAhEDEQA/ANwbjFxi41z/ABs49Ts7x60dNTk1o7U0tMzMtqahSUrLSslQoB5IycnIvIBZn8gd2YxTGKtZCkKpa1KUrOcqU+P4pnFb9Gfj9+5rXP8ALfSlaYv9JN1BJca+S2i71pVUjqbWm3tRSkQes64cnpFQHf8AWNnXiYfNoCsKas20i7rN1rKjrSLBD5i/ORSsp74t140iOpVyqsPIkbj7Cuwf7OmmcJ8R8O65Y6zw3p2rajpN2jiW4sraaboXMXsqZJImcqkkEnKCcDnwMVT/AMatebr3ghczK7Z20CrOSTURG/NLZ/e5GsMM7qbZ0kNUsbvK5yKQm4xGFZZrwvB3QQkID1kL6jo8rbmVsfrH3eWffW1+J9I8PtC/FR8D6KblAjt1tKt+gI3EpGZYofxbnovjnGOUFgG5SKUewOMfNutXQ1apFr2/siFSwi37W0otL+lEIF57Vs+NLVKevxZGpgay7obUvykkJUrKLziQow0K9JnB2kZh9J+NRdP/ALormxW5vuEtF06cs6mL73Ws4yuSoSaOzEcxdQWHSLAgHBOCRGDaMhyV0zZU1HY982FXp0kaxmW7VWy5N+h1ESgUOIyUbmYTxMZZOGxRkAomBqKIiSoTkakLV8GSYbGRh/yPxrKtK4T8M9atjd6bwdpFzArMhP3qtV5XUkMhDW49pSCGAyAQQTnIDdY3NtlSsoTtjYal4x3yhN8sil4x9HfKcSvfGOvOtL8q31j8auX93vAWMngfSAP/AIyz/oVsif0a3VrzkfyW37bt1pebd13qvTUNFNa1soxb1VEXjZNxF8lSZIK0ZdtCSjau0ex4AXIvVCmUXkak4WrzS7NpHdyzswUeZJGSf/w1zp/aM0jhXh7h3QrTRuHNP0nUNUvHcyW1lbQS9C2h9pQ8UavytJPGWGcEqM9q3N/xTOK36M/H79zWuf5b6uNcgUfimcVv0Z+P37mtc/y30pR+KZxW/Rn4/fua1z/LfSlH4pnFb9Gfj9+5rXP8t9KUfimcVv0Z+P37mtc/y30pR+KZxW/Rn4/fua1z/LfSlH4pnFb9Gfj9+5rXP8t9KVB3xIePOgaNwu3NaaTo3T1Os8X+Dv5MsdW1nS69PR3vdrUWOe+wl4mEC4aetHu3YC+mRPqBdEEvuhak5UqcXEz6q3Gf7P2mvu5rfSlSB6UqjHx6eAG3OenGXWkRx9qTC5bn1XuKOs0LESFlr1SE6plkrszWbwAczZ37ZoIiFErrzA1mSovyR5R4Uvy46i3UTSovIMsp/h+2t1+B3HmlcC8S6hNr101ro+p2jROyxvKRNHIksB5IwzEHEiZA258kgZrVaq/gJ+MDUJ6v2GG4+QYnlanYmwx4FchdSiYrfQ8tHzIBOQsdgBUpqV5GM/XSNY1kSLH/AFEqShaIYtZwQQoyPeK6euvHTwlvILi3m12QpcxvGx+990W5XRkJBaFhkBjykggE9iCQZusuAHjmPTTsnsTibpzatnkqxmvxdyuW5NQGtUO4QZwttJHlRX5Sp0KG7j262jhOBEbNxCypPkwrH30bkZ/FhifePjWDScbeCKLbxabxTe6Tawy9RoIbO66Lg4yoQw4TJHOHU5DEnBzikQ98MLxopEqzvuDfFR24WyCywdxY9GuSh9LOFFeN1utmEyJ6dfqKOvvlJFnIvCEqV368+57jf8Wu/wBHxqfH4j+DkShU411ZVBJwI70Zz2BxbjIG3KO4AAyQKQGyfB88YrZtWe1GQ4U8aavGPJJjKIc0Ky8eqpLxhmEg5fjbw8uzvKjsGBMOVNzBysiTNhDEvvlCF48NtORjpgf+qn6b4seEWmXcd5Hxlql1KispFwl/KjcyhcuhhCswxzKcDDEkd8VsP+AP4e+7uBmhN2tuRtQj6Rtja+3mcoqEjrTW7gNNDp1Oi4iquCzFVkXTXBCzMpcC4B6vqiwTClpT6mO8u1iaJW5xhmP07D7GtB+OvH2jcda9oz8PXbXmlaVaFedopIT15pneUBJVVsBFhHNjBxt2q+3qVWjaOlKOlKOlKOlKOlKOlKr98Uv6iO9P1Y/fHr3pSpA8TPqrcZ/s/aa+7mt9KVIHpSjpSuO2PyY/0x0pR2x+TH+mOlKO2PyY/wBMdKUdsfkx/pjpSuelKOlKOlKOlKOlKOlKOlKOlKr98Uv6iO9P1Y/fHr3pSpA8TPqrcZ/s/aa+7mt9KVIHpSjpSjpSjpSjpSjpSjpSjpSjpSjpSjpSjpSjpSjpSq/fFL+ojvT9WP3x696UqQPEz6q3Gf7P2mvu5rfSlSB6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uo6Uqv3xS/qI70/Vj98evelKkDxM+qtxn+z9pr7ua30pT3TUmmFh5WYW1dPkRUa/klMmXt/eO0sGhnamrT3bgQvckwHKB+qUY/OvHnIhPdWFKiFp/nfovbyaZkbuUoRNg6+0zsWopvbqoAbSjLfjt8w1pUiS9Wtkqxjtlvnke4GOuuHIpM/pkKxE8A3dlbqVkZ3nFoCLtlBqsPZx3fF+l6xGhslNfV+UqldY2t5umIj7HY5tzOASCCDYNBbJjnq2yHJmbuGVg4UiG5K3Upeak5L6z3VYttQdHenesdQvqK3l7Ys8Oup2BjsLW0DtOBnKzJtJUqzRGK3YWmDLeBZrwUSyCGZmtu6MpSFp/ObjfZ6YG6S97a61CuX29DOa/tD29StUYbR1uaVDYTyUhlOj5YxrQsvWJDB1kwn5KuUS/JgQ3qMJUpyC8nOPjZ9Jxjzcmu4+QhZCxxMszlLRGRbmNlamedb2GLeikTCy2kWpKvZvOBfYqk1x+sSCDZuVCUrvSHInRsQTAJfatGiXOGj96drKWFjGu2QY01ibPMSTR8QZYtwhzULYLAXKBGIWryIxDWRi6SJSsTFcqeNs4oaYneuqX+CsnUkhbe81/IlR7OiB2kV/g632EYZZ1mZNiGXKsDNBJXLhUSPGRwhSnTp15p+wYhU7SbLDWiJFISESd9CPwPwtZaJcKaSsS99FWVMpRs6QobhsZKDhXjykGnPbHSlKrpSjpSjpSjpSjpSq/fFL+ojvT9WP3x696UqQPEz6q3Gf7P2mvu5rfSlPZOxny1CS8Pl2dh8qxchGe9bIARwz9+0M0903G6EsRDj9bzoSRC0ZUjGFpUnOcZUqszVvCrjfJRVGgabv+cv01pKh8fKPTZKtWTVRHlfhuOGxoS60OZstfpNYExtNgc2emAaSEhJtDI9uJ+ziERRHcgsylfOR8KPS8yNjGzWy9vS9bE0lIuZgXTiiCHZ4mZv3JLYEmxlpWPo4XTVZnfKbZDJRo8jIiWjGJUPyPGrl08UqQUNw9joKvb2iWe39nkmuQEJruBt9udsdcHl4xpr6hxessLrjEdDRHNiylOihBkfcM3KcHfOnLBLLKxDApSIsPhy6JskzsBw6e2qLqOwths9kSOtqwiq12mR8s60U649X6Ijhx9W98SsWyiqhi2Jmd4bDqTqsc+ARqsRUnUrHTvCvjjRY6be3e8nA02hBaj1JbJ7awdTWp3e72xiM6hqE68lNiUJ4IuxLSKxJi5JmAaGVgey/pDjEOH7xL5Ske18Pzi3FT1p1NFbJssPY7+xq2z57V7a8QjySVGavt1sda1s9Xqk60eP6jrut3K8kCyYRygwHrRzCPdBKlToD1SvgXwwdE3WjCqchs/ZVpocoikqdt20hQfazbSi8QZvhhHYTMRNPxkaTUCZdy7gjdacfONuMosCiUkhiKVYdruiR2va+qEYGA7I4kHkvKSIa7VKwSVl5D0cv5R5GU2CjmfvzrChZi4b+oVasqUvKfIlClLvpSjpSjpSjpSjpSq/fFL+ojvT9WP3x696UqQPEz6q3Gf7P2mvu5rfSlL/bVEJtLVmydaBskvTjbCoNzowrdX1+nPVYlurUpXkWOEX6iPJLsVSWHTbPnT2M1RnzJ/tYUqEmON27HGv+PdazDagrL7RjPV1RtgKVZbTDo3PrSiVqUgZHXYbE0qDV9rrXxJ1NSsbeFV8qCK9rI4p6bLL1HjpSoyNeCvNIEA9i5jdubXY3T22jeXZxvnckQaZhZbgKPR8KxJBgiljisg5UsoW1qWMizYFEItOSFshSx6lK/di4Uc2p6OvxxbUaMLLaoXkSOPdh5FbjGCNsd84raQoepJAa2tZQlg3ieSlFvNrWhu2wiIRPolYwLqRkHzAKlOBauK/NC0WfM4a+1iJi5az0qQs0FWt37ihEPGdQ5o0fdi5YD9UAR0iRdccmN3prpoh0Fks01iJbiZ1fLcTBSsK54U8pZZcq2sdvq9rg2e6tW3XVkPP7h2U6aapoOrPEAsnJXMKybGqZhWyal9HvaDAj9/jOIh5rJlDjeOYPDV23UqSNi01yTre/oTcVNd0DazuN492LUZJjYtlPrqQc2Gz70rt9xJvoSja7eNVQMZSYp0EWGqwu5B83bNi+0SdxLAUqFeuOBvN6lUGGrcTuKHo9qhpfT0ZDWiD3Ps6zxtWq9a48bH1RsWWianL1Zuydv3l/sNSsWIpQhN5g8N7yQfNZNm1KRSrTeNGr7TqjXfyDcpablLDIP2UtKpltjTGzGTGUHVa1BSw63MTdZiTRsA5lYR6/S09r/WdS7p+ZSXb5yMalSF6Uo6Uo6Uo6Uo6Uqv3xS/qI70/Vj98evelKkDxM+qtxn+z9pr7ua30pTuXOztKVUrLb37CclWVYgpWedRdYg5WzWOSBEsjPSR8BXYNqd7OzR8B9Jq0aBK4cHMgQRrWrGMqVTDGb35aaTvTXW17eWtDLc3JfU1xhr5M0rYu4WEDrTkRobcFtventfnPWY307ZTt16ceOGMGMMgWGqt9jGx48oexmylIOwcnudu1dOb/qElSJeN2PH0y1U63UbVustjQ1v1iK2+HI13tEWiDv9fnnZ2O1G/IOw0yKiIJqYkwpF1DFjbnfsFzKFKfjUm+eYvzm3/GT1WvIarR5Ges+n5qwaE2RbJDb7SMdJzOa9iIxcvCqg3TOnR0D8gkK9Ztp+Ytzt173LeNkWQFKSdt3rzisBZqQYVnZtbhqvS+Ugq8SG0pbQOL1MyXELSOx9DSE3GJiyOQyzPdNk3RBMwx6giM+o4oxwY8jgTl8pWVccl+ekfWqUWN1TLodyNorkDZ0TemL9Z3lOpSttcdqbWrgcrB61cXCXsWsLrtqflxoQJVZPWlqkQsEQEoCRUp1aNyE5kyGx6pBzOrCTFGa7pvGrbTKtdfXOlWo9Wht/wC0qNWtrCj7bCohLBSHOpYXX007dRlhj3TT3juVYQ8/HykYyaqVaRjv2x3+ntjv/n/f0pWAlrbVYE4Ws5ZYCGcuMYy3byszGxx3GM9+2QheOUKJjOcZ+jGerfdatpdi4ivdSt7ORtwss0cbEeoDsDj31crPRtY1GN5dP0q5voo9maGCWVVPvZEYD9pqHXJHn7pPivYdfNdqrlGdF2KiTZxG04pLeVo7W0xhw4VT5OVaLUKOnSsDodgG4KH1wILkHq5AfA8b1fjKHTJrV7ewfWdLnVi1zaSxS9N1OOQoG9rK+1nnHoAcHGf8J+Feq8W2upCDU7fSdc094wun3wktppoZFP4+NpFAKq4KEcpPNjJAK5Uus+dPG3a0ieNqt/jDlGgJRGy7YOmxxOBpIFWCRrw6gKzhWO+CoRjHf+1n+6BY+JnDd3Obecz6a5PstPEQjf8AJC4U+5gPpqXrnglx7oVol5JYJexsMssD8zpjOcq6pzDzBQtkeVSxjZWNmWYpCJftJJkfv6Ttk4E5bkynPZaUlErOMqSrvhWPpTnHbOMZ6zu1u7a9hS4tLhLmCTOHRgynGxwVJG3mO47HetWXdnd2M7217bPaXEeOZJFZGGdxlWAO43B7Ebiu/wBSKjUdKVX74pf1Ed6fqx++PXvSlSB4mfVW4z/Z+0193Nb6Up1L7Y3FPo9ytjRhmVdVmq2OwtotJht8yLiEhnsoFhhwVaUAyYjRI/OpSUp9TvlWMY79KVXprTmZSd+PdHNrjoF1KScltDW1Zq1nk0UaWiK1ue3cI4jmVFWOnspaWPIQYRavtE/FCkc+3fgkMrZ91snZXifiRnVCyR9Rhj2QQCR54J2z6AkA+or6QKzBWfpg+ZBIB8s4ycepAOPQ008xy/tGrOSO5qxBa7oZMynKWKox1RuqJChyuw6vWOGeveQd3d23bx7N7KZ3xF1WUkW9djX7MZJyHqKWbJvhqzk5eK8jlSVeZcj1BBDDy3B3G4IB7HyJr2SNo25WwfQggg/QRsf5jzxS+x4hE3eNqaBqeqtflNF7AjalY7ZD2x1XGknLV7bfD7b/ACW1yGuWQNq9tWphjLaocRkul+1cgKmUGZqtLXzvBVK+KezjTzdgeUE81i6Xre0wrQkFGXl88s0rX2chGa1veuNbbH07enEG1OUxI61Mb+/Ys0DWrLeQ15PhIUqGPqLUqcvbGP7v/n4/HPx/zxjpSue2P/3/AKZ74/79KUZx3xnH5fh0pVYvJ3wytd8h9jTG2nu8d865mH6WUk4h6vY4GSpTWYhYwLBnNNoCyV52VphLdqNZWoHQ2xCpURIxrWvOcD1rw+0HV7u81KfniuroZdtnGQoXIDAkeyoBAIG22K3dwZ468X8H6Rp3D1jZ2d3p1iXVA8RSV0lkMjRySxsnP7bHlZ1JAwGLADGsbO0Rji0yNGqHPGvXfV8hmbRIwG56MV7GWqQdFcuWEhbK4/fykYGLEc6yoINWXI1DT6LYKvhjQTSaYlxI9jpNykcbARThTbMVQ45gkUjn2gMjmyd8lQa7QSfWL7Tbe51nT7MXccREsCSxXRBcfkLK8cEgKZAITCYGBJy71VxW7fY9M8hHJY2202kFq006A2ldRxpJGk7Aj2D9UY+XXW0o6S1jcLSBBFEy1wjIiqytug3p9ZTcRRXumAiOS9Mg26x5XhbGRzELzkb7b5PrjNWazaa31PpXCxaVCUBdIg7rcRscEYaUokiNgPy7L9OM7HvHPxO3FIM3msTQBgcmb4lYBRRvIWzqSPA1mf4GsY4ZykaU4Q6ANBsds5Xgg+wc47pWr8Q8MXv3RprnosczW7g9GYDb2lzs+BtKmHHnzLlTa+LvDbh/jC0NtdqpkjBEF0jKJ7YnJwpx+MjJO8UpKH/LyMecbI+g+QGveROuIvY9DlAFYuSljpiLM5brkq3Psy4bv4KWEJf/AEnSDKGoSs4ThwByE48eQycddK8P69acQaZb6hbfi2kH4yJiC8LjZkfGOx3VsAOuGA3xXC/GHCWqcGa5d6Jqah2gOY5kBEU8R3SWMnyIOGXJKOGRjlSae7CsZ+Hf45x37Z+Cu35fLn44+jPV9rFqr+8Uv6iO9P1Y/fHr3pSpA8TPqrcZ/s/aa+7mt9KU+cnGR01GyEPMMGcpEyrJ3GycZINxO2EjHP25Gr1i9aHQpDpoZqYoyjWlSFoIpCsZTnOOlKayB49aGqpYY9Z0vqyvGrtgjbZXywlCq8WSDtENTEa3iLHELZRiMxs4010IVfbOw+Q4IMSYkS0R6cN8KV9pfQ2mpo068e6woapKzXGv7Fn5ZNSr+ZSZ2DUhMgVS8yzwscpUrbIwEZGjYP3ODOGgo4AgrQIQ0JoTQJMVYkpIn5LqcOv0H0+acqfMGqiSNHkABkburDKn6R6+8EN6EUik8e9EQojN5TQenjRxmLGMNKxWr6iJCoyLi5eFjmUvGAh8qA0bQtgnmYsh9VsFnNvG+BtGjgwV0etNb/8Akr1Ih/qIO3+4gyR+smV8yEFVulFN/gNyP+Y57/qOdj7lbDeQLGl9r7WFWpUtarVDuzzMvdcxbYsy8BWxEjqbXHE24pGvoRdZgmAsUeB+c1hREhOl05CmZcZO9crJleJaOsiq6MHRtwQQQR6giozKyMVZSrL3BGCPpBp0uvqvKOlKOlKOlK1ZPG04G21lJUDefGvSVWgNbUaButs3PMazr7BtYGU0zeAlhWKwVca1Bkq8OFRIl9RnGHIl0gy32cjy3xjV/F2gCErPpmkqLeUMZmiypDZyWcKw5U5e7LgA83MQCK6S8JOPHYy2GvcTObyNo1tY7vEqNHy8vJEzo5M3NgBXJyvKIxkGqF6nyTjbpBfg7dag1BG1OdbvIG07Utul6qu5xDWVwtvKWKCcvgDev7ivsMjVTNAFIMEOEHChHl61m+lz6cJJxevJKMFIlfnBwchS2+FAyCSche3rXSKalYcRXUASxljjiGXmeVraJWCBciJioJOB7Cgox3dWOBWZneM9ogDsVaTYbfsVNJBNXR7FsKBrtMsHv0ZL7twwrraaKtpFED6Kmqz5Q6Wpau48Y8isxDrtg7OLySGOZTjlVi69uxZQQcHbuds53yBLTS9REKtBKMSEjKMQMeWBIEYkjclUA/N2GanV4TGy9g0zdLHV8hXI0lOkZW1LusXKSbWVcPAkrsi7fAlodS1JMzyNqyCZHciMFMhWMpUhKsXbSekOIdMv7e5YmRWVgEKo8QjfKk7Bt/aXmG2BjfFa38RNOaTg3WYb20SKWxMbRkyK7rK88YBA35Nm35TuC3lnMCOVfixc9vDJ56cg9D6f5K2y1agpN7RI0fXm4Vh25X4eiXWHirvBVJDm4qNKMQRjSwfJ48tZJuTAY4efPnOVd932ksrQxyRTMg3GM8w2OOzZG/uxj1rju6jjWd4poEfGN8crYIB/KXlz38806uf6RHyh55uYDi1eNfaHqVL2GyyK4P6bC3PNnlHlJam2CwexrucuTgEEMk1Uo71QJbOcZAow0lxlaVDuME9w8yK7Dl3zhcZ2JznmPn6VbpoLdIZXRGDDBGWyACQMY5Rnat6HiZ9VbjP9n7TX3c1vq41bqdu6ObSzp9rd0aPjpe6Nq5OOKjFS7hTSKkrMGMdEgmEk6QtOW7A0olqMy8KRlIyKz50f2sKVG+T2RyZh3wWMTpAV0iEiM6xY39hg6lKOgJgnssFkatNpN6hnJkmhCh/NhzkQleSSJj27hIBKUn3mzOYWYNyltoavYmsuEs27sFojyoCoAqy5dShId5LpG7jlKk7CAA0P0ENmsqJlYfeN0pUpTT9x5QV233NrEazgdh1YM8YdKdCmI+nGcQBoSvTKCSJHL10or0EnJ2OOSTCAocZqoc5CFckgwVK6LWc5GSkQ8m2etYnWkoTYMLFOYv37W4Oz0M8V7qdufyAOXZsnswmbOyaobheAc+3bvXK1ulpbNiRDaBZDLbv9zyMcttlGPq6ZAJ+cpVz5sRsZAuCyhJl6yjsc4dR6K+Dt81gy+gB3pOut4cqoyRywkeM8dgYMYQiQHsKL9pOLEWTQ5JGEGpY2asgj2hRtyrW4X8sYQIZcNVrL6LkIyx3I6EjbAk5Rj5BXwBk+Styt6A150GZTJCesi98DDL72Xvj5y5X3iu3B7o5R2KHrcsx45sWrWcbVacw7fW8LUvyHIKinky0dwUspo8gJz2bl+AAnaFEAoCHbpt5sqjsSqoU9WprhtqxllgbU1uyoZkDjzQvyNNLsbB0LMJX3sul9IlC3y2djm5p+wCFLfOC/Nd27wXICtckUp6+lKT1tq8Ld6tZKZY2mH9ftsBMVmdZZWoeHkPPRzmKk2vqI+I/UZOjp82Pinzd8fHHVG4gjuYJreUZinVkYeqsCCM+Wx7+RqRaXU1jd217bNyXFpIkqHGcPGwZTjzwQNvOtXC/eARvrX15d2njJvqjP6+3ZJbQsNsNhK1yzNUndEK4CWTiYyRYuXI2g2ocO0IarOlZc5C3x2SrVmoeHtzJDJBFNHew8wK9RnikxjGG5QyHHuKhjuVHaul9F8edOSSGbUdOm0+cIEcQrHcQZDKTIokeORS2CMe2UGwZvLDQvhF+JbOxMs0ndk6Hr7hKF+wNK260zj10RWFeVKHMLTlYbixjCEp9ZSvhnHmTnCeseTwrundZOjDEF7qZic+f+WNh/EetZlN/aO4fiTprBcXDP/nW2ReTJ7kPOufXYfxqGPh8a327rjlBZWVtr8/OI13Ibdo+xp2KHEWuCh9gR5y1R1BHnKvKvkR0yixlJlDaQUxdGbx5iBbkGNfavHpVxp14kk9p0EgBjAU5IY4UbbZHchgCrbnPerLxJxronEfDtxbWGqtdXV1LFKwkUoWVXMjEHLKMYAKEhlOAR51qy+LbfA3HxFeWdhw9E9STaR4gBBFwdOW9dgIGvhHgqVZxjCPk1SMpTnPlUjKM47pzjGzdKDHT7Q4PtKT6d2J/jXNutyoup3i5zyMBt22VfMbdxTR+HhIKLzO1EPz5ylxi/9sd89s+nqy7K+jv8Mf1ervApEiH0z/I1Y5ZMhwNg+P4Y+3239gziZ9VbjP8AZ+0193Nb6n1Gp3bjXk22o2iqqeGj0WWvTMAt83U6Q4ZomI5xHrcgIyetjjMhDjKkqC4bmTlOFCOJeEkSpUQ23EzYEKN0Ctcm9oRTHLd2OOj8ev6LBZY8jVp2W3nxpdYbuPQKghxGOVQcreFdnM4MZSkk74c7SmIhlIzvIa4ubgSvVUU01aSU61izWGtIE+a5a2T5UU9dRYLFgzsJHzJ0YmTFGYOGhkMmylPRZONr+cma/ZmG17dXrVEUODqMlY40XryE/KwsoR4i2u8yMkVLeUUwlrczTgePOhvaCN1OCshezKpXUa8cLeWJvULZd9bAt8fbtXTutmLec9ysMOecgWUAW4OGbeeS3mbFgDQp1KUECPdSDkoMNkl8mFK4iuNtpRtFey7Duy2yw3Eihy9pcawNCVF3FiElAq4qPLYnuQwGCNmK1tkZwJyoK/eIc4y39r8uiOrI6h1YYIIBBHoQcg/tr1WZWDKxVl3BBwQfcRuKkXlhKxOfPEmVIs8fFURJuFqKNOO+c4jZUuVLH/7ROfUHnPZKSgTjqH0Z7Yf9K3ViH+k5O3+25yV/VfmXyBQVK6sM+1wvTkP+ogG5+egwD+suD5kMayEfMMpBZG6MkavgJwpzGvR+2ft057Y86gKzn1QZz2wkolECvt/UIrqrDdRzEx7xzL3Rhhx78b5HzlLKfWqctvJEA5w8TdnU5U+7PkfmsAw8wKy3UmqFHSlHSlcKxnKc4xntnOM4xn8mc4+GelK8+7mfvaT8Enx7+S+85bXj696y5t63Y2iOZNZMkGLBdg2WrSz6yOUi7fLTmH2bRLg2wHBREGKxJcDJ8VALj2twTyQM1sEaWA9RVfm5SMEsPZ7HHbyyN6v+hT20d5Gl47x212OkzRBCyk7KxD7coOObzwfZ3rUi5bbihd+cmt9bqgKjF0GB2fte6XSEpEL6fyTVYialznYQrH0GgUqCJvhHdWBIyta1rzjurOcybSMx20EZULhRsM4BIyQM74B2FQr+QS3l04cyKXYAtjJAOATjbJGCfppxPDjP63NXTPZPlSjOxcY79++f/Ki9d8/5d+3+vU2LZ1x2PwP2/lUFjt7u32+3869iriZ9VbjP9n7TX3c1vqXVOpA9KUdKUdKUdKUdKUdKUdKVjpCJYyiBpdh8ywLyRs5EsgHjQue3/VaOwKSRsTtj45QrHmx8FYzjOcZoT28VwoEqZK7qQSGU+qsPaU+8EZ7HI2qrFNJCSY2wG2IIBVh6MpyCPcQaTr+Tl6oyeP5ETuxQce0dPXDqOZLc2Ro1aAK4NnMOwDnNhXgQleVLIeHhFeUYmbgqsd4jPeWm7g31uPNQBMo96jCyAeqBX+a5qSqW10QqMLSduwYnpMfQMcmMn5+U9XUU0fH7lzxw5SQLuwaJ23VL6KLIcE/CtHRoq41R40XgL2PuVFnwNZmpSAHHmGYMgxbqGtGUq+OM9SIL21uUZ4pgQmSwOxUDzYHBH0nb319Xulahp8ix3dq8RfZTjmV89uR1yrZ9ASfdT2yluq0JHYl5ixwUXFqzhKZB/LMGrNa84zlKBuTHwkhM4x8EpzlWf7sdULnV9KsrcXd3qUFtantI8saofP2WLYJ9wya+rTR9Wv7k2djplxd3YGTHHDI7geZKqpIA8yQAPM1EO98+9CVWYPW4CdRebE2D67hjCum7VqFOfMnCFPn3bLgvmTnGUgCbKfpV2xnHfWWveMvDOk5Wwjl1tkG7Q4jgB/N60uOY/wC2jj31uDh7wA451iFLvUYF4ftJDhTOrPK3bcRRZCj3yyR58hVFPikaB4reJBY9WXrkvXJ+vE1dGTdeqKqhfX9UcSETaJaKl3rW1SmIMhH4W7iMWVlgCG+ELeOU49RRceXWGpeNnEl9LzaXp9tYwn8kMj3DkZGSzsY028iseM571tDQ/wCz/wAPRq8eo3l3qt1GCWMbJAgIBwEReoxycBuaTYb4FN7wj/o/vg33zVNv2jbtM3vaUOS2zzNk9vu8Ni4RBw1LYCNLLiW1Ml4XIxOMuXBF+99w4zhmLyrEnKsL21wFxBquuaM+oa3Ii3BuJI0EaLEOnGqbkAtlmYtvnAAAx3rS/ijwlYcJcRxaNpUDKotYZpOrIZiJJmkIUMVGyoq5xnJJOe2NPfiyHUb3nXCTusNfwlErMjcNvSNGrkY8mpNFUqT6qX5dfggSU7KOnb9LaukaN1HdGMcykrIQmVKznGe2zObhAzE9/wD6mtcXCRCFyqgMMb/tA/l+zfavV94mfVW4z/Z+0193Nb6u1WypA9KUdKUdKUdKUdKUdKUdKUdKUZx3+GelKoT8VPw66dsK3RHLDX2vr3B3+HgZiv7Hu/F+cmKFvl22kUjFG3OSaQWFttrxkezS4bO2jlqqSQ1dZzgztnhY2mueObbiGCOLUtAihuYYwwuYGh55JA23OCDzMoBKyKoDYPMSwzjdvhLe8JX082gcVX82l3c7xtYXj3HJawmPJMTAqVikZ+WSGV+eMMvJyoxBaqTWJ5mwUOu1TYfidS8mqtPztXktLcc6yzt+Y0bjIYxAX73ZDfKpkMWvDd8o4yDW6GoifKPPpo0HNNwxO0RvNGv9OCH/AAIQk8Sg9zG7OjqucgK4bA7MRXYVnZ8ZaRHJJZaJo/EV1OmBeC4e0MoH5JubaOOWEyHCs8kXTDtk9MMTnr6rLDa1lJ+37z5Sttns8SjkdMqNPg2NVhI6NbqKVqKxPyrI5vFpMBTIiyIW0jgKSZKAGSpJh4pq0djf9O30vSJLaNcmRpfbmYc3s47JEpGebAZidg2NqyeJOKGSTrpaxGYKEKgIiZXEh7ksQc4yByqAeXm3qI/JzxDGl4cPISmsytYUKshGReG50mWBeRK8y8pzheP6iO2E59PGcYynGM475v2l8I3DtHPd8qfmqO6qRsdtx9vKsbl1nSeHkljgnN/ebhpF2QtncAk7jvv6edT48I7km6uPGPdOtlvcIkq/si3YKyU+UtyCt7SqEY1jHah/2itlSTCbD58Y8mCt1I83m+HW39LeTSbJLaLZEy22wJJ32H7Pf51y9x5jXOIZdSlH/kqsY/zYEeQBzH0BB2238q0sODDGRrnOHX9UkhEA9r05tevPgkyrCxO6/Qr/ABTka0q+jOHDFeO35cdbctWDvC4OQ4yPoK5H860HdKUSaNu6HB+kMAf4ivXd4mfVW4z/AGftNfdzW+rpVqqQPSlHSlHSlHSlHSlHSlHSlHSlHSlcZxjOO2f/AL/zxnH0Z6EZpVMfM/wYNNcoLm92br69zOgL3NKdOrUiv1yJs1Ktcu4Nk6599WH5264edKtSvdGj3QAu859Y7VTrKzrwbV+B7C/nkurRxYzTZZxyFo3YnJblV0KscktynlJ35ckk7j4U8Zde0Cxi0vUIzrFlbALCxl6c8SAYEYdo5RJGMDlV15lHsh+UKq1X7U8BfkrSao7e6+vWv96uwtnIkVzCH2sbAFLkWfckh1yrl1HPiKyjOfTW5ZrVlWEpUv6MYZf+H2rwFZrWSK8CnmaNMo7cvbHUPK+PQyD3A1uHQfH3hu4L2epQ3OkdRSqTSBbiNObY8xhHUjB75WJh64FVY6g8Ifmpuvc4dTl0zY9axICiVcr5seuTcJUKNDe6UlL9Tt+gOLPMZSha2kfFKckdrwnzEbtPVdj+9L0fU76c2/3HLZvEQHaVDGqjzJOBz5H5KqSTjuBvUTininh7SbT7v+/Fvq0VwrdFLaZZnkbOQAqsREBtztIo5SccpOFO3Xq7wxtL8V+MMzqrQ1SZTmxZQcJJW/ZNoCzTedmTkYb/AMQSVmArGiGikBcvvk6LaqHHsEqxhCCuCHdGz294dij0eS0sYRLdAq3M2AzkbN7RxyjlJwucD3nc8+Lxdd6hriX2pTGC09pRGmeSJSMr7OPabIHM5HMd+wwB55uwdC2bjd45WzdW2mHRBPo/bu3bM0jgnE6bihdi6ltOxIVTdyAq0GBmPtAe2UrV2ynKc582M9T9JSeKGziuU6dxEgV1yCAyrjYgkHbByD51ZdVeCaa8mtn6kErllbBGQzc3Y4I3JG4HavUB4mfVW4z/AGftNfdzW+r7VjqQPSlHSlHSlHSlHSlHSlcZ+H+uP++cY6UqBULzDuCDvQWDR10k8FsE3AQ7mkxU47aikWO6Lxq2MiZ1xORgBxzs9ercHZyuckS2BDzhjrxgIGR5NSsgx5eWqVuFVqrbQmw4jFknNUYLJ2NhItWMZV9jZECQM8Myiy+2t0U4cDI7jDJGMLMBnTl4Hsga1KRkBzhu+Wk6ey8eLqtEHE3i0uXlaW5UyHWtf2uxQ9gb+afjgZd3D5vxMZJs4cKsv34pXCBgDgkcSRUpcynM4sXNvK2TQ24Ty7AI8uCAhkrh1vTzderAmDCT9HGZUyJ6wI9dTYREDYx7h+NRh4QhalZZhydt62R5iZ07YYxo3r+s5LMANE48sr78INUrMzIT0etVcG0xT4KyWF1CzBnKwPGpavIultcdmrNypSBc86H8jAWuQqHHfcchIV+L2E6GWUi45vXWcxr1/MwsjUrDIx0ic7G5/K8OpBYZg2kZJu3doOoBFjO3EpSlXzaY5lyRgNHbtcATMMINEl801twELNOJ4cXL4ausIOmtDaQa3Mi9UPCWAT91DMpGUqUqlDxLvDjom9nWvvGAey07qrclJ0vr+DvWm2cA1fQNzlrRI51w0ez1hmhtJOMloiE2I4bIUlklToNbYiOIOEq6pGIdUS5wQO38P5VWExELQlcg9j6bg/b6av54o2CDBxb41gNMRQjB0DpwZRFkmIyDIjXVcwpBBrcYUheM4zjOM4xnGcfHHVTI9a+RDMQCImIPmFPwp/fnNXvz5D/tWO/iumR6ivehP8i/1T8KPnNXvz5D/tWO/iumR6inQn+Rf6p+FHzmr358h/2rHfxXTI9RToT/ACL/AFT8KPnNXvz5D/tWO/iumR6inQn+Rf6p+FHzmr358h/2rHfxXTI9RToT/Iv9U/Cj5zV78+Q/7Vjv4rpkeop0J/kX+qfhR85q9+fIf9qx38V0yPUU6E/yL/VPwr8/OSu/nyI/a7DOf8u+Xf0fH6Po6ZHqKdCf5F/qn4Ul7jtnWlAgz2O33atwcQ3WIPuXcyy8x3Jc5wBmzbBOor56vOFeQIkLWrCc58vlSpWJNnaXWoXEdpY273d1LnljjBZjjucDsB3JOAo3JA3q4aZoesa1drY6Xps19dOC3JHGzEKPymbAwqrkZZsKMjfJFRbkOe3FSTtBNevrGaac+gGVMrNdVM1zysvbyjIuJHBStnL1L8AcAEL1HCXTdGUITnA15zU+GXGy2xuW0V1XlEgXnj6hiIysoUNkRufZVjjmOCPZIY55/c7x6LBdRbSljjZ+TptKi3HNkj2oGxKo2zl1XC7nal7JKtOxJPF51hyegq7T5hrBFi4XFVg54TRUe0dYkQuflabblA4dOXyFuwHAF03WxCBWBZGVJMFljkgkeGeMwzRnDI4KspHcMpwQR6Gte3ul6jp11NZX1lJbXUBwyMhBHv7YKnurKSrDdSQc1khxG1mryNfo5GU6SWOZWWYj31Kg2sS8gnCq+hTRiBpZ1FYyTcUXMKAX1l4KufXg3bAR5xTyPUVF6E/yL/VPwr5w1WvkM/OVvyFqg4l0eZduYVpQKezGp5NPZmUO/E7FPebEhiRl8KUYiSKcJi23ucFMp2ZyyPUU6E/yL/VPwr4MK3tpm7EsnKSvu2GMYEVo51/UyucNhSTl83QF+uzdsvMNXWWhHBAryYDVuTIkORlMdkeop0J/kX+qfhUffErlG+eAW34x7ZomwTo2OqgPn7JTBnmVfN9ta8y8fBimz03s0kWMpfSQpaRYVnGFZSnv0yPWvGilUFmjZVHmVIH8q84feWstpS24djyUTr7YElGPbS7OwkI2rWV2wdt1NmaUmaOmjJQzgypKsYUhWU905xjPwz1aJopTLIRGxBJ8j8K/RTw/414Is+BeD7S84u0q0u7bTbRJYpb+zjkjdYVDJIjyhldTkMrAEHYimq/BFuL/AAw2b/s62/8AH9U+jL8k31T8Ky78PvD/APTbR/3lY/1qPwRbi/ww2b/s62/8f06MvyTfVPwp+H3h/wDpto/7ysf61H4Itxf4YbN/2dbf+P6dGX5Jvqn4U/D7w/8A020f95WP9aj8EW4v8MNm/wCzrb/x/Toy/JN9U/Cn4feH/wCm2j/vKx/rUfgi3F/hhs3/AGdbf+P6dGX5Jvqn4U/D7w//AE20f95WP9as/VtWbGZT8c4suotlyUEkhEyTRVMvK1KCsBUoIJDBLYizINkWU4wZKfpyrCsY8ufGhmxtE2f1T8KoXXHnAz28i23HOjxznHKfvlYd8jY80jDBHf2T7sU5zzWsWmRh5JhpTe6xKTJmsEEerXPEKIvzafhi2kMogVvMhVaVR5iLO6X6IELH5XCM57fAhusEGM+48p9fo9PdVrTjrh4xzRyce6CCOURuNQsOc/jVLFx1AmRFzAAIOZsH2TXZXqmrod+qLU/JI4SM1LUAtRsrds2lTicjUNIkMiFcQwSqZlEnLhLgmEnEYucYbrUEN1vmIjHzT9s/wr4HHuiFQG444eUgjcajZElQR6ygK7DIPs8o9lgPygHG0frm0RtquDdvWL3XdZSr6ntno7rUpXFxlYxvHy5JloxISPH6bJLhy9GZQyB9yF+EeBDcoFke8PBfS7KefXLziLiDS9B0MG1t7mG8lRL69hbrzzxWccjxhYQkSx3EpJExmW3UxyiN66C8HeOvCZdO1i74g8Q+GLDXrYO0bza7ptqoREEsYgWa8iMzl0BWNBIesiBmUECR04NrJSp5XWotEWGqRUfIlXC3XM/sFjR5GOhDhS8JiimAZuNxJwjY6GoDESkZjIx6yTYQtW79A1Hwkt7TUeHNI0/TtHS1il+57o6iLKzeKEBXVbX7pZee5hUiCB3JEnIQQ4GbfceO3A2p8SWs83EfDmjalayqh1heIba6M6rIoZ+kwfp9WIOBzOkahsNIj8pLG7ao1psmwoJzZKHtCdgW8TLN381VqzOvbMQOJN1mtx8m6aQombnAmHmIlYckMjDsYnShqQpHXOHilc2N1qOkR6bJHqF0tvNLczoyTyAy3B+5oZrm3UWspSBDKkcTyyWyy9G5ZJfZM7xo468KYLfQY+GOPOELvUAHMklnr9jegrIkUjLcNHcOkfJM0nSQHKlpVGVVSE4z1pXjgIiV0xvtmcVmlnjYsTTLopB6x8uPFwkQ6S8KTOXOYD2SHC8eXODZzlJsKwRZNXGG6HaMnb809/8A1XP78daCrAxceaC6mJVYPqNhkS8g53HK4GOpzFRvkdxjAHwJqmHbTjEmNQb6c19/W3K5NA61b3MjFz7qUGhuqFEVkFPYMUA5EAfEInzu0CO4wpCTY96N0R/hEHP5p7e/b+X7K9HHugPBIPw50FLmOUcn/cLEK8YQ56h6zd3IBZANlJVcHlr7D1TUMj9M2o+TiFJfRasGBX7CQxWGcP8AE1guTV/CBmR5YvLVCA49T1nHqmRkYsrdG6+TJ/4mvluPdGzleOeHDlW2OoWYAYcvJjFxkg+1zktthcKctjs8a9c7Agd+VGVk6NsCIrjRzbe0pYaxPxjUDM9WsbaNzIuHTbAG7gmTNEZxleU5ObCEKVnKc5l20cizIWjKgZycEDsawvxm4v4S1Twx4isdO4o0zUNSnFlywW17azSOy39o8nTjjkMjBVV3OF2RSxwAcf/Z">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/tbcoffee">
<img alt="" src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/7QAsUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQAB/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1QYWNrYXJkIENvbXBhbnkAAGRlc2MAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAAAAAAAAAAAAAABYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9kZXNjAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRlc2MAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAACxSZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2aWV3AAAAAAATpP4AFF8uABDPFAAD7cwABBMLAANcngAAAAFYWVogAAAAAABMCVYAUAAAAFcf521lYXMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAKPAAAAAnNpZyAAAAAAQ1JUIGN1cnYAAAAAAAAEAAAAAAUACgAPABQAGQAeACMAKAAtADIANwA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCGAIsAkACVAJoAnwCkAKkArgCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEBAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGhAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJxAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNyA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSoBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYWBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/B9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmkCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvIC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4uDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDXEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPFE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6Fx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3Gp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5AHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJVIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3JugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitpK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBsMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXCNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtrO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFqQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fASAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5uTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1VcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzWXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSUZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yvbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUodYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4BfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7h5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDWkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrVm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4pammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AAsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsuu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbDx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv77IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf///9sAQwABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgEBAgEBAQICAgICAgICAgECAgICAgICAgIC/9sAQwEBAQEBAQEBAQEBAgEBAQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC/8AAEQgAmAB/AwERAAIRAQMRAf/EAB8AAAIBAwUBAAAAAAAAAAAAAAAIBwUGCQECAwQKC//EAEYQAAAGAQMBBAYEDAQFBQAAAAECAwQFBgcACBEhCRITMRQiOEFRtxVhgYcWFxgjMlhxeJGXodZCsdHhCiUmM1I3Q0dlwf/EAB0BAQABBQEBAQAAAAAAAAAAAAABAgMEBQYIBwn/xABCEQABAwIDBQQHBAgFBQAAAAABAAIDBBEFEiEGMUFRYQcTkfAiQnGBobHBFBUy4RYjQ1KS0dPxCDNWlaJFYnKCsv/aAAwDAQACEQMRAD8A9g22LbFtrn9tm3qdndvWDpqcmsHYmlpmZlsTUKSlZaVkqFAPJGTk5F5AHWfyC7tZZVZZU51FVFTHOYxjCIkV0Zj2UbdLhifJNXquAcMVy0T9FtUVWp+uYvo8HOQtheQr1OEk4uWjIJNdi8RlBaHIokoQ4d3gDBzrUY/SVVfgmL0dFUSUlZU00zIZYXujljldG4RvY9hDmua/KQWkHktvgFXTUGN4RW1tPHV0dLUwvmiljbJHJE2RpkY9jwWua5mYEOBHReKqGj5iamIuvpKGQlpORaRBUnKyyKSEk5cEZmRcGKUxkiEdGMU4gURL3B6Dxxr894NstvKiohpW7YYo2aZzWWOI1gAeTlsf1ptZ2h00sv0JqNjNg6eCaqdsfhboImGS4w6jJLAM1x+qANxqNQDzU+nwY+kKmEzAPphxLtYtg7cNgdRkjXJFy+YIygCzsgKsyRaPoAOlUk1SOVHAFKUhiqFOUemOK7cS0IqKbbPGHTsY0kfeNQ+J5e0P9Gbv4wwZQ5wDg4uGgIIIXMDC9hoq37PU7GYO2B73gH7up2TMa1xZ6UPcSF5zZWlzSxrTckEEKPX2JclRkVKTUhFizYQ6ai78601Ggqk3ROzIo5BEj4wnb96RYgUwf9wXJfDA/rCXVSY52lwwTVEu1OKRxwXLr4nU3AGUE27/AFHpssRvzC19bbWLA+zSeeCnh2WwuSWoIDbYXT2JIcQ25p9/oOuOFjmtpeL/AEtXjn0o/HQRHxx6c+XPr9Pt1p/0623/ANZYr/uNX/WW5/QPYn/RuFf7dSf0Vod05KmociyyhipnOmQqpzeIcpBMQhQ73rCYwAAfHnT9Ottxc/pjipIB/wCo1f8AW4lBsJsQXAHY7CgL6n7upNOf7Hgva1gXZht4rWFMTwNuwFhqx2yLx1TmtonbLi6kTc7LWMIFipOPpSVk4JVw+dnk1HQmOqoY48AAmHjX6FbM01VSbPYJTV1RJV10NJTtmkme6SR8vdNMjnveXOc4vLrlxJX56bTVNLWbRY5U0FPFSUM1XUOhihY2OKOLvXCNrGMDWtaGBtg0AdFLX5Jm1b9Wfb9/JrHP9t63i0aPyTNq36s+37+TWOf7b0RH5Jm1b9Wfb9/JrHP9t6Ij8kzat+rPt+/k1jn+29ER+SZtW/Vn2/fyaxz/AG3oiPyTNq36s+37+TWOf7b0RH5Jm1b9Wfb9/JrHP9t6Ikd7SHbzgGjbLszWmk4Nw9TrPF/i7+jLHVsZ0uvT0d6blaixz30CXiYRFw08aPdu0FfDUL4iLpRI/JDmKJE8W0z2Vts/7v2GvlzW9ETACHIfHyEA546gPIdf2hqD4oF5V8+9kzusl84Zam8W0qpvcdzuQrRYKW5cZCrsO6CCsEmtNt260e7MVVmogtIOG/dMADw0AxfVMGvF20/YhtpPtFjdTg2HwSYXU1U0tO41UUZ7uV5kALHWLcpeW2PAX3EL2rsx24bEwbOYHT41iE8eLU1LDFUBtLLI3vImCMkPb6Lg8MD7j94g6gqgVXs0O0Np8XKQ0RQsfmjZpYy0ozkMlVd62e8MBYIpOWx3QJrIpFHxEgEvJFg73e44LrEo+yHtSoYZqeDDaUw1Bu9rqyFwd6OUAgusQ38TRbR2vRZNb2u9ldfNDUT4nVianFmObRzNLfSzEggXBdudrq3Tqrqddnjv3WM29GwPghokgwFodEbjU3SR3B+PFkESqOi+irCIGEhA7xExXW7ofnjBrMf2V9pbsmTZvDWBrctvtEDgSd7hdwynkBoLut+IrCZ2p9mTc+baXE5C52a/2edptwaSGm43XOhNm3/CF1lOzq39H7okwTt8QMTwe4olO0kyifhIrJG8MV3RwJ4hlhUUHjkyiSYgJQIBdUnsp7TCQRs3hbSLWtLT3FgRpdx33ueZA3Wsrje1bsxFwdpMVIN7juqixuQdbNG61hyBO+6pNK7J3eDK5bpUzkGgUCEpy9/qMjdVYS81YWrGtM5yLcWBSPgY83KhjRrV0IIIgHfUXN3ClA3AWcO7Edu5scw+oxTDKWnoHVUD6gx1MFmwtkYZS2Jm+7Gu9Ftrkm1lexHtu2CgwLEafC8TqqmvbSzspxLTTAumdG8RB8rt1nlvpO3AC+5erwocBx8BHj6g5HgA+oA4/hr2zay8SLXREaIjREaIjREaIjRFj97Uv2Ec6fdj848e6ImB2meyttn/AHfsNfLmt6ImB0RGiI0RGiI0RGiI0RGiI0RGiI0RGiI0RGiLH72pfsI50+7H5x490RMDtM9lbbP+79hr5c1vREwOiI0RGiI0RGiI0RGiI0RGiI0RGiI0RGiI0RY/e1L9hHOn3Y/OPHuiJgdpnsrbZ/3fsNfLmt6ImB0RGiI0RGiI0RGiI0RGiI0RGiI0RGiI0RGiLH72pfsI50+7H5x490RMDtM9lbbP+79hr5c1vRFKl9vlOxdSLfknIdkiKdQ6DWZy5XO2T7tNhCVqrVqNczE9Oy71Ue61jmkY0crLKD+iRERABHgBIlyxxvLx5kO0Y0qi9IzVj15muJnp/Dj3JuK5ypRmRIauQRbTILM3BlnB6hMjWDlkEYSzpQVgXaJOFkokxWT70UivnMm5fFuFaAxyDOzKU9HzmSsf4bq7CrPoaSd2TKWT7xDY7ptMZvXEoiwYP17ROsk3Kz122bR6Ca7p6qkiicdEUa4P3oVTN0vc2bbHGQaBB40m7Fj7JlzyBK4kY1eg5tqClLStGEpt3X8nyKz25Nj3dkVJ/HIvq49UhpFJpNKKItyuyJrZO01uFcEaS89DRbtSOkZdNrISbFk5UiohEXMrJJtnK5VFWLZABO4VKUU0ShyoYoaIlTw1vdxlm53ilStUvNMPUs9QUlacG5HteL5aKx9lKtMoBW3MpiGsLR26GtBJ09FWWh2ljQg5GWj0VXLFmsVBcEiJrmNmrsm2dPI6dhn7Ri8eR71yylGDpu0fxwcyDJ0u3cGI3doB1WSOJVEg6qFLois2vZhoNon7xXYiUfHcY9Qqzqwyz6vWGIqCzS419W0Qrus3mWjEYa6tPoZFRR2rDvnycccPAfmbLiCYkRI5mxhFWnGtMd3SD/CTMDeyPMbRrZ4k+PbmFRh0p6xSMSsyMom4jm0Y5aHO4A/giZ4ikU4qrJkMRSdoiNERoiNERoix+9qX7COdPux+cePdETA7TPZW2z/u/Ya+XNb0RR9v/wBr73efsy3HbX4q0I0uazLi+dqVetDxFy6i4eyiZrLVtzPM2Ygs+rQz0XHJybdIfFXj13SSfJzlASJedw0FvN3Z7Vso4MisLxm2bLF+2/5Yqr3KFiytUbDXKnlCxY4nqlBJYYlcbupCddQj2dl10FbFKx9XkYuvSDhdKJcSygRyJEk2WNjWc73kGOyFj/axWsXYzTvvZPKL7dS3DDpEE5DZ1uDuOVc1Zd7kVMqwRBRxDMVmgwJEXIzFiawgFlG0bGMo8BIqPEdn5uPRzW9yDYMWyAYeV37778tWnEtKvGGxn7vj7c1i6kUrEOYG8RaJA1bmLBXDVq9xr6Bml2r1pHZbdyEU6dPGp2a5FfWOeziyTRsk3hCSqGQp+spSWzm97T7Q8z3E2VvgA23HEteo0JinLFimnTW52GKr91g7PMqBXVnsXeY3KEpCzZm5VHq7siiWe7NLcBI0+MgNn2Orz2ZWSr1j3OMLuFNj3dRMW/ZU/e5GwTkWrMojD+32MvkihCywZptVQl4uwRtOoj+sMoB88QVkHgoRj8ik++bCZm80HZuEJsTr1KtWOs17C5XPtekchYmla07oO2mv5JgrilVYFO3Lw8/GIx97fM2r0UI2ct0dJJsrCxbNYlggQiV3dLtbi9ue5amyq+3LHFWwJkftXOzvPtzx3W1cN1+Es8fSNp2TMVZDiavQQl2cZTHCkvDNlkmT4WKEo2TaeOdFc3hJETJ4M2UZpx/uqxHnRxhyqBUa3uM36ZEbbfIG6YueW3azi7dZU8Ix+IWq8evPpw8ewfZAwvke2zLGsP36MVKZVckhyzItnzgCL0Fmk48j9CKO9aElHTN5INY07hEr9ywj12TV8+bsxP4izNFxIxyaqpSiRM79AhzFMqmBiLnO5QSURSUWTTVcGORBM5ykUWMmmZVQqKZhAVRKkUxjd0B4KUTDwAc6IuJtIsHq8g1ZvWjpzFOU2Uo3buUVnEa8WZNJJJo/RTOJmTk0e/ZLlTVApzIvElQKKahDGIu5oiNEWP3tS/YRzp92Pzjx7oiYHaZ7K22f937DXy5reiJgdERoiNERoiNERoiNEVEmK3XrCLMZ6Dh5kY5f0pgMtFsJIWLn1B9IZi9bqeir8pp+un3Tfmy9egaIsUmbB2XxuasjjknJWUmU/aIVqN1sdfs/0jW3Mt9O5KpkVAqtYOJcKwlwp6Dh2zj1fBbLxLeXjlG6yz1aScnIonvMh2fjCXezS1rzY/CPlp6PvasfMzNeh6hW7BMzkU5cWKLfxbRRpQIq3wTxlFNY9sZhFP2UUi2TQapQJyEVTsKGwCtWdytMWPPlbbMEXS548kbamMEyb1xyeRmYJk3TrAvnkSozYSDORKmqszVZo/QyqvdUZsxIsm+2jFlDxhjhFXHqlvUhMirxGR1AvMihKWRJeYpdTh2beSeoogZd2nB1+HIuddZ24UclXWWeOFFTKCRMJoiNEWP3tS/YRzp92Pzjx7oiYHaZ7K22f937DXy5reiJgdERoiNERoiNERoiNEWg88Dx1HgeA+I/boiQi1H3hJZNsCtUxRje0Y/kLTeCt0L88p0YlFRrSv0dGhWWDVryqsjPOpJ/DX9tMhKGbrs0bBAmapLJsH6ChFRpGW3sqWCClGe3XC7GMYST9J2mlZIB9LPY5xUmf0NJu13LtI8UZpJPXce4ZMXK6hRhPGReO2LgjcCK2Ied3l2VhT8gvdoeCgk65Cmk6hBy0+auW6IPa2DZGwwjNWWcH/AhcWibZqqos1Os4Sais4YMlf8AlwETCY8sG7VxdatE3/G2Mq1j4HMqaalapKmeumUS0r82jBRSLB1ZTGZuVZ0II51UGzlJFuko28MPFFy3Im00RGiLH72pfsI50+7H5x490RMDtM9lbbP+79hr5c1vREwOiI0RGiI0RGiI0RGiI0RGiI0RGiI0RGiI0RY/e1L9hHOn3Y/OPHuiKq7aMoOY3bTt4YIsym9CwXiNoBzCYO94GP68lz1Hj/Dz01jvqGtJFrkEjwWS2nDmguktmtayldbMkol3h9HQ4Dkeoj5fZ5asmsAOoAVwUYOozaewfBdEM+nbmD0xgYSf4jInARD9pR468e/VIxKIHUefPJDQE2DCb8FftdzTVZsU0fTSt3BuA8Fz+aMJh9xTG47w6yIqunlNg/KeXn+asSU00fq5h5/kpVaSjR4UBSVIYDcCAgYDFEB8hAQ1lZbi7TmCsXItfQqpapUo0RGiI0RGiI0RGiI0RGiI0RY/e1L9hHOn3Y/OPHuiKGsByB08A4MTAQ4LhvF5fMQH1aNBB9vw1z1TORNM0G2Vx+fP4rd00Q7uN3GwN+Wg+ivt9In7p+eeft+vWvdM43sdTx86rNEI4el8vzUXz80on3wA488D5DwHxAPrH3a181TkBsbkcPqslkFw2+l+Cj1ndDtn5UVxN1MHBgN+jyPv69fs/jrCjxOz7Hz+SyJaE5SQLka2+fkJuMbZIkmRUBI8Udsx7ombrHE/dDpyBTCPJB8vf+zXVYfiTiGguzNPw+q52qoxfRtnDpa/PpccdE7VbsjWZYIOSKlMVQAIbnodJUA5FJQvPQeA5AfIQAfIQENdGx4mbmbqT53c1qHAscWnQD5efNlc6oh4YmAenQeQ94c/Vqocuag8La+SqOLpcDD3RHgB8uB+znV0tHJQLAb7X86KqN1hUJ64gBg4+Ac/166tuFj0QHUhdnVKqRoiNERoiNERoix+9qX7COdPux+cePdESc4MyeVlg7EZJLE+cTxcXjCgR6tux9VqznWsGIwqEO3M+kY/EFuf2OqCfwxOdnIQAO2giZFwXxUz6t1Gzkk7Wzw1kQfOM2STNGbuF7AuDQfaCQRqCsmnxlsJEU1K8MjOXM2zrgcbAm3OxtyKuphnbDFpkjwdYy7i99YQVKipUp+3I43vaSpuQBBWjZYawMp6V3gEPDI2UERAQARHXI4ngm1lIHGHCW1MQ9aOQO09hyjUcAV0dFiez1TZsmIOppDva9hHiRmO/iQF1rmZ/Co+PYYWWgWqwCLd/IRr9CLcFDqBkZYzb0VYggPICRcxR55ARDXz6vxDFqNxFbhb6cDfmZI0fxWLfiuvpMNoquzqPEI6g8A17Cf4cwd03KA3y6TlYHsS9bOipmA4GbOUlyj5iIAZE5g9w+/36033zHI4OB7v3gj4arYOwmaNpDmXv0sR4ppMUuVnjNBUAFNQoACiRgEPW446FH3c/Zru8HqBPE17HaEa6ri8TpzFK9jhYk3+d/cnUoD5Vm5SRU5BB0AJH4HoB+QEhw+Bim48/iGu5oJyMlz+L5rlquIG5Glky8asK7bunHk5OSH4/wDIg90RAB+PHP263TraO5+Stdxtw3689/t8VwnEoGEBD38ByHQOR48x1dGoCpINzlOi2iUwdSGEo8iP1f5alA4esLoIu4KYC9R68f6jyGrZbr+HTmq9LF1+qqyZzmAO8UfIPWAOnP8Ap/pqjS5sdEBPL8vFc2oVSNERoiNEWP3tS/YRzp92Pzjx7oi+enkOHuOIsrWe643ynl/HU3OWJ3PqPcPZheIu2q0gYj0VpCl2dk2bth8dUwmSayPhc8giAJ8cfMavtVdguK1mG1Mju7ppZIwMpc0Bjy0Xyk20HFvwX2fDOyyqxjBaDEaQMk+1QxSEFwa4l7A42zgA2J4OHRNBTu1A3vs4dOrXbcJi/cFWEyJJ/gpvXwS2mUV26YAUGprW4iZpiHeAADxRdJgHAH7wca6LDu1bBajKHPiDifUf3bifYDG7/iVoMT7LcapMzpMOlDRfUNLm+4jvGnxCbPEfaFTMCcslK7EbXTGhkTmf3vs3NyltrMec4qCcXjnF9fs0pX3SIF7xhQdQXcEw8GTKUR466n2uwKvaQ+awfuDwyQfEMdbh+JcZU7KV9IbsDmOb0c09NRcDwTM1btO9qFpkys5DdO4xxaU1eFqhv72bwyb4x+pQbHzJt0eU6a7wHACi4csnqph9YxD86oq9ndjsa1koKSVx1D2/qZL9LgdN0iQ121eGDLBXT5B6pd3jbcrG4/4rJhibdo+fRibioYowjuHiygVQkps83cUyfsCzfwAV8VDEm4tjWpcywJCAi1Rm3agAIAUxxAR1gjYXD6O78OfLA3lfvGewkF+nvHBUTbSYnMbV8DZHDjlyO19zR8Dqp6wl2jO1e+XK9US0WeW283XH1xTpEhT9zTJhh+yPrI1goianG8YEhKuYx22jnEu3YrLpyqhFXbdcqRe4kBjQMLqYCC0d9HcajTpcakEdQd99N5WGa+nlaWv/AFbyL2P14jnqsr1Un4acahKQcxFz0O8MCzSVg5FnLxjpI6KYgqhIRq6qKyYj3uBKcQ89bbK7Ja1i07j+axLggm9zx8emiu4E26o94pyjz8BAf8h1Rdw0UkA63st/oxOOOR/h/vqMx33VWUWFgFs9HEhgN+kACAj18g56/wBP89TmLvR5qm2W5tY+K7YDyHIe/VBFtCqwQRpuWuilGiI0RGiLH72pfsI50+7H5x490RfNeyxlVlG5ZyaweEXWWZ3acZFTKAqCoRq6FBMAMI+qAETKAB5AAcB0DXmXaXCxLjmNPyhwfUzk36yOJ1XsDY/FRDs3gMZuMlHTjcDuiarlxkt+Fb5N0lHOGjZQSicqipgAxRHz7peAAoh/T6tfNMb7ujY4BwuBoN+vtX0zCnvqcrwwsDuZ/l58VkZo9LogJNnD+tRBn6ZSiSSRSNHyqZwAODJS0YdB0icBHoJVgEB4188btBitHJnpK+amI1AZI4DwuWnwsuikwLC8QYWVtBDUgjXvImuJ99r/AB0TColaPGP0W6nZCchTkBNSu5FYVvL1cEgBx4Ax+SoeRcIpCXp+ZeomAB9USjwOulw3tb2ywtzbVzauEerNGCf4mFh95BXK4l2SbG4i0k0L6SX96GQge3K7MPjZWWptc2sWNwZ3MYOgqu+VMJj2vbtfblgmyJlHgFVS1xV1OV9wt3BMIFBs0IJh49UBHX0PDP8AEXVUoBxTCnsDf2lLOPeckmU9bd59F8/xLsDDyfunGg4G9mVUJOnAZ4y4a9WD2JssU9k3nOYxpVJehboskQ1gyPNWdVWtyD2OzDV5WLez89IQEtYYpNg1WjDJ09xBFmnItZJsi/XUAqokUTKX03gO2tVj7aeswyR76OtjjkZnyvBaWNJL2Wdl9InW5BPG5XmzGtmoMEkqaHFYInVFG+Rjy0OYc2d1gx92l+m5pbe3Cyra2xvtP9ss4xn65R6Jb2caY/emMCWay4On5ciYABFZNKlPI5q7fAQgcGXYLCY5jHU8QTCGu5ixd5ZkrMMZKHeswkHwNx8LcFyjsPw9xzU1Y+nP7r7Ob42Dh4q78n9q9vL2q4NyfdbbC7jaxfMe1Z5YYGqZ2xpR8r4xtLiNOzaoV42WINlATcK8fPXSCLZRQsicVHgd4DFTMcD6jCpWkwh0UgBORzXN3dblpA5eiTwCoNDUxguMkdRE3eWnXX/tIDr+y9uOibzYv/xC9JzRUasXc7jdtjO62VFnJtpHG8keQpS0RNnIrEgjEZFeRc05fNkFQSkDR6cmj46JjNRVREpzQaASxiWCeN5de7A+7m9HaCxPAEe9WnCRjvSie1ptZ2Ulp0ubHjbcdd69G1TuVXvEFHWaqTTGbhJZog9YvmSvfIog5TBVIVEzAB26vcHqmoUhyiAgYoCGtc5jmOLXtyuG9Tcb+CrnjesPcABLz5fEf/zQk6XCpAGpDlzgco8AI90R9w9B1BFvepDrrfqFUjREaIsfval+wjnT7sfnHj3RF803I9bhnOcslOHfhCB77PrKAYA6qGfHMbkB8x5H+mvK+1lZUNxrHWNJs2qqAB07130C9lbE0NO/Z3Z+Rw9J1HTE+0xNN02ONQqsa0RIkZAg91PkCiTpwHQePd118XxkVs0ji4Et18+xfX6BkDGWYQPPTomTi5KNUAvhOUwKUoAUO+HQPIOQ58+eOemuUlhd6zSPgtyyUN3EXO7+6vJm/XKX80uAgHdMHdOHl7+vx4ENYL4yA4WsBbosmOcG2befDz9U0G27CGWdxl6a0jHECtJOBOitMyzjxW1cq0WY5QPL2aWKmYseyAO93EwAzl0YASaoqnHgL+z+xm0W3OLDBdn6MzPdbvZXXbT00ZNjLUSAEMaPVaLySH0Y2uJ01G1G2mAbFYQ7FcZqxE2xEUTbOmqJLXEUMZIL3bruuI4wc0j2hewXAGF4jA+MKrj+PeGnX0JEtmUnZ3TYjd7MPygU7pZJEDGGPjvGDhu2A49xMhRUE6veOP6ObFbLQbHbO4VgMU5q30MMcck7m5XTSMFi7KCcjODGXOUWuSbk/nbtbtLUbWY7iWNzxilFZI+RkDSXNiY43a3MQM7rWL32GZ24BtgJnaEJ44gYRApjCPQRDkOQEA8/LXYlzsnojW65wXsL71yT9HpVtj3EVZqxW7JFvCeG7jZ+Dippg7TH/wBt0xkmiibgnUehyGDryHA8DrGLiRYhGkgh7XlpHEG3grQTwDg5OGia4GHsWmr8CxRi4SEUx9UloqIjW/HgR8axXiDJsmROA7iaZQKXjoAapAaCCGgOHHj4qvPLcnvXa79TrffdSBB1et1lkEdXICFgGAG7/oUHFMIhp3wL3QP6LHN0k+93enPd546aqLnHUuJJ6qggHeq0VMhB5KUAH/L9nOqbk7zdAAFuEpREBEAEQ8tEsFropRoiNEWP3tS/YRzp92Pzjx7oi+bHlCm2l1mPJKww041QdXSdcM114eTQQctV3Iqt3LVdZqUrhuomYhk1ExMQ5TAYphAQEfKm1k8MWPY3mcL/AGqovz/zXfX+69l7Dskl2cwEt0Ao6cc/2LfcFcdZxdlSSUSb1uAtk27UEpUm0JXp2YcGMbj1CN4xiqYwiIhwAAP26441NLUuyRwmZx0s1rnnXhZoPke1d9mfSM7yWobCwcXvaweLnD3626p4sQdnv2lOU3DYKVtuyUzinBycWbIrRtiyropmEA9IXl7+7YCdEAHvD4CK5xAB7qZhHjW5o9gsVxloMGAztjf68sfcxj/3m7seFyudxHtG2bwYFtVtDTPkb+zhkFRIbcAyDvD45RzKz1bSew0t7Q8dYN3GbmTshBTXXxlhD0tVE4gHeFlNZRsDFEPD5DhQIqM5EOfDfl6G12mFdgdDUSMmx+syQt1MFKTc9HTuGg590y/KQL5ntB2/zd3JBszhdpDuqasCw6spmONzy72S3OMr0X4lxNjbC1RZUjFdMhKRWGRgUJGw6BgUduRIBDyMtIuDnczMocv/AHHLpVVcwdO+BeAD7zgeA4Ps3QxYZgeHR4dRRm+SNti53F73m75Hm2r5HOeRpewsvO2O45i+0Fc/EcaxCTEqyTTPI6+Vu8MjaAGxsHBjGtaN9r3KlEeADkBHkAER+ofdx089bw+iNwt5stQTcXvy8+xWy6nEGzhRMxgKYhhLyA+8Pt6e/V+OxYDbU/z5KXEiwO4rst7ImbjurB+zvfEegfUGpdGDvCgOHv8APke1V9rNkOJTGV4AR45MIcDx+kACI8c8f76tOiHAefPRLbraHz7/AJpOLDuA3L0675IZEwmhlWqwNodxVPZ0yBulRm5ODbYVe5g+mErPKqTMVaHB5ZitTUCJpRDdeyrtUju2xnAskrBFlWDuB4roSm7bcLCw8pJP9k+RHjmONJA1j63anVgPPAhDQNgivoQ6GPU1Tg6i58QMLpu1K2eVmZi1BPJt2DWTiykm3Bbsq7ktzVFudPaVvbe7vNcksaU+4WiKrbW7ykpH2KYfXolmrMRdFK41j1XkZHQlXVO3exzN6P0wbutl1F2rcIUrlPu8zOY8m9bbQ8jqwEdbpOuJODLXdCySkVHRljmU7XGVVfEBRVinbKEYIsyqvETHkbC1YrGQ5MuE26qL79NQrUhd6OfkYKDb2PZtlF5cVYqMNNKwURfmFR+lZGswU4io3cyWOXDqPZ+myUkweIGB4vGv4sUDKPERM7LCXPJN1gbKdpy3T3diuGLbLiOYZzRoo1as5ZP0pw3GCgJpKTaKy1ei1V2vfm1mahvRQIR5DO0iqKeGI6KR7LJau1L9hHOn3Y/OPHuiJdMBKWf8RmFAC2SijUuJMaA3ZOm8Y8QaN/wKg/CatvSWJzJoJp8FIHI8FIAddYbwXF2YNcATvZG62vNzSfFZMbi0DLcXHBzx8nAJiIV/PonKUJ6RKU3Aj6KdKP7weQ94GKSYcfDURucz8BDDza1rfZ+EBS52f8bQ/wD8i53/ANEqTYooLKlWcHVcrCIAKzpVRyp18+TrGMIjzrIaC83eS8jmSfmqdws0BoPIADwCk5gPqlKUOOgce7p19+rqjmFdrUA7odQ5H3fZx0Hjr/v8dVNFz0WNJckkN0C5XKxUUVFDf4Cibj6wABAPPVV82g3efmrQ1sOahZ+qZVZU4iIGOYxhH38mMYfd5ef9NZjBlDQBu4K9KLAdPP1VK8RdM3JDmDgOeo+/y6ddXhbx5blYUF3DGN5n7dL22sbg8sY0WmUK4wcQ1X+gpSBbRsA1KmslFxNnbOm0ZJPXPjrO3yCBFzisCYgYEyHGksvuOikOI6qDcjZGfYMl2zC8bzN0kg/XSjLAMBXsPU62j9CKtXEX4YTEVj8rZEDSkTKySqCjs786TczVu3Oh3CLY74t9hr55BVBxOpO5XNWc/VOGelt0duT3GTNWrmLa3HWuKncNT0wwRsjiLqON4rIDtnOwZ5OZekkiP5mWaxCzpsuuk+V7yy5e8piZTcC2qrLrK0lswRMDN1CjMd5G7yabWum1Wfql5j8N1ez1J3CT5nbyDWdWAtMO5UlV0IJdiBnRPEEs61eOTKlWTkAHna1kBvrw8+fgqtHZbjbzG0WsxW73cwhkGHhrMlaFY/BzqFcyLC6yb+RMa3BZqo3hYuQhmdLThWjhu4K8bLBIqslVFZlBynJGm4aJfdfj5/vwVuw+ZIiOgUZNTfDuyauJB+D9rXpjbuEpNwTpwnHQgV6YKegPCOXJHDJF0CPpxyKi9dOk/GRXExYt71Nx58/ksj+1yxEtGO5CWRy5eM0IHtcizStt9oCeOZRseNi4WPewTKDJWIkXEchJNnihnJm6gmeP3aILmIgRNKFKg3tS/YRzp92Pzjx7oiSbBeesOxGHMSxEtlnGEZIxeMMfRr9hIX6qs3rF6wqMM1dsnrRzKlUaO0nCSiaqZylORRMxDgBiiAYz2G5NiRc8PPRXmkADVTYw3F4GIr3hzbiJPqHU+SqYAceXmaZ6dNW8jxwPx+inMOe5STEbldu5O6KufMLJ8gAj38pUYggPv/TnQ6eeslgIvfQJmHNSIx3SbakwKBtw2DSAH/llmgh58/Gf1cVOYG+uiuVDdZtkAAAdxuBwAOP0su4+AeAH3f8AUPnwGnNWXcbXN1S5ndhtpOkKDfcNg5QTBycxMtUEwAA+QclsHrGH4B5e8dXYsoNyQPb0/NUhuUX3lR+tuX24iIiGf8JG8x/9VaKPPPPxnvPrrKDmX1eBfqFQcx3j4Lom3J7dRHpn7CnHT/5Uov8AHj6e1X3sdrl4ueov583UZTyWwdx23Qwjxn/CYfWOVaIHPn/999Yfw071g3OBv1CWPIqtQu47bom5IJ9xmEmyYG7wh+OCioF56CI8fhEAd7oH19A+GqHytI0IJHVVBp3nRTEz3UbXRTKi53K4FOmYgkUItmTHxyGIYokMQ5VLGIGKJREBAeggPAhwIhrCJAdcefO9XDrpzVeQ3VbUGyKLdvuT29oIIJkRRRRzHjhFFJJMoETTSSSsYFTTKUpQApQAoAUAAAAADVKlak3XbWCmER3N4AEOPL8dGPB5+wbL00Rcn5WO1X9ZjAH86Mef3Loi1DdltWAOA3MbfvtzNjof6jZNESPdpDuGwDedl2ZqtSc5YeuNnlPxd/Rlcq2TKXYZ6R9CytRZF76BERM2s4d+DHtHa6vhpm8NFqoqfghDGAi//9k=">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/wbdev">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/rwdata">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/btlang">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/pg_git">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/pg_js">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/actb">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/kcdc">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/olag">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
<div class="backmatter-cover">
<a href="http://pragmaticprogrammer.com/titles/hklean">
<img alt="" src="data:image/jpg;base64,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">
</a>
</div>
</div>
<hr xmlns:str="http://exslt.org/strings" class="backmatter-end">


</div></div>
</div>


<div id="res-toc-prebuilt" sel="#f_0002\.html"></div>
<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
