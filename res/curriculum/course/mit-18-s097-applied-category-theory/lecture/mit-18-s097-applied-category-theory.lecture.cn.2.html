<!DOCTYPE html><html class="translated-ltr" style=""><!--
 Page saved with SingleFile 
 url: file:///home/zy/ws/res/res/curriculum/course/mit-18-s097-applied-category-theory/lecture/mit-18-s097-applied-category-theory.lecture.html 
 saved date: Wed Mar 26 2025 21:16:17 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/7e38133eafc509dde33a8d67622c839d44b0cf66">
<meta charset="utf-8">
    <title>mit-18-s097-applied-category-theory.lecture</title>
<style>.VIpgJd-ZVi9od-ORHb-OEVmcd{left:0;top:0;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6B90DA;margin:0;box-shadow:0 0 8px 1px #999}.VIpgJd-ZVi9od-xl07Ob-OEVmcd{z-index:10000002;border:none;position:fixed;box-shadow:0 3px 8px 2px #999}.VIpgJd-ZVi9od-SmfZ-OEVmcd{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#FFF;border-left:1px solid #D5D5D5;border-top:1px solid #9B9B9B;border-bottom:1px solid #E8E8E8;border-right:1px solid #D5D5D5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline}.goog-te-gadget .goog-te-combo{margin:4px 0}.VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-l4eHX-hSRGPd:link,.VIpgJd-ZVi9od-l4eHX-hSRGPd:visited,.VIpgJd-ZVi9od-l4eHX-hSRGPd:hover,.VIpgJd-ZVi9od-l4eHX-hSRGPd:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-TvD9Pc-hSRGPd{display:block;margin:0 10px}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd{padding-top:2px;padding-left:4px}.goog-te-combo,.VIpgJd-ZVi9od-ORHb *,.VIpgJd-ZVi9od-SmfZ *,.VIpgJd-ZVi9od-xl07Ob *,.VIpgJd-ZVi9od-vH1Gmf *,.VIpgJd-ZVi9od-l9xktf *{font-family:arial;font-size:10pt}.VIpgJd-ZVi9od-ORHb{margin:0;background-color:#E4EFFB;overflow:hidden}.VIpgJd-ZVi9od-ORHb img{border:none}.VIpgJd-ZVi9od-ORHb-bN97Pc{color:#000}.VIpgJd-ZVi9od-ORHb-bN97Pc img{vertical-align:middle}.VIpgJd-ZVi9od-ORHb-Tswv1b{color:#666;vertical-align:top;margin-top:0;font-size:7pt}.VIpgJd-ZVi9od-ORHb-KE6vqe{width:8px}.VIpgJd-ZVi9od-LgbsSe{border-color:#E7E7E7;border-style:none solid solid none;border-width:0 1px 1px 0}.VIpgJd-ZVi9od-LgbsSe div{border-color:#CCC #999 #999 #CCC;border-right:1px solid #999;border-style:solid;border-width:1px;height:20px}.VIpgJd-ZVi9od-LgbsSe button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.VIpgJd-ZVi9od-LgbsSe button:active{background:none repeat scroll 0 0#CCC}.VIpgJd-ZVi9od-SmfZ{margin:0;background-color:#FFF;white-space:nowrap}.VIpgJd-ZVi9od-SmfZ-hSRGPd{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-SmfZ-hSRGPd img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.VIpgJd-ZVi9od-SmfZ-hSRGPd span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-te-float-top .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-top-width:0}.goog-te-float-bottom .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-bottom-width:0}.VIpgJd-ZVi9od-xl07Ob-lTBxed{text-decoration:none;color:#00C;white-space:nowrap;margin-left:4px;margin-right:4px}.VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:underline}.VIpgJd-ZVi9od-xl07Ob-lTBxed img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed{color:#000}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:none}.VIpgJd-ZVi9od-xl07Ob{background-color:#FFF;text-decoration:none;border:2px solid #C3D9FF;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-xl07Ob-ibnC6b{padding:3px;text-decoration:none}.VIpgJd-ZVi9od-xl07Ob-ibnC6b,.VIpgJd-ZVi9od-xl07Ob-ibnC6b:link{color:#00C;background:#FFF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:visited{color:#551A8B}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:hover{background:#C3D9FF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:active{color:#00C}.VIpgJd-ZVi9od-vH1Gmf{background-color:#FFF;text-decoration:none;border:1px solid #6B90DA;overflow:hidden;padding:4px}.VIpgJd-ZVi9od-vH1Gmf-KrhPNb{width:16px}.VIpgJd-ZVi9od-vH1Gmf-hgDUwe{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div{padding:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b .uDEFge{display:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .uDEFge{display:auto}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .fmcmS{padding-left:4px;padding-right:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd{text-decoration:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:active div{color:#00C;background:#FFF}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:hover div{color:#FFF;background:#36C}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:hover div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:active div{color:#000;font-weight:bold}.VIpgJd-ZVi9od-l9xktf{background-color:#FFF;overflow:hidden;padding:8px;border:none;border-radius:10px}.VIpgJd-ZVi9od-l9xktf-OEVmcd{background-color:#FFF;border:1px solid #6B90DA;box-shadow:0 3px 8px 2px #999;border-radius:8px}.VIpgJd-ZVi9od-l9xktf img{border:none}.VIpgJd-ZVi9od-l9xktf-fmcmS{margin-top:6px}.VIpgJd-ZVi9od-l9xktf-VgwJlc{margin-top:6px;white-space:nowrap}.VIpgJd-ZVi9od-l9xktf-VgwJlc *{vertical-align:middle}.VIpgJd-ZVi9od-l9xktf-VgwJlc .DUGJie{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc .TdyTDe{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc span{color:#00C;text-decoration:underline;cursor:pointer;margin:0 4px}.VIpgJd-ZVi9od-l9xktf-I9GLp{margin:6px 0 0}.VIpgJd-ZVi9od-l9xktf-I9GLp form{margin:0}.VIpgJd-ZVi9od-l9xktf-I9GLp form textarea{margin-bottom:4px;width:100%}.VIpgJd-ZVi9od-l9xktf-yePe5c{margin:6px 0 4px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf{z-index:1000;position:fixed;-webkit-transition-delay:.6s;transition-delay:.6s;left:-1000px;top:-1000px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf-ti6hGc{-webkit-transition-delay:0s;transition-delay:0s;left:-14px;top:-14px}.VIpgJd-ZVi9od-aZ2wEe-OiiCO{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#FFF url(data:image/png;base64,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)50% 50%no-repeat;-webkit-transition:all .6s ease-in-out;transition:all .6s ease-in-out;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}.VIpgJd-ZVi9od-aZ2wEe-OiiCO-ti6hGc{-webkit-transform:scale(.5);transform:scale(.5);opacity:1}.VIpgJd-ZVi9od-aZ2wEe{margin:2px 0 0 2px;-webkit-animation:spinner-rotator 1.4s linear infinite;animation:spinner-rotator 1.4s linear infinite}@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}.VIpgJd-ZVi9od-aZ2wEe-Jt5cK{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285F4;-webkit-transform-origin:center;transform-origin:center;-webkit-animation:spinner-dash 1.4s ease-in-out infinite;animation:spinner-dash 1.4s ease-in-out infinite}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb html,.VIpgJd-yAWNEb-L7lbkb body,.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb h1,.VIpgJd-yAWNEb-L7lbkb h2,.VIpgJd-yAWNEb-L7lbkb h3,.VIpgJd-yAWNEb-L7lbkb h4,.VIpgJd-yAWNEb-L7lbkb h5,.VIpgJd-yAWNEb-L7lbkb h6,.VIpgJd-yAWNEb-L7lbkb p,.VIpgJd-yAWNEb-L7lbkb a,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul,.VIpgJd-yAWNEb-L7lbkb li,.VIpgJd-yAWNEb-L7lbkb table,.VIpgJd-yAWNEb-L7lbkb form,.VIpgJd-yAWNEb-L7lbkb tbody,.VIpgJd-yAWNEb-L7lbkb tr,.VIpgJd-yAWNEb-L7lbkb td{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul{list-style:none}.VIpgJd-yAWNEb-L7lbkb table{border-collapse:collapse;border-spacing:0}.VIpgJd-yAWNEb-L7lbkb caption,.VIpgJd-yAWNEb-L7lbkb th,.VIpgJd-yAWNEb-L7lbkb td{text-align:left;font-weight:normal}.VIpgJd-yAWNEb-L7lbkb input::-moz-focus-inner{border:0}div>.VIpgJd-yAWNEb-L7lbkb{padding:10px 14px}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS,.VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-r4nke{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TvD9Pc-LgbsSe{display:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-l4eHX{float:left;margin:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-PLDbbf{display:inline-block}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf{display:none;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-H9tDt{margin-top:20px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-LK5yu{float:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-qwU8Me{float:right}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-cGMI2b{min-height:15px;position:relative;height:1%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-jOfkMb-Ne3sFf{background:-webkit-linear-gradient(top,#29910d 0,#20af0e 100%);background:-webkit-gradient(linear,left top,left bottom,from(#29910d),to(#20af0e));background:linear-gradient(top,#29910d 0,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0 2px 2px #1e6609;-moz-box-shadow:inset 0 2px 2px #1e6609;-webkit-box-shadow:inset 0 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-hSRGPd{color:#15c;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}.VIpgJd-yAWNEb-L7lbkb>textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}.VIpgJd-yAWNEb-L7lbkb textarea:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);border:1px solid #4d90fe;outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-IbE0S{margin-right:10px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp{min-height:25px;vertical-align:middle;padding-top:8px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp{margin-bottom:5px;margin-bottom:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);border-radius:2px;-webkit-transition:all .218s;transition:all .218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0s;transition:all 0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe{outline:none;border:1px solid #4d90fe;z-index:4!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.gk6SMd{background-color:#eee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eee,#e0e0e0);background-image:linear-gradient(top,#eee,#e0e0e0);box-shadow:inset 0 1px 2px rgba(0,0,0,.1);border:1px solid #ccc;color:#333}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-moz-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{border-color:#3079ed}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-mrxPge{color:#999;font-family:arial,sans-serif}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-W0vJo-fmcmS{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0 5px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-u0pjoe-fmcmS{color:#800;display:none;font-size:9pt}.VIpgJd-yAWNEb-VIpgJd-fmcmS-sn54Q{background-color:#c9d7f1;box-shadow:2px 2px 4px #99a;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-xl07Ob{background:#fff;border:1px solid #ddd;box-shadow:0 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb{cursor:pointer;padding:2px 5px 5px;margin-right:0;border-style:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb:hover{background:#ddd}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb h1{font-size:100%;font-weight:bold;margin:4px 0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb strong{color:#345aad}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:right;position:absolute;right:0;left:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-j7LFlb-SIsrTd .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:left;position:absolute;left:0;right:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-fmcmS,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{color:#222}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{color:white;position:absolute!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#c9d7f1;border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-DyVDA{background-color:transparent;border:1px solid #4d90fe;border-radius:0;-webkit-border-radius:0;-moz-border-radius:0;margin:-2px;padding:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-LzX3ef{border-left:2px solid red;margin-left:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-YIAiIb{border-right:2px solid red;margin-right:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf{padding:2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);outline:none;border:1px solid #4d90fe}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-sFeBqf{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-SIsrTd{position:absolute;top:10px;right:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c,.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd .VIpgJd-yAWNEb-hvhgNd-IuizWc{text-align:right;margin:0 36px 0 0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-UTujCb{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 .VIpgJd-yAWNEb-SIsrTd{left:5px;right:auto}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}sentinel{}</style><meta name="referrer" content="no-referrer"><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>

<body>
    <div id="book-container">
        <h1 id="applied-category-theory.-chapter-1-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 1 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 1, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 15 日) — 50:45 </font></font><a href="https://youtube.com/watch?v=UusLtx9fIjs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=UusLtx9fIjs</font></font></a></p><p> 6
            years ago (Jan 15, 2019) — 50:45 <a href="https://youtube.com/watch?v=UusLtx9fIjs">https://youtube.com/watch?v=UusLtx9fIjs</a></p>
        <h2 id="summary"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这门麻省理工学院课程 18S097，应用范畴论，由 David 和 Brendan Fong 教授，介绍了一种纯数学的新方法。这门课程是 IAP 期间的独立学习，涵盖了广泛的主题，从基本集合论开始，逐渐发展到更高级的概念，如算子和拓扑。教师强调在科学和工程领域的应用，突出了这门课程对这些领域的学生的潜在价值。这门课程将使用生成效应方法，并将涵盖分区、关系、函数和预序等主题。家庭作业将于周二截止。</font></font></p><p>This MIT Course, 18S097, Applied Category Theory, taught by David and
            Brendan Fong, introduces a new approach to pure mathematics. The course,
            which is independent study during IAP, covers a wide range of topics,
            starting with basic set theory and progressing to more advanced concepts
            like operads and toposes. The instructors emphasize applications in
            science and engineering, highlighting the course’s potential value for
            students in those fields. The course will use a generative effects
            approach, and will cover topics like partitions, relations, functions,
            and pre-orders. Homework is due Tuesday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">后面是 Brendan。David，你可以直呼我们的名字。如果你是注册学分的学生，请注册三个学分。出于某种原因，你可以自己决定，但只能做一次决定，好吗？我不知道那是什么意思，但这就是我被告知的。</font></font></p><p>That’s Brendan in the back. David, you can refer to us by our first
            names. If you’re a student enrolled for credit, please sign up for three
            units. For some reason, you get to decide yourself, but only one
            decision, okay? I don’t know what that means, but that’s what I’ve been
            told.</p>
        <h2 id="homework-schedule-discussion"><font style="vertical-align:inherit"><font style="vertical-align:inherit">家庭作业时间表讨论</font></font></h2><h2>Homework Schedule Discussion</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">顺便说一句，我们正在决定作业应该在星期五还是星期一交。如果是星期一交，那么最后一个星期二的交作业时间将是星期一、星期一、星期五。有人想投票吗？如果你选择星期一，唯一的区别就是你要花更多的周末时间做作业。这取决于你。有人有偏好吗？有人喜欢星期五做作业吗？一、二。有人喜欢星期一吗？一、二、三。好的。星期一、星期一、星期五。</font></font></p><p>By the way, we’re trying to decide whether homework should be due
            Fridays or Mondays. If it’s due Mondays, it’ll be due Monday, Monday,
            Friday, for the last Tuesday. Would anyone like to vote? If you pick
            Monday, the only difference is spending more of your weekend doing
            homework. That’s up to you. Does anyone have a preference? Does anyone
            prefer Friday for homework? One, two. Does anyone prefer Monday? One,
            two, three. Okay. Monday, Monday, Friday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">此外，对于那些没有课程大纲的人，课程网站是可用的。如果你想坐，前面还有一些空间，只要你不挡住这里的中间点。六年或四年前，……是的，如果你想的话，你可以去那个房间找一把椅子。</font></font></p><p>Also, for those of you who don’t have a syllabus, the course website
            is available. There’s some room in the front if you want to sit as long
            as you’re not obstructing this kind of half way point here. Six or four
            years ago, the… yeah, you can go in that room and get a chair if you
            want.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但我们不确定是否能以某种方式提供某些东西。好的。</font></font></p><p>But something we’re not sure about is making something available
            somehow. Okay.</p>
        <h2 id="course-introduction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程简介</font></font></h2><h2>Course Introduction</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一门 [Flag] 范畴论，人们会慢慢走进来，但我会在他们试图到达这里时介绍一下这门课程。我的意思是，这是一个新房间，但一般来说，如果你早点来，你会得到一个更好的座位。这是应用范畴论。如果麻省理工学院开设范畴论课程就太好了，但我认为美国只有两门范畴论课程。</font></font></p><p>So, so this is a [Flag] category theory, and people are going to
            wander in, but I’ll just kind of introduce the course while they do try
            to get here. I mean, it’s kind of a new room, but in general, if you get
            here early, you get a better seat. And this… so, this is Applied
            Category Theory. It would be great if MIT taught a category theory
            class, but I think there are only two category theory classes taught in
            the US.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个是卡内基梅隆大学的哲学课，另一个是河滨大学的数学系。出于某种原因，人们没有在课堂上教授范畴论作为基础。他们教授集合论，但他们总是希望你掌握范畴论，而从不……从不直接教授它。我们希望直接教给人们，但我们也认为它在科学和工程方面有很多应用。</font></font></p><p>One’s in a philosophy class course at CMU, and one’s in the math
            department at Riverside. For some reason, people aren’t teaching
            category theory as a base in class. They teach set theory, but they
            always expect you to kind of pick up category theory and never… and
            never teach it directly. We want to teach it directly to people, but we
            also think it has a lot of applications to science and engineering.</p>
        <h2 id="course-structure-and-goals"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程结构和目标</font></font></h2><h2>Course Structure and Goals</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，向人们快速提供大量材料的简单方法就是提供应用。所以，我认为范畴论是通往纯数学的大门。如果我要告诉那些说他们想学习纯数学的人，我会说学习范畴论。它就像一个中心枢纽，然后你可以从那里向任何方向走。所以，这应该会帮助你学习更高级的数学课程，但它也有科学和工程方面的应用。</font></font></p><p>And so that’s an easy way to kind of bring a lot of material pretty
            quickly to people is to give applications. So, I think that category
            theory is a gateway to pure math. If I was going to tell someone who
            said they wanted to learn pure math, I would say learn category theory.
            It’s kind of a central hub, and then you can walk in any direction out
            from there. So, this should help you in your more advanced math classes,
            but it also has applications for science and engineering.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们将尝试强调这些。基本上，我认为整个设计领域都存在组织模式。因此，人们会问，数学是被发现的还是发明的？我认为也许正确的词应该是设计。例如，如果你在树林里，你需要设计一条小径系统。你会设计你的生活，因为你不能随便选择你想要的东西；你不只是发明它，而是设计它。在整个设计领域的数学中，有很多模式反复出现，因为这就是我们的思维方式。范畴论对所有这些进行了分类，并说明了它们是如何相互关联的。我认为这就是范畴论的基本概要。</font></font></p><p>And so we’ll try to highlight those. Basically, I think there are
            organizational patterns throughout the design world. So, people ask, is
            math discovered or invented? And I think maybe the right word would be
            design. Where, like, if you’re in the woods, you need to design a trail
            system. You would design your life, because you can’t just pick whatever
            you want; you don’t just invent it, but you kind of design it. And in
            math throughout the design world, there’s lots of patterns that come up
            over and over, because that’s how we think. And category theory catalogs
            all those and says how they’re all interrelated. That’s kind of what I
            think is the basic outline of what category theory is for.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在这堂课中，我们将从零开始。我们不会假设你知道什么是集合。我可能会不小心在 R 中写出 5 作为元素，然后忘记告诉你这种东西是什么。如果我忘记告诉你符号是什么，你不知道，只需举手。但基本上，我们将从零开始，然后逐步建立相当复杂的概念，至少很多人会认为它们是 operads、toposes 和 profunctors。这些词听起来很花哨，甚至对数学家来说也是如此，但到最后，你会想，“为什么你们认为 profunctors 这么难？”至少这是希望。</font></font></p><p>And in this class, we’re going to start at nothing. We’re going to
            not assume you know what a set is. I might accidentally write, like, 5
            inside as an element of R and forget to tell you what that kind of thing
            is. If I ever forget to tell you what a symbol is, you don’t know, just
            raise your hand. But basically, we’ll start at nothing and we’ll build
            up to pretty sophisticated concepts, at least a lot of people would
            think they were, like, operads and toposes and profunctors. These words
            sound fancy, even to mathematicians, but by the end, you’ll think, like,
            “Why do you guys think profunctors are that hard?” At least that’s the
            hope.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，它之所以不难是因为他们在一个非常具体的环境中思考它，而这个环境很难，但 profunctor 的概念实际上是——我们只需要找到一个就是我的环境。</font></font></p><p>So, and the reason it won’t be hard is because they’re thinking about
            it in a very specific context where that context is hard, but the
            profunctor concept is actually—we just need to find a context where
            that’s me.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，一般来说，无论何时有问题，请提出，因为这些问题有助于指导进度。例如，我只得到反馈，或者布伦丹只教一半的课，这就是没有反馈的控制系统。它设计得不是很好。所以，你给我反馈，这有助于指导进度。我想，我们可以控制我们正在做的学习。所以，有问题就问吧。</font></font></p><p>So, as a general rule, whenever you have questions, please ask them,
            because those help guide the pace. Like, I only get my feedback or
            Brendan, so be teaching half classes, and that’s how it’s like a control
            system with no feedback. It wouldn’t be very well engineered. So, you
            give me feedback, and that helps guide the pace that way. We can control
            the learning, I guess, in what we’re doing. So, please ask questions as
            you have them.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">只需片刻，也许您可​​以转向邻居并介绍自己，然后询问他们为什么来这里，并告诉他们您希望了解什么。我知道。是的，请这样做。</font></font></p><p>And just for a second, maybe you could turn to a neighbor and
            introduce yourself and just ask them kind of why they’re here and learn
            and tell them what you hope to learn. I know. Yeah, please, please do
            that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">去年，我能否请大家举手回答一下背景？打断一下，但我可以说，开始总结一下，然后开始总结一下。</font></font></p><p>Last year, can I get a show of hands on people’s backgrounds?
            Interrupting, but I’ll kind of say, start to wrap that up, and then
            start to wrap that up.</p>
        <h2 id="student-backgrounds"><font style="vertical-align:inherit"><font style="vertical-align:inherit">学生背景</font></font></h2><h2>Student Backgrounds</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。</font></font></p><p>Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，请大家举手介绍一下你们的背景。请问一下你们中谁的背景更偏向计算机科学？好的。数学？还有其他的吗？好的。你们中谁还想说点别的？物理？物理？天体物理学？物理？天体物理学？法律？法律？哦，有意思。好的。计算物理学？是的。所以，这很棒……</font></font></p><p>So, can I get a show of hands on your backgrounds? Say who here is
            from more of a computer science background? Okay. Math? And then
            something else? Okay. Any of you want to shout out something else?
            Physics? Physics? Astrophysics? Physics? Astrophysics? Law? Law? Oh,
            interesting. Okay. Computational physics? Yeah. So, there’s great…</p>
        <h2 id="applications-of-category-theory"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴论的应用</font></font></h2><h2>Applications of Category
            Theory</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，范畴论从数学分支到物理学，例如量子物理学。你可以用某种基于范畴论的东西来取代希尔伯特空间形式主义，但仍然可以实现许多相同的目的。或者，在计算机科学中，许多函数式编程语言都是基于范畴论的。单子和函子的思想是使你的代码更易于维护的设计模式。它们会告诉你一些会反复出现的东西，并允许你命名它。所以，实际上，我们是在尝试命名这些设计模式，看看它们是如何相互关联的。</font></font></p><p>So, category theory is branched out of math into physics, for
            example, quantum physics. There’s a lot of you can kind of replace the
            Hilbert space formalism with something that’s founded on just category
            theory, but still can accomplish many of the same ends. Or, in computer
            science, a lot of functional programming languages are based on category
            theory. The ideas of monads and functors are design patterns that make
            your code more maintainable. They kind of tell you something that’s
            going to show up over and over again and allow you to name it. So,
            really, we’re kind of trying to name these design patterns, see how they
            interrelate.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">也许还有一个问题要问学生。你们希望学到什么？为什么来这里？是什么吸引你们来这里？玩得开心吗？玩得开心！太好了。</font></font></p><p>Maybe one more question for the students. For you guys, what do you
            hope to learn? Why are you here? What brings you here? Any have fun?
            Have fun! Great.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，我们想学习。玩得开心。我们也希望学生在课后尝试接手一个项目。也许你想加入我们。另外，我认为应用范畴论是一个新领域。我不知道这里有没有人下围棋，但在围棋中，你一开始就设置了一些棋子，它们会告诉你接下来的棋局。所以，在应用范畴论的早期阶段，我们现在要设置一些棋子。当你设置它们时，它就定义了这个领域将会变成什么样子。所以，如果你想加入这个领域，希望这门课程能告诉你一些你可以利用的东西，让你找到一个可以参与其中的地方。</font></font></p><p>Yeah, we want to learn. Have fun. We also would like students to
            maybe try to take on a project afterward. Maybe you want to join us in
            something. Also, I think Applied Category Theory is kind of a new field.
            I don’t know if anyone here plays Go, but in Go, you kind of set out a
            few pieces in the beginning, and they tell you the shape of the game to
            come. So, in this early part of Applied Category Theory, we’re putting
            down some pieces right now. And as you put those down, it defines what
            the field will become. So, if you want to join that, hopefully, this
            course will tell you something that you can use to find a place to play
            there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">人们来这里的其他原因？是的，很明显……好的，很好。很明显，是的。这很有帮助。也就是说，它会给你一些可以放下的物品，让你想起你在哪里，就像你在路线建设练习中留下的面包屑一样。它不会帮助你的大脑做不同的事情。好吧，也许吧，但它不会帮助你知道；它不是某种……是的，对。是的。其他事情？这是真的。是的。试试这个。我……我做了很多非正式的映射。我看到了很多类似的计算类型，它们看起来类似于完全不同领域的其他类型。</font></font></p><p>Other reasons people are here? Yeah, to clearly… okay, great.
            Clearly, co… yeah. It’s helpful. That is to say, it’ll give you some
            artifacts that you can lay down that will remind you where you were,
            like breadcrumbs on your trail building exercise. It doesn’t help your
            mind do different things. Well, maybe, but it doesn’t help you know;
            it’s not some kind of… yeah, right. Yes. Other things? This is true.
            Yeah. Take a shot at this. I… I’ve done a lot of informal mapping. I’ve
            seen a lot of like types of calculations that look analogous to other
            types in completely different fields.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，这正是试图了解这些关系所在。是的，这正是它的用途。我可能已经说过五次了。只是为了好玩。我不知道，但我想它有很多用途。这取决于你如何看待它。所以，我想让我们开始一些实际的映射，然后在最后，我会总结其余部分。正如我所说，我从零开始。所以，不假设你知道集合是什么。所以，对于一些人来说，这会很无聊，但也许你可以尝试获得比你已经拥有的更深层次的东西。或者它会很快。所以，我们将在 14、13 或 12 点到达 Topos 研究所。所以，如果你开始不注意，你可能会错过适合你的那一刻。</font></font></p><p>Yeah, that’s exactly trying to see where those relationships are.
            Yeah, that’s exactly what it’s for. I might have said that’s exactly
            what it’s for like five times. Exactly for fun. I don’t know, but it’s
            for a lot of things, I guess. It’s what you make of it. So, so I guess
            let’s start on some actual mapping, and then at the end, I’ll summarize
            the rest of it. And I’m starting, as I said, I’m starting from zero. So,
            not assuming you know what a set is. And so, for some people, that’s
            going to be boring, but maybe you can try to get something deeper than
            you already have. Or it is going to go fast. So, we will get all the way
            to Topos Institute by 14, 13, or 12. So, if you start to not pay
            attention, you might miss that moment where something is for you.</p>
        <h2 id="course-content-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程内容：集合</font></font></h2><h2>Course Content: Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但好吧。</font></font></p><p>But okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我将从一种叫做“生成效应”的东西开始，一位名叫埃莉·亚当斯的学生，他是麻省理工学院的博士。他曾经是博士，现在在这里任职。我们对生成效应的思考比我们要讨论的要广泛得多，但它们也被称为级联效应或涌现属性。我并不是说所有可以称为涌现属性的东西都是我现在要讨论的，但这可能是你可以去寻找的地方——这种地方可能是你可以去寻找涌现含义的地方。它一直是一个神秘的概念，我们想在数学中命名一些东西，然后说，“这足以满足你所说的涌现吗？”</font></font></p><p>So, I’m going to start with something called generative effects, and
            a guy, a student named Ellie Adams, who’s a PhD at MIT. He was, and now
            he’s a post here. We thought about generative effects much more broadly
            than we were going to talk about, but these are also called cascade
            effects or emergent properties. I’m not saying that everything that you
            could call an emergent property is what I’m going to talk about now, but
            that this might be somewhere where you can look—this kind of place might
            be where you can look for what emergence means. It’s always kind of a
            mysterious concept, and we want to name something in math and say, “Is
            this good enough for what you mean by emergence?”</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在这个生成效应的世界里，假设有四个人：父母、孩子、孩子的朋友和父母的同事。晚上，父母和孩子在一起；所以，他们在一起。同事独自一人，朋友独自一人。孩子的朋友真的处于悲伤的状态，他们独自一人。但在白天，孩子更快乐，因为孩子和另一个孩子一起上学，父母和同事在一起。现在，我们想知道传染的问题；我们想知道朋友（孩子的朋友）是否会让同事生病。</font></font></p><p>So, in this world of generative effects, the idea is that maybe you
            have four people: a parent, a kid, the kid’s friend, and the parent’s
            coworker. At night, the parent and the kid are together; so, those are
            together. The coworker is by themselves, and the friend is by
            themselves. The kid’s friend is just really in a sad state, and they’re
            just all by themselves. But during the day, the kid is happier because
            the kid is at school with the other kid, and the parent is with the
            coworker. Now, we’re wondering about contagion; we’re wondering about
            whether the friend (the kid’s friend) can get the coworker sick.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们看一下这个，然后说：“不。他们身处世界各个孤立的地方；他们不可能互相传染疾病。”我们看一下这个，然后说：“同事和朋友身处世界各个孤立的地方；他们不可能互相传染疾病。”但是，当你将这两个连接在一起时——这两个分区的连接（我们取同一个集合，用两种不同的方式对其进行分区）——当我们将它们连接在一起时，谁在一起？嗯，父母和孩子在一起，但父母也和同事在一起，孩子和朋友在一起。所以，他们都在一个 blob 中；他们根本没有分区。</font></font></p><p>We look in this one, and we say, “Nope. They’re in isolated parts of
            the world; there’s no way they can get each other sick.” We look in this
            one, and we say, “The coworker and the friend are in isolated parts of
            the world; there’s no way they can get each other sick.” But when you
            join these two together—the join of these two partitions (we took the
            same set, we partitioned it in two different ways)—and when we join
            them, then who’s together? Well, the parent is with the kid, but the
            parent is also with the coworker, and the kid is with the friend. So,
            they’re all kind of in one blob together; they’re not partitioned at
            all.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">从传染的角度来看，朋友可能会使人生病。但我们的观察有些问题，因为当我们观察这一个朋友和观察那一个朋友时，他们都说“假”——不会让人生病。然而，当我们把它们放在一起时，我们得到了这种生成效应，即孩子、孩子的朋友和同事都在同一个地方。从某种意义上说，这是一种突发行为，因为你不能把它孤立起来——给系统蒙上一层面纱，看看它们是否有联系。这是一个问题：它们有联系吗？这就像是一种观察系统的方式，你只拥有部分信息，而且这并不能保留……</font></font></p><p>Contagion wise, the friend can get the person sick. But something was
            wrong with our observation because when we observe this one and we
            observe this one, they both said “false”—cannot make sick. And yet, when
            we join them, we get this generative effect that the kid, the kid’s
            friend, and the coworker are in the same place. This is an emergent
            behavior in some sense, because you can’t just isolate it—put a veil
            over the system and see whether they’re connected or not. That’s a
            question: Are they connected? That’s like a way of viewing the system
            where you only have partial information, and that does not preserve…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们将从零开始讨论什么是连接和什么是分区。首先，我们有集合。因此，对于本课程来说，集合是一袋点。这是一个集合。如果您知道 Zermelo Fraenkel 集合论，请将其抛开，从一袋点开始。还有……这是集合 A、B。我们需要一些符号，这样我们才不必总是画出完全相同的东西。因此，您制作花括号 {abc}，然后您说 a 是 a 的一个元素。哎呀。a 是 — 如果我写一个冒号等号 — 哦，一些……如果我写一个冒号等号，这意味着将 a 设置为等于此步骤。因此，使 a 等于这个三元素集。然后我可以说 a 在 a 中或 b 在 a 中。这够清楚了吗？</font></font></p><p>So, we’ll talk about what joins are and what partitions are, starting
            from nothing. To begin, we have sets. So, a set, for this course, is a
            bag of dots. It’s that’s a set. If you know Zermelo Fraenkel set theory,
            just throw it away and start with a bag of dots. There’s also… Here is
            set A, B. We need some notation so we don’t always have to draw things
            identically. So, you make curly braces {abc} and then you say a is an
            element of a. Oops. a is—if I write a colon equals—oh, some… if I write
            a colon equals, that means set a equal to this step. So, make a equal to
            this three element set. And then I could say a is in a or b is in a. Is
            this clear enough?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">可能吧。还有一袋点叫做自然数，对我们来说就是零。自然数总是从零开始。1、2、18 到 500 都在那里，等等。有整数，有实数。</font></font></p><p>Probably. There’s also the bag of dots called the natural numbers,
            and that is zero for us. The natural numbers always start at zero. 1, 2,
            18 to the 500 is in there, and so on. There’s the integers, there’s the
            reals.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">整数。哦，这是我们要使用的整数。我们重写 b。它是一组布尔值。布尔值要么是真，要么是假。</font></font></p><p>Integers. Oh, here’s one we’ll use. We rewrite b. It’s the set of
            Boolean values. A Boolean is either true or false.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们在这里写了很多集合，还会有更多。但这些都是集合，这就是“元素”的符号：a 是 a 的一个元素。</font></font></p><p>So, we’ve written a bunch of sets here, and there will be many more.
            But these are sets, and that’s the symbol for “element”: a is an element
            of a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，接下来我想讨论的是乘积集和子集。乘积集。如果我设置了 a 和 b。那么，假设我们有两个集合。那么 a * b 就是所有对 (a, b) 的集合，其中 a 在 a 中，b 在 b 中。</font></font></p><p>Then, the next thing I want to talk about is product sets and
            subsets. Product sets. So, if I have set a and set b. So, suppose we
            have two sets. Then a * b is the set of all pairs (a, b) such that a is
            in a and b is in b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你有一套看起来像这样的设备——这里是 a，这里是 b——这里真的很热吗？或者我……？有人能把那扇门打开吗？门挡不起作用。但如果你能把它打开，你可能会得到一些气流。</font></font></p><p>So, if you have a set that looks like this—here’s a and here’s b—is
            it really hot in here? Or am I…? Is anyone able to keep that door open?
            The doorstop is not working. But if you can keep it open, you might get
            some airflow.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，乘积集是所有有序对的集合，一个在 a 中，另一个在 b 中。因此，如果某人来表示 a，另一个人来表示 ab，那么他们一起表示的是 (a, b)。因此，这是 a * b。这是点的网格。您有一大行点和一大行点，然后您取网格。</font></font></p><p>So, the product set is the set of all ordered pairs, one in a and one
            in b. So, if someone comes and indicates an a and someone else comes and
            indicates a b, then together they’ve indicated an (a, b). So, here’s a *
            b. It’s the grid of dots. You have a big line of dots and a big line of
            dots, and you take the grid.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。对此还有什么疑问吗？</font></font></p><p>Okay. Any questions on this?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，我忘了提一个非常重要的集合，那就是空集。空集就是里面什么都没有的集合。还有一个我忘了提：对于任何自然数 n——我将 n 写成下划线，表示 1、2、1——那么现在我们得到空集 = 0。集合总是有那么多——下划线的数字有那么多元素。集合，是的。</font></font></p><p>Oh, a very important set I forgot to mention is the empty set. This
            is the set with nothing inside. And one more I forgot to mention is: for
            any natural number n—I’ll write n with an underline to mean 1, 2, 1—so
            now we get the empty set = 0. And a set always has as many—a number
            underlined has that many elements in it. Set, yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">没关系。我的意思是，它相当于说从零到……它将是一个同构集，但它不会有我使用的相同命名约定。我想使用这个，这样我就知道它有这么多元素。但你想怎么做都可以。你们都想要一个包吗？你说什么？忘掉它吧。是的，这个，实数，是一个非常非常重要的。</font></font></p><p>Never mind. I mean, it would be equivalent to say like zero up to… it
            would be that would be an isomorphic set, but it wouldn’t have the same
            naming convention I’m using. And I want to use this one just so that I
            know that this has this many elements. But you can do however you want.
            Are you all for a bag? What did you say? Just forget you know. Yes, this
            one, the reals, is a really, really important one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，实数对实数，或者说，没关系。还有其他问题吗？所以这些是集合，所有数学都可以建立在集合论的基础上。我可以——我的意思是，人们假装它是，而且它就像是可以的。任何想要的人都可以在集合论上找到他们想要的数学。问题是，以这种方式工作相当困难。你不想认为实数是一对有理数的子集，每个子​​集都是用集合论写成的整数的商。</font></font></p><p>But then, real to the reals, or yeah, that’s okay. Other questions?
            So these are sets, and all of math could be founded on set theory. I
            could be—I mean, that people pretend that it is, and it’s like it can
            be. Anyone who wants to can found as much of math as they want on set
            theory. The problem is that it’s pretty hard to work that way. You don’t
            want to think that a real number is a pair of subsets of rational
            numbers, each of which are quotients of integers written in, like, in
            set theory.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有时他们想用非常具体的方式来写东西，比如这个和这个，来表示数字。但在范畴论中，我们不会考虑某物是由什么构成的，比如你身体里的实际原子是什么。我们考虑它们所扮演的角色。所以，这个东西，a 乘以 b，相对于这两个家伙来说，扮演着某种角色。我不确定我为什么要深入研究那一小部分，但是对乘积集有什么问题吗？还有其他问题吗？</font></font></p><p>Sometimes they want to write things in very specific ways, like this
            and this, to mean the numbers. But in category theory, we don’t think in
            terms of what something’s built out of, like what the actual atoms in
            your body are. We think about the roles that they play. So, this thing,
            a times b, plays the role of something with respect to these two guys.
            I’m not sure why I dived into that little part there, but any questions
            about product sets? Anything else?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，在我们讨论关系之前，最后一件事是子集，我们很快就会讨论到。所以，子集是这样写的：a 是 b 的子集。它只是意味着 a 的每个元素也是 b 的元素。那么，1、2、3 是 N 的子集，就像我在上面写的 N 一样，这是真的吗？是的，对吧？12、pi、123.5 是 M 的子集吗？不是。好的。空集呢？对于任意 a，空集是 a 的子集吗？是的，因为空集的每个元素都是 a 的元素。它没有元素，所以你不必检查任何东西。这被称为空真。对于任何 a，a 都是 a 的子集。</font></font></p><p>So, the last thing before we can get to relations, which we’ll get to
            soon, is subsets. So, a subset is written like this: a is a subset of b.
            And it just means that every element of a is also an element of b. So,
            is it true that 1, 2, 3 is a subset of N, as I wrote N over there? Yes,
            right? And is 12, pi, 123.5 a subset of M? No.&nbsp;Okay. What about the
            empty set? Is the empty set a subset of a, for arbitrary a? Yes, because
            every element of the empty set is an element of a. That has no elements,
            so you don’t have to check anything. This is called vacuously true. And
            a is a subset of a for any a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，一旦你有了集合、乘积和子集，那么你就有了所谓的关系。</font></font></p><p>Okay, so once you have sets, products, and subsets, then you have
            what’s called relations.</p>
        <h2 id="course-content-relations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程内容：关系</font></font></h2><h2>Course Content: Relations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，一种类型的关系，或者说 a 和 b 的关系——“关系”这个词旨在唤起关系。因此，如果你谈论世界上任何与其他事物有关系的事物，那么你应该能够举手说：“我想到这种类型的某些事物与那种类型的某些事物之间的关系。”这怎么能算是一种关系呢？我会试着回答这个问题。似乎没有做到这一点。然后，然后应该检查一下。</font></font></p><p>So, a relation of type, or on a and b—and the word “relation” is
            meant to evoke relationship. So, if you talk about anything in the world
            that has a relationship with something else, then you should be able to
            raise your hand and say, “I thought of a relationship between some
            things of this type and some things of that type.” How is that a
            relation? And I’ll try to answer this. Doesn’t seem to do that. Then,
            then should check.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，集合 a 和 b 上的关系是什么？集合 a 和 b 上的关系只是它们乘积的子集。那么，让我给你举几个例子。假设 a 是这个集合——也许 a 是 {4}——而 b 是 {3}。或者，举个例子。我们可以像这样画出关系。这是一张关系图。从这些术语上讲，关系是在集合 B 中，点集包含元素 1、1、2、3、1 和 4、3。所以，这张图片和这张图片是相同的；它们意味着同样的事情。</font></font></p><p>So, what’s a relation on sets a and b? A relation on sets a and b is
            just a subset of their product. So, let me give you some examples. Let’s
            say a is this set—maybe a is {4}—and b is {3}. Or, an example relation.
            We can draw relations like this. There is a picture of a relation. The
            relation, in these terms, is that inside set B, the set of dots contains
            the elements 1, 1, 2, 3, 1, and 4, 3. So, this picture and this picture
            are the same; they mean the same thing.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是子集，是子集，或者另一种更常见的写法，是数据库形式。所以，现在我们可以看到，在范畴论中，特别是在这门课中，我们将尽可能多地与当今现实世界中的事物联系起来。所以，在数据库中，我们有 a 和 b，我们会有 1、1、1、3、2、1、4 之类的东西。那只是一堆数字。是的。你说的很清楚，但你必须警告，集合 a 和 b 上的关系不是集合 b 和 a 上的关系，即使它们有点相似，对吧？集合上的关系，对吧？我的意思是，这是一种有趣的……</font></font></p><p>This is a subset, are subset of, or another way to write it, that’s
            much more common, is in database form. So, now we can see how, like, in
            category theory and especially in this class, we’re going to relate as
            much as we can to things in the real world of today. So, in a database,
            we have a and b, and we would have something like 1, 1, 1, 3, 2, 1, 4.
            That would just be a bunch of numbers. Yep. What you’re saying is clear,
            but then you have to warn that a relation on sets a and b is not a
            relation on sets b and a, even though it’s sort of the same, right? A
            relation on set, right? I mean, it’s a funny kind of…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这就是所谓的匕首类别，我想这是出于某种原因，因为它首先出现的地方就涉及到了匕首。不，是量子力学，是物理学中的关节。因此，这意味着从 a 到 b 的任何关系也是从 b 到 a 的关系。就像每个矩阵都有一个转置一样，这个矩阵可能是 1、z、1、z、1、0、0、1。它有一个转置，现在是 4 x 3，这就是从 b 到 a 的关系。而且它几乎是完全相同的数据；只是有人告诉你这是从 a 到 b。这是唯一的区别。所以，是的，这就像 a 是 b 的父级，而 b 有 a 作为父级；它们是相同的关系，重复了两次。</font></font></p><p>And so, this is what’s called a dagger category, for some reason, I
            guess, because where it came up first, it was a dagger involved. No,
            quantum mechanics, joint in physics. So, and what that means is that any
            relation from a to b is also a relation from b to a. Just like every
            matrix has a transpose, this matrix might be something like 1, z, 1, z,
            1, 0, 0, 1. And that has a transpose where it’s now 4 x 3, and that
            would be the relation from b to a. And it’d be almost exactly the same
            data; it’s just that someone told you this is from a to b. That’s the
            only difference. So, yeah, it’s like when a is a parent of b, and b has
            a as a parent; they’re the same relationship said twice.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，关系是数学中非常常见的东西。例如，每个函数都是一个关系。满足一些属性但又满足顺序的关系也是一种关系。我没有想到其他的……顺序是一种关系。等价性由关系给出。公差，比如在公差范围内的东西，是由关系给出的。各种关系。因此，在数学中你会看到很多关系，但我们先来谈谈函数，因为集合和函数是许多数学的基本组成部分，尤其是范畴论。</font></font></p><p>So, relations are very common things in math. For example, every
            function is a relation. A relation satisfying a few properties, but also
            order is a relation. I didn’t think of what other ones… order is a
            relation. Equivalence is given by a relation. Tolerance, like something
            being within tolerance, are given by relations. Kinds of relations. So,
            there’s lots of relations that you see all over math, but let’s talk
            about functions first, because sets and functions are kind of the basic
            building blocks of a lot of math, especially category theory.</p>
        <h2 id="course-content-functions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程内容：函数</font></font></h2><h2>Course Content: Functions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，什么是函数？从 a 到 b 的函数，我可能称之为函数 f，表示为 f: a → b。类型为 a → b。它是什么？它是 a 上的关系。如果你知道什么是伴随，什么是二元范畴，而大多数人不知道，那么我会说，“哦，它只是关系范畴中的一种伴随。”然后你就已经知道它是什么了。但这就是范畴论的力量，它可以将大量信息压缩到一个非常小的空间里。</font></font></p><p>So, what’s a function? A function from a to b, maybe I’ll call the
            function f, would be denoted f: a → b. Of type a → b. And what is it?
            It’s a relation on a. If you know what an adjunction is and what a two
            category is, which most of you don’t, then I would say, “Oh, it’s just
            an adjunction in the category of relations.” And then you’d already know
            what it was. But that’s the power of category theory to compress a lot
            of information into a very small space.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们要做的是从元素及其元素之间的关系来解释它。因为我们还没有进入范畴论的这一部分，所以函数被定义为关系，它是 A × B 的子集。换句话说，它是一个满足两个属性的关系 R ⊆ A × B：第一，对于 A 中的所有元素 a，存在一个元素 b，使得 a ⋅ b 在 R 中。a 和 b 是相关的。</font></font></p><p>What we have to do is explain it in terms of elements and how their
            elements relate. Because we’re not at that part of category theory yet,
            a function is defined as a relation, which is a subset of A × B. In
            other words, it’s a relation R ⊆ A × B satisfying two properties: one,
            for all elements a that are in A, there exists an element b such that a
            ⋅ b is in R. a and b are related.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">每个 a 都与某个 b 相关。对于所有 a、b₁ 和 b₂，如果 a 与 b₁ 相关且 a 与 b₂ 相关，则 b₁ 和 b₂ 相同。大多数人只会说存在一个唯一元素，但这在某种程度上更明确。那么，我在这里画的关系是一个函数吗？你怎么能这么说呢，它违反了哪条规则？它是一个关系吗？好的，那么它违反了哪条规则？它违反了两条规则。所以，这一条违反了规则一，而这一条违反了规则二。这一条无处可去；这一条有太多地方可去。所以，当关系是函数时，它们看起来的样子是左边的每个点只有一个地方可去。好吗？对集合、函数和关系、乘积有什么问题吗？好的，好的。</font></font></p><p>Every a is related to some b. And for all a, b₁, and b₂, if a is
            related to b₁ and a is related to b₂, then b₁ and b₂ are the same. Most
            people would just say there exists a unique element, but this is somehow
            more explicit. So, is the relation I drew here a function? From how can
            you, which rule does it violate? Is it a relation? Okay, so what rule
            does it violate? It violates both rules. So, this one violates rule one,
            and this one violates rule two. This one has nowhere to go; this one has
            too many places to go. So, the way relations look when they’re functions
            is that every dot on the left has only one place to go. Okay? Any
            questions about sets, functions, and relations, products? Okay,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，在我们再次讨论分区之前还有最后一件事，函数被称为单射或一对一，但我不太喜欢这种说法。你会说存在一一对应关系。它们的意思不是单射意义上的一对一；它们的意思是双射。所以，术语有点不对。如果函数满足二对偶关系，则该函数称为单射，函数为 f。如果对于所有 a₁、a₂ 和 b，如果 a₁ ⋅ b 和 a₂ ⋅ b 都处于关系中，则它们都是相关的，然后 a₁ = a₂。</font></font></p><p>So, then one last thing before we get to partitions again, so a
            function is called injective or one to one, but I don’t like that too
            much. You will say there’s a one to one correspondence. They don’t mean
            one to one in the sense of injective; they mean bijective. So, slightly
            bad terminology. A function is called injective, the function is f, if
            it kind of satisfies the dual to two. If for all a₁, a₂, and b, if a₁ ⋅
            b and a₂ ⋅ b are both in the relation, they’re both related, then a₁ =
            a₂.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是你该怎么写呢？人们可能知道这一点。那么，你该怎么用通俗的术语来写呢？f(a)。所以，如果我们在 R 中有一个，并且 R 是一个关系，那么我会把它放在云中，因为它是，而我们现在不一定有。我想我们必须说图 R 是…的图。那么，你说的 f，你的意思是 f 是与关系相对应的函数？</font></font></p><p>But how do you write that? And people probably know this. So, what do
            you, how do you write this in common terms? f(a). So, this, so if we
            have a is in R, and R is a relation, a, I’ll put this in a cloud because
            it’s, and we don’t necessarily have one right now. I guess we would have
            to say graph R is the graph of… Okay. So, by f, there you mean f is the
            function corresponding to the relation?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数只是一种关系。函数 f 只是一种关系，但它必须满足两个属性。这是一个关系。是的，抱歉，这不是很好，但我不想花时间……是的，最好写在书上。好的，这就是说某事物是单射的意思，但我们实际上对单射更感兴趣。我们稍后会对此感兴趣。单射函数意味着没有两个输入映射到相同的输出。</font></font></p><p>A function is just a relation. A function f is just a relation, but
            it has to satisfy two properties. That’s a relation. Yeah, sorry, that’s
            not very good, but I don’t want to take the time to… Yeah, it’s better
            written in the book. Okay, so this is what it means to say something’s
            injective, but we’re actually going to be more interested in surjective.
            We’ll be interested in this later. Injective functions mean no two
            inputs map to the same output.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">全射函数是单射函数的一种对偶。所以它被称为函数；它被称为全射。对于所有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，存在一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">使得……现在我们可以用全射来理解分区。所以一个集合的分区就是对另一个集合的全射。</font></font></p><p>Surjective functions are a kind of dual to injective functions. So
            it’s called a function; it’s called surjective. For all <em>b</em>,
            there exists an <em>a</em> such that…and now we can understand
            partitions in terms of surjections. So a partition of a set is just a
            surjection onto some other set.</p>
        <h2 id="course-content-partitions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程内容：分区</font></font></h2><h2>Course Content: Partitions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以如果我有一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，然后我画了这幅图，我说的是什么射影？好吧，我想要从这个集合到其他集合的射影。我应该使用哪个其他集合？Blob。是的，我们想要 Blob。所以有一个 Blob，有一个 Blob，还有一个 Blob。这两个人去这个 Blob，这个人去这个 Blob，这个人去这个 Blob。一旦我这样做了，那么我就会显示你从该分区开始的数据。我说这两个在同一个 Blob 中，这两个在他们自己的 Blob 中。对吗？</font></font></p><p>So if I have a set <em>a</em>, and I draw this picture, what
            surjection am I talking about? Well, I want a surjection from this onto
            some other set. What other set should I use? Blobs. Yeah, we want the
            blobs. So there’s a blob, there’s a blob, and there’s a blob. And these
            two guys go to this blob, this guy goes to this blob, and this guy goes
            to this blob. And once I do that, then I’ve kind of revealed the data
            that you started with of that partition. I’ve said these two are in the
            same blob, and these two are in their own blobs. Yeah?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">分割类别与全射类别不是有所不同吗？因为全射类别中有非平凡自同构？是的。</font></font></p><p>Isn’t the category of partitions different from the category of
            surjections because you have like non trivial automorphisms in a
            category of surjections? Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我们在这里的意思是，这些是同构的射影……他说的是，如果其他人画了同样的图，把这两个人送到那个人那里，把这个人送到那个人那里，把这个人送到那个人那里，这会给我们相同的划分，但功能不同。所以我们所做的就是重新排列这三个的顺序。所以我们说，难道你不应该这样做，直到重新排列这三个，你称之为同构吗？所以，从理论上讲，你可以做出这种区分。一次？是的。一个是同构的对象，对象。</font></font></p><p>So what we mean here is that these are surjections where up to
            isomorphism of this guy…all he said was that if someone else drew this
            same picture and they sent these two guys to that one, and this one to
            that one, and this one to that one, it would give us the same partition
            but with a different function. And so what all we did was we rearranged
            the order of these three. And so we said, shouldn’t you do this up to
            reordering of these three, which you call isomorphism? And so, category
            theoretically, you can make that distinction. Once? Yeah. One’s kind of
            the object of isomorphism, the object.</p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。关于这个还有其他问题吗？我们现在知道， a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的划分
            是从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">单射</font><font style="vertical-align:inherit">。所以也许这就像零件，这是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。你有
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和零件。这个单射，我想人们经常在那里写这个单射和单射。有些人写一个钩子。这在图表中有点烦人，因为你有不同方向的钩子。
        </font></font></p><p>Okay. Other questions about this? So we understand now a partition on
            <em>a</em> is a surjection from <em>a</em> to <em>b</em>. So maybe this
            is like the parts, and this is <em>a</em>, this is <em>a</em>. You have
            <em>a</em> and the parts. And this surjection, I guess people often
            write this surjective there, and injective. Some people write a hook.
            It’s kind of annoying in diagrams because you have hooks going different
            ways.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。那么关于分区作为射影还有什么问题吗？并不是说这特别有趣，只是这是一种谈论分区的方式，它为我们提供了一种方法，你知道，不需要画那么多，只需要依靠图片，而是依靠公式。</font></font></p><p>Okay. So any questions about partitions as surjections? Not that
            that’s like super interesting, just that that’s a way of talking about
            partitions that gives us a way of, you know, not having to draw as many,
            just having to rely on the pictures, but relying on the formulas.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在我们可以讨论分区的顺序。所以我们说一个分区……我们可以对分区进行排序。</font></font></p><p>So now we can talk about an order on partitions. So we say one
            partition…we can order partitions.</p>
        <h2 id="course-content-order-on-partitions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程内容：分区排序</font></font></h2><h2>Course Content: Order on
            Partitions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">假设我们有两个分区。我们有分区一和分区二，它们属于同一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，但是一个人这样分区，另一个人那样分区。那么</font><font style="vertical-align:inherit">如果存在从</font><em><font style="vertical-align:inherit">p1</font></em><font style="vertical-align:inherit">到
            </font><em><font style="vertical-align:inherit">p2的函数，我们说</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p2</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。我还没有解释“使图表可交换”是什么意思。只有你已经了解一些范畴论，你才会理解。我一会儿要回答某人的问题。因此，如果存在这样的函数，使得这由那个函数组成，我们说 p1 小于 p2 。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So say we have two partitions. We have partition one, and we have
            partition two, of the same set <em>a</em>, but one person partitions it
            this way, and one person partitions it that way. Then we say <em>p1</em>
            is less than <em>p2</em> if there is a function from <em>p1</em> to
            <em>p2</em>. I haven’t yet explained what “making the diagram commute”
            means. You’ll only understand it if you already know some category
            theory. I’m going to get someone’s question a second. So, we say p1 is
            less than p2 if there’s a function like this such that this composed of
            that.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我还没告诉你什么是组合，对吧？那么，p1 和 p2 是单射作用所针对的集合，还是分区？就像，它们难道不能是……我明白了。是的，我……是的，对。所以，这个是……所以，这里，A 是这个有四个元素的集合。p1 有三个元素，p2 有两个元素。现在，如果我取这个三元素集合，这里的三个分区，这里的两个分区，如果我想说这个分区小于那个分区，我需要给你一个从这个集合到这个集合的函数，因为这里的每个分区都应该在那里得到一个分区。这就是我说我需要做的。那么，这个家伙应该在哪里作为 blob？这里的每个 blob 都需要得到一个 blob……blob 一应该放在哪里？大 blob，大 blob。这个，大 blob，大 blob。这个，小 blob。所以，完全正确。感谢您的参与。</font></font></p><p>I’ve not told you what composition is, yeah? So, is p1 and p2 are the
            sets that the surjective action is onto, or are they the partitions?
            Like, couldn’t they be the… I see. Yeah, I… yeah, right. So, this one is
            the thing that… So, here, A is this set with four elements. p1 has three
            elements, p2 has two elements. And now, if I take this three element
            set, the three partitions here, the two partitions here, if I wanted to
            say that this partition is less than that one, I would need to give you
            a function from this set to this set, because every partition here
            should be getting a partition there. That’s what I said I was going to
            need to do. So, where should this guy go in terms of a blob here? Where
            each blob here needs to get a blob… where should blob one go? Big blob,
            big blob. This one, big blob, big blob. This one, little one. So, that’s
            exactly right. And thanks for participating.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，同学们，成绩的 75% 是作业，25% 是参与。参与就是刚刚参与的人所做的。它也意味着提问。所以，试着这样做，也请今天或明天向我或 Brendan 介绍一下自己。</font></font></p><p>Oh, class, the grade is 75% homework, 25% participation.
            Participation means exactly what people who just participated did. It
            also means asking questions. So, just try to do that, and also please
            introduce yourselves to me or Brendan today or tomorrow.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，在 LaTeX 中，它被称为双向右箭头。我的意思是，a 映射到 b。</font></font></p><p>Yeah, in LaTeX, it’s called a two headed right arrow. I mean, a maps
            to b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，所以这句话的意思是，每个分区，这个分区的每个部分都有这个分区的一部分。如果这个分区的每个部分都是这个分区的一部分，那么这个分区就小于那个分区。请注意，这个分区不小于这个分区，因为这个分区不是子集。它不只在那个分区内，也不只在那个分区内。顺序确实是这样。</font></font></p><p>Okay, so what this says is that every partition, every part of this
            one has a part of this one that is part of. And if every part of this
            one is part of a part of this one, then this one’s less than that one.
            Note that this one’s not less than this one, because this one is not a
            subset. It’s not inside of just that one, or inside of just that one.
            The order is really going that way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像越来越模糊，越来越不精致。那么，在这个东西的最顶端，最小分区是什么？有人知道吗？是的，一切都在它自己的部分。那是什么函数？A 到什么？A，一切都到它自己的部分。最大分区是什么，最不精致，就是那个。那是在一个 blob 上最精致的。所以，你有一个下划线，你有这个家伙，总是有一个这样的函数，它总是交换。所以，好吧。</font></font></p><p>It’s like getting more and more blobby, less and less refined. So, at
            the very top of this thing, what’s the minimum partition? Does anyone
            have any idea? Yeah, everything in its own part. And what function would
            that be? A onto what? A, everything onto its own part. And what would
            the maximum partition, least refined, that’s that one. That’s the most
            refined at one blob. So, you have one underline, and you have this guy,
            and there’s always a function like that, and it always commutes. So,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，请举手发言吧？谁知道怎么做……也许我不应该问这个问题。想让别人难堪吗？所以，大多数人可能都知道如何组合函数。我的意思是，我认为每个人都知道。所以，要清楚，如果你不知道，这并不尴尬。如果你不知道，这并不尴尬。但组合函数只是意味着先做一件事，然后再做另一件事。当我们说这个图可以使用时，这意味着如果我做这个[动作/事情]，那么那个[动作/事情]就会发生。好的。</font></font></p><p>So, can I get a show of hands? Who knows how to… maybe I shouldn’t
            ask that. Want to embarrass people? So, most people probably know how to
            compose functions. I mean, I think everyone does. So, be clear, it’s not
            embarrassing if you don’t. It’s not embarrassing if you don’t. But
            composing functions just means doing one then the other. And when we say
            this diagram can be used, it means that if I do this [action/thing],
            then that [action/thing] will happen. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，三个点 a、b、c 的所有分区的顺序是什么？有多少个分区？是的。等等。我们可以像这样定义顺序吗？难道我们不会因此而面临明确性问题吗？或者这是需要检查的东西？这可能需要检查。但如果这是一个同构，那么我们只能说一个小于另一个，另一个小于一个。不，不，不。但我们面临明确性问题，因为我们有不同的等效分区。</font></font></p><p>So, what are the—what is the order of all partitions of three dots,
            a, b, c? How many partitions of this are there? Yeah. Wait. Can we
            define the ordering like this? Don’t we have a well definedness issue
            because of that? Or is that something to check? That’s maybe something
            to check. But if this was an isomorphism, then we just say one is less
            than the other and the other is less than the one. No, no, no. But we
            have a well definedness issue because we have different partitions that
            are equivalent.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">不同的射影可以表示相同的划分。嗯。但是这两个集合将是同构的。是的，是的。这是个好问题。所以，当他说，不管是谁，说“达到同构”，他指的是这里的同构。在这种情况下，得到三和三，它们是同构集。而且它是可交换的。这将放在这里。其他问题？是的。四个关系——我的意思是四个。是的。那么，这里有多少个分区？是的。一个说四个，一个说六个。</font></font></p><p>Different surjections can represent the same partition. Mhm. And but
            those two sets will be isomorphic. Yeah, yeah. That’s a good question.
            So, when he said, whoever it was, said “up to isomorphism,” he was
            talking about exactly this being isomorphic here. That in this case, got
            three and three, and they’re isomorphic sets. And it commutes. This
            would go here. Other questions? Yeah. Four relations on—I mean, four.
            Yeah. So, how many partitions are there here? Yeah. One says four, one
            says six.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有人吗？你刚刚取了平均值。一共有 5 个。所以，有 a、b、c。有 a、b、c。a、b、c。哪一个——哎呀——哪一个小于哪一个？清楚了吗？是的，我想我已经这样做了。是的。第一层较小。当这个小于这个、这个小于这个、这个和这个时，我会画一个箭头。但是这些都不小于其他任何一个。那么，我们在做什么？</font></font></p><p>Anyone else? You just took the average. There’s five. So, there’s a,
            b, c.&nbsp;There’s a, b, c.&nbsp;a, b, c.&nbsp;And which one’s—oops—and which one’s
            less than which? Is that clear? Yeah, I guess I did do that. Yeah. The
            first layer is less. I’ll draw an arrow when there’s this one’s less
            than this one, this one’s less than this one, this one, and this one.
            But none of these are less than any other of these. So, what is it that
            we’re doing?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们习惯于对事物进行排序，也习惯于认为事物是有序的。多或少。秩序是关于多与少。这是在——在第二个中，不是，是的。让我们再看看我的定义。所以，a、b、c。在这个中，我们有这个家伙，这个斑点，还有这个斑点。我们有那个。在另一个中，我们又有两个，但现在 a 和 b 合并了，而 c 是不同的。哦，好吧。没有从二到二的函数可以纠正这个差异。</font></font></p><p>So, we’re used to ordering things, and we’re used to thinking about
            things being in order. Something being more or less. Order is about more
            and less. That’s in—in the second no, yeah. Let’s look at my definition
            again. So, a, b, c.&nbsp;In this one, we have this guy, this blob, and this
            blob. And we have that. And in the other one, we have again two, but now
            a and b are combined, and c is different. Oh, okay. And there’s no
            function from two to two that will rectify this difference out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我们按照这个方法，我们无法绘制出任何函数，那么我的意思是，我们无法让它工作。所以，这里我们得到 a 工作，b 工作，但 c 失败。你无法纠正这一点。是的。但是每个函数，每个分区都小于或等于其自身。每个。是的。是的。所以，这小于或等于其自身，小于每个。一切都总是小于或等于其自身。如果这个小于或等于这个，而这个小于或等于这个，而这个小于或等于这个。</font></font></p><p>There’s no function we could draw where if we follow this, and then I
            mean, we—we can’t make this work. So, here we get a works, b works, but
            c fails. And you can’t rectify that. Yeah. But each of those functions,
            each of those partitions is less than or equal to itself. Each. Yeah.
            Yeah. So, this is less than or equal to itself, less than each.
            Everything’s always less than or equal to itself. And if this one’s less
            than or equal to this one, and this one’s less than or equal to this
            one, and this one’s less than or equal to this one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你可以通过任何路径到达那里，那就很好了。现在，我要说的正是这一点：我们习惯于思考顺序，但什么</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">顺序？顺序，但人们实际上称之为预序。我认为这就是顺序的本质。预序是：一，集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">；二，它是一个关系
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r ，是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子集</font><font style="vertical-align:inherit">。但人们不写</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，而是写一个奇怪的符号；他们写了那个，但它只是一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，他们用中缀表示法来写它。
        </font></font></p><p>So, if you can follow any path to get there, you’re good. And now,
            what I was about to say is exactly this: we were used to thinking about
            orders, but what <em>is</em> an order? An order, but people actually
            call it a pre order. I think this is kind of the essence of order
            myself. A pre order is: one, a set <em>s</em>; and two, it’s a relation
            <em>r</em>, a subset of <em>s</em> × <em>s</em>. But people, instead of
            writing <em>r</em>, they write a weird symbol; they write that, but it’s
            just an <em>r</em>, and they write it in infix notation.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">中缀表示法意味着，它们不会写成</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s1 </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s2</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">在
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，或在 r 中，或等于，而是写成</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于或等于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s2</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。中缀表示法，如果你擅长计算机，你知道如何让你的关系具有中缀表示法，但我不擅长计算机，所以我只是让其他人这样做。但中缀表示法对于读取关系非常方便。出于某种原因，这很难读取。这没关系。但它们必须满足两个属性，而这两个属性正是我们刚才提到的。
        </font></font></p><p>Infix notation means instead of writing <em>s1</em> <em>s2</em> is in
            <em>r</em>, or is in, or equal to, they write <em>s1</em> is less than
            or equal to <em>s2</em>. Infix notation, and if you’re good at
            computers, you know how to make your relations have infix notation, but
            I’m not good at computers, so I just let other people do that. But infix
            notation is very convenient for reading relations. This is much harder
            to read for some reason. This is okay. But these have to satisfy two
            properties, and there are exactly the two we mentioned just a second
            ago.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">即：a，对于</font><em><font style="vertical-align:inherit">s</font></em><font style="vertical-align:inherit">中的所有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，</font><em><font style="vertical-align:inherit">s</font></em><font style="vertical-align:inherit">都小于或等于其自身；b，对于</font><em><font style="vertical-align:inherit">s</font></em><font style="vertical-align:inherit">中的所有</font><em><font style="vertical-align:inherit">s1</font></em><font style="vertical-align:inherit">、
             </font><em><font style="vertical-align:inherit">s2</font></em><font style="vertical-align:inherit">、</font><em><font style="vertical-align:inherit">s3</font></em><font style="vertical-align:inherit">，如果</font><em><font style="vertical-align:inherit">s1</font></em><font style="vertical-align:inherit">小于或等于</font><em><font style="vertical-align:inherit">s2</font></em><font style="vertical-align:inherit">，且</font><em><font style="vertical-align:inherit">s2</font></em><font style="vertical-align:inherit">小于或等于
            </font><em><font style="vertical-align:inherit">s3</font></em><font style="vertical-align:inherit">，则</font><em><font style="vertical-align:inherit">s1</font></em><font style="vertical-align:inherit">小于或等于</font><em><font style="vertical-align:inherit">s3</font></em><font style="vertical-align:inherit">。因此，第一个条件称为反身条件，第二个条件称为传递条件。因此，它表示所有事物都小于或等于其自身，并且如果某事物小于或等于其他事物，而该其他事物又小于或等于其他事物，则一直进行下去。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>And that is: a, that for all <em>s</em> in <em>s</em>, <em>s</em> is
            less than or equal to itself; and b, that for all <em>s1</em>,
            <em>s2</em>, <em>s3</em> in <em>s</em>, if <em>s1</em> is less than or
            equal to <em>s2</em>, and <em>s2</em> is less than or equal to
            <em>s3</em>, then <em>s1</em> is less than or equal to <em>s3</em>. So
            the first one’s called reflexive, and the second one’s called
            transitive. So it says that everything is less than or equal to itself,
            and that if something’s less than or equal to something else, which is
            less than or equal to something else, go all the way.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，任何小于或等于的有限长度路径都会给出小于或等于的结果。好的，所以我应该说，好的，我们现在有了这个顺序，我想说的最后一件事是顺序创建了一个连接。顺序创建了连接两个系统的概念，就像我们之前做的那样。假设你想连接这个分区，连接另一个分区。他说，也许你可以看到这将是一个很大的分区，但你实际上可以根据顺序来获得它。</font></font></p><p>So any finite length path of less than or equal to gives you less
            than or equal to. Okay, so I’m supposed to say that, okay, we have this
            order now, and the last thing I want to say is that order creates a
            join. Order creates the notion of joining two systems, like we did
            before. Say you want to join this partition, join another partition. He
            said that maybe you could see that that would be this big partition, but
            you can actually get it in terms of the order.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">两个分区的连接是比两个分区都大的最小分区。因此这两个分区的连接是这个。这两个分区的连接是这个。两个分区的连接比两个分区都大，但比两个分区都大的最小分区。因此连接不是那么重要。更基本的是顺序。然后，我们正在寻找带来事物的基本要素，并提出我们看到的现象。我们想谈谈母亲、父母和孩子如何与同事和朋友建立这种关系，我们谈论连接，但更基本的是这种顺序，我们可以在这种顺序中做到这一点和其他事情。</font></font></p><p>The join of two partitions is the least partition bigger than both of
            them. So the join of these two is this one. The join of these two is
            this one. The join of two partitions is something bigger than both, but
            the least thing bigger than both. And so joining is less fundamental.
            What’s more fundamental is order. We, and then we’re kind of searching
            for what are the fundamental pieces that bring things, bring up the
            phenomena we see. We want to talk about how the mother and the parent
            and the child have this relationship with the coworker and a friend, and
            we talk about joining, but more fundamental is this order where we can
            do that and other things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想我会在这里停下来，总结一下课程，然后结束。</font></font></p><p>So, I think I’ll stop here, summarize the class, and then wrap
            up.</p>
        <h2 id="course-summary-and-future-topics"><font style="vertical-align:inherit"><font style="vertical-align:inherit">课程概要和未来主题</font></font></h2><h2>Course Summary and Future
            Topics</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，当然，这有点困难，从零开始还要保持有趣。所以，这种生成效应的想法，比如父母和孩子等等，可能有点平淡，但我们会谈到更有趣的事情。正如我所说，我们将讨论资源理论，比如，你想从一种化合物构建一种化学物质到一堆其他化合物。这些都是资源，或者你想制造某种东西。</font></font></p><p>So, of course, this was—it was kind of difficult to start from
            nothing and still be interesting. So, this generative effects idea,
            where like the parent and the kid and all that, it’s kind of a little
            flat, maybe, but we’re going to get to more interesting things. And as I
            said, we’re going to talk about resource theories, which are, say, you
            want to build one chemical from one compound to a bunch of others. Those
            are resources, or you want to manufacture something.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你有锤子、钉子、木头和铰链，你想制作门、建筑物和类似的东西。所以，这些都是资源。我们将讨论数据库以及将数据从一个数据库转换到另一个数据库。如果你有一家公司或什么，或者有很多不同的数据库系统在运行，你想在它们之间移动信息，那将是第 3 章。在第 4 章中，你将协作设计一个机器人。比如说，该协作设计项目中的每个部分都有它需要其他部分的东西。</font></font></p><p>You’ve got hammers and nails and wood and hinges, and you want to
            make doors and buildings and stuff like that. So, these are resources.
            We’re going to talk about databases and transforming data from one
            database to another. If you have a company or something, or lots of
            different database systems working, and you want to move information
            between them, that’ll be Chapter 3. In Chapter 4, you’re collaboratively
            designing a robot. Say, each piece in that collaborative design project
            has things that it requires from others.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我需要你这个，我也能提供那个。而且我可能不需要我供应的那个人。某种易货系统。底盘需要电池中的某些东西，但电池需要由其他东西（底盘）承载。但马达——它们都在共同努力，使这个机器人快速可靠地运行。所以，当你再次放大到马达时，你就得到了你需要的东西——你需要满足的约束——以及你想要提供的东西。</font></font></p><p>I’m going to need from you this, and I’m going to be able to supply
            that. And I might not be needing from the same person I’m supplying to.
            Some kind of barter system. The chassis needs something from the
            battery, but the battery needs to be carried by something else—the
            chassis. But the motor—they’re all working together to make this robot
            go fast and reliably. And so, when you zoom in to just the motor again,
            you’ve got things you need to—constraints you need to satisfy—and you
            have things you’re trying to provide.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们将在第 4 章中讨论如何根据您提供的内容和需要的内容协作设计大型项目。这叫做 profun。然后我们将讨论信号流，这是克劳德·香农 (Claude Shannon) 1940 年代的东西。第 5 章，我们将讨论电路。然后第 7 章，我们将讨论行为逻辑，这就像空域系统的不同部分。如今，您拥有不同的飞机，它们使用地面控制、雷达和防撞系统来创建更大的空域属性，其中没有两架飞机彼此太近。但行为是随着时间的推移而发生的。因此，我们也会讨论时间和类似的东西。就这样。</font></font></p><p>And so, that question of collaboratively designing a big project in
            terms of what you offer and what you need is what we’ll do in Chapter 4.
            Something called profun. And then we’ll talk about signal flow, which is
            Claude Shannon, 1940s stuff. Chapter 5. We’ll do, or 6, we’ll do
            circuits. And then 7, we’ll do the logic of behavior, which is like
            different parts of the airspace system. You’ve got different airplanes
            today, and they’re using ground control and radar and collision
            avoidance systems to create a larger property of the airspace where no
            two planes get too close to each other. But behavior is taking place
            over time. So, we’ll talk about time and stuff like that, too. So,
            that’s it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是本课程的结构是，我们有 50 分钟的讲座时间。希望我们通常能够比这次有更多的互动。出于某种原因，我感到沮丧。时间有限，但在之后的 30 分钟内，任何想留下来的人都可以留下来，自言自语，与我们交谈，做任何事情。所以，没关系。</font></font></p><p>But the way this course is structured is we have this 50 minute
            lecture period. Hopefully, usually, we’ll be able to have more
            interaction than we did this time. For some reason, I felt depressed.
            For time, but in the 30 minutes after, anyone who wants to can stay,
            talk to themselves, talk to us, and just do kind of whatever. So, that’s
            okay.</p>
        <h2 id="housekeeping-announcements"><font style="vertical-align:inherit"><font style="vertical-align:inherit">客房清洁公告</font></font></h2><h2>Housekeeping Announcements</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。有两个房间通知。第一个：这里人很多，我打算明天去换一间大一点的房间。我不确定我是否能做到。他们能给我们的只有这些。周四要求了时间，但请保持更新；新房间会在网站上公布。就在网站上，或者如果你去网站点击“给我发电子邮件”或“邮件列表”之类的，你可以给我发电子邮件，我会把你列入名单。然后我会给你发一个更大的房间的通知。希望如此。</font></font></p><p>Okay. Two housekeeping announcements. First one: There are a lot of
            people here, and I’m going to try and get a bigger room for tomorrow.
            I’m not sure if I’ll be able to. This is all they could give us. A time
            was requested on Thursday, but stay updated; the new room will be on the
            website. Which is there, or if you go to the website and click “email
            me,” click “mailing list,” or something, you can email me, and I’ll put
            you on a list. Then I’ll send you an announcement with a larger room.
            Hopefully.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第二件事是针对那些为了学分而选修这门课程或只是对做一些练习并讨论它们感兴趣的人。网上有一份练习表。它仍然是草稿形式。今天结束前会完成。然后，显然是通过压倒性的民意投票，现在截止，不是星期一，而是星期二，因为星期一是假期。所以，星期二上课，无论如何我都会把它发布到网上。</font></font></p><p>The second thing is for those of you who are either taking the course
            for credit or just interested in doing some exercises and talking about
            them. There’s an exercise sheet online. It’s still in draft form. It’ll
            be done by the end of today. And then, it’s apparently by overwhelming
            popular vote, due now, not Monday, but Tuesday, because Monday is a
            holiday. So, beginning class Tuesday, I’ll post that online anyway.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你愿意的话就过来打个招呼吧。</font></font></p><p>Come say hi if you feel like it.</p>
        <h1 id="applied-category-theory.-chapter-1-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 1 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 1, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 16 日) — 53:50 </font></font><a href="https://youtube.com/watch?v=2BYl7NgHjvc"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=2BYl7NgHjvc</font></font></a></p><p> 6
            years ago (Jan 16, 2019) — 53:50 <a href="https://youtube.com/watch?v=2BYl7NgHjvc">https://youtube.com/watch?v=2BYl7NgHjvc</a></p>
        <h2 id="summary-1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这门麻省理工学院课程 (18S097) 由 David Spivak 和 Brendan Fong 在独立活动期间 (IAP) 讲授，介绍了应用范畴论。讲座涵盖了预序、真值表和幂集等示例以及交集和并集的概念。它探讨了单调映射、伴随（或 G 连接）以及它们与通用属性的关系。该课程强调了最大公约数和最小公倍数等熟悉的数学概念如何从这些抽象结构中产生。</font></font></p><p>This MIT Course (18S097), taught by David Spivak and Brendan Fong
            during Independent Activities Period (IAP), introduces applied category
            theory. The lecture covers preorders, examples like truth tables and
            power sets, and the concepts of meet and join. It explores monotone
            maps, adjunctions (or G-connections), and how these relate to universal
            properties. The course emphasizes how familiar mathematical concepts
            like greatest common divisor and least common multiple arise from these
            abstract structures.</p>
        <h2 id="housekeeping-and-problem-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">家务管理和问题集</font></font></h2><h2>Housekeeping and Problem
            Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想我应该从三件小事开始谈。</font></font></p><p>I guess I’ll start with three small housekeeping matters.</p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">恭喜您找到这个房间。希望我们能在这里度过课程的剩余时间，现在你们都有座位了。</font></font></p>
            </li><li>
                <p>Congratulations on finding this room. We’ll hopefully be here for
                    the rest of the course, and you all have your seats now.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你关心问题集，网上有一个。我们真正关心的是认真学习。所以，我不知道，希望玩得开心。不要太紧张。如果你对某个问题感到兴奋，只想写很多关于这个问题的内容，其中一些是相当开放的。你可以随意写一些东西，而不是试图完成。</font></font></p>
            </li><li>
                <p>If you care about problem sets, there’s one online. All we really
                    care about is a serious attempt to learn. So, I don’t know, hopefully
                    have fun. Don’t stress too much. If you get excited by some problem and
                    just want to write a lot about that problem, a few of them are fairly
                    open ended. Feel free just to write about something in rather than
                    trying to be complete.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后，视频似乎比上次好多了。所以，它在网上；它在 YouTube 上，你可以在课程网页上的链接上找到它。</font></font></p>
            </li><li>
                <p>Lastly, the video seems to have sort of worked from last time.
                    So, it’s on the internet; it’s on YouTube, and you can find it at the
                    link on the course webpage.</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我们开始吧。</font></font></p><p>Okay, so let’s begin.</p>
        <h2 id="definition-of-preorder"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预购的定义</font></font></h2><h2>Definition of Preorder</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">昨天，我们终于看到了预序的定义。那么，让我提醒一下你这是什么。预序是一个集合和一个关系。因此，它是一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">T</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，一个关系 ≤ ⊆ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">T</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">T</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这样：</font></font></p><p>So, yesterday, we saw, in the end, this definition of a pre order.
            So, let me remind you what this is. A pre order is a set and a relation.
            So, it is a set <em>T</em>, a relation ≤ ⊆ <em>T</em> × <em>T</em>, such
            that:</p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">将此关系写为中缀形式，我们称</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ≤ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。因此，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ≤ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">属于此关系。</font></font></p>
            </li><li>
                <p>Writing this relation in infix, we say <em>x</em> ≤ <em>x</em>.
                    So, <em>x</em> ≤ <em>x</em> is in this relation.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ≤ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">且</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ≤ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">z</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，则</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ≤ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">z</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font></p>
            </li><li>
                <p>Such that if <em>x</em> ≤ <em>y</em> and <em>y</em> ≤ <em>z</em>,
                    then <em>x</em> ≤ <em>z</em>.</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个够大吗，可以让每个人都在后面看书？太棒了。我声音够大吗？太好了。</font></font></p><p>Is this large enough for everyone to read in the back? Cool. I’m loud
            enough? Great.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么我们为什么要关心这个结构呢？</font></font></p><p>Okay, so why do we care about this structure?</p>
        <h2 id="examples-of-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预订示例</font></font></h2><h2>Examples of Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">首先，我们昨天看到了很多有趣的例子，接下来的半个小时我们会看到更多。但其次，这是一门应用范畴论课程，而预序恰好是基本例子之一，或者说是范畴的基本类。或者，预序必须是一个基本范畴。所以，当你探索范畴论中的概念时，有一件事通常非常有启发性，那就是探索预序设置中该概念的含义。所以，这就是我们在整个讲座中要做的一部分。</font></font></p><p>First, we saw a bunch of interesting examples yesterday, and we’ll
            see more in the next half hour. But second, this is a course on Applied
            Category Theory, and a pre order happens to be one of the elementary
            examples, or an elementary class of categories. Or, pre orders have to
            be an elementary category. So, much of when you’re exploring concepts in
            category theory, one thing that’s often very sort of, I don’t know,
            illuminating to do is explore the implications for that concept inside
            the setting of pre orders. And so, that’s part of what we’ll do
            throughout this lecture.</p>
        <h2 id="monotone-maps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">单调地图</font></font></h2><h2>Monotone Maps</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这种情况通常被称为反身性。 命名它。 这通常被称为传递性。 但它们是其他范畴概念的影子。</font></font></p><p>This condition is often called reflexivity. To name it. And this is
            often called transitivity. But they’re shadows of other categorical
            notions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，让我们举手回答一下。在应用范畴论课程中，谁以前见过范畴的概念？谁现在愿意在黑板上写下这个描述？谁以前从未听说过？</font></font></p><p>So, just a quick show of hands. Who has, in the Applied Category
            Theory course, seen the notion of a category before? Who is who would be
            comfortable writing the description on the board right now? And who has
            never heard of it before?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，太好了。听众们都很棒。对于那些之前没有看过的人，只要记住这个概念是一种类别。所以，我们已经进入了类别论。对于那些之前看过定义并熟悉它的人来说，你可能想要想出两个比这更精确的陈述。预序是一种通常只处理动态的类别，所以如果你有定义，应该很容易探索。稍微复杂一点的是，预序是一个完全丰富的类别。所以这只是让人们思考的事情。如果这是对他们的复习，那么下周每个人都应该理解这些陈述。好的。</font></font></p><p>Okay, so that’s great. It’s a great audience. For those of you who
            haven’t seen it before, just take away that this notion is this is a
            sort of category. So, we’re already inside category theory. For those
            that have seen the definition before and are familiar with it, you may
            want to think of, say, two more precise statements than that. A preorder
            is a category that most often just deals with dynamics, and so should be
            easy to explore if you have the definition. Something slightly more
            complicated is that a pre order is a full enriched category. So that’s
            just something for people to think about. If this is review to them,
            everyone should understand those statements next week. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">昨天我们看到的另一个有趣的定义是交并合并。我想要的符号是——如果我们有一个前序 P，并且我们在这个前序中有一些元素子集，那么我们说这个前序 P 中的一些元素是 A 的交，如果对于所有 p 都是——那么 p 就是下界，对吧？所以 p 是下界，m 也是最大下界。这意味着对于所有 q 和 p，q 也是 A 的下界，对吧？所以，对于 A 中的所有 a，q 小于 p，这样就可以了。</font></font></p><p>So, the other interesting definition we saw yesterday was that of
            meet and join. So, notation I want—so if we have a pre order P and we
            have some subset of elements in that pre order, then we say that some
            element of that pre order P is a meet of A if for all p is—so that is
            that p is a lower bound, right? And so p is a lower bound, and m is also
            a greatest lower bound. So that means that for all q and p such that q
            is also a lower bound of A, right? So, such that for all a in A, q is
            less than p, is okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们昨天看到的符号是这个角符号。所以我们写 e 等于——我们可以说它是 A 的交。它也可以是 A 的交——a 在 A 中。或者昨天，我们看到了这样的符号，其中 a1 到 an 具有 A 的元素。这并不是说 A 是有限的，但在有限的情况下，我们有点——我们可以这样写。具体来说，在 A 有两个元素的情况下，我们写——我们称它们为 a 和 b——然后我们写 a 交 b。</font></font></p><p>So, the notation we saw yesterday was this horn symbol. So, we write
            e is equal to—we could say the meet of A. It could also be sort of the
            meet of A—a is in A. Or yesterday, we saw notation like this, where
            these a1 to an have the elements of A. This is not to say that A is
            finite, but in the finite case, we sort of—we might write this. And in
            particular, in the case that A has two elements, we write—let’s call
            them a and b—then we write a meet b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，连接是——这是最大上限，是最小上限。所以，这是同样的想法，但是你把所有的不等式都反转了。</font></font></p><p>Similarly, a join is—this is a greatest upper bound, is a least upper
            bound. So, it’s the same idea, but you reverse all the inequalities.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我们看一些例子。所以，一个非常基本的偏序集合是一个偏序集合，或者，与那条语句中出现的偏序集合相同。因此，我将使用称为哈斯图的约定来写偏序集合。但具体来说，它是一堆点，我将在这里将它们写为 T 和 F，分别表示真和假。它们之间有一个箭头，表示顺序。所以，这是预序，其集合 P 为 T 和 F。因此，它的顺序是 F 小于真。但是，要使其成为偏序集合，您需要将其封闭在 — 抱歉，预序集合下。偏序集合是另一个类似的词，在本课程中，我将使用它作为相同的词。您需要封闭在这两个语句下。因此，具体来说，真小于真，假小于假。</font></font></p><p>Okay, let’s see some examples then. So, a very elementary poset is a
            poset or, which is the same poset that appears in that statement over
            there. So, I’m going to write posets using this convention called a
            Hasse diagram. But in particular, what it is, it’s a bunch of points,
            which I’m going to write here as T and F for true and false. And there’s
            an arrow between them indicating the order. So, this is the pre order
            which has the set whose set P is T and F. So, and it has the order that
            F is less than true. But also, for it to be a poset, you need to close
            under—sorry, a pre order. A poset is another similar word, and I’ll use
            it basically as the same word in this course. You need to close under
            these two statements. So, in particular, true is less than true, and
            false is less than false.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那又怎么样？让我们计算一下这个偏序集中的二元交点。那么，真交真会是什么呢？它是什么？它是最大下限。它是后置集中的一个元素。它既小于或等于，又小于或等于，并且小于或等于任何其他小于或等于这两个值的东西。那么，这是什么意思呢？想法？是的，这是真的。这就是我所说的。它最终会说真话。</font></font></p><p>Okay, so what? Let’s compute just binary meets in this poset. So, so
            what would true meet true be? It’s the what? It’s the greatest lower
            bound. It is an element in the postset. That’s both less than or equal
            to, both less than or equal to, and less than or equal to anything else
            that is less than or equal to both of those things. So, what does that
            mean? Ideas? Yeah, it’s true. That’s what I’ve talked about. It’s used
            to end up saying true.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">同样，假的论证也非常相似。假和假的最大下限也是假。如果有真和假，最大下限必须小于真和假，所以它必须是假。而假实际上是唯一的下限。所以，我们这里有一个二元或成对相遇的表格。所以，如果你做过一些基本逻辑，你可能会注意到，这是和的真值表。</font></font></p><p>Similarly, the argument for false is very similar. The greatest lower
            bound of false and false is again false. And if you have true and false,
            the greatest lower bound has to be less than both true and false, so it
            has to be false. And false is in fact the only lower bound. So, we have
            this table here for binary or pairwise meets. So, you might notice, if
            you’ve done some elementary logic, that this is the truth table for
            and.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，如果我们对二元连接进行类似的计算，真值表的参数类型与此相同，这意味着真值表没问题。因此，这些“与”和“或”的概念只是从对这个简单的后集的分析中产生的，这个后集有两个元素，其中一个大于另一个。这些最小上界、最大下界的概念，好吗？所以，这是一个例子。让我们再看一些例子，我们会看到一些熟悉的概念。</font></font></p><p>Similarly, if we do a similar computation for binary join, the same
            sorts of arguments for the truth table as this, which means the truth
            table is alright. So, these notions of and and or just arise from the
            analysis of this simple postset here with two elements, where one is
            greater than the other. And these notions of least upper bound, greatest
            lower bound, okay? So, that’s one example. Let’s run through a bunch
            more examples, and we’ll see some familiar notions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其次，我们来谈谈幂集。对于每个集合 X，你可以将 X 的子集与包含顺序关联起来。那么，什么是 X 的子集呢？让我们选择一个特定的集合。我们将选择平方乘以我的脸的集合。对吧？那么，给定这个集合，什么是子集？好吧，它是这里的任何事物的集合，对吧？所以，有一个包含所有内容的集合。有一个什么都没有的集合，我将用这个空集符号来表示，但你也可以用中间没有任何内容的括号来表示。</font></font></p><p>So, second, let’s talk about power sets. To every set X, you can
            associate the set of subsets of X and an inclusion ordering. So, what is
            a subset of X? Let’s let’s pick a particular set. We’re going to pick
            the set that’s square times my face. Right? So, given the set, what is a
            subset? Well, it’s any collection of things in here, right? So, there’s
            the collection that has everything in there. There’s the collection of
            nothing in there, which I’m going to write with this empty set symbol,
            but you also might write with sort of brackets with nothing in
            between.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后你就得到了各种各样的对：盒子乘以盒子，笑脸乘以笑脸，然后是单个对：盒子乘以等等。为了完成这个图表，这些是这个集合的幂集的元素。包含，这个子集或包含顺序表示，当这个集合包含在另一个集合中时，我们有一个从一个到另一个的箭头。所以，盒子包含在盒子时间中，所以那里有一个箭头。它也包含在……</font></font></p><p>And then you have all the sorts of pairs: box times box, smiley face
            times smiley face, and then individual ones: box times, and so on. To
            complete this diagram, these are the elements of this power set of this
            set. And inclusion, this subset or inclusion ordering says that we have
            an arrow from one to the other when this one set is contained in
            another. So, box is contained in box times, so there’s an arrow there.
            It’s also contained in…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有类似的箭头。空集包含一切，每个集合都包含一切。所以，你会注意到他们没有画出，例如，从盒子到一切的箭头，但这在路径的事实中是隐含的。这里是传递性的概念。好的，我们有另一个帖子集，我想思考一下在这个设置中交点和连接点是什么。事实证明，交点等于交点。所以，让我们考虑一下。</font></font></p><p>There are similar arrows. The empty set is contained in everything,
            and every set contains everything. So, you’ll notice they haven’t drawn,
            for example, the arrow from box to everything, but that’s sort of
            implicit in the fact of the path. And this notion here of transitivity.
            Okay, so we have another postset, and I want to think about what the
            meet and join are in this setting. It turns out that meet is equal to
            intersection. So, let’s think about this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我有集合 A 和集合 B，集合 A 和 B 的交集的下限是任何同时包含在 A 和 B 中的元素，并且小于或等于两个集合中的任何元素。所以，它可能是这样，也可能是包含这两个元素的整个集合。但它是最大下限。所以，笑脸是最大下限。你看，笑脸是共同元素，是黑色笑脸和时间笑脸的交集。</font></font></p><p>If I have set A and set B, a lower bound of the intersection of sets
            A and B is any element that is contained in both A and B, and is less
            than or equal to any element in both sets. So, it could be this, or it
            could be the entire set that’s contained in both of these things. But
            it’s the greatest lower bound. So, the smiley face is the greatest lower
            bound. And you see that the smiley face is the common element, the
            intersection between the black smiley face and the time smiley face.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，连接就是并集。也就是说，包含两个集合的最小集合就是这两个集合的并集。所以，这很容易理解。但是，我们再次看到熟悉的概念来自预序概念和这些构造。连接。然后相遇。我们看到，现在移动得更快，昨天我们有了这个集合或分区的偏序集的想法。我们在这里看到了这个例子，我们有四个人对这些人之间的传染这个概念感兴趣。所以，有一个妈妈，一个孩子，妈妈的同事和孩子的朋友。我们有这些分区。分区一，这是白天发生的事情。这是分区二，这是晚上发生的事情。连接是最小的事情，嗯，最好的事情可以比他们两个更接近，对吧？</font></font></p><p>Similarly, join is union. That is, the smallest set containing both,
            containing two sets, is just the union of those two sets. So, it’s
            fairly straightforward to see. But again, we see familiar notions coming
            out of this notion of pre order and out of these constructions. Join.
            And meet. We saw, moving more quickly now, yesterday we had this idea of
            a poset of sets or partitions. And we saw this example here where we had
            four people who were interested in this idea of contagion between these
            people. So, there’s a mom, a kid, a coworker of the mom, and a friend of
            the kid. And we have these partitions. This partition one, which is sort
            of what happens throughout the day. This is partition two, which is what
            happens at night. And the join is sort of the least thing that, well,
            the finest thing that can be closer than them both, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">偏序集的另一个常见例子是具有通常排序的自然数。通常的排序表示一小于二小于三。因此，这与前面的例子不同，因为它是无限的。这里，我们有什么？我们有交点，即最小值。因此，如果你取它的一个子集并要求它的交点，它就是该子集的最小元素。连接将是最大值。</font></font></p><p>Another common example of a poset is the natural numbers with the
            usual ordering. The usual ordering says that one is less than two is
            less than three. So, this differs from the previous examples in that
            it’s infinite. And here, what do we have? We have meet, the minimum. So,
            if you take a subset of this and ask for its meet, it’s the minimum
            element of that subset. And the join will be the maximum.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第五个例子使用相同的集合。在讨论预序时，我们可以使用相同的集合，但我们可以采用不同的顺序。我将其称为除法顺序，即如果 a 能整除 b，那么 a 小于 b，这在自然数中很常见。那么，这是什么意思呢？预序看起来是这样的：1 位于底部，因为 1 能整除一切。接下来是素数，有这样的：4、6、9、12，等等，然后除以 0。</font></font></p><p>The fifth example uses the same set. We’re allowed to use the same
            set when we talk about preorders, but we could put a different ordering.
            And I’ll call this the division ordering, which says that, say, a is
            less than b if a divides b, sort of cleanly, as is usual for natural
            numbers. So, what does this mean? The pre order looks something like
            this: one is at the bottom because one divides everything. Next have
            primes, and have something like this: four, six, nine, here, twelve, and
            so on, and by zero.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我给你一点时间讨论。我们已经给出了邻居，但在这里，我们看到 meet 和 join 是我们熟悉的朋友。它们是众所周知的概念，你早就知道了。我给你三分钟，也许和你的邻居谈谈发生了什么，然后再回答这个问题。我想我已经看到了。对吧？那就是你只需要取非零数字。你也会得到一个网格，对吧？</font></font></p><p>Okay, I’ll give you a moment to discuss. We’ve given out our
            neighbors, but here again, we see that meet and join are our familiar
            friends. They are well known concepts that you would have known about
            for years now. I’ll give you like three minutes, maybe talk with your
            neighbors about what’s been happening and come back with an answer to
            this question. I think I think I’ve seen this right. Right? That’s you
            just take the non zero numbers. You also get a grid, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那里有 1、3，对吧？所以，基本上，你有这样的满足 x、y 的东西。所以，你仍然可以问最大的。我想我有一个很好的问题。好的。我们做得怎么样？好的。我要把这个带回来。谁有答案？有人想大声说出来吗？但是，呃，我，这篇文章，抱歉。是的，我们认为是 GCD 和 LCM。是的，那么哪一个是哪个？我猜最大下限将是最大公约数，最小上限将是最小公倍数，对吧？</font></font></p><p>Where you have one, three, time, right? So, you basically have like
            that satisfies x, y. So, then you can still ask the greatest. I think I
            have a good question. Okay. How are we doing? Okay. I’m going to bring
            this back. Who has any answers? Anyone want to shout out? But the, uh,
            me, this post, sorry. Yeah, we thought it was GCD and LCM. Yeah, so
            which one’s which? I guess greatest lower bound is going to be the
            greatest common divisor, and the least upper bound is going to be the
            least common multiple, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果某个元素是集合中所有元素的倍数，则该元素将限制该集合——高于该集合的上限。好的，很酷。还有其他评论或问题吗？元素图中的深度是否有一个词来表示？A，意思是，我想可能有词，但这不是人们抽象思考的东西。在特定应用中，是的。哦，简单地说，比如，在组合几何中，当你谈到元素的阶时。好的，好的，好的。</font></font></p><p>So something bounds a set if it’s a multiple of everything in that
            set—above bounds above. Okay, cool. Any other comments or questions that
            came out of that? Is there a word for sort of the depth in this diagram
            of an element? A, meaning, I guess there may be words, but it’s not
            something people think about in the abstract. In particular
            applications, yes. Oh, just simply say, like, in combinatorial geometry
            when you speak of like the rank of an element. Yeah, okay, yeah,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我收到的另一个好问题是会议是否始终存在以及是否可以存在多个会议。所以让我就此发表一些评论。</font></font></p><p>So another good question I got was whether meets always exist and
            whether multiple meets can exist. So let me make some remarks on
            that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">备注1：相遇或汇合可能不存在。</font></font></p><p>Remark 1: Meets or joins may not exist.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它们会因为两个原因而失败：第一个是条件 (a)，第二个是条件 (b)，对吧？所以如果一个集合没有下限，那么它就可能没有交点。举个例子，如果我们以这个整数或自然数为例，它看起来大致如此，然后我们取所有偶数的集合，然后继续向上。然后如果我们要求连接这个——最大，对不起，最小上界——它没有上界，对吧？它是 0、1、2、3、4，对吧？所以两个的交点，我称之为 n 内的 2 * n，不存​​在。连接，对不起，连接，谢谢。</font></font></p><p>They can fail for two reasons: the first is condition (a), and the
            second is condition (b), right? So a set may not have a meet if it
            doesn’t have a lower bound. So one example is if we take, if we take
            this example of the integers or the natural numbers, which looks like
            this approximately, and then we take, say, the set of all evens, and it
            continues up. Then if we ask for a join of this—a greatest, sorry, a
            least upper bound—this has no upper bound, right? It goes 0, 1, 2, 3, 4,
            right? So the meet of, the meet of, of two, I’ll call it 2 * n inside n,
            does not exist. The join, sorry, the join, thanks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个可能不存在连接的原因是可能有多个下限，但没有一个是最大的。所以，在这个特定情况下，这里有一个图表。这个偏序集有四个元素，然后下面这里的元素小于上面这里的元素。让我们看看。我不想考虑。让我们考虑一下这个集合，想想是否存在它的交集。好吧，这个元素是这个集合的下限。这个元素也是一个下限，但两者都不能与另一个相提并论。所以两者都不是最大的下限。所以同样，连接也不存在。</font></font></p><p>Another reason that a join may not exist is that there might be
            multiple lower bounds, none of which is the greatest. So, in this
            particular case, here’s a diagram. So this poset has four elements, and
            then the elements down here are less than the elements up here. So let’s
            see. I don’t want to think about. Let’s think about this set and think
            about whether a meet of that exists. Well, this element is a lower bound
            of this set. This element is also a lower bound, but neither is
            comparable to the other. So neither is a greatest lower bound. So
            similarly, a join does not exist.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第三，第二个注释是可能存在多个交集。昨天讨论了分区和从属之间的区别，你可以将它们视为非常相似的结构，但对于从属，有许多从属见证每个分区。由于它们都是等价的，所以所有这些不同的从属...任何从四元素集到单元素集的映射都被视为该对的连接，以将其简化为本质。你可以考虑这里的这个偏序集，它有两个元素，并且它们都小于彼此。</font></font></p><p>Thirdly, a second remark is that there may be more than one meet. So
            there was a discussion yesterday about the difference between partitions
            and subjections, and you can view them as very similar structures, but
            with subjections, there are many subjections that witness each
            partition. And because all of them are equivalent, all of those
            different subjections… Any map from a four element set to a one element
            set is considered a join of this pair, to reduce it to its essence. You
            might consider this poset here, which has two elements, and they’re both
            less than each other.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这是这里的总关系。所以，如果我在这里寻找任何设置的绘图，对，也许是这个。所以，这是它自己的下限，事实上它大于其他所有下限——对不起，大于其他所有下限。但这个也是。所以，它们都是这个集合的交点。所以，这暗示了一个主题，当我们转向正确的类别时，这个主题会更多地出现。但类别理论实际上只看到所谓的同构。这两点本质上是等价的，或者用术语来说，是同构的。</font></font></p><p>So it’s the total relation here. So, if I look for the drawing of any
            setup here, right, maybe this one. So, this is a lower bound of itself,
            and it’s in fact greater than every other—sorry, greater than every
            other lower bound. But so is this one. So, they’re both meets of this
            set here. So, this sort of hints at a theme that will come up more as we
            shift to categories proper. But that category theory really only sees
            things up to what is known as isomorphism. And these two points are
            essentially equivalent, or, in the terminology, isomorphic.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我们如何理解这一点呢？好吧，如果我们将其称为 a 和 b，你可以将其想象为一个更大的偏序集合的一部分，但你只有两个小于或等于彼此的元素。所以，在任何——对不起，预序中，如果 a 小于 b 且 b 小于 a，那么对于该偏序集合的所有其他元素，当且仅当 b 小于 p 时，a 小于 p，同样，当且仅当 p 小于 b 时，p 小于 a。</font></font></p><p>So, how do we, how might we understand that here? Well, if we call
            this a and b, and you might imagine this as being part of a bit larger
            poset, but you just have two elements that are less than or equal to
            each other. There’s so it’s a fact in any—any, sorry, pre order that if
            a is less than b and b is less than a, then for all other elements of
            that poset, a is less than p if and only if b is less than p, and
            similarly, p is less than a if and only if p is less than b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，总之，如果你有 n 个元素，它们彼此小于或等于，那么就偏序集的其余部分而言，它们看起来是相同的。这就是同构的概念，也是我们在某种意义上不看就工作的概念，这就是为什么我一直在说相交而不是——抱歉，而不是说相交或类似的东西，而不是相交或类似的东西。</font></font></p><p>So, all that to say, somehow, if you have n elements that are both
            less than or equal to each other, then as far as the rest of the poset
            is concerned, they look the same. And that’s sort of this notion of
            isomorphism, and this notion that we sort of work without seeing, in
            some sense, which is why I’ve been saying a meet rather than—sorry,
            rather than saying the meet or something rather than a meet or
            something.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，在继续之前，最后再说一句哲学评论。这是我们第一次提到所谓的普遍属性。所以，从某种意义上说，它是普遍的，或者说是普遍的对象，也许它是一个具有普遍属性的对象。所以，宇宙或指的是这里的量词，表示它是某种最伟大的东西，或者某种最小的东西。我们会看到……</font></font></p><p>Okay, one last philosophical remark before moving on. This is our
            first instance of what is known as a universal property. So, it’s
            universal in the sense, or universal object, maybe it’s an object that
            has a universal property. So, the universe or refers to this quantifier
            here that says it’s sort of the greatest thing of some sort, or the
            least thing of some sort. And we’ll see…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在这些例子中看到，许多熟悉的事物都可以用这种非常简单的通用属性来表征，无论是“与”和“或”，还是“交集”和“并集”，还是“最大公约数”和“最小公倍数”。我们将看到，这是我们范畴论的一个主题，即许多自然构造或看似显而易见或自然的构造之所以自然，是因为它们具有一些特征性的通用属性。因此，本课程的主题之一是……本课程的主题之一是，用通用属性来表征事物的想法不仅适用于数学，也适用于更具体的应用。</font></font></p><p>So, we see here throughout these examples many familiar things can be
            characterized by this quite simple universal property, whether it’s of
            and and or, or intersection and union, or greatest common divisor and
            least common multiple. And we’ll see it’s a theme for our category
            theory that a lot of natural constructions, or constructions that seem
            obvious or natural, are natural because they have some characterizing
            universal property. So, one of the themes of this course is… One of the
            themes of this course is that the idea of characterizing things in terms
            of universal properties applies not only within mathematics but also to
            more concrete applications.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。第二部分，我想谈谈 Max。在这个偏序集的定义中，或者在这个偏序集的例子中，我们看到了一堆元素，然后是它们之间的某种关系网。这描述了预序的结构。这是您应该研究的另一个范畴论主题：您想要研究的对象，以及它们与其他类似对象或同一类的其他对象的关系。</font></font></p><p>Okay. Section two, I want to talk about Max. In this definition of a
            poset, or in this example of a poset, we see a bunch of elements and
            then some sort of web of relationships between them. This characterizes
            the structure of a pre order. That, and this is sort of another theme of
            category theory that you should look at: objects that you want to study
            with respect to their relationship with other similar objects, or other
            objects of the same class.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们特别研究了预序的概念。预序带有预序之间关系的概念，称为单调映射。</font></font></p><p>So, in particular, we’re studying this idea of a pre order. And pre
            orders come with a notion of a relationship between pre orders called a
            monotone map.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里有一个定义：一个单调映射，我称之为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，从一个预序到另一个预序，是一个函数——我们昨天将其定义为一个规则，如果你给我一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，那么我可以给你一个
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ——作为一个函数，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p'</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，那么这个顺序就会保留。所以，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f(p)</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f(p')</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。
        </font></font></p><p>So, here’s a definition: a monotone map, which I call <em>f</em>,
            from one pre order to another, is a function—which we defined yesterday
            as a rule that takes, if you give me a <em>p</em>, then I can give you a
            <em>q</em>—as a function such that if, say, <em>p</em> is less than
            <em>p’</em>, then this order is preserved. So, <em>f(p)</em> is less
            than <em>f(p’)</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我举几个例子。另一种简单的偏序集是生命之树。对吧？所以这是一种对整个物种进行分类的方法。我们有这样的东西——我不知道——是另一种方式吗？对不起，是另一种方式吗？哪一种都无所谓。对吧？是的，好的，好的。</font></font></p><p>Okay, so let me give some examples of this. Another, sort of, simple
            poset is the tree of life. Right? And so this is a way of classifying a
            whole species. And we have things like—I don’t know—is it the other way?
            Sorry, is it the other way? Doesn’t matter which one. Right? Yeah, okay,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">事实上，让我把类别记下来。所以，我已经记住了这个王国的类别。我走错了路。对吧？倒着走。物种、属、属、科、科。不能分类，对吧？</font></font></p><p>In fact, let me write down the classes. So, has memorized this
            kingdom class. I’m going the wrong way. Right? Go backwards. Species,
            genus, genus, family, family. Can’t do class, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们有，你有这方面的一个大问题。我只会画出其中很小的一部分，但我不知道。我们可能在这里……所以，从这个生命之树上可以看出，这些东西是物种。这些可能是科。我认为是属。不，对不起。智人和人类是相反的。谢谢。这不是你的主题，是吗？不，不是。我们就是这样。</font></font></p><p>And so we have, you have sort of this is a big thing here. I’ll only
            draw a very small part of it, but I don’t know. We might have here… and
            so there is a, uh, from this, of a big tree of life that says that these
            things are species. These are probably families. I think genus. No,
            sorry. Sapiens and Homo are reversed. Thanks. This isn’t really your
            subject, is it? No, it’s not. There we are.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但关键是，有两个前序，它们之间有一张图。给定某种分类，你可以给出它，或者，给定一些……我不知道，你怎么称呼这些东西？东西？给这个……什么？分类群？是的，也许不是我的主题。它们之间存在一种功能来保留顺序。这才是我们真正想见证的。</font></font></p><p>But the point being, there are two pre orders, and there’s a map
            between them. That given some sort of classification, you can give it,
            or, given some… I don’t know, what do you call these things? Things?
            Give this… what? Taxa? Yeah, maybe not my subject there. There’s a
            function between them that preserves the order. That’s what we really
            want to witness.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个更数学的例子是这样的：如果我们有包含幂集的这个预序，我们也有自然数的这个预序，并且按照通常的顺序排列。给定某个集合
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子集，你可以计算出</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中元素的数量</font><font style="vertical-align:inherit">。我就是这么想的。
        </font></font></p><p>A more mathematical example is something like: if we have this pre
            order of the power set with inclusion, and we also have this pre order
            of the natural numbers with the usual ordering. Given some set
            <em>A</em> a subset of <em>X</em>, you can count the number of elements
            in <em>X</em>. I’m just going that way.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，如果我们有设置</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">框</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以 2，它将被映射到 2。这是人们经常使用的单调映射。另一个单调映射来自这种传染。好吧。所以我们看到我们有这四个人的分区映射，我想映射到布尔真/假，基本上问：同事和朋友有联系吗？这就是问题所在。所以我们把这个映射称为
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">fe</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。
        </font></font></p><p>So, for example, if we have the set <em>box</em> times this gets
            mapped to two. That’s a monotone map people use frequently. Another
            monotone map comes from this contagion. Well, all right. So we saw we
            have this map of partitions of these four individuals, and I want to map
            to the Boolean true/false that basically asks: are the coworker and the
            friend connected? That’s the question. So let’s call this map
            <em>fe</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，我们有这个，这是……所以这是白天，白天，人们在工作，孩子在家。所以这个映射仍然是假的，因为这两个东西不是同一连通分量的一部分。还有另一个。这也是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 plus，映射到 true 的东西将是总分区。对吗？在这个中，孩子、同事和朋友在同一个连通分量中。所以去这里……</font></font></p><p>For example, we have this one, which is… so this was day, and during
            the day, people are at work, and kids are at home. So this map is still
            false because these two things are not part of the same connected
            component. There was this other thing. This is it’s also <em>m</em> to
            plus, and something that maps to true would be the total partition.
            Right? In this one, the kid, the coworker, and the friend are in the
            same connected component. So to go here…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，与本讲座的其余部分及以后的内容相关的一个定义是，单调映射保留连接。我们就说是连接吧。这就是术语：保留连接。如果对于所有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p'</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (p ∪ p') = </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (p) ∪ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (p')。
        </font></font></p><p>So a definition that will be relevant for the rest of this lecture
            and beyond is that a monotone map preserves joins. Let’s just say joins.
            So that’s the term: preserves joins. If for all <em>p</em> and
            <em>p’</em>, <em>f</em>(p ∪ p’) = <em>f</em>(p) ∪ <em>f</em>(p’).
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么问题是：该映射是单调的吗？我告诉你是的，但也许你应该争论一下。第二：它保留了连接吗？好的。我给你两分钟时间考虑一下。抱歉。啊。</font></font></p><p>Okay, so the question is: is that map monotone? I told you yes, but
            maybe you should argue it. And two: does it preserve joins? Okay. I’ll
            give you maybe two minutes to think about that. Sorry. Ah.</p>
        <p><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">fe</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">提出了一个问题：</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是否在同一个连通分量中？因此这里有两个个体，
             </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，如果它们在同一个连通分量中，则映射为真，否则映射为假。如果你有无限的……哦，抱歉，那很糟糕。是的，抱歉，你是对的。所以我们都是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子集。我想说</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (∪a) = ∪ </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (a)。对于该符号，我还没有定义它，但它只是形式为的所有元素……
        </font></font></p><p><em>fe</em> asked the question: are <em>c</em> and <em>f</em> in the
            same connected component? So there these two individuals here,
            <em>c</em> and <em>f</em>, and it maps to true if they are and false if
            they’re not. Does it… if you have an infinite… oh, sorry, that was bad.
            Yeah, sorry, you’re right. So we’re all subsets of <em>p</em>. I want to
            say that <em>f</em>(∪a) = ∪<em>f</em>(a). With that notation, I haven’t
            defined it, but it’s just all elements of the form…
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。有人想……大家对这个问题的回答如何？有人怀疑它的表述是否正确吗？这可能会对我们有所帮助。</font></font></p><p>Okay. Does anyone want to… how are people doing in terms of this
            question? Does anyone doubt its correctness in terms of formulation?
            This might help us.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我想继续。所以，这个问题是关于
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">fe</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是否单调的。一个非正式的答案基本上是说，分区上的顺序表明，如果一个分区更接近，则一个分区小于另一个分区。如果这里的每个 blob……那么，例如，这里的这个比这里的这个更接近，对吧？所以它是单调的，因为如果两个东西在某个较小东西的同一个组件中，因为 blob 的大小只会增加，它们会随着那里的顺序变大而处于同一个东西中。
        </font></font></p><p>Okay, I want to keep moving. So, so this question about whether
            <em>fe</em> is monotone. An informal answer basically says that the
            order on the partitions says that one partition is less than another if
            it sort of is closer. If it if every blob here… so, for example, well,
            this one here is closer than this one here, right? And so it’s monotone
            because if two things are in the same component in something lesser,
            because the blobs only grow in size, they’re going to be in the same
            thing as as you get larger in there of order there.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">至于它是否保留连接，我们实际上可以使用已经在黑板上的这个例子。这个函数 fe 为假，这个函数 fe 为假，但这个函数 fe 为真。因此，fe 不保留连接，因为 fe(day ∨ night) = false ∨ false = false，但 c(day ∨ night) = true。这两个结果不相等。因此，一个重要的事实是，单调映射即使保留了一些结构和顺序，也不必保留这些通用属性。</font></font></p><p>In terms of whether it preserves joins, we can use, in fact, this
            example here that’s already on the board. The function fe of this is
            false, and fe of this is false, but fe of this is true. Therefore, fe
            does not preserve joins, because fe(day ∨ night) = false ∨ false =
            false, but c(day ∨ night) = true. These two results are not equal. So,
            an important fact, then, is that monotone maps, even though they
            preserve some structure, the order, do not have to preserve these
            universal properties.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">事实上，这就是这两个讲座标题中提到的生成效应思想，并在本书和进一步阅读材料以及早期原子论中得到了进一步发展。但关键在于，如果你从不同角度看待这些单独的系统，你会发现同事和朋友在某种程度上是分开的。但当你观察将这些系统结合起来时会发生什么时，你会发现这种分离失败了。现在，这里的信息不仅仅是这里的信息和这里的信息的连接，对吧？所以，这是值得在更复杂的情况下研究的东西，这种语言可以让你掌握它。好的。</font></font></p><p>And, in fact, this is the generative effect idea that is referred to
            in the title of these two lectures and is developed further in the book
            and the further reading, and this thesis of early atoms. But the point
            being that, if you look at different sorts of views of these individual
            systems, you see that somehow the coworker and the friend are separated.
            But when you look at what happens when you combine these systems, you
            find that this sort of separation fails. Now, that the information here
            is not just simply the join of the information here and the information
            here, right? So, this is something that’s worth studying in much more
            complicated situations, and this sort of language gives you a handle on
            that. Okay.</p>
        <h2 id="g-connections-and-adjoints"><font style="vertical-align:inherit"><font style="vertical-align:inherit">G 连接和伴随</font></font></h2><h2>G-Connections and Adjoints</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们来谈谈 G 连接的概念，它是……间隙连接也被称为连接，但这是更一般的范畴术语，它是我们在相遇和连接之后的第二种观点，它们对应于范畴论中的通用属性或通用构造的极限和余极限。好的。</font></font></p><p>Let’s move into the idea of a G connection, which is a… So, gap
            connection is also termed in a junction, but that’s more general
            categorical term, and it’s sort of the second view that we’re going to
            have after meets and joins, which correspond to limits and colimits of
            universal properties or universal constructions in category theory.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，第 3 部分：连接。所以，G 连接……这是定义：G 连接是一对偏序集 P 和 Q 以及态射，因此单调映射 F 和 G。我要写下——这只是了解这种结构的符号——这两个偏序集和两个前序以及两个映射用于 G 连接。所以，它是这样的：G mon 的顺序是这样的，如果对于 P 中的所有 P 和 Q 中的 Q，当且仅当 T 小于 Q 中的 G，P 的 F 小于 Q。</font></font></p><p>So, Part 3: Connections. So, a G connection… This is the definition:
            G connection is a pair of posets P and Q and morphisms, so monotone maps
            F and G. And I’m going to write that—that’s just notation to know this
            sort of structure here—these two posets and two pre orders and two maps
            for a G connection. So, it’s this thing: orders G mon such that, if for
            all P in P and Q in Q, F of P is less than Q if and only if T is less
            than G of Q.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我们举几个例子来说明这个想法。一……好的，是……哦，很简单：我们有整数和实数。所以，它们之间有这种相当明显的单调映射，也就是乘以三，对吧？那么，它有什么作用呢？这里的这个……如果我们取整数 5，那就是 15。现在，这个东西恰好有左伴随和右伴随。我们只关注左伴随。左伴随在数学上看起来有点奇怪，但我们却很熟悉。</font></font></p><p>Okay, let’s give some examples of this idea. One… Okay, is… Oh, it’s
            simply this: we have the integers and the real numbers. So, and we have
            this sort of quite obvious monotone map between them, that the same
            multiplication by three, right? So, what does it do? This thing here… If
            we take the integer 5, and that’s it to 15. Now, this thing happens to
            have both left and right adjoints. Let’s just focus on the left adjoint.
            And the left adjoint happens to be something that sort of appears kind
            of weird mathematically, but is familiar to us.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是右伴随。这是……是的，抱歉。这是箭头指向左伴随的方向。所以我要告诉你右伴随。我可以告诉你左伴随。adint 是数字除以三后的下限。那么，这是什么意思呢？这意味着我们取某个数字——比如 3.3——我们将其除以三，然后取小于它的最大整数。这映射到 1。</font></font></p><p>This is the right adjoint. This is… Yes, sorry. This is the arrow
            goes in the direction of the left adjoint. So, I’m telling you about the
            right adjoint. I could tell you about the left adjoint. The adint is the
            floor of the number divided by three. So, what does this mean? It means
            we take some number—let’s take 3.3—we divide it by three, and then we
            take the integer that’s the greatest integer less than it. This maps to
            one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以，这两个是 ADINT。这里的 ADINT 条件是什么意思？这意味着，如果我们有某个整数</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和某个实数</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，那么</font><font style="vertical-align:inherit">当且仅当</font><em><font style="vertical-align:inherit">n</font></em><font style="vertical-align:inherit">小于</font><font style="vertical-align:inherit">小于
            </font><em><font style="vertical-align:inherit">x /3 的最大整数时，3 </font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n才小于</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。所以，这个连接或伽罗瓦连接的概念描述了这个向下函数的概念。同样，这个三是一个参数；我们选择哪个整数并不重要。所以，如果我在这里选择一个，那么就会有一个包含函数将整数映射并将它们视为实数，而实数的向下函数就是它的右 ADINT。事实上，向上函数是左伴随函数。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>Okay. So, these two things are ADINT. What does this ADINT condition
            mean here? This means that if we have some integer <em>n</em> and some
            real number <em>x</em>, then 3<em>n</em> is less than <em>x</em> if and
            only if <em>n</em> is less than the greatest integer less than
            <em>x</em>/3. So, this notion of a junction or a Galois connection
            characterizes this notion of a floor function. Similarly, this three is
            sort of a parameter; it doesn’t matter which integer we choose. So, if I
            choose one here, then there’s an inclusion that maps the integers and
            views them as real numbers, and the floor of a real number is the right
            ADINT to that. In fact, the ceiling is the left adjoint.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">作为第二个例子，我们可以考虑存在量词和全称量词。让我们开始吧。所以，如果我们有一个函数，如果我们有两个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">以及它们之间的一个函数，那么我们实际上会得到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x的幂集和</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的幂集之间的两个伽罗瓦连接</font><font style="vertical-align:inherit">，它们是我们之前看到的后集。所以，我先给它们命名，然后告诉你它们是什么。所以，我们有
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f ，从</font><strong><em><font style="vertical-align:inherit">y</font></em></strong></font><strong><font style="vertical-align:inherit"><font style="vertical-align:inherit">的幂集到</font><em><font style="vertical-align:inherit">x</font></em><font style="vertical-align:inherit">的幂集</font><font style="vertical-align:inherit">，然后反过来，我们得到了</font><em><font style="vertical-align:inherit">f</font></em></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em></strong><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它被称为，然后是</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f***。
        </font></font></p><p>As a second example, we can think about existential and universal
            quantifiers. Let’s go there. So, if we have a function, if we have two
            sets <em>x</em> and <em>y</em> and a function between them, then we get,
            in fact, two Galois connections between the power set of <em>x</em> and
            the power set of <em>y</em>, which are the post sets we saw earlier. So,
            I’ll give them names first and then tell you what they are. So, we have
            <em>f<strong>, going from the power set of <em>y</em> to the power set
                    of <em>x</em>, and then in reverse, we’ve got <em>f</em></strong>, it’s
                called, and then </em>f***.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你想知道连接点通向何方，我应该说——我猜我从来没有写下来，但为了明确起见我会说——我们称一个伽罗瓦连接由两个映射组成。我们称其中一个为左伴随，另一个为右伴随。特别地，我们称
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">为左伴随，称</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">g</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">为右伴随。但是，为了给你一些这些映射的定义，有一个明显的映射，它取</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的一个子集并返回</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的一个子集。这个映射叫做 *f**，但通常也写成</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f 1。所以，它取</font></font></em><font style="vertical-align:inherit"><em><font style="vertical-align:inherit">y</font></em><font style="vertical-align:inherit">的</font><font style="vertical-align:inherit">子集</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b并返回</font></font></em><font style="vertical-align:inherit"><em><font style="vertical-align:inherit">x</font></em><font style="vertical-align:inherit">中</font><em><font style="vertical-align:inherit">a</font></em><font style="vertical-align:inherit">的元素，
            </font><font style="vertical-align:inherit">使得</font><em><font style="vertical-align:inherit">f</font></em><font style="vertical-align:inherit"> (a) 在
            </font><em><font style="vertical-align:inherit">y</font></em><font style="vertical-align:inherit">中——b，</font><em><font style="vertical-align:inherit">对不起</font></em><font style="vertical-align:inherit">，是</font><em><font style="vertical-align:inherit">b</font></em><font style="vertical-align:inherit">。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>And if you want to know which way the junction goes, so I should have
            said—I guess I never wrote this down, but I will just to be explicit—we
            call a Galois connection consisting of two maps. We call one of them the
            left adjoint to the other, the right adjoint. And in particular, we call
            <em>f</em> the left adjoint and <em>g</em> the right adjoint. But, so,
            to give you some definitions of these maps, there’s an obvious map that
            takes a subset of <em>y</em> and gives you a subset of <em>x</em>. This
            map is called *f**, but it’s also commonly written as <em>f</em>1. So,
            it takes the subset <em>b</em> of <em>y</em> and returns the elements of
            <em>a</em> in <em>x</em> such that <em>f</em>(a) is in
            <em>y</em>—<em>b</em> sorry, <em>b</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">谢谢。我们还有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ** ，称为直接像。因此，这是</font><em><font style="vertical-align:inherit">y</font></em><font style="vertical-align:inherit">中的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的集合，存在一个</font><em><font style="vertical-align:inherit">a</font></em><font style="vertical-align:inherit">，使得</font><em><font style="vertical-align:inherit">y</font></em><font style="vertical-align:inherit"> — — 就是下面这个 — — 你的箭头指向错误的方向……谢谢。f </font><em><font style="vertical-align:inherit">**</font></em><font style="vertical-align:inherit"> ( </font><em><font style="vertical-align:inherit">a</font></em><font style="vertical-align:inherit"> ) 等于
            </font><em><font style="vertical-align:inherit">y</font></em><font style="vertical-align:inherit">。并且 y 使得对于 x 中的所有 a，如果 f(a) = a，那么 a = y 我们有一次，好的。看一个例子会很有帮助，因为它确实澄清了这些概念。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>Thanks. We also have <em>f</em>** is known as the direct image. And
            so, this is the set of <em>y</em> in <em>y</em> such that there exists
            an <em>a</em> such that <em>y</em>—and this is down here—your arrow goes
            the wrong way on the… thanks. <em>f</em>**(<em>a</em>) is equal to
            <em>y</em>. and y such that for all a in x, if f(a) = a, then a = y We
            have a one time, okay. It would help to see an example of this, because
            it really clarifies these notions.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但我要跳过这个。但你可以在课后半小时内问我，或者真的任何时候。但我想指出的是，这里的量词是存在的，并且对于所有量词来说，它们都是作为这个逆图像映射的附属物出现的。这是逻辑中极其重要的事实。但同样，我们看到了，我们将在整个课程中看到更多这样的内容，特别是在最后两节课中。但是，我想再次强调的是，我们有某种通用构造的抽象概念。</font></font></p><p>But I’m going to skip that. But you can ask me in the half hour after
            class, or anytime really. But what I wanted to point out is that these
            quantifiers here exist and for all appear as adjuncts to this inverse
            image map. And this is an extremely important fact in logic. But again,
            we see, and we’ll see more of this throughout the course, particularly
            in the last two lectures. But, but what I want to emphasize again is
            that we have this abstract notion of some sort of universal
            construction.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们看到，只要将熟悉的重要结构应用于监视器映射中的某种顺序概念，它们就会出现。其他情况，你会看到这一点。G 连接这个名字来自 G 理论，它基于域扩展和子群概念之间的这种特定 G 连接，如果你是数学专业的学生，​​你可能会看到这一点。它在解决关于五次和相交角的不可解性等千年问题方面非常重要。</font></font></p><p>And we see familiar, important structures falling about just from
            applying them to some notion of order in monitor maps. Other cases, you
            see this. The name G connection comes from G theory, which is sort of
            based on this particular G connection between this notion of field
            extension and subgroup, which you might see if you’re a math major. And
            it was sort of extremely important in solving sort of millennial
            problems about the insolubility of the quintic and intersecting angles
            and things like that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些称为关系克隆的东西之间存在着一种很酷的 G 连接，或者基本上是 CSP 中的一些关系图和一些功能图以及 3AP 之类的东西之间的连接，这允许您讨论有关可解性问题的某些难度猜想。这真的很酷。在问题集中，您会看到一个关于语用学的可爱小例子。所以，有这个概念。如果我问，或者有人问，“你喜欢这个讲座吗？”有人回答说，“我喜欢前半部分”，你可能对它的语义有特别的理解。</font></font></p><p>There’s a there’s a cool G connection between these things called
            relational clones, or basically between some relational picture and some
            functional picture in CSPs and things like 3AP, which allows you to talk
            about certain hardness conjectures about solvability problems. Which is
            really cool. In the problem set, you’ll see a cute little example about
            sort of pragmatics. So, there’s this notion. If I ask, say, or someone
            asked, “Did you enjoy this lecture?” and someone responds, “I enjoyed
            the first half,” you might have a particular understanding of the
            semantics of that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">也就是说，你享受了前半部分，谁知道后半部分呢？但你可能会合理地推断，这个人不喜欢后半部分。这是我们一直在做的一种计算，它在某种程度上体现在 GWA 连接的概念中。如果你做完这组问题，你就会明白。但在最后一分钟，我想把 GWA 连接的概念带回到保留连接的概念和生成效应的概念上，从物理上说，这是范畴论中一个非常重要的定理的预序版本。</font></font></p><p>That is literally, you enjoyed the first half, and who knows about
            the second half? But you might reasonably infer that the person didn’t
            enjoy the second half. And this is a sort of computation that we do all
            the time, that is kind of captured in this notion of GWA connection. And
            you’ll see if you do the problem set. But in one last minute, I want to
            bring this notion of GWA connection back to this notion of preserving
            joins and this idea of generative effects and physically just say a
            really the sort of pre order version of a really important theorem in
            category theory.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这被称为伴随预序。它表示监控映射</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是左伴随当且仅当它保留连接，而右伴随仅保留交。因此，具体来说，Gwa 连接的概念，或者关于找到给定映射的左或右伴随的想法，允许您争论您的特定映射（在这种情况下，您可能将其视为系统内对象的简化视图）是否有可能引入意外信息。所以，无论如何，生成效果。所以，感谢您的到来。如果您愿意，请继续聊天。</font></font></p><p>So, this is called the adjoint pre order. And it says that a monitor
            map <em>f</em> is a left adjoint if and only if it preserves joins, and
            a right adjoint only preserves meets. So, in particular, this notion of
            a Gwa connection, or whether this idea about finding a left or right
            adjoint to a given map, allows you to argue about whether your
            particular map, which you might view in this case as a simplified view
            of an object within a system, has the possibility of introducing
            unexpected information. So, generative effects anyway. So, thanks for
            coming. Stick around to chat if you like.</p>
        <h1 id="applied-category-theory.-chapter-2-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 2 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 2, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 17 日) — 48:49 </font></font><a href="https://youtube.com/watch?v=Cf3tsAeGhBg"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=Cf3tsAeGhBg</font></font></a></p><p> 6
            years ago (Jan 17, 2019) — 48:49 <a href="https://youtube.com/watch?v=Cf3tsAeGhBg">https://youtube.com/watch?v=Cf3tsAeGhBg</a></p>
        <h2 id="summary-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">麻省理工学院课程 (18S097) 讲座由 David 和 Brendan Fong (Spifong) 讲授，介绍了应用范畴论。课程涵盖了函数、参与和独立活动等主题。今年 7 月，牛津将举办一所应用范畴论学校，仅限受邀者参加。讲座讨论了函子、伴随函数和单半群范畴等范畴论概念，以及它们在资源理论、制造和化学中的应用。讲座强调了视觉辅助工具（接线图）在理解这些概念方面的重要性。讲座还涉及后集和单半群后集的公理，以及这些结构的示例。</font></font></p><p>This MIT Course (18S097) lecture, taught by David and Brendan Fong
            (Spifong), introduces applied category theory. The course covers topics
            like functions, participation, and independent activities. A school on
            applied category theory is being held in Oxford this July, by invitation
            only. The lecture discusses category theory concepts like functors,
            adjoints, and monoidal categories, and their applications in resource
            theory, manufacturing, and chemistry. The importance of visual aids
            (wiring diagrams) in understanding these concepts is highlighted. The
            lecture also touches on the axioms of post sets and monoidal post sets,
            and examples of these structures.</p>
        <h2 id="applied-category-theory-school"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论学校</font></font></h2><h2>Applied Category Theory
            School</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于应用范畴论学派的提醒。</font></font></p><p>Reminder about the Applied Category Theory School.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个应用范畴论学校将于今年 7 月在牛津举行。我认为日期大约是 12 日或 26 日，但我可能错了。它包括会议和学校。学校只接受邀请，但每个人都可以参加会议。我认为学校将有大约 20 名来自世界各地的学生，他们将与五名研究人员中的一名一起进行研究。我将是其中之一，Brendan 将担任助教。如果您有兴趣，请在 1 月 30 日之前申请。</font></font></p><p>This Applied Category Theory school is in Oxford this July. I think
            the dates are around the 12th or 26th, but I could be wrong. It includes
            both a conference and a school. The school is by invitation only, but
            everyone can come to the conference. I think there will be about 20
            students in the school from all over the world who will do research with
            one of the five researchers. I’ll be one of them, and Brendan will be a
            TA. If you’re interested, please apply by January 30th.</p>
        <h2 id="functions-and-participation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">职能与参与</font></font></h2><h2>Functions and Participation</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们开始之前还有什么问题吗？</font></font></p><p>Any questions before we start?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想简单谈谈函数，并提到另外两件事。一是参与度。参与度占总成绩的 25%。这真的很有用，特别是当你有问题时提出来。第一节课上有人问分割是单射还是最高同态。你可能以为那是一种打断，但对我来说，这实际上真的很有帮助，因为我打算稍后再讲，然后意识到我还没有提到它。这让我有一种“啊，真的很糟糕的感觉”，但是那个人问我这个问题，我就可以把它融入到讲座中。所以，如果你对某些你不理解的东西有疑问，那可能是打字错误或者应该说得更清楚。这绝对有帮助。</font></font></p><p>I wanted to talk briefly about functions and mention two other
            things. One is participation. Participation is worth 25% of your grade.
            It’s really useful, especially if you ask questions when you have them.
            Someone in the first class asked about whether partitions are
            surjections or up to morphisms. You might have thought that was an
            interruption, but for me, it was actually really helpful because I was
            going to get to that later and realized I hadn’t said anything about it.
            It gave me a “ah, really bad feeling,” but by that person asking me
            about it, I was able to fold it into the lecture as I went. So, if you
            have questions about something you don’t understand, there’s probably a
            typo or something that should be said more clearly. It’s definitely
            helpful.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一件事是，如果你有兴趣做项目。有很多途径可以做。有牛津欧洲计划、本科生研究机会计划，还有做事情、闲逛和做研究。我们也在这里。我们可以把所有的时间都花在做研究上，但我们不能把所有的时间都花在做特定的项目上。不过，我们可以指导和帮助促进这些项目。如果你对此感兴趣，请告诉我。</font></font></p><p>Another thing is if you’re interested in doing projects. There are
            various venues for that. There’s the Oxford Europe Program, the
            Undergraduate Research Opportunity Program, and just doing stuff,
            hanging out, and doing research. We’re here too. We can spend all of our
            time doing research, but we can’t spend all of our time doing particular
            projects. We can guide and help facilitate them, though. Let me know if
            you’re interested in that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们每周四还会举办一次研讨会。如果您想加入邮件列表，请与 Brendan 或我联系。</font></font></p><p>We also have a weekly seminar on Thursdays. If you want to join the
            mailing list, talk to Brendan or me.</p>
        <h2 id="junctions-in-category-theory"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴论中的连接</font></font></h2><h2>Junctions in Category Theory</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于功能……</font></font></p><p>On functions…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些也发表了很多。连接。当他们的简报说……我只是想简单地说一下，你可能有两个陪集，p 和 q。这些是全集。你有两个函子，或也称为单调映射，无论你称之为 l 还是一个你可能称之为 r。然后你有这个符号，那个奇怪的符号……也许你可以写一个小于或等于。它的意思是你有这个往返。对于所有的 p 和 e，它表示从这里开始小于往返 p，这小于我们的朋友。由于昨天的条件，与这两个不同，但与它们等同。另一个是，如果你从 q 开始并往返，它比你只是呆在那里要小。所以，q 的 r 的 l 小于 q。</font></font></p><p>These are also published a lot. Connections. When their briefing post
            says… I just wanted to briefly say that you have these maybe of two
            cosets, p and q. These are full sets. You have two functors, or also
            called monotone maps, whether you might call l and one that you might
            call r. Then you have this symbol here, and that weird symbol… maybe you
            could write a less than or equal to. What it means is that you have this
            roundtrip. For all p and e, it says that starting here is less than the
            roundtrip p, which is less than our friend. Due to conditions yesterday,
            which are different from these two, but equivalent to them. The other
            one is that if you start in q and round trip it, it’s less than if you
            just stayed there. So, l of r of q is less than q.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当人们看到这个定义时，他们会想，“嗯，这看起来不错。我很高兴你告诉我这件事。”我的意思是，它看起来不会真正帮助你的生活，但有趣的是这些会出现。我想你可以看出这是范畴论中令人惊讶的事情之一：这些出现的频率。</font></font></p><p>When people see this definition, they think, “Well, that seems fine.
            I’m glad you told me about that.” I mean, it doesn’t look like it’s
            going to really help you in your life, but what’s interesting is that
            these come up. I guess you can see that’s one of the surprising things
            in category theory: how often these come up.</p>
        <h2 id="examples-of-junctions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接点示例</font></font></h2><h2>Examples of Junctions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些为您提供了我们昨天讨论过的所有会面和加入的内容 - 会面和加入。</font></font></p><p>These give you things like all of the meets and joins we talked about
            yesterday—meets and joins.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">举个例子。我现在不会完全解释，甚至根本不会解释。以后再解释。来问我如何将交和并列看作是积和余积，积和并列，以及如何将交和并列看作是最大值和最小值，以及最小公倍数和最大公倍数，就像我们昨天做的一样。还有离散拓扑空间，它们是最无聊的，但它们仍然非常有用。有一个简化的构造。有……太多东西了，我甚至还没有想到它们全部。</font></font></p><p>So, examples. And I’m not going to explain this completely right now,
            or even at all. It’ll be further along. Come asking me about how meets
            and joins are products and coproducts, products and unions, and so makes
            and joins include max and min, and lcm and gcf, as we did yesterday. But
            also, like, discrete topological spaces, which are kind of the most
            boring ones, but they’re still very useful. There’s a reduced
            construction. There’s… so many things that I’m just not even thinking of
            them all.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你之前见过很多东西：自由群、群环、所有这些家伙、多项式环。你可能想过，“我的大生成角是什么，真的很特别吗？”好吧，它们是你从集合中注入后得到的环。每个环都有一个底层集合。所以，这是环，这是集合。你可以取环的底层集合。如果你向后移动，任何这种注入，你都会得到多项式环。所以，这些是来自范畴论的连接，这是偏序集的注入。但是，正如布伦丹所说，偏序集是一种范畴。</font></font></p><p>So many things you’ve seen before: free groups, group rings, all of
            these guys, polynomial rings. You may have thought, “What’s my big spawn
            angle, real special?” Well, they’re the rings you get from sets when you
            have an injection. Every ring has an underlying set. So, here’s rings,
            here’s sets. You can take the underlying set of a ring. If you go
            backwards, any of this injection, you’ll get polynomial rings. So, these
            are junctions from category theory, where this is an injection of
            posets. But, as Brendan said, posets are kind of categories.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在第 1 章中，我们讲解了最基本的内容。在第 2 章中，如果你今天开始，我们会……添加一层，然后继续。但我们可以看到来自数学领域的各种东西的反映，回到非常低级的偏序集层。这都是这种范畴论。这是四个范畴，而……我告诉过我人类不同的偏序集，但每个人都提到了其他的。像那样的偏序集会出现在复杂性理论中，等等。但关键是，伴随出现在那里的各个地方。</font></font></p><p>So, like, in Chapter 1, we kind of do the most basic stuff. In
            Chapter 2, if you start today, we do… we add one layer, and we keep
            going. But we can see reflections of all sorts of stuff from mathematics
            back home, back in a very low level layer of posets. It’s all this kind
            of category theory. These are four categories, whereas… and I told me
            about human different posets, but everybody mentioned other ones. Who
            posets like that will show up in complexity theory, etc. But the point
            is that adjunctions show up all over the place in there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它们非常有趣，尽管乍一看似乎很奇怪。所以，我只是想告诉你这一点。我认为我们谈论得不够多，因为我们有太多事情要做。所以，如果你对此有疑问，你并不孤单。来评论一下。右手拇指听，只是因为我昨天保存错了。哦，你留在好的，所以 Adwin 函子定理。</font></font></p><p>They’re quite interesting, even though they seem strange at first.
            So, I just wanted to kind of tell you that. I think we talked about it a
            little bit less than we could, just because we have so much to do. And
            so, if you have questions about it, you’re not alone. Come and comment
            about that. Right thumb to hear, just because I saved it wrong
            yesterday. Oh, you stay at the okay, so the Adwin functor theorems.</p>
        <h2 id="adjoint-functor-theorems"><font style="vertical-align:inherit"><font style="vertical-align:inherit">伴随函子定理</font></font></h2><h2>Adjoint Functor Theorems</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，也许人们会查一下，但我忘了加上这个条件……所以，我说 Adroid 俱乐部定理说单调函子有左伴随当且仅当它保留连接。但你必须有连接才能谈论保留它们。所以，我应该说我们假设预序有连接，右伴随和相遇的条件也是如此。Peter，frying，和……它在书中。它是关于它如何成为函子的。我们所说的监控图实际上是一种函子，或者说是保留连接的单调图。这个家伙有所有这些连接。所有可能的连接都可以连接任意数量的元素。如果 L 保留了这些，那么 L 将自动处于活动状态。</font></font></p><p>Yeah, maybe people look it up, but I forgot to include the condition
            that… So, I said that the Adroid club theorem says that a monotone
            functor has a left adjoint if and only if it preserves joins. But you
            have to have joins to talk about preserving them. So, I should have said
            that we’re assuming that the pre orders have joins, and likewise for the
            condition with right adjoints and meets. Peter, frying, and… it’s in the
            book. And it’s about how it’s a functor. What we call a monitoring map
            is actually kind of a functor, or a monotone map that preserves joins.
            And this guy has all those joins. All possible joins can join any number
            of elements. And if L preserves those, then L will automatically be
            alive.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，好的。所以，今天我们……所以，昨天我们结束了讨论帖子集的前一天。</font></font></p><p>Okay, okay. So, today we’re… So, yesterday we ended the day before we
            talk about post sets.</p>
        <h2 id="resource-theories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">资源理论</font></font></h2><h2>Resource Theories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些是关于顺序的。现在我们讨论的是幺半群闭范畴。它们就像顺序加上组合。这是我们在这里建立的最小的类别。我们从很少开始。所以，我们现在只有两件事：顺序和组合。</font></font></p><p>These are about order. And now we’re talking about monoidal closed
            categories. And these are like order plus combining. It’s kind of the
            least sort we’re building up here. We’re starting with not very much.
            So, we have now, we just have two things: order and combining.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这样做的动机是……动机是……资源理论是……嗯，资源是你拥有或可能拥有的东西。这些问题是：我能用我拥有的东西制造我想要的东西吗？现在，也许这……这就像生活的核心问题或类似的东西。是我们一直在做的事情。但这并不能解决生活的核心问题。我们不会让您总是能够判断您是否可以用您拥有的东西制造您想要的东西。但我们将提供一种基本理论，让您朝着这个方向前进。这就是资源理论的概念。</font></font></p><p>So, the motivation for this is… The motivation is… and a resource
            theory is… well, resources are things that you have or could have. And
            these are questions of: Can I make what I want from what I got? Now,
            maybe this… this is like the central question of life or something. Is
            what we’re always doing. And this is not going to solve the central
            question of life. We’re not going to get you to always be able to tell
            whether you can make what you want from what you have. But we’re going
            to give kind of a basic theory that starts you in that direction. And
            that’s the notion of resource theories.</p>
        <h2 id="example-lemon-meringue-pie"><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如：柠檬酥皮派</font></font></h2><h2>Example: Lemon Meringue Pie</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，对了。这里有一个例子：柠檬酥皮派。这是在书里写的，所以不会让人感到很惊讶，但是好吧。你有一些准备好的饼皮、柠檬黄油、糖和更多的糖。你可以做各种各样的事情。如果我有鸡蛋，我可以做蛋黄和蛋白，以及蛋黄和蛋白。如果我有柠檬黄油、糖和蛋黄，我可以做柠檬馅。如果我准备好了饼皮（如果我准备好了饼皮，我可以在这里做一些工作来准备好饼皮）和柠檬馅，我可以做一个不大的柠檬派。</font></font></p><p>Oh, right. So, here’s an example: lemon meringue pie. It’s in the
            book, so it’s not going to be very surprising, but okay. You have some
            things you have prepared crust, lemon butter, sugar, and more sugar. And
            you have various things that you can do. I can make yolk and white, and
            yolk and egg white from if I have egg. And I can make lemon filling if I
            have lemon butter, sugar, and yolk. And I can make a non big lemon pie
            if I have prepared crust (which I could have done some work over here to
            get prepared crust, if I ever prepared crust) and lemon filling.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我有蛋白酥皮和未烤制的柠檬派，那就可以做成柠檬蛋白酥皮派。我可以把它放进烤箱。我可以拿一个烤箱和这个派，然后得到这个，或者烤好的派。我会拿回我的烤箱，这真的是……人们认为那是……是的，我想这叫做耐用品。它也是一种催化剂。这个烤箱是制作派的催化剂，因为它可以让你把派烤好。</font></font></p><p>And if I have meringue and an unbaked lemon pie, that makes up a
            lemon meringue pie. And I can put this into an oven. I can take an oven
            and this pie, and I’ll get this, or baked pie. I’ll get my oven back,
            which is really… People think that’s… yeah, that’s called a durable
            good, I guess. And it’s also kind of a catalyst. This oven is a catalyst
            for pie making because it allows you to get your pie up and back (baked)
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是资源理论的一个例子。我猜，资源理论应该是一家杂货店，一个大型资源单位，因为 Whole Foods 可能会生产这些产品。那么，资源理论到底是什么呢？这里，它是某种对称的单半群集合。该集合的元素包括所有不同的成分以及所有成分的总和。因此，该集合中的一个对象是你准备好的柠檬、黄油和糖。该集合中的另一个对象或元素是柠檬馅和柠檬皮。该集合的顺序是指一个组合物是否小于另一个。因此，顺序 — 你是否说这个加上这个小于这个？而单半群结构能够组合事物。</font></font></p><p>This is an example of a resource theory. A resource theory would be,
            I guess, a grocery store, a big resource unit, because Whole Foods,
            maybe, will actually do these products. So, what is the resource theory
            actually? Here, it’s a certain symmetric monoidal poset. The poset has
            as its elements all of the different ingredients and all of the sums of
            ingredients. So, one object in the poset is you prepared cross lemon,
            butter, sugar. Another object in the poset, or element of the poset, is
            lemon filling, crust. The order of the poset is whether one combined
            thing is less than another. So, the order—do you say that this plus this
            is less than this? And the monoidal structure is being able to combine
            things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我试着真正了解一下。所以，在我正式开始之前，这是资源理论的动机。</font></font></p><p>Let me try to actually know. So, before I make that formal, this is
            the motivation for resource theories.</p>
        <h2 id="enriched-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">丰富类别</font></font></h2><h2>Enriched Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，明天，Brendan 将讨论丰富的类别。如果您有一个幺半群类别，则可以使用它来丰富其他类别。您可以将其视为尝试到达您想去的地方。或者，比如，我是否可以得到我想要的东西。我们问了这个问题。不仅有“我可以”这个布尔值，是/否，这将是布尔值和丰富的类别。但是从我想要的东西中得到我拥有的东西需要花费多少？</font></font></p><p>Then, tomorrow, Brendan will talk about enriched categories. Where
            you use, if you have a monoidal category, you can use it to enrich some
            other category. And that kind of—you could think of that in terms of
            trying to get where you want to go. Or, like, you have whether I can get
            what I want. We asked that question. There’s also not only can I, which
            is a Boolean yes/no, that’ll be Boolean and a rich category. But how
            much does it cost to make what I have from what I want?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这会帮助我从现在的位置到达我想要去的地方。这就是所谓的成本丰富类别。或者，你可以有一组方法，我可以用我已有的东西来做我想要的东西。这将是集合丰富的类别，因为方法的集合。所以，我可以是布尔值；成本是多少是另一个单半群类别；而得到我想要的东西的方法集是集合丰富的类别。这些被称为类别。所以，布伦丹明天会谈论更丰富的类别。他们有点构建了这个问题：我怎么做？我可以用什么方法做到这一点？</font></font></p><p>That’ll work to get where I want to go from where I am. That is
            what’s called cost enriched categories. Or, you can have the set of ways
            that I can make what I want from what I have. And that will be set
            enriched categories, because the set of ways. So, can I is Boolean; how
            much the cost is is another monoidal category; and what are the set of
            ways to get what I want is the set enriched category. Those are called
            categories. And so, Brendan will talk tomorrow about richer categories.
            They kind of structure this question: How can I? What are the ways that
            I can do this?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">明天，还有什么问题吗？</font></font></p><p>Tomorrow, any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。我想，也许你需要两块黄油换两块糖，对吧？是的。所以，这是个好问题。单半群运算可以是事物的元素，可以是事物的幂集。然后运算可以是并集。但它也可以是不相交并集。我……我实际上……所以，有一个中间类别，其中对象是子集，而单半群乘积是并集。所以，我稍后会更仔细地讲一下我刚才说的一切。</font></font></p><p>Yes. Maybe you need two butters for two sugars, I guess, right? Yeah.
            So, that’s a good question. The monoidal operation could be the elements
            of the thing could be the power set of something. And then the operation
            could be union. But it could also be disjoint union. I… I this actually…
            So, there’s a middle category where the objects are subsets, and the
            monoidal product is unions. So, I will say everything I just said much
            more carefully in a second.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，你说得对，这样做很好。还有其他问题吗？好的。那么，也许我们可以花一两分钟与邻居简要回顾并讨论一下什么是偏序集、偏序集的公理以及什么是哈斯图。</font></font></p><p>But, but you’re right, that would work fine. Other questions? Okay.
            So, maybe we can briefly review and discuss with a neighbor for a minute
            or two what a poset is, the axioms of a poset, and what a Hasse diagram
            is.</p>
        <h2 id="review-and-discussion"><font style="vertical-align:inherit"><font style="vertical-align:inherit">回顾与讨论</font></font></h2><h2>Review and Discussion</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们还将研究哈斯图和偏序集之间的关系。我想花一两分钟确保每个人都记住了这一点，然后我们继续。我的邻居，我觉得……哦，这里有聊天。好的。还有什么最后的想法吗？有什么问题吗？还有什么问题要问你吗？一切都好吗？好的，太好了。</font></font></p><p>We’ll also look at how Hasse diagrams and posets are related. I want
            to take a minute or two to ensure everyone remembers this, and then
            we’ll proceed. My neighbor, I feel that… oh, there’s a chat here. Okay.
            Any last ideas? Anything? Any questions come up for you? Everything
            okay? Okay, great.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，让我为你定义一下，让我定义一个叫做幺半集的东西。</font></font></p><p>So, let me define for you, let me define something called a monoidal
            set.</p>
        <h2 id="monoidal-sets-and-post-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半集和后集</font></font></h2><h2>Monoidal Sets and Post Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，你永远不会在范畴论书中看到“幺半群集”这个词。你会看到“幺半群”这个词，你实际上可以在代数教科书中找到它。但是幺半群集是一个集合，比如说，有一个函数 * (star) 取</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">与</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的笛卡尔积——集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m——</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有元组和一个公共时间，并且每对</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">都会给出一个新的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。这个符号只是一个简单的——不代表 x；它只是一个符号，好吗？这被称为幺半群积，幺半群积，这个被称为幺半群单位，这个元素。它们必须满足那个，并且</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> star </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">e</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它也等于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">e</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> star </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，好吗？</font></font></p><p>Now, you’ll never see the word “monoidal set” in a category theory
            book. You’ll see the word “monoid,” and you could actually find this in
            an algebra textbook. But a monoidal set is a set, say, with a function *
            (star) taking the Cartesian product of <em>m</em> with <em>m</em>—the
            set <em>m</em> times <em>m</em>—of all tuples, and one common time, and
            for every pair of <em>m</em>’s gives you a new <em>m</em>. And this
            symbol is just a simple—doesn’t mean x; it just means a symbol, okay?
            And this is called the monoidal product, monoid product, and this one is
            called the monoidal unit, this element. And they have to satisfy that,
            over that one, and that <em>a</em> star <em>e</em> is <em>a</em>, and
            that’s also equal to <em>e</em> star <em>a</em>, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这方面的一些例子是，自然数为 0 并且加上——我猜是加上 0。所以，这个元组 1、2、3 就是一个例子。另一个例子是自然数为 x 和 1。另一个例子是自然数的指数为 0。好吧，这不是真的。这不是真的。事实上，你什么都不能放——你——它会让这个成立，因为它不满足结合律。3 的 5 都加到 2，2 的 3 加到 2。这会起作用。这和 2 的……不一样。好吧。</font></font></p><p>So, some examples of this are, like, the natural numbers with 0 and
            plus—I guess plus in 0. So, this tuple 1, 2, 3 is an example. Another
            example is the natural numbers with x and 1. Another one is the natural
            numbers with exponentiation is 0. Okay, that’s not true. It’s not true.
            In fact, there’s nothing you can put—you—it’ll make this true because it
            failed associativity. 3 to the 5 all to the 2, 2 to the 3 to the 2. This
            will work. Is not the same thing as 2 to the… okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这些都是幺半群集。如果一个幺半群偏序集——好吧，另一个偏序集——是一个偏序集，那么幺半群函数就是单调函数，这样就保留了小于或等于关系和一个元素。然后这个……所以它完全一样——嗯，它不完全一样；它是偏序集中的幺半群对象，而不是集合中的幺半群对象。但我不会告诉你这意味着什么。这只是意味着在范畴论中，如果你有一个乘积类别，你可以定义一个幺半群——或者如果你有任何幺半群类别，你可以在其中找到一个模型。</font></font></p><p>So, these are monoidal sets. And if a monoidal poset—okay, another
            poset—is a poset, then a monoidal function is a monotone function so
            that preserves the less than or equal to relation and an element. And
            then this… so it’s exactly the same—well, it’s not exactly the same;
            it’s a monoid object in a poset instead of a monoid object in a set. But
            I’m not going to tell you what that means. That just means that in
            category theory, if you have a category of products, and you can define
            a monoidal—or if you have any monoidal category, you can find a model in
            it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">递归的一部分就是我可以如此轻松地做到这一点，你可以在整个范畴论中做到这一点，只需在这里插入任何有产品的范畴，无论是集合范畴还是偏序集范畴。你还不知道什么是范畴。我们还没有告诉你。除非你知道，否则你不知道某个类别中的产品是什么。但事实上，这种能力是存在的。这是范畴论试图为你组织起来并让你自动完成的事情。有问题吗？</font></font></p><p>And there’s part of this recursive thing where the fact that I could
            do this so easily, you can do that throughout category theory by just
            plugging any category with products in here, whether it’s the category
            of sets, or the category of posets. You don’t know what categories are
            yet. We haven’t told you. You don’t know what products in a category are
            unless you do. But the fact is that this ability exists. This is
            something that category theory is trying to organize for you and let you
            do this automatically. Questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，就是一个偏序集，那么乘积偏序集就是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">且小于且小于。我猜是这样。什么时候元组
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1, </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 小于且小于且小于且小于 1 乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 是犯罪行为？嗯，当且仅当，或者你将其定义为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 和
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 时，这才是真的。
        </font></font></p><p>So, if <em>m</em> is less than <em>m</em>, if <em>m</em> is less than
            <em>m</em>, is a poset, then the product poset is <em>m</em> times
            <em>m</em> with less than and less than. I guess so. When is a tuple
            <em>m</em>1,<em>m</em>2 less than and less than and less than and
            one times <em>m</em>2 a crime in time? Well, that’s true if and only if,
            or you define it to be that <em>m</em>1 is less than <em>m</em>1 and
            <em>m</em>2.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这个条件二说……所以，条件二说实际上要求你的单半群集的某个部分是最小偏序集。它要求如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 素数且
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 素数，那么</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 乘以
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 应该小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 素数乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 素数。
        </font></font></p><p>So, this condition number two says… so, condition two says to
            actually require something of your monoidal set to be a minimal poset.
            It requires that if <em>m</em>1 is less than <em>m</em>1 prime and
            <em>m</em>2 is less than <em>m</em>2 prime, then <em>m</em>1 times
            <em>m</em>2 should be less than <em>m</em>1 prime times <em>m</em>2
            prime.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们尝试思考中间偏序集合中的例子和一些非例子。</font></font></p><p>Let’s try to think of examples in the middle posets and some non
            examples.</p>
        <h2 id="monoidal-post-sets-and-examples"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半群柱集及例子</font></font></h2><h2>Monoidal Post Sets and
            Examples</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，为什么你们没有再来一对来回答这个问题呢？以下哪个尝试小于的自然数，其中单半群乘积为正，而单半群单位为 0？您可以找到小于和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> + 1 的实数，您可以尝试实数加 10 和 0。好的，是的。至少，哪一个是单半群……这些哪个不是……您还记得什么？</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">一对一乘以……这些哪个是单半群偏序集？</font></font></p><p>So, why don’t you guys have any pairs again, which answer this
            question? Which of these try natural numbers with less than, where the
            monoidal product is plus and the monoidal unit is 0? You can find the
            reals with less than and <em>x</em> + 1, and you can try the reals plus
            10 and 0. Okay, yeah. Which, at least, is a monoidal… which of these
            isn’t… is what did you remember? <em>x</em> on one on one in times…
            which of these is a monoidal poset?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">谢谢。所以，我们已经和你的邻居讨论过了。他们都在吗？是的，我提到了他们什么时候可能会受到关注。好的，我们正在改变政委对此的回答。</font></font></p><p>Thank you. So, we’ve discussed with your neighbor. Are they all in?
            Yeah, I mentioned when they might have some attention. Okay, we’re
            changing commissar answers to this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。第一行，有人说是，是，不是。还有其他意见吗？你们同意吗？是的，是的。那么，什么是“不是”？没错。实数的发布无法实现，因为负数不能满足这一点。也许当我写这篇文章的时候，你会想，“等等，但这不是这个的。”这个，也许是其他的，因为……是的，负数是……所以，如果你取负 1、负 1、0，也许 1、0，你会看到其他问题或其他……</font></font></p><p>Okay. The first row, we have someone says yes, yes, no. Any other
            comments? You guys agree to this? Yes, yes. So, what’s the no? That’s
            right. Publications of the reals does not manage because negative
            numbers don’t satisfy this. Maybe when I was even writing this, you’re
            like, “Wait, but that’s not that for this one.” This one, maybe other
            ones because… yeah, negative one is… so, if you take negative 1,
            negative 1, 0, and maybe 1, 0, you’ll see the other questions or
            other…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我要回答“是”、“是”、“不是”，在最下面一行，是的，这是新的“是”和“是”，或者是“是”和“是”。是的，所以有很多“是”。</font></font></p><p>So, where I’m going to greet yes, yes, no, and on the bottom row,
            yes, which are new yes and yes, or yes and yes. Yeah, so there’s a lot
            of yes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。关于单半群偏序集还有什么问题吗？它们经常出现。我的意思是，你看到了它们。范畴论所做的就是把你生活中已经见过很多次的东西拿出来，告诉你它们是如何运作的，以及这种不成立的失败有一个名字。这是一个完美的……我的意思是，我们的乘法是一个完美的单半群，完美的单半群集，但这总的来说不是一个完美的中间偏序集。</font></font></p><p>Okay. Any questions about monoidal posets? They come up a lot. I
            mean, you see them. What category theory is doing is taking things
            you’ve already seen lots of times in your life and telling you there’s a
            name for the fact about how these are working and for the failure of
            this one kind of no. This is a perfectly good… I mean, our would let’s
            have is a perfectly good poset. Our times one is a perfectly monoidal,
            perfectly good monoidal set, but this altogether is not a perfectly good
            middle poset.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。嗯，就像是这里有个“n”。抱歉，我注意到了。小事件很有趣。自然数与除法和聚类时间——其中一个一起工作。它不工作。好的，我们继续。哦，但这是题外话。我们讨论了单半群中的单半集，但你也可以讨论单半群相——例如小拓扑空间或单半流形。不，它们被称为李群。好吧，我们称它们为单半群，但有群而不是巨石。它们与李理论非常相似。</font></font></p><p>Yeah. Well, it’s like an ‘n’ is here. Sorry, I spotted it. A small
            event is fun. The natural numbers with division and cluster time—one of
            those works together. It doesn’t. Okay, let’s go on. Oh, but this is an
            aside. We talked about monoidal sets in monoidal posets, but you could
            also talk about monoidal phases—little topological spaces, for example,
            or monoidal manifolds. No, they’re called Lie groups. Well, we call them
            monoids, but there are groups instead of monoliths. They’re very similar
            to Lie theory.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的意思是，并不是说李理论涵盖了所有内容，而且根本没有，但这就是李理论，一种幺半群空间。I. 幺半群范畴。我会谈论很多。它似乎是应用范畴论和幺半群阿贝尔群的核心。如果我用阿贝尔李群代替集合或偏序集，那么，我就是一个被称为环的幺半群阿贝尔群。所以这些东西到处都有。它只是被组织成一个你可以反复看到的结构。好的。</font></font></p><p>I mean, not to say that everything in Lie theory is covered, that and
            find that not at all, but that’s what a Lie is, kind of a monoidal
            space. I. A monoidal category. I will talk about a lot. It seems to be
            kind of at the heart of applied category theory, and monoidal abelian
            groups. If I replace set or poset with abelian Lie group, there, I’m a
            monoidal abelian group is called a ring. So these things come up all
            over the place. It’s just organized into a structure that you get to see
            over and over. Okay.</p>
        <h2 id="wiring-diagrams-and-string-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图和串图</font></font></h2><h2>Wiring Diagrams and String
            Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接下来我想讲的是接线图，也称为弦图。两者之间有细微的差别，但我今天不打算解释。如果你感兴趣，可以稍后上来问。这些是用来做什么的：接线图或弦图的口号是什么？基本上就是你涉及到人类的视觉皮层。这就像他们去找投资者时的卖点。所以，我会说，“我现在有一家公司，所以我去找投资者，我就有一个卖点。”这真的很难——我是数学出身——很难做到这一点。我们想不出强有力的卖点，这是我能为他们想出的接线图的最佳卖点。但基本上，当你看到这个时，你的视觉皮层就像把它们解释成符号一样。</font></font></p><p>So, the next thing I want to talk about is wiring diagrams, also
            called string diagrams. There’s a subtle difference, but I’m not going
            to explain it today. If you’re interested, just come up and ask
            afterwards. And what these are for is: What’s the slogan of wiring
            diagrams or string diagrams? It’s basically that you’re involving the
            human visual cortex. That’s like their selling point when they went to
            the investors. So, I’m like, “I have a company now, so I go to
            investors, and I just have a selling point.” It’s really hard to—I’m
            coming from math—to have like this. We don’t come up with hard hitting
            selling points, and this is the best I can come up with for them for the
            wiring diagrams. But basically, when you look at this, your visual
            cortex is like interpreting those as symbols.</p>
        <h2 id="visual-cortex-and-quantum-processes"><font style="vertical-align:inherit"><font style="vertical-align:inherit">视觉皮层和量子过程</font></font></h2><h2>Visual Cortex and Quantum
            Processes</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但当你看到这个时，很容易看出整个结构是什么样的。所以，有各种各样的……</font></font></p><p>But when you look at this, it’s easy to see kind of what this whole
            structure is. So, there are various…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，这就是接线图的作用。例如，牛津大学的 Bob Coecke 是应用范畴论学校的赞助者或主办者，他有一本关于量子图像的书。他说，他认为量子过程的图像——传送或测量或任何量子的快速图像——所有这些量子过程，它们更接近希尔伯特空间形式中实际发生的事情。希尔伯特空间形式是你测试事物的方式；这是一种图表可以表示的方式。</font></font></p><p>Yeah, so that’s what wiring diagrams do. For example, Bob Coecke at
            Oxford, who’s kind of sponsoring this Applied Category Theory school or
            hosting it, he has a book about quantum pictures. He says that he thinks
            that the pictures of quantum processes—quick pictures of teleportation
            or measuring or whatever quantum—all these quantum processes, they’re
            closer to what’s actually going on in the Hilbert space formalism. The
            Hilbert space formalism is how you test things; it’s a way that it’s
            what the diagrams can mean.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但他认为，或者他似乎这么说，他实际上想让一些学习他的理论的 10 岁孩子与他进行对抗——他会和他们一起度过 8 个小时——然后是牛津人，他让牛津学生学习希尔伯特空间形式主义，并用他们自己的语言参加相同的测试，他认为 10 岁的孩子将是…… 这句话的其余部分不清楚，所以接线图可以让事情变得更容易，因为你有一个高度发达的视觉皮层。因此，接线图有多种类型，取决于你谈论的是幺半群类别还是类别。</font></font></p><p>But he thinks that, or he seems to say that, that actually he wants
            to pit some 10 year olds who learn his theory against—he gets to spend
            eight hours with them—and then the Oxford people that he, the Oxford
            students, get to learn the Hilbert space formalism and take the same
            test in each of their own language, and he thinks that the 10 year olds
            will be the… The rest of the sentence is unclear, so wiring diagrams
            make things easier because you have a highly developed visual cortex.
            So, there are various flavors of wiring diagram, depending on whether
            you’re talking about a monoidal category or a category.</p>
        <h2 id="monoidal-categories-and-dynamical-systems"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半群范畴和动力系统</font></font></h2><h2>Monoidal Categories
            and Dynamical Systems</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在一个类别中——我们还没有说会计委员会是什么——是的，但你会在单子类别中看到类似的东西。我们不仅有串行的东西；我们还有并​​行的东西。所以，这是一个单子类别，今天我们讨论的是单子盒式磁带，这就是为什么我们在那里看到了类似这样的图片。所谓的偶像类别的轨迹，就像向量空间一样，有一种叫做轨迹的东西，你可以从中获取其中一张图片，然后在那里进行反馈。</font></font></p><p>So, in a category—and we haven’t said what accounting board is—yeah,
            but you will see things that look like this in a monoidal category. We
            don’t just have serial things; we have parallel ones also. So, this is a
            monoidal category, and today we’re talking about monoidal cassettes,
            which is why we’ve seen pictures that look like that over there. What’s
            called a trace of an idol category, like the vector spaces, there is
            something called a trace where you can take one of these pictures and
            you can do feedback there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，在动态系统类别中，向量空间中有反馈。这是迹矩阵；你可以取一个矩阵，将对角线项相加，这就是这个符号所代表的意思。还有其他的。我不会说出所有不同类型的接线图，但它们有点——好吧，假设有一种叫做超图类别的东西，你甚至不需要考虑什么是输入，什么是输出，接线会混淆各种各样的东西。事实上，关系形成了一个超图类别。具有基的向量空间形成一个超图类别。如果你只跟踪基，你就可以形成一个超图类别。所以，这些都是不同类型的接线图，对应于不同风格的或所谓的学说和类别。今天，我们只关注这一点。</font></font></p><p>On the category of dynamical systems, for example, there’s feedback
            in vector spaces. This is the trace matrices; you take a matrix, can add
            up the diagonal entries, and that’s what this symbol will symbolize
            there. And there are others too. I’m not going to say all the different
            flavors of wiring diagram, but they’re kind of—well, say one where I
            guess there’s something called a hypergraphic category where you can
            have where you don’t really even think about what’s in and what’s out,
            and wires conflate all sorts of things. It is, in fact, relations form a
            hypergraph category. Vector spaces with bases form a hypergraphic
            category. If you just keep track of the bases, you can form a
            hypergraphic category. So, these are all different flavors of wiring
            diagram, corresponding to different flavors of, or what are called,
            doctrines and categories. Today, we’re just going to focus on this
            one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果你要证明 — — 好吧，我不会戴上你的证明帽 — — 如果你要证明 5.1 + 7 + 5.9 + 2 + 3 小于 21 – 0.5 + 1.6 + 6，再说一次，这是我们这门课的第三天，所以我们还没有证明真正困难的东西。</font></font></p><p>So, if you were going to prove—okay, I won’t get your proving hat
            on—if you’re going to prove that 5.1 + 7 + 5.9 + 2 + 3 is less than 21 –
            0.5 + 1.6 + 6, and again, we’re in day three of this class, so we’re not
            proving really hard stuff yet.</p>
        <h2 id="examples-and-proofs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">示例和证明</font></font></h2><h2>Examples and Proofs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是如果你要向别人证明这一点，你可能会注意到 5 + 5.1 + 5.9 很容易——5.1 + 5.9 = 11，而 2 + 3 = 5。还有 7。所以，既然你知道这些很容易，也许你可以先把它们加起来。简单意味着你可以先把它们加起来得到 11。3 + 7 + 2 很方便，因为它们紧挨着。所以，让我们把它们加起来。也许我们会努力把 7 和 3 加起来，但我们没有。</font></font></p><p>But if you’re going to prove this to someone, you might notice that 5
            + 5.1 + 5.9 is easy—5.1 + 5.9 = 11, and 2 + 3 = 5. And 7. So, since you
            know that those are easy, maybe you just add them first. Easy in the
            sense that you can add them first and get 11. 3 + 7 + 2 is convenient
            because they’re right next to each other. So, let’s add them. Maybe we
            would have been working to add 7 and 3, but we didn’t.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当你将这两个相加时，你知道你看到的是 21，和 –0.5 + 1.6 + 6。所以，这是事实。证明是所有这些盒子都小于或等于 s，每次你将电线放在一起时，我们都在进行单半群运算。所以，只要你有一个单半群后步骤，这些图就适用于单半群类别。另请参阅，女主人是类别。这些图将是无歧义可解释的。</font></font></p><p>And when you add these two, you know that you see that it’s 21, and
            –0.5 + 1.6 + 6. So, this is the truth. And the proof is that it that all
            these boxes are less than or equal to s, and every time you put wires
            next to each other, we’re doing the monoidal operation. So, whenever you
            have a monoidal post step, these diagrams work for a monoidal category.
            See also, hostesses are categories. These diagrams will be unambiguously
            interpretable.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你告诉我加法运算是什么，那么我将用它来解释将两根电线并联在一起意味着什么。如果你告诉我小于运算是什么，这将告诉我什么时候可以画一个框。所以，现在我知道我可以在我有的地方画一个框。所以现在我已经证明——如果你同意所有这些人的观点，但它们是正确的——那么你可以，你已经证明了整件事都是正确的。</font></font></p><p>So, if you tell me what the plus operation is, then I’m going to use
            that to interpret what putting two wires next to each other in parallel
            means. And if you tell me what the less than operation is, that’s going
            to tell me when I’m allowed to draw a box. So, now I know I’m allowed to
            draw a box in the places I have. And so now I’ve proven—if you agree
            with all these guys, but they’re true—then you can, and you’ve proven
            that the whole thing is true.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，很多时候我们都会这样推理。就像我一样——如果我要进行一些大操作，可能会以某种方式组织起来，让自己轻松完成。但关键是，我们不希望这是人类知道如何做的聪明才智。我们希望有一个可以交给某人的人工制品，他会说：“这是我们做的计算。”所以，如果他们发现错误，可以告诉我们，他们就可以隔离该问题。我们试图将事情从我们只擅长和知道如何做的事情的领域中移出，并使它们成为我们可以记录的事情。这就是这张图的作用。</font></font></p><p>And so, a lot of times we do reasoning like this. Like, that’s how I
            was—if I was going to do some big operation, probably like organize it
            in some way to make it easy for myself. But the point is, we don’t want
            that to be cleverness that the human knows how to do. We want an
            artifact that we can hand someone who says, “This is the calculation we
            did.” So, if they can tell us if they find an error, they can isolate
            that problem. We’re trying to kind of move things out of the realm of
            stuff that we’re just special and know how to do, and make them things
            that we can record. That’s what this diagram does.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对此还有什么疑问吗？</font></font></p><p>Any questions about that?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这和制作蛋白派是一样的——只是，不是像烹饪那样，是的，对制作蛋白派的人来说不是，但对我来说，好吧。</font></font></p><p>This is the same thing as making meringue pie—just well, not to cook
            like, yeah, not to people who make meringue pie, but to me, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可能见过的例子——科学中的例子——但它们不会是那样的。所以，我想我只想说的是，你可以在化学中找到这些东西。所以，在化学中，这个几何——我不知道，他们可能会说 CH₂O 或 H₂O + H₂O + 2Na（钠）可以变成 2NaOH（氢氧化钠）。如果你用小于或等于替换这个符号，这就是你的模块乘积，那么当你想到一个操作或结果时——他们会怎么称呼它？</font></font></p><p>Examples that you might have seen—examples from science—and they’re
            not going to be that. So, I guess what I just want to say is that you
            can find this stuff in chemistry. So, in chemistry, this geometry—I
            don’t know, they might say things like they might say that CH₂O or H₂O +
            H₂O + 2Na (sodium) can turn into 2NaOH (sodium hydroxide). And if you
            replace this symbol with less than or equal to, and this is your module
            product, then what—when you think of an operation or outcome—what do
            they call it?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">会产生某种产物和反应物的化学过程？我认为它们被称为反应物和产物。然后，我们可以看看这些相同的图表，想象一下，所有这些都充满了这些分子种类。当你有两种分子时——当你有两种不同的分子时——它们可以变成其他东西，等等。所以，如果你知道你可以遵循某种路径，那么你就可以到达你的起点，到达你想要去的地方。</font></font></p><p>A chemical process where you have some kind of products and
            reactants? I think they’re called reactants and products. Then that’s
            kind of what we could look at these same diagrams and just imagine like
            all of these filled in with these species of molecule. And when you have
            two species of molecule—when you have two different molecules—they can
            turn into something else, etc., etc. So, if you know you can kind of
            follow some pathway through, then you can get where you started toward
            where you want to be.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一个非常基本的例子，你以前见过。他们只是用这个符号代替小于。实际上，他们增加了比率；他们给这些东西加了比率。当你给事物加比率时，它会变得更加有趣。你可以想想你的 Petri 网是什么，如果你想了解更多关于实际处理种族问题的知识。琼·贝兹 (Joan Baez) 的人经常说“phase butterspy”，还有很多其他人。他不是第一个，但他是最接近的，所以那是——所以我首先想到的。他在焊接方面非常受欢迎。所以，所以，国家。接下来，我们可以看看偏见，找出从哪里开始看待这类事情的整个污垢。</font></font></p><p>So, that’s kind of a very basic example where you’ve seen this
            before. They just use this symbol instead of less than. Actually, they
            add rates; they put rates on this stuff. And when you put rates on
            things, it gets much more interesting. You can think about what your
            Petri nets are, and so if you want to learn more about actually doing
            things with race. Joan Baez’s people often say “phase butterspy” as, and
            lots of other people. He’s not the first, but he’s closest, so that’s—so
            I think of it first. And he’s very popular in terms of being welded. So,
            so, country. Next, we can look at bias to find out where to start to
            look at the whole dirt run on these kinds of things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个例子是，例如在制造业中——比如说，你在制造一个馅饼，或者你有铰链、钉子和其他东西，你正在制作门。但它们经常出现。你可以做一些你在化学中不被允许做的事情，那就是你可以扔掉东西。例如，我们制作了这种柠檬雨馅料。我们有一张黄油包装纸，我们应该一直用下去，直到它被其他东西用完。在将鸡蛋和蛋白分开时，我们实际上应该有一个鸡蛋。我们应该有一个蛋壳，它会一直用下去。突然间，我们的图表会变得非常混乱。</font></font></p><p>So, another example is, for instance, in manufacturing—your
            manufacturing of a pie, say, or you have hinges and nails and stuff, and
            you’re making the door. But they’re there a lot. You’re allowed to do
            something that you’re not allowed to do in chemistry, which is you’re
            allowed to throw things away. So, we made this lemon rain filling, for
            example. We had a butter wrapper that we should have actually carried
            through and will carry it through for the rest of time until it gets
            used up by something else. And separating the eggs and the white, we
            actually should have had an egg. We should have had a shell, and that
            would be carried through for the rest of time. And all of a sudden, our
            diagram will get very cluttered with things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在制造业中，我的意思是，当你制作东西，包括馅饼时，你会认为你可以浪费或扔掉任何你想要的东西。显然，我们可以看到，这既有节约的一面，也有损害——反之则有好有坏。因为我们想把东西扔进垃圾桶。我每天都这么做，但它并不总是像我们想的那样。它不会无处可去。所以，让我们假设，为了我们的想法，我们想把东西扔进垃圾桶。</font></font></p><p>So, in manufacturing, I mean, when you make stuff, including pies,
            you assume that you can always waste or throw away anything you want.
            And obviously, we can see that that has both to savings and a
            detriment—opposite would be both good and bad. Because we want to be
            able to throw things in the trash. I do it every day, but but it doesn’t
            always really mean what we think of means. It doesn’t just go nowhere.
            So, so, but let’s suppose, for our thinking, that we want to throw
            things in the trash.</p>
        <h2 id="discard-and-copy-axioms"><font style="vertical-align:inherit"><font style="vertical-align:inherit">丢弃并复制公理</font></font></h2><h2>Discard and Copy Axioms</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么我们实际上说的是，我们在单半群类别或单半群偏序集上添加了一个公理。我们添加了公理——waitstaff。我们把它放在这里。这对于任何旧的单半群偏序集都不成立，但如果你的偏序集——如果你的小接近——它有丢弃公理，它就是真的。它是什么？它对所有 a、m 都说了这一点，好吧。它小于。所以，我总是可以取任何东西而什么也得不到。他是单半群单位。我可能没有提到它，但在这些图片中，当你把两根电线放在一起时，我说那是明天的产品。</font></font></p><p>Then what we’re actually saying is we’re adding an axiom to our
            monoidal category or our monoidal poset. We’re adding the
            axiom—waitstaff. Let’s put it here. This is not true for any old
            monoidal poset, but if your poset—if your little close—it has the
            discard axiom, and it is true. And what is it? It says it for all a, m,
            okay. It is less than. So, I can always take anything and get nothing.
            He is the monoidal unit. And I may not have mentioned it, but in these
            pictures, when you put two wires next to each other, I said that’s
            tomorrow’s product.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当你根本看不到任何线时，那里就有一个单子单元。所以，这是单元的中间。没有到处都有节点单元。如果它们在那里，那么这个以太……所以如果我有东西，我只是……我在这里做的是，我说，“哦，我可以扔掉我的黄油包装纸了。”我添加了一个公理，总有办法把所有东西都扔掉，我只是想让它不叫它们。我想让它变得如此普遍，以至于我甚至不——我只是在那里放了一个图标。这个点图标说：每当你看到这个点时，它总是意味着使用丢弃。对丢弃有什么问题吗？是的，你。</font></font></p><p>When you don’t see any wire at all, there’s a monoidal unit sitting
            there. So, this is a middle of the unit. There’s no nodal units
            everywhere. If they’re there, the ether of this… so if I have something,
            and I just… what I’m doing here is I’m saying, “Oh, I can throw away my
            butter wrapper.” I’ve added the axiom that there’s always a way to throw
            everything away, and I just want to make that I don’t call them. I want
            to make that so common that I don’t even—I just put an icon there. This
            dot icon that says: whenever you see this dot, it always means to use
            the discard. Any questions on discarding? Yeah, you.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，当你说，当你使用丢弃公理时，这意味着你隐式地采用了单半群积。等等，好吧，那我们该怎么做呢？好吧，让我们这样做的方法是，我们可以这样写：当 a + b 小于 c 时，对吧？我们也是——但这隐式是 e + a + 对吧？所以现在 a 小于 e。E 只是这个世界的缺失或以太。所以，我把这个写在其他问题上。这有点令人困惑。我们可以稍后再讨论。我最终会抓住一些东西来解决下一个问题。</font></font></p><p>So, when you say that, when you’re using the discard axiom, that
            means you’re implicitly taking the monoidal product. Wait, well, like
            how does that let us do that? Well, the way that lets us do that is that
            we are able to write this: when a + b is less than c, right? We’re
            also—but this implicitly is e + a + right? And so now a is less than e.
            E is just the absence or ether of this world. So, I write this by other
            questions. It is a bit confusing. We can talk about it more afterward.
            I’ll finally grab something to the next problem.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">把这种强调视为事实——哦不，你不是在这些图表中到处乱逛。是的，这些图表，解释它们只是……是的，没错。你到处都做过了吗？这需要一些时间来适应吗？</font></font></p><p>Treat the fact that this sort of emphasis—oh no, you’re not lying
            around everywhere in these diagrams. Yeah, these diagrams, interpreting
            them just… yeah, exactly. Have you done everywhere? Is it that takes
            some getting used to?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你怎么看？是否有必要将该单位用作丢弃单位，因为我不想在右边画任何东西？我想那里什么都没有，这样其他人的就可以不受阻碍地在那里？当我添加到任何东西时，吃东西不会改变它。所以，这就是为什么它是一个令人讨厌的单位，因为当我将它添加到这个时，不会改变它在那里。只有这一个。</font></font></p><p>What do you think? Is it necessary to use the unit as the discard in
            the sense that I want to not draw anything to the right? I want to have
            nothing there so that the other guys’ ones can be there unobstructed?
            Eat when I added to anything doesn’t change it. So, so that’s why is it
            some annoyingly unit because when I add it to this one, doesn’t change
            it’s there. It’s just this one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">问题是什么？它可能是另一个单位大小的东西，而这个单位没有问题吗？对不起，对吧？如果我把它称为其他东西，那么我就得到了一个字符串。事实上，单半群单位被画成什么都没有，这让它消失了。所以，这只是一个惯例。那个基本的惯例。公理允许的那些惯例。好的，另一页。明智的选择。</font></font></p><p>What was the question? Could it be something the size of another unit
            that was there without the question? Sorry, right? If I if I call it
            something else, then I have a string. The fact that the monoidal unit is
            drawn as nothing makes it disappear. So, it’s just a convention. That
            basic convention. Those conventions permitted by the axioms. Okay, other
            page. The sensible thing to pick.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么，在制造业中，你可以添加这个丢弃公理。或者在信息学中，你处理的是信息，一组事物。你可以在信息学中处理信息的这一部分添加制造业。你不仅可以丢弃电子邮件，还可以复制。复制公理说，对于所有 a、m，a 小于 a + 如果我有一个 a，那么我可以有两种方法。所以，如果有人说，“你介意帮我复制这张 CD 吗？”他们的意思不是复制实体 CD。</font></font></p><p>Okay, so, in manufacturing, you might add this discard axiom. Or in
            informatics, where you’re working with information, a set of things. You
            could add a manufacturing at this part in informatics where you’re
            working with information. You not only can throw an email away, but you
            can also copy. And the copy axiom says that for all a, m, a is less than
            a + if I have a, then I can have two ways. So, if someone says, “Would
            you mind copying this CD for me?” They don’t mean copying the physical
            CD.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">他们说你有一张 CD，现在你有两张 CD。Bobby，真的吗？那将是一个非常特殊的场合。这次不同。这是因为你有一张 CD，而且你有——我想在书中，我们称之为碧昂丝的电视——还有一张空白 CD。当你完成后，你就有了两个未婚夫和学生。好的，但是当人们说他们要复制一张 CD 时，我们实际上</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的意思</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">不是公司，而是信息。如果你有一封电子邮件，比如说你有一个日历。你的日历程序是打开的，我还需要什么？你的地图程序是打开的。然后，从那里，也许你已经能够使用它们来编写你的电子邮件。你用它们来决定如何阅读你的电子邮件，现在你将这封电子邮件复制给几个人。好吗？是的，你可以。我想你也可以放弃一个临床医生。好的。</font></font></p><p>They stop that you have a CD and now you have two CDs. Bobby, really?
            That would be a really special occasion. This is different. This is that
            you have a CD and you have—I guess in the book, we call it Beyoncé’s
            TV—and you have a blank CD. And when you’re done, you have two fiancé
            students. Okay, but what we actually <em>mean</em> when people say
            they’re going to copy a CD, they don’t mean the company, but the
            information. If you have an email, say you have a calendar. Your
            calendar program is open, and what else do I need? Your maps program is
            open. Then, from that, maybe you’ve been able to use those to write your
            email. You used them to decide how to read your email, and now you copy
            that email to several people. Okay? Yeah, you can. You can also discard
            a clinician, I guess. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这些都是不同风格的幺半群类别。我画了一些非常极端的不同风格，你可以做反馈，甚至不知道“方向”是什么意思之类的。但这些稍微不那么极端。它们只是在幺半群类别接线图中添加了这两个图标：“弹出”图标和“丢弃”图标。如果我们添加这些公理，我们就可以使用它们。刚刚创办的公司。</font></font></p><p>So, these would all be different flavors of monoidal category. I drew
            some pretty extreme, different flavors where you’re allowed to do
            feedback, and you’re allowed to not even know what “direction” means and
            things like that. But these are slightly less extreme. What they are is
            that they add just these two icons: the “pop” icon and the “discard”
            icon to the monoidal category wiring diagram stuff. We’re just allowed
            to use these if we add these axioms. Just starting companies.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，对此有疑问吗？</font></font></p><p>Okay, questions about that?</p>
        <h2 id="monoidal-post-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">单一柱集</font></font></h2><h2>Monoidal Post Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么，在纯数学中，N 无穷大与小于或等于无穷大和最小值的组合是否是单数？意大利面，番茄，贴出来。因为这意味着这是我们要使用的步骤。小于或等于。你已经知道它是什么了，你不必担心 V 是否小于无穷大。你知道，这是一个小单位。当我用任何东西将它取最小值时，我就会得到那个东西。</font></font></p><p>Okay, so, in pure math, is it true that N union infinity with less
            than or equal to and infinity and min is that monoidal? Pasta, tomato,
            post that. Because what this means is that this is the step we’re going
            to use. Less than or equal to. You already know what it is, and you’re
            not worrying about whether V is less than infinity or not. You know, and
            this is a little unit. When I min it with anything, I get back that
            thing.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">五分钟。第 55 分钟和无穷大是……这有复制吗？有重复吗？所以，这满足了“公司”——对不起，“复制”公理和“丢弃”公理。有人说“是”丢弃，因为一切都小于幺半群单位。</font></font></p><p>Five minutes. Minute 55 and infinity is… does this have copying? Does
            it have duplication? So, this satisfies the “company”—I’m sorry, the
            “copy” axiom and the “discard” axiom. Someone says “yes” to discard
            because everything is less than the monoidal unit.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在这里吃饭。那咖啡呢？是的，是的。五小于最小值和五，因为我们使用的是最小值。所以，如果你不知道二加六的最小值——你不确定——但你可以证明二加六的最小值小于四的最小值，那么你可以写一个图表……有一个证明。我不知道他们为什么这样证明，但没关系。</font></font></p><p>Eat here. And what about coffee? Yeah, yeah. Five is less than the
            minified and five, ’cause we’re using a min. So, you could write a
            diagram if you didn’t know whether the minimum of two and six—you’re not
            sure—but you can prove the minimum of two and six is less than the
            minimum of four and… there is a proof. I don’t know why they proved it
            that way, but that’s okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么为什么不尝试找到一个幺半拓扑步骤：一，不满足丢弃；二，不满足复制；三，都不满足？</font></font></p><p>Okay, so why don’t you try to find a monoidal topos step that: one,
            does not satisfy discard; two, does not satisfy copy; and three, does
            not satisfy either?</p>
        <h2 id="practice-problems"><font style="vertical-align:inherit"><font style="vertical-align:inherit">练习题</font></font></h2><h2>Practice Problems</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，你为什么不利用剩下的时间做这件事呢？时间到了我会给你打电话，这样你就不用担心了。是的，和邻居谈谈。</font></font></p><p>So, why don’t you take the rest of the time and do that? And I’ll
            call when time’s up, so you don’t have to worry about it. Yeah, talk to
            a neighbor.</p>
        <h1 id="applied-category-theory.-chapter-2-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 2 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 2, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 18 日) — 50:47 </font></font><a href="https://youtube.com/watch?v=DvI3jzFNbEU"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=DvI3jzFNbEU</font></font></a></p><p> 6
            years ago (Jan 18, 2019) — 50:47 <a href="https://youtube.com/watch?v=DvI3jzFNbEU">https://youtube.com/watch?v=DvI3jzFNbEU</a></p>
        <h2 id="summary-3"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本 MIT 课程 (18S097) 由 David Spivak 和 Brendan Fong 讲授，介绍了单半群预序和对称单半群预序。IAP（独立活动时间）讲座回顾了预序，重点介绍了它们与偏序集的等价性。课程介绍了成本集和幂集等示例，以及用于可视化这些结构内推理的接线图。然后，课程定义了对称单半群预序并探讨了成本类别，将它们与度量空间和有向图联系起来。讲座最后给出了如何使用有向图表示成本类别的示例。</font></font></p><p>This MIT Course (18S097), taught by David Spivak and Brendan Fong,
            introduces monoidal preorders and symmetric monoidal preorders. The IAP
            (Independent Activities Period) lecture reviews pre-orders, focusing on
            their equivalence to posets. Examples like cost and power sets are
            presented, along with wiring diagrams for visualizing reasoning within
            these structures. The course then defines symmetric monoidal preorders
            and explores cost categories, connecting them to metric spaces and
            directed graphs. The lecture concludes with examples of how directed
            graphs can be used to represent cost categories.</p>
        <h2 id="announcements-and-forum"><font style="vertical-align:inherit"><font style="vertical-align:inherit">公告和论坛</font></font></h2><h2>Announcements and Forum</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我先开始。好的。</font></font></p><p>I’ll start. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，课程开始时会有一个公告。这个 URL 上有一个论坛，它相当长，但如果你转到课程网页，然后滚动到底部，也会有一个链接。这是一个论坛，由我的博士生导师 [导师姓名] 主持，有很多人在讨论这门课程以及很多额外的材料。好的。</font></font></p><p>So, one announcement at the beginning of class. So, there’s a forum
            at this URL, which is pretty long, but if you go to the course webpage
            and then go scroll to the bottom, there’s also a link to it. That’s a
            forum, moderated by my PhD supervisor, [Name of supervisor], and there
            are a bunch of people discussing this course and a lot of extra material
            as well. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在我开始正式讲课之前，我想快速澄清一下我们对“pre order”和“poset”这两个词的使用，因为我们对于它们之间的区别非常不正式。</font></font></p><p>Before I get into the lecture proper, I want to clarify just quickly
            our use of the words “pre order” and “poset,” since we’re being pretty
            informal about the distinction between them.</p>
        <h2 id="preorder-vs.-poset"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预购与 Poset</font></font></h2><h2>Preorder vs.&nbsp;Poset</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里有一个定义，我会陈述它，然后我们可能会继续忽略它。但是偏序集（偏序集的缩写）是遵循这个公理的预序，该公理表示如果 x 小于或等于 y，并且 y 小于或等于 x，则 x = y。所以，我们称之为反对称性。</font></font></p><p>So, here’s a definition, which I’ll state, and then we’ll probably
            just continue to kind of ignore it. But a poset, short for partially
            ordered set, is a pre order that obeys this axiom that says that if x is
            less than or equal to y, and y is less than or equal to x, then x = y.
            So, we call this anti symmetry.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，从形式上讲，大多数人使用“poset”这个词来表示这种结构，即具有自反、传递和反对称顺序的集合。但对于我们的情况，“预序”是一个稍微弱一些的定义，从范畴论的角度来看更自然。有一个很好的事实是，每个预序，即使它看起来像一个较弱的结构，在某种我不会告诉你的精确意义上，与 poset 是等价的。好吧，这两个术语之间存在形式上的差异。就我们的目的而言，它们大致相同。如果我们说“poset”，我们可能真的是指“预序”。我们无意中说了“poset”，因为事实上，我们并没有真正、也没有太注意区别。好吧。</font></font></p><p>So, formally, most people use the word “poset” to mean this
            structure, that is, a set with an order that’s reflexive, transitive,
            and anti symmetric. But for our case, “pre order” is a slightly weaker
            definition that is more natural from the point of view of category
            theory. And there’s a nice fact that every pre order, even though it
            seems like a weaker structure, is equivalent in some precise sense that
            I’m not going to tell you about, to a poset. Well, there is a formal
            difference between the terms. For our purposes, they’re about the same.
            And if we say “poset,” we probably really mean “pre order.” We have
            accidentally said “poset” because, by this fact, we don’t really, we
            aren’t too careful of the distinction. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，让我继续正确地说......</font></font></p><p>So, let me move on properly to…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">抱歉。原因是……不是等号，而是……是吗？所以，例如，这是一个偏序集。哦，抱歉。这是一个预序。我已经犯了错误。这实际上不是一个偏序集，因为……这两个元素，这个小于或等于这个，这个小于或等于这个，但它们不相等，对吧？但这在某种程度上等同于这个预序。对吧？所以，每当你有一个适当的预序，其中有很多这样的东西时，你只需将它们全部商在一起，然后考虑你认为任何同构的东西实际上都是相等的。比如，a、c、h、o，我想。所以，是的。是的，说得好。我想我也不会太精确。</font></font></p><p>Sorry. Is the reason for that… that instead of the equals there, you
            get an… yeah? So, so for example, here’s a poset. Oh, sorry. Here’s a
            pre order. I’m already making mistakes. That is not actually a poset
            because… as these two elements, and this is less than or equal to this,
            and this is less than or equal to this, but they’re not equal, right?
            But this is somehow equivalent to just this pre order. Right? And so,
            whenever you have a proper pre order where there’s lots of this stuff
            going on, you just kind of quotient it all together and just consider
            the things where you consider anything isomorphic to actually being
            equal. Like, a, c, h, o, I guess. So, yeah. Yeah, good point. I’m not
            going to be too precise about that either, I guess.</p>
        <h2 id="symmetric-monoidal-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对称幺半群预序</font></font></h2><h2>Symmetric Monoidal Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。</font></font></p><p>Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，让我来告诉你关于对称预序的知识。好的。那么，首先，让我们来看一下什么是幺半群预序。正如我们昨天看到的……哦，预序。人们也说预序幺半群，这是一种观点……不，等等。不。大卫无论如何都采取了幺半群预序的观点。幺半群预序，我们……乘以二……我们有一个集合，一个顺序关系，一个……我将首先用这个 O(time) 符号写出单位元素，然后是预序上的 mon 运算。所以，这个数据，其中 umal 预序是这个数据，其中 t 与这个顺序关系形成预序。我要说 o 次是一个从 p * p 到 p 的函数。所以，这只是集合论，但这样：</font></font></p><p>So, let me tell you about symmetric preorders. Okay. So, first, let’s
            and do what a monoidal preorder is. So, as we saw yesterday on… oh, pre
            order. People also say pre ordered monoid, which was sort of the
            viewpoint that… no, wait. No.&nbsp;David took the monoidal pre order
            viewpoint anyway. Monoidal preorder, which we… by two… we had a set, a,
            order relation, a… I will first write the unit element and then the mon
            operation on a preorder with this O(time) symbol. So, this data, where
            the umal preorder is this data where t with this order relation forms
            the pre order. I’m going to say that o times is a function from p * p to
            p.&nbsp;So, this is just set theoretic for now, but such that:</p>
        <ul>
            <li>
                <ol type="a">
                    <li><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是…这是…这个运算形成了一个幺半群。所以，它是结合律。我们有这个。它是单元律，所以这意味着我们有这个。</font></font></li>
                </ol>
            </li><li>
                <ol type="a">
                    <li>It’s… it’s… this operation here forms a monoid. So, it’s
                        associative. We have this. It’s unital, so it means that we have
                        this.</li>
                </ol>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，David 说这应该是一个单调映射。所以，我们有这个单调性条件，明确地说：如果 a₁ 小于 c 且 b 小于 d，那么 a * b 小于 c * d。对吗？所以，这就是我们昨天看到的。</font></font></p><p>Then, David said that this should be a monotone map. So, we have this
            monotonicity condition that explicitly says: if a₁ is less than c and b
            is less than d, then a * b is less than c * d.&nbsp;Right? So, that’s what we
            saw yesterday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们有这些例子，其中有 b……所以，这个例子 b，关于设置事物真/假，其中顺序小于我昨天看到的顺序。但它是……我只是要隐式地写：假意味着一切，真只意味着真。然后我们在单位处有真。而且……而且，也就是这个 ∩ 符号，是幺半群积。抱歉，还有另一个幺半群预序，这在本课中很重要。</font></font></p><p>And we had these examples where we had the b… So, this example b, as
            to set things true/false, where the order is this less than order that I
            saw yesterday. But it’s… I’m just going to write implicitly: false
            implies everything, and true only implies true. And then we have true at
            the unit. And… and, which is this ∩ symbol, is the monoidal product.
            Sorry, there’s also another monoidal pre order that’s going to be
            important in this lecture.</p>
        <h2 id="cost-preorder-example"><font style="vertical-align:inherit"><font style="vertical-align:inherit">费用预订示例</font></font></h2><h2>Cost Preorder Example</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这叫成本。</font></font></p><p>This is called cost.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里的底层集合是 Z⁺∪{∞}，它是一个闭区间。那么，这是什么意思呢？这是所有正实数加上一个额外的元素，我们称之为无穷大，它被认为大于其他所有元素。顺序将是大于关系，而不是小于关系。所以，它与你可能预期的相反。所以，具体来说，这个东西，这个无穷大元素，是……我想它现在应该被认为是底部元素，但它大于其他所有元素。所以，它位于符号之前。幺半群单位是零，幺半群乘积是 +。其中任何东西 + 无穷大都等于无穷大。我们昨天确实看到了这一点。</font></font></p><p>The underlying set here is Z⁺∪{∞} as a closed interval. So, what does
            this mean? This is all positive real numbers plus an extra element,
            which we call infinity, which is considered greater than everything
            else. The order is going to be the greater than relation, not the less
            than relation. So, it’s reversed from what you might expect. So, in
            particular, that this thing, this infinity element, is the… guess it
            should be considered the bottom element now, but it’s greater than
            everything else. So, it goes before the symbol. The monoidal unit is
            zero, and the monoidal product is +. Where anything + infinity is equal
            to infinity. We did see that yesterday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，这是另一个例子。给定一个集合 X，你可以取它的幂集，其中底层集合是子集的集合。幂集的顺序是子集的包含。幺半群运算是并集，幺半群单元是交集，无单元是补集。</font></font></p><p>And then, here’s another example. Given a set X, you might can take
            its power set, where the underlying set is the set of subsets. The power
            set, the order is inclusion of subsets. The monoidal operation is union,
            and the monoidal unit is the intersection, and the no unit is the
            complement.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，为了再复习一下，我们还看了接线图。那么，这是什么意思呢？</font></font></p><p>Okay, so to review a few more things, we also saw wiring diagrams.
            So, what does this mean?</p>
        <h2 id="wiring-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图</font></font></h2><h2>Wiring Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里我们有了预序单半群……等等，预序，用这个符号表示也是一样。好的，所以……所以，在这个布线符号中，这个集合是一组线标签。这个顺序就是我们可以画盒子的地方。这个元素是单位，是以太或环境结构。时间，即单半群乘积，让我们可以把事物并联起来。我们有一个符号，我们可以画一个盒子，里面有进出的线，用自由预序元素 {a, b, c, d} 标记。</font></font></p><p>So, here we have our pre order monoid… wait, pre order, same thing
            using this notation. Okay, so… so, in this wiring notation, this set is
            a set of wire labels. This order thing is where we can draw boxes. This
            element is the unit, is the ether or the ambient structure. And the
            times, the monoidal product, allows us to put things in parallel. We
            have a notation where we can draw a box with wires coming in and out,
            labeled by elements of the free preorder {a, b, c, d}.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">标签可以重复使用。'a' 代表这样的箭头。这个事实，所以，这里的符号是单半群预序推理的另一种符号。所以，通常的符号是我们在这里使用的符号，也就是写成 A ⊗ B ⊗ C，对不起，时间小于 D * A，对吧？但这只是该表达式的另一种符号。这一点是，在某些情况下，比如说，在这个预序集合中，成本，我们可以采取一些事实，比如——我得到这么小——我们可以采取一些事实，比如说，3 + 3 小于，不，4 + 2，对吧？</font></font></p><p>Labels can be reused. ‘a’ represents an arrow like that. This fact,
            so, so this notation here is an alternate notation for reasoning within
            a monoidal pre order. So, the usual notation is the one we’ve been using
            here, which is to write things like A ⊗ B ⊗ C, sorry, times is less than
            D * A, right? But this is just an alternate notation for that
            expression. And the point of this is that, some cases here, that in,
            say, this pre order set here, cost, we can take some facts like—I’m
            getting this small—we can take some facts like, say, 3 + 3 is less than,
            no, 4 + 2, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们还可以考虑另一个事实。所以，这就是这个东西所代表的，对吧？这是说，因为现在我正在计算成本，所以非乘积是加号并且大于。所以，这个框表示 3 + 3 大于 4 + 2，对吧？你也可以有这样的事情，比如 3 大于 1，我们可以说 2 大于 0。但由于 David 昨天提到的，零可以忽略它，所以这可以逐渐消失。</font></font></p><p>And we can take another fact. So, so that’s what this thing
            represents, right? This is saying because now I’m working cost, so the
            not product is plus and is greater than. So, this box represents the
            fact that 3 + 3 is greater than 4 + 2, right? And you can also have
            things like 3 is greater than 1, and we can have, say, that 2 is greater
            than 0. But because of what David mentioned yesterday, the zero can kind
            of ignore it, so this can kind of just fade out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们可以把这些表达式组合起来，形成类似这样的结果。我们有 4，2，对吧？那么，这是什么意思呢？这是一个证明，它表明从这三个假设（它们有相应的解释）中，我们可以得出这个外框，它表示 3 + 3 大于 4 + 1。所以，这是你可能在脑子里进行的某种推理，它正式地表示了这个过程。</font></font></p><p>And we can take these expressions and put them together to form
            something like this. We have coming in 4, 2, right? And so, what does
            this mean? This is a proof that says from these three hypotheses, which
            have these corresponding interpretations here, we can derive this outer
            box, which represents that 3 + 3 is greater than 4 + 1. And so, this is
            some reasoning you sort of might do in your head, and this sort of
            represents that process formally.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，你可能会注意到，单半群预序的公理与你的视觉皮层在这里所做的直观的事情相对应，对吧？例如，如果我有两个盒子，其中 2 大于 1，3 大于 1，那么我可以将它们并排放置，这就表明 3 + 1 大于 1 + 1，这正是下面的单半群公理。好的。</font></font></p><p>So, what you might notice is that the axioms of the monoidal pre
            order correspond to sort of intuitive things that your visual cortex is
            doing here, right? So, for example, if I have two boxes where 2 is
            greater than 1 and 3 is greater than 1, then I can sort of put them side
            by side, and this says that 3 + 1 is greater than 1 + 1, which is
            precisely this monoid axiom down here. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，现在来一个新的定义。从对称单半群序来看，如果单半群预序进一步遵循称为对称性的公理，即 A * B 小于 B * A，则该单半群预序是对称的。</font></font></p><p>So, now to a new definition. From symmetric monoidal orders, a
            monoidal pre order is symmetric if it further obeys this axiom called
            symmetry, which says that A * B is less than B * A.</p>
        <h2 id="symmetric-monoidal-preorders-review"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对称幺半群预序（评论）</font></font></h2><h2>Symmetric Monoidal
            Preorders (Review)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，称其为对称。好的。所以，这意味着事实上，因为这是针对所有 A 的，所以对于所有 A，A ⊗ B 等于，对不起，A * B 等于 B * A，对吧？所以，我们总是有这个框 A、B、B、A。还记得 David 昨天开始介绍公理的时候吗？所以，重点是这些框代表了你用来构建更大事物的假设。对吧？所以，这些是你的假设，或者内部框是假设，然后这个东西，外部框，我们称之为结论，或者类似的东西，即 3 + 2 + 3 大于 4 + 1。所以，如果我们加入更多公理，那么加入更多更大的图像也是很好的，所以这些框真正代表了来自这个特定模型的假设，无论是成本还是其他什么，而不仅仅是公理。因此，在这种情况下，我们经常说，在范畴论中，我们有这个图标可以让我们交换东西。好的。所以，这主要是回顾。哦，是的，好的。回答一个问题。</font></font></p><p>So, call this symmetry. Okay. So, I, this means that in fact, because
            this is for all A, we have that for all A, A ⊗ B is equal to, sorry, A *
            B is equal to B * A, right? So, I, we always have this box A, B, B, A.
            And then remember when David started introducing axioms yesterday? So,
            the point is that these boxes represent hypotheses you’re using to
            construct your larger thing. Right? So, these are your hypotheses, or
            the internal boxes are the hypotheses, and then this thing here, the
            outer box, we’ll call the conclusion, or something like that, which is 3
            + 2 + 3 is greater than 4 + 1. So, if we throw in more axioms, it’s nice
            also to throw in more a greater sort of iconography, so the boxes truly
            represent hypotheses that come in from this particular model, whether it
            be cost or whatever, instead of just the axioms. So, in this case, we
            often say that in categorical theory, we have this icon that lets us
            swap things. Okay. So, that’s mostly a review. Oh, yeah, okay. Take a
            question.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这是否意味着它们不具有交换性？不，这意味着它们是可交换的。但是什么引发了这个问题？因为对称性和可交换性之间存在差异。啊，你可以称之为可交换的。我们使用对称这个词的原因是，当我们讨论更一般的情况，即范畴情况时，我们更感兴趣的是对称结构或可交换结构，在这种特殊情况下，可交换性和对称性是相同的，但在一般情况下，对称性更弱，结构也更有趣。</font></font></p><p>So, does this mean that they’re not commutative? No, it means that
            they are commutative. But what prompts that question? Because of the
            difference between symmetry and commutative. Ah, you might just call
            this commutative. The reason we use the word symmetric is because in
            when we go to a more general case, the categorical case, we’re more
            interested in the symmetric structure or the commutative structure,
            which, where in this particular case, commutative and symmetric are the
            same, but in the general case, symmetric is weaker and the more
            interesting structure.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我只是用了那个词，但谢谢，好问题。好吧，它们在同构上是相同的，但对称性是……哦，是的，好的。我们正在做预定，我们的过程……是的，交换的。对不起，我之前说过这意味着相等，但我在那里使用了反对称的假设。所以我收回那句话。这稍微弱一点，正是由于反对称假设的不同。所以，这意味着张量 b 与 b 张量 a 同构，但不一定相等。这就是对称性和交换性的区别。是的，这是一个很小的区别。是的。</font></font></p><p>So, I’m just using that word, but thanks, good question. Well,
            they’re the same up to isomorphism, but symmetry is… Oh, yeah, okay. We
            are doing pre orders and our process… yeah, commutative. Sorry, I said
            before that that implies equality, but I was using that assumption there
            of anti symmetry. So, I take that back. This is slightly weaker,
            precisely by the difference of that anti symmetry assumption. So, this
            implies that a tensor b is isomorphic to b tensor a, and not necessarily
            equal. And that’s the distinction between symmetry and commutativity.
            Yes, it’s a pretty minor distinction. Yes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这里 p 实际上应该像 f 标签的有限列表，对吧，而不仅仅是 f 的集合。P 就像 p 的一个元素，将是一个有限的线列表。但是，这是一个好问题。昨天，当 David 在做类似 cap 图的东西时，他假设这个 monoid 结构有一些生成器，并且只用生成器标记线。我明白了。好的。但你可以做任何一件事。</font></font></p><p>So, here, p should actually be like the finite lists of f labels,
            right, instead of just the set of f’s. P, like an element of p, will be
            a finite list of wires rather. But, so this is a good question. Where,
            when David was doing stuff like the cap diagram yesterday, he sort of
            assumed that there were some generators to this monoid structure and was
            only labeling wires with the generators. I see. Okay. But you can do
            either.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我猜，我暗示说你可以用 4 + 1 之类的数字来标记电线，也许吧。好的。只是让每个人都有机会喘口气。这是一个稍后会涉及到的问题。那么，cost 有连接吗？如果有，它们是什么？所以，也许我会给你两分钟时间。我们将与我们的邻居讨论这个问题，并讨论他们到目前为止可能有疑问的任何其他问题。我周围有人想谈论这个吗？</font></font></p><p>So, I could, I guess, implicitly I’m saying you can label wires with
            like 4 + 1 or something like that, maybe. Okay. Just, just to give
            everyone a chance to catch that breath. Here’s a question that’ll be
            relevant later. So, does cost have joins? If so, what are they? So,
            maybe I’ll give it two minutes. We’ll discuss that with our neighbors
            and also just discuss anything else they might have questions about so
            far. Anyone around me want to talk about this?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">元素……元素 z……因此给定两个……某个东西，比两者都……是的，实数。</font></font></p><p>The element… the element z… and so given two… something that’s than
            both… yeah, the real numbers.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有什么问题吗？或者我……有人想大声说出来吗？首先，什么是连接？连接是什么意思？是的，所以你有一个集合并要求最小上界，但是话虽如此。但是，我们在顺序上有些棘手。那么，如果我先给你两个数字，这两个数字的连接是什么？六和八，或者？好的，是的，很好。六和八。六和八的连接是什么？六。对。所以，连接——连接——相同。如果我不给你数字，那是什么？空集的连接？无穷大。所以，它是最小的数字——等等，最大的数字。它是小于零的最大数字。对吗？大于零的最大事物。所以，它只是无穷大。所以，我要写连接空集。</font></font></p><p>Any questions? Or am I… Anyone want to shout out? First, what is a
            join? What does it mean to have a join? Yeah, so you have a set and ask
            for a least upper bound, but that said, okay. So, but we have something
            slightly tricky with the order going on. So, what’s if I give—if I first
            give you two numbers—what’s the join of those two numbers? Six and
            eight, or yeah? Okay, yeah, good. Six and eight. What’s the join of six
            and eight? Six. Right. So, the join—join—same. If I give you no numbers,
            what’s that? The join of the empty set? Infinity. So, it’s the least
            number that’s—wait, the greatest. It’s the greatest number that’s less
            than nothing. Right? Greatest things such that nothing. So, it’s just
            infinity. So, I’m going to write join empty set.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，现在我们来讨论类别。我将“丰富”放在括号中。</font></font></p><p>Okay, so now we move on to categories. And I’ll put “enrich that” in
            parentheses.</p>
        <h2 id="categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别</font></font></h2><h2>Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我已经讨论了单半群预序，其思想是单半群预序或对称预序构造了如何从 a 到达 b 的问题。因此，具体来说，如果你问“你能从 a 到达 b 吗？”，可以用“是”或“否”来回答。再从 A 到 b。或者你可以问“从 a 到 b 要花多少钱？”这个问题的答案是某个正实数，表示花费五美元，或者多少美元，以及无穷大。对吧？你也可以回答——问这样的问题，“你如何——那么，从 a 到 b 有哪些方法？”所以，如果你有一组从 a 到 b 的方法，那么 X 的幂集。</font></font></p><p>Okay, so I’ve talked about monoidal pre orders, and the idea is that
            monoidal pre orders, or symmetrical pre orders, structure the question
            of how of getting from a to b. So, in particular, if you ask something
            like, “Can you get from a to b?” that can be answered by “yes” or “no.”
            A to b again. Or you can ask, “How much does it cost to get from a to
            b?” And that’s answered by some positive real number that says it costs
            five, or what, and costs infinity. Right? And you can also answer—ask
            questions like, “How can you get—so, what are the ways you can get from
            a to b?” And so, if you have a set X of ways from getting from a to b,
            then the power set of X.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么从 a 到 b 的概念如何不仅涉及集合，还涉及幺半群预序结构？因此，当您考虑从 a 到 b 的方法时，一个重要的概念是，您可以通过其他点（路径点）到达。对吗？因此，具体来说，如果它有点——它花费——那么，假设我们正在回答这个问题，“从 a 到 b 需要多少钱？”从 a 到 c 需要花费四美元，从 c 到 b 需要花费三美元。</font></font></p><p>Okay, so how does this notion of getting from a to b entail not just
            the set, right, but the monoidal pre order structure? So, an important
            notion when you think about ways to get from a to b is that you can go
            via other points—way points. Right? So, in particular, if it’s sort
            of—it costs—so, say we’re answering the question, “How much is it to get
            from a to b?” And it costs four to get from a to c and three to get from
            c to b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，我们希望，为了使这些数据连贯一致，从 a 到 b 的价格必须小于或等于通过其他路线从 a 到 b 的价格。对吗？所以，我们有这个表达式小于或等于，我想，小于或等于。对吗？因为如果这是八，那么我们只需经过 c，七点就可以到达那里。对吗？所以，我们在回答这个问题时有这种连贯条件，即我们希望 4 + 3 大于或等于六。</font></font></p><p>Then we want, for this data to be coherent, the price of getting from
            a to b has to be less than or equal to the price of getting from a to b
            through some other route. Right? So, we have this expression less than
            or equal to, I guess, less than or equal to. Right? Because if this was
            eight, say, then we would just go through c, and we could get there in
            seven. Right? So, we have this sort of coherence condition on answering
            this question that says that we want something like 4 + 3 to be greater
            than or equal to six.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。好的。如果我们在思考从一个地方到另一个地方的方法，比如我们有一组从 A 到 B 的方法（例如乘船或汽车），然后有一组从 B 到 C 的方法。那么，从 a 到 b 的方法集至少应该包含两者，但它也可能包含一些其他的东西，比如火车之类的。所以，在这里，我们又有了这个，这个想法，这个连贯性的想法，它说（抱歉写得太短了）船∩汽车⊂bo 应该包含在这个东西 bo 中。好的。</font></font></p><p>Yes. Okay. If we’re thinking about ways to get from one place to
            another, like if we have a set of ways to get from A to B (by boat or
            car, for example), and then a way to get from B to C. By, say, then the
            set of ways to get from a to b should at least contain both, but it
            might also contain some other things, like a train, something. So, here
            again, we have this, this idea, this coherence idea that says that
            (sorry for the small writing) that boat ∩ car ⊂ bo should be contained
            in this thing, bo. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我们看到我们在这里使用这个，这个幺半群结构，对吧？这里的交点，这是幺半群，这里的包含是你在那边看到的顺序。同样，这是顺序，这是幺半群结构。好的。</font></font></p><p>And so we see ourselves using here this, this monoidal structure,
            right? This intersection here, this is the monoid, and this inclusion
            here is the order you see over there. And similarly, here’s the order,
            and here’s the monoidal structure. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，好的，下面是一个定义。设 V 是经典的东西，但我们称之为对称幺半序。那么 V 类别是一个集合，我将其称为 X，我们将其中的东西称为对象。然后是一个从 X × X 到 P 的函数，我将这个函数脚本称为类别 C。好的。</font></font></p><p>So, okay, so a definition. Let V, which is some classical thing, but
            we’ll say a symmetric monoidal preorder. Then a V category is a set,
            which I’m going to call X, and we call the things in here objects. And
            then a function which goes from X × X to P, and I’m going to call this
            function script C for category. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这就是这些数据。它只是一个集合，然后对于集合的每一对元素，我们都会得到一个幺半群预序的某个元素，这样我们就有两个公理。第一个公理叫做恒等式，它表示对于所有 x ∈ X，e 都小于或等于 C(x, x)。恒等式。第二个公理叫做结合性，它表示如果我们有三个对象，x、y 和 z，那么，那么元素，所以，如果我们将这个预序视为这样，这样，这个数据量化了从 x 到 x 需要多少时间，这就表示它——嗯，这很难——但让我来解释一下结合性公理。这表明，当我们使用幺半群运算将它们结合起来时，从 x 到 y 的方式，以及从 y 到 z 的方式，在某种程度上小于或等于从 x 到 z 的方式。这正是这里的想法。</font></font></p><p>So, it’s this data. It’s just a set, and then for every pair of
            elements of the set, we get some element of a monoidal preorder, such
            that we have two axioms. The first is called identity, and it says that
            e is less than or equal to C(x, x) for all x ∈ X. Identity. The second
            one is called associativity, and this says that if we have three
            objects, x, y, and z, then, then the element, so, so if we think of this
            preorder as this, this way, this data quantifying how much it takes to
            get from x to x, this says that it—well, it’s hard to—but let me
            interpret the associativity axiom. This says that the way of getting
            from x to y, and the way of getting from y to z, when we combine it
            using the monoidal operation, is somehow less than or equal to the way
            of getting from x to z. Which is exactly this idea here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么你称它为结合性？你的意思是组合性吗？哦，对不起，我的意思是组合性。我不知道为什么我说结合性。谢谢。如果有任何东西是传递性的，我想这是我要问你的下一个问题。</font></font></p><p>Why do you call it associativity? Do you mean composition? Oh, sorry,
            I mean composition. I don’t know why I said associativity. Thanks. If
            anything is transitivity, which I think is my next question for you.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，问题是：当 V 被标记时，a 和 b 表示什么？让我们花几分钟来讨论一下。周围的人会问，那么，这是否表示有一组对象？你有一堆点，并且有从点到点的方法。这就是他标记这些箭头的原因。因此，我们可以将其视为成本，即从 x₁ 到 x₂ 的最短距离。数字 1 表示从 x 到 x 的成本为零，例如 e 小于或等于成本。</font></font></p><p>So, question: What do a and b say when V is a marked? Let’s take a
            few minutes to discuss that. Whoever is around is like, so, does this
            say has a set of objects? You’ve got a bunch of dots, and you’ve got
            ways to go from dot to dot. That’s why he’s labeling those arrows. So,
            we can think of it as the cost, the least distance to get from x₁ to x₂.
            Number one says that the cost of getting from x to x is zero, like e is
            less than or equal to the cost.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们的函数基本上是成本，但它是 P 值成本。成本像 C 吗？是的。小于或等于则为假。当我说成本时，请注意成本有一个我们称之为成本的东西，所以像数字 b 部分。所以，哦，你试图回答你对 a 提出的问题。那么，它说了什么？对于任何人来说……那么，c(xx) 总是正确的还是正确的？嗯，所以，具体来说，如果我们解释这一点，它说的是真小于 c(xx)。</font></font></p><p>Our function basically, like, yeah, it’s the cost, but it’s the P
            valued cost. Is the cost like C? Yeah. False is less than or equal to
            of. And when I said cost, note that cost has a thing we call cost has,
            so like number b part. So, oh, you were trying to answer the question
            you did for a. So, what does it say? For anyone have any… So, what is
            c(xx) is always true or right? Well, so, so in particular, so if we
            interpret that, it says that true is less than c(xx).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是 true 是顶部元素，所以我们总是有 c(xx) 小于 true。所以，这有点等同于，我明白了，c(xx) 是……第二个说什么？有人知道吗？嘘……对。好的，让我们……那完全正确。那么，让我把它抄下来。它说……好吧，我要说我将使用这种符号，就像我使用 c(xy) 和 c(yz) 意味着 c(xz)。好的。所以，现在我想使用这种符号，而不是当我有的时候，而不是写 c(xx) 等于 true，我想写符号。</font></font></p><p>But true is the top element, so we always have c(xx) is less than
            true. So, this is sort of equivalent to, I see, c(xx) is… What’s the
            second one say? Anyone? Sh… right. Okay, so let’s… that’s exactly right.
            So, let me copy that down. It says that… well, I’m going to say that I’m
            going to use this notation, like I used c(xy) and c(yz) implies c(xz).
            Okay. So, now I want to use this notation instead of when I have,
            instead of writing c(xx) equals true, I want to write the notation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">每当 c(xy) 等于真时，我都会写 x &lt; y。对吧？所以，这里的这个语句表示 x &lt; x，我们之前见过。对吧？这是反身性。那么，现在，这个语句说了什么？有人想大声说出传递性吗？是的。它说这个……所以 c(xy)，它表示 x &lt; y，嗯，好的。而 y &lt; z 意味着 x &lt; z。这是传递性。所以，我在周二提到，另一种思考预订单的方式是将其视为牛市类别。</font></font></p><p>Whenever c(xy) equals true, I’m going to write x &lt; y. Right? So,
            this statement here says that x &lt; x, which we’ve seen before. Right?
            This is reflexivity. So, now, what does this statement say? Does anyone
            want to shout out that transitivity? Yeah. It says that this… so c(xy),
            it says that x &lt; y, well, yeah, okay. And y &lt; z implies that x
            &lt; z. This is transitivity. So, I mentioned on Tuesday that another
            way of thinking about a pre order is as a bull category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，预序，范畴。预序可以是函数，但是当我们将其定义为序时，它可以是关系，这有什么奇怪的吗？任意关系。我们定义时是否说过？所以，我们所说的关系是 X 上的二元关系，它恰好是子集。这是一个非常好的问题。所以，当我们定义预序时，我们说它是 X * X 的子集。对吗？</font></font></p><p>So, preorders, categories. Is there anything weird about the fact
            that pre orders has could be a function, but when we define it to be
            orders, it could be a relation? An arbitrary relation. When we defined
            or did we not say that? So, the relation we said was a binary relation
            on X, which is exactly a subset. That’s a very good question. So, when
            we defined pre orders, we said that then is a subset of X * X.
            Right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，我们已经说过，我们想要一个从 X * X 到 {true, false} 的函数。逻辑上，这两个东西是同一回事，这是一个相当重要的观察。对吧？那么，如果我们有一个 X * X 的子集，我们如何得到一个从 X * X 到 {true, false} 的函数？我们将该子集中的任何内容设置为 true，将其他内容设置为 false。同样，如果我们有一个这样的函数，并且我们想要一个子集，我们只需取映射到 true 的元素子集。</font></font></p><p>Now, we’ve said that we want instead a function from X * X to {true,
            false}. And it’s a rather important observation in logic that these two
            things are the same thing. Right? So, if we have a subset of X * X, how
            do we get a function from X * X to {true, false}? We send anything in
            that subset to true and anything else to false. Similarly, if we have a
            function like this, and we want a subset, we just take the subset of
            elements that map to true.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这是逻辑中大量使用的一一对应关系。我们称这个东西为子对象分类器集。我们将在第 7 章中看到更多内容。因此，在最后两节课中……问题。抱歉，我仍然对 b 下的注释感到困惑。那么，我们是在说 c……我们是否将 c 定义为小于或等于？是的，是的。所以这正是这种对应关系，我想我应该早点解释一下。</font></font></p><p>So, this is a one to one correspondence that is heavily used in
            logic. We say that this thing is the sub object classifier set. And
            we’ll see more of that in Chapter 7. So, in the last two lectures…
            Question. Sorry, I’m still confused by the note under b. So, is like,
            are we saying c… Are we defining c to be less than or equal to? h, it’s
            yes, we are. So that’s exactly this correspondence, which I guess I
            should have explained earlier.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我们不再将</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c视为从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到真/假的函数
            </font><font style="vertical-align:inherit">，而是将其视为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子集。然后我会写
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是它的真值。所以它要么是真要么是假，对吧？所以你只是用小于来代替</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">？是的，是的。所以它表示如果这是真的并且这是真的，那么这是真的。好的。
        </font></font></p><p>Then, so instead of thinking of <em>c</em> as a function from
            <em>x</em> × <em>x</em> to true/false, we can now think of it as a
            subset of <em>x</em> × <em>x</em>. And then I’m going to write
            <em>x</em> is less than <em>y</em> is sort of the truth value of this.
            It’s so this is either true or false, right? So you’re just writing less
            than instead of <em>c</em>? Yeah, yeah. And so it says if this is true
            and this is true, that this is true. Okay.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我举个例子，也许会有点帮助。这里有一个水果或其他东西的偏序集的例子。芒果很好，桃子也很好，但可能没有芒果那么好。草莓和香蕉还行。没有其他可用的了，对吧？这里有一个用哈斯图表示的偏序集，就像我们前几天看到的一样。将偏序集视为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别表示我们有一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。该集合再次相同，是偏序集的底层集合。</font></font></p><p>So, to maybe it will help slightly if I do an example. So here’s an
            example of a poset of fruits or something. So mangoes are great, peaches
            are also great, but maybe not so great as mangoes. Strawberries, and
            then bananas are okay. Nothing else is available, right? So here’s a
            poset represented by a Hasse diagram, as we saw the other day. Thinking
            of a poset as a <em>v</em> category says that we have a set <em>x</em>.
            The set is again the same, the underlying set of the poset.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这四种水果。函数表示当某物小于另一物时。因此，为了表示从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的函数，我将写出一个表格。我现在要滥用</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。所以这里的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是桃子的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。那么这个函数是什么？它完全符合我的要求，即如果某物小于另一物，那么它就是真的。所以，具体来说，芒果——抱歉，芒果是最好的方法。
        </font></font></p><p>So these four fruits. The function is says when something is less
            than another. So to represent a function from <em>x</em> × <em>x</em> to
            <em>P</em>, I’m going to write out a table. And I’m currently going to
            abuse <em>P</em>. So this <em>P</em> here is <em>P</em> for peach. So
            what’s this function? It says exactly what I was were saying that if if
            something is less than something else, then it’s true. So, in
            particular, mangoes—sorry, mango is that’s what’s the best way to do
            that.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">芒果比其他任何东西都好。所以如果我们把</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">trs</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">放在这里，所有东西都比它自己好，或者至少和它自己一样好。这可能是更好的说法。也许我们可以从这里开始。香蕉是……所以桃子比香蕉好。草莓比香蕉好，桃子和草莓并不比草莓好。它们之间没有可比性。所以草莓也不比桃子好。香蕉也不比其他任何东西好。桃子不比芒果好，草莓也不比芒果好。所以这是这个 poset，或者说预购，作为预购，这是这个预购作为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别。好的。</font></font></p><p>Mango’s better than everything else. So if we put <em>trs</em> down
            here, everything is better than itself, or at least as good as itself.
            It’s probably the better way to say it. Maybe let’s go here. Banana is…
            so peach is better than banana. Strawberries are better than banana,
            peaches, and strawberries aren’t better than strawberries. There’s sort
            of no comparison between them. So strawberries are not better than
            peaches either. Bananas are not better than anything else. Peach is not
            better than mango, and strawberry is not better than mango. So this is
            this poset, or pre order, as a pre order, and this is this pre order as
            a <em>v</em> category. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以让我来记一下“丰富”这个词。这些通常被称为丰富类别或</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">丰富类别，但这种术语有点误导，因为它听起来好像
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别或丰富类别是具有额外结构的类别。所以，把这个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">更多地看作是基数的变化，就像在线性代数中一样。最初，矩阵是在实数上引入的。后来，人们意识到，所有线性代数运算、矩阵组合和向量空间讨论都只需要一个域的结构。所以现在我们要改变基数，讨论复数上的线性代数。
        </font></font></p><p>So let me make a note on that word “enriched.” So these are often
            called enriched categories or <em>v</em> enriched categories, but that
            terminology is slightly misleading because it makes it sound like the
            <em>v</em> category or enriched category is a category with extra
            structure. So, think of this <em>v</em> more as a change of base, like
            in linear algebra. Initially, matrices are introduced over the real
            numbers. Later, it’s realized that all the linear algebra operations,
            matrix composition, and vector space discussions, require only the
            structure of a field. So now we’re going to change base and talk about
            linear algebra over the complex numbers.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这有点不同。比如说，乔丹定理采用了不同的形式，但你仍然可以说话。它仍然是线性代数的某种变体。同样，对于范畴论，大多数范畴论的介绍，以及你在标准数学课程中看到的内容，你都会使用集合上的范畴，这是一个幺半群范畴，而不是一个预序。但我们会讲到这一点。但我们已经开始使用不同基础的范畴。特别是，比如说这里的 B 范畴。预序。</font></font></p><p>This has a slightly different flavor. You’ve got, say, the Jordan
            theorem takes a different form, but you can still talk. It’s still some
            variant of linear algebra. Similarly, with category theory, most
            introductions to category theory, and as you’ll see it in the standard
            math curriculum, you work with categories over sets, which is a monoidal
            category and not quite a pre order. But we’ll get to that. But we’ve
            sort of started with categories over different bases. In particular,
            the, say, B categories here. Pre orders.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">Lee，你有问题吗？不，我只是——你用“C”来表示“特征函数”这个术语？不，我用“C”来表示“类别”，但我想这很方便。是的，这是个好问题。谢谢。</font></font></p><p>Lee, you had a question? No, I just—you use “C” to suggest the term
            “characteristic function”? No, I used “C” to suggest the term
            “category,” but I guess that’s convenient. Yeah, that’s a nice problem.
            Thanks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，类别的另一个重要例子是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">成本</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            类别。</font></font></p><p>Okay, so another important example of categories is <em>cost</em>
            categories.</p>
        <h2 id="metric-spaces"><font style="vertical-align:inherit"><font style="vertical-align:inherit">度量空间</font></font></h2><h2>Metric Spaces</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">令人惊讶的是，它们与度量空间的概念非常接近，很多人可能以前见过度量空间。那么让我来告诉你们度量空间。</font></font></p><p>And they somewhat surprisingly turn out to be very close to this
            notion of metric space, which many of you may have seen before. So let
            me tell you about metric spaces.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，定义：度量空间是一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，一个函数，我们称之为距离函数</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ×
             </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到正实数，开区间 (0, ∞)，这样：
        </font></font></p><p>Okay, so definition: A metric space is a set <em>X</em>, a function,
            which we call the distance function <em>d</em>, from <em>X</em> ×
            <em>X</em> to the positive real numbers, the open interval (0, ∞), such
            that:
        </p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到其自身的距离</font><font style="vertical-align:inherit">为零。</font></font></p>
            </li><li>
                <p>The distance from <em>x</em> to itself is zero.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">它是对称的。因此，从x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离</font><font style="vertical-align:inherit">等于从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离。</font></font></p>
            </li><li>
                <p>It’s symmetric. So the distance from <em>x</em> to <em>y</em> is
                    equal to the distance from <em>y</em> to <em>x</em>.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果从x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离</font><font style="vertical-align:inherit">为零，则
                    </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">等于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。
                </font></font></p>
            </li><li>
                <p>If the distance from <em>x</em> to <em>y</em> is zero, then
                    <em>x</em> is equal to <em>y</em>.
                </p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个想法被称为三角不等式，它表示从x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离加上从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">z</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离
                    </font><font style="vertical-align:inherit">必须小于或等于从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">z</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离。
                </font></font></p>
            </li><li>
                <p>This idea here, known as the triangle inequality, which says that
                    the distance from <em>x</em> to <em>y</em> plus the distance from
                    <em>y</em> to <em>z</em> has to be less than or equal to the distance
                    from <em>x</em> to <em>z</em>.
                </p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">大于或等于，是的，谢谢。</font></font></p><p>Greater than or equal to, yes, thank you.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，空间。很好的例子。你的空间就在空间中。让我们看看。例如，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">ℝ</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2。那么你有两个点
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y ，从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离</font><font style="vertical-align:inherit">就是它们之间直线的长度。因此，我们可以检查，例如，从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x 的距离——这里的这个点</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">——x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">之间的直线</font><font style="vertical-align:inherit">没有长度，所以距离为零。它是对称的。从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y的距离与从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">距离相同
            </font><font style="vertical-align:inherit">。
        </font></font></p><p>So, space. Well, great examples. You space right in the space. So
            let’s just see. Say, for example, <em>ℝ</em>2. Then you have two points
            <em>x</em> and <em>y</em>, and the distance from <em>x</em> to
            <em>y</em> is just the length of that straight line between them. So we
            can check, for example, that the distance from <em>x</em> to
            <em>x</em>—this point here—the straight line between <em>x</em> and
            <em>x</em> has no length, so the distance is zero. It’s symmetric. The
            distance from <em>x</em> to <em>y</em> is the same as the distance from
            <em>y</em> to <em>x</em>.
        </p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的距离</font><font style="vertical-align:inherit">为零，那么
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">必须是同一点，因为任何两个不同的点之间都有一条实际的线。三角不等式是空间中的经典原理，但有许多有趣的距离概念不遵循这些公理。那么，让我们来想一些。一个是努力的概念，对吧？所以，如果不是在平面上，而是在某种山丘上，x 在山顶，y 在山脚，那么从 x 到 y 不需要能量或努力。有东西会从山上滚下来，对吧？所以，这里的这个公理 C 说，如果它们之间没有努力，那么同一点就不被遵守。你还可以看到它不是对称的，因为从 y 到 x 比从 x 到 y 需要更多的工作。所以，我们也没有那个。
        </font></font></p><p>If the distance from <em>x</em> to <em>y</em> is zero, then
            <em>x</em> and <em>y</em> have to be the same point, because any two
            distinct points have a sort of actual line between them. The triangle
            inequality is a classical principle in space, but there are many
            interesting notions of distance that do not obey these axioms. So, let’s
            think about some. One is some notion of effort, right? So, if instead of
            being on a plane, this was some sort of hill, and we had x at the top of
            it and y at the bottom, then it takes no energy or no effort to get from
            x to y. Something will just roll down the hill, right? So, this axiom,
            C, here, that says that if there’s no effort between them, then the same
            point is is not obeyed. You can also see that it’s not symmetric,
            because getting from y to x takes a lot more work than getting from x to
            y. So, we also don’t have that.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个想法是豪斯多夫距离。豪斯多夫距离，即两点之间或两个子集之间的距离，比如说，问。因此，我们可以讨论这个集合和这个集合之间的距离。它表示 x 从 x 到 y 的距离，问：如果我在这里的任何一点，或者在最坏的情况下，我只知道我是 x，我离 y 有多远，对吗？所以，如果我想知道从 x 到 y 的距离，它由这可能是离 y 最远的点给出，它由这条线的长度给出，对吗？</font></font></p><p>Some other idea is Hausdorff distance. So, Hausdorff distance, the
            distance between two points, or between two subsets, say, says ask. So,
            we can talk about the distance between this set and this set. And it
            says that the distance of x from x to y asks: if I’m at any point in
            here, what’s the, or in the worst case scenario where I just know that
            I’m an x, how far am I from y, right? So, if I want to know the distance
            from x to y, it’s given by this is probably the furthest point from y,
            and it’s given by the length of this line, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这不是对称的，因为如果我问，如果我在 y 中，我能离 x 最远的点是什么？这就像这里一样。所以，从 y 到 x 的距离，这是从 x 到 y 的距离，这是从 y 到 x 的距离。所以，这是一个非常重要的数学例子，它是一种度量或一种度量类结构，但不是通常意义上的度量。虽然从经典意义上讲，豪斯多夫距离是对称的。哦，好的，是的，但没有必要。我们可以，我们可以处理这个问题。</font></font></p><p>Which is not symmetric, because if I ask, if I’m in y, what’s the
            furthest point I can be from x? That’s something like here. So, the
            distance from y to x, this is the distance from x to y, this is the
            distance from y to x. So, it’s a very important mathematical example of
            a metric or a metric like structure that is not a metric in the usual
            sense. Although classically, Hausdorff distance is symmetrized. Oh,
            okay, yeah, but there is no need to. We can, we can handle that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，让我们看看。我想再举一个类似的例子，比如步行距离。我之所以举这个例子，是因为我想要一个需要无限距离的东西。所以，具体来说，我对这个定义的三个部分有点质疑。一个是，哦，有 B 和 C，但还有一种观点，即距离必须是有限的。所以，如果你看从这里到澳大利亚的步行距离，那是不可能走路的。所以，我们可以考虑用无限的距离来标记，好吗？</font></font></p><p>So, let’s see. I guess to give one other example similar to this
            might be something like walking distance. I include this example because
            I want something that requires infinite distances. So, in particular,
            I’m sort of taking issue with three parts of this definition. One is
            this, what, oh, there’s B and C, but there’s also this idea that
            distances must be finite. So, if you’re looking at like the walking
            distance from here to Australia, that’s it’s not possible to walk. So,
            we might think about marking out with an infinite distance, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我们如何用距离概念来纠正这些问题呢？</font></font></p><p>So, how can we rectify these issues with the notion of distance?</p>
        <h2 id="cost-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">成本类别</font></font></h2><h2>Cost Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，让我们想想什么是成本类别。那么，什么是成本类别？好的，它是一个集合 X，它是一个函数 X * X 到 0，无穷大，封闭，我现在将其称为 B，这样。那么，在这种情况下，A 会说什么？它表示我拥有成本的最小单位是什么，但请记住，它表示零大于零加。所以，单位是零，这将大于所有 x 到 x 的距离。</font></font></p><p>Well, let’s think about what a cost category is. So, what is a cost
            category? Okay, so it’s a set X, and it’s a function X * X to 0,
            infinity, closed, which I’ll call B, now, such that. So, what does A say
            in this situation? It says that the minimum unit where I have what cost
            is, but remember that it says zero is greater than zero plus. So, the
            unit is zero, and that’s going to be greater than the distance from x to
            x for all x.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其次，复合陈述表明 x 到 y 的距离加上 y 到 z 的距离总是大于 x 到 z 的距离。因此，我们确实有这种度量空间的修正定义，或者度量空间的另一种定义，其中我们有条件 a，条件 b。条件 d 在那边吗？我们扩展了我们的域。我们可以取值。因此，这也被称为 L 度量空间。L 是一个很棒的范畴论问题。当你做解析极限时，你可以对范畴极限进行分类，比如，你能用这种方式进行分析吗？我想说，大致上是可以的，但还有很多值得探索的地方。</font></font></p><p>Second, the composition statement says that the distance from x to y
            plus the distance from y to z is always greater than the distance from x
            to z. So, we exactly have this sort of corrected definition of a metric
            space, or this alternate definition of a metric space where we have
            condition a there and condition b here. Is condition d over there? And
            we’ve extended our domain. We’re allowed to take values. So, this is
            known also as an L metric space. L is a great category theorist
            question. Can, when you do analytic limits, you can categorical limits
            like, like can you do analysis this way? That’s roughly yes, I would
            say, but there’s a lot to explore.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。我们还有大约两分钟的时间，所以我只想提醒大家，您可以像演示一样，使用其中一个图表（有向图）进行预订。</font></font></p><p>Okay. I, we got about two minutes left, so I just want to make a note
            that in the same way that you can present, you can take one of these
            diagrams, a directed graph, and get a pre order.</p>
        <h2 id="directed-graphs-and-cost-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">有向图和成本类别</font></font></h2><h2>Directed Graphs and Cost
            Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，您可以从图中得到一个公有类别。有一种方法可以呈现跨类别或从有向图中得到 L 度量空间。因此，具体来说，您可以将有向图视为边标记为真和假的图。但具体来说，它们都标记为真。如果一条边标记为假，则您不会绘制它。同样，您只需拥有一个有向图，其中有标记距离的事物，就可以生成一个 L 度量空间。</font></font></p><p>So, you can, from a graph, you can get a bull category. There’s a way
            of presenting cross categories or getting L metric spaces from directed
            graphs. So, in particular, you might view a directed graph as labeled as
            a graph where the edges are labeled by true and false. But, in
            particular, they’re all labeled by true. And if an edge is labeled by
            false, you don’t draw it. In the same way, you can generate an L metric
            space just by having a directed graph where there are things labeled
            with distances.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们挑选三个地方：麻省理工学院、波士顿公园和水族馆。假设出于某种原因，我们只能走这些路径。我们只需写下一个有向图，并标注我们可以去哪里以及去那里需要多长时间或去那里需要花费多少钱，就可以得到某种度量空间或某种 L 度量空间。</font></font></p><p>Let’s pick, sort of, I don’t know, three places around here: MIT,
            Boston Common, and the Aquarium. And let’s say, for some reason, we can
            only get, we can only take these paths. We get some sort of metric space
            or some L metric space by just writing down a directed graph with labels
            that say where we can go and how long, or how much it costs to get
            between.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这样做的方法是，我们展示一个类别，其中包含这些面。这是一条鱼，是的，这是水族馆的鱼。从任何地方到它自己的距离都是零。从麻省理工学院到波士顿公园的距离显然是四。到波士顿公园是五。从波士顿公园到麻省理工学院，我们必须经过水族馆，所以我们走最短的路径。所以，这是 11。到水族馆是 8。然后它现在又是三和八。</font></font></p><p>So, the way this is done is that this presents a category where we
            have these faces. That’s a fish, yeah, that’s fish for aquarium. And
            what the distance from any place to itself is is zero. The distance from
            MIT to, say, the Common is apparently four. To Boston Common is five.
            From Boston Common to MIT, we have to go via the Aquarium, so we take
            the shortest path. So, this is 11. To the Aquarium is eight. And then
            it’s currently three and eight again anyway.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这将采用一个图表并生成一个成本类别。并且有一种非常有趣的方式来生成这个东西。有向图理想情况下应该只表示边，不包括长度大于 1 的路径。因此，我们可以说从这里到这里的一跳距离将是无穷大。您无法一步从 Button Common 到达 MIT，也无法一步从 MIT 到达 Aquarium。MIT。使用矩阵乘法的一些概念，您可以获取任何有向图并将其编码为矩阵，然后将这些矩阵相乘以构造类别本身的函数，这是一件非常有趣的事情。课程结束后，我可以告诉大家更多有关这方面的内容。</font></font></p><p>So, this takes a graph and generates a cost category. And there’s a
            fun, fun way to do this with to generate this thing. A directed graph
            should ideally represent only the edges, excluding paths longer than
            length one. So, we might say that the one hop distance from here to here
            is going to be infinity. You can’t get from Button Common to MIT in one
            step, or from MIT to Aquarium in one step. MIT. And using some notion of
            matrix multiplication, you can take any directed graph and code it as a
            matrix and multiply those matrices out to construct the function of the
            category itself, which is a super fun thing to do. I can tell people
            more about that after the class ends.</p>
        <h1 id="applied-category-theory.-chapter-3-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 3 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 3, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 19 日) — 53:15 </font></font><a href="https://youtube.com/watch?v=T2vge38STok"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=T2vge38STok</font></font></a></p><p> 6
            years ago (Jan 19, 2019) — 53:15 <a href="https://youtube.com/watch?v=T2vge38STok">https://youtube.com/watch?v=T2vge38STok</a></p>
        <h2 id="summary-4"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">由 David 和 Brendan Fong (Spifong) 教授的 MIT 课程 18S097 讲座介绍了使用类别理论的数据库和数据转换。讲座解释了如何将数据库模式视为类别、将数据库实例视为函子以及将数据转换视为通用构造。本课程将在下一讲中进一步探讨函子和数据转换。问题集 2 现已可用。</font></font></p><p>This MIT Course 18S097 lecture, taught by David and Brendan Fong
            (Spifong), introduces databases and data transformations using category
            theory. The lecture explains how database schemas can be viewed as
            categories, database instances as functors, and data transformations as
            universal constructions. The course will explore functors and data
            transformations further in the next lecture. Problem Set 2 is now
            available.</p>
        <h2 id="introduction-to-databases-and-data-transformations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库和数据转换简介</font></font></h2><h2>Introduction
            to Databases and Data Transformations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，开始之前还有什么问题吗？好的。今天我们将讨论数据库和数据转换，以此作为思考类别、函子、极限和余代数神话的一种方式。但实际上我们主要还是讨论数据库和数据，今天主要依赖于类别中的数据库。明天我们将讨论函子和数据转换等内容。</font></font></p><p>Okay, any questions before we start? Okay. So, today we will talk
            about databases and data transformations as a way of thinking about
            categories, functors, and limits and coalgebra myths. But we’ll actually
            mainly just stick with databases and data, dependent mainly on this
            database in categories today. And then tomorrow will be functors and
            data transformations and stuff like that.</p>
        <h2 id="reliable-communication-and-open-source-tools"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可靠的通信和开源工具</font></font></h2><h2>Reliable
            Communication and Open Source Tools</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是您可以使用的密钥。我想我会保留这个板。我有讲座，所以您可以使用这个密钥。基本思想：数据库模式将是类别。所以，如果你听到有人担心使用“模式”这个词，谈论，好吧，对于一个模式，它就像一个类别。一个数据库实例，比如如果数据库中至少有一个特定的时间，那就是所谓的 dolly 函子。而大的转换是有序的，称为通用构造，将数据从一个模式移动到另一个模式的方法，而无需做出任何选择，只需执行这些选择。</font></font></p><p>Here’s the key that you can use. I think I’ll keep this board. I’ve
            got the lecture, so you can use this key. Basic idea: the database
            schemas are going to be categories. So, if you ever hear someone worried
            about using the word “schema,” talking about, okay, with a schema, it’s
            like a category. A database instance, like what if databases has in it
            at least certain time, that’s a said dolly functor. And big
            transformations are ordered called universal constructions, ways of
            moving data from one schema to another while making no choices, just
            doing these choices.</p>
        <h2 id="databases-and-knowledge-representation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库和知识表示</font></font></h2><h2>Databases and Knowledge
            Representation</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我稍后会谈论这个。可靠的沟通，很快就会谈论这个，但我只想告诉你，有一个开源工具可用。我认为这是正确的网站。我得到了确认：nubbie.ww.categorical data thought.net。那里有一个 GitHub 页面。最后，宣布问题集 2 现已可用。</font></font></p><p>So, I’ll talk about this in a second. Reliable communication, talk
            about that soon, but just want to tell you that there’s an open source
            tool available. I think this is the right website. I’m getting
            confirmation: nubbie.ww.categorical data thought.net. There’s a GitHub
            page there. And lastly, an announcement that Problem Set 2 is now
            available.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你想去……哦，我知道。所以，我想对我来说，数据库是关于可靠通信的。数据库和数据转换。所以，想象一下你试图理解什么是知识，因为什么或变成什么信息。</font></font></p><p>If you want to go… oh, I know. So, so I guess for me, databases are
            about reliable communication. Databases and data transformations. So,
            imagine you are trying to understand what knowledge is, because or into
            what information is.</p>
        <h2 id="mathematical-perspective-on-databases"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库的数学视角</font></font></h2><h2>Mathematical Perspective
            on Databases</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以花很长时间思考信息到底是什么，但我们可以从存储在数据库中或存储在我们头脑中开始。那么，你所知道的数据结构是什么？让我们假设你可以把它放在数据库中。我不认为你真的可以，但假设你可以。那么，如果我的数据库是一些以某种奇怪的方式连接的神经元，而你的数据库是一些以不同方式连接的神经元，那么它们的连接方式就不一样了。</font></font></p><p>You can contemplate for a long time what information actually is, but
            we kind of can start by saying that stored in databases or stored in our
            heads. So, what is the data structure of what you know? Let’s pretend
            you could put it in a database. I don’t think you actually could, but
            suppose you could. Then, if I have my database into some neurons
            connected in some weird way, and you have yours, they’re not connected
            in the same way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它们与我们的视网膜或指纹相比有很大不同。我如何将信息传递给你，而你实际上也收到了信息？这怎么可能呢？那么，沟通如何可能呢？可靠的沟通如何可能真正起作用？我认为人们并不真正了解这一点，但是……但是如果我们想象我们有数据库，那么我有原生八种。你有一个数据库。我们以不同的方式构建信息。我需要一种将我的数据传输给你的方法。换句话说，我所学的所有例子，我想将其中一些传达给你。</font></font></p><p>They’re more different than our retina or our fingerprint. How is it
            that I can get information to you, and you actually receive it? How is
            that possible? So, how is communication possible? How is it possible
            that reliable communication actually works? I don’t think people really
            know this, but… but if we imagine that we have databases, then I have
            native eights. You have a database. We’ve structured information
            differently. I need a way of transferring my data to you. In other
            words, all the examples of everything I’ve learned, I want to
            communicate some of them to you.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因为我们都有某种简化的世界观，比如我们无法用这些常数来理解世界，所以我们会简化并忘记很多东西。我们会做等价运算，我们会四舍五入等等。但是，我对世界的理解和简化方式与你们不同。我仍然需要找到一种方法来向你们传递信息。当你拥有以同样的方式反复传递信息的数学产物时，就会发生可靠的交流。</font></font></p><p>Because we all have some kind of simplified worldview, like we can’t
            get the world as it is in these constants though, and so we simplify and
            we forget lots of stuff. We make equivalences, we round off, etc. But
            still, I wrap and I simplified in the world differently than you do. I
            still need to find a way to get information to you. Reliable
            communication occurs when you have mathematical artifacts that
            consistently transmit information in the same way repeatedly.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这不是当前商业等行业的做法。他们将信息从一个数据库移动到另一个数据库的方式是通过脚本，比如 Python 脚本，这些脚本以后无法重复，因为数据库会发生变化，人员会离开组织等。而且这些脚本的编写方式也不同——不同的数字，不同的方式来书写同一个数字。编写同一个软件脚本来发送数据的方法有很多种。当你试图读取别人的软件时，可能会很困难。</font></font></p><p>This is not the current practice in business, etc. Where the way they
            move information from one database to another is through scripts, say
            Python scripts, that you can’t repeat later because the database
            changes, the person leaves the organization, etc. And they’re written in
            kind of different ways—different numbers, different ways of writing the
            same number. There are more ways of writing the same software script to
            send data. And when you’re trying to read someone else’s software, it
            can be hard.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">而如果你有某种数学工具，它就会变成九，甚至九十，这样就更好了。所以，这就是数据库观点的目标，或者数据库数学观点的目标，使整个数据库概念更加数学化。</font></font></p><p>Whereas if you have some kind of mathematical artifact, this just
            becomes a nine, and some kind of really ninety way, and that’s better.
            So, so that’s kind of the goal of this database point of view, or this
            mathematical point of view on databases, to make the whole database idea
            more mathematical.</p>
        <h2 id="categories-and-database-schemas"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和数据库模式</font></font></h2><h2>Categories and Database
            Schemas</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这样就可以移动信息，也就是我们的数学产物。当然，这不仅发生在两个不同的数据库之间，也发生在你和朋友之间，也发生在你和未来的你之间。所以你需要记住一些事情。这就是你以前想做的事情。但你需要记住的东西与你记录的东西不同。你只需要记住一个小方面。你想查询你的旧信息，并使某些东西现在可供你访问，你可以现在使用。</font></font></p><p>So that way to move information, our mathematical artifacts. And of
            course, this takes place not just between two different databases, but
            from or between you and a friend, but between you and a future you. So
            you need to remember things. That’s what you kind of think to do this
            before. But what you need to remember is different than what you
            recorded. You need to remember only one small aspect. You want to query
            your old information and make something accessible to you now that you
            can use now.</p>
        <h2 id="categories-and-morphisms"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴和态射</font></font></h2><h2>Categories and Morphisms</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，数据转换，你不应该只考虑在人与人之间传递，也应该考虑从你自己到未来的自己，因为你的理解和你与世界联系的方式会发生变化。你还如何回忆事情？好的。</font></font></p><p>So, data transformations, you shouldn’t just think about sending it
            between people, but also from yourself to a future self, as your
            understanding and the way you schema ties the world changes. How do you
            still recall things? Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是设置。下一层，可能稍微不那么哲学，但仍然有点哲学。我想思考一下我所说的数据运动学。这是以下两件事中的任何一件：它如何静止以及如何移动。数据在数据库中静止；这就是数据什么也不做，坐在那里，就是数据。它如何移动是通过数据转换。人们很少谈论这一点，但它实际上和移动一样重要。我的意思是，它是如何将数据从一个地方传输到另一个地方，如何改变它的形式。</font></font></p><p>So that’s kind of the setup. The next layer, slightly less
            philosophical, maybe, but still kind of philosophical. I want to think
            about what I call data kinematics. And that is any of those two things:
            how it rests and how it moves. Data rests in databases; that’s data
            doing nothing, sitting there, being data. How it moves is through data
            transformations. And people talk about this less, but it’s actually as
            important as movement. I mean, it’s how you get the data from one place
            to another, how you change its form.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。当你移动时，你会改变通道四，并且会改变很多可访问的内容。就像现在，这是可访问的，但如果我移到这里，其他内容也是可访问的。所以你想改变数据中可访问的内容。我不想改变全部，只想改变这一部分。让我可以访问这一部分。所以我们想了解它在那里的位置和移动方式。所以它存在于数据库中。我将从网络开始。</font></font></p><p>All right. When you move, you channel four, and you change much
            accessible. It’s like right now, this is accessible, but if I move over
            here, something else is accessible. So you want to change what’s
            accessible in the data. I want to not all of it, just this part. Make
            this part accessible to me. And so we want to understand how it rests
            there and how it moves. And so it rests in databases. The network where
            I’ll start.</p>
        <h2 id="example-of-a-database-schema"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库架构示例</font></font></h2><h2>Example of a Database Schema</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，什么是数据库？下面是一个例子。我先从你可能看到的样子开始。你可能会在员工表中看到员工。每个员工都有名字和经理。每个员工都在一些部门工作，而且部门也存在。他们有名字和秘书。所以，我会画一条双线来表示我们实际看到的内容。</font></font></p><p>So, what is a database? Here’s an example. And I’ll just start off
            with how you might see it. You might see employees in your employee
            table. Every employee has a first name and a manager. Every employee
            works in some departments, and departments also exist. They have names
            and secretaries. So, I’ll put a double line for kind of what we’re
            actually looking at.</p>
        <h2 id="database-schema-as-a-category"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库模式作为类别</font></font></h2><h2>Database Schema as a
            Category</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们在这里查看员工，我们在这里查看部门，我会在其他列之间放置单行姓名。</font></font></p><p>We’re looking at employees here, we’re looking at departments here,
            and I’ll put single name lines between the other columns.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在您的数据库中，我现在拥有的就是所谓的模式。这就是您简化世界的方式。世界由这些东西组成，它们之间的关系如下。事实上，您可能想说名字是一个类型字符串，或者经理将是另一个员工，或者工作地点将是某个部门。所以，对我来说，从技术上讲，这就是模式的一部分，它要去哪里——这些东西意味着什么。</font></font></p><p>So, in your database, what I have now is called the schema. It’s how
            you’re simplifying the world. The world consists of these things, and
            here’s how they’re related. In fact, you might want to say that first
            name is a type string, or manager is going to be another employee, or
            works in is going to be a department. So, that is technically, for me,
            part of the schema, where it’s going—what these things mean.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，对于员工，您可以有员工一、二、三。一号员工的名字是 Alice，二号员工的名字是 Bob，三号员工的名字是 Carlisle。州。一号员工的经理是三号员工，而三号员工本身就是经理。一号员工在 101 工作，二号员工在 102 工作，一号员工在三号员工中工作。这些是部门类型，因此它们位于部门表中。部门一是销售部门，部门二是 IT 部门。秘书 — 这个是 101，员工一，庇护所 — 这个是员工二。因此，秘书属于员工类型。这是一个数据库，这是一个数据库模式。</font></font></p><p>So, employee, you can have employee one, two, three. The first name
            of one is Alice, and two is Bob, and three is Carlisle. State. The
            manager of one is three, and the meant to is manager of the cells, and
            three as management themselves. And one works in 101, and two works in
            102, and one works in three works in one. These are a type department,
            so they land in the department table. Department one is sales, and
            department two is IT. Secretaries—this one is 101, employee one, and
            sanctuary—this one is employee two. So, the secretary is of type
            employee. That’s a database, that’s a database schema.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">线的顶部是一个实例。线的下方，实例表示在某一时刻。我们一直都知道这是真的，但我可以从技术上添加或假装实际上有一个包含所有弦的表，只是为了让理论很好地发挥作用，或者让理论简单地发挥作用。当你不考虑弦表时，理论可以很好地工作，但那时它只是——我需要制造稀薄的水。</font></font></p><p>On top of the line is an instance. Below the line, instance means at
            some instant of time. This we’ve always known this was true, but I could
            technically add or pretend that there’s actually a table full of all
            strings, just for it to make the theory work out nicely, or to make the
            theory work out simply. The theory works fine when you don’t consider
            there to be a table of strings, but then it’s just—I need to make thin
            little water.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在字符串表中，您有所有您喜欢的字符串，包括销售额等。您从未实例化该表，但它没有表单。除了 ID 列之外，它没有其他列。现在这里的所有内容都是所谓的外键。您有这些身份 ID 列 - 员工 ID、部门 ID，我猜是字符串 ID。您的名字就是所谓的外键。它将您从您所在的表（员工表）指向外部表。经理将您从您所在的表带到外部表（员工）。这就是这些。它们是键或 ID，以及其他人。</font></font></p><p>So, in a table of strings, you have, yeah, all—you have sales, etc.,
            in your favorite strings. And you’ve never instantiated that table, but
            it has no form. It has no columns other than the ID column. And now
            everything here is what is called foreign. Keys. You have these identity
            ID columns—the employee IDs, the department IDs, and I guess the string
            IDs. You have first name is what’s called a foreign key. It points you
            from the table you’re in—the employee table—to a foreign table. And a
            manager takes you from the table you’re in to a foreign table—employees.
            And that’s what these are. They’re the keys or the IDs, and other
            people.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在某些情况下，数据库是一个互锁表的系统。但我们可以安排所有这些信息——只是它的模式。模式，我们可以通过说明我们有哪些表来很好地安排它：员工、部门和字符串。我将使用开口圆圈而不是闭合圆圈来拆分字符串，因为它很奇怪；它是一种数据类型。它来自我们的编程语言，Java 或其他语言。它不是我们要自己填写的东西。所以，这是字符串与员工和部门之间的一个小小的技术差异。</font></font></p><p>So, in some, a database is a system of interlocking tables. But we
            can arrange all that information of this—just the schema of it. The
            schema, we can arrange it pretty nicely by saying what tables we have:
            employees, departments, and strings. I’ll break strings using an open
            circle instead of a closed circle because it’s that weird; it’s a data
            type. It’s from our programming language, Java, or whatever. It’s not
            something we’re going to get to fill in ourselves. So, that’s a slight
            technical difference between string and employees and departments.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在我们有了这三张表。每个员工都在一个部门工作，每个部门都有一名秘书，每个员工都有一名经理，每个员工都有名字，每个部门都有 [不清楚]。</font></font></p><p>So, now we have these three tables. We have that every employee works
            in a department, every department has a secretary, every employee has a
            manager, every employee has a first name, and every department has
            [unclear].</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，如果你数一数，就会发现有三个点，就像那里画了三张桌子一样。这不是巧合。有一、二、三、四、五个箭头，就像有五个非标识列：一、二、三、四、五。所有非空列。所以，这五和五并不是巧合。</font></font></p><p>And now, if you count, there are three dots, just like there are
            three tables drawn there. That’s not a coincidence. There are one, two,
            three, four, five arrows, just like there are five non identity columns:
            one, two, three, four, five. All the non empty columns. So, those five
            and five are not coincidences.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">实际情况是，从这里的任意一个点发出的箭头代表那边表格中的列。因此，经理、工作单位和名字是那里的三列，就像这里有三个箭头一样。</font></font></p><p>What’s going on is that arrows emanating from any dot here are the
            columns in the table over there. So, the manager, works in, and first
            name are the three columns there, just like there are three arrows
            here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对此还有什么疑问吗？</font></font></p><p>Any questions about that?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当然。</font></font></p><p>Sure.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">更正姓氏。</font></font></p><p>Rectified last name.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，好的。</font></font></p><p>Okay, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">顺便说一句，我还可以向这个模式中添加业务规则或完整性约束，以确保人们输入数据的方式不与我作为设计师所希望的方式相悖。</font></font></p><p>And I could also, by the way, add to this thing, this schema, a
            business rule or an integrity constraint that ensures that the way
            people enter data to this is not contrary to the way I want them to as a
            designer.</p>
        <h2 id="database-schema-and-integrity-constraints"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库模式和完整性约束</font></font></h2><h2>Database Schema and
            Integrity Constraints</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我犯了错误，它就会发出一个标记。所以，这很有用。</font></font></p><p>So, it’ll throw a flag if I make a mistake. So, that’s useful.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，例如，我可能知道，对于部门类型中的所有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d ， </font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p.secretary</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">（该部门的秘书）</font><font style="vertical-align:inherit">都在该部门工作。</font></font></p><p>So, I might know, for example, that for all <em>d</em> in type
            department, it’s the case that <em>p</em>.secretary (the secretary of
            that department) works in that department.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我可以添加任意数量的方程式。这些方程式的唯一规则是，它们都是“适用于所有”的形式。对于所有员工，经理可能与员工在同一个部门工作，或类似情况。实际上不太可能发生这种情况，但因为这样你就永远不会超越自己的部门。</font></font></p><p>So, I can add any number of equations. The only rule for these
            equations is that they’re all of the form “for all” something. For all
            employees, maybe the manager works in the same department as the
            employee works in, or something like that. Doesn’t actually tend to
            occur, but because then you never get beyond your own department.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，但是对。所以，如果我从一个部门开始，我可以选择按照这样的路径，也可以选择简单的路径，然后让它们相同。</font></font></p><p>But, but right. So, if I start in a department, I can either follow
            the path around like this, or the trivial path, and I make them the
            same.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你在这里查看一下，就会发现它说的是：如果你在一个部门开始，找到秘书一号，看看他们会在哪个部门工作，结果又是 101。所以，101 名秘书，一名在 101 部门工作，一名或两名秘书在 1 部门或 2 部门工作。所以，这满足了这些限制。</font></font></p><p>And if you check over here, why it’s saying is: if you start in a
            department and find the secretary one and see what department they will
            work in is again 101. So, 101 secretaries, one works in 101, one or two
            secretaries two works at one or two. So, this satisfies those
            constraints.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">明天，我们很快就会看到，这实际上是一个类别的呈现。</font></font></p><p>And tomorrow, and what we’ll see soon, is that this is actually a
            presentation of a category.</p>
        <h2 id="categories-and-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴和函子</font></font></h2><h2>Categories and Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就像类别的哈斯图。并且这个类别中的一个函子，比如当我在顶部遇到我所说的数据库模式时，它等于类别，然后是一个从这个类别到集合类别的函子，它被称为集值函子。我们不知道——我还没有告诉你这个类别是什么，或者函子是什么。事实上，我要到明天才会告诉你函子是什么，或者布伦丹会在周二告诉你。然而，这将分配一组员工、一组部门、一组字符串和函数：（</font></font><code>manager</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            将每个员工分配到一个员工）和</font></font><code>workson</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">（将所有内容分配到一个部门）。所以，从那里到集合的函子会给我一些方法，一些这个数据库模式的实例。</font></font></p><p>This is like the Hasse diagram for a category. And that a functor
            from this category, such when I met my said database schema equals
            category at the top, and then a functor from this category to the
            category of sets, which is called the set valued functor. We don’t—I
            haven’t told you whether the category is yet, or what a functor is. In
            fact, I won’t tell you what a functor is until tomorrow, or Brendan will
            tell you on Tuesday. However, this will assign a set of employees, a set
            of departments, a set of strings, and functions: <code>manager</code>
            (taking each employee to an employee), and <code>workson</code> (taking
            everything to a department). And so, a functor from there to sets will
            exactly give me some way, some instance of this database schema.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这个家伙在范畴论中，有很多这样的箭头。所以，无论我想表示什么，我都会使用像闪电箭头这样的箭头，好的。</font></font></p><p>So, this guy there in category theory, of these arrows, a lot. So,
            whatever I want to indicate something, I use a, like, a lightning bolt
            arrow, like, okay.</p>
        <h2 id="categories-and-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和图表</font></font></h2><h2>Categories and Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些除了表明这一点之外没有任何意义。到目前为止对此还有什么疑问吗？</font></font></p><p>Those never mean anything except indicating it. Any questions so far
            about this?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么 Serena，还有其他类型的想法，对吧？因为字符串，我实际上无法填写我自己的字符串版本。哦，我明白了。好的。它们是一种数据类型，可以提供给其他问题。好的，这是静止的数据，还有运动中的数据。我们必须等到明天才能讨论，但它基本上就像数据转换。</font></font></p><p>Why Serena, sort of, all the other types of thoughts right? Because
            strings, I don’t actually get to fill in my own version of of strings.
            Oh, I see. Okay. They’re a data type that’s kind of given to other
            questions. Okay, so that’s data at rest, and there’s data in motion. We
            have to wait till tomorrow to there we got talked about, but it’s
            basically like data transformations.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，转换 — 这些就是查询之类的东西。您向数据库询问一些问题，例如“4G 类型的 employee where 就像 SQL select from where 语句。”尽管我认为编程语言理论领域的人们倾向于，对于 where，返回 — 至少我是这样的，或者我得到了 employee，其中员工的名字等于 Alice。我想 Alice 想知道，在哪工作。比方说，想知道我的部门。如果您愿意，您可以将它们分配给列名。将是 e.worksIn，以及我的，我的秘书，我的秘书部门。我的工作，秘书。我想知道我部门的名称，我想知道我部门的秘书，我想要另一个人。因此，这将返回一个表，其结果是我的部门，有点像一行，我会说，我提取您的 ID，我的部门和我的集合，我的部门被两次称为部门销售，他们的秘书是她自己。</font></font></p><p>So, transformations—these are things like querying. You ask the
            database something, like, “4G of type employee where is like a SQL
            select from where statement.” Although people in programming language
            theory tend to, I think, prefer to, for where, return—at least, I do, or
            I got employee where the employee’s name equals Alice. Alice wants to
            know, I thought, works in. Let’s say, wants to know my department. You
            could assign these to column names if you want. Would be e.worksIn, and
            mine, my secretary, my secretary department. I work, secretary. I wanted
            to know the name of my department, and I want to know the secretary of
            my department, and I want another person. So, this would return a table
            whose results are my department, a little have like one row, and I’ll
            say, I lift your ID, my department, and my set, and my department is
            called twice for department sales, and their secretary is herself.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，对此还有什么疑问吗？我们讨论的是查询。这就是数据移动的方式。这里有所有这些数据，我们改变了它们的形式。我们对数据进行了转换，使其成为这里的数据库。这也是一个数据库；它只有一个。这个数据库看起来像这样：字符串、我的部门、我自己。所以，你有这个非常小的数据库，我们将它从那个移动到这个。所以，有一种叫做查询的东西，人们最了解它，但也有一种叫做 ETL 的过程——提取、转换，然后加载到新数据库之间。有一种叫做仓储的东西。所以，这些都是所谓的结构化数据转换，我讨厌仓储，转换模式演变，你想移动数据。</font></font></p><p>Okay, any questions about this? So, we’re talking about querying.
            That’s the way that data can move. There’s all this data here, and we’ve
            changed its form. We’ve done a transformation of the data to make it a
            database here. This is also a database; it just only has one. This is
            the database whose looks like this: string, my department, at myself.
            So, you’ve got this very small database, and we moved it from that one
            to this one. So, there’s something called querying, which people know
            best, but there’s also something called ETL processes—between extract,
            transform, and then load into a new database. There is something called
            warehousing. So, these are all what are called structured data
            transformations, where I hate warehousing, converting schema evolution,
            you want to move data.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，还有问题吗？现在让我告诉你什么是类别，因为这让我很困惑，希望这会吓到一些东西，然后它就是课程的名称。所以，好的，定义：类别。好吧，想想看，这不是……那是书法……看，这是由一些东西组成的书法。一个由一组、一个表格组成的，看，这些被称为对象。其中的元素被称为对象。对象没有任何意义；它们只是被称为，它们只是对象。</font></font></p><p>Okay, any questions? So, now let me tell you what categories are,
            because that’s pushing me colleges, hopefully that would be will terrify
            some things, and then it is kind of the name of the course. So, okay, so
            definition: a category. Well, thought, see that’s not an… that’s a
            calligraphic… see, it’s a calligraphic see consisting of some things.
            One to consist of a set, table, see, and in these are called objects.
            Elements of this are called objects. Objects aren’t, don’t mean
            anything; they’re just called, they’re just objects.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果有人说一组对象，他们并不是说一组特殊的对象；它们是不同的资产。好吧。这个类别 C 有一个 C 集，然后对于每个 C1 和 C2，我们在 C 中有两个不同的对象，称为子 C、C1、C2。这是一种过时的术语，当时人们只从同态、铃声的外壳监狱或几十个组的角度来考虑类别。这就是“房子”一词的来源。</font></font></p><p>So, if someone says a set of objects, they’re not saying a set that’s
            special; they’re distinct assets. So, okay. And this category, C, is got
            a set of C, and then for every C1 and C2, we’ve got two different
            objects in C, step called sub C, C1, C2. And that’s kind of old
            fashioned who terminology from the time when people thought about
            categories only in terms of homomorphisms, hull prisons of ringtone, or
            dozens of groups. Those are where the word “house” comes from.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">通常，我们更容易放弃无意义的、相当无意义的符号“家”。就像 C、C1、C2 一样，昨天我们讨论了 V 类别，以及 Brendan 称为 X 的对象集。在那里我们写了距离，或者我认为像 D，你们看到了吗。有一个场景；这是一个不同的情况，我们正在研究 V 类别。现在，我们正在研究所谓的集合类别，单​​子类别。它设置了它本身，对于我的朋友称为原始软泥的东西，因为它的一切都可以用来定义其他东西。所以，它在某种意义上非常流畅。你可以在类别理论的不同部分之间移动，并使用它们来讨论，找到其他部分。如果你愿意的话，可以线性地通过这些东西，但实际上能够非常流畅地通过它是件好事。所以，好吧。</font></font></p><p>It’s often easier to drop it’s meaningless, fairly meaningless symbol
            “home.” And just like C, C1, C2, yesterday we talked about a V category,
            and the set of objects Brendan called X. And there we wrote distance, or
            I think with like D, see, you guys went to. There’s a scene; it’s a
            different situation where we were looking at V categories. Now, we’re
            looking at what are called set categories, monoidal category. It sets
            this gives very interlocked into itself, for the kind of a friend of
            mine called primordial ooze, because it’s everything can kind of be used
            to define other things. So, it’s just very fluid and fluent in some
            sense. You can move between different parts of category theory and use
            them to talk about, to find other parts. There is, if you want, a linear
            progression through the stuff, but it’s actually nice to be able to move
            through it pretty fluently, fluidly. So, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们有一组对象。对于每对对象，我们都有一组态射。这些态射被表示为。如果你有这个东西的一个元素，它们就是同一个东西，对吧？或者 C。如果你有一个元素 C1、C2，那么 co 这个词在范畴论中被非常重视。它总是意味着另一个的种类，另一边。好吧，你会发现这没问题。所以，你有一组对象，一组长距离的集合。</font></font></p><p>So, we have a set of objects. We have, for every pair of objects, a
            set of morphisms. And these are denoted. If you had an element of this
            thing, those are the same thing, right? Or C. If you have an element C1,
            C2, and co is the word is taken very seriously in category theory. It
            always means the kind of the other one, the other side. Well, you’ll see
            that as okay. So, you have a set of objects, a set of long distance.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于每个对象，如果你能想到地点和从一个地方到另一个地方的所有方式。对于每个对象 C，都有一个指定的元素，称为 idC 和 C。换句话说，我总是可以从我所在的地方到达我所在的地方。对于每个 C1、C2、C3，一个称为 senecal fat、semi 的函数，它接受 C、C1、C2，它是从 C1 到 C2 的任何方式，从 C2 到 C3 的任何方式，并产生它们的复合。</font></font></p><p>For every object, so if you could think of places and all the ways of
            getting from one place to another. For every object C, there is a
            specified element called idC, and C. In other words, I can always get
            from where I am to where I am. And for every C1, C2, C3, a function
            called senecal fat, semi, that takes C, C1, C2, it’s any way of getting
            from C1 to C2, in any way of getting from C2 to C3, and produces their
            composite.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">至于它如何实现，则取决于类别。如果你能以不同于我的方式做到这一点，那么在我看来，你就有了自己的类别。没有一种特定的方法来组合事物，但如果你有从 c1 到 c2 的方法，有从 c2 到 c3 的年度方法，并且你告诉我你有一个类别……你最好能告诉我如何获得这些学生。你可以删除之前的内容。我们的变量是使其在此边界上连续。因此，这四条信息就是所谓的——嗯，这里有一些元素，有些东西、对象和态射，还有一些结构或一些长度方式，它们是相关的。这些家伙需要满足一些属性。这样就很好了。</font></font></p><p>Which how it does it is up to the category. If you can do it
            differently than I can do it, then you have your own category in my
            mind. There is not one specified way to compose things, but if you have
            a way to get from c1 to c2, an annual way to get from c2 to c3, and you
            tell me you have a category… You better be able to tell me how to get
            those students. You can erase the previous thing. Our variable was to
            make it continuous on this border. So, these four pieces of information
            are what are called—well, there are some elements here, there are some
            things, objects, and morphisms, and there are some structures, or some
            length ways, that they’re related. And these guys need to satisfy some
            properties. That is fine.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第一，对于所有 c1、c2，如果我这样做——抱歉，这是 f 和 g——那么我会写 faccent。对于所有 c1、c2，我会做 c1 fat semi fo，对于所有 f、g、c1、c2，我会做 c1 与 f 组合是 f，这也是与项组合的 f。而且，基本上，如果您有 f、g 和 h，您可以按任何顺序组合它们。我没有为所有 c1、c2、c3 到 c4 等写量词。身份是一个单位。所以，好吧。</font></font></p><p>One, that for all c1,c2, if I do—sorry, this is f and g—then I
            write faccent. For all c1,c2, I do c1 fat semi f o, and for all f,
            g, c1,c2, I do c1 composed with f is f, and that’s also f composed
            with items. And, be basically, that if you have f, g, and h, you can
            compose them in any order. I’m not writing the quantifiers for all
            c1,c2, c3, to c4, etc. An identity is a unit. So, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我举几个例子。例如，Brendan 发表的每篇文章，每篇文章都是某种渠道。所以，他提到了《人类简史》。好的，我们在这里。我们有一些小型的预订单，这是人质。我是 Graham。对象是什么？你认为这是一个类别吗？如果我说这也是一个类别，字母，它是对象。有什么猜测吗？好的。在这种情况下，对象是 topos。所以，这个类别有四个对象。</font></font></p><p>Let me give you some examples. So, for example, every post out, each
            post that Brendan said, was the kind of channel. So, he mentioned
            Sapiens. Okay, so we’re here. We have some kind of small pre order where
            this is the hostage. I Graham. What are the objects? Do you think of
            this as a category? If I said this is also a category, letter, it’s
            objects. Any guesses? Okay. The objects are the topos in this case. So,
            this category has four objects.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">至于态射呢？有谁能猜一下吗？标记是什么，是吗？好的。所以，如果那是对的，那么你需要告诉我从 Sapiens 到 Sapiens 的恒等箭头是什么。好的。所以，它不仅是箭头，还有隐含的东西，每个拓扑，你必须告诉我如何用这个箭头组合这个箭头。对吗？所以，现在我们明白了。所以，从那个态射，从这里到这里，箭头是从这里到这里。那么，我们为什么不写......？</font></font></p><p>And the morphisms? To anyone have a guess? The markings are, yeah?
            Okay. So, if that was right, then you would need to tell me what the
            identity arrow from Sapiens to Sapiens is. Okay. So, it’s not only the
            arrows, but also the implicit things, each topos, and you have to tell
            me how to compose this arrow with this arrow. Right? So, now we’ve got
            it. So, the arrows, from that morphisms, from here to here, are to pass
            from here to here. So, why don’t we write…?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。现在，在偏序集中，我们做了另一件事，那就是只有一个方法，只有一个方法可以从一个地方到达另一个地方。所以，如果你有类似这样的情况，我想我们会说这个复合数就是——你会说 a 小于 b，b 小于 c，c 小于 b，a 小于 d。它们只是一种复合数，或者只是任何东西的又一个人——任何其他东西，或者没有更多的业务。</font></font></p><p>Okay. Now, in a poset, we make another thing, which is that there’s
            only one, there’s only one way to get from from one place to another.
            So, if you’ve had something it looks like this, I guess we would say
            that this composite is just—you would say that a is less than b, and b
            is less than c, and c is less than b, and a is less than d.&nbsp;They’re just
            one kind of composite, or just one more person for anything—anything
            else, or no more business.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这可能不公平，但我可以稍后再谈。好的。所以，偏序集是范畴。任何不完全清楚的东西，你需要稍后和我讨论，或者看看书。当我们有时间说：好的，那么，范畴。在这种情况下，当我谈论范畴时，态射是……哦，不是问是否存在路径，比如，a 是否小于或等于 b——是否存在路径？</font></font></p><p>If that may not be fair, but I can talk about that later. Okay. So,
            posets are categories. Anything that’s not completely clear, you need to
            talk about with me later, or look in the book. It’s much clearer when we
            have time to say: Okay, so, categories. In this context, when I’m
            talking about categories, morphisms are… oh, instead of asking whether a
            path exists, like, is a less than or equal to b or not—is there a path
            or not?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不在乎差异；我只关心是否存在差异。然后，在类别中，你计算所有的路径。那么，在这个自由类别中，有多少个态射？超过六个？超过六个？你可能忘记了它是已经设定的答案之一。所以，你需要包括身份。你需要包括四个组合——有十个。所以，这被称为预平方。很快，我们将讨论所谓的交换平方。</font></font></p><p>I don’t care about the difference; I just care about whether there is
            one. And then, in categories, you count all the paths. So, in this free
            category here, how many morphisms are there? More than six? More than
            six? You may be forgetting it is one of the answers already set. So, you
            need to include the identity. You need to include four
            compositions—there are ten. So, this is called the pre square. Soon,
            we’ll talk about what’s called the commutative square.</p>
        <h2 id="categories-and-free-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和自由类别</font></font></h2><h2>Categories and Free
            Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但在此之前，我要说的是，有一些类别，我们写一个，请注意这个类别。所以，这些都是重要的类别，尤其是这个。结果报告看起来有点像游泳池，可能。</font></font></p><p>But before we do that, let me say that there are categories called—we
            write one—note this category. So, these are important categories,
            especially this one. It turns out the report—it kind of looks like a
            pool, probably.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里面的所有路径是什么？这个范畴代表什么？有多少个态射？有无数个。每个自然数都有一个态射——你绕这个循环的次数：零次、一次、两次等等。而且，这可以称为模型图。</font></font></p><p>What are all the paths in this? What is this category representing?
            How many morphisms are there? There are infinitely many. There’s one for
            every natural number—the number of times you go around this loop: zero
            times, one time, two times, etc. And, said this could be called a model
            diagram.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，哦，我没有——我没有——是的，在这些图中，我没有画出任何隐含在那里的东西。例如，它会延长路径，我在这里没有画出反身循环。你不能画——是的，意味着我实际上想要那里。当然，这只是符号，但是是的。为什么我没有——为什么我没有画——那个图中有无数条路径吗？有吗？嗯，或者抱歉，不是无限多，因为那个图中没有自循环，对吧？对。</font></font></p><p>And then, oh, I didn’t—I didn’t—yeah, in these diagrams, I don’t draw
            anything that’s implicitly there. For example, it’ll prolong paths, and
            I don’t draw reflexive loops here. The fact that you can’t draw—yeah,
            means I actually wanted there. It’s just notation, of course, but yeah.
            Why didn’t that—why didn’t I draw like—are there infinitely many paths
            in that graph? Are there? Well, or sorry, not infinitely many, because
            there is not a self loop right in that graph, right? Right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。这是将类别呈现为图形。所以，它实际上并不是绘制态射，对吧？没错。没错。这些只是用图形表示的类别的图形表示。它们是自由的，因为它们没有添加任何方程。是的。但我们可以通过添加方程使它们不自由。例如，我们可以说 f fat semi f 等于单位 c。&nbsp;</font></font></p><p>Yep. This is presenting a category as a graph. So, it’s not actually
            drawing the morphisms, right? Exactly. Exactly. These are just graphical
            representations of categories represented by graphs. And the reason
            they’re free is when they didn’t add any equations to them. Yes. But we
            could make them non free by adding an equation. For example, we can say
            that f fat semi f equals identity c.&nbsp;</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这个范畴有多少个态射？我添加了一个方程，表示 f 的分号现在由 f 组成的 f 是 i。可以吗？是的。是的。这个范畴是整数 2Z 的幺半群。幺半群——幺半群意味着一个——和一个……我们改天再讨论它。但你也可以将幺半群视为一个只有一个对象的范畴。所以，这是一个只有一个对象的范畴。当你以幺半群的方式思考时，要添加一些——一些带有运算的集合——一个你可以加或乘的集合。</font></font></p><p>So, how many morphisms does this category have? I’ve added an
            equation that says an f semicolon now for f composed of f is i. Can I?
            Yeah. Yeah. This category is the monoid of integers 2Z. A monoid—a
            monoid means one—and a… we talked about it another day. But you can also
            think of a monoid as a category with one object. So, here’s a category
            with one object. And when you think of the monoid way, to add some—some
            set with operations—a set where you can add or multiply.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们讨论的集合是所有路径。所以，如果我有路径 3 和路径 2, 1, 2，我可以将它们组合起来，得到我绕 5 圈的路径。这就是自然数的幺半群。在这个集合中，路径保持不变，注意说 fc 经过路径 f，但 ff 又停滞不前。所以这有点像人……是的，我不知道。你可以说这个人，出于某种原因，如果你转身两次，他们会感觉很好，但如果你转身一次，他们会觉得哪里不对劲。所以这个东西必须一次同态，没有时间。所以你在餐厅里很开心，这是一种幺半群方式。这个幺半群是一些 Xbox 图像到 ZC2。对此有什么问题吗？是的，没错。</font></font></p><p>The set we’re talking about is all the paths. So, if I have the path
            3 and the path 2, 1, 2, I can compose them and get the path wherever I
            go around 5 times. And that’s the monoid of natural numbers. In this
            one, have the path stay, note say fc over the path f, but then f f is
            just sitting at sea again. So it’s kind of like the person… yeah, I
            don’t know. You can say the person, for some reason, if you turn on
            twice, they feel like really good, but if you turn around once, they
            feel like something’s wrong. So this thing has to morphisms once and no
            times. So you’re happy in a restaurant, and this is a monoid way. This
            monoid is some Xbox image to ZC2. Any questions on this? Yep, right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在自由方块中，这些只是符号。它是图的符号，然后该图对应于一个类别。那么如何从图中获得类别呢？你取对象的点，取路径作为态射，然后你的问题是：为什么没有无限多条路径？路径是从头到尾的箭头序列。从它开始。哦，也许你认为一条是倒着走的，或者嬉皮士是倒着走的？哦，是的，是的。如果一条是那样的，而这些是那样的，那就不会有很多了。是的，好的，好的。</font></font></p><p>So, in the free square, these are just notation. It’s the notation of
            a graph, and then that graph corresponds to a category. So how do you
            get a category from the graph? You take the dots of the objects, you
            take the paths as the morphisms, and then your question is: why are
            there not infinitely many paths? A path is a head to tail sequence of
            arrows. Start with it. Oh, maybe you thought that one went backwards, or
            hippies went backwards? Oh, yeah, yeah. If there’s one that way, and
            these went this way, that wouldn’t make lots of them. Yeah, okay,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？是的。当你对任何东西进行恒等运算时，包括你的身份，是的，就好像你没有做过一样。所以这会迫使你。没错。这是一个泵组合，是一个函数，它在这里取一些东西，在这里取一些东西，然后在那里给你一些东西。是的，并且该函数必须是这样的，即身份不会在这些表示中累积。部分的态射和组合是姿势的串联，但身份是对象上长度为零的路径。所以如果你做了一个像零一样的口袋，你就什么也没有了。有点像做了一样，但即使你多次这样做，它仍然是一样的，对吧？这是我的想法。</font></font></p><p>Other questions? Yeah. When you do the identity with anything,
            including with your identity, yeah, it’s as though you just didn’t do
            it. So this forces you. It’s right. It’s a pump composition is a
            function that takes something here, something here, and gives you
            something there. Yeah, and that function is required to be such that
            identity does not accrue in these presentations. Morphisms of parts and
            composition is concatenation of postures, but the identity is the path
            of length zero on an object. So if you’ve kind of made something with a
            pocket like zero, you have nothing to it. Sort of makes the same, but
            even if you do that multiple times, it still remains the same, right?
            That’s my thought out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果有的话，如果你想用哈斯图来表示类别，那么你必须画一个维恩图。我的意思是，你必须选择一些惯例，最好说如果我不写出来，它就是隐含的。我不会去写。或者如果任何隐含的东西在那里，我就不必画出来。好的。</font></font></p><p>That if there is that, if you want to use Hasse diagrams to indicate
            categories, then you have to make a Venn diagram. I mean, you have to
            choose some convention, and it’s best to say if I don’t write it, it’s
            implicit. I’m not going to. Or if anything that’s implicitly there, I
            don’t have to draw. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是另一个例子。集合的范畴。所以它的对象……我没有把这些都写下来。他们只是用文字告诉你了这一切。</font></font></p><p>So, it’s another example. The category of sets. So its objects… I
            didn’t write all each of those. They just told you in words, all of
            that.</p>
        <h2 id="categories-of-sets-and-vector-spaces"><font style="vertical-align:inherit"><font style="vertical-align:inherit">集合和向量空间的类别</font></font></h2><h2>Categories of Sets and
            Vector Spaces</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其中有四个，这里只有一个。子集是所有集合。有时这可能是一个大集合。有小和大的区别，或者称为类，虽然这不是一个非常重要的区别。我之所以要说它们，唯一的原因是，否则有人会抱怨：真的有一个所有集合的集合吗？没有，但有一个所有集合的类，或者有一个所有集合小于某个基数的集合的集合。所以你修复了所谓的格罗滕迪克宇宙。你修复了所有计算都将发生的宇宙的基数，然后你就可以讨论所有小于某个不可访问基数的集合之类的事情。所以，如果你担心这个，那可能是因为你已经被训练得不仅仅是担心，因为这确实是一种担心。但这是我的偏见，好吗？</font></font></p><p>One has four out of that one is one here. A subset is all the sets.
            This is sometimes this could be a large set. There’s a distinction of
            small and large, or what’s called a class, though it’s not a very
            important distinction. The only reason I’m going to say them because
            someone would otherwise complain is: is there really a set of all sets?
            And there is not, but there’s a class of all sets, or there’s a set of
            all sets smaller than some cardinality. And so you fix what’s called a
            Grothendieck universe. You fix the cardinality of a universe where all
            of your calculations will take place, and then you can talk about things
            like all sets that are smaller than some inaccessible cardinal or
            something. So, if you’re worried about that, it’s probably because
            you’ve been trained to be more than worried, because it’s actually a
            worry. But that’s my bias, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以集合的对​​象就是所有的集合，如果我有两个集合，s1和s2，那么从s1到s2的映射集合就是函数。</font></font></p><p>So, the objects of sets are all the sets. If I have two sets, s1 and
            s2, then the set of maps from s1 to s2 is functions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在集合类中，对象是集合，而态射是函数。集合上的恒等式是通常的恒等式，它将 s 的每个元素都发送给自身。而组合是通常的组合。你可以组合两个函数。</font></font></p><p>So, in the category of sets, the objects are sets, and the morphisms
            are functions. The identity on sets is the usual identity, which sends
            every element of s to itself. And the composition is the usual
            composition. You can compose two functions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第一天，我非常担心人们可能不知道如何组合函数，但我希望我知道，否则你早就跟我谈了。</font></font></p><p>The first day, I was very concerned that maybe people didn’t know how
            to compose functions, but I think hopefully I do, or you would have
            talked to me already.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是集合的范畴，但同样，还有向量空间的范畴。我不指望你们知道什么是向量空间，尽管你们中的许多人可能知道。</font></font></p><p>So, that’s the category of sets, but there’s also, similarly, the
            category of vector spaces. I’m not expecting you to know what a vector
            space is, although many of you probably do.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些就是它的对象，你可以在脑海中用群范畴、环范畴或拓扑空间范畴来替换它，如果你知道其中任何一个是什么的话。</font></font></p><p>Here are the objects of that, and you can replace that in your mind
            with the category of groups, or the category of rings, or the category
            of topological spaces, if you know what any of those things are.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是向量空间的对象都是向量空间。还有一类有限维向量空间。有一类 17 维向量空间。17 维向量空间类别的对象都是 17 维向量空间。这不是一个非常……这不是任何人以前研究过的范畴理论。所以，如果你想要一些新的研究，你可以计算一下其中的对象。</font></font></p><p>But the objects of vector spaces are all vector spaces. There’s also
            a category of finite dimensional vector spaces. There’s a category of 17
            dimensional vector spaces. The objects of the category of 17 dimensional
            vector spaces are all vector spaces of dimension 17. It’s not a very…
            it’s not a category theory anyone has studied before. So, if you want
            some new research, you can count objects of that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">都是向量空间。从 v1 到 v2 的向量空间映射是保留总和和保留标量乘法的线性变换。身份就是身份。组合就是通常的组合。群和偏序集也是一样。</font></font></p><p>It’s all vector spaces. The vector space maps from v1 to v2 are
            linear transformations that preserve sums and preserve scalar
            multiplication. The identity is the identity. The composition is the
            usual composition. Same with groups and with posets.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">偏序集合范畴以所有偏序集合、或偏序、或预序作为对象，以所有单调映射作为态射。</font></font></p><p>The category of posets has as objects all posets, or partial orders,
            or pre orders, and as morphisms all monotone maps.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，最后，我说的是数据库。所以，这是一个数据库，也是一个类别。对象是三个点。态射都是路径，但考虑两条路径相等，如果它们从员工开始，显示员工的工作地点，并显示秘书的工作地点，这也等于员工的工作地点。换句话说，所有可以删除任何“.secretary.work”出现的路径都被认为是等价的。当与邻居讨论时，询问今天在课堂上发生了什么，是关于什么的，你是否理解，你没有得到什么，你得到了什么，等等。试着找出你不理解的东西或可以相互分享信息的东西。那么，继续做吧。就是这样吗？</font></font></p><p>Okay, and finally, I said a database. So, here’s a database that is
            also a category. The objects are the three dots. The morphisms are all
            paths, but considering two paths equal if they start at an employee,
            show the employee’s workplace, and show the secretary’s workplace, which
            is also equal to the employee’s workplace. In other words, all paths
            where you can remove any occurrence of “.secretary.work” are considered
            equivalent. When discussing with a neighbor, ask about what happened in
            class today, what it was about, whether you understand it, what you
            didn’t get, what you did get, etc. Try to identify something you don’t
            understand or something to share information with each other. So, go
            ahead and do that. Was that it?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我知道很多居民。有人有问题吗？他们会来吗？好的。</font></font></p><p>A lot of the residents, I know. Anyone have any questions? Are they
            coming up? Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，有人有疑问。他们向水族馆工作人员询问有关圆盘的问题。圆盘有一定的数量。所以，在类别集合中，他们想知道是否存在从集合到空集的函数。</font></font></p><p>So, someone has a question. They’re asking about the discs at the
            aquarium staff. They have a certain number. So, in the category sets,
            they wondered whether there’s a function from a set to the empty
            set.</p>
        <h2 id="functions-into-the-empty-set"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数归入空集</font></font></h2><h2>Functions into the Empty Set</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个问题。答案是这是函数定义的一部分。</font></font></p><p>Another question. The answer is that’s part of the definition of
            functions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，要回答这个问题，谁会回过头来记住函数是什么呢？你会问，“这是一个从集合到空集的函数，对于这个集合的每个元素，你都需要一个到那个集合的元素。”所以，如果这个集合不为空，你就做不到，但如果这个集合为空，那么就有一个集合。</font></font></p><p>So, to answer that question, who goes back and remembers what a
            function is? And you would ask, “These are a function from a set to the
            empty set, and what it is is for every element of this one, you need an
            element to that one.” So, if this is non empty, you can’t do it, but if
            this is empty, then there is one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，你可以这样说，它被称为严格初始对象，这意味着进入空集的唯一函数是同构。进入空集的唯一函数，嗯，空集中的态射是 [某事不清楚] 上的恒等式。</font></font></p><p>So, one way you could say that is it’s called a strict initial
            object, which says that the only function into the empty set is an
            isomorphism. The only function into the empty set, well, morphism in the
            empty set is identity on [something unclear].</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，答案是，很少有函数。是的。类别的定义要求您拥有这些向量空间来推进。不，不。您可以采用使用对象或向量空间的类别，但这些态射都是函数。是的。我的意思是，线性[不清楚]是必要的吗，还是它只是有用，因为它是每个人在外面学习时都会学习的？是的，是的。</font></font></p><p>So, the answer is rarely there’s rarely a function. Yeah. And the
            definition of a category that requires you to have these vector spaces
            to propulsions. No, no. You could take the category of use objects or
            vector spaces, but these morphisms are all functions. Yeah. What I mean
            is like, is the linear [something unclear] they’re necessary, or is it
            only useful because it’s the one everyone studies when they’re studying
            when you’re out? Yeah, yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我在这里要说的是，这些例子中的这些是我们在数学中经常发现的一组类别。我们很少发现 17 维向量空间类别，我们也找不到非线性的类别。还有其他问题吗？是的。</font></font></p><p>So, what I’m saying here, and these in these examples are one set, we
            categories we find often in mathematics. We don’t find the 17
            dimensional vector spaces category often, and we also don’t find a
            category where that’s not linear. Other questions? Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">没什么。它只是一个占位符，等待你告诉我你的是什么。这就像，什么是名字，或者你知道，如果一个名字期待鲍勃什么的，那它是什么，对吧？你应该填写它。所以，同态的含义由你来决定。</font></font></p><p>Nothing. It’s a placeholder that’s expecting you to tell me what
            yours is. It’s like, what is a name, or you know, what is its if a name
            is expecting Bob or something, right? You’re supposed to fill it in. So,
            what is meant by morphism is up for you to decide.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我经常说的是，当有人在某个类别中指定时，他们必须告诉你一类对象。他们必须告诉你如何找到态射。例如，对于任何两个对象，你都可以说出这两个对象之间的态射是什么。他们必须告诉你身份不是什么，并且必须告诉你组合公式是什么。</font></font></p><p>So, in what I often say is when someone specifies in a category, they
            have to tell you a class of objects. They have to tell you for
            everything how to find the morphisms. Like, for any two objects, you’re
            allowed to say what are the morphisms in between these two. They have to
            tell you what the identity isn’t, and have to tell you what the
            composition formula is.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，是的，我是一个占位符，我们正在等你告诉我你的其他问题是什么。实际上，它不是那种组合……那么，在和秘书中，作品的组合是什么？哦，你说在纯数学中，组合不是感觉像组合。好吧，它会被写成如果组合的话，但是在这个我刚刚删除的类别中。如果我有这个类别，在 f 与 g 的组合是由这个组合的，那么这是一个类别。它有四个对象，我不知道，还有七个，表兄弟，或者其他什么，或者九个态射，因为这个和这个是同一个态射。你只要想想就可以读出组合定律。但这不是一个函数；这只是一个符号。这个类别有四个对象，还有，四个，七个符号，还有，七个更多业务的符号。从任何集合论意义上来说，没有任何东西被组合。</font></font></p><p>So, yes, I’m a placeholder while we’re waiting for you to tell me
            what your entire other questions were. Where it’s not actually that
            composition… Well, what’s the composition of works in and secretary? Oh,
            you said in pure math where the composition is not does not feel like
            composition. Well, it’ll be written if composed, but in this category
            that I just erased. If I have this category at the point where f
            composed with g is composed by this, this is a category. It’s got four
            objects and I don’t know, seven more, cousins, or whatever, or nine
            morphisms, because this one and this one are the same morphism. And you
            can read off the composition law just by thinking about it. But this is
            not a function; this is just a symbol. This category has four objects,
            more, four, seven symbols, more, seven symbols of more business.
            Nothing’s being composed in any set theoretic sense.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这种情况在纯数学中是否发生过？在范畴论中确实如此。因为每次看到交换图时，你实际上都在谈论函子。</font></font></p><p>Now, does this ever occur in pure math? It does in category theory.
            Because every time you see a commutative diagram, you’re actually
            talking about a functor.</p>
        <h2 id="categories-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和图表</font></font></h2><h2>Categories and Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果有人说，“我有一个步骤交换图”，他们会给你四个步骤和四个函数，并要求它们交换。所以他们实际上只是给你一个从这里到这里的一个函子。当你画图时，你已经看过一篇第三类论文，它实际上只是一个从像这样的一个小类别到你的类别的函子。所以这是一个有用的想法，但它没有使用真正的组合，只是组合的概念。</font></font></p><p>If someone says, “I have a commutative diagram of steps,” they’re
            going to give you four steps and four functions, and they’re going to
            ask this to commute. So they’re actually just giving you a functor from
            this to here. When you diagram, you’ve seen a category three paper, it’s
            actually just a functor from a tiny little category like this into your
            category. So it’s a useful idea, but it does not use real composition,
            just the idea of composition.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。你去过那里吗？我认为你的数学家，这些 posix 度量面和基本观点，都不是她喜欢的，对吧？所以让我们看看一些基础知识。在你有一些空间之前，这些空间应该是空间中的一个洞，然后你画出来，那么你的对象就是这个空间的所有点。有三个对象，态射是你可以做的所有路径。那是一条路径。如果你包含……，那么两条路径被认为是等价的。好的，所以我们有所有这些路径，他说的是，当你认为组合是连接路径时，那不是函数的组合。所以，是的，谢谢。</font></font></p><p>Yeah. Have you gone to that? I think your mathematicians, these posix
            metric faces and fundamental viewpoints, which none of what she’s like,
            right? So let’s see some of the fundamentals. Before you have some space
            that’s supposed to be like a hole in the space, and then you draw, then
            your objects are all the points of this space. There are three objects,
            and the morphisms are all the paths you can do. That’s a path. That’s
            the path where two paths are considered equivalent if you contain… Okay,
            so we have all these paths, and what he’s saying is that when you think
            the composition is concatenating the paths, that’s not composition of
            functions. So, yeah, thanks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？是的，是的，是的。它们将是我们用来进行转换的东西，或者它们将指定数据不应如何转换，并且数据必须通过该函数（函子）在某处进行转换，对吗？</font></font></p><p>Other questions? Yes, yes, yes. They’re going to be what we use for
            doing transformations, or they’re going to specify how the data
            shouldn’t be transformed, and the data will have to transform somewhere
            through that function, functor, right?</p>
        <h2 id="categories-and-data-transformations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和数据转换</font></font></h2><h2>Categories and Data
            Transformations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果类别是向量空间，那么它就有向量空间作为这些对象，以及保存这些结构的东西。什么是向量空间？它是一些东西，一些像向量一样的元素。它是……所以，这是我今天要说的最后一件事。</font></font></p><p>So, if the category is vector spaces, it has vector spaces as those
            objects, and things that preserve those structures. What is a vector
            space? It’s some stuff, some elements like vectors. It’s… So, this is
            the last thing I was going to say today.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，对于每种类别，都有一些对象，它们就像是某种元素的元组。它们有……所以，这只是为了直观的目的。</font></font></p><p>So, for each kind of category, there are objects that are kind of
            tuples of like some elements of some sort or sort. They have… So, this
            is all just for intuition purposes only.</p>
        <h2 id="categories-and-data-structures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别和数据结构</font></font></h2><h2>Categories and Data
            Structures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">元素、结构和内容，从结构和属性开始。因此，在向量空间中，每个对象都是一个向量空间，它具有元素，即向量。它具有能够添加或缩放向量的结构，并且具有属性，例如如果我将两个向量相加，则与将它们反向相加相同。在偏序集 (poset) 中，对象是偏序集。它们具有元素、有序结构以及反身性和传递性属性。因此，这些是类别的对象和态射。</font></font></p><p>Elements, structure, and stuff, starting structure and properties.
            So, in vector spaces, every object is a vector space, and it has
            elements, namely vectors. It has structure enabling the ability to add
            or scale vectors, and it has properties like if I add two vectors, it’s
            the same as having them in reverse. In posets, the objects are partially
            ordered sets. They have elements, a structure in the order, and the
            properties of reflexivity and transitivity. So, these are the objects
            and the morphisms of the category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它们将元素发送给元素，并保留结构。所以，这一切都很松散，但我们可以——我的意思是，我只是在画一些奇怪的东西或跳舞的东西——但想象一下向量空间的态射是什么？它们将一个向量空间的元素（向量）发送给另一个向量空间的元素，并保留结构。它保留了加法，但属性消失了。你忘记了加法是可交换的事实。</font></font></p><p>They send elements to elements and they preserve structure. So, this
            is all very kind of loosey goosey, but we can kind of—I mean, I’m just
            kind of drawing some weird things or dancing stuff—but just imagine what
            are the morphisms of vector spaces? They send the elements of one vector
            space, the vectors, to the elements of the other, and they preserve the
            structure. It’s preserved plus and but the properties kind of disappear.
            You forget about the fact that the plus is commutative.</p>
        <h2 id="morphisms-and-structures-in-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴中的态射和结构</font></font></h2><h2>Morphisms and Structures
            in Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有一年，当你在研究变换时，对吧？你在态射期间停止思考它们，对吧？当你在研究态射时，你会忘记。你不关心它们是可交换的。这更多的是关于对象，好吗？</font></font></p><p>One year when you’re looking about looking at when your
            transformations, right? You stop thinking about them during the
            morphisms, right? When you’re looking at a morphism, you forget. You
            don’t care about the fact that they’re commutative. That’s more about
            the objects, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，同样，如果我们想提出什么范畴，我们已经说过什么是对象。它的对象就是它的对象。它们具有某种元素，即它具有对象和态射。它具有某些结构，如组合和身份，它具有属性，如整体性和结合性。因此，这应该告诉你并让你很好地猜测两个范畴之间的态射应该是什么。它们应该将一个范畴的元素发送给另一个范畴的元素。因此，你应该将对象发送给对象，将态射发送给态射。它们应该保留结构，它们应该保留身份和组合。当我们看态射时，我们将忘记整体性和结合性。对象，态射。这就是 Brendan 将在星期二谈论的内容。所以，好吧，如果你想要分类，请继续享受这段有趣的时光。</font></font></p><p>So, in the same way, if we wanted to come up with what category of
            categories, we’ve already said what is objects. On its objects are its
            objects. They have a certain sort of element, namely, it has objects and
            it has morphisms. It has certain structures like composition and
            identity, and it has properties like totality and associativity. And so,
            that should tell you and give you a good guess for what the morphisms
            between two categories should be. They should send the elements of one
            category to the elements of the other. So, you should send objects to
            objects and morphisms to morphisms. They should preserve the structures,
            they should preserve identities and composition. And we’re going to
            forget about, you know, totality and associativity as we look at the
            morphisms. Objects, morphisms. And that’s what Brendan will puff around
            on Tuesday. So, okay, stay around for the fun time if you want to
            categorical.</p>
        <h1 id="applied-category-theory.-chapter-3-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 3 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 3, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 23 日) — 55:17 </font></font><a href="https://youtube.com/watch?v=uqxy5MZrQtI"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=uqxy5MZrQtI</font></font></a></p><p> 6
            years ago (Jan 23, 2019) — 55:17 <a href="https://youtube.com/watch?v=uqxy5MZrQtI">https://youtube.com/watch?v=uqxy5MZrQtI</a></p>
        <h2 id="summary-5"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">麻省理工学院课程 18S097 由 David Spivak 和 Brendan Fong 在独立活动期间 (IAP) 讲授，涵盖了范畴论中的函子概念。函子（从 C 类到 D 类）是将 C 中的对象映射到 D 中的对象，将 C 中的态射映射到 D 中的态射的函数，同时保留身份和组合。给出了一些示例，包括预序、幺半群和数据库模式之间的函子。讲座还介绍了函子之间的态射即自然变换，并讨论了它们与多态函数的关系。最后，简要介绍了通用构造的概念，如乘积和伴随，作为预序概念的概括。</font></font></p><p>This MIT Course 18S097, taught by David Spivak and Brendan Fong
            during the Independent Activities Period (IAP), covered the concept of
            functors in category theory. A functor, from category C to category D,
            is a function that maps objects in C to objects in D and morphisms in C
            to morphisms in D, preserving identities and composition. Examples were
            given, including functors between pre-orders, monoids, and database
            schemas. The lecture also introduced natural transformations as
            morphisms between functors, and discussed how they relate to polymorphic
            functions. Finally, the concept of universal constructions, like
            products and adjunctions, was briefly introduced as generalizations of
            concepts from pre-orders.</p>
        <h2 id="introduction-to-categories-and-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴与函子简介</font></font></h2><h2>Introduction to
            Categories and Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，欢迎回来。让我们开始今天的节目吧。让我先找到一个直播开始。好的。</font></font></p><p>Okay, welcome back. Let’s get started for today. Let me find a live
            start. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">周五，David 向你们介绍了类别和数据库，具体来说，类别是这个世界中存在着一些称为对象的东西，这些对象可能是某种代数对象，比如集合、向量空间或群，也可能被视为某种编程语言系统中的某种类型。然后，关联对象，我们也有称为态射的东西，或者类别中的态射。因此，态射存在于对象之间。你可以把它看作函数或群同态，或者在其他例子中，它是一个将一种类型的数据转换为另一种类型的数据的程序。</font></font></p><p>So, on Friday, David told you about categories and databases, and in
            particular, a category is this world where we have these things called
            objects, which might be some sort of algebraic object like a set, or a
            vector space, or a group, or might be considered as some sort of type
            for, say, in some sort of programming language system. And then,
            associated objects, we also have these things called morphisms, or
            morphisms in a category. So, a morphism goes between objects. You might
            think of it as something like a function, or a group homomorphism, or in
            other examples, it’s, say, a program taking data of one type to data of
            another type.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在讨论完这个问题之后，David 开始从元视角来思考这个问题，并开始考虑范畴的范畴。因此，如果范畴本身是范畴中的对象，那么我们需要两个范畴之间的态射相关概念。David 将这些称为函子。</font></font></p><p>So, after talking about this, towards the end, David started to give
            it a bit of a meta perspective and started to consider the category of
            categories. So, if categories were themselves to be objects in a
            category, we need an associated notion of morphism between two
            categories. And David called these functors.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，在思考函子应该具有什么时，他谈到了元素或数据的概念，然后谈到了结构和属性。他说，某种代数对象之间的某种态射应该将数据传递给其他数据，并保留这些结构。</font></font></p><p>And then, sort of reflecting on what sort of thing a functor should
            have, he spoke about these ideas of elements or data and then structure
            and properties. And he said that some sort of morphism between some sort
            of algebraic object should take the data to other data and should
            preserve these structures.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，今天，我们将解开这个谜团，并给你一个函子概念的正式定义，看看它是如何保存数据的，以及如何保存结构。</font></font></p><p>So, today, we’re going to unpack that and give you a formal
            definition of the notion of a functor and look at how this preserves,
            say, data to data and preserves structure.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。说完这些，我将直接给出定义。</font></font></p><p>Okay. So, having said what I just said, I’ll get straight to a
            definition.</p>
        <h2 id="formal-definition-of-functor"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子的正式定义</font></font></h2><h2>Formal Definition of Functor</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，给定类别</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">D</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ，我们说从</font><em><font style="vertical-align:inherit">C</font></em><font style="vertical-align:inherit">到</font><em><font style="vertical-align:inherit">D</font></em><font style="vertical-align:inherit">的函子
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是：
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So, given categories <em>C</em> and <em>D</em>, we say a functor
            <em>F</em> from <em>C</em> to <em>D</em> is:
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">首先，一个函数，我也将其称为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F ，从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的对象到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">D</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的对象</font><font style="vertical-align:inherit">。它是另一个函数，对于所有对象</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">（由于我说过对象，所以我只写</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
            ，否则</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y就是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的对象</font><font style="vertical-align:inherit">），我们有另一个函数，从
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y的态射到从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F(x)</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F(y)</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的态射集</font><font style="vertical-align:inherit">，其中</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">使得</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的对象</font><font style="vertical-align:inherit">，因此</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F将它们转换为</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">D</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的对象。因此，我们可以讨论</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F(x)</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F(y)</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">之间的态射集</font><font style="vertical-align:inherit">。
        </font></font></p><p>First, a function, which I’ll also call <em>F</em>, from the objects
            of <em>C</em> to the objects of <em>D</em>. And it’s another function,
            for all objects <em>x</em> and <em>y</em> in (I’ll just write <em>C</em>
            since I’ve said objects, but otherwise <em>x</em> and <em>y</em> in the
            objects of <em>C</em>), we have another function from the morphisms from
            <em>x</em> to <em>y</em> to the set of morphisms from <em>F(x)</em> to
            <em>F(y)</em>, where <em>F</em> so <em>x</em> and <em>y</em> are objects
            of <em>C</em>, so <em>F</em> turns them into objects of <em>D</em>. And
            so, we can talk about the set of morphisms between <em>F(x)</em> and
            <em>F(y)</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对吧？所以，这就是 David 所说的：函子，或者任何代数的东西，都应该将数据转化为数据。所以，类别的数据由对象和态射组成。所以，他告诉你如何将对象转化为对象，将态射转化为态射。但我们也有一些属性，一些结构，这个东西应该保留。</font></font></p><p>Right? So, this is what David said: a functor, or any sort of
            algebraic thing, should take data to data. So, the data of a category
            consists of objects and morphisms. And so, he told you how to take
            objects to objects and morphisms to morphisms. But we also have some
            properties, some structures, that this thing should preserve.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这样，首先，我们将一个恒等态射与类别中的每个对象相关联。函子应该将恒等态射发送给恒等态射。因此，对于所有对象 x，f(idx) = idf(x)。其次，这被称为“保留恒等”。我们与类别相关联的另一部分结构是组合规则，因此它也应该保留这一点。因此，这是针对所有态射 f 和 g 的，以便它们可以组合，我们应该有，如果我们取 f 的图像并取 g 的图像并将它们组合，则等于 f 与 g 组合的图像。这就是“保留组合”。因此，再次，我们有函数在数据中的作用以及一些表明它保留结构的属性。有……</font></font></p><p>Such that, firstly, to every object in the category, we associate an
            identity morphism. Functors should send identity morphisms to identity
            morphisms. Therefore, for all objects x, f(idx) = idf(x). And, secondly,
            this is called “preserves identities.” The other bit of structure we
            have associated with categories is a composition rule, so it should also
            preserve this. So, this is for all morphisms f and g, so that they may
            be composed, we should have that if we take the image of f and we take
            the image of g and compose them, that’s equal to the image of f composed
            with g. This is “preserves composition.” So, again, we have what the
            function does in data and some properties that say it preserves
            structure. There is…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">David 还谈到了将每个态射与一个域和一个陪域相关联。因此，从另一个角度来看待这个定义——你可以将某种域和陪域视为类别中的某种结构——从另一个角度来看待这个定义，这个东西实际上是一个函数，从 C 的态射（即所有同位集）到 D 的所有同位集，但 f 的态射的域……</font></font></p><p>David also spoke about associating to every morphism a domain and a
            codomain. So, another way of viewing this definition—and you might view
            sort of domain and codomain as certain structure in the category—another
            way of viewing this definition is that this thing is really a function
            from the morphisms of C, so all of the homsets, to all the homsets of D,
            but such that the domain of a morphism of f…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果我们有从 x 到 y 的 f，请记住，我们将 x 称为定义域，将 y 称为陪域，我们希望这个对象的 f 的定义域（即 f 的定义域）等于 f 的 f 的定义域。陪域（右边的东西）也类似。但你可以把这些东西写成定义，这只是另一种观点。</font></font></p><p>So, if we have f from x to y, remember that we call x the domain and
            y the codomain, and we want the domain of that f of this object, which
            is the domain of f, to equal the domain of f of f.&nbsp;And similarly for the
            codomain, the thing on the right. But you can take this stuff and write
            it as a definition, and that’s just another viewpoint.</p>
        <h2 id="examples-of-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子的例子</font></font></h2><h2>Examples of Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。</font></font></p><p>Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">首先举几个例子。我想谈谈函子之间的表示，部分原因是因为这给出了一个很好的画面。所以，这是一个类别的某种表示，这是另一个类别 C 的表示。</font></font></p><p>So, some examples first. I want to talk about functors between
            presentations, because partly because this gives a nice picture. So,
            here’s some sort of presentation of one category, here’s a presentation
            of another category C.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这两者之间的函子是什么呢？嗯，函子首先将对象带到对象。所以，它会发送……所以对于这里的每个对象——有三个——我们说，这个对象应该去这里，这个对象 m 应该在这里，现在假设这个对象在这里，对吧？但它也会将态射发送到态射，以一种发送的方式……</font></font></p><p>So, what is a functor between these two things? Well, a functor takes
            objects to objects first of all. So, it’s going to send… so for every
            object here—there are three—we say well, this object should go here,
            this object m up here, and let’s say for now that this object go is
            here, right? But it’s also going to send morphisms to morphisms, and in
            a way that sends…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，有两种观点。首先，如果它将一个态射从 x 发送到 y，它必须将一个态射从 x 发送到 y 发送到一个态射从 f(x) 发送到 f(y)。因此，我们称之为……</font></font></p><p>So, there are two viewpoints. Firstly, if it sends a morphism from x
            to y, it has to send a morphism from x to y to a morphism from f(x) to
            f(y). So, we call this…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里有一个对象 x，这是一个从 x 到 y 的态射，这是一个对象 x，这是一个对象 y，我们将其视为从 x 到 y 的态射。因此，具体来说，它必须转到从 f(x) 到 f(y) 的态射。这里只有一个；就是这个。有两个……哦，有一条路径。哎呀，抱歉。现在只有一个。我修好了。但我们可以选择其中任何一个。无论如何，我们可以说这个态射映射到这个态射。所以，我们还必须将这个态射发送到某个地方。</font></font></p><p>So, here’s an object x, here’s a morphism from x to y, here’s an
            object x, here’s an object y, and we think of this as a morphism from x
            to y. So, in particular, then it’s got to go to a morphism from f(x) to
            f(y). And there’s only one here; it’s this one here. There are two… oh,
            there’s a path. Oops, sorry. Now there’s only one. I fixed it. But we
            could have chosen either one. In any case, we might say that this
            morphism maps to this morphism. So, we’ve also got to send, say, this
            morphism somewhere.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我们应该把这个态射发送到哪里呢？嗯，它必须是从这个对象到它自己的态射。虽然在表示中看起来那里没有态射，但那里总是有一个态射。它被称为身份态射。它是长度为零的路径。所以我们可以将这个态射发送到，嗯，这只是这里的身份态射。所以，这就是你可以想到的函子。这是一种方式——我的意思是，我在这里画的结构有点像一个图。从态射来看，它将边发送到——它将边发送到路径，将点发送到点。所以，具体来说，任何态射图——任何将边发送到边，将点发送到点，保留域、陪域或源和目标的东西——都会在图中呈现的两个类别之间诱导一个函子。好的。</font></font></p><p>And so, where should we send this morphism? Well, it’s got to be a
            morphism from this object to itself. And it doesn’t look like there’s a
            morphism there in the presentation, but there is always a morphism
            there. And it’s called the identity morphism. It’s the path of length
            zero. So, we can send this morphism to, well, this is sort of just the
            identity morphism on here. So, that’s that’s how you can sort of think
            of a functor. It’s a way of—I mean, this, the structure I’ve drawn here,
            is somewhat like a graph. From morphisms, it’s sending edges to
            either—it’s sending edges to paths and points to points. So, in
            particular, any graph of morphisms—so, anything that sends edges to
            edges and points to points, preserving domain, codomain, or source and
            target—will induce a functor between the two categories that the graph
            presents. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是函子的第一个例子。其次，这是——实际上，一个相同类型的例子，但可能带有更多暗示的语义内容——是数据库模式之间的一个例子。因此，您可能有一个数据库模式，例如，仅用于存储飞机座位。因此，我们可能有两种类型的座位：经济舱座位和头等舱座位。对于每个座位，我们都关联一个价格，无论是经济舱还是头等舱。对于每个经济舱座位，我们都关联乘客的姓名，头等舱座位也是如此。</font></font></p><p>So, that’s a first example of a functor. Secondly, this is—so, an
            example, effectively, of the same type, but maybe with a bit more sort
            of suggested semantic content—is an example between database schemas.
            So, you might have a database schema, say, for just storing airline
            seats. And so, we might have two types of seats: economy seats and first
            class seats. And to every seat, we associate a price, whether it be
            economy or first class. And every economy seat, we associate the name of
            the passenger there, and similarly for the first class seats.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一种数据库模式。另一种用于存储相同类型数据的更简单的数据库模式是只有一个座位，然后我们将其与价格和乘客相关联。因此，两个不同的公司可能会使用这两种数据库模式，并希望讨论它们之间的某种关系，这将有助于他们理解如何将数据从以这种格式存储的数据迁移到以这种格式存储的数据。因此，你可以用函子描述这种关系，函子是一种显而易见的函子，它将这种数字对象发送到数字对象，或将价格对象发送到价格对象，将字符串对象发送到字符串对象，将两个座位对象发送到此模式的单个座位对象。然后它会将这些态射发送到那里的相应态射。好的。就是这样。我要——抱歉——我要谈谈下一个。</font></font></p><p>So, that’s one database schema. Another simpler database schema for
            storing the same sort of data would just be to have one seat, and then
            we have price and passenger associated to it. And so, one might—two
            different companies might use these two database schemas and want to
            talk about some sort of relationship between them, which would help them
            understand how to migrate data from that that’s stored in this format to
            data that’s stored in this format. So, you can describe that
            relationship with a functor, which is sort of the obvious one that sends
            this sort of the the numbers object to the numbers object, or the price
            object to the price object, the string object to the string object, and
            both seat objects to a single seat object of this schema. And then it
            will send these these morphisms to the corresponding ones there. Okay.
            So, that’s that. I’m going to—sorry for—I’m going to talk about
            next.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我之前告诉过你们的另一件事是，范畴是幺半群和预序的泛化。我们已经讨论了很多关于预序的内容。所以，我只想考虑一下这两个例子中的函子是什么。所以，预序之间的函子——这些将是幺半群映射。</font></font></p><p>So, another thing I’ve told you then is that categories are both
            generalizations of monoids and pre orders. And we’ve spoken a lot about
            pre orders. So, I want to just consider what a functor is in those two
            examples. So, functors between pre orders—and these will be monoid
            maps.</p>
        <h2 id="functors-between-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预序之间的函子</font></font></h2><h2>Functors Between Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。我们假设 C 和 D 类别是预序。在 C 中，预序符号只是一个集合和一个顺序关系（或二元关系），即顺序。假设这些是预序。然后让我们考虑一下它们之间的函子是什么。好吧，让我首先提醒你这种关于预序和类别的观点。因此，我们为 c(x,y) 是否为空的概念写一个预序。如果 c(x,y) 有一个元素，我们写 x 小于 y，如果它是空的，则不写，对吗？所以，如果这里的 h 是空的，x 不小于 y。</font></font></p><p>Okay. So, we’re calling—let’s just suppose here that the category C
            and D are pre orders. In C, the preorder notation is simply a set and an
            order relation (or binary relation) which is the order. So, suppose
            these are pre orders. Then let’s consider what a functor is between
            them. Well, okay. Let me remind you first of this sort of perspective on
            pre orders and categories. So, we write a pre order for the concepts of
            c(x,y) is either empty or not. And we write x is less than y if c(x,y)
            has an element and not if it’s empty, right? So, x is not less than y if
            this h here is empty.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么什么是函子？首先，它是一个从 C 的对象（即元素集合 C）到 D 的对象的一个​​函数。其次，它是集合的一个态射……所以它是一个从……对不起，它是一个从 c(x,y) 到 d(f(x), f(y)) 的函数。但这实际上意味着……只有当这个 hom 集有一个元素时，这才是真正重要的事情。具体来说，第二点是约束，即如果这个 hom 集有一个元素，那么 D 中对应的 hom 集也必须有一个元素。所以，对应的 hom 集 D 有一个元素。我们将 C 和 D 中的 f(x) 小于 f(y) 写为下标。</font></font></p><p>Okay, so what then is a functor? First, it’s a function from the
            objects of C, which is just the set C of elements, to the objects of D.
            And two, so it’s a morphism from the set… so it’s a morphism from…
            sorry, it’s a function from c(x,y) to d(f(x), f(y)). But what this turns
            out to mean… where this this only really turns out to be an important
            thing if this hom set has one element. And, in particular, two turns out
            to be the constraint that says that if this hom set has an element, then
            the corresponding hom set from D has to have an element. So, the
            corresponding hom set D has an element. We write that f(x) is less than
            f(y) in C and D as subscripts.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">问题：右上角括号里写的是什么？哦，那只是……它应该是一组。所以，你可以叫它你的……或者任何你想要的。叫它什么。现在，好的。好的，谢谢。好的，好的。</font></font></p><p>Question: What’s written within the braces in the top right? Oh,
            that’s just a… it’s meant to be one set. So, you can call it your… or
            whatever you want. Call it something. Now, okay. Okay, thank you. Okay,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，预序之间的函子……我的意思是，好吧。因此，有一些条件需要检查。身份……保留身份意味着什么？在这种情况下，保留组合意味着什么？但大致上，您以前见过这种东西。它是元素之间的函数，用于保留顺序。接下来，我将让您探索问题中的细节。不过，我想谈谈单态。所以，我们讨论了幺半群。我们还没有讨论过单态，但您可能已经见过它们。如果您没有特别见过单态，您可能见过群同态，其中群是幺半群的一种特殊类型。</font></font></p><p>So, functors between pre orders… I mean, okay. So, there are some
            conditions to check. What does the identity… what does it mean to
            preserve identities? And what does it mean to preserve compositions in
            this setting? But roughly, you’ve seen this sort of stuff before. It’s a
            function between the elements that preserves the order. And I’ll leave
            you to explore the details in the problem next. Though, I want to talk
            about monomorphisms. So, we’ve talked about monoids. We haven’t talked
            about monomorphisms, but you may have seen them. If you haven’t, in
            particular, seen monomorphisms, you may have seen group homomorphisms,
            where groups are a particular type of monoid.</p>
        <h2 id="functors-between-monoids"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半群之间的函子</font></font></h2><h2>Functors Between Monoids</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但实际上，它是两个幺半群之间的函数，保留了幺半群运算。</font></font></p><p>But really, it’s a function between two monoids that preserves the
            monoid operation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，假设 C 和 D 是幺半群。在这种情况下，这些数据应该怎么说？好吧，我说有一个从 C 的对象到 D 的对象之间的函数。但是作为幺半群，幺半群是一个对象类别。所以，C 和 D 只有一个对象。所以，这个东西说……条件一什么也没说。条件二要求在 hom 集之间有一个函数。所以，条件二想要一个从 c 的函数……我只会写 C，因为它有一个唯一的对象。</font></font></p><p>So, what does… So, suppose C and D are monoids. What should… what
            should this data say in that case? Well, I says that there’s a function
            from the objects of C to the objects of D. But as monoids, monoids are
            one object categories. So, C and D only have one object. So, this thing
            says… condition one says nothing. Condition two asks for a function
            between the hom sets. So, condition two wants a function from c… I’m
            just going to write C because it has a unique object.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，将 C 中的态射称为 D 中的所有态射。对，事实上，这是对的。只是作为乘法的运算，可能是 D 中的 C 乘以乘法。好的。所以，这是数据；它是一个从这个集合到这个集合的函数，对象集到集合——对不起，态射集到态射集，这样我们有两个条件。首先，它将身份元素发送到 C 中的身份元素在 D 中为 1，其次，这个保留组合的概念。所以，这里我们开始将组合写为乘法，因为我们将其视为一个幺半群。所以，它表示 f * g 的 f 等于 f * f * g。为什么我们不能在第一个中什么都不写？啊，好的。</font></font></p><p>So, call the morphisms in C to all the morphisms in D. Right, in
            fact, that’s right. Just the operations as of times, maybe C times in D
            times. Okay. So, this is the data; it’s a function from this set to this
            set, the set of objects to the set of—sorry, the set of morphisms to the
            set of morphisms, such that we have two conditions. First, it sends the
            identity element to the identity element in C is 1 in D, and, and
            second, this notion of preserving composition. So, here we started
            writing composition as times because we’re thinking of this as a monoid.
            And so, it says that f of f * g is equal to f * f * g. Why could we
            write nothing in first? Ah, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果您看一下这个定义，就会发现要求从 C 的对象到 D 的对象有一个函数。但是现在考虑幺半群的情况，而幺半群是只有一个对象的类别，问题表上有一个问题可以进一步探讨这一点。但是如果认为这是理所当然的，那么要求从单元素集到单元素集有一个函数。但那有点像——只有一个唯一函数，所以实际上没有任何数据需要考虑。所以，我没有写任何东西来表示这一点。好的。</font></font></p><p>So, if you look at this definition, one asks for a function from the
            objects of C to the objects of D. But when now considering the case of
            monoids, and monoids are categories with one object, there’s a question
            on the problem sheet to explore that further. But taking that for
            granted, then one is asking for a function from a one element set to a
            one element set. But that’s sort of—there’s only a unique function, so
            it’s not really any data to consider. So, I’ve just written nothing to
            represent that. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">举个例子。有单态。你可以把整数看作一个对象，一个单态，一个对象类别。所以，每个整数都是一个态，而态的组合就是整数的乘法。然后有一个函数，比如说从 Z 到 Z，一个从 Z 到 Z 的单态，我想这是一个平方的乘法，对吧？所以，它将一个自然的，对不起，一个整数发送到整数的平方。所以，这是一个函子的例子。</font></font></p><p>So, so examples. There are monomorphisms. You might consider, say,
            the integers as a one object, as a mono, as one object category. So,
            every integer is a morphism, and composition of morphisms is just, let’s
            say, multiplication of integers. Then there’s a function, say, from Z to
            Z, a monomorphism from Z to Z, which is a multiplication, I guess,
            squaring, right? So, it sends a natural, sorry, an integer to the
            integer squared. So, this is an example of a functor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我给你——到目前为止，我们已经考虑了具有相同味道的类别之间的函子，因此它们都是预序，或者都是幺半群。</font></font></p><p>Okay, let me give you—so far, we’ve considered sort of functors
            between categories which have the same sort of flavor, so they’re both
            preorders, or they’re both monoids.</p>
        <h2 id="database-instances-as-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数据库实例作为函子</font></font></h2><h2>Database Instances as
            Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接下来，我想谈谈数据库实例如何成为函子的一个示例。所以，这是数据库实例。所以，我们看到的是集合类别。提醒一下，集合有对象，集合和态射是函数。所以，如果我们选择一些数据库模式——我说的是这里、那里有座位的那个——座位。让这个数据库的一个实例成为这个 C 的函子——这个数据库模式是这个集合类别的函子。那么，这是什么意思呢？</font></font></p><p>Next, I want to talk about how database instances are an example of a
            functor. So, this is database instances. So, we’re seeing the category
            of sets. Just a reminder, a set has objects, sets, and morphisms are
            functions. And so, if we pick some database schema—I say that one over
            here, over there, with the seats—seat. Let an instance of this database
            be a functor from this C—this database schema is a functor from this
            category to sets. So, what does this mean?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于这里的每个对象，我们都关联一个集合。因此，我要说的是，对于这个对象，也就是我刚才放的美元符号，我将关联一组正实数。对于名为“座位”的对象，我将关联包含飞机上所有座位的集合，1A、1B，一直到 32[某个数字]。对于字符串，我将关联 U 中的字符串集合。假设是空间中的标准 alpha 版本。</font></font></p><p>To every object of here, we associate a set. So, I’m going to say to
            the object, which I’m just which I just put a dollar sign, I’m going to
            associate a set of positive real numbers. To the object called “seat”,
            I’m going to associate the set containing all seats in the plane, 1A,
            1B, all the way down to 32[something]. To the string, I’m going to
            associate the set of strings in U. Let’s say the standard alpha version
            in space.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这会将这里的每个对象发送到集合中的一个对象。同时，函子还要求我们将这里的每个态射发送到集合中对象映像之间的态射。所以它会将这个箭头发送到一个函数。它会是什么函数呢？让我们将它发送到，将 c 发送到 $ 到某个函数，我将称之为 price，从这些座位，当 a 等到正行数时。然后我们还需要一个将座位发送到字符串的函数。所以它假设，我们将其称为乘客的 s。所以它发送，坐下并告诉你坐在那个座位上的人的名字。好的。</font></font></p><p>So this sends each object of here to an object in the set. And also
            the functor also asks us to send each morphism in here to a morphism in
            the set between the images of the object. So it’s going to send this
            arrow to a function. And what function is it going to be? Let’s send it
            to, going to send c to $ to some function, which I’m going to call
            price, from these seats, when a and so on to the positive row numbers.
            And then we also need a function that sends seats to strings. So it’s
            say, and we’ll call it this s of passenger. So it sends, takes a seat
            and tells you the name of the person who’s sitting on that seat.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">隐式地，这个类别中有几个态射，更多的态射，对吧？比如说，这个价格对象有一个恒等态射。但我们会发送它。我们知道我们已经必须将恒等态射发送到恒等态射。因此，它从正整数到自身变为常数或恒等函数。是的。</font></font></p><p>Implicitly, there are a few morphisms, more morphisms in this
            category, right? There’s an identity morphism on, say, this, this price
            object here. But we’re going to send that. We know we already have to
            send identity morphisms to identity morphisms. So it goes to the
            constant or the identity function from the positive integers to itself.
            Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你如何表示集合中的箭头？因为集合没有结构。它就像点一样，对吧？哪个集合，对不起，这个，这个类别，集合，还是对的？你如何表示集合的函数？我不确定我是否理解你的问题。所以我，我，我以为它会像遗忘函子一样，忘记所有结构，只保留对象，没有同态。但不知何故你得到了同态。让我们，我不知道。</font></font></p><p>How do you represent the arrows in the set? Because the set has no
            structure. It’s just like the dots, right? Which set, sorry, this, this
            category, set, or yeah? How do you represent the functions to the both
            of the set? I’m not sure I understand your question. So I, I, I thought
            it’s going to be like the forgetful functor that forgets all structure
            and only keeps the objects and no homomorphisms. But somehow you get the
            homomorphisms. Let’s, I don’t know.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这是一个有三个对象和五个态射的范畴。所以我们有一个集合范畴的函数。所以对于这里的每一个对象，我们得到一个集合，它是这个范畴中的一个对象。对于这里的每一个态射，我们得到一个集合之间的函数，它是这个范畴中的一个态射。嗯，是的，在这个范畴中。这就是我在这里写的内容。我写出了两个有趣的地方，嗯，这两个有趣的态射在哪里。其他态射是恒等态射。好的。</font></font></p><p>So this is a category with three objects and five morphisms. So, and
            we have a function to the category of sets. So for every object up here,
            we get a set, which is an object in this category. And for every
            morphism in here, we get a function between the sets, which is a
            morphism in this category. Well, yeah, in this category. So that’s
            that’s what I’m writing out here. I’ve written out the sort of two
            interesting places that, well, where the two interesting morphisms go.
            And the other morphisms are identity morphisms. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但也许这是一个开始提问的好地方。所以只是一些讨论。实际上，再举一个例子，然后我会给你们一点时间讨论。对于那些对数学有一定了解的人来说，思考代数拓扑可能会有所启发，它考虑拓扑空间的 Top 类别，其中的态射是连续映射。它还考虑群类别之类的类别，其中的态射是群态射。</font></font></p><p>But maybe this is a good place to to start for a question. So just
            some discussion. Actually, one more example, and then I’ll give you a
            bit of time to discuss. For those who have seen a bit more math, it
            might be enlightening to sort of think about algebraic topology, which
            considers a category Top of topological spaces where the morphisms are
            continuous maps. And it also considers categories like the category of
            groups, where the morphisms are group morphisms.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有函子，这些人们经常谈论的构造，比如基本群。所以我就用这个，或者同调可能是另一个常见的。它形成从拓扑空间类别到群类别的函子。所以，具体来说，像基本群构造这样的东西不仅会取一个空间并给你一个群，还会取一个连续映射并将其变成一个群同态，也就是所谓的同伦群。所以，我知道不是每个人都学过代数拓扑，但这有点像这个学科的起源：范畴论。这只是一个非常有趣的应用。好的。</font></font></p><p>And functors, these constructions that people often talk about, like
            the fundamental group. So I’m just going to use that one, or maybe
            homology is another common one. It forms functors from the category of
            topological spaces to the category of groups. So, in particular,
            something like the fundamental group construction not only takes a space
            and gives you a group, but it takes a continuous map and turns it into a
            group homomorphism between what are known as the homotopic groups. So, I
            know not everyone has studied algebraic topology, but this is sort of
            the origin of the subject: category theory. And it’s just a very
            interesting application. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我会给你两三个问题，比方说。</font></font></p><p>So, I’ll give you two or three questions, let’s say.</p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">什么是函子？</font></font></p>
            </li><li>
                <p>What are functors?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是一个范畴，那么从这个对象、一个对象范畴到 Set 的函子是什么？</font></font></p>
            </li><li>
                <p>If <em>C</em> is a category, what are functors from, say, this
                    one object, one object category to Set?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我已经调用过这个了。从二到 Set 的函子是什么，然后也许从三到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的函子是什么？</font></font></p>
            </li><li>
                <p>I’ve called that one. What are functors from two to Set, and then
                    maybe what are functors from three to <em>C</em>?</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，找一个邻居，讨论一下到目前为止发生的事情，也许看看你是否能构造出这些问题的答案。这是基于……哦，是的。[S] 指出你需要任何……你知道，对吧？做……是的，对。就像一个……是的，我认为这就是想法。对于任何函子
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">F</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> : </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">G</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> → </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，对……你是对的。好的。
        </font></font></p><p>So, take a neighbor, discuss what’s been happening so far, and maybe
            see if you can construct an answer to these questions. This is based on…
            oh, yeah. [S] points out that you need any… you know, right? Do… yeah,
            right. Like one… yeah, I think that’s the idea. For any functor
            <em>F</em>: <em>G</em> → <em>C</em>, the right… you’re right. Okay.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有人能回答这些问题吗？还有问题吗？</font></font></p><p>Does anyone have some answers to these questions? Any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">首先，有人提出问题了吗？是的。你能再解释一下定义中的黄色部分吗？</font></font></p><p>Firstly, did anyone come up with any questions? Yeah. Can you explain
            again the yellow bit in the definition?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。这有点离题了，但我想让你说的是：这是表示函子的一种方式，这可能是更常见的方式，它表示函子是从对象到对象的映射。然后，给定两个对象，它是从这些对象之间的态射到这些对象的图像之间的态射的映射。但一种等效的表述方式，与这种数据或 David 周五谈到的元素结构属性图略微一致，就是认为它没有……不是对这些对象进行量化并说我们对每对对象都有一个函数，而是说我们有一个从态射到态射的函数。但这怎么会变成同样的事情呢？</font></font></p><p>Okay. That was a bit tangential, but what I want you to say was: this
            is one way of presenting a functor, which is probably the more common
            way, which says that it’s a map from objects to objects. And then, given
            two objects, it’s a map from morphisms between those objects to
            morphisms between the images of those objects. But an equivalent way to
            state that, which is slightly more in line with this sort of data or the
            element structure property picture that David talked about on Friday, is
            to think of it as not having a… not sort of quantifying over these
            objects and saying we have a function for each pair of objects, but just
            saying we have a function from morphisms to morphisms. But how does that
            become the same thing?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">嗯，有一些与态射相关的结构需要保留。这些结构被称为域和余域。因此，它表示当我们使用</font><em><font style="vertical-align:inherit">d</font></em><font style="vertical-align:inherit">中的这个函数获取态射</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的图像时，其域与该态射图像的域对象相同。因此，只需引入一个图。因此，我们在</font><em><font style="vertical-align:inherit">C中有这组态射，我们想要获取</font></em><em><font style="vertical-align:inherit">d</font></em><font style="vertical-align:inherit">中的某种对象</font><font style="vertical-align:inherit">。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>Well, there are certain structures associated with morphisms that
            need to be preserved. And so, those structures are called domain and co
            domain. And so, it says that the domain of a morphism <em>c</em>, when
            we take its image using this function here in <em>d</em>, is the same as
            the domain object of the image of that morphism. So, just introduce a
            diagram. So, we have this set of morphisms in <em>C</em>, and we want to
            get to some sort of object in <em>d</em>.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们可以取</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C中的态射，并使用此函数将其转换为</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的态射</font><font style="vertical-align:inherit">，然后取其定义域。或者我们可以取 C 中的定义域，从而得到 C 中的对象，并将其映射到 D 中的对象。我们希望这两个对象相同，所以我们说我们连接符号并说它是可交换的。这只是查看结构的另一种方式。因此，说我们有一个从态射到态射的映射，它遵循这个保留定义域和余域的东西，这等同于说，对于每个 x 和 y，我们都有一个函数。好吗？还有其他问题吗？</font></font></p><p>And we can take the morphism in <em>C</em> and use this function to
            turn it into a morphism in <em>d</em>, and then take the domain. Or we
            can take a domain in C, which gives us an object in C, and map it to an
            object in D. We want these two objects to be the same, so we say we join
            the symbols and say it commutes. And so that’s just another way of
            viewing the structure. So, saying that we have a map from morphisms to
            morphisms that obeys this thing that has preserves domains and codomains
            is the same as saying, for each x and y, we have a function. Okay? Any
            other questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想请原谅我问一下符号的问题，当我们谈论从模式到集合的实际定义，比如你使用的函子，比如一个新的箭头，我猜？哦，这个东西，是的。</font></font></p><p>So, I guess forgive me for sort of asking about notation in the, when
            we’re talking about the, like, from the schema to set for the actual
            definition of like the functor you use, like a new arrow, I guess? Oh,
            this thing, yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是我对态射的符号，但这种符号类似于函数，这是它对特定数据的作用的符号。所以，它来自最清晰的符号，如果你谈论的是集合之间的函数，你经常会写成，我们有一个</font><font style="vertical-align:inherit">从</font><em><font style="vertical-align:inherit">x</font></em><font style="vertical-align:inherit">到</font><em><font style="vertical-align:inherit">y 的函数</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，然后，比如说，从实数到整数，我们写成它取一个实数，然后将其映射到该实数的底数，对吧？所以，这是函数的名称，这被称为一种箭头映射，它表示集合的特定元素上发生了什么。在这种符号中，这有点像那个字符。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So, so this is my notation for a morphism, but in this sort of a
            function like thing, and this is a notation for what it does on
            particular data. So, it comes from the sort of clearest well, if you’re
            talking about functions between sets, often you write sort of, we have a
            function <em>f</em> from <em>x</em> to <em>y</em>, and then, let’s say,
            from the real numbers to the integers, and we write it takes a real
            number, and then it maps that to the floor of that real number, right?
            So, this is the name of the function, and this is called sort of a map
            to arrow that says what’s happening on particular elements of the set.
            And this is sort of, in this notation, is in that character.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么这些问题的答案是。如果我有一个从某个对象类别到 Set 的函子，那么我该如何理解我们为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C中的每个对象都得到一个集合？对吗？它们与</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的对象相同</font><font style="vertical-align:inherit">。如果我有一个从这个类别（称为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">2</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">）到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子呢？态射也是一样，对吗？因此，由于域和余域必须保留，一旦我知道这个态射去哪里，我就知道这个对象中的这个对象要去哪里，以及这两个对象上的恒等态射要去哪里。</font></font></p><p>Okay, so answers to these questions. If I have a functor from the one
            object category to Set, to see what’s how do I understand that we get
            one set for every object in <em>C</em>? Right? They’re the same as
            objects in <em>C</em>. What about if I have a functor from this category
            here, called <em>2</em>, to <em>C</em>? Same with the morphisms, right?
            So, because the domains and codomains have to preserve, once I know
            where this morphism goes, I know where this object in this object have
            to go, and where the identity morphisms on those two objects have to
            go.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，尽管这在两个对象中有三个态射，但指定这个函子的数据与在</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C中选择一个态射是一样的。我们可以说从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">2</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子</font><font style="vertical-align:inherit">只是在</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C中选择一个态射。那</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">3</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">呢</font><font style="vertical-align:inherit">？选择，选择一对可以组合的，对吧？所以，它选择了两个东西，但它们有一个约束，即这个箭头态射的余域的定义域必须是这个态射的定义域。
        </font></font></p><p>So, despite the fact that this has three morphisms in two objects,
            all that to specify the data of this functor is the same as choosing a
            morphism in <em>C</em>. We can say that a functor from <em>2</em> to
            <em>C</em> just chooses a morphism in <em>C</em>. What about <em>3</em>?
            Choosing, choosing a pair that can be composed, right? So, it chooses
            two things, but they have the constraint that the domain of the co
            domain of this arrow morphism has to be the domain of this morphism.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这意味着它们是可组合的，从头到尾更大，就像图中那样，但现在在</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。所以，它可能是一个从
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数，然后是一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">z 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数，但它不能是一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是那样的话……好的，太好了。现在我想谈谈自然性。好的，范畴论来自 1940 年代左右，来自代数拓扑。
        </font></font></p><p>So, that means they’re composable, bigger sort of head to tail, as in
            that the diagram, but now in <em>C</em>. So, it might be a function from
            <em>x</em> to <em>y</em>, and then a function from <em>y</em> to
            <em>z</em>, but it can’t be a function from <em>x</em> to <em>y</em> and
            from <em>a</em> to <em>b</em> if <em>C</em> what that… Okay, great. Now
            I want to talk about naturalness. Okay, so category theory comes from
            about the 1940s, from algebraic topology.
        </p>
        <h2 id="natural-transformations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">自然变换</font></font></h2><h2>Natural Transformations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">尤其是，这是因为该主题的创始人艾伦伯格和麦克莱恩试图描述某些构造（如基本群）在何种意义上是自然的。因此，自然变换本身就是函子之间态射的正确概念。</font></font></p><p>And in particular, it comes because Eilenberg and MacLane, the
            originators of the subject, were trying to describe in what sense
            certain constructions, like the fundamental group, were natural. So,
            natural transformations themselves are the sort of right notion of
            morphism between functors.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们有范畴，有范畴的态射，也就是函子，还有函子的态射，也就是自然变换。重点是，当你到达这个阶段时，它有助于准确捕捉你说某个构造是自然的时的意思。</font></font></p><p>So, we have categories, we have morphisms of categories, which are
            functors, and we have morphisms of functors, which are natural
            transformations. The point is, as you get to this stage, it helps
            capture exactly what you mean when you say a certain construction is
            natural.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想简单说一下这些。我会用一个定义来说明。如果我们有两个类别 C 和 D 中的函子，并且它们之间有两个函子，我们把它们称为 f 和 g。就是这样。它们之间的自然变换，我实际上可能会写出相同的符号，所以我将称之为 α。它是 f 和 g 之间的箭头。对于 C 的每个对象，对于 C 中的每个 x，它是 D 中从 f(x) 到 g(x) 的态射。所以我将这个从 f(x) 到 g(x) 的态射称为 αx。</font></font></p><p>So, I want to talk briefly about these. So, I’ll do it with a
            definition. So, if we have some functors from two categories, C and D,
            and we have two functors between them, let’s call them f and g. So,
            that’s that. A natural transformation between them, which I might
            actually write the same notation, so I’m going to call it α. And it’s an
            arrow between f and g. It’s, for each object of C, for each x in C, a
            morphism from f(x) to g(x) in D. So, I’m going to call this morphism αx
            from f(x) to g(x).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，然后它有一个称为自然性条件的条件，即对于 C 中的所有态射，我们都有这个交换平方。所以，我们开始。我们有一个从 f(x) 到 g(x) 的态射 αx。但我们也有一个从 f(y) 到 g(y) 的态射称为 αy。现在，给定 C 中从 x 到 y 的任何态射，我们的函子 f 给我们一个从 f(x) 到 f(y) 的态射，称为 f(f)。我们的函子 g 给我们一个从 g(x) 到 g(y) 的态射，g(f)。所以，自然性说这必须是交换的。</font></font></p><p>Okay, and then it has a condition known as the naturality condition,
            such that for all morphisms in C, we have this commuting square. So, we
            start. We have a morphism αx from f(x) to g(x). But we also have a
            morphism called αy from f(y) to g(y). And now, given any morphism in C
            from x to y, our functor f gives us a morphism from f(x) to f(y), called
            f(f). And our functor g gives us a morphism from g(x) to g(y), g(f). And
            so, naturality says that this must commute.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想我没有……所以我要再次将这个函数称为 f。所以，如果我们在这里取一个态射 f，这里，它的像将被称为 f(f)。对于函数 g，类似地，它的像被称为 g(f)。</font></font></p><p>So, I think I didn’t… So, I’m going to call this function f again.
            So, if we take a morphism f in here, here, its image is going to be
            called f(f) here. And similarly for the function g, its image was called
            g(f).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，举个例子。如果我们回到那边的例子，只讨论从一到一再到 C 的函子，比如说，从一到某个类别，对吧？所以，这些和对象是一样的。所以，假设我们在 C 中有两个对象。我将使用符号，只称它们为从一到 C 的函子，分别称为 x 和 y。这两个东西之间的自然变换 α 是什么？嗯，对于每个 x，它是从 f(x) 到 g(y) 的态射。所以，它是从 f 的态射……所以这里唯一对象的 x，我们称之为 x，以及这里唯一对象的 y，我们称之为 y，这样对于所有态射……这里唯一的态射是恒等态射，因此这个平方立即交换。所以，我有一个从一到 C 的自然变换。只有一个态射和 C，好的。</font></font></p><p>Okay, so examples. If we go back to that example over there, just
            talk about functors from one to one to C, say, one to some category,
            right? So, these are the same as objects. So, let’s say we have two
            objects in C. I’m going to use notation, just call them functors from
            one to C, called x and y. What is a natural transformation α between
            these two things? Well, for each x, it’s a morphism from f(x) to g(y).
            So, it’s a morphism from f of the… so x of the unique object in here,
            which we’d call x, and y of the unique object in here, which we’d call
            y, such that for all morphisms… The only morphism here is the identity
            morphism, and therefore this square immediately commutes. So, I have a
            natural transformation from one to C. There’s just a morphism and C,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第二个例子，仅从演示中，或者从另一个角度看待这个概念，假设我考虑过从二到二再到某个类别的态射。那么，让我画一个函子 F。我们可以将这个对象发送到这个对象，将这个对象发送到这个对象，将这里的箭头发送到这里的箭头。换句话说，函子是一种获取这种图像并找到它或将其放在这里的图像中的方法。</font></font></p><p>A second example, just from presentations, or another way of seeing
            this concept is that say I had considered a morphism from two to from
            two to some category here. So, let me draw a functor F. And we can send
            this object to this object, this object to this object, and this arrow
            here to this arrow here. So, in other words, a functor is a way of
            taking this sort of picture and finding it or placing it inside this
            picture over here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我有另一种方法可以做到这一点，那么让我们将那个发送到那里，将那个发送到那里，然后将这个箭头发送到这里。我可能需要一种方法来比较这里这个类别中的两个不同图像。将这种方法称为 G，另一种方法称为 F。那么，我该怎么做呢？自然变换说，对于每个对象，我们需要一种方法来表示我们如何将该对象放在黄色映射 F 下，如何将其放在蓝色映射 G 下的这个类别中。对于另一个对象也是如此。我们需要这个正方形可交换的事实。所以，这里的这个类别必须遵循这个等式，即这个东西，这里的这条路径，等于这里的这条路径，好吗。</font></font></p><p>So, if I have another way of doing that, let’s send that there and
            that there, and send this arrow here. I might want a way of comparing
            the sort of two different images of this category inside here. Call this
            one way G, and one is called F. So, how do I do that? A natural
            transformation says we sort of need, for every object, so for this
            object, we need a way of saying taking how we put that object inside
            here under the yellow map F to how we put it there under into this
            category under the blue map G. And similarly for the other object. And
            we need sort of the fact that this square commutes. So, this category
            here would have to obey the equation that says that this thing, this
            path here, is equal to this path here, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我——这个东西就是自然变换。当 A、B、A 然后是 B、C 然后是 D 时，那么它就像 C 中的交换平方，是的，好的。自然变换就是交换平方。所以，从一进行的自然变换只是一个态射。从二进行的自然变换就是交换平方。</font></font></p><p>So, I—this thing is a natural transformation. When A, B, A then B, C,
            then D, so then it’s like a commutative square in C, yeah, okay. A
            natural transformation is a commutative square. And so, a natural
            transformation from one is just a morphism. A natural transformation
            from two is a commutative square.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么从黄色到蓝色必须有一种独特的方式？或者可以有两个自然变换吗？所以，自然变换是从黄色到蓝色的一种方式的名称。所以，两个函子之间可以有许多自然变换。是的，事实上，这就是我要简要介绍的内容。</font></font></p><p>Why does it have to be a unique way that you go from yellow to blue?
            Or can there be like two natural transformations? So, the natural
            transformation is a name of a way to go from yellow to blue. So, there
            can be many natural transformations between two functors. And, yeah, in
            fact, that’s what I’m just going to get to briefly.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，还有其他例子。对于从事计算机科学的人来说，另一种思考自然变换的方式是它是一个多态函数。因此，多态函数的一个例子是 flatten，它接受一个列表列表并将其重新转换为列表。无论是数字列表还是字符列表，您都可以这样做。还有，再说一次，如果您有办法将数字转换为字母串，您可以在平铺列表之前执行此操作，也可以在平铺列表之后执行此操作，您会得到相同的结果。</font></font></p><p>So, other examples. Another way to think about a natural
            transformation, for those of you who have done computer science, is it’s
            a polymorphic function. So, an example of a polymorphic function is
            something like flatten, which takes a list of lists and turns it back
            into a list. It doesn’t matter whether a list of numbers or a list of
            characters; you can always do that thing. And what’s—what’s once more,
            if you put if you sort of have a way of transforming numbers into
            strings of letters, you can either sort of do that before you flatten
            your list or do that after you flatten your list, and you get the same
            result.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这正是自然性的表达。我认为有些对之间没有自然变换。所以，如果你看一下关系，就会发现存在一个自然变换。一对函子是等价关系。不，不。所以，例如，存在一个非等价的态射。存在一个态射；它不是相等的关系，对吧？所以，例如，如果我只有这个类别……存在一个从这里到这里的态射，但不是……</font></font></p><p>And so, that’s precisely an expression of naturality. I gather that
            there are pairs that do not have natural transformations between them.
            So, if you look at the relation, there exists a natural transformation.
            A pair of functors is an equivalence relation. No, no. So, for example,
            there exists a morphism between something is non equivalent. There
            exists a morphism; it is not an equal relation, right? So, for example,
            if I have just this category to… there exists a morphism from here to
            here, but not…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但它不是反射的，不是对称的。它不是对称的，因为从这里到这里没有同态。是的，好的。那么，让我们看看。所以，是的，我只想……多态的例子。所以，你是说如果你有办法制作任意列表？如果你有办法制作这个整数列表加上列表，那么从那里你可以通过自然变换，使用你可以如何将字符串列表的列表变成加上字符串列表？</font></font></p><p>but it’s not reflective, symmetric. It’s not symmetric because
            there’s no morphism from here to here. Yeah, okay. So, let’s see. So,
            yeah, so I just want to… the polymorphic example. So, is it that you’re
            saying that if you have a way of making arbitrary lists? If you have a
            way of making, like, this list of integers, plus lists, then from that
            you can, through a natural transformation, use how you can make lists of
            lists of strings into plus lists of strings?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，扁平化是自然变换的名称，它表示如果您有它，那么您可以扁平化通用列表。但无论是数字列表、数字列表还是字符串列表，对吗？列表 F 是列表的列表……是列表的列表。G 是列表，X 是整数，Y 是字符串。字符串，好的。是的。他是这么说的，但任何东西……任何，对不起，我打断了。没关系。但任何……无论您在哪里扁平化都可以，无论您的数据类型是什么。它都可以，并且您可以将任何函数映射到扁平化上。因此，如果您有将字符串转换为整数的方法，那么当您扁平化字符串列表的列表然后将其转换为整数列表时，您就可以扁平化。您可以按照其他顺序进行操作。这就是多态自然性。因此，具体来说，这种 alpha 是扁平化的想法，它将您的数据类型作为参数。</font></font></p><p>So, flattening is the name of the natural transformation, and it says
            if you have it’s the… so you can sort of flatten a generic list. But
            whether it be lists of numbers, lists of numbers, or lists of strings,
            right? List F is list of list… is list of list. G is list is list, and X
            is integers, and Y is strings. Strings, okay. Yeah. And he’s saying
            that, but anything… any, sorry, I’m interrupting. That’s fine. But any…
            no matter where you flatten works, no matter what your data type is. And
            it works, and you can map any function across flatten. So, if you have a
            way of turning strings into integers, then you can flatten when you
            flatten a list of lists of strings and then turn it into a list of
            integers. You could have done it the other order. That’s the polymorphic
            naturality thing. So, in particular, this sort of alpha is this idea of
            flattening, and it takes as an argument your data type.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。快问快答。实际上，我会很快继续讲下去，但下课后我们还有时间。所以，请上来回答，然后提问。好的。</font></font></p><p>Okay. Quick questions. Actually, I’m going to move on quickly, but
            we’ve got time at the end of class. So, come up and answer, ask
            questions then. Okay.</p>
        <h2 id="functor-category"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子范畴</font></font></h2><h2>Functor Category</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，假设……好吧，我要说函子和自然变换形成一个范畴。因此，给定范畴 C 和 D，有一个范畴，就像这样，其中对象是函子，而态射是自然变换。因此，这意味着，具体来说，存在恒等自然变换和组合自然变换的概念。因此，这被称为函子范畴。然后，具体来说，我们……给定一个数据库模式，即有限表示范畴，我们就称其为 C。</font></font></p><p>So, let’s say… well, I’m going to say that functors and natural
            transformations form a category. So, given categories C and D, there is
            a category, which is like this, where objects are functors and morphisms
            are natural transformations. So, this means, in particular, that there’s
            this notion of an identity natural transformation and a composing
            natural transformations. So, this is called the functor category. And
            then, in particular, we… so, given a database schema, so a finitely
            presented category, let’s just call it C.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们说函子集……所以我们看到，从模式到集合的函子是数据库实例，我们将这个函子称为类别，然后是 C 实例类别。所以，这是一种重要的结构化方法……特定模式的数据库实例如何相互关联？此外，在讨论类别之间的函子时，请考虑这些实例类别之间的函子。这成为一种非常结构化的方式来讨论数据迁移。</font></font></p><p>We say that the set of functors… so we saw that a functor from a
            schema to sets is a database instance, and we call this functor category
            then is the category of C instances. So, this is an important sort of
            way to structure how… How are database instances of a particular schema
            related to each other? Also, when discussing functors between
            categories, consider functors between these categories of instances. And
            that becomes a very structured way to talk about data migration.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们请到了 Ryan，他和 David 共同创立了 Categorical Informatics 公司，该公司专门开发商业级软件来实现这一目标，我们来谈谈结构化数据迁移。所以，他是个很好的谈话对象。如果你想和他一起完成你的第三个任务，或者只是想考虑一下，他今天就在这里，你很适合和他交谈。</font></font></p><p>So, we’ve got Ryan, up at the back, who founded, along with David,
            this company, Categorical Informatics, which sort of builds commercial
            grade software to do precisely this, to talk about structured data
            migration. So, he’s a great person to talk to. He’s here today if you
            want to do a project with him for your third assignment, or if you just
            want to think about the stuff, he’s great to talk to.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在 categorical data.net 上也有一些项目。有一款名为 AQL 的软件，那里有它的免费开源实现，玩起来很有趣。</font></font></p><p>And there are also projects on categorical data.net. There’s a
            software called AQL, and there’s a free, open source implementation of
            it there, which is fun to play around with.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我们看看。我想——让我看看在最后五分钟里我是否可以告诉你一些关于类别中的通用构造。</font></font></p><p>Okay, let’s see. I wanted to—let me see if in the last five minutes I
            can tell you a bit about universal constructions in categories.</p>
        <h2 id="universal-constructions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">通用结构</font></font></h2><h2>Universal Constructions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在第二节课中开始看到一些关于预序的通用构造，并且我们看到了“相遇和结合”的概念，它概括了许多事物。它概括了诸如“和”和“存在”之类的事物。它概括了最大公约数 (GCD) 和最小公倍数 (LCM)、并集和交集。但是这个概念——这些概念可以在类别的背景下进一步概括，以涵盖更多人们喜欢思考的自然构造。</font></font></p><p>So, we started to see some universal constructions for preorders in
            the second lecture, and we saw that there’s this notion of meet and
            join, which generalizes a bunch of things. It generalizes things like
            “and” and “there exists” for it. It generalizes greatest common divisors
            (GCD) and least common multiples (LCM), unions, and intersections. But
            this notion—these notions can be generalized further in the context of
            categories to encompass even more sort of natural constructions people
            like to think about.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，请注意普遍性。我们特别看到了这个概念……</font></font></p><p>So, just a note that universality. We saw, in particular, the
            notion…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，要知道的是，乘积的概念可以看作是通用构造的一个例子。比如说，集合的乘积，因此也属于这类东西，比如交集——以及……</font></font></p><p>So, something to know then is that the notion of product can be seen
            as an example of a universal construction. Say, the product of sets, and
            hence sort of also in this family of things like meets—so like
            intersections—and…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，记住，如果我们有两组集合，A、B 和 C，那么集合的乘积就是 (a₂, a₃, b₂, b₃) 这种集合，我们看到了伽罗瓦连通的概念，现在可以将其推广为伴随的概念。</font></font></p><p>So, remember, if we have sort of two sets, A, B, and C, the product
            of the set was this sort of set of (a₂, a₃, b₂, b₃), and we saw this
            notion of Galois connection, which can now be generalized to a notion of
            an adjunction.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">伽罗瓦伴随（就像伽罗瓦连接一样）是一对函子，而伴随是一对朝相反方向发展的函子，使得 hom 集之间存在双射。</font></font></p><p>A Galois adjunction—just like a Galois connection was a pair of
            functors—and an adjunction is a pair of functors going in the opposite
            directions such that there’s this bijection between hom sets.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我们选择 D 的一个对象并根据将其映射到 C — 抱歉，这是不对的。如果我们选择 D 的一个对象 x 并将其映射到 c，然后根据 f 映射到 d，那么从像到 D 中其他对象的态射与从 x 到 y 像的态射是双射。所以，伴随是一对方向相反的函子，这样我们就可以自然地在同源集之间进行双射，其中“自然”是由自然性变换的概念捕捉到的。那么，这是 G 连接定义的概括。让我们看看；有这样一种想法，即相遇可以理解为某种连接，或者从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Gawa</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接相对于对角线产生的东西。</font></font></p><p>So, if we pick an object of D and map it into C according to—sorry,
            that’s not right. If we pick an object x of D and map it to c and then
            to d according to f, then the morphisms from the image to some other
            object in D are in bijection with the morphisms from x to the image of
            y. So, an adjunction is a pair of functors in opposite directions such
            that we have bijections between homsets in a natural way, where
            “natural” is captured by this notion of naturality transformation. Then,
            this is a generalization of the definition of a G connection. Let’s see;
            there’s this idea that meets can be understood as some sort of junction,
            or something arising from a <em>Gawa</em> connection with respect to the
            diagonal.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，给定任何偏序集</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P ，我们有一个从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的映射</font><font style="vertical-align:inherit">，它只是复制了该元素。因此，我们称其为对角线的 Δ (delta)。因此，这有一个伴随，事实上，伴随是交点。
        </font></font></p><p>So, given any poset <em>P</em>, we have a map from <em>P</em> to
            <em>P</em> × <em>P</em> which just duplicates that element. So, we call
            that Δ (delta) for diagonal. And so, this has an adjoint, and in fact,
            the adjoint is meet.
        </p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">在这个特定案例中，这意味着什么？这意味着，回想一下Gawa</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接的定义</font><font style="vertical-align:inherit">，某个元素的对角线小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的某个任意元素，当且仅当——这就是我所说的双线——当且仅当
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">小于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的交点。
        </font></font></p><p>What does this mean in this particular case? It means that, recalling
            the definition of a <em>Gawa</em> connection, the diagonal of something
            is less than some arbitrary element in <em>P</em> × <em>P</em> if and
            only if—so this is what I mean by this double line—if and only if
            <em>P</em> is less than the meet of <em>x</em> and <em>y</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在这个范畴的概括中，我们讨论了一些乘积的概念，我们只讨论集合中的乘积。我们有一个从集合（集合 × 集合）到对角线的函数。因此，我们将集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">再次称为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。由于集合之间的函数，你只是在每个点或每个因子上执行相同的函数，这个东西有一个伴随，或右伴随。右伴随称为乘积，它的意思正是那里的构造。</font></font></p><p>So, in this generalization to categories, where we talk about some
            notion of product, let’s just talk about product in sets. We have some
            function from a set, a set × a set, to the diagonal. So, we’ll call the
            set <em>P</em> again to <em>P</em> × <em>P</em>. And since a function
            between sets, you’re just doing the same function on each point or each
            factor, this thing has an adjunction, or a right adjoint. And that right
            adjoint is called product, which means exactly that construction
            there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">具体来说，这种映射，因为它需要一对集合来得到这两个集合的乘积，而我们如何理解这一点与此相关，就是表征乘积的另一种方式是通过这种方式在 hom 集之间进行双射。</font></font></p><p>In particular, this sort of map, since it takes a pair of sets to the
            product of those two sets, and how we understand this is related to
            that, is that another way to characterize the product is by this sort of
            bijection between hom sets in this sort of way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体而言，存在从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的函数，其中</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X与从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的函数（抱歉，这是集合 × 集合）自然地一一对应</font><font style="vertical-align:inherit">。
        </font></font></p><p>So, in particular, there are functions from <em>P</em> × <em>P</em>
            to <em>X</em>—where <em>X</em> is in one to one correspondence in a
            natural way with functions—sorry, this is set × set—from <em>P</em> to
            <em>X</em> × <em>X</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么这是如何实现的呢？如果我们有一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P ，它有一个从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 Y的函数</font><font style="vertical-align:inherit">和一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 X 的函数，那么我们可以通过对这个函数进行排序来提取一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 Y的函数。因此，具体来说，它将元素</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">发送到</font><em><font style="vertical-align:inherit">P</font></em><font style="vertical-align:inherit">的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，</font><em><font style="vertical-align:inherit">P</font></em><font style="vertical-align:inherit">的</font><em><font style="vertical-align:inherit">g</font></em><font style="vertical-align:inherit">。而要返回另一种方式，我们可以进行投影。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>And how does this work? Well, if we have a <em>P</em> with some
            function from <em>X</em> and a function to <em>Y</em>, then we can
            extract a function to <em>X</em> × <em>Y</em> by just taking sort of the
            pair of that thing. So, in particular, it sends an element <em>P</em> to
            the <em>f</em> of <em>P</em>, <em>g</em> of <em>P</em>. And to go back
            the other way, we can take the projection.</p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果你有一个从P</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的映射</font><font style="vertical-align:inherit">，那么我们可以说，好吧，它将元素发送到第一个因子的哪里，它将元素发送到第二个因子的哪里？这给出了这两个集合之间的对应关系，这恰恰概括了这里的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Gawa</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接的概念。但同样，我们现在不问是否有办法从一个对象到达另一个对象，而是讨论从一个对象到达另一个对象的方法集。</font></font></p><p>So, if you have a map from <em>P</em> to <em>X</em> × <em>Y</em>,
            then we can just say, well, where did it send the element in the first
            factor, and where did it send the element to the second factor? And that
            gives a correspondence between these two sets, which precisely
            generalizes this notion of a <em>Gawa</em> connection here. But again,
            instead of asking whether there’s a way from getting from one object to
            another, we now talk about the set of ways to get from one object to
            another.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想我就到此为止了。如果您有任何问题，请提出。这是一场简短的讲座，所以请随时留下来提问。至少还有半个小时的时间来做这件事，所以，好吧。</font></font></p><p>I think I’ll end there. Please ask if you have any questions. This
            was a fast lecture, so feel free to stick around and ask questions.
            There’s at least half an hour to do that, so, okay.</p>
        <h1 id="applied-category-theory.-chapter-4-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 4 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 4, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABALDBoYFhoaGBodHRofHR0dHR0dHSUdHR0dLicxMC0nLS01PVBCNThLOS0tRWFFS1NWW1xbMkFlbWRYbFBZW1cBERISGBUXJRoaJVc2LTZXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV//AABEIAWgB4AMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAAAQMCBAUGB//EAEYQAAIBAgMCCQkGBAUEAwEAAAABAgMRBCExElEFQVJhcZGSsdIGExYiMnKBodEUFTNCU8EXI2LwgqKy4fEHNENzY4PCJP/EABgBAQEBAQEAAAAAAAAAAAAAAAABAgME/8QAHREBAQEBAQEAAwEAAAAAAAAAAAERIQISAzFBIv/aAAwDAQACEQMRAD8A+fgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9d/DvGfq4ft1PAP4d4z9XD9up4CauPIg9d/DvGfq4ft1PAP4dYz9XD9up4C6mPIg9f/DrGfq4bt1PAP4dYz9XDdup4Bo8gD1/8OsZ+rhu3U8BH8OsZ+rh+3U8BNHkQesq/wDT7GQhKTqYe0U5O053slfkHG+46vKh1v6FHMB0nwJV3w639DB8EVf6et/QDQB16XALlricPB/1+eXz2LG9Q8jKtT2MXgpdFaV/9IHmgevX/TnGfq4bt1PAP4c439XDdup4Bo8gD1/8OMb+rhu3U8A/hxjf1cN26ngGjyAPX/w5xv6uG7dTwFU/+n2OXHRfRN/QDyoPRz8isZH2thdvwlXoliOXS7UvCBwQd30TxHLpdqXhJ9E8Ry6Pal4QOCDveieI5dHtS8I9E8Ry6Pal4QOCDu+ieI5VLtS8JPojid9Prl4QOCDuvyUxC/NS65eEj0Wr8ul2peEDhg7notX5dLtS8JD8lq/LpdqXhA4gO36LV+XS7UvCR6MV+VS65eEDig7XoxX5dLrl4R6MV+VS65fQDig7XoxX5dLrl4R6M1+XS65fQDig7a8l6/LpdqXhJ9Fa/LpdqXhA4YO56K4jlUu1L6EPyWxHKpdqX0A4gOy/JqvyqfXL6EejlblU+uX0A44Ov6OVuVT65fQejtblU+uX0A5AOt6P1uVT65fQej9blU+uX0A5IOr6P1uVT65fQfcFblU+uX0A5QOr9w1eVT65fQj7hq8qn1y+gHLB0/uKryqfW/oPuOryodb+g0cwHS+5KvKh1v6D7lq8qHW/oBzQdF8DVOVDrf0I+6KnKh1v6Ac8HUocBVak1BSp3d7XbtpfcdFeRGKcdrzlC3vT8JNH1UAGW0koxJQEgAqBBJBBTj/wKv8A65/6WfO1ofRMd+BV/wDXPuZ87WhqIkgAoGMqcXrFP4GSLpxULJq8rJtPSPN0gUU7w9ic4e5OUO5m5S4WxcPZxNTons1O9XKKmy0nHJ6OP7rmMaVNykorV5LpA61Lyoxcfa8zPpi4v5M26XlhJfiYZ/8A11E/k0jzlxcg9dT8r8M/bjWp+9T2v9Nzdo+UGDn7OIgvfbpv/NY8JchpPVIYPpdOvCavCcZLfGSfcTOnGXtRT6UmfMfNRTulZ71k/kbFHF1qfsV60f8A7HJdTJg99Pg+jLWmvhePcUT4GpPRyXxv3nlKXD+Nh/5oz/8AZTj+1jbpeVuIXt0aU/dlKHfcdHYqcBv8tRfFWNefA9ZabL6JfUqpeWMPz4erH3XGa70bdLyqwcsnUlB/105xXXaw6NOWCrR1hL4K/cVOTjrddOR3qHC+GqO1PEUZPcqkdrqvc23Zria60NR5R1SNtHpZ4OlLWnHqs/kUT4IovRSj0S+o2GOGtncT5uLOnPgSP5ajXSrlT4HqLSUX8Who57oLiZi8Pzm/LA1Y/kb6Gn3GH2efIl2WUaLpIjzW5m7KhNa05fGDNatPdkBTsGDMncxuBCJuTkSqV+MDFVbEqoRLD85g6LAzlK5VJ55oZrUTkQQ0Y7LYui2EtzKMI4aTz0XOHRS1d/kX1ZZampJsgyaju+Zi1HcVNMgCx23GN0VhgZNowbRDAGLMTJoxAhmDM2Y2uUbPBn49Ppf+lnrqf4T/AL4jyfB0Wq9K/K/ZnrKP4b/viM+kdgEAOiSUYmSAkEAqJMSSAKsb+DV/9c+5nzpaH0TGfg1Pcn3M+dLQsGVwQwVGdPVX0uZ4xPztS+u3LvKbmxOcamcnszSs3ZuMraXtmmBVCnKTtFN9BbhHs1oX4px+TJp14wjsuO2tpSybinZaPLNE18SnU87CTUpWbWmzK2dn03AYvByhOpldRlLRptR2rJtGvKDjqmrq6urXW82+EMd56Un63tScbvJxbuk1vRbTrxqQvUSSVam5NXu07p9y0IOaS1pn/sb2KrwSls7LnJw2nFZWs9pJ9Kj8ymnWh/N/Lt3UXa+ym811ZAY4Omp1YRejkk/iyhHSwioqrQdOUnJVIbSkrXzWa5jmJgSWTpSjGMmvVldRe+2veIwlsZey5JWvrKztl1m/j8PU2MNSteSjN2TvZyltWfwsBzLi5ZUoTje8X6rSb1S3ZrIqAxlCL1SfSiacdl3hKUH/AETlDuZk4uydsne3w/5RAG1T4TxUPZxNXolaa/zI26flLjI6yozX9VNp/wCVo1KXr05RftQTnDo1lH9/g95jFxhH1oqUpLJO9ox39IHYpeV9Re3hovnhVt8mv3Nul5XUH7dOtD/CpL5M8mQ5qzd9CZB7in5SYKX/AJ4x99On3o3aWLpVM4VIS92al3HzV4hcaK5OEuKN+glg+qXK5KMtUpdOZ84o4upCPqTnFf0zaLsNw3iE7Kq3n+ZKRB7KpwRTejkupmGH4JhGalOW1FcVrX6czhQ8pcTHKUaU7e9B/ubFPysf/kw0l7lRT70i9HoqtPkNLmsl+xqSwknrGMvgm/kaNPyowz9rzkPept/6bm1S4aws/Zr077m9l/MhijH4GUYKcYbKTtLN/BnL22emhWT9mSa/pZXVown7UU3v0ZdMec2g7M7U+DaT4muh/UonwVHim/ihqY5LpbjBxtzHW+wTWjixOhO2cL9FmXRxm2TtG9Vorjg0UypQ5wNa24xcTYlRXEypwaAqBk0QBizHZbZYSBH2Z8bRhKkt5cpMxlBAUOmiL20M5uxTII2sDO9Wn76PU0PYf98TPJYH8Wn78e89bh/Zf98TJ6HYBAK6pJRiZIIkAADEyMXqBVjPwanuT7mfOlofRcZ+DU9yXcfOVoWJUi5AKibggASCABnTklJOSur5reiypUjs7ENq1025WTdr2yXSygACSABKlZ3TswQCC2lXlBpxej2lxq+8tpY+cZSk7S2r7SlFNO+XwNUAbbxt1aUFL2s5Nt2etufn6DVla+V7cV9SABldbPHtXVt1s7/t8zEADZ4Of86mno5KL915P5NlFapeTk+N9S3EQk4tOLs07p7maONcrq3GgLq+IX5U/jmadWtLPrMo4WbjtZlTg1qRbGEarvobO0rO1ka9tRGLurhG3RrpLe3kzNzvlaKe80pqxg80MV0/tCbz143z7zYjSk4uSV1FJt7k8kcilVyz/tG1hsU/Yu7X0vlffYI2SGluM4tJ5q63O9n1FuIjT1g1zq8n3xX7lRqqlFO6VnvWTN6VWrSso4ipdWvHak7XV+PU1Iq7SulzvRG7XwynKKhNSk6cHo0rKKu7voCkOGsVH/yqXvwi+6xsU/KOsvap05dDcX+5za2HlByWtrXavZX7iq3HbImQegh5SQ/NSmvdal9C2HlBhnrKUfehLvRwKkE47cU0nOatrZZNL5krD/y5Tf8ARbobkv8A8jIuvT0+EqE/ZrQf+JLvLXGMuS+pnjqtKOzGSWTbjZ70lfvKVFLS691uPcT5TXsp4SD/ACr4ZFE+DoPRtfG55uniqyso1qnQ5bXebC4WxMHaU1Jp2alBJ/KxMqutLgzdLrRTLg6pxWfxNWPlBVXtU4Pok19S+HlDD81Oa6LMf6MjCWEqLWD+GZhstapo3IcOYd6ycX/VCXebEMfRnpVg/wDEibTHJZFuc7TpQlnaL+CMHg6b4upsfaY5EoXIeFyumdSXB8eJtdTI+xW4y/UMrl4eOzUhtZWnDquj0NPhGhDKdWKb5/3NDE4RyjkldnI4UwE4Ri0nK+71u4uyplfRrggFdE3MomBnEiMiAABjxmRg9SivF/hVPcl3HzlaH0bF/hVPcl3M+cx0RYlSCz1N8l8FL90T5uPFUXxUl+xUVAt8xunTf+K3eT9kqcUb+61LuApBlOhOPtQkumLRWBIuAQCSCQBAAEkAACSABIsQbFNeqrPNqXq5+txAUp9ZTOltSRu0KDU4t2spReuquVYeN5xXOhVjvU8JCNNRsskjzfCdNKpLuPU1M45HluE7KbvJc+Zy8/t19/pzl0CpNW9UbUW73+WpvU8BTqQezN+dS2ti2TXM950c55t/TlXvqZTWljN2/wCTG60Kyqu0TSlZ85nJoqTzCuzCV0mSY0vZXQZMIFtPEtST/p2MnZ2tbXeUkAblLGKMZw2bqV837Svb90vnvFXEqVOClKV00thXUdlLXN2v0bzTARuxqUnStJtNSqPZu+NK3FnpzGMZQjGUHLKUqLb1srPa6tr5GmAN2lKk4xhJyt52byt7LUUm3xaGr5t7ahb1m9m3PexjDZv6ybXHZ2ZnUrN1NuOT2tpcdne6IrY+wSg4Sbg15yMfVlfO4pUJOvTm4vZdaPrNWi/Wzz6zVVaStzPaXM/7RsS4QlKCUkrxnGSa3JW+gRr1qbTd1lvMaUNqcY75RXWy+WObTWzG17pPO2bdvmWQxyum07KpGdlbK2ufOBp1IWbtonYrcVxm/CVObb2LNQUnybqybt0srqyhstxUb7SWaztbVZ5Zp9YVppW0bXQ2i+njKsdKs/i795SyAN6PDFdfmi+mP0LocPVF7UIvobX1OWDNkNdyHD0X7VOS6GmXw4YovVtdMWecFyfMXX1QEA0qTOJWITle2y7X1uraAXAgADF6mRhfMorxf4VT3JdzPnUdEfRMX+FU9yXcfO1oWJQEkFQFgWUZpO0vZeT+vSBEK84+zOS6JNFn26rxzb960u8w8zabi+J5vm3lcrXdtOK+oF/2t8cKb6aaXdYnz0PzUY/4ZSj+7KqSzvuIkQZVJRfsxcd95bX7IrBlKDST4ne3w/5KMQCAJIAIAAAGaqNKybSMBYCzz0t7eaee8r886frKKlb8rbSfVmDawGD89PZfs2vLoBJtY0sS6rV0lfWEU1DqN7GcHQdGXqpO2SSSSZTgcO4S9detGTXSt50K1S8WcrevRJzry+Go3laSyN2lBU68EtbJ35txK9WV7ZXOhLEUIwulebWdln1i1fEee4RWzUnlk3c1G4vS9zocKUnKKkt+ZyprZZ0jl+SdZW0zMFG8klvFrmxgorb+BWHQirJIkAjIQAVQgkgACAwAIBAAIAEAAZRm1ez1Vn0XT/ZGJAAEEkEAEEgQSQSgPqZAIDaSyBUWUyjMEAIFdknkrcZYVvUCvF/hVPcl3HzuOiPoeL/Cqe7LuPnkdF0FiVIAKgEQANqt+HGXG1sP/D/tslNOMX7Utn4N3IlUbio20bfO72+hgBsUoXlZP46K28wrbOWztc7ds+jcTRnsu+WjWeaaMJVLu9kuhWQEyoySu07d3TuNpYaU6VOydlKo27OyVo5lMsW5QlFpJSe1ll619X8+siOKkoqPEnJ553TSTXyIIlh2k2mmlueuV31FWy93QbeEqvbUWlZ7SeWkWszH7ZkrRs1FpO+l0lddV+lgVeb0Vne7ytmVtWNmliXG2Wikr8efSUzqXio7m3d9yAeZyvtQ7ST+ZWWwxDStaLX9UIv56lcnd3tbm4gCLJ0muLK0XfizWRWXfa52UcrLm13X6AIVGTuraOXWtUbuExPmIetH2s+drT6mlTxMotNPNNvPe1ZmNStKVtp3to3m7dJL1fPqy661OuqsttR2Va2e8nFySicqniZpKMVxl1THbUbSykc7Hf62K3LLXIwptXtr0GrKpK7RbQ1WZU11KdBSVmcvhbgq0duCvnn0Hbw2hs2TJuNZK8FOjJcTL8EvWPY1cDCX5Vmc/GcFqEduMbW1tuNT05+vGOcQW4ei6rtC8nzJm3iuCZUqe25J5rJLfzm3JzyAwyCAAUQACCAABBBJAAAAQQSQwAIAAAEAEEgfUSLhkBtkWUyq5ZTKLCAADK5PMsZVLUIrxf4VT3Jdx89joug+gYv8Kp7ku4+fR0XQWJWRABUCdl2btktXxIgzpVHF3XVxNbnzAYA2HCMZSla8UlKKfHfNJ/3xFFSbk7u3wSiupAZRaKxcgCSUyEW4iT2muJZJcSAyniG7+rFNqzaTu/mVIxNinSbpykot2lG7teytL/Ygr4mYGVm03xbzEACyMItXc0nucX3oqYGUVd2WpBMJWae53Mq6tOS/ql3gYEmJIE7TV7GnWqP82TNsrq0lLUmLuNSNTnLqNS7tzkLBR3smM40pK+a7iWNT09LhV6qL4mng6qlFNO6Zs08VTVWFObd5O2XFuuc82uv1xu0s9C5uKydnvRRWqv2YKyMI4Z78ztPxT+ufr8lv6ZRpqKUYRUYviirIjG0tqjOPM3u5ynFY2OH9rOVso8dt73I41fHzqv1n6vEuJdBvkcmjIgvcY21RS1uafQYViAQQCAAAAAhkEgCAABBBIAggkEEEE2AEEgAfUGQQ2RcrbIsp6FRZS0YFlwQAiWUyeZaymWoFeLf8qp7su4+fLRH0DF/hVPdl3Hz+Oi6CxKkAFQuCBcDaxD/l0t7Ur/Bu3eymFSKWcFLpclbqaMZTbST0WnWYsgmTV9LcyubVLKC9WLi1Lbbjd34s+Li0NIsm/Uj0y/Yo2lCnd6ZQU2296XqrrIliIvbbs5ZbGS1azb6DSBBtOvFuPq2Ub2sk3plffnn8RSxOx7KbWWrzvfU1bkgbPn7pppKNso24+bdqUXMbgC2nUtrGMlz3/ZmM2m8klzK9vmYEgSjdrKleT2k276bV79VjRM/MvLnA2Z4dOailbauoq/HeyfQyKNOK27+tKNsrXvv6Sl05RSknx2y1TMZXvd6vMDOm01JWV3o2r25ubpKiLkATc1cVsr2k3fRriNx02oqXE218UVVYpr1tALOCKjhle61XOiMVN+cc753uuaxRRqKm7pXtoV4iu5N8QnKu8e5wclUjGd1ZpM5vDXDiovzdG0qu/WMPq+Y87HhGtCGzGVlay3o1aSd7t5655tmtZbXnHtOUpOUpZybd22ZRu3msuKK4+krh0W3L92X33a8bbILFbjfVkG1xZr4FTmlq18cyFVb0iQZTjbTQwM4TTy+RhIioBBIAgAAQSQAAAEBW4wQAAAAAEEEogAfTWQGRcraS2lxlJbS0YFpAICJZTLUtZTJ5hVeL/Cqe7LuPAR0R73F/hVPcl3HgY6IsZqQAVAmEW3ZasghATbr3CcWsmmnuaszZk8lVWtrP39L9TTNaNOVRvNN6tykl82wK2xtPQsVB7WzdN/0tNdaL54WEdZSVo7TulfW2S5+cCihreydk3Zq60MHK7v8Atb5GxsKnNZtXjLma1S68jL7VDXYu8s5Wd2/ab7l1kGFOF6c7LjhxdJVsu17ZPQujinFtw0taz04uL4FNSo5O76OZLcBnGm3b+rQiVOS1TWdviTCvJWta6Vk7Z2/tllKu3Ujtu62ot33J/wDIFU6TSTbWd8uNdPWbEcI5Q2oRqP8AwXi/imUVp3k1e9m0ui5VcKyeR0acU4Qs3e2iS4st5zbl8I3cV/dwNqpsxjJXveStnu4yirNtWvktDGrGSavGxkqa/NLZWq5+gIois0nlmi5wilJyVmsopP8Au5VXlFtbN7bMdd9sysg34TpqKi83G8t8W3ZNfI5WIqKUskrbuJFlSdkzXhvKhJ24mYavSxa9GY8TKMNjPN/Flilu04+cwvbne4m13b4sDO7S0vcxb3u73GO18P2MY2vf/kCxK2Zl5zcUt3ZkFXRnfUtvc1b5l9ORKJIJZDIBAAAAi4AEMASQAABAAAAgAAD6WQGQVtJbS0ZSW0tGBaRcEASUz1LWUyeYFWL/AAqnuS7jwMdEe9xf4VT3Jdx4KOhYzUgAqABAFrq/y3D+pS+TX7lBkzEC/BRvUj8e41i6jUcJKS1TTW4wjBvJEGMm288wjp0PJ/FVFdU3Ff1tR+TzN+h5J1GvXqwjzJOTRPqRctcCTyISNnH4OdCpKnPVaNaNb0a2gnUS0QGwUQAABaqrVmsmvkVADZli3mlo75c7tfuKJSb1ZiAJuEQTeyYFNWWu4hLRES4iYvXmCImyGiVm/wBjF8+gGKkuJacZKyV75shyy/uwlKysBhNtrPQcxF22rksolIyuYpmUdwEsmMjANhWxGd1fr6SSmlKza36FxAIJIIBAAAEEgAAAIBAEggAAAB9KZFw2YhtkW0tGUXLqWj6QLQQQBLZTLUsZTLUCrGfg1Pcl3HhEe6xr/k1Pcl3HhEajNSAAiRFXIEZWYEyVjFIs1zeiXF06F1DC7dmmknJRzenO2BrJHoODsPDCxVWqr1NYxf5ed85bS4KpYe7liKUqn5Ulez6zapcH0a3rTm5c19lHP1Xbx5ma1avlRFu0fidfCV9tbW41Z8EYd2ShTik004tuTtvZnVjs5Q05jncbZcMcGxxNPLKoruL/AGfMeGqQcZOMlZp2a40z31Krso5nDmCozj521p6PO1+cvj1lxz9+f68oGXzw9tH8HkymdNrVHZyY3BBIAEEgCbmJlGN2AKqsjOWISysukonIILiJUszGGdibASiuT438DNPUwmsrv4FEbkROSvmL55Ixna4GEZ3k8uIsbNdVPXL2wrKJLIQCMkLEImwUh7S+JsFNJZlxAABBAJIAAACAAAIJIAAAAAAPpDMRci4bSXUtCgupaAWkAgAymWpa2Uy1KinHfg1Pcl3Hhke4x7/k1fcl3HhkIlTcXIBUTcgi4AsjNWaabTs8nbMwnWklZNpXva/GQyubA1pza0ZbhuFatPK7a6TGSKJwF6stjqU+Hqq4zcocOpr1m0zziRmjPzF+69TT4Yjy79LHCPCkZ0rRSb6dTzEY7WS4zKfqJQ+La3k+Zq33cbccRxJuPM80WxxD41lvjoc+EudPmZnGVtLxfyNuboKcZar9mT5mL0bXzNONSy/csVXMC6VDc+kPDu5jGvmZ+ezAxVF8eRjVrKKaQxNb9jTlO9yCJ1VIrbsYyjcrbaKNuk7pPpMpOyMKFnG/MzJvK24gJ2Rg1o3qZp5WMJLO7KMfzENJ63yJTzIla+oGtVyknaxsJFVV3ayLYO6AzCFibAQzIxJQVbTLDCkZkAEAgm5AZAEkAAAQAJIAAAEASCAB9GZAZAbSXUtCgupaFFpBAIIZVJ5lrKZagUY9/wAir7ku48Oj23CH4FX3Jdx4k0zUkABC4IABlcjNsrkBWzFozIaCKWgZ2JsFVjpJaMQMtglSa5+kxTM0wjNTJU7ldjG9gq9SzMnUzRr7XGRt6fUIvqyvdGtKTtfrLNrMrb16QI2zCTITFr5AbVH2PkZpCELQSe8mp/wQY8RjnddHwMtnJGHHd6biiONkOGebyM75u5i484FVR7lkZUdGiJO7y0Ig/W6QLrBIJ2JugF0AALaRmV0iwigIBAYBAEkAACAAAAAAAALggD6LcgEBtJdS0KC6np8SiwMi4CDZTLUsZVLUDX4R/Aq+5LuPEntOEn/Iq+5LuPFosSgACJIAAhmLJZiwMGQZMxAxsCQBi0YNFpDiBUjIloWICMjEkCZU76GDossTMkwNdwluMakXfQ3EANOOHk89Ok2aVFR6TMkBPiMJ55ky4iGrIInLIrepZLRZ9JU5XemXFzgTTazQcc7BPN3MW3coxnxW0KtGi2cs7LrKpMC9R3jYIjK6RNwBlcJkNBWdPUsKIvMvJRBIIAAAgAACAAAFgABAAAAgD6IQGQG0pl1PQoL6byAzuRcgFQbKpaljKpahWtwk/wD+er7ku48Yey4T/wC3q+5LuPGlZoAAgAAMWQzJmIGDRiyxlcgMQQyUBkCCQIMWjMggxBLRAEmSMDJEGaJIRJQJIJQEtZ/Ark+LeW3zf95FTWYRM1zlcpXatxFso7uMqna6sUFG7aIcHezJUcyZJ306wK5pcRVNF87KyyuVVIgZUHdWXEXbG9lNCVou2tyyyf5gDS3hcxDit5CTCsrFqKbFlN5EozAAEAkEEEEgCASQUCCSCAAAIBIA+gsgMFbDYp+ya5fDQDIAgA2VPUsZW9QjU4T/AO3q+5LuPHHsOFP+3q+5I8gVKgkAIgE2IKIMTKxDRBizBmbMGBgyAyAJMkYkoDIgAgENEkAQSmQEBaiTFEgSAEAerz/4IuZPVlcnp1hGcobuMqm9EiybzyMaltOPjKMGlf8Aclt7hKOaErreBEls9JXNljjZXeRVMCcPScrviL/NR42U0IyksskW/Z+cB6i5x53ciPNLeQ4W4wrGpULqfsoomtDZiskQSAAAAIBBLIAAACAABAJIAAAD6CLHhPTTE8ij2Z+IemmJ/TodmfiKuvdF0JZLrPn/AKaYnkUezPxGa8uMV+nQ7M/EU19AIPAenOK/TodmfiHpziv06HZn4ga9+yrVnhfTnFfp0OzPxGPptiv06HZn4gbHuMRhvO05wbspJq+tjl+jUP1ZdlHnV5cYr9Oh2Z+IenOK/TodmfiBsej9Gofqz7KI9Gofqy7KPO+nGK/TodmfiI9OMV+nQ7M/EE49H6Nw/Vl1Ij0ch+pLqR5303xX6dDsz8Q9NsV+nQ7M/EDj0L8nYfqS6kYPydh+pLqRwPTbFfp0OzPxEPy0xPIo9mfiA7s/J+H6kupFEuAocuXUjjy8sMS/yUezPxFb8rMQ/wAlLsy8QXjqS4HhypfIx+6YcqXyOS/KWu/y0uqX1I9I63Jp9UvqQ4664KhypfIyXBMOVL5fQ43pHW5NPql9R6SVuTT6pfUdOO4uCafKl1r6Ergmlvn1r6HC9JK/Jp9UvqT6S1+TS6pfUnV2O990Ut8+tfQn7mpb59a+hwfSevyKXZl9SV5U1+RS7MvEMpsd37kp8qfWvoPuSnyp9a+hw/SmvyKXZl4h6VYjkUuzLxEypsekp+T9J/mqdcfoZ+jtLl1OuP0POR8sMSvyUezLxGXplieRR7M/EXKbHofR6jyqnXH6D0epcqp1r6HnvTPE8ij2Z+IemWJ5FHsz8QynFmPo+brTgr2jZK+trGq0amM4ZqVpucowTdl6qaWXxKPt890ep/UsZdCSYk+I5zx090eofbZbl8yjpStl3kzdkc146b4o9TIWOmt3zA6HOyuTNKWNk9UvmQ8VLcvmB1I05WtdJEOlvkc77bPcvn9SPtkt0fn9QOi6X9Ri4c5ofbJbo/P6j7ZLcvmB1ODsN56vGDvbV24kkei+46fLn8jyWB4ZqUJucYwbat6ybsvgze9LsRyKPZl4jNl/jUsd77jhy5fIfccOXLqRwPS3Ecij2ZeIn0txHIo9mXiJlOO59xx5cupD7jjy5dSOF6W4jkUezLxD0txHIo9mXiGU47n3JHlvqRH3HHlvqRxPSzEcil2ZeIelmI5FLsy8QynHa+5Fy31Efci5b7JxfSzEcil2ZeIeleI5FLsy8Qz0cdr7kXL/AMv+5j9yf/J/lOP6V4jkUuzLxEelWI5FLsy8Qz0cdn7k/wDk/wApi+BX+ouo5HpViORS7MvEPSqvyKXZl4hno4633LLlrqZi+BpctdTOX6U1+RS7MvEQ/KivyaXZl9Rno44gANsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 24 日) — 50:47 </font></font><a href="https://youtube.com/watch?v=4Uqgsy3zrjs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=4Uqgsy3zrjs</font></font></a></p><p> 6
            years ago (Jan 24, 2019) — 50:47 <a href="https://youtube.com/watch?v=4Uqgsy3zrjs">https://youtube.com/watch?v=4Uqgsy3zrjs</a></p>
        <h2 id="summary-6"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本 MIT 课程 (18S097) 讲座讨论了“co.design”，一种协作设计方法。演讲者 David 使用范畴论将设计选择（底盘、电机、电池）建模为具有功能和资源的盒子。讲座介绍了这些组件之间的可行性关系（pro 函子）的概念，表示为预订或成本指标。目标是使用帕累托最优前沿找到最佳解决方案。该讲座是 David 和 Brendan Fong (Spifong) 教授的独立活动期 (IAP) 课程的一部分。</font></font></p><p>This MIT Course (18S097) lecture discusses “co.design,” a
            collaborative design approach. The speaker, David, uses category theory
            to model design choices (chassis, motor, battery) as boxes with
            functionalities and resources. The lecture introduces the concept of
            feasibility relationships (pro functors) between these components,
            represented as pre-orders or cost metrics. The goal is to find optimal
            solutions using Pareto optimal fronts. The lecture is part of an
            Independent Activities Period (IAP) course taught by David and Brendan
            Fong (Spifong).</p>
        <h2 id="introduction-to-codesign"><font style="vertical-align:inherit"><font style="vertical-align:inherit">协同设计简介</font></font></h2><h2>Introduction to Codesign</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，今天我要谈论的是协同设计。前几天我说过，这里的类别是要非常认真地对待“协同”这个词的定义。这不是协同设计；这是协作设计。协作设计的理念是，你试图设计一个机器人。</font></font></p><p>Okay, well, today I’m talking about co design. Which I’ve said the
            other day that category here is to take the word “co” very seriously
            under that definition. This is not co design; this is collaborative
            design. And the idea of collaborative design is you’re trying to design,
            say, a robot.</p>
        <h2 id="robot-design-example-and-resources"><font style="vertical-align:inherit"><font style="vertical-align:inherit">机器人设计实例和资源</font></font></h2><h2>Robot Design Example and
            Resources</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">作为设计师，您已决定需要三个团队：一个设计底盘，一个设计发动机，一个设计电池。底盘将提供……因此，对于每个团队，我们都有一堆盒子。机器人本身就是一个盒子，也许机器人是盒子的一部分，如果有人设计每个盒子，那么盒子就更大了，无论是机器人电池、发动机还是底盘。左边有一些东西，右边有一些东西。这些有时被称为功能。</font></font></p><p>And you’ve decided, as the designer, that you need three teams: one
            to design the chassis, one to design the motor, and one to design the
            battery. And that the chassis is going to provide… so for each, we have
            a bunch of boxes. The robot itself is a box, and maybe the robot is a
            part of them, and even bigger if someone’s designing each box, whether
            it’s the robot battery, the motor, and the chassis. Some number of
            things on the left and some number of things on the right. And these are
            sometimes called functionalities.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我还应该提到，我今天没有谈到的所有内容都是对 André FNC 作品的改编，他在这里待了一段时间，现在在苏黎世。他将这些称为功能。所以，我们正在设计一个——我们正在设计这个框和这个功能框，它们是提供的资源。所以，这个框将提供某些资源，它会阻止需求，我认为这是消耗或需要的资源。</font></font></p><p>I should also mention that everything I haven’t talked about today is
            an adaptation of work by André FNC, who was here for a while and now is
            in Zurich. He called these functionalities. So, you’ve got—we’re
            designing a—we’re designing this box and this box of functionalities,
            which are resources provided. So, this box is going to provide certain
            resources and it stops requirements, which I think about as resources
            consumed or required.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，例如，如果这个机器人需要 7 美元来制造，但最终能够以一定的速度承载一定的重量。底盘需要一定的扭矩、速度和资金，但我想它也能提供重量——它可以承载重量并实现一定的速度。电机将提供扭矩和速度，但它需要——它需要一定的重量。因此，电机和电池都需要由底盘承载。因此，对于更大的电池，您可以从电池组中获得更多的电流和电压，但现在您必须承载更多重量。因此，我们必须为此找到最佳设计。反馈回路使它变得更加困难。</font></font></p><p>Okay, so, if, for example, this robot here is going to require $7 to
            make, but in the end is going to be able to carry some weight at a
            certain velocity. And the chassis is going to require a supply of torque
            and speed and money, but is going to provide, I guess, weight—it’s going
            to carry weight and it’s going to carry out a velocity. The motor is
            going to provide torque and speed, but it’s going to require—it’s going
            to weigh something. And so, the motor and the battery are both need to
            be carried by the chassis. So, maybe for a bigger battery, you can get
            more current and more—a lot more current and more voltage out of that
            battery pack, but you now have to carry more. So, we have to find an
            optimal design for this. And the feedback loops are what makes it
            harder.</p>
        <h2 id="pareto-optimal-design-and-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">帕累托最优设计和预订</font></font></h2><h2>Pareto Optimal Design and
            Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，在协同设计领域，有人必须设计这些发动机、底盘等。我们将放大并继续用文字设计如何使电池工作，使发动机工作得最好。我们想要一个理论，说所有这些决定都可以组合成一个决定。所以，你要决定一个——决定做什么。例如，假设我在外面，我携带着一定重量，我以一定的速度行驶。</font></font></p><p>So, right, in the co design world, someone’s going to have to design
            each of these motors, etc., the chassis, etc. We’re going to zoom in and
            just keep designing in words how to make the battery work, the motor
            work best. And we want a theory that says that all those decisions can
            be composed together into a decision here. So, you want to decide
            one—decide what to do. So, for example, suppose I have on the outside
            there, I’m carrying a certain amount of weight and I’m going a certain
            velocity.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">也许这些是设计可能性。我能以这个速度获得这么多的重量。这已经很不错了。我甚至可以获得更快的速度。这就是我要走的路。重量更小，所以最好的显然是这个。我以高速度获得高重量，但我想画的是所谓的帕累托最优前沿。这些都没有比另一个更好或更差。这个重量更大，速度更小；这个速度更快，但重量更小。</font></font></p><p>Maybe these are design possibilities. I can get this much weight at
            this velocity. That’s pretty good. I can get even more velocity. That’s
            the way I’m going to go. A smaller weight, so the best thing is
            obviously this one. I get a high weight at a high velocity, but what I
            meant to draw was what’s called a Pareto optimal front. None of these
            are better or worse than the other. This one has more weight, less
            velocity; this has more velocity, but less weight.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这些被称为反链。如果你有一个偏序集，那么速度就形成了一个偏序集。它看起来像这样：一个偏序集。实数是正实数，但它可以是任何偏序集、任何偏序集，或者预序可以是速度预序，重量也是如此。所以，重量乘以速度也是一个预序。在预序中，速度乘以重量，它不再是线性顺序。所以我们有一些东西既不比其他东西好也不比其他东西差。</font></font></p><p>So these are called anti chains. If you have a poset, so velocity is
            forming a poset. It looks like this: a poset. The real numbers are the
            positive real numbers, but it could be any poset, any partially ordered
            set, or pre order could be velocity pre order, and so is weight. And so,
            weight times velocity is also a pre order. And in the pre order,
            velocity times weight, it’s not a linear order anymore. So we have
            certain things that are neither better nor worse than certain other
            things.</p>
        <h2 id="codesign-formalization-and-categorical-ideas"><font style="vertical-align:inherit"><font style="vertical-align:inherit">协同设计形式化和分类思想</font></font></h2><h2>Codesign
            Formalization and Categorical Ideas</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">协同设计的问题在于我们想要一个最优解。我们想知道哪些最优解是帕累托最优的，也就是帕累托曲线上的任何东西。给定一定数量的资金，就有各种可能。我们希望能够事后以经理或其他人员的身份做出一些决定，即使我们不知道是否如此——即使我们的模型没有区分出这些决定的优劣。</font></font></p><p>The problem of co design is that we want an optimal solution. We want
            to know what optimal solutions were Pareto optimal, meaning anything on
            that Pareto curve. There are possible given a given amount of money. We
            want some decision we can make the decision afterwards as a manager or
            something, even though we have no idea if either—even though our model
            has not distinguished any better or worse between these.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们想实现共同设计的情况。我们想将整个情况正规化。</font></font></p><p>So, the co design situation—well, we want to make this. We want to
            formalize this whole situation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，对此还有什么疑问吗？我们该如何做呢？</font></font></p><p>So, any questions about that? How we’re trying to do that?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，抱歉。回来。你说了。反链和反链。</font></font></p><p>Yeah, sorry. Back on. You said it. Anti chain and anti chains.</p>
        <h2 id="anti-chains-and-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">反连锁和预订</font></font></h2><h2>Anti-Chains and Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，在偏序集或预序中。昨晚见。我猜是子集 A 中的反链。NP。所以这里我的 P 是这个网格中的所有点。A 是相当乐观的东西，以至于 A 中的所有 a1、a2，如果 a1 小于 a2，那么 a1 就在 A 中。换句话说，没有两个不同的东西是可比的。所以这两个不能意味着互换。这两个不能一起成为反链，因为一个严格小于另一个。但任何有效的。所以我猜在这种有趣的实数情况下，它将是所有单调递减的曲线。</font></font></p><p>Oh, in a poset or a pre order. See you last night. An anti chain in a
            subset A, I guess. NP. So here’s my P is all the dots in this grid. A is
            the thing that’s pretty optimistic such that all a1,a2 in A, if a1
            is less than a2, then a1 is in A. In other words, no two different
            things are comparable. So these two could not mean interchange together.
            These two cannot be an anti chain together because one is strictly less
            than the other. But anything efficient. So I guess it’ll be all the
            monotonically decreasing curves in this kind of funny case of reals.</p>
        <h2 id="categorical-idea-and-parameterization"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴思想与参数化</font></font></h2><h2>Categorical Idea and
            Parameterization</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我将开始讨论整个事情，关于如何做到这一点以及分类思想的想法。因此，这些将是可行性关系，尤其是当 v 很酷时。我今天谈论的整个事情都是由不同的东西参数化的。你可以把整个讨论拿来。我将使用两个不同的 b。</font></font></p><p>Okay, so I’m going to start talking about what this whole thing is
            about how to do this and the idea of the categorical idea. So these are
            going to be feasibility relationships, especially where v is cool. The
            whole thing I’m talking about today is parameterized by different
            things. You can take the whole discussion. I’m going to use two
            different b’s.</p>
        <h2 id="feasibility-relationships-and-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可行性关系和类别</font></font></h2><h2>Feasibility
            Relationships and Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个是功率，一个是成本。但您也可以将两个 v 都视为类别集，然后我们再次进行整个讨论。在功率的情况下，我不会问
            ，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">而是</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">会问：我能否得到一个可以提供这么大扭矩和这么大速度的电机，以承受这么大的重量、这么大的电流、这么大的电压等？对于成本，我能否在给定这三个因素的情况下获得这么大扭矩和这么大速度的成本？
        </font></font></p><p>One is power and one is cost. But you can also take both v to be the
            category sets, and we run this whole discussion again. Instead of asking
            <em>so</em>, in the power case, I’m going to ask: Can I get a motor that
            can provide this much torque and this much speed for this much weight,
            this much current, this much voltage, etc.? Can I, for the via cost, get
            the cost of this much torque and this much speed given these three
            things?
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">成本将在每个盒子中内化，而不是发送到外部。并且，如果我以前等于步骤，它会说，“给定重量、电流等，扭矩的实现集是什么？”那么，我可以吗——它花费了多少钱——以及现在不同的费用有哪些方法？我们主要讨论的是，“我可以吗？这样做可行吗？”好吧，那又怎么样？所以，这个想法是，类别——类别将是电线，函子将是盒子，函子组合就像整个代码。</font></font></p><p>The cost would be kind of internalized in each of these boxes instead
            of being sent out to the world. And, set if I used to be equal to step,
            it would say, “What are the set of implementations of a torque—given a
            weight, a current, etc.?” So, can I—how much did it cost—and what are
            the ways to—are different fees today? We will mainly be talking about,
            “Can I? Is it feasible to…?” Okay, so what? So, the idea is that a
            Category—the categories are going to be the wires, and functors are
            going to be the boxes, and the functor composition is like the whole
            code.</p>
        <h2 id="categories-as-wires-and-functors-as-boxes"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴作为连线，函子作为盒子</font></font></h2><h2>Categories as Wires
            and Functors as Boxes</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这不是一个设计机器人组成和追踪各种我们还不一定知道的单词的问题，但是明天……</font></font></p><p>Is not a problem like designing the robot composition and trace all
            sorts of like words that we don’t necessarily know yet, but
            tomorrow…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。明天，Brendan 将讨论其余设置。我今天将讲解这些内容。他将讨论这是一个紧凑的封闭类别，以及在我们已经看到的任何幺半群类别中，我们可以如何绘制这些接线图。</font></font></p><p>All right. Tomorrow, Brendan will talk about the rest of the setup.
            I’m going to get through this stuff today. He’ll talk about how this is
            a compact closed category and how, in any monoidal category we’ve
            already seen, we can draw these wiring diagrams.</p>
        <h2 id="compact-closed-categories-and-feedback-loops"><font style="vertical-align:inherit"><font style="vertical-align:inherit">紧凑的封闭类别和反馈回路</font></font></h2><h2>Compact Closed
            Categories and Feedback Loops</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些反馈回路就是所谓的紧凑闭包。所以，明天，我猜这就像前馈函子组合，可以自由进行前馈协同设计，然后就是所谓的紧凑闭包结构。人们的反馈，增加人们……</font></font></p><p>And those feedback loops are what are called a compact closure. So,
            tomorrow, I guess this is like feed forward functor compositions, free
            for feed forward co design, and then what’s called compact closed
            structure. People’s feedback, adding people…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">问题太多了。有人记得 B 是什么吗？</font></font></p><p>This is so many questions. Does anyone remember what B is?</p>
        <h2 id="b-categories-and-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">B 类及预订</font></font></h2><h2>B-Categories and Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">大胆？什么是 B 类？所以，他有一堆点，一个点可以小于或等于另一个点。那个“小于或等于”是一个真/假问题。组合定律说，如果 A 小于 B，B 小于 C，那么 A 小于 C。恒等式是那一天总是小于 A。</font></font></p><p>Bold? What is a B category? So, he’s got a bunch of dots, and one can
            be less than or equal to another. That “less than or equal to” is a
            true/false question. And the composition law says that if A is less than
            B, and B is less than C, then A is less than C. And the identity is that
            that day is always less than A.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，在共同设计问题中，我说 V 类别将是电线。</font></font></p><p>So, in a co design problem, I said that the V categories are going to
            be the wires.</p>
        <h2 id="preorder-structures-and-feasibility"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预订结构和可行性</font></font></h2><h2>Preorder Structures and
            Feasibility</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这意味着后置集——那里的电线用后置集标记。那么，这些后置集是什么……我已经说得很清楚了。重量或预置——我总是混淆速度和重量——在这里是预置。速度乘以重量也是一个预置。所以，这个东西里的每根电线你都想有更多——小于的预置结构是 A 和 B 是否更好。“更好”意味着每当我有 A 时，如果有人要求 A、B，我就可以使用它。</font></font></p><p>And so, what this means is that post sets—that the wires there are
            labeled with post sets. So, what post set these… and I kind of already
            made that clear. That the weight or pre orders—I get always confuses
            velocity and weight—are pre orders here. Velocity times weight is also a
            pre order. So, every wire in this thing you want to have more—the pre
            order structure of the less than is whether it’s better to have A and B.
            And “better” means whenever I have A, I can use it if someone just asked
            for A, B.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我有 10 美元，你向我要 5 美元。我可以用我的 10 美元，然后提供你需要的 5 美元。所以，这里每根电线的预订单是……我们必须假设你的模型，10 瓦或 10 伏比 9 伏好。如果有人给你 10 美元，你就可以得到 9 美元。如果你不能接受一百万伏，如果你认为一百万伏不比 10 伏好，那么你就不会在它和一百万之间放一个小于符号。所以，你必须提前做出决定，什么可用于什么。</font></font></p><p>So, I have $10, and you ask me for five. I can use my 10 and supply
            you the five you need. So, the pre orders associated every wire here
            are… we have to assume for your model that having 10 watts or 10 volts
            is better than 9 volts. If whenever someone gives you 10, that you could
            get 9. If you can’t take a million volts, if you don’t think a million
            volts is better than 10 volts, then you don’t put a less than symbol
            between it and a million. So, you have to kind of make that decision
            upfront of what is usable for what.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果我能携带 100 磅，我也能携带 10 磅。你提前决定。如果那不是真的，那么你在这里做出不同的预订。因此，这些电线中的每一根都带有预订或节拍类别。换句话说，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是“满的”，那么这些电线中的每一根都带有一个后置集。如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是“成本”，那么这些电线中的每一根都带有一个度量空间，表示“如果我有 5 瓦，它会花费多少钱？”说，“获得 4 瓦的成本是多少？成本为零还是成本......？”好的。因此，每根电线都带有预订。现在我们需要告诉您预订是什么。</font></font></p><p>So, if I can carry 100 pounds, I can carry 10. You decide that
            upfront. If that’s not true, then you make a different pre order here.
            So, each of these wires is carrying a pre order or a beat category. So,
            in other words, if <em>v</em> is “full,” each one of those wires is
            carrying a post set. And if <em>v</em> is “cost,” each one of those
            wires is carrying a metric space that says, “If I had 5 watts, how much
            would it cost?” Say, “What’s the cost of getting 4 watts? Cost zero or
            cost…?” Okay. So, each wire is carrying a pre order. And now we need to
            tell you what a pre order is.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> pro 函子。谢谢大家。也许我应该先说这个。</font></font></p><p>A <em>b</em> pro functor. Thank you, guys. Maybe I should say this
            first.</p>
        <h2 id="profunctors-and-feasibility-relations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函数与可行性关系</font></font></h2><h2>Profunctors and
            Feasibility Relations</h2>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">你知道v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别的对立面</font><font style="vertical-align:inherit">是什么吗？给定一个
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别，它的对立面是什么？它的对立面是具有相同对象的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            类别。因此，如果你将类别或集合视为一堆点，它们之间有一些箭头，那么对立面就是相同的点，但箭头从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">或</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是关键。
        </font></font></p><p>Do you know what the opposite of a <em>v</em> category is? Given a
            <em>v</em> category, what’s its opposite? Its opposite is a <em>v</em>
            category with the same objects. So, if you think about a category or a
            set as a bunch of dots with some arrows between them, then the opposite
            is the same dots with the arrows backwards, from <em>x</em> to
            <em>y</em> or <em>p1</em> is key.
        </p>
        <h2 id="opposite-categories-and-profunctors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对立范畴和复制函数</font></font></h2><h2>Opposite Categories and
            Profunctors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你想知道</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> i </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> f* 是否取决于相同的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">sp</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和它的态射，除了一次反转。如果你把整个帖子转到这个方向，箭头就会转过来，或者你把你的类别转到箭头的方向。现在我终于可以告诉你什么是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> pro 函子了，从一个类别到另一个类别。它通常用一个斜线划掉。这并不意味着它只是箭头的名称。我称它为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">φ</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">表示可行性。所以，这将是一条线，这将是一条线，这将是一个我在那里说的盒子。什么是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> pro 函子？它是一个……所以，这是一个普通的旧函子。这是一个 pro 函子，但它们的意思是一样的。</font></font></p><p>So, if you want to know if <em>p</em>i<em>a</em>f* is it’s up to the
            same <em>sp</em> and it’s morphisms, other than once in this reversed.
            If you take your whole post at this turn, the arrows around, or you take
            your category, turn the arrows around. And now I’m finally ready to tell
            you what a <em>b</em> pro functor is, from one category to another. It’s
            often written with one of these slashes through it. It doesn’t mean it’s
            just a name of the arrow. And I’m calling it <em>φ</em> for feasibility.
            So, this will be a wire, and this will be a wire, say, and this will be
            a box I said there. And what is a <em>v</em> pro functor? It’s a… So,
            this is a regular old functor. This one’s a pro functor, but they mean
            the same.</p>
        <h2 id="unpacking-profunctors-and-feasibility"><font style="vertical-align:inherit"><font style="vertical-align:inherit">解析 Profunctor 和可行性</font></font></h2><h2>Unpacking Profunctors and
            Feasibility</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像这个家伙包装脂肪一样。</font></font></p><p>Like this guy packages up fat.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这是什么意思？这意味着对于每个……那么，什么？让我们来解开它。在范畴论中，我们通常有更好的解开方法。你写下这个非常简洁的定义，然后解开它，看看它在我的例子中意味着什么？所以，解开……答案是
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它是一个布尔值，是/否。那么，它可行吗？是/否。或者它可行吗？是的，成本为零。是的，成本为无穷大。它取决于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我们正在回答不同类型的问题。
        </font></font></p><p>So, what does that mean? It means that for each… So, what? Let’s
            unpack this. In category theory, we often have better unpacking things.
            You write this very concise definition, and then unpack it to see like,
            what does it mean in my case? So, unpacking… and the answer is a
            <em>b</em>, which is a Boolean, which is a yes/no. So, is it feasible?
            Yes/no. Or is it feasible? Yes, at a cost of zero. Yes, and a cost of
            infinity. It costs it for depending on <em>v</em>, we’re answering
            different types of questions.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，我们仍然以不同的方式回答问题。但问题仍然是可行性如何，或者我该怎么做？所以，我们说，给定</font><em><font style="vertical-align:inherit">q</font></em><font style="vertical-align:inherit">中的一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我们得到是/否、真/假。但还有整个“op”而不是 on，那是什么？也就是说，如果 p prime 小于 p，那么如果我说“你能花 20 美元给我一份两人份的晚餐吗？”，你说可以，那是可行的，然后我说“实际上，我只需要一人份的晚餐”？我们还能花 20 美元做到这一点吗？”如果我提出的要求较少，或者如果我想提供较少的东西，那么这总是可行的。我想提供一人份的晚餐，而不是两人份的晚餐。然后，如果我能用一些资源为两个人做这件事，我想我仍然可以为一个人做这件事。所以，如果 p prime 小于 p，或者如果 q 小于 q prime，无论哪种方式，给定 q 时 p 的可行性小于可行性 p prime。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>But still, we’re answering questions in different ways. But it’s
            still the question of how feasible is it, or how do I do it? So, we’re
            saying that given a <em>p</em> in a <em>q</em>, we got a yes/no,
            true/false. But there’s also this whole “op” thing and not on thing, so
            what’s that about? That says if p prime is less than p, so what if I
            said, “Can you give me dinner for two for $20?” and you said yes, that’s
            feasible, and then I said, “Actually, I just need dinner for one”? Can
            we still do that for $20?” That’s always going to be feasible if I’m
            asking for less requirements, or left, if I want to provide less stuff.
            I want to provide dinner for one instead of dinner for two. Then, if I
            could do it with some resources at that for two, I think I can still do
            it for one. So, if p prime is less than p, or if q is less than q prime,
            either way, the feasibility of p given q is less than feasibility p
            prime.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，正如你所看到的，p prime 在这边看起来更少，所以我在这里向后走，这就是为什么有 op，我在这里向前走。如果我能以 20 美元的价格提供两人晚餐，我也可以用 30 美元的价格提供一人晚餐。</font></font></p><p>So, as you can see, the p prime is like less on this side, so I’m
            going backwards here, which is why there’s the op, and I’m going
            forwards here. If I can provide dinner for two for $20, I can also
            provide dinner for one for $30.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，说得好。所以，这里的 B 就是今天讨论的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> v* 类别。它本身也是丰富的。所以，它也被称为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">quant</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> all，这意味着它具有所有关节，并且关节在张量上交换或分布。</font></font></p><p>Yeah, good point. So, here, B is what’s called, in today’s
            discussion, a <em>p</em>v* category. It’s also, which means it’s
            enriched in itself. So, it’s also what’s called a <em>quant</em> all,
            which means it has all joints, and that the joints commute or distribute
            across the tensor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这意味着……对于布尔值，你可以从许多不同的命题中取四个。你可以，向上取整，你知道，你有真、真、假、假、真、假、真、真。你可以取很多个来得到真。它的成本是三、五、七和二。你可以取它的最小值——这就是连接和成本。我们需要这样的属性：连接，比如 a 和 b 的某个集合上的连接，等于同一集合 a 和 b 上的连接。这就是你说连接分布的方式……抱歉，反正只是张量。</font></font></p><p>So, what that means is something like… for Booleans, you can take
            four of lots of different propositions. You can, floor up, you know, you
            have true, true, false, false, true, false, true, true. You can or that
            a lot to get true. It costs you have three, five, seven, and two. You
            can take the infimum of that—that’s the join and cost. And we need the
            property that that join, the joint over like some set of a and b, is
            equal to the join over that same set a and b. That’s how you say that
            join distributes over… and we’re sorry, just the tensor anyway.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，是的，B 本身就很丰富，而且任何一点都是如此。所有这些都在书中，但对于这门课，你真的不需要。我只会使用它，你会发现你可以使用它们来获得更多细节。请参阅这本书。</font></font></p><p>So, yes, B is enriched in itself, and any point. All this is in the
            book, but for this class, you don’t really need to. I’ll just use it,
            and you’ll see you can use them for more details. See the book.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，您对这个可行性想法还有什么疑问吗？或者为什么它不行？或者还有其他什么问题吗？</font></font></p><p>Okay, any questions about this feasibility idea, or why it’s off, or
            anything else?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。p 是否小于或等于 p 在 p op 中的时间？这里是，这是 p 在 p op 中小于 t 素数。所以，如果你想看，这里是 p 在 p op 中小于 p 素数。这里是 p 和 q 中小于 q 素数的 q。这实际上是我在说它们时使用的，就像它们都以相同的方式指向。如果你先对 p 求反，然后……</font></font></p><p>Yeah. Is the p time less than or equal to p that’s in p op? Where
            this is, this is, which is at p is less than t prime in p op. So, if you
            want to see, here’s p less than p prime in p op. Here’s q less than q
            prime in p and q. And this is really the one I’m kind of saying them
            using like they’re both directed in the same way. If you opposite p
            first, and…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，所以如果我先求 p 的反面，p 小于 p 素数。我这样写是因为对我来说比较简单。好吗？还有其他问题吗？我希望你们能和我页面上的邻居讨论这个问题。也许你可以这样做，看看你是否理解到目前为止我们正在尝试做什么以及我们计划如何使用这些 profunctor 来实现这一点。</font></font></p><p>yeah, so if I opposite p first, p is less than p prime. I wrote it
            this way because it’s easier for me. Okay? Other questions? I was hoping
            you guys could discuss this with a neighbor on my page. Maybe you can do
            that and see if you understand what’s going on so far in terms of what
            we’re trying to do and how we’re planning to do it using these
            profunctors.</p>
        <h2 id="profunctor-composition-and-feedback"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子组合与反馈</font></font></h2><h2>Profunctor Composition and
            Feedback</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，目标是将整个协同设计问题带到那里，并从 profunctor 的组成和反馈的角度来理解它。所以，看看你是否明白这将如何工作。这到底是怎么回事？找个人谈谈，弄清楚发生了什么。</font></font></p><p>The goal, then, is to take this whole co design problem there and
            understand it in terms of compositions and feedback of profunctors. So,
            see if you understand how that’s going to work. What is this all about?
            Talk to somebody and figure out what’s going on.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。还有问题吗？</font></font></p><p>Okay. Any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我有一些问题。我们迪亚兹·菲德尔的人很快就会谈论这些，即：</font></font></p><p>I have some questions. People of our Diaz Fidel soon to talk about,
            namely:</p>
        <h2 id="questions-on-profunctors-and-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于 profunctor 和类别的问题</font></font></h2><h2>Questions on
            Profunctors and Categories</h2>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里左右两边为什么有这么多字符串？</font></font></p>
            </li><li>
                <p>Why are there so many strings here on the left and
                    right?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么这里只有一件事，这里只有一件事？</font></font></p>
            </li><li>
                <p>And why is there only one thing here, one thing here?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这张图片和这个有什么关系？</font></font></p>
            </li><li>
                <p>What does this picture have to do with it?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个问题是：profunctor 到底如何成为一个类别？但这些是相互关联的。</font></font></p>
            </li><li>
                <p>Another question is: How exactly is a profunctor a category? But
                    those have to do with each other.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">也许：如果这些函子是……会怎样？</font></font></p>
            </li><li>
                <p>And maybe: What if these functors are…?</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其他问题：什么是 profunctor？</font></font></p>
            </li><li>
                <p>Other questions: What’s a profunctor?</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">profunctor 是这样的：没有从 P 到 Q 的函子的 profunctor。事实上，你不是从 P 到 Q，而是从 P 到 P，并且箭筒得到真/假。</font></font></p><p>A profunctor is this: a profunctor without the functor from P to Q.
            And the fact that instead of going from P to Q, you’re going from P to P
            and a quiver getting a true/false.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Other questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。V 类是什么？所以，你可能错过了一些早期的课程。</font></font></p><p>Yes. What’s in a V category? So, you may have missed some earlier
            classes.</p>
        <h2 id="v-categories-and-monoidal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">V 类别和幺半类别</font></font></h2><h2>V-Categories and Monoidal
            Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是真的吗？</font></font></p><p>Is that true?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。这些类别是在某个星期三讨论的。让我们回顾一下。现在，我们假设它们又一次被讨论。</font></font></p><p>Okay. The categories were discussed on a certain Wednesday. Let’s
            review them. And now, let’s say they are again.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，所以 V 是一个幺半群，一个对称幺半群偏序集，或者一个对称幺半群类别。AV 类别包括：</font></font></p><p>Oh, so V is a monoidal, a symmetric monoidal poset, or a symmetric
            monoidal category. A V category consists of:</p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一组对象，a，b，类别等。假设是一组对象。</font></font></p>
            </li><li>
                <p>A set of objects, a, b, categories, etc. Let’s say a set of
                    objects.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于所有作为对象的 P1 和 P2（我将把它们画成点），以及对于所有作为 V 元素的 P1、P2（因此，V 的布尔值，这是是/否：P1 是否小于或等于 P2）。</font></font></p>
            </li><li>
                <p>For all P1 and P2 that are objects (I’m going to draw these as
                    dots), and for all P1,P2 that are an element of V (so, V’s
                    boolean, this is the yes/no: is P1 less than or equal to P2 or
                    not).</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么条件就是：</font></font></p><p>Then the conditions are:</p>
        <ul>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">P 的 AP 成立。</font></font></p>
            </li><li>
                <p>A P of P holds.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">或者 V 的顶部元素小于或等于 S。</font></font></p>
            </li><li>
                <p>Or the top element of V is less than or equal to S.</p>
            </li>
        </ul>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后我们就知道了。你知道它大于 100。你知道。</font></font></p><p>Then we know it all. You know it’s greater than 100. You know it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里，V 是 P3 小于 V。但是我们绘制它们的方式（更容易理解......这应该做得正确）是画一堆点。</font></font></p><p>So, here, V is P3 is less than V. But the way we draw them (what’s
            easier coming… this should have been done right) is we draw a bunch of
            dots.</p>
        <h2 id="hostage-diagrams-and-profunctors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">人质图和 profunctor</font></font></h2><h2>Hostage Diagrams and
            Profunctors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这叫做哈斯图。P，这里是 P 的所有对象。然后我们画箭头来表示一个小于另一个，并且如果有一个箭头序列或从一个到另一个的路径，则一个确实小于另一个。</font></font></p><p>This is called a Hasse diagram. P, and here are all the objects of P.
            And then we draw arrows to indicate that one is less than another, and
            one is really less than another if there’s a sequence of arrows or a
            path from one to the other.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这里……</font></font></p><p>So, here…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，保留它并用 E 的元素标记它们。是的，它们实际上是用元素标记的。在碗状函数器中的函数器中，元素被标记为存在或不存在。如果存在，则认为是真的；如果不存在，则认为是假的。在成本类别中的成本函数器中，我用元素数量标记它们。成本的成本是 0 到无穷大，所以我可能会说 2、1、4、3、6。因此从这里到这里的成本是 10，是 9，因为我可以走这条路。所以这是从那里到那里的最低成本。好的。</font></font></p><p>Yeah, keep it and label them by elements of E. Yeah, these are really
            labeled by elements. In a profunctor in a bowl profunctor, elements are
            labeled as present or absent. If present, it’s considered true; if
            absent, it’s considered false. In a cost profunctor in a cost category,
            I label them by a number of elements. The cost of the cost is 0 through
            infinity, and so I might say 2, 1, 4, 3, 6. And so the cost of getting
            from here to here is 10, is 9, because I could take this route. So it’s
            the minimal cost to get from there. Okay.</p>
        <h2 id="examples-of-profunctors-and-collages"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Profunctor 和 Collage 的示例</font></font></h2><h2>Examples of Profunctors
            and Collages</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在 bull profunctor 中，这里有一个 bull profunctor 的示例。您可以根据所谓的拼贴画来绘制 bull profunctor。这是从 X 到 Y 的某个 profunctor。换句话说，它接受一个 X 和一个 Y 并生成一个布尔值。现在，我们到了这里。我接受了 X 和一个 Y 并生成了一个成本。</font></font></p><p>So, in a bull profunctor, here’s an example of a bull profunctor. You
            can draw a bull profunctor in terms of what’s called its collage. This
            is some profunctor from X to Y. So, in other words, it takes an X and a
            Y and produces a boolean. Now, we’re here. I’ve taken an X and a Y and
            produced a cost.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，所以这里发生的事情是，对于 X 的每个元素和 Y 的每个元素，我必须告诉你是或否，因为这就是 profunctor 的作用。如果我后退 X 或在 Y 中向前移动，是必须保持是。这就是它所说的。如果我后退 X 或在 Y 中向前移动，并且我在多次是之后处于是...</font></font></p><p>Okay, so what’s going on here is for every element of X and element
            of Y, I have to tell you yes or no, because that’s what a profunctor is.
            And if I back up an X or move forward in Y, yeses have to remain yeses.
            That’s what this says. If I back up in X or move forward in Y, and I was
            at a yes, after many yeses…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，拼贴画的画面是你画的箭头。它有点像整个 profunctor 的人质图。如果你画一个箭头表示从 E 到 C 是肯定的，那么从 S 到 A 也是肯定的。那么，如果从 S 到 A 是肯定的，那么从 S 到 C 也是肯定的吗？是的。</font></font></p><p>So, the picture of the collage is you draw an arrow. It’s kind of
            like a hostage diagram for the whole profunctor. If you draw an arrow to
            say that there is a yes from E to C, there’s a yes from S to A. So, if
            there’s a yes from S to A, is there a yes from S to C? Yes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，现在我们可以把它写下来。所以，这是实际的 profunctor，φ，或者其他什么。策略 X 是北、西、东和南。这个……有没有从北到 A 的路径？答案是肯定或否定。没有从北到 A 的路径，因为要从一个到达另一个，我要么需要一个箭头，要么需要一个半箭头。我需要通过这个，说一个箭头，然后通过那个路径，这样它就会在回溯和向前跟踪下关闭。</font></font></p><p>So, now we can write this down. So, here’s the actual profunctor, φ,
            or whatever. Policy X is north, west, east, and south. This… and is
            there one from north to A? It’s a heavy yes or no. There is no way to
            get from north to A, because to get from one to another, I either need
            an arrow where I need a half, basically. I need to pass through this
            one, said an arrow, then a path through that one, that way it’ll be
            closed under backtracking here and forward tracking there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，有没有从北到 A 的路线？没有。错误。我会用这个符号表示错误。相反的符号表示正确。有没有从北到 B 的路线？什么？好的。在哪里？哪里有从北到 C 的路线？没有。你知道……是的。从西边……西边，西边唯一能到达任何地方的路线是经过，试着经过北边。所以，这看起来完全一样。错误，错误，错误，错误，正确。</font></font></p><p>So, is there one from north to A? No.&nbsp;False. I’ll write that symbol
            for false. And the opposite for true. Is there one from north to B?
            What? Okay. Where? Where is there one, north to C? No.&nbsp;You know… yes.
            From west… West, the only way west can get to anything is by going
            through try going through north. So, this looks exactly the same. False,
            false, false, false, true.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">东能到 A 吗？好的，让我们……让我填一下。所以，东到 B 和 C，但不能到 A，是的，D，是的，E，南到……除了你之外的所有地方，对不起。我不认为我现在被拘留了。除了你之外的所有地方，好吗？所以，你想知道……哦，什么去吃？对不起。东西要回家，对不起。他去了 D。所以，我们需要检查的是，如果我在这个表中的某个地方输入一个真值，然后我去 Y，我会在那个表中得到一个真值，那个位置是 Alice。</font></font></p><p>East can east get to A? Okay, let’s… so let me fill this out for a
            second. So, east goes to B and C, but not A, and yes, D, and yes, E, and
            south goes to… Everything except look sorry. I don’t think I’m in
            custody right now. Everything except for you, okay? So, you want to
            know… oh, what goes to eat? Sorry. Stuff goes to go home, sorry. He’s
            goes D. So, the thing that we need to check is if I put a true somewhere
            in this table, and I go up in Y, I’ll have a true in that table and that
            spot to Alice.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想我现在就回答你的问题了。所以，如果你……你可以在这个表中的任何地方检查，找到一个真值，如果你可以向上移动并说明原因，它将保持为真，或者如果你在 X 中返回，它将保持为真。这样做的原因是，如果有一条从某处到另一处的路径，而某物在当时，那么在更远的地方仍然有一条路径。我想我只是向上移动然后穿过。</font></font></p><p>I think I’m answering your question right now. So, if you… you can
            check anywhere in this table, find a true, and if you can go up and why,
            it’ll remain true, or if you go back in X, it will remain true. And the
            reason that works is because if there was a path from something to
            somewhere else, and something’s back then, there’s still a path in that
            further back thing. I just go up and then across, I guess.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，是的，是的。似乎这里没有关闭，因为所有箭头都朝着相同的路线，就像它们想要去的方向一样。我们只是非常直观地绘制图片，但不知何故这个被选中了。原因是因为被选中的是：这有效吗？对不起。我们要回答的是：这……有路吗？通过向后走可以延长路径，通过向前走可以延长路径。</font></font></p><p>So, yeah, yeah. It seems like there’s no off here because all the
            arrows are going the same route, like in the direction they like to go.
            And we’re just drawing pictures as very intuitive, and yet somehow this
            one’s opted. And the reason is because the thing that’s being opted is:
            does this work? Sorry. The thing we’re answering is: does this… is there
            a path? And paths get extended by going backwards here, and paths get
            extended by going forwards there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">只有通过向后追溯才能帮助确定路径的存在。是的，这是一个证明函子，而不是函子。证明函子是函子——胡说，而不是——为什么是从 X 操作乘以 Y——拉？所​​以，发生的事情是，我实际上是把这个东西的 2 2 东西图向上，然后这个东西向前乘以，得到 20 个节点，然后转到一个小的胡说八道，是的，没有东西。这就是秘密拥有的，就像，这就是它。从那个点看。</font></font></p><p>The existence of a path is only helped by going backwards. Yeah, this
            is a pro functor and not a functor. And a proof functor is a
            functor—bull, and not—why is from X op times Y—pull? And so, what’s
            happening is I’m actually taking a 2 2 thing diagram of this thing up,
            and this thing’s forward multiplying, getting 20 nodes, and then going
            to a little bull, yes no thing. And that’s what secretly have, like,
            that’s what this is. It looks like from that point.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">谢谢。当然。现在，有人想知道函子是什么。此外，函子是一种专业函子。函子是一种专业函子，你可以把它画成拼贴画，或者这是它的爪子，这样每个人……你可以把它画成这些点中的每一个都只有一个地方可以去。所以，这里，他有两个地方可以去。这个西边，虽然看起来没有地方可去，但确实有一个 E。</font></font></p><p>Thanks. Sure. Now, someone wanted to know what a functor is. Also, a
            functor is a kind of pro functor. A functor is a pro functor, which you
            can draw as a collage, or this is the claws of it, such that everyone…
            you could draw it where every one of these dots has exactly one place to
            go. So, here, this he had two places to go. This west, although it looks
            like it has no places to go, does have an E.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我也可以很容易地画出另一个这样的箭头，那意味着同样的拼贴画，只要它像这样通勤并拉动所有可以拉动的东西。你能……做……所以，抛开这个不谈，某事……某事……profunctor 是 functor 的泛化。functor 将域中的所有内容映射到陪域中的某个内容。然而，profunctor 允许你将</font><font style="vertical-align:inherit">
            域中的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">某些元素映射到陪域中的</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">某些</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">元素，不一定是所有元素。</font></font></p><p>So, I could have just as easily drawn another arrow like this, and
            that would have meant the same collage, as long as it’s like this
            commutes and pull everything that could. Can you… does… So, putting that
            aside, something that… something… A profunctor is a generalization of a
            functor. A functor maps everything in the domain to something in the
            codomain. A profunctor, however, allows you to map <em>some</em>
            elements of the domain to <em>some</em> elements of the codomain, not
            necessarily everything.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个 profunctor。您可能还想将域的两个特定子集相互映射；这也是一个 profunctor。所以，一个函子，一个 pro 函子，函子——如果您可以重新绘制它，其中每个源拓扑都只有一个地方可以去——这就是您在说我们一直在绘制函子时所想的，因为这里的一切都只有一个地方可以去。我会说是的，如果拼贴画看起来像那样，那么您的 pro 函子就是函子的泛化，或者来自函子。</font></font></p><p>This is a profunctor. You might also want to map two specific subsets
            of the domain to each other; that’s also a profunctor. So, a functor, a
            pro functor, the functor—if you could redraw it where every one of these
            source topos had exactly one place to go—which is what you were thinking
            of when you said we’ve been drawing functors as everything here has one
            place to go. And I would say yes, if the collage looks like that, then
            your pro functor is a generalization of, or is coming from, a
            functor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">每个函子都是一种可以提供的函子，对吧？就好像如果我可以创建一个结尾，是否意味着我也可以创建一个 S？这些就是我提供的，这些就是我需要的，对吧？所以它说如果你给我一个 E，我就可以给你一个 A。我可以给你一个，对不起，一个微不足道的 I，如果你给我一个 B 或 C，我可以给你一个 biggie。所以，顺序和鸡蛋——如果 x1 小于 x2，那么我宁愿要这个而不是这个。是的，我宁愿要西本身。所以，如果我可以使用 C 得到西，如果我可以使用 C 得到东，那么我也可以使用 B 得到南。我在一开始就说过了。如果我可以花 20 美元吃双人晚餐，我就可以花 20 美元或 30 美元吃一人晚餐。</font></font></p><p>Every functor is a kind of pro functor, can be provided, right? It’s
            like if I—if I can make an end—does that mean I can also make an S?
            These are what I’m providing, and these are what I need, right? And so
            it says I can give you an A if you give me an E. I can give you an I’m
            sorry, a little meager I, I can give you a biggie if you give me a B or
            C. So, the order and eggs—if x1 is less than x2, then I would rather
            have this than this. Yep, I’d rather have west itself. And so, if I can
            get a west using if I can get it east using a C, then I can also get a
            south using B. Which I said in the beginning. If I can get dinner for
            two for $20, I can get dinner for one for $20 or for $30.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Other questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。所有这些，左侧是功能，右侧映射到需求。</font></font></p><p>Yeah. And all these guys, the left hand side is functionality, and
            the right hand side maps into requirements.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Other questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里的 X 和 Y 是 V 类别。AV 类别是这样的图表，其中箭头已用 V 的元素标记。V 知道如何通过所谓的张量进行组合。</font></font></p><p>X and Y here are V categories. A V category is a diagram like this,
            where the arrows have been labeled with elements of V. The V knows how
            to compose by what’s called tensor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Other questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我知道我有 15 分钟，有点浪费时间，所以我本来想让你算出这个的概况和表格，但它已经在书上了，所以我猜。但举个例子，从 C 到 Z 的距离是多少？从 C 到 Z，我觉得这有点奇怪。我想可能是 17。哦，是的。从 C 到 Y 查一下，70。是的，有一种方法可以从 C 到 Y，花费 311。</font></font></p><p>I see I have 15 minutes, and in kind of a waste, so I was going to
            have you work out the profile, the table for this one, but it’s in the
            book already, so I guess. But just for example, what’s the distance from
            C to Z? C to Z, I think that’s kind of odd. I think it’s probably 17.
            Oh, yeah. Look up from C to Y, 70. Yeah, there’s a way to get from C to
            Y that costs 311.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我认为是 18。但你也可以通过 3、5、9 到达 C 和 Y，也就是 17，这样更便宜。所以，距离——如果我要写出这个表格，把 C、A、B、C 放在这边，Y、Z 放在那边——我会把 4、C、Y 写成最小距离。这可以用矩阵乘法来计算，矩阵乘法是——好吧，我想我马上就会谈论 pro functor 组合。</font></font></p><p>And for which I think is 18. But you could also get from C to Y by
            going 3, 5, 9, which is 17, which is cheaper. So, the distance—if I was
            going to write out this table and put C’s, A, B, C over here next to Y,
            Z over there—I would put 4, C, Y, the minimum distance. And that can be
            calculated with matrix multiplication, where the matrix multiplication
            is—well, I guess I’ll talk about pro functor composition in just a
            second.</p>
        <h2 id="profunctor-composition-and-matrix-multiplication"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子组合与矩阵乘法</font></font></h2><h2>Profunctor
            Composition and Matrix Multiplication</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这涉及到一种矩阵乘法。但只要写下这个家伙，就可以理解 pro 函子本身。我应该把这个留给书本，布伦丹。我们上次或几次之前讨论过这个问题。有一种方法可以通过乘以矩阵来计算出从 C 到 Y 的最快距离是 17。</font></font></p><p>And that involves a kind of matrix multiplication. But just the pro
            functor itself can be understood by writing down this guy. I should
            leave that to the book Brendan. We talked about this last time, or a
            couple of times ago. There’s a way to figure out that the fastest
            distance from C to Y is 17 by multiplying matrices.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，在谈论这个之前，我刚刚提到过，profunctor 是一种被抽取的……呃，是一种 profunctor。我们知道 Brendan 说过，范畴之间的函子是单调映射。</font></font></p><p>Oh, before I talk about that, I just mentioned that a profunctor is a
            kind of pumped…er, is a kind of profunctor. And we know that Brendan
            said that a functor between categories is a monotone map.</p>
        <h2 id="monotone-maps-and-profunctors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">单调映射和函数子</font></font></h2><h2>Monotone Maps and
            Profunctors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，任何单调映射都应该是一个衍生函子。</font></font></p><p>So, any monotone map should be a profunctor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我有一个单调映射，例如，一个 N 乘以 M 的有机体是一个完整的类别，其顺序为 5 小于 6。并且有一个映射将两个自然数相加。这是单调的，因为如果 a 小于 a 素数且 b 小于 b 素数，那么 a 加 b 小于 a 素数加 b 素数。所以，这是一个单调映射。所以它应该涉及某种 profunctor。它是什么 profunctor？它是取这个 N 乘 N 网格中的点并返回它们的总和的 profunctor。当然。</font></font></p><p>So, if I have a monotone map, for example, an N times M organism is a
            full category where the order is like 5 is less than 6. And there’s a
            map that takes two natural numbers and adds them. And that’s monotonic
            because if a is less than a prime and b is less than b prime, then a
            plus b is less than a prime plus b prime. So, that’s a monotonic map.
            And so it should involve some kind of profunctor. And what profunctor is
            it? It’s the profunctor that takes the dots in this N by N grid and
            returns their sum. Of course.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像我之前说的，那个 profunctor，好吧。所以，你需要这么多点。但是，正如你所见，箭头向上和向右。那么，什么样的函子……如果这是提供的功能，这是一种资源，这有点像你用两个自然数画一个框。你给定一个自然数提供两个自然数。这有点像你切蛋糕，或者其他什么。也许我妈妈会说，“我只需要交税什么的。”所以，她要交税。所以，她会交五，她会交二和二，然后说，“就这样。”然后她会把税平均分给它。所以，只要……</font></font></p><p>And that profunctor, as I said before, okay. So, you’d need anywhere
            near this many dots. But, as you can see, the arrows go up and right.
            And so, what sort of functor…if this is a functionality provided and
            this is a resource, it’s kind of like you’re drawing a box with two
            natural numbers. And you’re providing two natural numbers given a
            natural number. And it’s kind of like you’re cutting, cutting the cake,
            or whatever. With…and maybe my mom would say, like, “All I get a tax or
            something.” So, she gets a tax. So, it’s just that she’ll give in like
            five, she’ll give a two and a two and say, “There you go.” And she’ll
            cut it evenly with the tax. So, as long as…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，profunctor 表示，如果我将两个坐标相加，其和小于这个和，则这里的一个点有一条通往这里的一个点的路径。当我们添加权重时，我会使用这个，我会使用这里的那个框。</font></font></p><p>So, the profunctor says that a point here has a path to a point here
            if when I add the two coordinates, it’s less than this sum. And I use
            that, I use that box over here when we added weights.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我告诉过你我在设计一个机器人，我们需要设计底盘、发动机和电池。但是，我暗自想……我有这两个优点，你可能会想，“为什么它们会出现在图中？我为什么不谈论它们？”而它们是来自 V 函子的单调映射的 profunctor。是的。</font></font></p><p>So, I told you I was designing a robot, and we need to design the
            chassis, the motor, and the battery. But, I secretly have…I had these
            two pluses that you might have thought, like, “Why are they in the
            picture? And why didn’t I talk about them?” While they are profunctors
            that are just coming from monotone maps from V functors. And yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，可能是我们……我们可以承担比我们说的同一周更多的责任，你有税。是的。我没有正式定义。我有。好的。是的。这是一个正式的定义，每当有人说“函子”或“类别”或“profunctor”而不提到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">时，它们总是分别意味着集合类别或集合profunctor？函子集合是一个中间类别。是的，从来没有告诉过你关于幺半群类别。你还没有告诉你中间类别是n阶。下次是约翰·格雷厄姆吗？好的，或者至少那是——它在书里。我今天只谈论
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是幺半群预序的原因是因为我们到目前为止只谈论了这些。但我给你一个提示，这可以扩展到那个。还有其他问题吗？好的。
        </font></font></p><p>So, it could be that we are…we can carry even more weight than then
            we say the same week that you have a tax. Yeah. I’m not defined
            formally. I did. Okay. Yeah. Is it a formal definition that, whenever
            someone says “functor” or “category” or “profunctor” without mentioning
            the <em>v</em>, they always mean a set category or a set profunctor
            respectively? A functor set is a middle category. And, yeah, never told
            you about monoidal category. You haven’t told you in the middle
            categories are order n.&nbsp;Is John Graham everyone next time? Okay, or at
            least that’s the—it’s in the book. The reason I’m only talking about
            <em>b</em> being a monoidal pre order today is because that’s all we’ve
            talked about so far. But I’m giving you a hint that this can be extended
            to that. Other questions? Okay.
        </p>
        <h2 id="profunctor-composition-and-semantics"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子组合与语义</font></font></h2><h2>Profunctor Composition and
            Semantics</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，pro 函子可以组合，我想这就是我要讨论的内容。问答：从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的 pro 函子或盒子设计问题。因此，我在那里有一些可行性关系，在那里有一些大小能力，即可行性关系。我需要将它们组合在一起。从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的可行性关系。因此，给定一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我可以说这是可行的。给定一个
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我可以说这是否可行。现在我想知道，给定一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这是否可行？那么，它应该是什么呢？
        </font></font></p><p>So, pro functors can be composed, and I guess that’s what I’ll talk
            about. Q and A: pro functor or box design problems from <em>c</em> to
            <em>r</em>. So, I have some feasibility relationship there and some size
            ability, a feasibility relationship there. I need to compose them
            together. Feasibility relationship from <em>p</em> to <em>r</em>. So,
            given a <em>p</em> <em>q</em>, I can say that’s feasible. Given a
            <em>q</em> <em>r</em>, I can say whether that’s feasible or not. And now
            I want to know, given a <em>p</em> <em>r</em>, is that feasible? And so,
            what should it be?
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，如果我想取</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">或</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f并将其与</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">组合
            </font><font style="vertical-align:inherit">，然后问一个问题，从那个角度看</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是否
            可行？如果你考虑语义，你大概可以猜出它应该是什么，比如这意味着什么？好吧，这意味着他们发现了一些——我们可以找到一些</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
            ，使得</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">e</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">表示给定</font><em><font style="vertical-align:inherit">q时</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">e</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是可行的</font><font style="vertical-align:inherit">，而</font><em><font style="vertical-align:inherit">s</font></em><font style="vertical-align:inherit">表示给定</font><em><font style="vertical-align:inherit">q时</font></em><em><font style="vertical-align:inherit">e</font></em><font style="vertical-align:inherit">是可行的</font><font style="vertical-align:inherit">。现在，这个——这个和在哪里发生？发生在布尔值中。这是一个布尔值，可行性，是或否。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So, if I want to take <em>p</em> or <em>f</em> and compose it with
            <em>s</em> and then ask the question, is a <em>p</em> <em>r</em>
            feasible in that angle or not? You can kind of guess what it should be
            if you think about the semantics, like what does this mean? Well, it
            means that they found some—we can find some <em>q</em> and <em>q</em>
            such that <em>e</em> says that <em>e</em> is feasible given <em>q</em>’s
            and <em>s</em> said that <em>e</em> was feasible given <em>q</em>. Now,
            this—where does this and taking place? Is taking place in Boolean.
            That’s a Boolean, and feasibility, yes no.
        </p>
        <h2 id="quantalls-and-associativity"><font style="vertical-align:inherit"><font style="vertical-align:inherit">量子和结合律</font></font></h2><h2>Quantalls and Associativity</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是布尔值是或否。这是布尔值的“与”，这是“或”。</font></font></p><p>That’s a Boolean yes no. This is the and, and this is the or in
            Boolean.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我说我们需要一个量化全部，这意味着我们有所有这些订单，它们分布。现在我们用我们手中的大或来计算复合可行性。是的。他的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">被认为是什么？是的，他是一个交换或对称的单半群预序，其连接分布在张量上。量化全部。同样，这在书中写明了什么是量化全部以及为什么需要它。我们需要，这样当你得到分布时，我们就可以写出这个符号，这样组合就是结合的。</font></font></p><p>So, I said that we needed a quant all, which means we have all these
            orders, and they distribute. And now we’re using our big or in our hand
            to compute the composite feasibility. Yeah. His <em>b</em> be considered
            to be what? Yes, he is a commutative or symmetric monoidal pre order
            with joins that distribute over tensor. A quant all. And again, this is
            written in the book on what a quant all it is and why you need it. We
            need so we can write this symbol when you get distributes over, and so
            that composition is associative.</p>
        <h2 id="identity-profunctors-and-feasibility"><font style="vertical-align:inherit"><font style="vertical-align:inherit">恒等函子和可行性</font></font></h2><h2>Identity Profunctors and
            Feasibility</h2>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，你认为p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的函子的恒等式是什么
            </font><font style="vertical-align:inherit">？这是一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">r</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">或到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子。你认为恒等式 pro 函子是什么？每次你秘密看到一个字符串时，那里就有一个恒等式 pro 函子。那么，它是什么？他必须确定
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的恒等式，因为 pro 函子必须能够确定，给定一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            和一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">素数，是说是还是否。
        </font></font></p><p>So, what do you think the identities will be for a functor on
            <em>p</em>? This is a functor from <em>p</em> times <em>p</em> to
            <em>r</em> or to <em>b</em>. What do you think is the identity pro
            functor? Every time you see a string secretly, there’s an identity pro
            functor sitting there. So, what is it? He has to decide identity on
            <em>p</em> as a pro functor has to be able to decide, given a <em>p</em>
            and a <em>p</em> prime, whether to say yes or no.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它可能总是正确的。其他想法，但它们可能不正确，因为是的，p 小于 p 素数。但是 p 怎么写呢？是的，p，p，p。如果你检查它，就会得到正确的答案。所以，这些都是可行性关系。我可以写博客吗？给定一个区块，我可以提供这个吗？</font></font></p><p>It could say always true. Other ideas, but they might not be correct
            because then, yes, p is less than p prime. But how does p write that?
            Yes, p, p, p.&nbsp;And this is the one that, if you check it, will give you
            the right answer. So, these are all up feasibility relations. Can I make
            a blog? Given a block, can I provide this?</p>
        <h2 id="generalization-of-profunctors-and-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">仿函子和函子的泛化</font></font></h2><h2>Generalization of
            Profunctors and Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">鉴于此，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">本身有一个概念，即给定六瓦，它是否可以提供五瓦？这就是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。因此，一般来说，对于任何</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">类别，比如该类别，它都是自己的启动子。它有一个身份函数器。它会问：有没有办法从这里到这里？成本是多少？这可能有点太远了，但我们可以在五分钟后与我讨论这个问题。</font></font></p><p>Given this, and <em>p</em> itself has a notion of whether it can
            provide five watts given six? That was what <em>p</em> is. So, in
            general, for any <em>V</em> category, like that category, it is its own
            promoter. It has an identity profunctor. It asks: Is there a way to get
            from here to here? What’s the cost? That might be a bit too far, but we
            can talk to me out in five minutes about that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我接下来要做的要么是写出结合律的证明，要么是因为结合律，当我做</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> SI 时，如果我不知道其他字母，我就必须做两次。而“或”基本上是进来并与结尾等进行交互。我可以向你展示，或者我只是……我们可以提前结束。或者，有什么问题吗？</font></font></p><p>So, what I had to do next was either write out the proof of
            associativity, or, because associativity, when I do a <em>V</em>SI, and
            I don’t know some other letter, I’m going to have to do this twice. And
            the “or” is basically coming in and interacting with the ends and stuff
            like that. I could show you that, or I just… we could just end early.
            Or, any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">下次，布伦丹将讨论反馈，这将完成该图表。</font></font></p><p>Next time, Brendan is going to talk about feedback, which will
            complete this diagram.</p>
        <h2 id="feedback-and-completion-of-diagram"><font style="vertical-align:inherit"><font style="vertical-align:inherit">反馈并完成图表</font></font></h2><h2>Feedback and Completion of
            Diagram</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让这个图表完全易于理解，就像它的语义一样。它将说明我们将在每个图表中放置一个 profunctor，并且我们将在看到前向跟踪时将它们组合起来。现在，我们将在看到反馈时放置所谓的反馈或跟踪结构。Brendan，下次，我们将讨论这到底是什么。但还有其他问题吗？</font></font></p><p>Make this diagram completely understandable, like the semantics of
            it. It’s going to say we’re going to put a profunctor in each of these,
            and we’re going to compose them whenever we see forward tracking. Now,
            we’re going to put what it’s called this feedback or trace structure
            whenever we see feedback. Brendan, next time, we’ll discuss what this is
            all about. But other any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，没错。所以，你可以看到事情是否可行，事情是否比其他事情更重要，等等。</font></font></p><p>Yeah, right. So, you can see whether things are feasible, whether
            things are more than other things, and whatever.</p>
        <h2 id="andres-cycle-and-boolean-profunctors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">安德烈循环和布尔函子</font></font></h2><h2>Andre’s Cycle and Boolean
            Profunctors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，是什么？北卡罗莱纳大学的计算机科学专业学生 Andrea 发明了这一切？整个想法。他不知道布尔函数。他只是以他作为工程师认为最合理的方式完成了所有这些工作。结果发现，这些正是布尔函数。然后呢？他还在 chen.c.science 上开源了一种编程语言。我不知道他从哪里得到了“science”这个名字。这就是入口，但无论如何。</font></font></p><p>So, what? What Andrea, cycle degree at NC, invented all this? This
            whole idea. He didn’t know about Boolean profunctors. He just did all of
            this stuff in the way that seemed most sensible to him as an engineer.
            And it just turned out to be exactly Boolean profunctors. And what? And
            he also made a programming language open sourced at, I think,
            chen.c.science. I don’t know where he got the idea of “science” as the
            name. That’s the entrance, but anyway.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它所做的是绕过前厅帕累托最优反链，而不是绕过布尔函数本身。它接受一定数量的美元或其他东西，并生成所有帕累托最优事物的反链，这个人说它通过了。有点像通常所说的克莱尼定理。我知道，戏剧，格兰特，孙子，甚至我都病了。克莱尼。所以，我认为是克莱尼，而不是清洁或清洁。他使用克莱尼定理来确定这里的反链。</font></font></p><p>What it does is it passes around the antechamber Pareto optimal
            antichains instead of passing around the Boolean profunctor itself. It
            takes in a certain amount of dollars or whatever and produces the
            antichain of all Pareto optimal things that this one says passed it
            through. And kind of like, usually what’s called the Kleene theorem. I
            know, plays, Grant, grandson, and even I’m sick. Kleene. So, I think
            it’s Kleene, as opposed to clean or clean. He uses the Kleene theorem to
            determine the antichain here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不知道我是否回答了你的问题，但关键是这个布尔关系，如果我只保存了反链，比如，给定一个输入，我告诉你输出反链，那么我也可以通过检测小于最佳反链的东西来告诉你可行性关系。这个反链中是否有一个元素小于其他元素？是的，所以你说 pro 函子是函子的泛化，但它在这里也被定义为是，我想我是这方面的大师。是的，那是原始的软泥。</font></font></p><p>I don’t know if I answered your question, but the point is that this
            Boolean relationship, if I just saved the antichain of, like, given an
            input, I tell you the output antichain, then I can also tell you the
            feasibility relation by detecting something’s less than that optimal
            antichain. Is there an element in this antichain that is smaller than
            other elements? Yeah, so you said that a pro functor is a generalization
            on a functor, but it’s also defined here in terms of yes, and I guess
            I’m a master of that. Yeah, that’s the primordial ooze.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，范畴论是非常灵活的，因为很多事物都可以用其他事物来定义。</font></font></p><p>So, category theory is very fluid in the sense that lots of things
            can be defined in terms of other things.</p>
        <h2 id="fluid-nature-of-category-theory"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴论的流动性</font></font></h2><h2>Fluid Nature of Category
            Theory</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，你首先定义一个函子，然后使用它来定义一个 pro 函子。然后你意识到，如果需要的话，函子可以被理解为特殊的 pro 函子。因此，我们经常需要以线性方式做事，这样我们才能让事情立起来，这很重要。但通常，你也可以从许多不同的部分开始。</font></font></p><p>So, you define a functor first, then you use it to define a pro
            functor. Then you realize that functors could be understood as special
            pro functors, if you need to. So, often we need to do things linearly
            just so we can kind of have things up next to stand, and that’s
            important. But often, you can also start from lots of different areas of
            parts.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，是的。当</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是范畴意义时，你就得到了一个范畴。你可以将</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">视为拓扑空间的范畴，这样你就得到了一个整体空间和从一个到另一个的映射，而不是一组从一个事物到另一个事物的映射。</font></font></p><p>Yes, yes. When <em>V</em> is the category sense, you get a category.
            You can take <em>V</em> to be the category of topological spaces, and
            you get, instead of a set of maps from one to another, one thing to
            another, you get a whole space and maps from one to another.</p>
        <h2 id="enrichment-of-v-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">丰富 V 类</font></font></h2><h2>Enrichment of V-Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当您将</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">视为向量空间时，您将得到从一个到另一个的映射的向量空间。</font></font></p><p>When you take <em>V</em> to be vector spaces, you get a vector space
            of maps from one to another.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，就像我说的，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">本身就丰富了。事实证明，事实上，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">本身就丰富了。给定任何两个向量空间，就会有一个完整的映射向量空间。所以，映射的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">空白</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">就是粗体</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。当</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是布尔值时，你会得到映射的“是”/“否”。</font></font></p><p>So, just like I said, <em>V</em> was enriched in itself. It turns
            out, in fact, <em>V</em> is enriched in itself. Given any two vector
            spaces, there’s a whole vector space of maps. So, the <em>blank</em> of
            maps is the bold <em>V</em>. When <em>V</em> is Bool, you get a yes/no
            of maps.</p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">V</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">本身的丰富</font><font style="vertical-align:inherit">意味着什么？如果确实如此，我想知道它是如何体现出来的？</font></font></p><p>What does it mean for <em>V</em> to be enriched in itself, and I’m
            wondering how that shows up in this stuff, if it does?</p>
        <h2 id="requirements-and-profunctors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">要求和函数器</font></font></h2><h2>Requirements and Profunctors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">事实上，这个泵……就像，</font><font style="vertical-align:inherit">当</font><em><font style="vertical-align:inherit">b</font></em><font style="vertical-align:inherit">是……时，pro 向量通过</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b的程序的要求是什么？</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>The fact that this pump…like, what is the requirement that a program
            of the pro vector via <em>b</em> under means when the <em>b</em> is…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好问题。也许可以做得更好。只是……我无法在 30 秒内回答。30 秒内还有其他问题吗？</font></font></p><p>Good question. Maybe better crafted. Just… I can’t answer it in 30
            seconds. Anything else in 30 seconds?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那我们就先结束吧，然后再上来。</font></font></p><p>Okay, so let’s end, and then come on up afterwards.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">幸福罗梅罗布什</font></font></p><p>Happiness Romero Bush</p>
        <h1 id="applied-category-theory.-chapter-4-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 4 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 4, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 25 日) — 56:19 </font></font><a href="https://youtube.com/watch?v=92Xp1z9PwJM"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=92Xp1z9PwJM</font></font></a></p><p> 6
            years ago (Jan 25, 2019) — 56:19 <a href="https://youtube.com/watch?v=92Xp1z9PwJM">https://youtube.com/watch?v=92Xp1z9PwJM</a></p>
        <h2 id="summary-7"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本视频讲座继续讨论协作设计，使用图表来表示团队之间的交互。演讲者介绍了单子范畴，即预序的泛化，以正式描述这些交互。讲座解释了如何将表示组件之间关系的图表转换为代数符号，以及如何表示组合和并行操作。讨论了图表中的一致性概念，以及集合、向量空间和预序等类别的例子。讲座最后介绍了紧凑闭范畴，一种特殊类型的范畴，以及它们与协作设计问题的关系。</font></font></p><p>This video lecture continues a discussion on collaborative design,
            using a diagram to represent interactions between teams. The speaker
            introduces monoidal categories, a generalization of preorders, to
            formally describe these interactions. The lecture explains how diagrams
            representing relationships between components can be translated into
            algebraic notation and how composition and parallel operations are
            represented. The concept of coherence in diagrams is discussed, along
            with examples like categories of sets, vector spaces, and preorders. The
            lecture concludes by introducing compact closed categories, a
            specialized type of category, and how they relate to the collaborative
            design problem.</p>
        <h2 id="collaborative-design-problem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">协同设计问题</font></font></h2><h2>Collaborative Design Problem</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们开始吧。好的，今天我们继续讨论协作设计。David 昨天贴出了这张图，让我们来谈谈什么是协作设计问题。它提出了一个问题：给定一些团队的某些规格——例如，一个底盘团队生产了某些产品，比如说，如果给定了最漂亮的某些功能、某些资源，给定这三个团队的这些规格——整个团队可以生产什么？给定一定数量的资金，可以生产出什么样的机器人，能够支撑一定的重量和 Addison 速度？</font></font></p><p>Let’s get started. Okay, so today we continue talking about
            collaborative design. So, David put up this diagram yesterday, and so
            let’s talk about what this is a collaborative design problem. So, it
            asks the question: given some specifications of some teams—so, a chassis
            team produced certain, say, that if the prettiest certain functionality
            is given, certain resources, given these specifications of these three
            teams—what can the team as a whole produce? What sort of robot, which is
            capable of supporting a certain weight and Addison velocity, can be
            produced given a certain amount of money?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在此通过此图给出了团队如何互动的规范。此图很有趣，因为它几乎在形式上直观。您可以看到这一点；这里的想法是，这条线代表了电机应该为底盘提供速度的想法。但是在本讲结束时，我们将看到，此图也是正式的。它不仅提供了正在发生的事情的图景，而且还提供了一种特定的算法，给定这些关系，我们如何计算团队的整体能力？这个团队如何协作设计某些产品。</font></font></p><p>So, the specification we have here for how the teams are interacting
            is given by this diagram. This diagram is interesting because it’s at
            once almost in form intuitive. You can see this; the idea here is that
            this line represents the idea that the motor should be supplying the
            speed to the chassis. But we’ll see by the end of this lecture that this
            diagram is also formal. It provides not just a picture of what’s going
            on, but a particular algorithm for, given each of these relationships,
            how do we compute what the entire capability of the team is? How this
            team can collaborate to design some product.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，不过，在我们讲到这一点之前，我想先给大家介绍一些老手。好吧，实际上还有一条评论。大卫昨天说过，我提醒你们这些是什么，但他认为这些东西应该用他称为布尔参数或所有参数的东西来表示，他也称之为可行性关系。</font></font></p><p>Okay, so before we get there, though, I would turn to give you a lot
            more veterans, I guess. Well, so one more comment actually. So, David
            said yesterday, and I remind you what these are, but that he’s these
            things should be represented by these things he called Boolean
            parameters, or all parameters, which he also termed feasibility
            relations.</p>
        <h2 id="formal-representation-of-relationships"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关系的正式表达</font></font></h2><h2>Formal Representation of
            Relationships</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这些正是事物，正是来自预序的子集或布尔函数，它们回答了这个问题：什么可以生产，需要资源？如此之快。</font></font></p><p>So, these are precisely things, precisely subsets or Boolean
            functions from the pre orders that answer the question: what can be
            produced and want resources? So fast.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">回顾课程的开始，我们首先介绍了幺半群的概念。</font></font></p><p>Going back, right back to the beginning of the course, we first
            introduced the notion of a monoid.</p>
        <h2 id="monoidal-categories-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半群类别和图表</font></font></h2><h2>Monoidal Categories and
            Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">暂时先说一下，这是一个带有二元运算的集合，你知道，二元运算有一个单位元素或单位。然后我们看到，我们可以构造这些称为幺半群过滤器的东西，这是一个带有这些结构的集合，称为 G，我们有一个顺序，但在这个东西上，我们有一个二元运算。然后我们看到了类别的概念。所以，这是一个类似的，它是一堆幺半群和预序的泛化，但不是放置模型结构，不是能够使用我们的操作来组合预序的元素，而是开始拥有关系的方式，我们可以组合这些元素、对象、态射等关联方式，然后我们有了这个组合操作。</font></font></p><p>For just a moment, this is a set with a binary operation, and you
            know, so the binary operation has an identity element or a unit. We then
            saw that we could construct these things called monoidal filters, which
            is a set with these structures called G, and we have an order, but also
            on this thing, we have a binary operation. Then we saw the notion of a
            category. So, this is a similar, it’s a bunch of generalization of a
            monoid and a pre order, but instead of putting the model structure,
            instead of being able to compose elements of the pre order using our
            operation, we start having ways of relationships, and we can compose
            those ways of relating these elements, objects, sort of morphisms, and
            then we have this composition operation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">显示注释。</font></font></p><p>Show notes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，单半群范畴。所以，具体来说，你可以说 Topos Institute 是一种特殊类型的范畴。或者，嗯，那是一种特殊类型的单半群和一种特殊类型的范畴。我不能同意一个对象，但坐在这里，你可以表演同样的技巧。所以，这些都是范畴。所以，这就是所有的数据，但它们有一个单半群结构。所以，我们有一种组合的方式，即以并行的方式将对象彼此组合，将态射彼此组合。</font></font></p><p>So, monoidal categories. So, in particular, you can say that a Topos
            Institute is a special type of category. Or, well, that one is a special
            type of monoid and a special type of category. I can’t agree with one
            object, but sitting down here, you can perform this same trick. So, what
            these are categories. So, that’s all of that data, but they have a
            monoidal structure. So, we have a way of composing, so combining objects
            with each other and morphisms with each other in a parallel sort of
            way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们的目标是到达这里，但让我们再多想想我们如何谈论这些事情，如何表示它们。您在代数语法层面上已经了解了这一点。我们会写出诸如 p &lt; q 之类的东西。但我们还讨论了事物在图表上的情况。A 5 1 是世界上最好的能量。因此，特别是在这里，如果您绘制这些图表，那么这些东西就是电线，这就是这些电线可以串联起来的方式。</font></font></p><p>So, the aim is to get here, but let’s think a bit more about how we
            can talk about these things, on how we represent them. You had this at a
            very algebraic syntax level. We would write things like p &lt; q. But we
            also talked about things being on a diagram. A 5 1 is best energy over
            here on the world. So, here in particular, if you draw these diagrams,
            then these things are the wires, and this is how these wires can be put
            in series.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在很多行中，我们经常会写，您可能会写一些类似 1 + 2 + 3 的内容，或者您​​也可以将其视为一些流程串。因此，您从某个东西开始，您有 1，您读到，您是 3。因此，在这个解释中，这些东西，这里的相关性，是盒子，这是系列，这是我们将工作与之关联的东西。所以，所以是单半群结构，但您可以将其视为从线开始。所以，您总是从另一个顶部重新排序开始。我们只是有一种水关系，但我们可以将事物并行。所以，我可以画出像 1 + 2 &lt; 4 这样的东西。这里还有另一件事，它表明第 5 节中的 3。一切都总结了结构。让我们考虑一下 1 + 2 + 3 &lt; 4 + 5 这个事实。所以，这里是盒子。</font></font></p><p>In a lot of lines, we often write, you may write something like 1 + 2
            + 3, or you might also think of this as some maybe string of processes.
            So, you sort of start with something, you had 1, you read to, you are 3.
            So, in this interpretation here, these things, the relevance here, are
            the boxes, and this is series, and this is a thing we associate the work
            either to. So, so the monoidal structure, but you can think of it as
            starting with the wire. So, you always start with from another top
            reorder. We had just sort of a water relationship, but we could put
            things in parallel. So, I could draw things like 1 + 2 &lt; 4. It also
            another thing here that says that 3 in session 5. Everything sort of
            concludes the structure. Let’s just think about the fact that 1 + 2 + 3
            &lt; 4 + 5. So, here it’s boxes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于类别，我们开始输入这种组合概念。因此，具体来说，我们有，比如说，所以，但这里重要的是，这些过程，这些事物之间的关系，是紧密的。所以，你不能只拿一根棒和焊料，因为没有东西可以连接。所以，这里我们有这些电线，这些盒子。我不知道，它们不仅仅是盒子，只是小于号的存在，而是一种与事物相关的自然方式。</font></font></p><p>For categories, we started typing this notion of composition. So, in
            particular, we have, say, so, but the important part being here is that
            these processes, these relationships between things, are tight. So, you
            can’t just take a bar and solder because there’s nothing to connect. So,
            here we have these are the wires, these are the boxes. I don’t know,
            they’re not just the boxes, are just the existence of the less than
            sign, but a natural way of relating to things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后这是串联组合。所以，在幺半群范畴中，你有一个范畴。所以，你可以将这四根电线、盒子和盒子串联起来，但你还有这个东西，一个幺半群积，它给你一个并联组合的概念。所以，在普通范畴中。所以，你可以看到这些结构中的每一个都捕捉到了这个图表的概念。而在其他范畴中，捕捉到所有这些概念的这种共同概括，我们允许盒子并联和串联，它们允许不同的类型，有对象，这里是对象乘积之间的态射。</font></font></p><p>And then this is series composition. So, in the monoidal category,
            you’ve got a category. So, you can do these four wires, boxes, and boxes
            in series, but you’ve also got this thing here, a monoidal product,
            which gives you a notion of parallel compositions. So, in the normal
            categories. So, you can see each of these structures is capturing this
            notion of diagram. And in other categories, capture this sort of common
            generalization of all of these notions, where we’re allowed boxes in
            parallel and series, and they’re allowed time different types, there are
            objects, and here are morphisms running between products of objects.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">并非所有这些结构都指定了数据等。模型 I、II 为您提供了去年的框，类似地，类别的集合为您提供了线。而这个设置，即设置一个态射，仍然为您提供框，但我们还有公理来确保这个数据库和实际结合在一起。那么我们如何根据这些图片来思考它们？好吧，例如，这个态射的乘法需要具有结合性。结合性意味着，即使我们指定了像 + 这样的二元运算，我们在哪个点拥有一串东西并不重要；我们以什么顺序添加它们并不重要。</font></font></p><p>Not all of these structures specify data, etc. A model, I, II, gives
            you the boxes for last year’s and similarly, this set for a category
            gives you the wires. And this setup, set a morphism, still gives you the
            boxes, but we also had axioms that make sure that this database and
            actually together. So how do we think about them in terms of these
            pictures? Well, for example, this multiplication of the morphisms is
            required to be associative. And what associativity means is that, even
            though we specified a binary operation like +, it doesn’t matter which
            point we have a string of things; it doesn’t matter which order we add
            them in.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果将这些图表编译为这种正式符号，它们可能会产生歧义。该图表可以表示 1 + 2 然后 + 3，也可以表示 1 + 2 + 3。现在，连贯性，即我们关于单半群范畴结构的公理，表明该图表是无歧义的。因此，这是一种将其捕捉到视觉图像中的好方法。因此，物质范畴，即我们在此结构之间放置的单半群范畴的公理，以及其他确保此类图表具有无歧义解释的方法。因此，无需介绍，我们将给您一个粗略的定义。之所以粗略，是因为我不会告诉您连贯性到底是什么意思。我只会列出结构并说明它捕捉了这个想法。对吗？对。</font></font></p><p>So these diagrams, if you compile down to this formal notation, could
            be ambiguous. This diagram could represent 1 + 2 then + 3, or it could
            represent 1 + 2 + 3. Now, coherence, our axioms on the structure of a
            monoidal category, say that this diagram is unambiguous. So that this is
            a good way of capturing this to the visual picture. So, material
            categories, the axioms of monoidal categories that we put between this
            structure, ways of other ways of making sure that diagrams like this
            have an unambiguous interpretation. So, without introduction, then we
            give you a rough definition. So the reason this is rough is I won’t tell
            you exactly what the coherence means. I’ll just lay out the structures
            and say that it captures this idea. Right? Right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">他的元组是第一个类别 C 和乘积。因此，给它任何类别，我们都可以形成这个乘积类别。这里的对象是否是这里的对象对，以及乘积类别中的态射是类别 C 中的态射对，它们介于关注域和陪域之间。所以，这是一个类别。我将有一个函子，我称之为张量，它接受事物对，两对对象，并返回一个对象。</font></font></p><p>He’s tuple is first category C and product. So, give it any category,
            we can form this product category. Whether the objects in here are pairs
            of objects in here, and the morphisms in the product category are pairs
            of morphisms in category C that go between the sort of care domain and
            codomain. So, that’s a category. And I’m going to have a functor that
            I’ve called tensor that takes pairs of things, two pairs of objects, and
            returns an object.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">扩展一些自闭症并返回一个很棒的。所以，这就是单半群函子。哦，因为这是统一的。所以，我还想谈谈从一个对象类别到 C 的一堆。但请记住，我们前几天看到，从一个对象类别到一个类别的函数与另一个类别的函数相同。然后我们有一些东西可以帮助跟踪这些想法，比如结合性和统一性。所以，我们有自然变换或自然同构。</font></font></p><p>To expand some autism’s and returns an awesome. So, that’s the
            monoidal functor. Oh, because this is unified. So, I also want to talk
            about a bunch from the one object category to C. But remember, we saw
            the other day that a function from the one object category to a category
            is just the same as another category. And then we have some things that
            help keep track of these ideas, like associativity and unity. So, we’ve
            got natural transformations or natural isomorphisms.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接下来，我们有这个态射，Orlando X，从单位乘以 X 到 X。这很好。并且有一个 X 的右单位。我们有一种处理结合律的东西。因此，对于每个 X、Y 和 Z，我们都有一个从 X 张量 Y 张量 Z 到 X 张量 Y 张量 Z 的映射。结合律。然后，现在，我定义一个幺半群范畴，对称幺半群范畴表示我们将一个映射设置为满足效用的宽松形式。它接受一个对象 x 和一个张量 y，并返回一个对象。效果，好的。因此，对称雷诺范畴是这些数据，使得这些自然同构相对于表现良好的自然项表现良好，好吗？</font></font></p><p>Next, we have this morphism, Orlando X, from unit times X to X again.
            This is nice. And one have a right unit of X. We kind of something that
            takes care of associativity. So, for every X, Y, and Z, we have a map
            from X tensor Y tensor Z to X tensor Y tensor Z. The associative. And
            then, so right now, I’m defining a monoidal category and a symmetric
            monoidal category says that we put a map that is a relaxed form to meet
            utility. It takes an object x and a tensor y, and returns an object.
            Effects, okay. So, symmetric Renault category is this data such that
            these natural isomorphisms are well behaved with respect to well behaved
            natural items, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这与图表有什么关系呢？好吧，我们这样解释图表，它代表了多个 x。给出：看这样的图表。我将其解释为过期，看看我看到的是并联还是串联，对吗？那是串联。这是组合。我将跳过对象的类型。并行的东西。医生注意到两个或更多事物的张量积。但如果我看到事物串联和并联，像那样修复事物，会发生什么？</font></font></p><p>So, how does this relate to the diagrams? Well, so we interpret a
            diagram like that, and it’s representing more than one x. Given by: See
            a diagram like this. I interpret it as expired to see if I see things in
            parallel or in series, right? That’s are in series. This is composition.
            And I’ll skip the types of objects. Things in parallel. Doctor notes a
            tensor product for two or more things. But what happens if I see things
            in series and in parallel, fixing things up like that?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，我可以给出任何图表。你可以从左到右追踪翻转。然后在发生某些事情的每个地方，你可以细分。所以，从这里到这里发生了一些事情。所以，这里有两件事发生。首先，我们可以看到这是 f 与 a 的组合，然后我们可以看到它与 g 的组合。所以，这就是你用这样的图表阅读一个团块的方法。我停止了扫描并划分为政治情节。</font></font></p><p>Well, I can give it any diagram. You can sort of trace the flop flung
            it from left to right. And then at every place where something happens,
            you can sort of subdivide. So, something happened from here to here. So,
            there are two things happening here. First, we can see this is f
            composed with a, and then we can see that it does being composed with g.
            So, that’s how you read a clump with a diagram like this. I stopped
            scanning across and dividing into a political plot.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你在常数恒等式之间划了一条线。我想这是一些恒等式，我不知道你在这里发生了什么事。所以，我们需要输入它，对吧？好的。所以，这是一堆材料。所以，我会给你一点机会来解释这一点。如果我要使用这种语法，我将如何编写这些图表？我给你两分钟时间找一个吊坠来谈论这些事情。</font></font></p><p>You sort of put a line between constant identity wise. I guess this
            is some identity lies here that I don’t you was here on something
            happened to treat. So, we need to enter that, right? Okay. So, that’s a
            bunch of material. So, I’ll give you a bit of a chance to interpret
            this. If I was going to use this syntax, how would I write these
            diagrams? I’ll give you two minutes to find a pendant talk about these
            things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">不会是我的朋友，对吧？但那为什么呢？你觉得有什么不同呢？所以，你不希望它是正确的？因为最初，我是否必须对答案如此精确？这是否真的是用 1 张量恒等式与恒等张量组成的敌人所写的内容？这就是行为良好的大卫之一。我认为这很有趣，这个定义的重点。你听到了一种确定所有行为良好的方法，它在那个地方的行为如何，以确保它正在运行。</font></font></p><p>Wouldn’t be my friend, would you? But then why? And what do you what
            do you make the difference between the way that? So, you don’t want it
            to be right? Because initially, it’s like do I have to be that precise
            about an answer? Is that what’s really being written in 1 tensor
            identity composed with identity tensor the enemy’s? And that is one of
            the well behaved David. I think that’s the fun, the point of this
            definition. You heard one way to determine all that well behaved it, how
            its behavior in that place to make sure that it means it’s going.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">假设两件衣服都是完美的，看 w。这意味着 c 是无定形的。每当您看到任何两件平行的东西时，张量线与 x 和 y 修复平行。有什么问题吗？Lady Rebecca 尝到了它是否是一个带有我们电线的盒子。以太平行线与放置竞争者。你觉得这些是什么？好的。第一层是身份 y 是的。所以，如果你坚持这种方法来找出事情发生的地方，那么有很多方法。</font></font></p><p>Let’s say that two outfits are perfection watch w. It means that c is
            amorphous watch. Whenever you see any two things in parallel, at tensor
            wire with x and y repair parallel. Any questions? Lady Rebecca tasted
            wonders whether it’s a box with our wires. Etherial parallels with put a
            contender. What do you think these kind of? Okay. And the first layer is
            an identity y yes. So, there are all the ways if you sort of stuck to
            this method of figuring out where things happen.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以这样做，你可能会在三个罐子里幸存下来。在这种情况下，你会得到什么是什么？这是一个密度恒等式。然后与是的，当然，感觉是 g 组合。所以这里重要的结构是这两个表达式必须表示这个类别中的相同态射。所以，这就是我所说的这种结构的连贯性。所以，也许为了更明确地看到这一点，让我们来看看下面这个东西。</font></font></p><p>You could do you might survive dolphins three pots like this. In
            which case would you get what’s what? This is a density identity. Then
            compose with yeah, definitely, sense a g. So the structure that’s
            important here is that these two expressions have to represent the same
            morphism in this category. So, this is what I mean by the coherence of
            this sort of structure here. So, maybe to see this bit more explicitly,
            let’s come to this thing down here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">大家知道如何表示这个图吗？好的。</font></font></p><p>Do people have some idea about how to represent this diagram?
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，事实证明这两个态射在任何对称类别中总是相同的，而这正是这些公理所要求的，特别是张量积的准时性所要求的。因此，张量积是接受态射或返回一个态射的东西。但准时性表明我们可以组合然后做我们的张量，这很棘手，我们先组合它们。十，所以整周都先密集学习，然后组合。所以，这正是这里发生的事情。要么是张量，先张量，然后组合，要么我们可以组合这些东西然后张量化它们。</font></font></p><p>So, what turns out is that these two morphisms are always the same in
            any symmetric whatever category, and that’s required by these axioms, in
            particular, is required by the punctuality of the tensor product. So,
            the tensor product is something that takes, in this case, morphisms or
            returns one morphism. But punctuality says that we can either compose
            and then do our tensor, which is cancerous, we compose them. Ten, so all
            week intensive first and then compose. So, that’s precisely what’s
            happened here. It’s either tensor, tensor first, and then compose, or we
            could compose these things and tensor them.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体来说，我们也可以执行张量和组合或组合与张量的技巧。但是如果我们先组合然后张量，那么这里，这里是张量和组合，但是如果我们先组合然后张量，我们得到 f 与空张量身份组合，与 g 张量组合，而由身份组合的 f 就是 f。因此，与 g 组合的 f 就是 f 张量 g。</font></font></p><p>So, in particular, up here, we can also perform this trick of tensor
            and composing or composing versus tensoring. But if we compose first and
            then tensor, so here, here is tensor and composing, but if we compose
            first and then tensor, we get f composed with that empty tensor identity
            composed with g tensor, and f composed by an identity is just f.&nbsp;So,
            it’s f composed with g is just f tensor g.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，对于该图，这两种解释都是可以接受的，而且它们在任何对称的、另一个类别中总是相同的，因为人们在这个结构上拥有正确的连贯性公理。有人想快速说出这一点吗？好问题。这些联想器的连贯性表明这不是必要的。我可以稍后再详细说明。好的，就是这样。</font></font></p><p>So, these are both acceptable interpretations for this diagram, and
            they’re always going to be the same in any symmetric, another category,
            because one has the right coherence axioms on this structure. Does
            anyone want to shout out this one quickly? Good question. The coherence
            for those associators say it’s not necessary. I can expand on that
            afterwards. Okay, just so.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，你大概知道这个结构是什么了。让我向你介绍另一个非常重要的类别，因为类别是丰富了这个类别的类别，这是一个事实，即必须有效地挂起以便更快地查看可能只是轮廓必须是状态。</font></font></p><p>So, now you kind of have some idea about what this structure is. Let
            me submit to you another category that’s very important, because
            categories are categories enriched over this category, which is an
            effect that the fact that has to be efficiently hanging around for
            faster you look possible that just has been contours must be state.</p>
        <h2 id="categories-enriched-over-monoidal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">比 Monoidal 类别更丰富的类别</font></font></h2><h2>Categories
            Enriched over Monoidal Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您有这个幺半群类别。因此，底层类别是集合。因此，对象是集合。态射是函数。幺半群乘积由集合的乘积和函数的乘积以及两个函数的乘积给出。我有下一个 a 到 b，然后我可以得到一个映射，下一个是 a 乘以 d，它使用第一个将其带回 x play 和 a man said 到 a，使用 f，就是这样，对吗？</font></font></p><p>You had this monoidal category. So, the underlying category is Set.
            So, the objects are sets. The morphisms are functions. The monoidal
            product is given by products of sets and also products of functions as
            well as the fun off total two functions. I have next a to b, then I can
            get a map next is fine a times d, where it takes it back x play and a
            man said to a using the first, using f, and that’s it, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这两个映射在每个角上都是分开的。正如你可能检查的那样，这个东西属于另一个类别，因为它有两个基本不连贯条件，直到它可能服从最后一个条件，即 c3，我们称之为（人们倾向于称之为）交换定律。所以，具体来说，给定一些函数 f 和 g，你可以……我投票赞成……这是一个域，我把它归功于那个函数。但如果这是你可以检查的东西，它对函数也成立，这很好地说明了这是类别上某个点的一个例子。</font></font></p><p>So, it’s just these two maps are very separately on each corner. As
            you might check, then, this thing is in another category because it has
            two base incoherence conditions until it might obey this last one, there
            c3, which we call (which people tend to call) the interchange law. So,
            in particular, given some functions f and g, you can… I vote my tab…
            that’s a domain, a credit me into that function. But if this is
            something that you can check, it holds true for functions, and that’s a
            good out the fact that this is an example of a certain point over a
            category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个可以使用的例子是集合，然后我们引用余积来让你失望，你知道，感觉。有些人可能称之为标记并集。给定一些集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">B</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，即使在你的集合论中，它们可能共享一些限制来调用它们，你也会为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的每个元素和彼此创建一个副本。所以，假设两个集合的不相交并集的基数只是它们基数的总和，而空集的幺半群。所以，拟合取并集，我在谈论一个空集，它又是同一个集合。是的，有点像幺半群单元的作用。</font></font></p><p>Another example you can use is sets, and then let’s quote the co
            product to disappoint you, you know, sense. So, some people might call
            this a tag union. Given some sets <em>A</em> and <em>B</em>, even if
            they might sort of, in your set theory, share some that limits to call
            them, you kind of create a copy for each element in <em>A</em> and each
            other to be. So, say the cardinality of the disjoint union of two sets
            is just the sum of their cardinalities, and the monoidal, you know, for
            that of the empty set. So, fitting taking union, I’m talking with an
            empty set, it’s the same set again. Yeah, sort of what the monoidal unit
            does.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个很好的例子是，这种符号倾向于使用来自向量空间的张量符号。某个域上的向量空间，好吗？所以，对象是向量空间，态射是线性映射，而正常结构中的单半群积来自所谓的线性映射和向量空间的张量积。</font></font></p><p>And quite an example where this notation tends to be using this
            tensor symbol comes from vector spaces. The kind of your vector spaces
            over some field, okay? So, the objects are vector spaces, the morphisms
            are linear maps, and the monoidal product in the normal structure comes
            from what’s known as the tensor product of linear maps and vector
            spaces.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，我们将要讨论的第四个例子是预序类别。因此，这里的对象是类别，对于某些类别，我们假设是对称的，我们知道要对它们进行预序。态射是预序，稍后会提醒它的定义，然后幺半群积是预序的乘积，对不起，是所有类别的乘积。并且有一个与之相关的预序乘积概念。</font></font></p><p>And then, a fourth example, which we’re going to discuss, is the
            category of preorders. So, here our objects are categories, for some,
            let’s just say symmetric, we know to preorder them. The morphisms are
            the preorders, which are reminded the definition of in a second, and
            then the monoidal product is the product of preorders, sorry, all of the
            categories. And there’s an associated notion of product of pre orders
            that goes with that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，错过一个类别</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">B</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">之后，形成另一个类别，你知道，好的。如果我们可以在我扩展之前提升怎么办？不会。所以，这个图中发生的事情被称为分类过程。</font></font></p><p>And yes, miss one after the category <em>B</em> category, which forms
            another, you know, okay. What if we can promote before I extend? Will
            not. So, what’s going on in this diagram is known as the process of
            categorization.</p>
        <h2 id="symmetric-monoidal-categories-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对称幺半群类别和图</font></font></h2><h2>Symmetric Monoidal
            Categories and Diagrams</h2>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在这里看到的是，假设我们有一个先验</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">结构，</font><font style="vertical-align:inherit">因为我们知道事物是可以关联的。当我们将预序的概念归类为一个类别时，我们会用一组关联的方式来取代这种事物是否关联的观念。同样，这就是从单半群结构到两个或多个类别的过程。事实上，正如模型不是一个对象类别，单半群类别是一个对象两个类别。</font></font></p><p>So, what we see is here, say we have this structure of an <em>a
                priori</em> as we have that things can be related. And when we
            categorize the notion of a preorder to a category, we replace this idea,
            this sort of whether things are related or not, with a set of ways that
            they’re related. And similarly, that’s that’s the process from the
            monoidal structure over two or more categories. And in fact, just as a
            model isn’t one object category, and the monoidal category is a one
            object two category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，二分类已经知道了二分类，其中我们不仅有对象（即分类）和态射（即函子），还有态射之间的态射（即自然变换）。这种图景继续下去，这是思考和丰富结构的重要方式。丰富或添加细节在这里可能有点用得过度，但它是关于添加更多的生态和结构来描述越来越丰富的现象。现在，有一点需要注意，那就是当你进一步讨论事物相互关联的方式之间的更多关系时，你会削弱连贯性的概念。</font></font></p><p>The example, the two category already knows the two category of
            categories, where we not only have objects which are categories and
            morphisms which are functors, but morphisms between morphisms, which are
            natural transformations. This sort of picture continues, and it’s an
            important way to think about and enrich your structure. Enriching, or
            adding detail, is probably a bit overused here, but it’s about adding
            more ecology and structure to describe richer and richer phenomena. Now,
            one thing to notice, though, is that as you go up and talk about some
            more relationships between the way things relate to each other, you
            weaken your notion of coherence.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，某些相等性通常恰好是发生在顶部的情感连贯性。因此，没有办法谈论单半群元素之间的数学映射。因此，我们只是说等于 4 以完成结合性。而在这里，我们有更多的结构，因为这些东西是对象，我们有一种谈论对象与态射概念相关方式的方法。因此，我们不是说 y 的范围趋向于 z 下一次 y 时态 z 等于 x 10 y 密度，而是要求它们之间同构。</font></font></p><p>So, some equality happens to usually be an emotional coherence that
            occurs right at the top. So, there is no way to talk about maps between
            math maps between elements of a monoid. So, we just say that equals 4
            for the associativity finishing. Whereas here, we have a bit more
            structure because these things are objects, and we have a way of talking
            about the way objects are related with the notion of morphism. So,
            instead of saying that extents of y tends to z next times y tense of z
            is equal to x 10 y density, we ask for an isomorphism between them.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">再进一步，同构必须以自然的方式连贯。有人在最后一节问过。我在这里说了“自然”，并谈到这些自然的东西是自然化的态射，但引入自然性的概念是自然变换的概念，它运行在函子之间。这里的函子是看不见的，但是一旦函数是，比如说，在这个第三种情况下，这是一艘宇宙飞船，有两件事 x 10 选择 10 到 z 和 x 10 所以 y 趋向于 z 表示从 C × C × C 到 C 的函子。</font></font></p><p>And then further on, hasta the isomorphism be coherent in a natural
            way. Someone asked during that last section. I said “natural” here and
            talked about these natural things being naturalized morphisms, but that
            the notion of naturality, who introduced it, is the notion of natural
            transformation, which runs between functors. And the functors and here
            are kind of invisible, but once the functions are, say, in this, let’s
            say, in this third case, these a spaceship, there’s these two things x
            10 select 10 to z and x 10 so y tends to z represent functors from C × C
            × C to C.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，第一个函子表示您有三件事。第一个和第二个函数都表示了这一点。因此，自然同构的概念是这两个因子之间的自然同构。所以，这就是这里的 alpha。这很糟糕，是的。maximoff 是同构意味着在另一个方向上有一个自然变换，称为 Alfred S，这样它就是……是的。所以，这就是对称包，它与我昨天讨论的主题（即这个资源区域）略有相似之处。</font></font></p><p>So, the first functor says that you’ve got three things. The first
            and the second function says that. And so, this notion of natural
            isomorphism as a natural isomorphism between these two factors. So,
            that’s the alpha here. That’s awful, yeah. And maximoff it being an
            isomorphism means there’s a natural transformation in the other
            direction called Alfred S, such that it’s… yeah. So, that’s symmetrical
            packages, and it’s slightly close to the topic I have, which is this
            resourced area yesterday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">David Webster，一般来说，但我只想谈谈引入类别的事情，这些类别是完整的国家。哪一个对你来说很容易？所以，目前有一个很好的事实值得探索。它是对称的另一个类别，每个函子都有偏好。让我们弄清楚这个医生是什么。布尔目的。所以，这是一个类别。对象、态射，这些东西是可行性关系。所以，例如，有很多方法可以考虑这些可爱的事情，那就是我要尝试 mac，这是一个时髦的时代，例如。</font></font></p><p>David Webster, generally with respect to, but I just want to talk
            about things in terms of pulling in categories, which are full
            countries. Which one for you is it’s easy? So, there’s a nice fact
            exploring at the moment. It is is a symmetrical another category
            preferences per functors. Let’s figure out what this doctor is. Boolean
            purposes. So, this is a category. Objects, the morphisms, these things
            for feasibility relations. So, for example, there are a bunch of ways to
            think about these cute is that is that I’m gonna try mac that is a funky
            times, for example.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们可能会说，圣诞老人还有更多的蛋糕。好的。拿房子来说，我们可能会问一些袖口。所以，有不同的……所以，一个非常简单的例子。让我们假设出于某种原因，商场里有两个蛋糕。所以，这将是复杂的，最喜欢的蛋糕口味。随便选一个，草莓。好的。看，我更强。好的。有一个预购，然后是敷衍的“是”。在这里，就这一点而言，我们有所有选项：0、10、20 和关系。所以，过去，像，和我，0。</font></font></p><p>We might have, say, Santa more cakes. Okay. Take the house of about
            some set of cuffs, and we might ask. So, there are different… So, a very
            simple example. Let’s assume there are the two cakes in the mall for
            some reason. And so, that’s going to be complicated and favorite cake
            flavor. Take any one, strawberry. Okay. Look, I’m stronger. Okay.
            There’s a preorder, then a perfunctory yes. Here, in terms of this, we
            have all options: 0, 10, 20, and the relationship. So, past, like, and
            I, by 0.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">谢谢你不给我钱。是的，是的，你得到 20 美元。如果你给我零美元，我也可以不给你磁带。我不会给你巧克力蛋糕。你可以。我去看草莓蛋糕。它似乎要花 10 美元。如果你想要两个蛋糕，你必须给我 20 美元。好的，这就是你考虑公平竞争的一种方式。现在他们谈论的方式是颜色，它说你在这里画这些，然后你有这两个桥。假设你有零个蛋糕。哦，零美元，十美元，三十五，二十个级别。所以你可以问，如果我有 20 美元，我能得到什么？好吧，你可以得到任何东西。你可以从任何东西中得到它。十美元，你可以从草莓蛋糕中选择一个，因为有一条从那到十的路径，从零美元，你可以得到，不要白白出去。好的。</font></font></p><p>Thanks for no dollars. Yes, yes, you get $20. I can also give you no
            tapes if you give me zero dollars. I’m not going to give you a chocolate
            cake. You can. I go see the strawberry cake. It seems to be costing $10.
            And if you want both cakes, you have to give me $20. Okay, so that’s one
            way you’re thinking about a fair contest. And now the way in which
            they’re ever talked about is the color, which says that you draw these
            here, and then you have these two bridges. Let’s say you got zero cakes.
            Oh, zero dollars, ten dollars, thirty five, twenty levels. And so you
            can ask, if I have $20, what can I get? Well, you can get anything. You
            can get that from anything. Ten dollars, you can get a choice from a
            strawberry cake because there’s a path from that to ten, and from zero
            dollars, you can get, don’t get out for nothing. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，合成是由这个公式给出的。本质上是这样的。所以，它告诉你，你给它一对，它会告诉你你是否能得到它，而你是否能得到它取决于我们所有的 q。它应该让你想起这个公式，它说矩阵的乘法是可怕的。</font></font></p><p>So, composition is given by this formula. That is essentially, yeah.
            So, it tells you, you give it a pair, and it tells you whether you can
            get it, and whether you can get it is determined by doing all our q of
            the. It should remind you of this formula that says the multiplication
            of matrices is fearsome.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，这是另一个对偶函子，它表示，给定一些钱，我能用这些钱做多少种类别？所以，所以，对于 20 美元，我无法得到任何类别。所以，这个矩阵大约是这样的。这是您可以为类别获得多少类别。是的，这是我可以为类别获得多少钱。哦，所以你得到了 20 美元？是的，我得到了一个玩具。好的。相当于找出底部是什么。</font></font></p><p>Okay, so here’s another pair functor, which says, given some money,
            how much, how much kind of category can I do for some money? So, and so,
            so for $20, I can’t get any category. So, the matrix for this is around
            right. This is how much category you can get for category. Yes, it’s how
            much money I can get for category. Oh, so you’re getting paid $20? Yeah,
            I’m getting a toy. Okay. Corresponds to figuring out what the bottom
            that’s a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。</font></font></p><p>Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">问题：我教授范畴论能得到多少蛋糕？那么，你为什么要和不同的朋友一起穿呢？首先看看你如何使用这个公式来组成这两个矩阵，其次，检查这可能与当你把这些图并排放置并描绘出路径时发生的情况一致。嗯，那是因为有可能得到报酬。在你的诚信之后可能会有 0 美元，因为你可能会这么认为，它们是 20 美元。但这是一个类似于昨天问大卫的问题，为什么这些东西不一定是域，即使它在这里说，不一定是对象处理器。</font></font></p><p>Question: How many cakes can I get for teaching category theory? So,
            why do you wear with with a different friend? Look at firstly how you
            might compose these two matrices using this formula, and secondly, check
            that might agree with what happens when you can put these diagrams side
            by side and trace out paths. Well, that’s because it’s possible to be
            paid. It’s possible to have $0 after your integrity because they’re $20
            after you might think so. But that’s a similar question to the one that
            was asked of David yesterday about why these things don’t have to be the
            domain, even though it says up here, doesn’t have to be an object
            processor.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是这个想法，即在偏序集中以某种方式下降会要求更少，这是附加条件。当然。你对心感兴趣。这并不明显，但需要一点思考才能明白。那么，如果我想将这两个矩阵相乘会发生什么？这一行有一个四行三列的矩阵。这个矩阵有三列两行，所以我最终得到了一个二乘四的矩阵。</font></font></p><p>And that’s this idea that somehow going down in the poset is asking
            for less, which is the sort of rider. Sure. And you’re interested in
            hearts. It’s not obvious, but it takes a bit of thought as obvious. So,
            what happens if I want to multiply these two matrices? This row has a
            matrix with four rows and three columns. This matrix has three columns
            of two rows, so I end up with a two by four matrix.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我如何计算这里的 DMZ？它是真的。所以它是真的，因为如果我们必须做真与真，或者好吧，那没关系。只要你有真与真，它就是真的。但它在真或假中是真的，或者假就是真的。同样，因为这一行都是真的，事实上，这一列将是真的。</font></font></p><p>And so, how do I compute, say, DMZ here? It’s true. So it’s true
            because if we had to do true and true, or well, it doesn’t matter. As
            soon as you have true and true, it’s true. But it’s true in true or
            false, or false that’s true. So similarly, because this row is all true,
            in fact, this column is going to be one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但在这里我们看到真或假都是假的。真或假和控制脉冲都是假的，都是假的。虽然，抱歉，真和假都是假的。真脉冲总是假的。所以这里的这个条目最终只是一堆力的所有者，这仍然是假的。所以，我们最终只是往下走。我们最终得到了这个矩阵，它……</font></font></p><p>But here we see true or false is false. True or false and control
            pulses are all false, is false. Although, sorry, true and false is
            false. True impulses is always false. So this entry here just ends up
            being the owner of a bunch of forces, which is still false. So, we end
            up simply going down. We end up with this matrix here, which…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这里的一个条目代表什么呢？这些是蛋糕，这些是范畴论映射。是范畴论。</font></font></p><p>And so, what one of the entries here representing? This is these are
            the cakes, and these are the category theory maps. Are category
            theory.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以你看，如果我提供零个范畴论，我会得到……等等，什么？蛋糕。我一生中租了这么多蛋糕。好吧。我做一个范畴论，我可以得到零个蛋糕。但如果我提供任何范畴论，我就可以得到我想要的任何蛋糕，我想要的所有蛋糕，每一件东西，这就是这张图中发生的事情，对吧？</font></font></p><p>So you see that from if I provide zero category theory, I get… wait,
            what? Cakes. And I rented all this one cake my life. Okay. I do a
            category theory, I can get zero cakes. But if I provide any category
            theory, I’m good to any cake I want, and all the cakes I want, every
            single thing, which is what’s happening in this diagram right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可能想缩小类别理论的范围。除了这里的任何选项之外，如果没有类别，您需要镜像，那么有一个绿色箭头。右边有一个绿色箭头，一直向右，一直向右。是的，就在那里？是的，谢谢。好的。</font></font></p><p>You might want to narrow the category theory. Doesn’t our apart from
            any option here where if there’s no category, and you need a mirror,
            there’s a green arrow. A green arrow on the right, all the way on the
            right, all the way on the right. Yeah, right there? Yes, thank you.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">简而言之，这就是组合结构。这就是类别结构。我保证那些在单半群类别结构中的人。因此，单半群结构由……由乘积给出。我想这就是这个东西在这里所说的。</font></font></p><p>That’s compositional for pumped us in a nutshell. That’s the category
            structure. I promise those in monoidal category structure. So the
            monoidal structure is given by… is given by the product. I guess that’s
            what this thing says here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，给定对象 p 和 q，是的，这指的是张量积，即 p 乘以 q 作为每个集合。给定两个参数，它们是从 p 乘以 q… 哦，是的，乘以 q 到真假的映射。我能做的就是把这两个参数放进去。所以我有一个从 p 乘以 q 到 p 乘以 q 的函数，以及一个从 r 到 x 的函数。然后我可以通过手工将这三个组合在一起，得到一个从 p 乘以 r 到 q 乘以 s 的函数。</font></font></p><p>So, given the objects p and q, and yeah, that refers to the tensor
            product, to the p times q as a per set. And given two parameters, which
            are maps from p times q… oh, yup, times q to true false. What I can do
            is I can put the two parameters. So I have a function from p times q to
            p times q, and a function from r to x. Then I can combine these three
            together by taking hand to get a function from p times r to q times
            s.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后，我想谈谈回到这个图表。到目前为止，我已经告诉过你如何运行这个东西并组合这些东西。所以在这里……是的，我可以将其与猎手身份的乘积结合起来，然后我可以组合这些猎手身份。但我的直觉告诉我发生了什么奇怪的循环。那么，牛市类别的环境结构如何捕捉这些失败者呢？</font></font></p><p>So, lastly, I want to talk about going back to this diagram. So far,
            I’ve told you how to run through this thing and compose these things. So
            here… and yes, I can take the product of this with the identity for
            hunters, and I can compose those identity hunters. But I had these sorts
            of weird loops in my intuition for what’s going on. So, how does this
            ambient structure of a bull category capture these losers?</p>
        <h2 id="compact-closed-categories-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">紧凑封闭类别和图表</font></font></h2><h2>Compact Closed
            Categories and Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有另一种结构更严谨的范畴，称为紧闭范畴。在任何紧闭范畴中，我们说 X 有对偶对象。如果存在更多电影，则没有对象。所以，它打破了另一个范畴，我们称之为 C。因此，我们想要从 A 到 X 对偶张量 X 的态射。你知道，我们有一个从 X 张量 X 到恒等项 epsilon 的态射，这样在弦图中，这个东西有 Ada，可以写成从运动单元到 X 对偶张量 X 的态射。我们可以用 epsilon 进行这种组合。所以现在我们有了一个从 X 点 F 到 X 点的映射。我希望这是 X 点的恒等项。类似地，我们可以从另一个方向组合它们。所以，这最终会变得很拗口。</font></font></p><p>And so there’s another, even more structured form of category known
            as a compact closed category. So, in any compact closed category, we say
            that X has dual objects. So, there are no objects if there exists more
            films. So, it’s smashing another category, let’s call it C. And so, I
            then we want morphisms from A to X dual tensor X. You know, we have a
            morphism from X tensor X to the identity epsilon, such that in string
            diagrams, so this thing has the Ada and be written as a morphism from
            the motor unit to X dual tensor X. And we can perform this composition
            with epsilon. And so now we have a map from X dot F to X dot. And I want
            this to be the identity of X dot. And similarly, we can compose them in
            the other direction. So, this ends up being a mouthful.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接下来，例如：麦克马斯特。这是身份。嗯。那么，接下来，隔壁，例如。接下来，你的对象如果有两个态射，eta 和 epsilon，它们遵循这两个方程，这两个方程写在弦图中。所以，如果你熟悉这个例子，你应该想到的原型是一个向量空间，它是这扇门上的有限维向量空间，这就是名字的由来。</font></font></p><p>Next, example: McMaster. This is the identity. Mm. So, next, next
            door, example. Next up, your objects if there are two morphisms, eta and
            epsilon, that obey these two equations, which are written in string
            diagrams. So, the prototype you should have in mind here, if you’re
            familiar with this example, is a vector space, and it’s a finite
            dimensional vector space on this door, which is why the name comes
            from.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，什么是紧致闭范畴？紧致闭范畴是具有有限维向量空间的范畴。还有一种范畴就是这个，这是与我们相关的例子。所以，你可能会问，在这个范畴中，除了我们提到的，还有其他什么？是的，V 目标是对偶向量空间。让我们来看看。如果我们在 P 上有一些燃料，那么我们取 P 星等于相反的先验。但是如果我说 P 是双数，你会问我从一到 P 乘以 P 向上的第一个猎人，以及从 P 向上乘以 P 到一的 pro 函数。</font></font></p><p>So, what is a compact closed category? A compact closed category is a
            category with objects, finite dimensional vector spaces. There’s also
            the category is performed to this, and this is the example that’s
            relevant to us. So, you might ask, in this category of effluvium for
            pumped us, what other doles? Yeah, the V goal is the dual vector space.
            Let’s go here. If we have some fuel on a P, then we take P star to be
            equal to the opposite prior. But then if I say P off is the dual, you’re
            going to ask me for a first hunter from one to P times P up, and also a
            pro function from P up times P to one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么这些偏好是什么？嗯，一个从 P 乘以 P 直到 1 的 pro 函数和一个从 1 开始的函子是一样的，后者只是从 1 到 P 乘以 P 直到 1。还有一个 pro 函子。它有一个从这里到这里的函子，它会多次检查它们。所以，给定一对 X 和 Y，抱歉，他也搞错了。鉴于此，我们称它们为 P 和 Q。实际上，如果你取一对 P 和 Q，那么如果 P 小于 Q，则返回 true，否则返回 false。</font></font></p><p>Okay, so what are these preferences? Well, a pro function from P
            times P up to one is the same thing as a functor from one off, which is
            just one to P times P up to one. And there’s a pro functor. It has a
            functor from here to here, which reviews many times, corn s them. So,
            given a pair X and Y, sorry, he’s also the wrong way around. Given that
            let’s call them P and Q. Actually, if you take a pair P and Q, then you
            return true if P is less than Q and false if it’s not.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，从 P 乘以 P off 到 1 的 pro 函数与从 Q 乘以 Q op 到 1 的函子相同。我们都可以看到你说的是同样的水。你可能会注意到这些 prounctor 类似于恒等函子，就像 David 昨天提到的鸡尾酒中的身份一样。这有点像紧凑闭类别中发生的事情。因此，具体来说，在紧凑闭类别中，你有这些相同的方程，或者精确的方程。</font></font></p><p>Similarly, a pro function up from P times P off to one is the same as
            a functor from Q times Q op up to one. And we can all see you back for
            saying the same water. You might notice that these profunctors resemble
            the identity functor, much like the identity in a cocktail David
            mentioned yesterday. That sort of is the flavor of what’s going on in
            the compact closed category. So, in particular, in a compact closed
            category, you have these same equations, or the exact equations.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们曾简要提到过，我们处于类别的结构中。我们经常使用特殊图标来使它们看起来更像是结构的一部分。生命是假设，是您正在思考的一点数据。因此，在这种情况下，我们只是……这解释了我们在此图中的工作方式。所以，这一半代表这个单位，好吗？你知道，那里有一个函子。所以现在，由于这正确地代表了一个配置文件选项卡，您可以做您的事情……这是一个带有 profunctor 张量的 profunctor。我们用这个东西来计时。您组合并跨越，您可以通过矩阵乘法计算此处表示的可行性关系。因为他们为我放了一个围绕 epsilon 的框。之后……好吧……所以我通过我更纯粹的中心逃脱了，就像这样。这个东西可能由……表示。好的，好的。如果您有任何问题，请继续关注，或者只是打个招呼。</font></font></p><p>And we sort of briefly mentioned at some point that we’re in a
            structures for and into the structure of the category. We often use
            special icons for them to make it seem more part of the structure. Life
            is the hypothesis, a bit of data that you are thinking about. So, in
            this case, we just… and this explains how we’re working in this diagram
            here. So, this half here represents this unit, okay? You know, for a
            functor there. And so now, since this properly just represents a profile
            tab, you can do your things where you… this is a profunctor tensor with.
            We times it with this thing. You compose and you go across, and you can
            compute the feasibility relation represented here just by matrix
            multiplication. Because they put a box around epsilon just for me.
            After… well, so… so I escaped via my more only pure center like this.
            This thing might be represented by… Okay, okay. Stick around if you have
            any questions, or just say hi.</p>
        <h1 id="applied-category-theory.-chapter-5-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 5 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 5, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 26 日) — 50:57 </font></font><a href="https://youtube.com/watch?v=33yVpzPOLjM"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=33yVpzPOLjM</font></font></a></p><p> 6
            years ago (Jan 26, 2019) — 50:57 <a href="https://youtube.com/watch?v=33yVpzPOLjM">https://youtube.com/watch?v=33yVpzPOLjM</a></p>
        <h2 id="summary-8"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本 MIT 18S097 课程由 David 和 Brendan Fong (Spifong) 教授，介绍了 Claude Shannon 发明的信号流图。讲座介绍了信号流图，即使用线、点和装置元素（代数结构）表示变量之间的线性关系的图表。视频解释了这些图如何表示乘法和加法等运算，以及如何根据控制理论解释它们。然后，讲座定义了 props（一种特殊类型的单半群类别），并讨论了字符串图作为这些 props 的语法。最后，介绍了自由 props 的概念，其中态射是具有类型的端口图。</font></font></p><p>This MIT 18S097 Course, taught by David and Brendan Fong (Spifong),
            introduces signal flow graphs, invented by Claude Shannon. The lecture
            covers signal flow graphs as diagrams representing linear relations
            between variables, using wires, dots, and elements of a rig (algebraic
            structure). The video explains how these graphs represent operations
            like multiplication and addition, and how to interpret them in terms of
            control theory. The lecture then defines props, a special type of
            monoidal category, and discusses string diagrams as syntax for these
            props. Finally, the concept of free props is introduced, where morphisms
            are port graphs with types.</p>
        <h2 id="signal-flow-graphs-and-props"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图和道具</font></font></h2><h2>Signal Flow Graphs and Props</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，今天我们来谈谈激励思想，也就是所谓的信号流图。重点是讨论所谓的 props。</font></font></p><p>Okay, so today we’re talking about the motivating idea, which is
            something called signal flow graphs. The point is to talk about things
            called props.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是信号流图的示例。信号流图由克劳德·香农于 20 世纪 40 年代发明，用于放大器、滤波器和网络物理系统。该图与我在此处绘制的图类似。它适用于任何设备。</font></font></p><p>Here’s an example of a signal flow graph. Signal flow graphs were
            invented by Claude Shannon in the 1940s, and they’re used in amplifiers,
            filters, and cyber physical systems. The picture is like the one I’ve
            drawn here. It makes sense over any rig.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">布伦丹明天被留在了钻机上。但它基本上，基本上就是一个戒指，如果你知道那是什么的话。然后，把戒指拿走。如果我要……你感兴趣。这里的钻机是我们的快速出口，SS 大学。</font></font></p><p>Brendan was left on a rig tomorrow. But it’s basically, basically a
            ring, if you know what that is. Then, take the ring. If I was going to…
            you’re interested. The rig here is our Rapid Exit, SS University.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的意思是，信号流图中允许绘制的是线、开点和闭点。这些图片允许您在结构中写入任何元素。结构是一种代数结构，就像没有负数或没有 m 的环。在这个结构中，您可以在此处绘制任何这些符号。</font></font></p><p>What I’m saying is that the things allowed to draw in signal flow
            graphs are wires, open dots, and closed dots. These pictures here allow
            you to write any element in the rig. A rig is an algebraic structure,
            like a ring without negatives or, in, without an m. In this rig, you’re
            allowed to draw any of those symbols here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当你将它们并联时，这意味着相乘。当你将它们用点串联时，这意味着相加。但我们很快就会谈到这一点。</font></font></p><p>When you put them in parallel, it means multiply. When you put them
            in series with a dot, that kind of means add. But we’ll talk about that
            soon.</p>
        <h2 id="signal-flow-graph-interpretation-and-linear-combinations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图解释和线性组合</font></font></h2><h2>Signal
            Flow Graph Interpretation and Linear Combinations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这张图这里说的是黑色节点对应的是复制，白色节点对应的是添加。</font></font></p><p>So, what this picture here says is that the black node corresponds to
            copy, and the white node corresponds to add.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这句话的意思就是我要在 m 上加 1。我要取 f，无论输出力是多少，或者 x，James Park，乘以 1/m。有些东西进来了，有些信号。我要对它进行积分。那将是 s 代表的……所以我把它变成了一个积分。我要把它加到 u 上。我还要把它加到 a 乘以 u 加上 b 乘以这个的积分的 k 倍上。</font></font></p><p>So, what this says is that I’m going to add one over m. I’m going to
            take f, whatever output force or whatever x, James Park, multiplied by
            1/m. Some stuff is coming in, some signal. I’m going to integrate that.
            That would be s stands for… so I turned it into an integral. And I’m
            going to add to that u. I’m also going to add to that some k times the
            integral of a times u plus b times whatever this is.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但我知道，这是相等的，因为有复制节点。因此，b 既等于访问，也等于这个东西，即 u 乘以 b 然后积分，乘以 p。&nbsp;</font></font></p><p>But this, I know, is equal, because of the copy nodes. So, b is both
            equal to visiting and equal to this thing, which is u and multiplied by
            b and then integrated, multiplied by p.&nbsp;</p>
        <h2 id="signal-flow-graphs-and-control-theory"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图和控制理论</font></font></h2><h2>Signal Flow Graphs and
            Control Theory</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是它的意思。换句话说，可能的集合……这代表了力和……我忘了这是什么……对于一些控制理论图，初始……不断出现的东西。这是速度。我忘了深度……这代表什么。但这是这个变量、这个变量和这个变量之间的关系。并且一个关系不断被维持，就是这里的这个关系。</font></font></p><p>This is what this says. In other words, the set of possible… this
            represents a relation on force and… I forget what this is… to some
            control theory diagram, initial… something that’s coming in constantly.
            This is the velocity. And I forget what the depth… what this represents.
            But it’s a relationship between this variable, this variable, and this
            variable. And a relation is constantly being upheld, is this relation
            here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是信号流图的想法。</font></font></p><p>So, that’s kind of the idea of signal flow graphs.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。t，t 实际上只是一个虚拟变量。所以，你可以……这些都是 t 的 u，t 的 u。</font></font></p><p>Yeah. t, t is really just a dummy variable. So, you could just… these
            are all u of t, of t.</p>
        <h2 id="signal-flow-graphs-as-linear-operators"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图作为线性算子</font></font></h2><h2>Signal Flow Graphs as
            Linear Operators</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这只是在装置中说的，我们甚至不需要担心 t 是什么。这只是一个极限。这只是积分作为线性算子。所以，是的。但积分作为线性算子，意味着这是基本信号流图变量中的线性表达式。它从这里开始这张图片。所以，我说的是：每次你看到一个复制节点，最后，到最后，我们将在下一节课结束时查看这些内容并提供反馈。</font></font></p><p>And it’s just saying in the rig, we don’t even need to worry about
            what t is. This is just a limit. This is just the integral being a
            linear operator. And so, yeah. But the integral, being a linear
            operator, means this is a linear expression in the variables of the
            basic signal flow graph. It’s starting this picture here. So, what I
            said is: every time you see a copy node, so in the end, by the end,
            we’ll be looking at these things with feedback on the end of the next
            lecture.</p>
        <h2 id="feedforward-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">前馈信号流图</font></font></h2><h2>Feedforward Signal Flow
            Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在本讲座中，我们将只讨论前馈的简单信号流图。无论您看到什么黑点，我们都会复制。所以，我们这里有一个 x。在下一年，每当您看到其中一个放大器时，就乘以它。每当您看到白色节点时，就添加它。这是 x + 7y、5x、50x，这里我们有 x + 7y + my、2x + 14y 和 3x。</font></font></p><p>And during this lecture, we’re just going to look at simple signal
            flow graphs that are feed forward. And whatever you see a black dot, we
            do a copy. So, we have an x here. In the next year, and whenever you see
            one of these amplifiers, you multiply by it. And whenever you see a
            white node, you add. This is x + 7y, 5x, 50x, and here we have x + 7y +
            my, and 2x + 14y, and 3x.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可能已经看出来了，由于我们只能乘以标量、装备元素，或者添加或复制，因此到最后，我们只会在每个输出中的每个变量中获得一些线性组合。喝点首字母，好吗？就是这样。</font></font></p><p>As you can kind of tell, since we’re only allowed to multiply by
            scalars, elements of our rig, or add or copy, by the end, we’re just
            going to get some linear combination in each variable in each of these
            outputs. Drinks of the initials, okay? So, that’s that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果您希望将每条输出线都保持完整，那么，它就像是从 x 到 y 的所有路径的快速总和，沿着该路径在设备上进行放大，即智能的 x1 x2 输入。</font></font></p><p>So, if you wanted to kind of stay all in one piece for each of these
            output wires, why, it’s kind of the sum over all in quick steps of the
            somewhat paths from x to y of the amplification along that path times in
            the rig, the brainy x1 x2 input.</p>
        <h2 id="calculating-paths-in-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算信号流图中的路径</font></font></h2><h2>Calculating Paths in
            Signal Flow Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">比如，也许应该说 x1 x2。我会在这里用 SVC 将其相加。所以，你看看所有的路径。从这个人到这个人的所有路径是什么？嗯，这是顶部路径，这是底部路径。在顶部路径中，我乘以 1，在底部路径中，我乘以 2。因此，我得到了 3x。</font></font></p><p>Like, maybe just should have said x1 x2. I would add this up in SVC
            here. So, you kind of look at all the paths. What are all the paths from
            this guy to this one? Well, there’s this top path, and there’s this
            bottom one. In the top path, I multiplied by 1, and the bottom path, I
            multiplied by 2. And so, I get 3x.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于这个 y，从他这里到这里有多少条路径？没有路径。关于此图还有什么疑问吗？</font></font></p><p>For this y here, how many paths are there from him, from from here to
            here? There are no paths. Any questions about this diagram?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，今天的目标是讨论这个图表的位置。</font></font></p><p>So, the goal of today is to talk about where this diagram lives.</p>
        <h2 id="props-as-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Props 作为类别</font></font></h2><h2>Props as Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它存在于所谓的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">prop</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，这是一种特殊的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">石油类别</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。所以，这张图片和前一篇文章中涉及的数学知识是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">props</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ... </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">props</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            曾经代表产品和排列类别之类的东西，但它不是一个很好的缩写。无助于您思考。所以我们就称它为</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">props</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它是简单的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">米勒类别</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。这些是弦图，就像您使用弦图呈现的幺半群类别，或使用生成器和关系呈现的组一样。这就是使用生成器和方程式呈现的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">props</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font></p><p>And it lives in what’s called a <em>prop</em>, which is a special
            kind of an <em>oil category</em>. So, the math involved here in this
            picture and the previous thing is that <em>props</em>… <em>props</em>
            used to stand for something like product and permutation category, but
            it’s not a very good acronym. Doesn’t help you think about it. So, we
            just call it <em>props</em>, which are simple <em>miller
                categories</em>. These are the string diagrams, just like you’ve got a
            presented monoidal categories using string diagrams, or presented groups
            using generators and relations. That are presented <em>props</em> using
            generators and equations.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，我们还将讨论字符串图，特别是语法和语义。以及健全性。</font></font></p><p>And then, we’re also going to talk about string diagrams, and in
            particular, syntax and semantics. And soundness.</p>
        <h2 id="string-diagrams-and-syntaxsemantics"><font style="vertical-align:inherit"><font style="vertical-align:inherit">字符串图和语法/语义</font></font></h2><h2>String Diagrams and
            Syntax/Semantics</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这就是我们接下来一天和明天要讨论的内容。这些字符串图是某种东西的语法。语义可能是这样的：它发生在某个幺半群类别中，比如线性关系，或者类似的东西。我们会说它是可靠的。如果你能证明任何东西，比如使用字符串图操作一个图等于另一个图，在幺半群类别中为真，我们会说它是可靠的。那最好是真的；否则，它就不可靠。如果你能证明错误的东西，那它就是一个糟糕的推理系统。如果你能在幺半群类别中证明任何东西，比如任何证明一个态射不等于另一个态射的证明，都可以通过操作这些图来证明，那么它们就被称为完整的。这就是图形证明系统的可靠性和完整性。</font></font></p><p>So, this is kind of what we’ll be talking about over the next day and
            tomorrow. These string diagrams are syntax for something. The semantics
            could be something like this: it takes place in some monoidal category
            of, say, linear relations, or something like that. We would say that
            it’s sound. We’d say it’s sound if anything you can prove, like one
            diagram equals another using string diagram manipulations, is true in
            the monoidal category. That better be true; otherwise, it’s not sound.
            It’s a bad reasoning system if you can prove false things. And they
            would be called complete if anything you can prove in the monoidal
            category, any proof that one morphism isn’t equal to another, say, can
            be proved by manipulating just these diagrams. That’s soundness and
            completeness of a graphical proof system.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我来定义一下。粗略地说，它是一个大致的幺半范畴，或者一个对称的幺半范畴。</font></font></p><p>Okay, so let me define it. So, roughly speaking, it’s a roughly
            monoidal category, or a symmetric monoidal category.</p>
        <h2 id="monoidal-categories-and-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">幺半群类别和预序</font></font></h2><h2>Monoidal Categories and
            Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">昨天已经定义了。类中的一个方面——一个集合——对象集。我可能应该说“类”，但它只是意味着一个大集合，一个对象集。这个单半群类别的例子将被称为 C。花哨的 C。我只是提醒你这是什么。所以，它是一个对象集。显然，它是一个集合——比睡衣更高级。被称为对象的东西。并提供一对对象——哦，还有一个函子。哦，对不起，我应该用正确的方式来表达。</font></font></p><p>It was defined yesterday. One aspect in a class—a collection—set of
            objects. I should probably say “class,” but it just means a large set, a
            set of objects. And this example of a monoidal category will be called
            C. The fancy C. I’m just reminding you what this is. So, it’s a set of
            objects. Obviously, it’s a set—a step up from sleepwear. Things called
            objects. And furnish a pair of objects—oh, and a functor. Oh, sorry, I
            should just say it the right way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。它是一个范畴。一个范畴。首先，我们把它看作一个元素。这些必须满足一些规则，比如它是一个幺半群范畴，这意味着这个张量是结合的。那个张量和我是这个张量的单位，诸如此类。我想我也应该提到它。我说它是对称的。所以，我还给了自己一个从一个张量积到另一个张量的映射。对吧？我有一个映射，C 张量 C 到 C。有时你会看到它们交换。你应该能够看到它自然是这样的。一个函子是这样的。无论如何，我这里那里应该是自然同构的。这只是回顾我们昨天讨论的内容。</font></font></p><p>All right. It’s a category. A category. One, we just think of it as
            an element. And these have to satisfy some rules that say things like
            it’s a monoidal category, which means that this tensor is associative.
            That tensor and I are unit for this tensor, and things like that. I
            guess I should also mention it. I said it’s symmetric. So, I also give
            myself a map from from one tensor product to another. Right? That I have
            a map, and C tensor C to C. Sometimes you see that swaps. And you should
            be able to see it’s naturally this way. A functor this way. I here and
            there should be natural isomorphisms for me anyway. This is just
            reviewing what we talked about yesterday.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么什么是幺半群偏序集？我将假设它是一个幺半群类别，其中 C 是一个偏序集。所以，这就是我们第二天或第三天讨论的内容。一个幺半群预序，其中 C 是一个预序。记住，预序是一个态射很容易的类别。它们很容易的原因在于，在任何两个对象之间，要么有一个，要么没有。它永远不会——要么只有一个，要么没有。</font></font></p><p>Okay, so what is a monoidal poset? I’m going to posit that as a
            monoidal category where C is a poset. So, this is what we talked about
            the second or third day. A monoidal pre order where C is a pre order.
            Remember, a pre order is a category where the morphisms are easy. And
            the way that they’re easy is that between any two objects, there either
            is one or there isn’t one. It is never—there’s only one or not.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这真的很容易。如果有的话，就有一个。当你从中去掉一个小于或等于时，就像这样可以表示一个张量。P 小于或等于 C。如果没有，我们就不能画出小于号。我们不能画出方框。所以，预序是一个以某种方式变得简单的类别，即它具有非常简单的态射。要么有一个，要么没有。</font></font></p><p>So, it’s really easy. There is one if there is one. When you drop a
            less than or equal to from, like this could represent a tensor. P is
            less than or equal to C. And if there isn’t one, we’re not allowed to
            draw the less than sign. We’re not allowed to draw the box. So, a pre
            order is a category that’s made easy in a certain way, namely it has
            very simple morphisms. There either is one or there isn’t one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我之所以谈论这个，是因为 prop 是一个幺半群范畴。在这种态射中，对象既容易，又不容易，两者的方式完全相同，或者说方式类似。但这里的类比是它们很容易。那么，它是什么呢？它是一种中间范畴，我见过的只有自然数。</font></font></p><p>And the reason I’m talking about that is that a prop is a monoidal
            category. The morphisms where the objects are easy and they are not easy
            in exactly the same way, or in an analogous way. But the analogy here is
            that they’re easy. So, what is it? It’s such a middle category such that
            I’ve seen is just natural numbers.</p>
        <h2 id="props-as-monoidal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Props 作为 Monoidal 类别</font></font></h2><h2>Props as Monoidal Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">没有单位是零；它必须在其中——它必须是一个客观的 C，这是一个自然数。它是什么自然数？零。并且对于所有，并且变成 M，看看我是否有两个对象和它们的张量幂定义。所以，Prop 是一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">ab</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">特殊的幺半群类别，其中对象只具有一些有限基数。它们只是有限基数。它们只是一个数字。你如何表示这个数字？你显然用三条线来表示数字 3。所以，在这些弦图中，我将绘制每个对象，它们只是一些线。张量积——这是一个张量 1 张量 1——这就是我们昨天绘制平行线的方式。我们总是并行绘制张量，现在我们这样做，每条线都是 1。</font></font></p><p>No unit is zero; it has to be in it—it has to be an objective C, and
            that’s a natural number. And what natural number is it? Zero. And such
            that for all, and become an M, and see if I have two objects and their
            tensor power defined. So, Prop is an <em>ab</em> special monoidal
            category where the objects just have some finite cardinality. They’re
            just a finite cardinality. They’re just a number. And how do you
            represent that number? You represent the number 3 in obviously a as
            three lines. So, within these string diagrams, I’m going to draw each
            object that is just a number of lines. The tensor product—this is one
            tensor 1 tensor 1—and that’s how we were drawing parallel lines
            yesterday. We always draw tensors in parallel, and now we’re doing that
            where each line is a 1.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我给你举几个例子。</font></font></p><p>Okay, so let me give you some examples.</p>
        <h2 id="examples-of-props-and-matrices"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Props 和矩阵的示例</font></font></h2><h2>Examples of Props and
            Matrices</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵 Prop 称为 Mat over a rig。但你可能不知道什么是 rig。我想，Brendan 明天（星期一）会找到它。它基本上是一个代数对象，你可以在其中添加和乘以事物。但由于我不会假设这一点，我会在那里放两个卷轴，因为这是一个例子。所以，Map sub R — 将这些矩阵放在它们的卷轴上。这是个问题。所以，对于它来说，要成为一个 Prop，我的意思是它是一个以自然数为对象的单类。</font></font></p><p>Matrices Prop is called Mat over a rig. But you might not know what a
            rig is. Brendan’s going to find it tomorrow, Monday, I think. It’s
            basically an algebraic object where you can add and multiply things. But
            since I won’t assume that, I’ll put two reels there because that is an
            example. So, Map sub R—make these matrices over their reels. That’s a
            problem. So, for it to be a Prop, what I’m saying is it’s a monoidal
            category where the objects are natural numbers.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，它们是什么？好的，那么它是一个幺半群范畴吗？它的对象是什么？我已经告诉过你如何张量以及单位是什么，但是态射是什么？所以，记住，每当我们看到一个范畴时，我们都会写</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c xy 来表示从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">y 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有态射的 hom 集</font><font style="vertical-align:inherit">。那么，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Mat</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> R 是什么？比如说，从 1 开始——不记得到另一个——不，我的意思是这个。这很简单。你也可以在这里使用那个符号。态射吗？实际上不是矩阵。我以为你是在说这个。你知道，那应该是个玩笑。好的，是的，是的。矩阵——符号工作得很好，因为你无法区分矩阵的通常符号和我们在这里使用的符号。</font></font></p><p>So, what are they? Okay, so is it a monoidal category? What are its
            objects? I’ve already told you how to tensor and what the unit is, but
            what are the morphisms? So, remember whenever we have like, see a
            category, we would write <em>c</em>xy to mean the hom set of all
            morphisms from <em>x</em> to <em>y</em>. So, what is <em>Mat</em>R from,
            say, 1—not remember to another—no, I mean this. That’s a simple. You
            could also use that symbol here. Are the morphisms? Not matrices,
            actually. I thought you were talking about this way. You know, that’s
            supposed to be a joke. Okay, yes, yes. The matrices—the notation works
            very well in the sense that you can’t distinguish between the usual
            notation for matrices and the and the notation we’re using here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我开始了，然后，问题是：你如何组合两个矩阵并让它们成为张量？所以，如果我有一个矩阵</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，你有一个矩阵</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，那么它们的复合矩阵应该是哪个？它必须是一个从
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵，正如你所见——一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵。你可以猜出哪一个。它是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。如果你担心……是的，好的。所以，它是……
        </font></font></p><p>Okay, so I start, and then, but then the question is: how do you
            compose two matrices and have you tensor two matrices? So, if I have a
            matrix <em>m</em> and you have a matrix <em>n</em> and <em>p</em>, then
            what matrix should be their composite? It has to be a matrix from
            <em>m</em> to <em>p</em>, as you can—an <em>m</em> by <em>p</em> matrix.
            And you can guess which one. It’s <em>m</em> times <em>n</em>. And if
            you’re worried that… yeah, yeah, okay. So, it’s…
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，我想我在这里停顿一下，因为还有另一个问题叫做“map off”，其中对象是相同的，因为所有道具都有相同的对象，但态射只是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">mxm</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵。或者夹柱，我总是——我认为人们通常喜欢——我喜欢 mxn 是 mx m。我认为这是人们通常绘画方式的转置。她通常喜欢将事物乘以右边的列向量，而我喜欢将事物乘以左边的行向量，只是因为我喜欢事物与板子的方向相同。这不是很——它们是内置作物，它们都有效。所以，如果这个有错误的方差，那就好了，就这样吧。</font></font></p><p>Yeah, I guess I’m pausing a bit here because there’s another problem
            called “map off” where the objects are identical because all props have
            the same objects, but the morphisms are just <em>m x m</em> matrices. Or
            the clamp post, and I always—I think people generally like—I like it so
            that m x n is m x m. And I think that’s kind of a transpose of the way
            people usually draw. She will usually like to multiply things by a
            column vector on the right, whereas I kind of like to multiply by a row
            vector on the left, just because I like things to go the same direction
            as the board. It’s not very—they’re built crops, and they both work. And
            so, if this one has the wrong variance, and just okay, so okay.</p>
        <h2 id="composition-and-tensoring-of-matrices"><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵的合成与张量</font></font></h2><h2>Composition and Tensoring
            of Matrices</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后问题是：但是你如何对两个矩阵进行张量处理？所以，如果我有一个 m 乘 n 的矩阵，称为 M，而你有一个 m' 乘 n' 的矩阵，称为 M'，那么它们的张量应该是多少？它应该是 m — 嗯，首先矩阵的维度是多少？是的，m 加 n。需要从中得到一个 m 加 m' 乘 n 加 n' 的矩阵。我想我们打算称之为 n 加 m'。我可能应该在这里这么说。在 prop 中，我们通常会写成表示我们期望 — 最常见的符号或默认符号是零中的加号。</font></font></p><p>And then the question is: But how do you tensor two matrices? So, if
            I have an m by n matrix called M, and you have an m’ by n’ matrix, M’,
            then what should their tensor be? It should be an m—well, what’s the
            dimension of the matrix first of all? Yeah, m plus n.&nbsp;Need from this to
            get an m plus m’ by n plus n’ matrix. And I guess we’re planning on
            calling it n plus m’. And I probably should have said that in this. In a
            prop, we usually write to indicate that we’re expecting the—the most
            common notation, or the default notation, would be a plus in a zero.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，所以我们想以某种方式将两个矩阵相加，但它们的维度不同。那么，这意味着什么呢？是的，有很多块。是的，所以也许我们喜欢用圆圈写加法。无论如何，在线性代数的深度中，你可以将“带圆圈的加法”读作“张量”。</font></font></p><p>Okay, so we’re thinking we’re going to add two matrices somehow, but
            there are different dimensions. So, what could this mean? Yeah, plenty
            of block. Yeah, so maybe we like to write plus with a circle. Anyway, in
            depth in linear algebra, you read “plus with a circle” as “tensor.”</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我举个例子。假设你有矩阵 1 2、3 4、5 6，你想得到——我想我会在那里画一个圆圈——再加上矩阵 8 9。所以，这是一个从 2 到 3 的矩阵，这是一个从 1 到 2 的矩阵，或者好吧，这是一个应该是 3 乘 5 的矩阵：1 4、2 3、2 5、0 0、0。</font></font></p><p>So, let me just give an example. So, suppose you had the matrix 1 2,
            3 4, 5 6, and you want to get—I think I will put the circle there—plus
            add to it the matrix 8 9. So, this is a matrix from, say, 2 to 3, and
            this is a matrix from 1 to 2, or alright, this is the matrix that’s
            supposed to be a 3 by 5: 1 4, 2 3, 2 5, 0 0, 0.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">张量积总是——总是感觉平行。在这些图片中是平行的。您可以看到张量，或者我们一直将张量积视为并行结构。在这里，我们再次将这两个东西并行，您可以看到它们在这张图中没有相互作用。这里发生的一切都与那里发生的完全不同。所以，我想现在我会让你们自己讨论一下，讨论合作伙伴，以及我们迄今为止讨论过的一切。</font></font></p><p>The tensor product is always—be always kind of feels parallel.
            Parallel in these pictures. You can see tensor, or we’ve always talked
            about tensor product as a parallel structure. And here again, we have
            these two things in parallel, and you can see that they’re kind of not
            interacting in this picture. Whatever is happening here is kind of
            separate from what’s happening there. So, I think now I’ll let you guys
            just talk amongst yourselves, discuss the partner, everything we’ve
            talked about so far.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">无论你对什么感兴趣，无论你不明白什么。他们会说，如果你愿意，你可以找个人告诉他们。我不知道该怎么做。是的。我不知道。剩下的抄本缺少了，所以这个……你是否被迫像这样定义这个圆加法运算，或者你可以像我一样选择一个不同的……是的，在技巧上，这是正确的大小？是的，你可以选择任何一个，只要一件事：维度是加法，第二件事是它具有结合律。你必须选择一个单位。</font></font></p><p>Whatever was interesting to you, whatever you didn’t understand.
            They’re like, you’re doing like, find someone to tell them if you want.
            I don’t know that to see what. Yes. I don’t. By remainder of the
            transcript is missing that yeah, so this… are you forced to define this
            circle plus operation like this, or can you pick, like I did, a
            different… yeah, on tricks that’s the right size? Yeah, you can pick any
            one you want as long as one thing: the dimension is plus, and second
            thing is that it has the property that it’s associative. You have to
            pick a unit.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，顺便问一下，这里的单位矩阵是什么？它是一个零乘零矩阵。这是哪一个？所以你必须自己思考，然后弄清楚。单位。掌握诀窍。你喜欢的单半群乘积，它们必须是结合的。它必须与单位一起工作，这样它就不会改变事物，而且当你乘以它时，比如，如果我这样做——你有某种本能论证。你必须——我的意思是，必须满足定义。</font></font></p><p>So, what’s the unit matrix, by the way, here for this? I—it’s a zero
            by zero matrix. Which one is this? And so you have to think to yourself,
            yet figure. Unit. Get the trick. Monoidal product that you like, and
            they have to be associative. It has to work with the unit such that it
            doesn’t change the thing, and it has to be that when you multiply, like,
            if I do—you have some kind of instinct argumentation. You have—I mean,
            has to satisfy the definition.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果你将两个矩阵相乘，然后对另外两个矩阵进行相乘，那么同样的操作就是将这个操作重复两次并相乘。所以，一旦你掌握了所有这些东西，就很难再想出任何东西了——这是范畴论的一个优点。这里有很多，比如，它告诉你规则是什么，但当你从自然界中得到一种规则时，它们的数量就足够了。</font></font></p><p>So, it would have to be that if you multiply two matrices and do this
            thing to the multiplication of two other matrices, the same thing is
            doing the thing twice and multiplying. So, it’s like, well, once you
            have all that stuff, it’s going to be hard to think of anything
            that—that’s a nice thing about category theory. Here, it’s got so many,
            like, it tells you what the rules are, but then there’s enough of them
            that works really well when you’ve got one kind of from nature.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但如果不是来自自然界，就很难找到。但还有另一种。当蒂姆提出另一种幺半群积时，它被称为矩阵的张量积，或克罗内克积。你在那里做的是制作一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> × </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m'</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ×
             </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">n' 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵。
        </font></font></p><p>But it’s really hard to find one if it’s not coming from nature. But
            there is another. When Tim suggested another monoidal product, which is
            called the tensor product of matrices, or Kronecker product. And what
            you do there is you make an <em>m</em> × <em>m’</em> by <em>n</em> ×
            <em>n’</em> matrix.
        </p>
        <h2 id="alternative-monoidal-products"><font style="vertical-align:inherit"><font style="vertical-align:inherit">替代的 Monoidal 产品</font></font></h2><h2>Alternative Monoidal
            Products</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但那会与“是”相矛盾。所以，它不再是一个 prop，但它仍然是一个 monoidal 类别。它基本上就像一个乘法块。我稍后会告诉你。但你会觉得——这将是一个——而不是一个 3 × 2，乘以 3 乘以 1 × 2，我想，这将是一个 2 × 6 矩阵，我只需将这个矩阵</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">a</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            乘以</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，然后将其差乘以 9。</font></font></p><p>But that would contradict yes. So, it’s not a prop anymore, but it’s
            still a monoidal category. And it would be basically like a block of
            multiplying. I can tell you about that later. But you would kind of—this
            would be a—instead of a 3 × 2, by 3 times a 1 × 2, I guess, would be a 2
            × 6 matrix, where I would just kind of take this matrix <em>a</em>
            multiplied by <em>b</em>, and next enough with this difference times
            9.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就是这样。这也行得通。不会有问题。还有其他问题吗？这是另一项工作。我的意思是，这是矩阵类别上的另一个单半群结构。但如果你想让它保持一个支柱，我从未证明过这是唯一的支柱，但我不想与圆交叉。德里克，它与集群相比如何？圆，十字，圆被划掉的地方？也许我应该写圆加号。</font></font></p><p>That’s it. That works also. It’s not going to be a problem. Other
            questions? It’s another work by works. I mean, that’s another monoidal
            structure on the category of matrices. But if you want to keep it a
            prop, and I have never proven that this is the only one, but I wouldn’t
            want to cross with the circle. Derek, how does it compare to the
            cluster? The circle, the cross, where the circle was crossed out? And
            maybe I should be writing circle plus.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在我开始之前我并没有选择一种符号，但是这就像——这是幺半群类别的一般默认符号。</font></font></p><p>I kind of didn’t pick a notation before I started, but this is
            like—this is the general default notation for monoidal category.</p>
        <h2 id="default-notation-and-associativity"><font style="vertical-align:inherit"><font style="vertical-align:inherit">默认符号和结合律</font></font></h2><h2>Default Notation and
            Associativity</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在我说我们处于一个 prop 中，我认为 prop 的默认符号应该是 plus，或者可能是 plus。这只是一个默认符号。您可以使用任何二进制运算符、运算符符号，只要它不是单一的。澄清这一点可能会有点令人困惑：当我们说某个不是集合的东西的类别时，这不是一个严格的事物。因此，如果集合类别有对象集合和函数的态射，而矩阵类别，正如 David 刚才所说，有矩阵作为态射。所以，它只是其中之一。当我们说 X 的类别时，它有点像是人们与某种结构相关联的自然类别，仅从这个短语来看，尚不清楚它在类别中扮演什么角色。好的。</font></font></p><p>And now I’m saying we’re in a prop, and I kind of think the default
            notation for a prop should be plus, or maybe plus. It’s just a default
            notation. You can use any binary operator, operator symbol you want, as
            long as it’s not one thing. To clarify that, might be slightly
            confusing: when we say the category of something that’s not a set,
            that’s not a rigorous thing. So, if the category of sets has objects
            sets and morphisms of functions, whereas the category of matrices, as
            David just said, has the matrices as the morphisms. So, it’s just sort
            of one of them. When we say the category of X, it’s sort of there’s a
            natural category that people have associated with some sort of
            structure, and it’s not clear what role that plays in the category just
            from that phrase. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想给出另一个道具的例子，这是图表的道具。</font></font></p><p>So, I want to give another example of a prop, and this is the prop of
            graphs.</p>
        <h2 id="free-props-and-signatures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">免费道具和签名</font></font></h2><h2>Free Props and Signatures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但这是一种特殊的支柱，因为它是自由支柱。我们将把它视为自由支柱生成器，就像你在某些生成器上有一个自由群，在某些生成器上有一个自由环，它是一个多项式环。你可以在一些生成器上有一个自由支柱，它将是图的支柱。</font></font></p><p>But this is a kind of special prop, and that’s because it is the free
            prop. We’re going to find it as the free prop generators, just like you
            have a free group on some generators, a free ring on some generators,
            it’s a polynomial ring. You can have a free prop on some generators, and
            it will be the prop of graphs.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是态射的一个例子。这里，a 是从 1 到 2、3 的态射，b 是从 3 到 2 的态射，c 是从 2 到 1 的态射。整个东西，我称之为 d，或者别的什么。B 是从 1 到 2 的态射。所以，图的支柱，这被称为图，它是这个幺半群范畴中的态射。这个中间范畴，这个支柱是从 2 到 2。</font></font></p><p>So, this is an example of a morphism. So, here, a is a morphism from
            1 to 2, 3, and b is a morphism from 3 to 2, and c is a morphism from 2
            to 1. And this whole thing, I call it d, or something. B would be a
            morphism from 1 to 2. So, the prop of graphs, this is called a graph,
            and it’s a morphism in this monoidal category. This middle category,
            this prop from 2 to 2.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以写下程序是什么。你可以想象一下。到目前为止，你绘制的所有字符串图都是图形。</font></font></p><p>And you can write down what a program is. You can imagine this. All
            the string diagrams you’ve drawn so far have been graph.</p>
        <h2 id="port-graphs-and-string-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">端口图和串图</font></font></h2><h2>Port Graphs and String
            Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">只是在这里，a、b 和 c 的含义不是某个程序。这不是程序或函数。它是一个道具。里面是一个图表。弦图中唯一允许你画的东西，允许你放进盒子里的东西，任何图表。所以，它有点递归，或者实际上，它有点操作性。我们将在三天后的第三章、第六章讨论操作。但是，我不是……如果……抱歉，如果这是单半群图类别中的弦图的图片，那么我们在这里讨论图表。</font></font></p><p>It’s just that here, the meaning of a, b, and c is not some program.
            This is not a program or a function. It’s a prop. Inside here is a
            graph. The only thing in the string diagram you’re allowed to draw,
            you’re allowed to put into a box, any graph. So, it’s kind of recursive,
            or really, it’s kind of operadic. And we’ll talk about operads in
            Chapter 3, Chapter 6, in three days. But, I’m not… if… sorry if this was
            a picture of a string diagram in the monoidal category of graphs, then
            in here we go graph.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但就其本身而言，这已经是一个图了。那么，我来谈谈理论上图的定义，因为它不仅仅是一张图片。你应该能够在我的计算机中对它进行编码。</font></font></p><p>But just as it is, this is already a graph. So, let me say what a
            graph is set theoretically, because it’s not just a picture. You should
            be able to encode it in my computer.</p>
        <h2 id="port-graphs-as-data-structures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">端口图作为数据结构</font></font></h2><h2>Port Graphs as Data
            Structures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，那是什么？一张……那是一张……对吧的图片。那么，程序或图形的大小或奇偶校验是多少？并且由一个资产组成，深……哦，我想它是一种元组，v……是的，我。一组顶点，这些将是照片中的盒子。两个函数，输入和输出，将每个顶点转换为自然数，或者每个盒子，我想，转换为自然数，并将每个盒子转换为另一个自然数。这些将像输入端口的数量和数字。每个盒子都有一定数量的输入和输出端口。</font></font></p><p>So, what is that? A picture of… that is a picture of… right. So, what
            is the program or graph size or parity? And consists of one asset, deep…
            Oh, I guess it’s kind of a tuple, v… Yes, and I. A set of vertices, and
            these will be the boxes that are going to be in the photograph. Two
            functions, in and out, that take every vertex to a natural number, or
            every box, I guess, to a natural number, and every box to another
            natural number. And these are going to be like a number of input ports
            and a number. Every box is given a number of input and output ports.</p>
        <ol start="2" type="I">
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我们设定，让大写 I 成为顶点中所有框的并集，a，这是步骤，让 O 成为所有框的并集。然后，在三中，我们说 yoga 是从 M ∪ O 到 I 的同构。我稍后会解释这一点，但我需要一个条件，即图 — — 因此我可以制作一个顶点集、边集和另外两个源和目标的图，它采用一条边并告诉您源的顶点和第一个目标的顶点。</font></font></p>
            </li><li>
                <p>If we set, let capital I be the union over all boxes in a vertex,
                    a, this is the step, and let O be the union over all boxes. Then, in
                    three, we say that yoga is an isomorphism from M ∪ O to I. And I’ll
                    explain this in a second, but then I need one condition, such that the
                    graph—so I can make a graph of the set of vertices, a set of edges, and
                    two more for the source and target that takes an edge and tells you a
                    vertex for a source and a vertex whose first target.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我在 2010 年中期有任何事，但我要……好的，所以在这张图片中，B 是 3。这是 A 中的一组 A、B、C。A 是多少？好吧，我说它是输入端口的数量，你可以对所有输入端口都这样做。那么，I 是多少？它有多少个元素？是的，它有六个。是的，所以它有 a1、b1、b2、b3、c1，这就是 I。它遍布每个顶点。我所有的输入端口是什么？O 是 a1，我说的不是只取一个。如果需要，你可以在这里放素数，a2、b1、b2 和 c1。</font></font></p>
            </li><li>
                <p>So, if I have anything in mid 2010, but I’m going to… Okay, so in
                    this picture, B is 3. Here’s a set, A, B, C, in A. A is what number?
                    Well, I said it’s the number of input ports, and you can do that for all
                    of them. So, what is I? How many elements does it have? Yeah, it has
                    six. Yeah, so it has a1, b1, b2, b3, c1, and that’s I. It’s all over
                    every vertex. What are all my input ports? And O is a1, say, and I’m not
                    just taking the one. You could put prime here if you need to, a2, b1,
                    b2, and c1.</p>
            </li>
            <li>
                <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，最后，对于一个小 I — — 也许我应该称它为 iota — — 我们需要一个从 M ∪ O 到 I 的映射。所以，这里的 M 是 2，输入 1，输入 2，以及并集 I。所以，N 是关于 1。这是……现在，据说，这可以用这两个集合之间的同构来表示。而同构是谁被谁喂养。所以，输出 1 由 C 的输出喂养。所以，输出 1 去往……更适合……由 D 的输出喂养。a1 由输入 1 喂养。B1 由输入 8 输出到 3 喂养。V2 由 A 输出到 B 喂养。3 由输入 C 喂养。1 由 A 输出 1 喂养，C2 由 P1 喂养。</font></font></p>
            </li><li>
                <p>And now, finally, for a little I—maybe I should call it iota—we
                    need a map from M ∪ O to I. So, M is 2 here, input 1, input 2, and union
                    I. So, N is about 1. This is… and now, supposedly, this is represented
                    by an isomorphism between these two sets. And the isomorphism is who
                    gets fed by whom. So, out 1 is fed by C’s output. So, out 1 goes to…
                    some more apt to… is fed by D’s output. To a1 is fed by input 1. B1 is
                    fed by in 8 output to 3. V2 is fed by A output to B. 3 is fed by input
                    C. 1 is fed by A output 1, and C2 is fed by P1.</p>
            </li>
        </ol>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">V. 所以，这个同构代表了这个图。然后，如果我想，我可以写下这个……这个……这个图，它不再是一个端口图，而是一个 Dobson 四点和箭头图。Dobson 箭头图要求我把……我的意思是，我想……我会放弃……所以，它基本上是说你读出来有一个……这是源，这是目标。它说我的顶点是 m，加上顶点 a、b、c，加上 n，也就是这两个。然后，对于</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">联合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">o</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的每个元素，换句话说，对于这里、这里、这里、这里、这里、这里、这里的所有东西，对于这里，我得到一个边。如果你弄清楚这是什么，这是一张与我使用这个同构来获得它的图相同的端口图的图片。抱歉，targa 阅读。</font></font></p><p>V. So, this isomorphism here represents this graph. And then, if I
            want to, I can take, I can write down this… this… this graph, which is
            like not a port graph anymore, but just a Dobson four dots and arrows
            graph. And that Dobson arrows graph asked me to put… I mean, I’d like
            to… I’ll drop… So, what it basically says that you read this out that
            there’s a… That’s the source, that’s the target. It says my vertices are
            m, plus the vertices a, b, c, plus n, which are these two here. And
            then, for every element of <em>m</em> union <em>o</em>, in other words,
            for everything it’s here, here, here, here, here, here, here, for here,
            I get an edge. And if you figure out what this is, this is a picture of
            the same port graph as a graph where I use this isomorphism to get it.
            Sorry, targa reading.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我只是想提醒你，人们可能会看到这个并称其为图表，然后说：“哦，这很明显。这些是顶点，这些是复仇者。”你知道，你是托马斯吗？我真的不喜欢这样，因为如果这不是一个图表，它就会有更多的数据。更多的数据是你在图表中无法看出我交换了这两个输入。你不是在告诉我，这就像你期待两个自然数和一个字符串，我以任意顺序将它们给你。我只是把它们扔给你。在这里，我把它们扔给你。在这里，我会小心地给你它应该在的地方。所以，对。</font></font></p><p>And I just want to warn you that people might look at this and call
            it a graph and say, “Oh, it’s obvious. These are the vertices, and these
            are the Avengers.” You know, are you Thomas? And I really don’t like
            that because if this is not a graph, it’s got more data. And the more
            data is that you can’t tell in the graph picture that I swapped these
            two inputs. You’re not telling me it’s like you’re expecting two natural
            numbers and a string, and I give you them to you in like an arbitrary
            order. I just fling them at you. Here, I’m flinging them at you. Here,
            I’m taking care to like give you the one where it’s supposed to be. So,
            right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这些被称为端口图。这些被称为工艺。</font></font></p><p>So, these are called port graphs. These are called crafts.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于这种区别或其他问题，您有疑问吗？您看到这张图片是如何通过这些数据捕捉到的吗？正如我所说，例如循环，这意味着当您绘制此图时，没有路径。因此，在端口图的图形或请求中，没有正确的路径。是的，就像您丢失了类型、标签和边缘一样。是的。所以，顶点，他们会说，你画了那些图吗？</font></font></p><p>Any questions about that distinction or about anything else? Do you
            see how this picture is captured by this data here? And, as I said, such
            as a cyclic, which means that when you draw this graph, there’s no,
            there’s no path. So, there’s not correctly like in a graph or petition
            of the port graph. Yeah, like you’re losing like the types, like the
            labels, so the edges. Yeah. So, a vertex, the way they would say to
            thing, did you draw those pictures?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你在谈论一个图。他们会说顶点配备了输入和输出类型，或者类似的东西，就像期望这个东西期望一定数量的隐式。你看，他们不喜欢看到，而不是只是给定的，这些期望将由实际的东西来满足，而不仅仅是一些东西，不仅仅是三个，而是这些具体在这个是数据，未命中数据，这样这是一个病态。这个数据和这个数据是一样的。是的，我的意思是，这个病态的反馈，不是没有反馈，和交流是一样的。是的，只是每个人都已经知道什么是无环图。所以，我只需要这些数据，并弄清楚如何找到我需要检查它们是否是循环的图，你只需写下它，就像这里是你要写的一样。</font></font></p><p>You’re talking about a graph. They would say the vertex comes
            equipped with its input and output type or something like it’s like
            expecting this thing is expecting a certain number of implicit. See,
            they’re not prefer to see the instead of just being kind of given, and
            those expectations that would be filled by actual things, and not just
            in a pardon allottee of things, not just three, but these specifically
            in this yes data, miss data, such that this is a sick. This data is the
            same as this data. Yeah, I mean, a sick olicity of this, not no
            feedback, is the same as ac. Yeah, it’s just that everyone already knows
            what an acyclic graph is. So, I just took this data and figured out how
            to find the graph that I need to check what they’re cyclic and you just
            write down its wrote down like here’s what you.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，这也是一个 trop，因为您可以采用任意两个端口图并将它们串联组合，并且只要类型有效，您就可以将它们并行组合。</font></font></p><p>Okay, so that is also a trop because you can take any two port graphs
            and you can compose them in series, and as long as the types work, and
            you can compose them in parallel.</p>
        <h2 id="composition-of-port-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">端口图的组成</font></font></h2><h2>Composition of Port Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这些是端口图中的单子单元和乘积。猪肉。令人困惑的是，F 程序看起来已经是一个弦图，但这些是我的态射，这些将是盒子。整个东西是一个盒子。我的意思是，本身也是一个端口图，但最重要的是更通用的程序，并且写下这些是盒子，但我可以将它们串联或并联。事实上，你可以把它放在它自己里面，这就是我所说的操作手段。你可以放大或缩小。</font></font></p><p>So, those are the monoidal unit and product in port graphs. Pork.
            What’s confusing is the F program looks like it’s already a string
            diagram, but those are my morphisms, and those are going to be the
            boxes. That whole thing is one box. I mean, a by itself is also a port
            graph, but the big thing is the more general program, and write those
            are the boxes, but I could put them in series or parallel. And the fact
            that you can kind of put that thing inside of itself is what I mean by
            operadic means. You can kind of zoom in or zoom out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有问题吗？是的，我还有另外两个图，就像二到二，所以是两个端口图。是的，我想把它们组合起来。或者，物理学认为它们是一系列的？是的，它们只是正常的、更明显的组合。是的。它们都是从二到二，所以应该没问题。是的，它在那里。你会如何写下另一种组合，即电线交叉？你会加入对称性。所以，在对称中间类别中，有一件事我忘了写出来——哦，我确实写过有一种对称性，它表示 N 与融合对称性 sigma 同构。</font></font></p><p>Questions? Yeah, I have like two more diagrams that are like two to
            two, so two port graphs. Yeah, and I want to compose them. Or, physics
            consider them like in a series? Yeah, they’re just normal, more visible
            composition. Yep. They’re both from two to two, so that should be fine.
            Yes, it’s there. How would you write down the other composition, which
            is that the wires cross? You would put in a symmetry. So, in a
            symmetrical middle category, one thing I forgot to write up here is—oh,
            I did write there’s a symmetry that says N is isomorphic to fusing
            symmetries sigma.</p>
        <h2 id="symmetry-in-port-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">端口图中的对称性</font></font></h2><h2>Symmetry in Port Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我会用 sigma 将它们组合起来，无论 N 在哪里。我想，是否有类似的术语，也许你会用它来弄清楚，好吧，我想要这个，你去这里？是的，是的。但在 prop 中，只要所有字符串都没有标签，就可以摆脱那些关联符。是的，如果你在处理簿记，你必须在计算机科学中这样做，而在数学中你不需要做那么多，因为你习惯于知道你可以做到这一点。</font></font></p><p>And so I would compose them with a sigma wherever N is there. Is
            there a similar, I guess, maybe a term that you would use to sort of
            figure out, okay, I want this, you go here? Yeah, yeah. But in the prop,
            as long as since all the strings are unlabeled, kind of kept rid of
            those associators. Yeah, if you’re taking care of bookkeeping, which you
            have to in computer science, and you don’t have to as much in math
            because you get used to knowing that you just can do it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是我和 QLI 的程序员 Ryan 之间最大的问题。对我来说，同构是免费的，而对他来说，它们很贵。对吧？只要你有它们。所以，对，你可能需要一个关联器，但可能是因为这是一个问题，因为我的意思是，其他问题。换句话说，你不需要同构，因为我们只是在没有同构的骨架类别中工作。</font></font></p><p>And this is like the biggest issue between me and Ryan, the person
            who coded at a QLI. For me, isomorphisms are free, and for him, they’re
            expensive. Right? As long as you have them. So, right, you probably need
            an associator, but maybe because it’s a problem because I mean, other
            questions. In other words, you don’t need an isomorphism there because
            we’re just working in a skeletal category where there are no
            isomorphisms.</p>
        <h2 id="skeletal-categories-and-isomorphisms"><font style="vertical-align:inherit"><font style="vertical-align:inherit">骨架类别和同构</font></font></h2><h2>Skeletal Categories and
            Isomorphisms</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">抱歉，原因不在这里。抱歉，但是是的，这等于那个。因此，关联器可能就是身份。我认为这是一个错误，是的，错误，对吧？抱歉，它被称为严格的中间类别，这意味着你关联它将是一个问题。是的。我不确定这个对称性。因此，当我们将两个大盒子组合在一起时，我们会看到我们如何切断电线。如果我有一个从二到二的大图，而你有一个从二到一的图，好吗？</font></font></p><p>Sorry, where that’s not the reason. Sorry, but yeah, this just equals
            that. So, the associator might just be the identity. I think that’s a
            tripped, yes, tripped, right? Sorry, it’s called a strictly middle
            category, which means you associate it’s going to be, you know, a
            problem. Yes. I’m not sure about this symmetry thing. So, when we
            compose like two of these big boxes, we are seeing like how we cut the
            wires. If I have a big diagram from two to two, and you have a diagram
            from two to one, all right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么如果这个——也就是所谓的 TLS 垃圾，叫做 Q，那么合成 P 分号 Q 将由此给出，但分号 sigma 分号 Q 会略有不同。我看到有一个图标或交叉。看起来像交叉线，表示信号更强。我明白了。所以，从 a 到 b，有一个 sigma 让我在那里。sigma？是的。而且在包络上方还有两个恒等式。我认为这可能是因为您需要一个张量上的恒等式或加上 sigma 是自由的。</font></font></p><p>Then if this—that’s called TLS crap, is called Q, then the
            composition P semicolon Q will be given by that, but the semicolon sigma
            semicolon Q would be given slightly differently. I see there’s an icon
            or a crossing. That looks like a crossed wire, indicating a stronger
            signal. I see. So, from a to b, there’s a sigma there for me to be
            there. The sigma? Yeah. And there’s also two identities above envelopes.
            I think this might be written because you need to identity on one tensor
            or plus sigma being free.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">他们说对于任何端口图，都有一个相反的程序。是的，是的。我可以永远交换所有相关角色。我已经把程序倒着写了。是的。所以，类别中任何对象的对立面总是在模态类别中。道具的对立面也是道具。听起来你在谈论相反的问题。还有其他问题吗？或者你可能想说正确程序的对立面与封面照片同构。我不确定，但大概是这样的。没错。是的。好的。</font></font></p><p>They’re saying that for any port graph, there is an opposite program.
            Yeah, yeah. Forever, I could have switched the roles of everything
            involved. I’ve written the program backwards. Yeah. So, the opposite of
            any object in a category is always in the modal category. And the
            opposite of a prop is also a prop. And it sounds like you were talking
            about the opposite problem. Other questions? Or maybe you’re trying to
            say the opposite of the proper programs is isomorphic to cover
            photographs. I’m not sure, but yeah, something around there. That’s
            right. Yeah. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，免费道具。所以，签名上的免费道具。所以，抱歉，我的意思是，我应该这样说：道具签名。</font></font></p><p>So, free props. So, the free prop on a signature. So, sorry, I mean,
            I should say it this way: a prop signature.</p>
        <h2 id="free-props-on-signatures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">签名上的免费道具</font></font></h2><h2>Free Props on Signatures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">定义很好。你的 prop 签名和函数。所以，你的签名告诉你一堆标签。Lambda 表示标签，1 和 2，或者你认为 a 和 a 背心。我是 Griffin。这是一个签名。然后这个签名上的 3 prop 是一个 prop。所以，我们知道它的对象是什么。对象是自然数。而态射，它们是端口图。或者一个态射是一个端口图。V 在我的瑜伽中，但我喜欢它的样子。</font></font></p><p>Good definition. Your prop signature and also functions. So, your
            signature is telling you a bunch of labels. Lambda for label, and the 1
            and 2, or you thought a and the a vest. I’m Griffin. And that’s a
            signature. And then the 3 prop on this signature is a prop. So, we know
            what its objects are. The objects are the natural numbers. And the
            morphisms, they’re the port graphs. Or one morphism is one port graph. V
            in how my yoga, but I’m like how it looks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">嘿，iota 是某人的。好的。所以，成为一个外向的 iota，以便与标签或类型和类型函数结合在一起。然后为端口图中的每个顶点分配一个标签，我猜是 a、b、c 或 d。规则是这样的，抱歉，那是在中间。这样看看进出。对于每个顶点，我得到三个自然数。对于每个 lambda，我得到两个自然数。我有一个类型函数。</font></font></p><p>Hey, iota for somebody. Okay. So, be an out iota such that to get
            together with a labeling or a type and typing function. Then assigns to
            every vertex in your port graph a label, a, b, c, or d, I guess. And the
            rule is such that, sorry, that being in the middle there. Such that look
            at the ins and outs. For every vertex, I get three natural numbers. And
            for every lambda, I get two natural numbers. And I have a typing
            function.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">他们应该同意。换句话说，如果我有一个仅使用 a、b、c 和 d 的端口图。是的。还有第四个图。顶点是这个、这个和这个。每个顶点，或者我称之为 b，我称之为顶点。反邪教盒子。这里有三个盒子。每个盒子都被分配了一个类型。给我一个标签，a、d。盒子的输入/输出维度等于它被分配的标签的顶点的输入/输出维度。</font></font></p><p>And they should agree. In other words, if I have a port graph using
            only a’s, b’s, c’s, and d’s. Yeah. There’s a fourth graph. The vertices
            are this one, this one, and this one. Every vertex, or I called it b, I
            call it vertices. Anti cult boxes. There are three boxes here. Each box
            has been assigned a type. Make me one of these labels, a, d.&nbsp;And the
            input/output dimension of the box equals the input/output dimension of
            the vert of the label it was assigned.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是所谓的签名上的自由支柱。这些与 Petri 网有关。</font></font></p><p>And that’s called the free prop on that signature. And these are
            related to something called Petri nets.</p>
        <h2 id="relation-to-petri-nets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">与 Petri 网的关系</font></font></h2><h2>Relation to Petri Nets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你听说过这些。Petri 网几乎就是这个。只是我们现在允许自己在这些线路上拥有类型，比如位置。我正在研究这一点。但他们使用并发理论、化学反应网络和进化博弈论等。所以，这是我们没有在书中包括的内容，但它绝对是一个有趣的七幅素描风格的故事，对吧？这只是……我们在哪里？</font></font></p><p>If you’ve heard of those. So, Petri nets are almost exactly this.
            It’s just that we now allow ourselves to have types on these wires, like
            that are places. And I’m looking into that. But they’re using
            concurrency theory and chemical reaction networks and evolutionary game
            theory and stuff. So, that’s something we didn’t get to include in the
            book, but it’s definitely an interesting seven sketch style story,
            anyway, right? This is just… where are we?</p>
        <h2 id="summary-and-next-steps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">总结和后续步骤</font></font></h2><h2>Summary and Next Steps</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们刚刚发现或证明了签名上的自由放置。他有以下问题……所有四个图形都是同态，只要这些可怜的工艺品配备了地图，标签集就会满足这一点。你只需说 lambda 上的三个支柱，还是你必须指定更多？那么你已经到了那里，然后放下一个具有自然数作为对象的图形，是的，并且具有从二到三的同态。所有四个从二到三的图都在那里定义，它们还配备了……</font></font></p><p>We just discovered or justifying the free drop on a signature. The
            questions he has… all four dresses morphisms, as long as those poor
            crafts have been equipped with a map, the labeling set satisfies this.
            And you just say the three prop on on that on lambda, or is that you
            have to specify more than that? You’ve got there then, and drop one that
            has as objects natural numbers, yeah, and has morphisms be from two to
            three. All four graphs from two to three have defined over there, where
            they’ve been also equipped with the…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">被拍照的形态已经具备了标签功能。那里。鲍勃最近低声说着，是另一种生物。你们都在那里。它们都在那里。所有可能的生物都在那里，是的，是的。你能不能就想拍照，然后把这称为我们的一天？是的。所以，在这一个里面，你可以说这是……而且这是一个奇怪的逻辑事物。</font></font></p><p>got photographed as a morphism has been equipped with a labeling
            function. There. Bob talking low lately is a different organism. You’re
            all there. They’re all there. And every possible one is there, yeah,
            yeah. Can you just felt like like taking photos and call this our day?
            Yeah. So, inside of this one, you could say this is… and and this is the
            one that some weird logical thing.</p>
        <h2 id="semantics-of-props-and-relations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Props 和 Relations 的语义</font></font></h2><h2>Semantics of Props and
            Relations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，当你画出这个……这个，这意味着，或者你会在这里和这里写一个结尾，然后是这里的一次性盒子，或者其他什么。或者，但现在你可能想知道的一件事是，假设你做了和和和，你知道这是我用联想法做的同样的事情，和和和然后是另一个顺序，无论这个自由先知不知道什么。它会认为这两个是需要考虑的，还有一些是不同的，就像猪肉棕色一样。那些是不同的工艺品，你知道。这是一张标签的图片，所以猪肉图要么不同。所以，布伦丹下次要谈论的是语义，你看的提示不仅是免费的，而且里面有一些关系。你肯定会想要与你们的电路有关系，不是吗？还有其他问题吗？好的，我想是时候了。所以，下次见。留下来讨论。</font></font></p><p>And now when you draw this… this that will mean, or you’ll have
            you’ll have an end written here and here, and then the throwaway box
            here, or whatever. Or, but now one thing you might want is to know that,
            let’s say you do and and and and you know that’s the same thing I was
            doing associatively, and and and then the other order, whatever that
            would not be known to this free prophet. It would consider those to be
            two to consider, and a few to be different as a pork brown. Those are
            different crafts, you know. This is a picture of a label that’s so as
            pork graphs either different. So, what Brendan will talk about next time
            is the semantics, where you look at prompts that are not just free but
            have some relations in them. And and you would definitely want relation
            with you guys’ circuits, not okay? Other questions? Okay, I guess that’s
            time. So, see you next time. Stay after for discussions.</p>
        <h1 id="applied-category-theory.-chapter-5-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 5 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 5, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 29 日) — 54:50 </font></font><a href="https://youtube.com/watch?v=0tnqd29TY9w"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=0tnqd29TY9w</font></font></a></p><p> 6
            years ago (Jan 29, 2019) — 54:50 <a href="https://youtube.com/watch?v=0tnqd29TY9w">https://youtube.com/watch?v=0tnqd29TY9w</a></p>
        <h2 id="summary-9"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本 MIT 课程 (18S097) 讲座由 David Spivak 和 Brendan Fong 讲授，介绍了信号流图的概念及其与范畴论的联系。讲座探讨了有向图如何表示前序和范畴，以及如何使用自由结构（如自由范畴和自由属性）从较简单的结构生成更复杂的结构。给出了示例来说明如何用信号流图表示范畴中的集合和态射之间的函数，然后将其链接到矩阵。讲座最后讨论了如何使用信号流图来表示矩阵和线性关系，以及如何使用这些概念来分析矩阵。</font></font></p><p>This MIT Course (18S097) lecture, taught by David Spivak and Brendan
            Fong, introduces the concept of signal flow graphs and their connection
            to category theory. The lecture explores how directed graphs can
            represent pre-orders and categories, and how free structures, like free
            categories and free props, can be used to generate more complex
            structures from simpler ones. Examples are given to illustrate how
            functions between sets and morphisms in categories can be represented by
            signal flow graphs, which are then linked to matrices. The lecture
            concludes by discussing how signal flow graphs can be used to represent
            matrices and linear relations, and how these concepts can be used to
            analyze matrices.</p>
        <h2 id="homework-announcements"><font style="vertical-align:inherit"><font style="vertical-align:inherit">家庭作业公告</font></font></h2><h2>Homework Announcements</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，好的。内部通知。快点开始。这是我们下课后某个时间会布置的第一份家庭作业。关于你最好的作品，你可以用一个量表来评分。检查，加，检查，检查——相当简单的量表，对吧？三件事。大卫在你今天离开之前，我想已经把本周或上周的作业读完了。今天晚些时候还会有另一份家庭作业。它将于星期五截止，时间不多了。坦白说，这将是一份较短的家庭作业，基本上涵盖了到本堂课为止的内容。但从现在开始，我们有点……因为如果有什么事情发生，好吧。</font></font></p><p>Yes, okay. Housekeeping announcements. Begin fast. This is the first
            homework that we’ll have back at some point after class. About your best
            work, and you can get it back graded on a scale. Check, plus, check,
            check – fairly simple scale, right? Three things. David’s read through
            things this week’s or last week’s homework, I guess, please before you
            leave today. And there will be another homework out later today. It’s
            due Friday, which is not very much time. To confess negativity, so it’ll
            be a shorter homework and cover things basically up to this lecture. But
            from now on, we’re sort of… because if anything kicks up in place,
            okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">上次我们看到了信号流图，它在工程中用于讨论信号、系统，我们还看到了预定序的概念，对于大多数测量来说，它相当简单，非常棒。</font></font></p><p>So, last time we saw these things for signal flow graphs, which are
            used in engineering to talk about signals, systems, and we also saw this
            notion of a pre order, which was a pretty, a certain simple, for most
            measurements, are kind of great.</p>
        <h2 id="signal-flow-graphs-and-preorders"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图和预订</font></font></h2><h2>Signal Flow Graphs and
            Preorders</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我将继续讲述这个故事，特别是引入有关线性代数的概念，以了解为什么信号流图在工程中很有用。但这是更多类别理论结构的开始。因此，我们在整个课程中偶尔会释放左派，并且我们给出了一种生成空心结构的方法。因此，我们说，如果您想推动这一点，一种方法是使用 Hasse 图来呈现它的过程。</font></font></p><p>So, I’m going to continue the story, and in particular, bringing
            notions about linear algebra chops to understand why signal flow graphs
            are something useful in engineering. But that’s the beginning of a more
            category theoretic structures. So, we set the left free occasionally
            throughout this course, and we’ve given a way of generating a hollow
            structures. So, we said that if you want to push that, one way to get
            your hands on a process to present it using a Hasse diagram.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，事实证明，您可以用这种方式呈现每个预排序。但所有预排序都以这种方式呈现，但有向图呈现预排序的想法，并且有很多不同的方式来呈现单个预排序。例如，您可以只用一个元素呈现预排序，但他是另一个。在这两种情况下，这都是两个不同的有向图，您可以生成相同预排序的预排序。</font></font></p><p>So, and it turns out you can present every pre order in this way. But
            all pre orders in this way, but there’s this idea that the directed
            graph presents the pre order, and there are many different ways to
            present a single pre order. So, for example, you could just have the pre
            order with one element presentation, but he is another one. In both
            cases, that’s sort of two different directed graphs that you can
            generate a pre order of the same pre order.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想做的是将自由的概念或呈现事物联系起来，无论是预订还是类别。</font></font></p><p>So, what I want to do is link this notion of freeness or presenting
            things, whether it be pre orders or categories.</p>
        <h2 id="freeness-and-presenting-structures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">自由度和呈现结构</font></font></h2><h2>Freeness and Presenting
            Structures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们还看到了如何使用有向图将它们表示为节点，即 Bernard 结点，以便让您了解结点是如何表示年份的，以及如何抽象地理解自由的含义。但我只举两个例子。所以，首先，事实是自然数，作为……理解自然数的一个属性的一种方法是，如果你寻找函数……</font></font></p><p>We’ve also seen how to present them as using directed graphs with the
            nodes, Bernard junctions, to give you some idea about how junctions are
            the years, and also how to understand abstractly what freeness means.
            But I’ll just give you two examples in this vein. So, the first thing,
            fact is that the natural numbers, as a… one way to understand this over
            one property of the natural numbers is that if you look for
            functions…</p>
        <h2 id="natural-numbers-and-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">自然数和函子</font></font></h2><h2>Natural Numbers and Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以你可以考虑从这个从一个集合到任何其他集合的态射的驼峰集的函数集，假设它是底层集合，对吧？所以，这是从一个集合到另一个集合的函数集。所以，可以观察到这些东西，这些函数，与自然数的态射是一一对应的，对吧？那么，我们如何在这两者之间进行转换呢？好吧，让我们从这里开始。如果我有一个从自然数到其他集合的态射，我可以考虑元素一是否映射到某个东西，那就是一个函数。而女孩被描述为从元素一或元素一到的第二个驯服的函数……</font></font></p><p>so you could consider the set of functions from this hump set of
            morphisms from one to any other set, let’s say it’s the underlying set
            one by one, right? So, this is the set of functions from one set to
            another set. So, it is possible to observe that these things, these
            functions, are in one to one correspondence with morphisms from the
            natural numbers, right? So, how do we go between these? Well, let’s
            start here. If I have a morphism from the natural numbers to some other
            set, I can consider whether the element one maps to something, and
            that’s a function. And where the girl is described as a function from
            element one or the second taming of element one to…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我撒谎了。大君说，更灭绝了。我们可以换个方式。如果你有一个从 1 到幺半群的底层集合的函数，你可以以独特的方式将其扩展为从自然数到 M 的幺半群态射。所以这是一一对应的。那个独特的方法是什么？好吧，如果我们知道 1 去哪里，我们需要考虑 0 去哪里。由于某种同态，它会到达幺半群的单位。</font></font></p><p>I’m lying. Said of the Maharaja, more extinct. We can go the other
            way. If you have a function from one to the underlying set of a monoid,
            you can extend that to a monoid morphism from the natural numbers to M
            in a unique way. So this is a one to one correspondence. What is that
            unique way? Well, if we know where one goes, we need to think about
            where zero goes. It goes to the unit of the monoid because of some
            homomorphism.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以它必须去那里。那么二去哪里呢？嗯，二必须去一加一，对吧？所以我要带一个 f，二的 f 等于一加一等于二。对于幺半群运算，必须去两次，对吧？所以根据同态性质，每个一加一都需要去一个一的 f 和一的 f 的乘积。所以我们知道二去哪里，同样，我们知道每个自然数应该去哪里。它去的是 n 个一的 f 的乘积，也就是一的 f 乘以 n。&nbsp;</font></font></p><p>So it has to go there. And where does two go? Well, two has to go to
            one plus one, right? So I’m going to come home with an f, an f of two is
            equal to one plus one equals two. Has to go two times for the monoid
            operation, right? So every one plus one, by the homomorphism property,
            needs to go to the product of an f of one and f of one. So we know where
            two goes, and similarly, we know where every natural number should go.
            It goes to the product of n copies of f of one, which is just f of one
            to the n.&nbsp;</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">更抽象一点，我们可以考虑集合的范畴。我们可以同意 Manos 的观点，我们有一个自由函子，它将一个集合发送给某种自由的幺半群概念。所以，如果这个函子要将一个集合发送给自然数，那么函子可能一直接受某个对象，欠你它的底层集合，这就是这个附加属性，它表示从一个映射，从一个对象映射到这里的幺半群的底层集合，再映射到这里的图片集，再映射到这里的幺半群。我说我们可以把这个集合推到这里，考虑从图像到 M 的映射，或者我可以使用底层函子将幺半群拉回这里，考虑从我经常拉回的集合中绘制的映射。就是这样。并且存在一一对应关系。所以这是一个选项的例子。</font></font></p><p>More abstractly, we can think about the category of sets. We can
            agree with Manos, and we have a free functor that sends a set to some
            sort of free notion of monoid. So here, if this one is to send one to
            the natural numbers, a functor might be all the way that takes some
            object, owes you its underlying set, and that’s this adjunction property
            that says maps from one, from from an object to the underlying set of a
            monoid here to a picture set here, and a monoid here. And I said we can
            either push that set over here and consider maps from from the image to
            M, or I can pull the monoid back here using the underlying functor and
            consider maps drawn from the set that I’m pulling back with a lot.
            That’s this thing. And there are one to one correspondences. So that’s
            an example of an option.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，自由结构的另一个例子，它给出了函子的例子，是自由类别的概念。</font></font></p><p>Okay, so another example of a free structure, which gives an example
            of a functor, is the notion of a free category.</p>
        <h2 id="free-category-and-path-category"><font style="vertical-align:inherit"><font style="vertical-align:inherit">自由类别和路径类别</font></font></h2><h2>Free Category and Path
            Category</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，这里有一个有向图类别。它只是一些表示方向的东西……我们还有一个类别 C。所以我们可以把它看作是路径类别的表示。我知道你会把它扔出去说，“把它看作一个类别。”你可能会。它有一个函子，它接受一个有向图类别。这是一种从自由类别（路径类别）到 C 的映射。每个类别都可以被认为是一个有向图，其中图的对象是 C 的对象，箭头是态射。我们只是忽略了组合属性。所以这意味着有一个从你的类别到品味线图的映射——这个自由构造。但也有这个映射，自由的，它接受一个图并返回路径类别。所以这两个东西也知道医生，这是从流行人物那里看到的，就像图同态从某个图到我正在标记的底层有向图一样。</font></font></p><p>Similarly, here we have the category of directed graphs. Things where
            it’s just some direction representing… and we also have a category C.
            And so we can think of this thing as presenting the path category. Which
            I know you just throw it out and say, “Think of that as a category.” You
            might. It has a functor that takes a directed graphical category. This
            is sort of maps from the free category, the path category, to C. Every
            category can be considered a directed graph where the objects of the
            graph are the objects of C, and the arrows are the morphisms. We just
            ignore the composition property. So that means that there’s a map from
            the kind of your categories to cross the taste line graph—this free
            construction. But there’s also this map, free, that takes a graph and
            returns the path categories. And so these two things also know doctor,
            and that’s from the pop characters to see how the same as graph
            homomorphisms from some graph to the I’m flagging underlying directed
            graph.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，自由结构的概念是好的，因为它为您提供了一种提供一些更简单的数据类型（例如有向图）并免费获得更复杂的数据类型（例如类别）的方法。这变得非常重要，因为我们真的不只是想知道抽象结构的存在，而是想找到生成它们的方法，找到简单、具体地指定类别的方法，而不必构建所有这些额外信息，例如检查、构建组合规则，并检查其关联性和单位性或每一步。</font></font></p><p>So the notion of a free structure is good because it provides you a
            way of giving some simpler data type, like a directed graph, and getting
            for free the more complex data type, like a category. And this becomes
            very important, of like a degree here, because we really want not just
            to sort of know abstract structures exist, but to find ways to generate
            them, to find out ways to sort of simply, in concrete terms, specify the
            category without maybe having to sort of construct all this extra
            information, like checking, constructing the composition rule, and
            checking that it’s associative and unit or every step of the way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在本次演讲中，我们将讨论信号流图的概念如何脱离线性代数。因此，具体来说，我想谈谈信号流图的特定变体如何呈现我们上次看到的正确矩阵。</font></font></p><p>So, in this talk, in this lecture, we’re going to talk about how
            these notions of signal flow graph present notions are off of linear
            algebra. So, in particular, I want to talk about how a particular
            variant of signal flow graphs presents the proper matrices that we saw
            last time.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，现在让我们思考一些问题。</font></font></p><p>Okay, so let’s think about some problems now.</p>
        <h2 id="props-and-symmetric-monoidal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Props 和对称幺半群类别</font></font></h2><h2>Props and Symmetric
            Monoidal Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，有句名言说，思考 props 的一种方式是，它们是对称的单半群类别。这次我们会制作其中一种结构吗？对象非常简单，而不是说态射之间的预序之一非常简单。因此，简单，我们在这里真正指的是这种自由的概念。</font></font></p><p>So, a famous said that one way to think about props is that they’re
            symmetric monoidal categories. Will we make one of the structures this
            time? The objects are really simple instead of said one of the preorders
            between morphisms is very simple. So, by simple, we really mean this
            sort of notion of freeness here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，提醒一下，道具是——它是这里的一个东西，在一个生成器上是免费的。然后是彩色液滴的更一般概念的概括，在一组颜色或类型上是免费的，适合联合国儿童基金会的类型。</font></font></p><p>So, a prop, just to remind you, is a—it’s one thing that’s right
            here, is free on one generator. And then there’s a generalization of a
            more general notion of a colored droplet, free on a set of colors or
            types, proper for unicef type.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，严格，我提到的正常类别是什么意思？</font></font></p><p>So, what does strict, I mentioned the normal category mean?</p>
        <h2 id="strict-symmetric-minimal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">严格对称最小范畴</font></font></h2><h2>Strict Symmetric Minimal
            Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是我们顺便提到的一个术语，但我认为我之前没有写下它的定义。因此，严格意味着这些——结构映射——所以我们记住一个对称的单半群范畴，以及这些东西，单位是什么，以及有助于见证张量积的单位和结合性的结合子。因此，严格意味着单位是——换句话说，之前我们说 x 张量 x 应该同构于 x，现在我说它们相等。</font></font></p><p>This is a term we’ve mentioned in passing, but I don’t think I’ve
            written down the definition before. So, strict means that these—the
            structure maps—so we remember that a symmetric monoidal category, and
            these things, what unit is and associators that help witness the unit
            and associativity of the tensor product. So, strict means that the unit
            is—in other words, before we said that x tensor x should be isomorphic
            to x, and now I’m saying they equal.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体来说，这意味着对象形成了一个适当的幺半群。它们不仅仅是某种松散的、更宽松的概念，我们可以通过同构来见证这些事物。特别是，一个适当的偏见，不，我必须成为项链才能永远自由。在这里，在自由的概念中，考虑类别的属性。</font></font></p><p>So, in particular, this means the objects form a proper monoid.
            They’re not just some sort of lax, more relaxed notion of one of it
            where we witness these things by isomorphisms. And in particular, a
            proper bias that no, I had to be the necklace to serve to be free also
            much forever. Here, in the notion of freeness, consider the properties
            of categories.</p>
        <h2 id="functors-and-tensor-products"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子和张量积</font></font></h2><h2>Functors and Tensor Products</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可以讨论这样的函数……好吧，它们只是具有决定它们是否保持简单的中心属性。有——您想要提升一个函子。所以，不，没有音乐，这意味着什么？好吧，它不仅像函子一样保留了组合——当然——而且还保留了张量积，对吧？所以，就对称对象而言，这就是身份。所以，具体来说，首先是道具。任何道具都有，并且它的对象集也是如此，因此因为对象的因子在道德上只是 1 到 1 和 2 到 2 的句子，依此类推。</font></font></p><p>You can talk about functions such that… well, they just have a
            central property that determines whether they remain simple or not.
            There’s—you want to promote a functor. So, no, no music does that mean?
            Well, not only does it preserve composition like a functor—sure—but it
            also preserves the tensor product, right? So, in terms of symmetrical
            objects such that is identity. So, in particular, first, props. Any prop
            has again, and as is its set of objects, and so because that the factor
            on objects just be ethically a sentence 1 to 1 and 2 to 2 and so on.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么，另一个是耳机。让我们跟着他们。G 设置 P 和两个南瓜。所以，这里，这个东西是一样的。这个东西是 a。函子是如果在函子的定义上施加了更多的东西，或者它只是一个函子？所以，函子不必是一般对象的身份，但这不是你所处理的事实所强迫的。不，这不是强迫的。一个好，两个好，他会去四个。</font></font></p><p>Okay, so, so another that is is headset things. Let’s follow them. G
            set P with two pumpkins. So, here, this thing is the same. This thing is
            to a. A functor is that if that imposing anything more on the definition
            of functor, or is it just a functor? So, functors don’t have to be
            identity of objects in general, but that’s not forced by the fact that
            you’re dealing with. No, that’s not forced. One good, good of two, and
            he would go to four.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，是的，没错。1 变成 2，然后 2 必须变成 4。这是由该函子的局部性质的对称节点性质所强制的。但你仍然可以自由地将 1 发送到 2，然后再发送其他内容。事实上，由于自由属性，你设置 1 的位置决定了你必须从哪里发送其他所有内容。</font></font></p><p>Yeah, yeah, yeah, exactly. 1 goes to 2, then 2 has to go to 4. That
            is forced by the symmetric nodal nature of the local nature of this
            functor. But you was still free to send 1 to 2, then something else. And
            in fact, because of the freeness property about where you set one
            determines where you have to send everything else from.</p>
        <h2 id="free-props-and-signatures-1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">免费道具和签名</font></font></h2><h2>Free Props and Signatures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">Bonta。所以我从 prop 签名的范畴中直接跳出来，但有一个定理说签名上的自由 prop。例如，如果我取签名，是的，这个 a 的数量从 1 到 1，那么就是一个态射。所以，自由适当 a 的对象是自由问题。这总是必须是自然数，但态射，我只是浏览。我们可以通过将这些东西串联、并联连接在一起来构造。我们可以交换东西。这就是我比马耳他人更了解的。所以，同样，我知道另一个例子——它没有太大不同。我要把它们合上，拿一张餐巾纸——那辆车的唾液分泌。是的，他有一个签名。又是一个非常简单的签名。你的 b 缺少 a。</font></font></p><p>Bonta. So, so I went to the right out of the category of prop
            signatures, but there’s a theorem that says a free prop on a signature.
            So, for example, if I take the signature, yes, this amount of a from 1
            to 1, then a morphism. So, the objects of the free proper a are free
            problems. This always have to be the natural numbers, but the morphisms,
            I just browse. We can construct by putting connect these things together
            in series, in parallel. We can swap things around. That’s just what I’m
            Maltese than that. So, similarly, I know another example—it’s not very
            different. I’m going to close them and have a napkin—saliva production
            for that vehicle. Yeah, he has a signature. Very simple signature again.
            Your b is missing a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我问一个简单的问题。这样你就可以喘口气了。</font></font></p><p>So, a quick question. So, you can catch your breath.</p>
        <h2 id="finite-sets-and-morphisms"><font style="vertical-align:inherit"><font style="vertical-align:inherit">有限集和态射</font></font></h2><h2>Finite Sets and Morphisms</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">什么是计数器？但如果我将其称为 b，它是什么？所以，我应该告诉你这个问题。有限集。它的对象是自然数，但你认为你认为自然数是有限集，对吧？并且有一个元素集，然后你可以讨论它们之间的函数的适当有限集中的态射。实际上，加上零。因此，有限集的对象存在类别问题，函数的态射，然后移动乘积由不相交的并集、评估或加法给出。所以，我们想给你一个，或者你想解开它？哦，是的，所以也许，也许由邻居来讨论，并谈论只是试图解开这个深度。这真是个问题。因为，应该是。有人可以告诉我，例如，好吧，根据这个定义，你应该如何考虑 prop 函数？好的。</font></font></p><p>Is what is a counter? But if I call this b, what is it free? So, I
            should have told you about the problem. Finite sets. Its objects are the
            natural numbers, but you kind of consider that you consider the natural
            numbers as finite sets, right? And there’s an element set, and then you
            can talk about the morphisms in proper finite sets of just functions
            between them. And actually, plus in zero. So, there’s a category problem
            with objects of finite sets, the morphisms of the functions, and then
            the mobile product is given by disjoint union, assess or addition. So,
            we wanted to give you one, or you want to kind of unpack it? Oh, yeah,
            so maybe, maybe by the neighbor, and talk about just trying to unpack
            this depth. What a problem. For, should be. Anyone can tell me, for
            example, well, how you should think about a prop function in light of
            this definition? Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，对不起，这个定理说自由道具泡沫签名很粗糙，但具体来说，自由道具很粗糙。然后我被自由道具拒之门外。也许应该将其表征为一种选择。是一个映射，表示它是自由道具的生成态射。道具文件中的态射，除了光标之外，它就像任何集合函数一样，从一个集合到另一个相同大小或更小的集合，封闭的。</font></font></p><p>So, so this, I’m sorry, this theorem says that the free prop foam
            signature is rough, but in particular, the free prop is rough. Then I
            flunked out of the free prop. Maybe should be the characterization of
            that is really just a choice. Is a map that says he is sort of the
            generating morphism of the free prop. And what morphism in the prop
            file, except for the cursor, it’s just going to be like any set function
            from like one set to a set of the same size or smaller, closed.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，所以它必须选择。我们必须将我们发送到一个函数，但这必须是一个从某个对象到另一个对象的函数。而这个因素已经在对象中确定了，因为参数必须是它们的身份，匿名的。所以，这是一个从对象到扩展自由属性的态射。因为，所以很抱歉，所以它必须从两个元素集或一个元素集转到一个函数。但一般来说，你可以看到你从任何函数中得到，只要，哦，那是什么？</font></font></p><p>So, so it’s got to pick. We’ve got to send us to a function, but this
            has got to be a function from some object to another. And this factor is
            already determined in objects because parameters have to be their
            identity, anonymous. So, this is a morphism from the object to widen the
            free prop. Because, so it’s sorry, so it’s got to go to a function from
            the two element set or one element set. But so the general can see that
            you get any function from, and as long as, oh, so what is?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，所以一般来说，态射是自由 prop，是的。所以你描述的是图像。不，我也是这么想的。你得到的，我得到的。没有显示。不，我，因为我错了。是的，那就是我认为它只是一个美国偶像函子，而不是 prop 函子，对吧？所以，如果他写的是对称幺半群函子，那他就是对的。你必须选择一个集合让流去，对吧？</font></font></p><p>Yes, so morphisms in general, that the free prop, yeah. So you’re
            describing about the image exactly. No, that’s what I thought. To what
            you have, that’s what I got. No shows. No, I, because I was wrong. Yeah,
            and that is that I thought it’s just an American Idol functor as opposed
            to a prop functor, right? So, he would be right if he’d written
            symmetric monoidal functor. You’d have to pick a set for the stream to
            go to, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后你，是的。所以我得到了相同的答案，我们错了。但正确的答案又来了，它基本上就是你所说的。它是一个，它是一个，所以自由道具中的态射看起来像这样，其中每一个都代表一种独特的功能。这些蜜蜂代表从二到一的独特功能。所以在这里，我可以把它看作是一个来自二、四、六元素、二或三元素集的函数。那个函数是什么？它发送这个东西的第一个元素，这个东西的第二个元素，等等，对吧？所以每个建议实际上都可以通过图形的 V 标签给出。所以，这个自由道具有点像，它是一个图像。</font></font></p><p>And then you, yep. So I got the same answer, and we’re wrong. But but
            the correct answer again, it’s basically what you’re saying. It’s a,
            it’s a, so morphisms in the free prop look like this, where each of
            these represents sort of a unique function. Of these bees represents the
            unique function from two to one. So here, I can think of this as a
            function from a two, four, six element, two or three element set. And
            what is that function? It’s well, that sends the first element of this
            thing, the second element of this thing, and so on, right? And so every
            suggestion can in fact be given by a V label for graph. And so, so this
            free prop is kind of, it’s an image.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是有限集之间的引诱。对称单半群，是的，函子。两个对称单半群类别之间可能存在一个函子，而它本身不是对称单半群吗？或者，函子是对称单半群意味着什么？这是一种属性还是一种结构？它是函子的附加属性吗？所以，如果你真的对你的对象作为对称矿物类别感兴趣，那么结构上的求和 1 就是发生事情的关键，那么它是关键的一个表达就是你已经学会了真正考虑它们之间的对称函子。</font></font></p><p>And here is the seduction between finite sets. A symmetric monoidal,
            yeah, functor. Is it possible to have a functor between two symmetric
            monoidal categories that is not itself symmetric monoidal? Or, what does
            it mean for a functor to be symmetric monoidal? Is this a property or a
            structure? Is it an additional property on functors? So, if you’re
            really interested in your objects as symmetric mineral categories, so
            somehow the summation 1 over structures is key to what’s going on, then
            an expression of it being key is that you’ve learned to really consider
            symmetrical functors between them.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，例如，有限集类别中有两个对称的矿物结构。因此，您可能不会考虑它们，因为您可能不会考虑它们两者。您可能不会，甚至可能不尊重它们之一。因此，某些东西可能是对称的，经过了类别。它会发出哔哔声。因此，您可能能够为它配备提交窗口的结构，Caprio。将其视为对称类别，但您可能无论如何都不会这样做。好的情况是，是的，基本上，当您将某物视为某种结构化对象时，您几乎总是应该考虑办公室的概念，以保留该结构。好的。</font></font></p><p>But, for example, the category of finite sets has two symmetric
            mineral structures in it. And so, you may not be working with respect to
            you can’t do what, for you may not be working with respect to both of
            them. You’re probably not, you may not even be respecting working with
            respect to one of them. So, something might be a symmetric, went over
            category. It’ll have it beep. So, you might be able to equip it with the
            structure of a submission window, caprio. Think of it as a symmetrical
            category, but you might not be doing that anyway. The good situation,
            yeah, basically, this sort of when you consider something as a certain
            structured object, you should almost always consider the notion of
            office enough reserves that structure. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，希望我们对接下来会发生什么有所了解。所以，考虑一下这个签名。所以，对于 sigma，它将有一个从 1 到 2 的态射。事实上，我写的是记录类型，但这是一个从 1 到 2 的态射，因为它是一个输入为 1 到输出为 0 的事物的图像。然后我转向了从 1 到 1 的更多自定义，或者每个行号的自定义。那么，什么是自由提示？办公室更喜欢什么？</font></font></p><p>So, hopefully, we have some idea what comes about. So, consider this
            signature. So, for the sigma, and it’s going to have a morphism from 1
            to 2. In fact, I write record types, but this is a morphism from 1 to 2,
            because it’s a picture of something has one input, into output to zero.
            And then I went to more custom from 1 to 1, or a for every row number.
            So, what is a free prompt? What does an office in prefer?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">sigma 上的免费道具，sigma，对吧？那么，这些提交是什么？这些是五和六，但基本上就是采用这些符号，然后绘制一些图形。那是一个全日制学生。所以，这就是这个函数。所以我要调用，我要把这些东西称为信号流图。</font></font></p><p>The free prop on sigma, sigma, right? So, it’s what are those
            submissions? These are five and six, but it’s basically taking these
            symbols and then drawing some graphs of them. That’s a full time
            student. So, so there’s this function from this. So, I’m going to call,
            I’m going to call these things signal flow graphs.</p>
        <h2 id="free-props-and-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">免费道具和信号流图</font></font></h2><h2>Free Props and Signal Flow
            Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可以看到与此的相似之处，这是 David 上周在板上画的信号流图。它有一堆吐出符号和添加符号、信号，以及使用这些行号放大它们的方法。它更简单一点，因为我们没有考虑时间承载事物和积分等，但基本结构是一样的。好的。</font></font></p><p>You can sort of see the resemblance to that, that’s signal flow graph
            David drew on the board last week. It has a bunch of spit symbols and
            add symbols, signals, and also ways to amplify them using these row
            numbers. It’s a bit more simpler because it’s a bit more simple because
            we’re not sort of considering time bearing things and integrating and so
            on, but the basic structure is the same. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，您可以为它们定义一个从 sigma 照片到矩阵的函子，因为它是自由道具，通过说明这些生成器去往何处。因此，我要将其发送到矩阵，您就走了。</font></font></p><p>So, you can define them a functor from sigma photographs to matrices,
            just because it’s the free prop by saying where these generators go. So,
            I’m going to send this to the matrix, you’re gone.</p>
        <h2 id="matrix-representation-of-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图的矩阵表示</font></font></h2><h2>Matrix
            Representation of Signal Flow Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">很抱歉，请看最后一个。不，这是错误的方式。哦，这是一个坏连接，因为它允许我这样做。所以，这可能不是您可能习惯的矩阵的通常约定的转置，但对于自由结构，再次说明这些生成器将去往何处。说，但每个态射都会决定每个信号流图将去往何处。所以我告诉过你这些单个矩阵去往何处，现在如果我绘制一个信号流图……我可以告诉你它对应的矩阵是什么。</font></font></p><p>That’s sorry, go the last one. No, it’s the wrong way. Oh, this is a
            bad connection because it allows me to. So, this isn’t probably the
            transpose of the usual convention for matrices that error you might be
            used to, but so saying again for free structure, saying what these
            generators go to. Says, but every morphism minutes of where every signal
            flow graph will go. So I’ve told you where these individual matrices go,
            and now if I draw a signal flow graph… I can tell you what matrix that
            corresponds to.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是——这只是向我展示句法，因为它是零。就是这个。所以，嗯，好的，有一个后面的。一零二一。所以，要生成一个 prop，你只需要指定一些符号。有时，对吧？所以，我说这是一个有零输入、有点输出的符号。我没有给它任何语义解释。是的，但是给定这些符号，你可以构造一个问题，它只是一些自由的句法。实际上没有任何意义。你的态射，像这样，我们会继续，也许之后的任何谈话都会变得清晰。好的。</font></font></p><p>So, this is—this is just showing me syntactic because it’s the zero
            thing. It’s this one. So, there’s a back from, hmm, okay. One zero, two,
            one. So, to generate a prop, you just have to specify some, some, some
            symbols. And sometimes, right? So, I’m saying that this is a symbol
            which has zero input, somewhat output. I don’t give it any sort of
            semantic interpretation. Yeah, but given these symbols, you can
            construct a problem which is just some free syntactic thing. Doesn’t
            really have any meaning. Where your morphisms, like this, we’ll
            continue, and maybe it’ll become clear any talk afterwards. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，为了精确地描述自闭症，我将画出一个图。我可能会这样画。因为这些东西定义了函数和矩阵，所以这是自由属性中的态射。所以，它对应于一个矩阵。你介意添加一个开放的圆圈吗？或者要关闭你的应用程序，比如在那里放一个？那么，这应该是什么？一种方法是弄清楚，好吧。所以，这是复合的。如果我们从玩具中映射它，那就是与此相对应的矩阵块，它是由五、十组加上这个东西组成的。</font></font></p><p>So, for example, to be precise about autism, I’m going to draw. I
            might go like this. So, because these things define functions and
            matrices, this is a morphism in the free prop. So, it corresponds to a
            matrix. Would you mind adding an open circle or were to kill your app,
            like put one there? And so, what should this be? One way to do this is
            by figuring out, okay. So, this is the composite of. If we map this from
            toy, that’s the clump of the matrix corresponding to this, which is one
            one composed with five, ten sets of plus this thing.</p>
        <h2 id="matrix-multiplication-and-signal-flow-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵乘法和信号流图</font></font></h2><h2>Matrix
            Multiplication and Signal Flow Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个东西映射到一个元素上的单位矩阵。所以，我只是映射一些东西。这个矩阵在这里，这个东西在这里，只是矩阵五。但大卫说，矩阵中单半群积的直接和就是这个对角线。好的。她也交换了，因为对称单半群因子必须映射到矩阵类别中的对称性。所以，矩阵类别中的对称性看起来像这样。现在大卫让我倾向于留下一个空矩阵。</font></font></p><p>This thing maps to the identity matrix on one element. So, I just map
            stuff. This matrix here, and this thing here, just the matrix five. But
            David said that the direct sum of monoidal product in matrices is just
            this diagonal. Okay. She had the swap also, because the symmetric
            monoidal factor has to be mapped to the symmetry in the category of
            matrices. So, symmetry in the category of matrices looks like this. And
            now David’s made me tend to left with an empty matrix.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是空矩阵仍然有维度，并且维度，我猜，它是零，除以什么？所以我确定我列。那么，这个东西就变成了这个。我不知道在哪里。所以，没有谈到零原子。所以，它给了我那个矩阵。所以，这个的通勤是 Spivak 拓扑下的信号流图，是这些矩阵的复合，我要说的是，它不应该是 1。我不是，对不起，是 0 1。好的。</font></font></p><p>But the empty matrix still has a dimension, and has the dimension, I
            guess, it’s a zero by what? So, I’m sure I column. So, then this thing
            becomes this. I don’t know where. So, the zero atom that wasn’t talked
            about. So, it gives me that matrix. And so, the commute of this is
            signal flow diagram under the Spivak topos is the composite of these
            matrices, which I’m going to say shouldn’t be one. I’m not, I’m sorry,
            zero one. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我有点忽略了那个构造。是的，让我们看看原因。所以，矩阵乘法不是——没有必要，如果我们在谈论矩阵时，我们通常不谈论零乘以 n 乘以零的矩阵。</font></font></p><p>So, I kind of ran past that construction there. Yeah, let’s see the
            reason. So, matrix multiplication is not—no need if we, when we’re
            talking about matrices, we usually do not talk about zero by an n by
            zero matrices.</p>
        <h2 id="zero-dimensional-matrices-and-signal-flow-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">零维矩阵和信号流图</font></font></h2><h2>Zero-Dimensional
            Matrices and Signal Flow Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是矩阵乘法的概念会给你这个公式。如果你想要某个矩阵的 i、j 项，它等于 m 的和。所以，这是一个中间变量。但是如果我们有一个零维矩阵，那么这个 k 将会求和。这个和将尝试从一个空集中抽取 k。所以，我们将看到一个空和。按照惯例，零和为零。</font></font></p><p>But then the notion of the matrix multiplication gives you this
            formula. That if you want the i, j entry of some matrix, it’s equal to
            the sum over m. So, this is some intermediate variable. But if if we
            have a zero dimensional matrix, then this k is going to be summing. This
            sum is going to try and draw k from an empty set. And so, we’re going to
            be looking at an empty sum. The sum of nothing is zero by
            convention.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可能在秋天之后没有看到它，但这是一个非常强大的惯例。因此，具体来说，有一个零乘一矩阵。当我们对此感到紧张时，在行中添加一个额外的列。还有一个下一个或一个一个的矩阵。也许我会让你告诉我这是什么。所以，这里有一个问题：这一个映射到什么？也许还有，好吧，这里有一些问题。告诉我这三个信号流图知道什么。</font></font></p><p>You may not have seen it after the fall, but that’s a very robust
            convention. So, in particular, there’s a zero by one matrix. When we
            tense up with this, add an extra column in the rows. And there’s also a
            next or one by one matrix. Maybe I’ll just get you to tell me what this
            one is. So, here’s a question: What does just this one map to? And maybe
            also, okay, so here are some questions. Tell me what these three signal
            flow graphs know.</p>
        <h2 id="signal-flow-graphs-and-matrix-representation-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图和矩阵表示（续）</font></font></h2><h2>Signal
            Flow Graphs and Matrix Representation (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">也许我很抱歉。告诉我这三个信号流图代表哪些矩阵。我不会在这种压力下在性感时刻之前问任何问题。好吧，它必须是一对一的。应该是两个。所以，它总是输入的数量，行数。你是在问那是一根大手指吗？两个不同的手指？这个问题是两个不同的问题。但人们从这里得到了什么？老师，嘿，胸围对吧？所以，这是一个一对一的矩阵。</font></font></p><p>Maybe I’m sorry. Tell me which matrices these three signal flow
            graphs represent. I’m not—under this pump—asking any times before the
            sexy time. Well, it has to be a one by one. It should be two. So, it’s
            always going to be the number of inputs, the number of rows. Are you
            asking is that one big finger? Two different ones? This question is two
            different ones. But what are people getting from here? Teachers, hey,
            busty right? And so, it’s a one by one matrix.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它有一个输入和一个输出，入口是坏的吗？这个怎么样？好的，那么矩阵的形状是什么？二乘二。好的，我猜答案是全是七。但全是七。所以，这是可以计算的。我马上给你一个捷径。有人想告诉我这里的答案是什么吗？如果你这样做，这个需要大量的计算，因为有很多部分。</font></font></p><p>It’s got one input and one output, and the entry is it busted? How
            about this one? Okay, so what’s the shape of the matrix? Two by two. And
            okay, I guess the answer is it’s all sevens. But it’s all sevens. So,
            that can be computed. I’ll give you a shortcut to this in a second.
            Anyone want to tell me what the answer here is? This one requires a lot
            of computation if you do it this way because there are a lot of
            pieces.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果您注意到，解释所有这些事情的简写就是考虑从一个输入到输出时要做什么。因此，这里的这个条目可以被认为是所有路径的放大。因此，您要对所有路径的乘积求和。您唤起我们所有路径，并将您经过的放大乘以阶数。然后您对从输入到输出的所有路径求和。</font></font></p><p>So, if you’ll notice here, the shorthand for interpreting all these
            things is to think about going what you do when you go from one input to
            an output. So, this entry here can be thought of as the amplification
            over all paths. So, you sum over the product of all paths. You evoke us
            all paths and multiply order for the amplifications that you go that you
            run through. And then you sum over that over all paths from the input to
            the output.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体来说，这是从一到一。所以，你不能从这里到这里。所以，对于这个东西，零应用，如果你要从这里到这里，你有什么办法吗？就是通​​过这条路径。而应用是没有应用的。关闭。只有一个。另一个，你交叉射击五个。所以，是五个。这里的某个人，你通过两个应用。你在这里得到一个时间速度。你有两条不同的路径。这部分给你一个，这部分是你的出价。</font></font></p><p>So, in particular, this is from one to one. So, you can’t get from
            here to here. So, the zero application for this thing, if you’re getting
            from here to here, you there any way to do it? Is to go through this
            path. And the application is no application. Close. Just one. And the
            other, you crossfire five. So, it’s five. Someone here, you go through
            two applications. You get a time speed here. You have two different
            paths. This part gives you a, and this part is your bidding.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，结果是 a。它一定是 a。同样，在这里你会得到所有 7，因为只有一条唯一的路径到达事物，并且你总是通过服务器运行。因此，在这里，从第一个输入到第一个输出，只有一条路径，你会得到 1。从第一个输入到第二个输出，你可以遵循信号流，然后你会得到 2 到第七个。理解这种信号流解释有一个技巧。</font></font></p><p>So, the result is a. It must be a. And similarly, here you get all
            sevens because there’s only a unique path coming to things, and you
            always run through the server. So, here, from the first input to the
            first output, there’s only one path, and you get one. From the first
            input to the second output, you can follow the signal flow, and then you
            get a two to the seventh. There’s a trick to understanding this signal
            flow interpretation.</p>
        <h2 id="bijection-between-signal-flow-graphs-and-matrices"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图和矩阵之间的双射</font></font></h2><h2>Bijection
            Between Signal Flow Graphs and Matrices</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些图中的哪一个可以准确捕捉到这个矩阵乘法？所以，这是一个非平凡的结果，但这就是这个自由函子的一种描述。所以，这个函子由狂欢类别给出。你说什么？生成。让我们来看看这些矩阵。是的。列是输出吗？是的。所以，这是代表第一个输出的。这一列代表第二个苹果。然后我认为它应该是第一个输入到第二个输出。这是第一个刷子，正如我所知，转置一个转置完成。谢谢。</font></font></p><p>Which of these graphs that exactly captures this matrix
            multiplication? So, this is a non trivial result, and but that’s this is
            sort of a description of this free functor. So, of this functor given by
            from out of the spree category. What you say? The generate. Let’s go to
            these matrices. Yep. Are the columns the columns are outputs? Yeah. So,
            this is the this is represents the first output. In this column
            represents the second apple. And then I think it should be first input
            to second output. It’s a first brush, as I, you know, to transpose a
            transpose done. Thanks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，我们不再画图并用它们表示矩阵，因此您可以提出一些问题。一个问题是，每个矩阵都有一张图片吗？因此，这是针对 x、y 的所有 x、y、z 给出的。因此，函数是将 C </font></font><sub><font style="vertical-align:inherit"><font style="vertical-align:inherit">m xn</font></font></sub><font style="vertical-align:inherit"><font style="vertical-align:inherit">映射到。因此，具体来说，使用这个术语，您可以回答这个问题：矩阵的每个信号流图（即每个矩阵都有信号流图）吗？</font></font></p><p>So, there are some questions you can ask now that we kind of laying
            off sort of drawing pictures and having them represent matrices. One is
            that does every matrix have a picture? So, this is given is for all x,
            y, z of x, y. So, the function is mapping C<sub>m x n</sub> to do. And
            so, in particular, using this bit of jargon, you can answer the
            question: Does every signal flow diagram of a matrix with talking every
            matrix have a signal flow diagram?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">根据 x 等于 4 的定理。所以，无论它是什么，建议泵总是设置矩阵的主集。所以，这里总有一些东西映射到路径上。总是有一个信号流图。如果记录任何主要特征。这是对此的证明草图。这个想法是这样的。你可以看到，如果你交换这些数字，你可以生成任何 2x2 矩阵。一般来说，因为你在做这个路径诱惑的事情，如果你想要一个 4x3 矩阵，你要做的就是对每个输入，复制它，次数与苹果的数量相同。</font></font></p><p>With the theorem that x is 4. So, whatever it’s always suggestion
            pump sets the home sets of the matrices. So, there’s always something
            down here that maps onto path. There’s always a signal flow diagram. And
            if records any major features. It’s an a proof sketch of this. The idea
            is something like this. You can see that if you swap out these numbers,
            you can generate any two by two matrix. And in general, because you’re
            doing this path tempting thing, if you want sort of a 4 by 3 matrix,
            what you do is for every input, you duplicate it as many times as you
            have apples.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，对于每个输出，你应该将每个输入的单个元素全部加起来。然后连接起来。这样，这些元素和这些元素之间就形成了一种双射。连接起来。因此，第一个输入到第一个输出的第一个元素由输入放大给出。然后是你想要的矩阵。所以，如果你想要矩阵，它从右上角的 2 开始，左上角的 12 开始。你把 2mm 放到这个位置，然后你就可以构建一个信号流图，用这种方式来表示你的矩阵。</font></font></p><p>Then, and for every output, you should add all of one single thing
            for each input. And then you connect up. So, this is then you have sort
            of a bijection between these things and these things. You connect up.
            So, the first one for the first input to the first output is given by
            amplifying by the entry. Then the matrix that you want. So, this is if
            you want the matrix, it begins with two in the top right hand, twelve
            left hand corner. You put a 2mm to application that, and you can
            construct a signal flow diagram that represents your matrix in that
            way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么第二个问题是，现在您知道可以使用图形来表示每个矩阵。</font></font></p><p>The second question then is that now that you know you can represent
            every matrix by using a graph.</p>
        <h2 id="equivalence-of-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图的等价性</font></font></h2><h2>Equivalence of Signal Flow
            Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是你如何判断两个事物是否相同？例如，如果我要求你表示这个矩阵，你可能会给我这个东西。但你也可能给我这个。这是一样的，对吧？好的。你也可能给我那个。你也可能给我是的。事实证明，我的意思是做播客并计算所有矩阵。你可以看到这对应于信号流图。所以事实证明你实际上可以映射；在这里给出一个演示文稿，描述每两个矩阵，当你有两个信号流图表示同一个矩阵时。答案在这里给出，有这组 17 条公理。那么这里发生了什么？它看起来有很多信息，但实际上它可以归结为一堆简单的公理。</font></font></p><p>This is how do you figure out when two things are the same? For
            example, if I ask you to represent this matrix, you might give me this
            thing. But you also might give me this. That’s the same, right? Okay.
            You also might give me that. You also might give me yes. And it turns
            out that I mean doing the podcast and getting all the matrices computed.
            You can see that this corresponds to signal flow graphs. So it turns out
            that you can actually map; give it here a presentation that describes
            with every any two matrices this, when you have two signal flow graphs
            represent the same matrix. And the answer is given here with this set of
            its 17 axioms. So what’s going on here? It looks like a lot of
            information, but really it boils down to a bunch of simple axioms.</p>
        <h2 id="axiomatization-of-matrix-multiplication"><font style="vertical-align:inherit"><font style="vertical-align:inherit">矩阵乘法的公理化</font></font></h2><h2>Axiomatization of
            Matrix Multiplication</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，我们之前在任意范畴中见过幺半群的概念。幺半群有乘法，所以它——我认为它取两个东西并返回一个东西——它有一个单位，只是一个东西的一个元素。所以这些公理捕捉到了幺半群的概念，说如果我们将东西相乘并再次相乘；如果我们有三个东西，我们将前两个相乘，然后将那个乘以第三个，这和将后两个相乘并将那个乘以第一个是一样的。所以这只是结合律的图景。这恰好是单位律的图景，这是交换律的图景。</font></font></p><p>For example, we saw this notion of a monoid earlier in an arbitrary
            category. And a monoid has a multiplication, so it’s—I think that takes
            two things and returns one thing—and it has a unit, which is just an
            element of one thing. And so these axioms here capture this notion of a
            monoid by saying if we multiply things and multiply them again; if we
            have three things, we multiply the first two, then multiply that one
            with the third one, it’s the same as multiplying the second two and
            multiplying that with the first one. So that’s just a picture of
            associativity. And this happens to be a picture of unitality, and this
            is a picture of commutativity.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似地，这些东西是相同的，只是被转置了。这些是同态概念的图像。这些是图像；这是其中一种方式。所以我们称之为幺半群，而余幺半群和幺半群之间有一种鲜为人知的相互作用方式。我可以买我自己的吗？你通过双代数的概念看到了很多表示理论。所以这只是说这种情况发生了。</font></font></p><p>Similarly, these things are the same but transposed. These are
            pictures of the notion of a homomorphism. And these are pictures; this
            is a way of that. So we call this a monoid, and there’s this little well
            known way that co monoids and monoids can interact. Could I buy my own?
            That you see a lot of representation theory through the notion of a
            bialgebra. And so this is just saying that that happens.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但关键是，这为我们提供了矩阵乘法的合理而完整的公理化。因此，如果您对矩阵有任何疑问，如果您想用信号流图来表示它们，那么我们矩阵，您有这种简化矩阵的方法。矩阵用称为矩阵乘法的矩阵计算。当两个矩阵或两个复合矩阵和矩阵等价时也是如此。这里，这个地方是类似的。如果您在 Wallace 工作，可能有 17 条规则允许您确定两个信号流图是否具有相同的含义，是否表示相同的矩阵，或者是否都表示应用程序中的相同结构。矩阵为您提供了其他一些方法，因此作为线性代数，但如果您只承诺这些在道具世界中允许的操作，我们实际上无法谈论整个线性代数。谈论内核和图像以及九十个向量之类的东西非常困难。但是您可以通过线性关系的概念，以相当优雅的方式更接近这一点。</font></font></p><p>But the point is that this gives us a sound and complete
            axiomatization of matrix multiplication. So given any question you have
            about matrices, if you want to represent them in terms of signal flow
            graphs, so we matrices, you have this way of reducing matrices. Matrices
            are computed with matrices called matrix multiplication. And that’s also
            when two matrices or two composites and matrices are equivalent. Here,
            this place is analogous. Probably 17 rules allow you, if you’re working
            in the Wallace, you can flow graphs and said to determine whether two
            signal flow graphs have the same meaning, represent the same matrix, or
            all represent the same structure in your application. Matrices get you
            some other way, so as linear algebra, but from if you only commit
            ourselves these operations that were allowed in the world of props, we
            can’t actually talk about all of linear algebra. It’s very difficult to
            talk about kernels and images and ninety vectors and things like that.
            But you can get closer in quite an elegant way through the notion of a
            linear relation.</p>
        <h2 id="linear-relations-and-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">线性关系和信号流图</font></font></h2><h2>Linear Relations and
            Signal Flow Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，这具有非常好的图形视角。关键点，如信号流图所示，是工程师早已认识到平面的方向在语义上无关紧要。如果您有这些符号之一，如果它是电气元件或某物，您可以随时将其翻转。它没有这些东西必须说的百分比阻止方向。一切都是这样的。这个符号总是从二变为一。所以你可以问这样的问题，你知道，这个东西代表矩阵，其中。</font></font></p><p>And then this has a really nice graphical perspective. The key point,
            as seen in this signal flow graph, is that engineers have long
            recognized the orientation of the planes is semantically irrelevant. If
            you have one of these symbols, if it’s an electrical component or
            something, you can always turn it around. It doesn’t have this percent
            prevent orientation that these things have to say. Everything goes like
            this. This symbol always goes from two to one. So you can ask questions
            like, you know, that this thing represents the matrix among which.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我们认为我在添加两个信号，但这个符号直观上应该是什么意思？它应该意味着我们有来自那个方向的信号。但这不再是一个函数，因为如果我们试图解释这些东西，矩阵从左到右，而没有矩阵，那么就会把东西作为来自另一个方向的东西添加。但我们可以回到绑定关系的概念，我们在第一堂课中讨论过这个概念。</font></font></p><p>So we think I was adding two signals, but what should this symbol
            mean intuitively? It should sort of mean that we have signals coming in
            from that direction. But that’s no longer a function because the way if
            we’re trying to interpret these things, matrices going from left to
            right, and there is no matrix, then kind of add things as things from
            the other direction. But we could return to this notion of the binding
            relation, which we talked about in the first lecture.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，所以这个东西可能代表矩阵，但是这个东西有等价的数据来表示我们认为 x，y，z，2。</font></font></p><p>All right, so this thing it might represent the matrix, but this
            thing has to this equivalent data to saying it says that we think x, y,
            z, 2.</p>
        <h2 id="linear-relations-and-signal-flow-graphs-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">线性关系和信号流图（续）</font></font></h2><h2>Linear
            Relations and Signal Flow Graphs (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后我们强制执行约束，现在这是一个更加对称的结构，我们可以将其翻转。因此，不要将这些符号解释为矩阵，因为这个 prod moon 是线性关系的支柱，其中态射主集是线性子空间的子空间。你可以像转换关系一样组合它们。</font></font></p><p>Then we enforce the constraint, and now this is a much more symmetric
            structure, and we can flip this around. So instead of interpreting these
            symbols as matrices, as this prod moon is the prop of linear relations,
            which is where the morphisms home set is the subspaces for the linear
            subspaces. And you can compose these like you converse relations.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，反过来看，我们现在不是在矩阵中解释，而是在线性关系中解释，就像设置 x、y、z，使得 x，这被视为从 a 到我们的态射。现在，例如，它们，我们有一个大矩阵。</font></font></p><p>So, flipping this around, we have that this thing now interprets not
            in matrices, but in linear relations, as sort of set up x, y, z, such
            that x, and this is seen as a morphism from a to us. And now, for
            example, them, and we have a big matrix.</p>
        <h2 id="kernel-and-subspaces-in-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图中的核和子空间</font></font></h2><h2>Kernel and Subspaces
            in Signal Flow Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们如何考虑这个矩阵的 chip kernel 之类的东西？好吧，我们想要找到所有映射到零的向量。我们如何表示零子空间？好吧，这个东西已经，正如您之前谈到的，表示位于零维空间内的元素零。因此，如果我们将其翻转并在此处放置零，则这个东西表示的只是这些输入生成的向量空间的子空间。事实上，这是内核，所以对于你们在线性代数课中看到的所有人来说，这是分析矩阵的基础，您可以更详细地讲述这个故事。</font></font></p><p>How do we think about something like the chip kernel of this matrix?
            Well, we want to find all vectors that map to zero. And how do we
            represent the zero subspace? Well, this thing already, as you sort of
            talked about earlier, represents the element zero lying inside zero
            dimensional space. So if we flip this around and put zeros here, this
            thing represents a subspace of just the vector space generated by these
            inputs here. And the fact this is the kernel, then, so for all of you
            have seen in session linear algebra, that’s fundamental to analyzing
            matrices, and you can kind of carry out the story in more detail.</p>
        <h2 id="summary-and-enrichment-of-signal-flow-graphs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">信号流图的总结和丰富</font></font></h2><h2>Summary and
            Enrichment of Signal Flow Graphs</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我认为，但总结一下，信号流图上存在这种很好的情况，它大致发生在这个领域，你可以用一些最伟大的结构来丰富它，这些结构可以更多地谈论灵感和微分方程，但要记住 n 大西洋情况的线性。然后你可以画出这些图。这些是通过 prop 的概念形式化的。这个 prop 的概念可以帮助你推理线性代数，提供所有矩阵所在的框架结构。</font></font></p><p>So I think on that, but just to summarize, there’s this sort of well
            on a signal flow graphs, which roughly takes place over instead of this
            field a, you can enrich it with sort of greatest structures that can
            talk about inspiration and sort of differential equations a bit more,
            but keeping in mind the linearity of the n Atlantic situation. And then
            you can draw these graphs. These are formalized through the concept of a
            prop. This concept of a prop helps you reason about linear algebra,
            providing the framework structure where all matrices reside.</p>
        <h1 id="applied-category-theory.-chapter-6-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 6 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 6, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 30 日) — 51:23 </font></font><a href="https://youtube.com/watch?v=JUiHg_F_v1o"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=JUiHg_F_v1o</font></font></a></p><p> 6
            years ago (Jan 30, 2019) — 51:23 <a href="https://youtube.com/watch?v=JUiHg_F_v1o">https://youtube.com/watch?v=JUiHg_F_v1o</a></p>
        <h2 id="summary-10"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这门由 David 和 Brendan Fong (Spifong) 在独立活动期间 (IAP) 教授的 MIT 18S097 课程讨论了应用于电路的范畴论。本章使用电路图（触发器、电阻器、晶体管）来激发对超图范畴的抽象。视频解释了从电路超图范畴到关系范畴的函子，然后深入研究了各种范畴（包括集合）中图的极限和余极限。集合范畴中显示了极限（如乘积和拉回）和余极限（如余积和推出）的示例。视频最后暗示了范畴图的未来应用。</font></font></p><p>This MIT 18S097 Course, taught by David and Brendan Fong (Spifong),
            during the Independent Activities Period (IAP), discusses category
            theory applied to electrical circuits. The chapter uses diagrams of
            circuits (flip-flops, resistors, transistors) to motivate the
            abstraction into hypergraphic categories. The video explains functors
            from hypergraph categories of circuits to categories of relations, and
            then delves into limits and colimits of diagrams in various categories,
            including sets. Examples of limits (like products and pullbacks) and
            colimits (like coproducts and pushouts) are shown in the category of
            sets. The video concludes by hinting at future applications to diagrams
            of categories.</p>
        <h2 id="typographic-categories-and-popper-ads"><font style="vertical-align:inherit"><font style="vertical-align:inherit">印刷类别和波普广告</font></font></h2><h2>Typographic Categories
            and Popper Ads</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">今天我们来谈谈印刷类别和波普尔图。我会讲很多关于极限和余极限的内容，但我想先谈谈本章的动机：电路。我想是的。这是一张触发器内存图。外面有六个端口，还有电阻器、晶体管、电压和地线，以及各种不同的东西。</font></font></p><p>So, today we’re talking about typographic categories and Popper
            diagrams. I’ll do a lot of, like, limits and colimits stuff, but I
            wanted to start by talking about the motivating thing for this chapter:
            electrical circuits. I guess. Here’s a picture of a flip flop memory
            diagram. You’ve got six ports on the outside, and resistors,
            transistors, voltage, and ground, and all sorts of different things.</p>
        <h2 id="hypergraphic-category-abstraction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">超图类别抽象</font></font></h2><h2>Hypergraphic Category
            Abstraction</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，您可能会认为，如果您在科学文献中找到任何系统的绘制图表的方法，那么就有这种方法。这是寻找范畴论的好地方。因此，今天，我们将看到这种图表。好吧，我不确定我是否会深入讨论，但我想我会在这里说出来。在这种图表中，存在着联系，并且有些事物是相互联系的。与我们之前看到的图片不同，这些联系是无向的。例如，它感觉不像是一个幺半群范畴。然而，有些事物是相互联系的。</font></font></p><p>So, one belief you could have is that if you find any kind of
            systematic way of doing diagrams in the scientific literature, yeah,
            there is that. It’s a good place to look for category theory. So, in
            this, today, we’ll see this kind of diagram. Well, I’m not sure I’ll
            really get into it much, but I guess I’ll say it right here. In this
            kind of diagram, there are connections, and there are things that are
            kind of being connected. And those connections, unlike pictures we’ve
            seen before, are not directed. For example, it doesn’t feel like a
            monoidal category exactly. And yet, there are things being
            connected.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这将被抽象为所谓的超图范畴，其中这将是组合不同态射的一种方式。这些晶体管中的每一个都将是一个态射，这些电阻器中的每一个都将是一个态射，这将是将许多态射组合在一起的图像。因此，您可以在幺半群范畴中组合这样的态射，而不是在一条线上或逻辑范畴中组合态射。您可以串联和并联组合态射。在超图范畴中，线路是有向的。在紧凑闭范畴中，就像我们在 Co design 中讨论的那样，您可以获得反馈，但这个世界上的一切仍然具有方向性。没有方向性。切换全电压向前和向后移动的幅度一样大。</font></font></p><p>So, this will be kind of abstracted into what’s called a hypergraphic
            category, where this will be the sort of way of composing different
            morphisms. Each one of these transistors will be a morphism, each one of
            these resistors will be a morphism, and this will be a picture of
            composing a lot of morphisms together. So, instead of composing
            morphisms in a line, or in your logic kind of a category, you can
            compose morphisms like this in a monoidal category. You can compose
            morphisms in series and parallel. And in a hypergraphic category, the
            wires are directed. And in a compact closed category, like we talked
            over at Co design, you can have feedback, but there’s still a
            directedness to everything in this world. There’s no directedness.
            Switching full voltage goes as much forward as backwards.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们需要一种图像语言，一种图解语言，让这些有意义，每个小气泡都是各种东西之间的电阻器或晶体管。要为这些找到一种图解语言……</font></font></p><p>And so, we want a kind of picture language, a diagrammatic language,
            where these make sense, where each of these little bubbles is, say, a
            resistor or a transistor between various things. To have a diagrammatic
            language for these…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，你可以有语法。还有语义。Brendan 和 John Baez 证明，如果你只看你的无源线性电路——开关、电阻器、电感器、电容器——那么就会有一个函子从这个图表、这个图表语言到拉格朗日关系类别。更一般地说，这些将对应于一个函子，从类别——比如超图类别（称为超图图片）——从所有电路的超图类别到关系类别。比如说，这个组件意味着这个关系，当它们全部互连时，它们都会同时得到满足。</font></font></p><p>And then, you can have syntax. There’s also semantics. Brendan and
            John Baez proved that, like, if you’re only looking at your passive
            linear circuit—switches, resistors, inductors, capacitors—then there’s a
            functor from this diagram, this diagram language, to the category of
            Lagrangian relations. More generally, these would correspond to a
            functor from the categorical—from, like, the hypergraph category (called
            this—the hypergraph pictures)—from the hypergraph category of all
            circuits to the category of relations. Say, this component means this
            relation, and all of them are satisfied simultaneously when they’re all
            interconnected.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是从图像语言到语义再到范畴关系的过程。这就是今天的想法。但我想，这就是我们真正会花很多时间关注的动机：今天的极限和余极限。</font></font></p><p>That’s how you kind of go from picture language to semantics to
            category relations. That’s the idea today. But that’s the motivation, I
            guess, about what we’ll really focus on a lot of time: today’s limits
            and colimits.</p>
        <h2 id="limits-and-cold-events"><font style="vertical-align:inherit"><font style="vertical-align:inherit">限制和冷事件</font></font></h2><h2>Limits and Cold Events</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们已经讨论过这个问题，但我们需要更深入地探讨这个问题，无论是下一次讨论还是关于 Chocobo 系列的内容。所以，你可能已经看到，在任何使用范畴论的课程中，你都会看到交换图。</font></font></p><p>We’ve talked about this a bit, but we need to go into it more deeply,
            for both next time and for the Chocobo series stuff. So, you might have
            seen, like, in any class that uses category theory, you’ll see
            commutative diagrams.</p>
        <h2 id="indexing-category-and-functor-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">索引类别和函子图</font></font></h2><h2>Indexing Category and
            Functor Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，有人可能会说他们有一个交换图 ABCD，因此在 C 语言中也有一个交换图。在安全交换中，但我们可以从函子的角度来理解交换图。我们之前说过，但我还是再说一遍。那么，我可以定义形状吗？I，也是一个——它被称为小范畴。你可以把它想象成一个有限范畴，或者只是一个有集合的范畴，比如一个关于一组对象的集合。但我写 I 大写是因为我们不使用脚本，因为它的作用略有不同。它是图的形状，一个 I 形图。我想你会说 I 代表索引范畴。</font></font></p><p>So, someone might say that they have a commutative diagram ABCD, and
            so there’s some diagram in C. In your safe commutes, but we can
            understand diagrams in terms of functors. We’ve said this before, but
            I’ll just say it again. So, can I shapes of definition? And I, and is
            also a—it’s called a small category. You can think of it like a finite
            category, or just a category with a set, like a set about a set of
            objects. But I am writing I capital because, well, we’re non script
            because it’s serving a slightly different role. It’s the shape of the
            diagram, an I shape diagram. And I stands for indexing category, I guess
            you’d say.</p>
        <h2 id="constant-diagrams-and-terminal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">常量图和终端类别</font></font></h2><h2>Constant Diagrams and
            Terminal Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">I 是这个图的索引类别。我的意思是，C 是从 I 到 C 的函子图。那么，I 是什么？如果这是一个交换图，那么这里的 I 是什么？它是什么类别？</font></font></p><p>The I is the indexing category of this diagram. I mean, C is a
            functor diagram from I to C. So, what is I? If this is a commutative
            diagram, what is I here? What category is it?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，这是一个有四个对象和九个态射的范畴。对于恒等态射，Adobe 的 C 加上一、二、三、四，再加上复合态射，我被迫认为这种方式和这种方式相等。这是一个范畴，从这个东西到 C 的函子为这里的每个对象分配一个 C 中的对象。因此，它可能将 A 分配给这个，将 D 分配给这个，将 C 分配给那里的这个空对象。它为 I 中的每个态射分配一个态射。所以它只是读取并在 C 中绘制这幅图。</font></font></p><p>Yes, well, it’s a category with four objects and I think nine
            morphisms. For identity morphisms, and the C for Adobe plus one, two,
            three, four, plus the composite where I’m forced that this way and in
            this way are equal. And that’s a category, and a functor from this thing
            to C assigns to each object here an object in C. So, it might assign A
            to this one, D to this one, C to this empty there. And it assigns a
            morphism for every morphism in I. And so it just reads draws this
            picture in C.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果 C 是集合类别，那么您可能会将自然数映射到自然数，映射到整数，映射到自然数。它们不必用于不同的映射。这将是身份。这可能是 x 减去 - 这可能是 -6 乘以 5，2 减去 5，这可能是乘以 -2。如果我……我认为这看起来不错。您可以使用非映射。发生了什么？好吧，让我们不用蜂巢 - 绝对值秒。&nbsp;</font></font></p><p>So, if C is the category of sets, you might have natural numbers
            mapping to natural numbers, mapping to integers, mapping to natural
            numbers. They don’t have to be for different maps. This would be the
            identity. This could be x minus—this could be minus 6 times 5, 2 minus
            5, and this could be times negative 2. And if I’m… I think that looks
            good at once. You can use not a map. What happened? Well, let’s do
            without hives—absolute value sec.&nbsp;</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">没关系。谢谢。在这个图中，X 映射到 2x 的绝对值。你看，它们不必是不同的对象。我可以对 x 做恒等式、恒等式、恒等式、恒等式、自然数。但这是从那里的小类别到 C 的函子，到类别 C。状态 A。我想我可以继续这个定义。图的态射。所以，如果我在同一个类别中有两个不同的 I 形图，那么你大概可以通过我刚画的图猜出我可能会将态射变成什么。更多的表亲将是自然变换。今天的目标是理解它对我们说了什么。我们已经定义了四个变换。</font></font></p><p>Didn’t ok. Thank you. X maps to the absolute value of 2x in this
            diagram. You see, they don’t have to be for different objects. I could
            have just done identity, identity, identity, identity, naturals for x.
            But this is a functor from this small category there to C, to the
            category C. Status A. And I guess I can continue this definition. A
            morphism of diagrams. So, if I have two different I shape diagrams in
            the same category, then you could probably guess by the picture I just
            drew what I’m probably going to make the morphisms be. More cousins are
            going to be the natural transformations. The goal today is to understand
            what it’s saying to us. We’ve already defined four transformations.</p>
        <h2 id="limits-and-natural-transformations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">极限与自然变换</font></font></h2><h2>Limits and Natural
            Transformations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不会再重复这个了，但我们会讨论一下它是什么样子的，以及它的工作原理。重要的是，我们会讨论一种特殊的图表和特殊的度量变换，称为极限和终极。</font></font></p><p>I’m not going to do that again, but we’re going to talk about what
            that kind of looks like and work. Importantly, we’re going to talk about
            kind of special diagrams and special metric transformations called
            limits and ultimates.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有一件事。如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是一个对象——如果你有这个对象——在数学中很多时候，我不知道是否每个人都知道这一点，但在数学中，语法通常是用符号写出一些东西，然后用英语写出来。所以，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的一个对象</font><font style="vertical-align:inherit">，我说得对吗？那么常数图——这个</font><em><font style="vertical-align:inherit">c</font></em><font style="vertical-align:inherit">上、或在</font><em><font style="vertical-align:inherit">c</font></em><font style="vertical-align:inherit">处和</font><em><font style="vertical-align:inherit">c上的常数</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">形图</font><font style="vertical-align:inherit">——嗯，它是一个从</font><em><font style="vertical-align:inherit">I</font></em><font style="vertical-align:inherit">到</font><em><font style="vertical-align:inherit">c</font></em><font style="vertical-align:inherit">的函子。但我想要使用的，我将转到一个对象终端类别</font><em><font style="vertical-align:inherit">1</font></em><font style="vertical-align:inherit">。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So, one more thing. If <em>c</em> is an object—if you have this
            object—a lot of times in math, I don’t know if everyone knows this, but
            in math, grammar is typical to kind of write something symbolically and
            then out in English. So, if <em>c</em> is an object of <em>c</em>, am I
            right? Then the constant diagram—this constant <em>I</em> shape diagram
            on <em>c</em>, or at <em>c</em>, and on <em>c</em>—is well, it’s a
            functor from <em>I</em> to <em>c</em>. But what I want to use, I’m going
            to go down to the one object terminal category <em>1</em>.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后让我们——唯一的三重态再一次陈述我们。我们曾经看到，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c中的对象与从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的态射是同一回事</font><font style="vertical-align:inherit">。这里的一个是这个小类别。所以，从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的一个对象，就像这样，或者</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">5</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">9匹马中的对象，随便什么。所以，我们把它和它在</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的对象联系起来。但是对于任何其他类别</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ，都有一个唯一的函子</font><font style="vertical-align:inherit">。1 有一个唯一的函
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">子</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。
        </font></font></p><p>And then let’s—the only tri state us again. We once saw that objects
            in <em>c</em> are the same thing as morphisms from <em>1</em> to
            <em>c</em>. One here is this little category. So, by the from <em>1</em>
            to <em>c</em>, that’s an object in <em>c</em>, just like this is, or
            objects in <em>5</em> and <em>9</em> horses in there, whatever. So, we
            have this down with its object in <em>c</em>. But there’s a unique
            functor for any other category <em>I</em>. There’s a unique functor to
            <em>1</em>.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它将所有对象发送到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，并将所有态射发送到身份。因此，每当你写一个感叹号时，通常意味着，当然，我们一直在写</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> blower shriek，这是一个例外，但通常人们使用感叹号来表示有一个唯一的感叹号。我不需要给它命名。我认为在函数式编程中，你可能只写一个破折号或一些下划线。我不知道它们有什么用。但是，如果有一个唯一的单元类型或其他类型，你可以在这里重写一个感叹号。</font></font></p><p>It sends all the objects to <em>1</em> and sends all the morphisms to
            the identity. So, whenever you write an exclamation point, that usually
            means, of course, we’ve been writing <em>f</em> blower shriek, which is
            an exception, but usually people use an exclamation point to mean
            there’s a unique one. And I don’t need to name it. I think in functional
            programming, you might just write a dash or some underscore. I don’t
            know what they do. But, but if there’s a unique one to unit type or
            whatever, you rewrite an exclamation point here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们说的是，在</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的常数图中，取</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，取其中的每个对象并将其发送到一个点，然后将该点发送到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。例如，我所说的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的常数图，无论
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">我</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">有什么形状，常数图都会将每个对象发送到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1到称为</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的东西，并将每个态射发送到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的身份</font><font style="vertical-align:inherit">。你们看到这种写法了吗，一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c的函数，通过</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">1 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子
            </font><font style="vertical-align:inherit">，是如何实现这种恒定性的？有些人看起来很开心。有些人……好吧。一样吗？是的。
        </font></font></p><p>And so, what we’re saying is, in the constant diagram on <em>c</em>,
            takes <em>I</em>, takes every object in it and sends it to a single
            point, and then sends that point into <em>c</em>. So, for example, what
            I said, the constant diagram on <em>1</em>, for whatever shape
            <em>I</em> have, the constant diagram sends every object to that to
            <em>1</em> to the thing called <em>c</em>, and it sends every morphism
            to be identity on <em>c</em>. Do you guys see how this way of writing
            it, a function from <em>I</em> to <em>c</em>, the functor through
            <em>1</em>, is accomplishing this constancy? Some people look happy.
            Some people… okay. Same or not? Yes.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，图表可以是任何形状，但女性不会进入这里的正方形。我正在做一个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">形图。所以你修复你的
            </font></font><code>i</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">，但无论形状</font></font><code>i</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">是什么，所以我可能是我不知道那个形状。我有一个函子，它将其中的每个点发送到单个点，每个箭头发送到更多身份，然后我有这个映射来查看自然数。二，对不起，除了说它只是发送到自然数。现在，所有这三个都会被发送到自然数。所有三个。霸权身份。好的，这就是常数图。
        </font></font></p><p>So, the diagram can be anything that women don’t come into the square
            here. I’m doing an <em>I</em> shape diagram. So you fix your
            <code>i</code>, but no matter what the shape of <code>i</code> is, so I
            could be I don’t know that shape. I have a functor that sends every dot
            in that to the single dot, every arrow to the more identity, and then I
            have this map to see to the natural numbers. Two, sorry, except say that
            just sends out into the natural numbers. Now, all three of these will
            get sent to the naturals. All three. Bullies identity. Okay, so that’s
            what a constant diagram is.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此我可以发现，我可以使用所调用的扩展来定义什么是极限，这听起来比我正在做的一个非常简单的案例更加复杂。</font></font></p><p>And so I can find, I can define what a limit is, using what are
            called upon extensions, which sounds even more complicated than I’m
            doing a very simple case of it.</p>
        <h2 id="limits-in-the-category-of-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">集合类中的极限</font></font></h2><h2>Limits in the Category of
            Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，定义。</font></font></p><p>So, definition.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">假设你又有一个类别。好吧，我猜 C 和 I 都是类别，在某个图中 I 到 C。这是 C 中的眼睛形图。它是一个对象。嗯，mv。这是对象的名称。它有一个很长的名字。D 可以称为 q，随便什么。有一个对象 D，以及一个自然变换。</font></font></p><p>Let’s say you have again, let’s give me a category. Well, I guess C
            and I are both categories, and I to C in some diagram. That’s an eye
            shaped diagram in C. It’s an object. Well, mv. That’s the name of the
            object. It’s got a long name. D could be called q, whatever. There’s an
            object D, together with a natural transformation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我们将采用数据包中的这个定义，并为您提供许多不同的例子。它是什么？自然变换？好吧，我们有 I 到 C。这是图表。D。它是交换平方或任何其他东西。我们有这个唯一的函子。</font></font></p><p>So we’re going to take this definition in the packet and give you
            lots of different examples. And what is it? A natural transformation?
            Well, we have I to C. This is the diagram. D. It’s this commutative
            square or whatever it is. We have this unique functor to one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在我们得到了这个。有人给了我们 D 作为 C 中的一个对象，他们还给了我们一个自然变换，比如 q，正如你所看到的。这幅图意味着从 D 到复合初始最终对象没有变换。这意味着对于任何其他事物，如果有人来，一些坏人来，他给我们，或者她给我们，另一个从 1 到 C 的函子，叫做 Dolan，然后他们认为他们就是那个，他们还给了我们一个从 D 到感叹号 Dolan D 的 q 素数。</font></font></p><p>And now we get this. Someone gives us D as an object in C, and they
            also give us a natural transformation, say q, from what you see. This
            picture here it means that there’s no transformation from D to the
            composite initially final objects. What that means is that for any other
            thing, if someone comes, some the bad guy comes, and he gives us, or she
            gives us, another functor from one to C called Dolan, and then they
            think they are the ones, and they also give us a q prime from D to
            exclamation point Dolan D.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后我们就能向他们展示我们是第一个，我们可以从我们的东西自然地转换为他们的东西，这样 q prime 就是 q 和这个人的复合。所以无论他们从 D 找到什么，我们都可以，我们可以分解它。几个小时。我们就像这个最初的通用守门人。谢谢。最小的，或者这个小的工作，这个最小的，是的。D 在同构上是唯一的。是的。</font></font></p><p>Then we will be able to show them that we are, we are first in line,
            that we can get a natural transformation from our thing to their thing
            such that q prime is the composite of q and this guy. So whatever they
            find from D to theirs, we can, we can factor it. Few hours. We’re like
            the initial universal gatekeeper of this. Thank you. Smallest, or this
            small work, this smallest, yeah. D is unique up to isomorphism.
            Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当我说最小时，它不是，它是直觉的桌面，是的。那么这是一个初始对象吗？就像生命的函子类别？这个三角形的图？是的，是的。它是从这个到这个的所有函子类别中的初始对象，它们都配备了一个变换，一个从 Dolan D 到 Dolan 的特定映射。它应该是独一无二的。如果你愿意的话，有一种更正式的表达方式，即，你有一个从 C 到 C 的 I 到使用常数图的 I 的映射。</font></font></p><p>It’s not, when I say smallest, it’s desktops for into intuition,
            yeah. So is this an initial object? And like the functor category of
            life? This triangle looking diagram? Yes, yes. It’s the initial object
            in the category of all functors from this to this, that are that are
            getting to come equipped with a transformation, a particular map from
            Dolan D to Dolan. It should be unique. There’s a way of expressing this
            more formally, if you wanted, namely, you have there’s a map from, yeah,
            seeing the I from C to C to the I that uses the constant diagram.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接受 C 中的任何对象，它都会返回形状为 I 的常量图。我想我们之前讨论过这个。如果自然数在具有恒等式的数学中变为 NaN，那么这个东西就有左伴随，这很酷。如果您喜欢选择，这是另一种说法，但这是我们更容易谈论的，即使它现在看起来很复杂。极限非常相似。它的极限是一个对象，它只是对象的名称，以及自然变换。</font></font></p><p>Takes any object in C, it returns a constant diagram of shape I. I
            think we talked about that before. If natural numbers go to NaN in math
            with identities, that thing has a left adjoint, and that’s cool. That’s
            another way to say if you like a choice, but this is the one that’s
            going to be easier for us to talk about, even though it looks
            complicated right now. Limits are pretty similar. Its limit is an object
            that’s just the name of the object, together with a natural
            transformation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">CFD。您有……您有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，并且您要求它朝另一个方向发展。马上就会明白这一点。所以，我们有这个</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">e</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">映射，它是最终的。所以，如果有人来给我们</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Mindy</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和一个数学</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我们将能够通过我们的 d 分解它们，其中通用守门人是最接近的守门人，或者最接近</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d的人，通过一个对象分解。基本上，我们是</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的一个对象摘要</font><font style="vertical-align:inherit">。</font></font></p><p>CFD. You have… you have <em>d</em>, and you’ve asked for it to be
            going the other way. It’ll make the sense of this in a second. So, we
            have this <em>e</em> map, and it’s final. So, if someone comes and gives
            us <em>Mindy</em> and a mathematical <em>d</em>, and we will be able to
            factor their through ours, where the universal gatekeeper were the
            closest one, or the closest one to <em>d</em> that factors through the
            one object. Basically, we’re a one object summary of <em>d</em>.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是两种不同的方法， </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的这个大对象、多个箭头，找到一个对象的摘要。这个总结，即它是一个摘要的事实，被编码在存在自然转换的事实中。所以，它说那里的所有数据，我知道如何在你的摘要中解释它，或者那里的所有数据，我知道如何确定你的摘要，从这个意义上说，它是对一个对象类别的最佳总结。它们就是总结。如果你相信那是一种总结，那么它就是最好的总结。</font></font></p><p>These are two different ways of taking <em>d</em>, which is like this
            big, multiple objects, multiple arrows in <em>C</em>, finding a one
            object summary of it. That the sum, the fact that it’s a summary is
            encoded in the fact that there’s a natural transformation. So, it says
            all the data that’s there, I know how to interpret it in your summary,
            or all the data that’s there, I know how to determine your summary in
            it, and it’s the best possible summary for a one object category in that
            sense. They’re summarizing. If you believe that’s a kind of summary,
            then it’s the best one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，还有问题吗？</font></font></p><p>Okay, so any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在我们的图中，不一定是事物对象。例如，这里有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，上层团队在这里访问，对吧？所以，这里，假设你称</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">为
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，有四个对象，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">B</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">、
             </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">D</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。那么</font><em><font style="vertical-align:inherit">A</font></em><font style="vertical-align:inherit">中的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">D</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ……嗯，确实很自然，但我们真的很想把它简化为一个类别，就像他们输了一样。什么对象落入对象？是的。所以，</font><em><font style="vertical-align:inherit">T</font></em><font style="vertical-align:inherit">不必通过 1 进行分解。是的。D</font><em><font style="vertical-align:inherit">不是</font></em><font style="vertical-align:inherit">这个。如果</font><em><font style="vertical-align:inherit">q</font></em><font style="vertical-align:inherit">不存在，则此图不可交换。q</font><font style="vertical-align:inherit">表示我有一个从这个函子到这个复合函子的更自然的变换。所以，</font><em><font style="vertical-align:inherit">d本身不必通过 1 进行分解</font></em><em><font style="vertical-align:inherit">。</font></em><font style="vertical-align:inherit">所以，我们在满足和连接中看到了一个例子，在问题中也看到了一点……哦，是的。所以，也许我应该说一下</font><em><font style="vertical-align:inherit">p</font></em><font style="vertical-align:inherit">和
            </font><em><font style="vertical-align:inherit">q</font></em><font style="vertical-align:inherit">在做什么，然后给出一堆例子。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>In our diagram, not necessarily the things object. So, for example,
            here we have like <em>N</em> and <em>C</em> <em>N</em>, that the up team
            here that visit, right? So, here, let’s say you call <em>A</em>,
            <em>I</em>, has four objects, <em>A</em>, <em>B</em>, <em>C</em>,
            <em>D</em>. Then <em>D</em> of <em>A</em>… well, in the natural indeed,
            but we really like reduce it to the one category, like they lose the
            deal. What object fall towards objects? Yeah. So, <em>T</em> doesn’t
            have to factor through one. Yeah. <em>D</em> is not this. This diagram
            does not commute if the <em>q</em> isn’t there. The <em>q</em> says I
            have a more natural transformation from this functor to this composite
            functor’s. So, <em>d</em> isn’t having to factor through one itself. So,
            we’ve seen an example of this in meets and joins, and in a problem a
            bit… oh, ho, yeah. So, maybe I should say kind of what <em>p</em> and
            <em>q</em> are doing, and then give a bunch of examples.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么这些东西是什么？这说明什么是……什么是
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">q</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">？例如，它与每个对象</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">i</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">同步。而
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">i</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我有这个。从图中可以看出，我们有</font><em><font style="vertical-align:inherit">i</font></em><font style="vertical-align:inherit">的
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，对吧？这就像自然数或整数，我们有一个名为</font><em><font style="vertical-align:inherit">q</font></em><font style="vertical-align:inherit"> sub </font><em><font style="vertical-align:inherit">i 的</font></em><font style="vertical-align:inherit">分量。因为自然变换带有这些分量。对于每个</font><em><font style="vertical-align:inherit">i</font></em><font style="vertical-align:inherit">和
            </font><em><font style="vertical-align:inherit">i</font></em><font style="vertical-align:inherit">，我们都会得到</font><em><font style="vertical-align:inherit">d的</font></em><em><font style="vertical-align:inherit">v</font></em><font style="vertical-align:inherit"> sub </font><em><font style="vertical-align:inherit">i</font></em><font style="vertical-align:inherit"> by 2 :
            分量</font><font style="vertical-align:inherit">。d 的所有这些不同值都映射到同一个对象 d。那么，那个元素是什么？
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>Okay, so what is all this stuff? This is saying what is… what is
            <em>q</em>? For example, it’s synced with each object <em>i</em>. And
            <em>i</em>, I have this. We have from the diagram, we have <em>d</em> of
            <em>i</em>, right? That’s like the naturals or the integers, and we have
            a component called <em>q</em> sub <em>i</em>. Because natural
            transformations come with these components. For every <em>i</em> and
            <em>i</em>, we get a component from <em>v</em> sub <em>i</em> by 2 : of
            <em>d</em>. All these different values of d are mapped to the same
            object d.&nbsp;So, what is that element?
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我转到这里。它转到那里的一个对象。一切都是如此，然后转到名为 D 的对象。所以，这就是自然变换的作用。对于这里的每个对象，它从那个东西转到那个东西。对于每个年轻的地图，从 I 到设备、Fryman、I 的应用程序，图表都会通勤。什么图表？好吧，我们有 I 的 D。我们有 DI，自行车运行，这里的数学称为 F 的 D。</font></font></p><p>I go to here. It goes to the one out object there. Everything does,
            and that goes to the object called: D. So, that’s what this natural
            transformation does. It goes from, for each object here, it goes from
            that thing to that thing. And for each young map, app from I to device,
            Fryman, I, the diagram commutes. What diagram? Well, we have D of I. We
            have D I, bike running, and here the math is called D of F.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像 x 变成 2 倍 x。这就是现在发生的事情。然后我们有一个名为 Qi 的映射，它指向：D。鉴于此，称为 Qi prime，以及映射：D。那么这里应该有什么呢？好吧，我们应该有这个的分量。抱歉，你应该将这个函子应用于 F。但是这个函子，如果我有一个 F 和 I，每个态射，我都会被发送到那里的身份，而身份只会给出身份。</font></font></p><p>It’s something like x goes to 2 times x. That’s what’s happening
            right there. And then we have a map called Qi that goes to: D. Given
            that, called Qi prime, and maps of: D. And then what should we have
            here? Well, we’re supposed to have the component of this. Sorry, you’re
            supposed to have this functor applied to F. But this functor, if I have
            an F and I, every morphism, and I get sent to the identity there, and
            the identity only gives something the identity.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这被发送到身份。身份。史密斯：好的。所以我们说这是可交换的。就像我们取了整个 I。我们取了 I。所以我欠了一些奇怪的类别。也许它是一个正方形。谁知道是什么形状？我有一些奇怪的类别，我们把它全部取了。我们有这个叫做 D 的函数。D 将它发送到一半。而且，只需转储到我们的类别中。这发生在 C 中。现在这另一件事带我们到：：：然后这个 Q 说 a 不是：英尺。</font></font></p><p>So, this gets sent to the identity. Identity. Smith: Okay. So, we’re
            saying that this commutes. It’s like we’ve taken the whole of I. We’ve
            taken I. So, I owe some weird category. Maybe it’s a square. Who knows
            what shape? I have some weird category, and we’ve taken all of it. And
            we have this function called D. And D sends it to like a half. And also,
            just dump in our category. This is occurring in C. And now this other
            thing takes us to just like: : : And then this Q is saying that a not
            to: feet.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，墨西哥是阳性的。CFC：主题。MC：一切都是可交换的。所以，这有点像是一遍又一遍地复制同一个图表。单一的总结，所有这些人都映射到总结中。所有的图表都是可交换的。所以，如果你已经映射到总结中，然后像这样往下走，那么它就是同样的东西。然后，总之，这就是自然类比的意思。是的，让我们看看。</font></font></p><p>So, a Mexico would be masculine. CFC: theme. MC: And every everything
            commutes. So, it’s kind of just copying that diagram with the same thing
            over and over. The single summary, and all these guys are mapping into
            the summary in. And all the diagrams commute. So, if you have be mapping
            into the summary and then going down like that, it’s the same thing
            that’s going down like that. And then, in summary, that’s what the
            natural analogy means. Yeah, let’s see.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们举几个例子，希望这些例子能说明一切。我不太清楚。这个。所以，输入集合。在我们已经看到的连接余极限的帖子中，它可能不会有好结果。因此，例如，我们现在将 5 和 6 的最大值称为 5 和 6 的总结。就像，对于某些人来说，最大值可能是一个总结。而对于其他人来说，最小值可以是 5 到 6 的总结。对于其他人来说，5 的 6 的 gcd 或 lcm，这些 5 和 6 的公倍数可以总结什么？比如，6 中的 5 到底给了我什么？他们给了你 30。你可能还不知道。我不知道。比如，当你试图总结 2/5 加 3/6 时。不要总结。这里的共同点是出于这个目的的总结，对吧？因为你希望它们都存在于一个共同的地方。是的，就是这样的总结。这不是一个好词；我其实不太支持这种直觉。</font></font></p><p>So, let’s do some examples, and hopefully, it’ll become clear. I
            don’t know right away. This. So, so input sets. It may not end well in
            post that we already saw that joins our colimits. And so, for example,
            we’re now calling the max of 5 and 6 the summary of 5 and 6. It’s like,
            for someone’s purposes, max could be a summary. And for someone else’s
            purposes, min can be a summary of 5 to 6. And for someone else’s
            purposes, gcd of 5 of 6 or lcm, these common multiple of 5 and 6 can be
            a summary of what? Like, what are 5 of 6 really giving me? They’re
            giving you 30. You may yet. I don’t know. Like, when you’re trying to
            summarize 2/5 plus 3/6. Don’t summarize. What’s common here is a summary
            for that purpose, right? Because you want them both to live in one
            common place. Yeah, so it’s that kind of summary. It’s not a great word;
            I’m not really standing behind that intuition too much.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，如果你有这个，那么在这种情况下，也许你必须……这是你的高级类别，这是你的帖子步骤，也许你的帖子看起来像这样。这是医院。我同意。好的。然后你有某种函子。这是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。好的。现在，这个的极限是什么？</font></font></p><p>But, if you have this, so in that case, maybe you have to… Here’s
            your high category, here’s your post step, and maybe your post that
            looks like this. This is the hospital. I agree. Okay. And then you have
            some kind of functor. Here’s <em>d</em>. Okay. Now, what is the limit of
            this?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么这个极限是什么？嗯，它是某个单一对象。所以我得找点时间。这很简单。我在那里做一件事，然后试图找到从一到这个东西的映射，并以此方式进行自然转换。这意味着如果我在这里拿任何东西，把它送到一，进入这里，我会让他们说我有一个从那个东西到原始东西的映射。</font></font></p><p>Okay, so what’s the limit of this? Well, it’s some single object. So
            I’ve got to find some time. This is kind of simple. I’m doing a thing
            there of one, and I’m trying to find some map from one into this thing
            and a natural transformation that way. Which means that if I take
            anything here, send it down to one, go in here, I’ll have them that says
            I have a map from from that thing to the original.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这有点意思。如果你要找一个总结，它可能是这样的，也可能是这样的。这两种方法都可以，因为在这两种情况下，我都会有一个自然的转变，或者一个以这种方式发生的组件。</font></font></p><p>So it’s something. If you’re going to find a summary, it could be
            like this, or it could be like this. Both of those would work, because
            in both cases, I’ll have a natural transformation, or a component that
            takes what happened this way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，唯一可能的，比如，排队在那里——即使是结肠或面团肢体或什么的——在波士顿或其他认为自己有的人，他们必须在这里的某个地方降落才能实现这种自然转变。但这个是最好的。这是最接近这两个相遇的。</font></font></p><p>So the only possible, like, queue there—even the colon or the dough
            limb or whatever—in Boston or other person who thinks they’ve got one,
            they’re going to have to land down here somewhere in order to have this
            natural transformation. But this one is the best possible one. It’s the
            closest to these two meet.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这个家伙就是活生生的援助。我想你也可以猜猜煤在里面——余数——要有一张从
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d到它的地图——我的意思是，先生，把你的东西倒过来画——那么，必须有一张从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">d</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到它的地图</font><font style="vertical-align:inherit">。所以它在那两个点上方，它是离它们最近的东西。
        </font></font></p><p>And so this guy here is the living assistance. And I guess you can
            also guess the coal in it—the colimit—to have a map going from
            <em>d</em>—I mean, Mr.&nbsp;draw your thing upside down—so well, has to have
            a map from <em>d</em> to it. So it’s above those two dots, and it’s the
            closest thing to them.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于我想让你在这里做什么？我们已经讨论了极限和余极限方面的连接和交集。这有点，但上面的图表首先看起来很吓人。我想让你在这里看看。你在这里看得够多了？好的。</font></font></p><p>About seeing what I want you to do here? We already talked about
            joins and meets in terms of limits and colimits. It’s a little bit, but
            that diagram up there looks scary first. And I want you to see it here.
            Do you see it enough here? Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这种自然转变是存在的，取决于你处于哪个组件。这是一个组件。没关系。</font></font></p><p>This natural transformation is there and there, depending on which
            component you’re out. That’s a component. That’s okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们来算一下集合类。所以我会给你一个通用的插入图，也就是集合类。有一个通用公式。我不知道余极限和极限的通用公式。所以我会给你极限的通用公式。现在，我马上让你算出另一个公式。</font></font></p><p>Let’s do the category of sets. So I’ll give you a general inset,
            which is the category of sets. There is a—a—all purpose formula. I don’t
            know the general formula for both the colimit and the limit. So I’ll
            give you the one for the limit. Now, I’m going to let you work out the
            other one in a second.</p>
        <h2 id="examples-of-limits-product-pullback"><font style="vertical-align:inherit"><font style="vertical-align:inherit">限制示例（产品、回调）</font></font></h2><h2>Examples of Limits
            (Product, Pullback)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于任何图表的极限。如果有人有一个图表，并且它是一个拉回、产品、均衡器或他们想要的任何其他类型的图表，则将此图表称为 D。图表的形状是 I；这是索引类别。而你的集合函子——顺便说一下，如果你愿意的话，它们也被称为数据库 I 的数据库实例——如果你想回忆一下。任何图表的极限如下：D 作为一个集合的极限是所有元组的集合——我应该写这个。</font></font></p><p>For the limit of any diagram. If someone has a diagram, and it is a
            pullback, or a product, or an equalizer, or any other kind of diagram
            they want, call this diagram D. The shape of the diagram is I; that’s
            the indexing category. And your functor to sets—these, by the way, are
            also called database instances for database I, if you like—if you want
            to recall that. The limit of any diagram is as follows: that the limit
            of D, as a set, is the set of all tuples—I should have written this
            one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们把 x1、x2、xi 放好——我在做什么？xi，对于 I 中的每个 i，这样对于 I 中的所有将 i​​ 带到 i' 素数的 f，好吧。我在哪里？所以这个东西不在这里。我们去。D of x。D。让我再试一次。抱歉。那么假设我们的图表看起来像这样。在书中，有一个很好的……好吧。所以 x1 在 D(i1) 中，x2 在 D(i2) 中。D(i1) 是一个集合。D(i2) 是一个集合。D(i) 是一个集合。</font></font></p><p>We lay down x1,x2, xi—what am I doing? xi, for each i in I,
            such that for all f taking i to i’ prime in I, okay. Where am I? So this
            thing isn’t here. We go. D of x. D. Let me try again. Sorry. So let’s
            say our diagram looks like this. In the book, there is like a nice…
            okay. So x1 is in D(i1),x2 is in D(i2).D(i1) is a set. D(i2)
            is a set. D(i) is a set.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">嘿，听着，我假设这个东西是有限的。对不起。好的。所以我想要 D 给我的每个集合中都有一个对象，用于 I 中的每个对象。所以我们在 I 中有五个对象。我将得到 5 个元素：x1、x2、x3、x4、x5。我必须告诉你，它必须满足条件，即对于 I 中从 i 到 i' 的每个映射，如果我将 f 的 D 应用于 xi，它等于 xi'。</font></font></p><p>And hey, listen, I’ll just assume that this thing is finite. I’m
            sorry. Okay. So I want one object in each of the sets that D gave me for
            each object in I. So we have five objects in I. I’m going to get 5
            elements: x1,x2, x3,x4, x5. And I have to tell you, and it
            has to satisfy the condition that for every map from i to i’ in I, if I
            apply D of f to xi, it’s equal to xi’.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我们举几个例子。这个演示太糟糕了。那么我在说什么呢？假设 I 是图表。你看，那只是两个点：i1 和 i2。从这个东西到集合的函子 D 表示我们有这两个集合：D(i1) 和 D(i2)。那么这个公式说明了什么？我们的乘积是——我们的乘积是元组 x1,x2 的集合，一个对应于这个，一个对应于那个，这样对于 I 中的每个态射，它都会将一个东西发送到另一个东西。</font></font></p><p>Let’s do some examples. This is terrible presentation. So what am I
            talking about? So let’s say I is the diagram. See, that’s just two dots:
            i1 and i2. And the functor from this thing to sets, D, says that we have
            these two sets: D(i1) and D(i2). Then what does this formula say? That
            our product is—well, our product is the set of tuples x1,x2, one
            for this one, for that one, such that for every morphism in I, it sends
            like one thing to another.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是除了恒等式之外，没有比 I 更多的态射了。当 I 中的其他所有态射都是恒等式时，这个条件不是空洞地成立吗？好吧，空洞地成立是因为恒等式的 D 将是恒等映射。所以这是一个条件。或者，如果你真的想，你会说恒等式 i1 的 D 应用于 x1 等于 x1，恒等式 i2 的 D 应用于 x2 等于 x2。但这是强迫的。所以我们不必这样做。所以它只是 D(i1) × D(i2) 内的 x1,x2 对的集合。</font></font></p><p>But there are no more morphisms than I, except for the identities.
            When every other morphism in I is the identity, doesn’t this condition
            vacuously hold? Well, vacuously hold because D of the identity will be
            the identity map. So this is a condition. Or, if you really wanted to,
            you would say that D of identityi1 applied to x1 equals x1, and D of
            identityi2 applied to x2 is x2. But that’s forced. So we don’t have to.
            So it’s just the set of pairs x1,x2 inside of D(i1) × D(i2).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以它只是 D(i1) × D(i2)。只是一个产品。这么一点。所以它只是一个产品。好的。如果你已经打乱了 B 和 C 并刺穿了它们之间的空间，那么拉回的调用会怎么样？这是集合图中的图表的示例。这个图的拉回或极限是什么？这里的整个东西是 a — 它是那里这个形状的 ab；它在那里。用公式来切断它的极限是 x₁、x₂、x₃ 的集合，其中，首先，x₁ 在 a 中，x₂ 在 b 中，x₃ 在 c 中，x₁ 的 f 等于 x₃，x₂ 的 f 加上 x₂ 的 g 等于 x₃。</font></font></p><p>So it’s just D(i1) × D(i2). Just a product. This little bit. So it’s
            just a product. Okay. What about the call to pull back if you have upset
            B and C and punctured the space between them? This is an example of a
            diagram inside of a set diagram. What is the pullback, or the limit, of
            this diagram? This whole thing here is a—it’s a b from this shape there;
            it is there. To cut the limit of this by a formula is the set of x₁, x₂,
            x₃, where, well, first of all, x₁ is in a, x₂ is in b, x₃ is in c, and f
            of x₁ equals x₃, and f of x₂ plus g of x₂ equals x₃.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这叫做回拉。所以，回拉到这个图就是另一个图。所以，人们经常会这样写：a 到 c，b 到 c，然后回拉——这个 lim 东西在这里——所有的回拉。人们经常这样写。它将是一对或三元组 (a, b, c) 的集合，其中这个和这个映射，将 a 设置为 c，将这个从 b 设置为 c。有什么问题吗？所以，它是集合元素的元组。</font></font></p><p>And this is called a pullback. So, the pullback to this diagram is
            this other one. So, people will often write it like this: a to c, b to
            c, and the pullback—this lim thing is here—all the pullback. People
            often write it like that. And it’s going to be the set of pairs or
            triples (a, b, c) where this and this map, setting a to c and this one
            since b to c.&nbsp;Any questions? So, it’s a tuple of elements of sets.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些元组——一个元素，除了它不是杀虫剂。是的，这个案例是一组元组。是的，它是一组满足问题的元组。是的，总结任何单个空间。是的，我想在第一天，我画了一张图。去掉点。它表示是这个 a 的乘积，在点的网格中，它表示如果你表示 a 和 ab，那么我现在会给你一个总结。</font></font></p><p>These tuples—an element except it’s not a pesticide. Yeah, this case
            is a set of tuples. Yep, it’s a set of tuples satisfying the problem.
            Yeah, summarizes any single space. Yeah, I think on the very first day,
            I kind of grew this bit of a diagram. Rid of the dot. It says is the
            product of this a and in the grid of dots, it says if you if you
            indicate an a and a b, then I will give you a summary in now.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">确实如此。是的。所以，x 和 y 让我成为了拓扑空间而不是集合。如果你知道拓扑空间，那只是你不知道——它只是一种形状。a 中的一半是一个函数，一个从看起来像这样的空间到 a 的连续映射，而这些中的路径是从这个空间到 b 的函数。所以，如果我在 a 中有一条路径，在 b 中有一条路径，这与在 a 中得到一条乘以 b 的路径是一样的。</font></font></p><p>That’s exactly that’s true. Yeah. So, x and y, it made me our
            topological spaces instead of sets. If you know topological spaces, it’s
            just you don’t—it’s just a shape. And of half in a is a function, a
            continuous map from a space that looks like this into a, and a path in
            these is a function from this space into b. And so, if I have a path in
            a and a path in b, that’s the same thing as getting a path in a times
            b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您可以总结这两条路径。是的，没错。是的，谢谢。回调，也许这是件好事，因为我已经画出来了。如果 a 和 b 已经映射到 c 怎么办？而 c 是一组颜色。因此，b 的每个元素都会得到一种颜色——那个颜色和这个颜色——而 a 的每个元素都会得到一种颜色——比如那个颜色和这个颜色。然后回调将是映射到 a 和 b 以及颜色的东西，这样它们都可以交换。</font></font></p><p>You can summarize the two paths. Yeah, that’s right. Yeah, thanks.
            And the pullback, just to be maybe this is a good thing since I’ve
            already drawn it. What if a and b already have maps to c? And c as a set
            of colors. So, every element of b gets a color—that color and this
            color—and every element of a gets a color—say that color and this color.
            Then the pullback is going to be something mapping to a and b and the
            colors such that it all commutes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后得到的是——让我们看看你得到了什么——你得到了这张图片。所以，我认为 a 中的一个东西和 b 中的一个东西的颜色一致。在整个网格中，只有这些、这些和这些颜色匹配。所以，这里的第七个元素是回撤。我让你们讨论几分钟，看看我们现在在哪里？所以，转向邻居，弄清楚他们在哪里，告诉他们你在哪里，这样你们就可以提出一个共同的问题。是吗？有什么问题吗？有什么问题吗？有人玩得开心吗？有什么说法、想法、问题，什么的吗？什么都没有？是的。</font></font></p><p>And what you end up getting is—let’s see what do you get—you get this
            picture. So, it’ll be I think it’ll be a thing in a and a thing in b
            that agree when you look at their colors. Of the entire grid, only
            these, these, and these match in color. So, the seventh three elements
            here, it is going to be the pullback. Why don’t I let you guys discuss
            for a few minutes and see where we are? So, turn to a neighbor, figure
            out where they are, tell them where you are, so you can come to a common
            question. Yeah? Any questions? Any questions? Anyone have fun? Any
            statements, ideas, questions, anything? Nothing? Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，回撤。任何类别的回撤，但你不会总是有像我们这样的好公式。是的。它是否仅限于当你有那种形状的东西时？是的。回撤是这种形状。是的。它从这两个箭头进入一个共同的东西开始。好问题。谢谢。就像我说的一样。蛋白石。蛋白石也是集合。不，……是的。这些是元素。x1 是爱荷华州运动员集合 D 的一个元素。是的。就这一点而言，很有趣。</font></font></p><p>So, pullback. Pullbacks in any category, but you won’t always have
            this nice formula like we have it. Yeah. And is it limited to when you
            have things kind of in that shape? Yes. Pullback is this shape. Yeah. It
            starts with these two arrows coming into a common thing. Good question.
            Thanks. Say it like I said. Opals. Opals also sets. No, the… Yeah. These
            are elements. x1 is an element of the set D of Iowa athletes. Yeah. The
            funny one in terms of this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们定义活动。我认为你足够强大。然后我们可以……你说是的。我定义 Ian Selleck 的扩展。这些 travelpod 成员 Scott 是正确的。是的。众所周知，所有的事情都像扩展一样，但我不确定我们是否应该详细说明。是的。可能有一些……下一种方法。所以，就像它的方法一样……是的。肯定有谈论伴随的方法。听起来像是所谓的通用箭头的通用术语。可能有一种方法可以这样做。好的。</font></font></p><p>So, we define activities. I think you is strong enough. Then we can…
            You say yes. I define Ian Selleck on extensions. These travelpod member
            Scott is true. Yeah. Famously, all things like on extensions, but I’m
            not sure we should elaborate. Yeah. Probably there’s some… The next way.
            So, just like ways it… Yeah. There’s definitely ways of talking about
            adjoints. Sounds like universal terms of what are called the universal
            arrows. And there’s probably a way to do it this way. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，对。顺便问一下，如果 I 是这里的空类别，会发生什么？你想把 kid 列放进去，还是极限？极限是空罐子，里面什么都没有。所以，从 I 到 C 的函子不会从 C 里面取出任何东西。什么也不做。从空类别到未改变类别有一个唯一的函数。现在我在寻找空类别的这个极限。空图。它是什么？</font></font></p><p>So, right. By the way, what happens if I is the empty category here?
            You want to take the kid column in, or the limits? A the limit is the
            empty can, where it’s got nothing in it. So, there the functor from I to
            C takes out nothing inside of C. Doesn’t do anything. There’s a unique
            function from the empty category to an unaltered category. And now I’m
            looking for this limit of the empty category. The empty diagram. What is
            it?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，我们需要一个具有自然变换的演员变换。没有数据，因为没有要查看的组件。所以，这些数据，最好的消失，它只是说 Lindy 是终端。所以，这就是类别中的终端对象。它是类别的一个对象，任何其他对象都以独特的方式映射到它。所以，类别意义上的终端对象是一个对象集。它是一个集合。好吧，一个元素集是一个集合。</font></font></p><p>Well, we need an actor transformation with natural transformation.
            Has no data because there’s no components to look at. So, this data, the
            best goes away, and it just says such that Lindy is terminal. So, it’s
            what’s called the terminal object in the category. It’s an object of the
            category such that any other object maps to it in a unique way. So, the
            terminal object in the category sense is the one object set. It’s a set.
            Well, the one element set is a set.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">任何其他集合……我绝对……如果那是终端对象，那就最好了。它也是空集的极限。我想我可能会说一个对象类别也是终端类别。是的。你……这么快就说它是所有没有形态的对象。小脚趾或凹痕是什么？它是所有没有形态的对象。我……我不能……你是什么意思？是的。我不知道是什么。不，我不会这么说，但也许我们谈过之后。</font></font></p><p>And any other set… I’m absolutely… And that’s best if that’s the
            terminal object. And it’s also the limit of the empty set. I think I
            might have said that the one object category is also the terminal
            category. Yeah. You… This quick to say that it’s all objects without
            their morphisms. What is the little toe or dent is it? It’s all objects
            without their morphisms. I… I can’t… What do you mean? Yeah. I don’t
            know what. No, I wouldn’t say so, but maybe after we talk.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">相反，库仑的描述也很简单。别担心。我们来谈谈联产品。你有一些集合。它们的联产品就像一个摘要，或者像一张家庭照片，或者其他什么。</font></font></p><p>Coulomb’s instead, there’s also a pretty easy description. Don’t
            worry. Let’s talk about co products. You have some sets. Their co
            product is like a summary, or maybe like a family photo, or
            something.</p>
        <h2 id="pushouts-and-colimits"><font style="vertical-align:inherit"><font style="vertical-align:inherit">推出和共极限</font></font></h2><h2>Pushouts and Colimits</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它们都放在一起，而且都并列在一起。这是这两个集合的摘要。它是包含它们两个的集合。每个集合都有一个到这个联产品的映射。这些家伙就是这样。对于任何其他集合，如果你有一张来自这里的地图，而我不是来自这里的地图，你将能够在那里获得一张地图。推出，推出。我有一个集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和一张到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">B 的地图以及一张到</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">C</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的地图</font><font style="vertical-align:inherit">，我想取出推出。</font></font></p><p>They’re all in there together, and they’re all kind of side by side.
            This is the summary of these two sets. It’s the set that includes both
            of them. There’s a map from each into this co product. These guys is
            this. And for any other set, if you had a map from this one here and I’m
            not from this one here, you’ll be able to get a map that one there. Push
            out, push out. I have a set <em>E</em> and maps to <em>B</em> and a map
            to <em>C</em>, and I want to take the pushout.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，有人问：“什么是外推？”它会将什么拉回？它只是这种形状吗？而且，然后是，而且，外推意味着这种形状的图表的余极限。因此，我们期待着——我们在某种意义上找到了一种普遍的东西。如果你很迂腐，你会说，或者如果你从字面上理解这个定义，我们正在寻找一种形状，冒号等号，这样所有的图表都可以，但如果你把它们压缩成一个，就把它想象成一个叫做</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的东西，你觉得它更像一个圆锥体，那么它就是同一个想法，只是压缩了这个想法。好的。</font></font></p><p>So, someone asked, “What is a pushout?” What does it pull back? Is it
            just this shape? And again, and then it was, and again, the pushout
            means the co limit of a diagram of this shape. So, we’re looking forward
            to—we’re kind of finding the universal thing in some sense. If you were
            being pedantic, you would say, or if you took that definition literally,
            we’re looking for something of a shape, colon equals, such that all
            diagrams for you, but if you kind of crush these into one, just think of
            this as one thing called <em>X</em>, and you kind of think of this as
            more of like a cone, then it’s the same idea, just kind of compresses
            that idea. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们正在寻找一个集合，它吸收或包含这三个集合的摘要以及它们之间的映射。好的。那么，余极限是什么？它必须以某种方式包含副本，所有这些都以一种好的方式。它必须是自然的。所以，这意味着我们——不管怎样。让我们试着做一下。所以，我需要一个地方来放置这个。但无论它去了哪里，根据自然性，根据它必须交换的事实，这个点必须去同一个地方。</font></font></p><p>So, we’re looking for a set that absorbs or contains a summary of
            these three sets and the maps between them. Okay. So, what is the
            colimit? And it’s gotta contain copies somehow, all these in a kind of
            good way. It’s got to be natural. So, it means we’re—whatever. Let’s
            just try doing it. So, I’m going to need a place for this one to go. But
            wherever it went, by the naturality, by the fact that this has to
            commute, this dot has to go to the same place.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是如果这个点到了这里，那么这个箭头也必须指向同一个地方。这个需要通勤。但是如果这个箭头到了这里，那么这个也必须指向同一个地方。所以，那个就在那里。现在这个就在那里。现在这个就在那里。现在这个就在这里。好的，就是这样。这应该是尽可能自由的，同时让所有这些事情都通勤。所以，现在我们需要一个地方让这个去，它就在那里。</font></font></p><p>But if this dot went here, then this arrow has to also go to the same
            place. This one needs to commute. But if if this arrow went here, then
            this one has to go to the same place. So, that’s there. And now this
            one’s there. And now this one’s there. And now this one here. And okay,
            that’s it. This is supposed to be as free as possible while making all
            those things commute. So, now we need a place for this one to go, and it
            goes there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在这个去那里，这个去那里。现在我们仍然需要一个地方让这个去。所以，我们得到了这个，这就是余极限。这就是这个的总结。所以，所有这些像家庭中的人都可以在这里看到自己，但是——他们——而且——但是关系、箭头被保留了下来，或者其他什么。我不知道。关于这个图的科尔极限以及为什么是这个，有什么问题吗？</font></font></p><p>And now this one goes there, and this one’s over there. And now we
            still need a place for this one to go. So, we get that, and that’s the
            colimit. That’s the summary of this. So, all these like people in the
            family can see themselves in here, but—and they—and—and, but the
            relationships, the arrows, are preserved, or something. I don’t know.
            Any questions about the Cole limit of this diagram and why it is
            this?</p>
        <h2 id="colimits-and-game-semantics"><font style="vertical-align:inherit"><font style="vertical-align:inherit">余极限和游戏语义</font></font></h2><h2>Colimits and Game Semantics</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你认为你有……不能……我的工作是……这种游戏是语义的吗？这不是关于霍乱；这只是关于观察逻辑的游戏语义。每当你有一个 for all、exists 交替公式，然后在最后有一个属性时，是否存在？你是存在玩家，你的对手是 for all 玩家。你还必须在最后证明这个属性。所以，我的意思是，存在一些东西——所以我展示它；这就是我的暗示——这样，有了这些人的地图，事情……</font></font></p><p>if you think you have a… couldn’t… my job is so… is this kind of game
            semantics? This is not about cholera; it is just about watching the game
            semantics of logic. Is there’s whenever you have a for all, exists
            alternating formula, and then a property at the end? You’re the exists
            player, and your opponent is the for all player. You also have to prove
            the property at the end. So, what I’m saying is, there exists
            something—so I present it; that’s my tell—such that with maps from these
            guys, things…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我将它呈现给所有其他的集合。那就是你。你可以展示世界上的任意集合，以及这三个事物的映射，使图表可交换。这就是所有人的，你展示存在一个从我的到你的唯一的映射。所以，不管怎样，如果有人有一个想法，他们把……他们认为……库仑……它是……作为证明者，我的工作是，这是一个真正的承诺，以一种独特的方式制作一个从我的到你的映射，不管你如何找到这三个的匹配。它之所以有效，是因为如果你确保所有这些图表都是可交换的，那么我已经做到了。除了必要的东西，我没有任何信息。所以，我只知道把所有东西都发到哪里。我要把这个点发到哪里？我要把它发送到你此时发送的任何地方。好吗？</font></font></p><p>so I present that to such a for all other ones. That’s you. You’re
            allowed to present any set in the world, together with maps from these
            three things, make the diagram commute. That’s the for all, and you
            present that there exists a unique map from mine to yours. So, no matter
            what, if someone had an idea, they put… they thought the… Coulomb… it
            was… it’s my job as the prover that this is a real commitment to produce
            a map from mine to yours in a unique way, no matter how you find
            matching these three. And the reason it’ll work is because if you made
            sure that all these diagrams commute, then I already did. I have no
            information in mine except the necessary stuff. So, I just know where to
            send everything. Where am I going to send this point? I’m going to send
            it wherever you sent it at this point. Okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于拉力赛还有什么问题吗？这是推力赛。我想我只剩一分钟了，所以我……我只会告诉你类别中的神圣性。我们的奥运会类别中的神圣性。</font></font></p><p>Any questions about pull events? This is the pushout. And I guess I
            only have one minute left, so I… I’ll just tell you what about holiness
            in the category of categories. Our Olympics in the category of
            categories.</p>
        <h2 id="limits-and-colimits-in-categories-of-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴的范畴中的极限和余极限</font></font></h2><h2>Limits and
            Colimits in Categories of Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个类别，这是一个类别，这是一个类别。这个类别中有一个因子，这个，这个类别中，这个……所以当我取冒号时，它必须是一个新的类别。它必须能够解释这里的所有点和所有箭头。那么，库仑……有人猜一下吗？有多少个点？冒号类别有多少个对象？顺便说一下，当它去那里时……这个去那里……</font></font></p><p>Here’s a category, here’s a category, and here’s a category. And
            there’s a factor from this category, this one, in this category, this
            one’s… so when I take the colon, it’s got to be a new category. It’s got
            to be able to interpret all the dots and all the arrows in here. So, the
            Coulomb… anyone have a guess? How many dots? How many objects does the
            colon a category have? So, by the way, it’s when it’s going there… this
            one’s going there…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它在那里……这个要去那里……那里……那里。我要把物体推出去。结果又是三个……是的，我也需要一个地方让这个态射去。所以，它需要去这里。我需要一个地方让这个态射去。这里去什么？这就是答案。这……这是图类中的推出。但我认为这有点有趣的唯一原因是，突然间……</font></font></p><p>it’s there… this one’s going there… there… there. I’m going to take
            the pushout of the objects. It turns out again, for three… yeah, and I
            also need a place for this morphism to go. So, it needs to go here. I
            need a place for this morphism to go. What goes here? And that’s the
            answer. This… this is the pushout in the category of graphs. But the
            only reason why I think this is a little bit interesting is that all of
            a sudden there is…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在原始的范畴中，没有从这里到这里的态射。在这些范畴中，没有从 A 到 C 的态射，然而在推出范畴中出现了从 A 到 C 的态射。所以，这有点像推出范畴从这三个范畴中取出了推出。它取出了对象和态射的推出，但自动添加了复合态射。是的，是的。它有点突现。就像说，“我知道我需要复合态射，所以每当我等待我看到可组合态射时，我就会添加它们。”就像，一个来自这里，其中一个来自这里。然后，我想你可以称之为合并的出现。复合态射出现是因为它有两个。所以，事实上，取范畴的极限很容易，但取范畴的余极限，从这个半 sa 图来看可能很容易，但在某种意义上，无论如何，这是一个更困难的计算。这就是极限和余极限的故事。</font></font></p><p>there is no morphism from here to here in the original. No morphism
            from A to C exists in any of these, yet a morphism from A to C emerges
            in the pushout category. So, it’s kind of like the pushout category kind
            of takes the pushout of each of these three. And it takes the pushout of
            the objects and the morphisms, but adds in the composites automatically.
            Yes, yeah. It’s kind of emergent. It’s like saying, “I know I need to
            have composites, so I will just add them whenever I’m waiting for
            whatever I see to be composable morphisms.” Like, the one came from
            here, one of them came from here. Then, I guess you could call it the
            merge one emerges. The composite emerges because it has two. So, in
            fact, it’s really easy to take limits of categories, but to take
            colimits of categories, it might look easy from this half sa diagram,
            but in some sense, it’s a more difficult computation anyway. That’s the
            story of limits and colimits.</p>
        <h2 id="colimits-and-diagrams-of-circles"><font style="vertical-align:inherit"><font style="vertical-align:inherit">圆的余极限和图</font></font></h2><h2>Colimits and Diagrams of
            Circles</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？</font></font></p><p>Any questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。下次，我们将讨论余极限和扇形，以及它们与画许多圆圈并将东西放在一起的图画有什么关系。基本上，这些图画就是所谓的余极限带上的图画。当你组合它们时，你会在圆圈内放置一些小黑圈，然后擦除这些外圈。我们将使用余极限来做到这一点。还有圆圈套圆圈和图套图的故事。我们明天等你。</font></font></p><p>Okay. So, next time, we’ll talk about colimits and fans, and what any
            of this has to do with pictures where you draw lots of circles and you
            put things together. Basically, what’s going to happen is that these
            will be pictures of these will be pictures on what are called colimit
            bands. And when you compose them, you put little dark circles inside the
            circles, and you erase these outer circles. We’re going to be using
            colimits to do that. And the story of circles inside of circles and
            diagrams inside diagrams. We’ll be waiting for you tomorrow.</p>
        <h1 id="applied-category-theory.-chapter-6-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 6 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 6, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 1 月 31 日) — 55:48 </font></font><a href="https://youtube.com/watch?v=4HoNfw7XCKU"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=4HoNfw7XCKU</font></font></a></p><p> 6
            years ago (Jan 31, 2019) — 55:48 <a href="https://youtube.com/watch?v=4HoNfw7XCKU">https://youtube.com/watch?v=4HoNfw7XCKU</a></p>
        <h2 id="summary-11"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">麻省理工学院课程 (18S097) IAP (独立活动时间) 讲座由 David Spivak 和 Brendan Fong (Spifong) 讲授，涵盖了类别、图表和函子。讲座探讨了类别中的推出概念，特别是在有限集的背景下。给出了示例来说明如何将图表总结为其他类别中的对象。讨论还涉及初始对象和联产品的概念，以及这些概念与函数和图表的组合的关系。讲座最后介绍了操作符的概念，它们是描述类别组合理论的结构。</font></font></p><p>This MIT Course (18S097) IAP (Independent Activities Period) lecture,
            taught by David Spivak and Brendan Fong (Spifong), covered categories,
            diagrams, and functors. The lecture explored the concept of pushouts in
            categories, particularly in the context of finite sets. Examples were
            given to illustrate how diagrams can be summarized as objects in other
            categories. The discussion also touched on the idea of initial objects
            and co-products, and how these concepts relate to the composition of
            functions and diagrams. The lecture concluded by introducing the concept
            of operads, which are structures that describe theories of composition
            in categories.</p>
        <h2 id="introduction-to-papa-rats"><font style="vertical-align:inherit"><font style="vertical-align:inherit">鼠爸爸简介</font></font></h2><h2>Introduction to Papa Rats</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，今天的目标是告诉你们关于 Papa Rats 的所有事情，或者至少让你们思考所有四个元素，可能是设置中最简单的兴趣，即 ricotta 网格有限集。</font></font></p><p>So, today the goal is to tell you all about Papa Rats, or at least
            get you to think about all four elements, possibly the simplest interest
            for setting, which is ricotta grid finite sets.</p>
        <h2 id="limits-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">限制和图表</font></font></h2><h2>Limits and Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，只是提醒一下，昨天的一些夸张言论是，限制总结了这是如何成为一个有争议的图表。</font></font></p><p>So, just a reminder, some swagger from yesterday was that limits
            summarize how this was a little contentious diagrams.</p>
        <h2 id="functors-and-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子和范畴</font></font></h2><h2>Functors and Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这发生在类别中，我们将其称为 C。图表是什么意思？图表是一个函子，我将称之为 D，来自 D C 中的其他类别。所以，我们说 David 说这个其他类别应该是一个小类别，你可以从技术上理解这一点，在这种情况下，这意味着一种增长，或者旧的饮料，对象的集合是一个适当的集合。但你也可以认为 I 只是你觉得这么小的东西。哇。我们来看例子。所以，它采用这个图表并将其总结为一个对象，之前的对象。好的。</font></font></p><p>So, this takes place in the category, we’ll call it C. What does the
            diagram mean? A diagram is a functor, which I’ll call D, from some other
            category, in D C. So, we said David said this other category should be a
            small category, and you could take that sort of technically, in which
            case that means a kind of grow, or the old drinks, the collection of
            objects is a proper set. But you might also just think of I as just
            something that you feel this small. Wow. We’ll see examples. So, it
            takes this diagram and summarizes it as an object, the objects before.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就是这样。让我也给你们每个人举一个小例子，我们昨天已经看过了。</font></font></p><p>So, that’s just. Let me also give you a tiny one, each I, which we
            saw yesterday.</p>
        <h2 id="initial-objects-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">初始对象和图表</font></font></h2><h2>Initial Objects and Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在 David 的演讲中，您是如何做到这一点的？我们有这个图表。我们取函子，它是一个 1 到 100 的类别，然后我们寻找最好的函子，在某种意义上，函子是该图表的 4 个因子或弱因子。所以，它是取图表但将其推入单个对象，并且有这个最佳的概念，它表示它立即具有从这个函子到这个公共集合的自然变换，然后如果有任何竞争函子具有到它的自然变换，那么这个东西就是初始的。它更好。它有点像之后的。</font></font></p><p>Which, in David’s presentation, how did you do this? We have this
            diagram. We take the functor, which is a 1 to 100 category, and then we
            look for the best, in some sense, functors that’s 4 factors or weakly
            factors the diagram. So, it’s taking the diagram but pushing it through
            a single object, and there’s this notion of best, which says that it has
            at once a natural transformation from this functor to this common set,
            and then if there’s any competing functor with a natural transformation
            to it, this thing is initial. It’s better. It sort of has an after
            that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以，David 说，每个类别都为您提供初始对象。所以，我还没有看到弹出的初始对象定义。所以，定义是：存在，存在一个唯一映射，然后值得从初始对象或 X 采取行动。所以，具体来说，他们试图有限集，这种空的东西的比赛，空图，是空的。先生，给定任何其他集合 X 从截距到 X，也就是，函数是什么？对于这个的每个元素都是一样的。取 X 的一个元素，但它们不是脚凳。所以，只有一种方法可以做到这一点。好的。你介意在你的 dixit 后面写上唯一吗？谢谢。所以，这也是你的可能。这个短语在这里会用到。</font></font></p><p>Okay. So, David said that the ends, each category gives you the
            initial object. So, haven’t seen the definition of initial object
            popping that up. So, the definition is: there exists, there exists a
            unique map, and then deserve to act all from the initial object, or X.
            So, in particular, and they try to finite sets, this tournament of this
            sort of empty thing, empty diagram, is empty. Sir, given any other set X
            from the intercept to X, which is well, what is the function? Is the
            same for every element of this. Take an element of X, but they’re not
            ottomans. So, there’s only one way to do that. Okay. Would you mind
            writing unique after your dixit? Thanks. So, this will also be your
            possible. This phrase here will use.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。另一个例子：离散二元类别。</font></font></p><p>Okay. Another example: discrete two element category.</p>
        <h2 id="discrete-categories-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">离散类别和图表</font></font></h2><h2>Discrete Categories and
            Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，打开一些酒，看看这如何相关。这个图表是远端类别的赞许只是另外两个，不同意。是一个对象，很好，实际上配备了地图，从 Mike 那里，这是运行到它的旋度的自然变换。但是我们有这个普遍性属性，所以这是这样的。所以我们有这个主题，对于任何其他对象对，比如对象</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">c</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">或任何其他具有</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">g</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">映射到它的对象，都存在一个唯一的映射。</font></font></p><p>So, to unpack some wine, so how this relates. This diagram is that
            the thumbs up from distal category is just two others, not agree. Is an
            object, fine, equipped actually with maps, and from Mike, that’s the
            natural transformation running to the curl of it. But then we have this
            universality property, and so this is such that. So we have this theme
            such that for any other pair of objects, say the object <em>c</em> or
            any other object with <em>g</em> mapping to it, there exists a unique
            map.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">据说地图可以使这些图交换。因此，交换性是自然性，除非它是它们在该国的自然变换的交换性的交换性。所以，如果我们有——我的意思是，如果我们有两个集合，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> = {1, 2} 和
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">​​ Y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> = {1, 3}，那么——继续观察——考虑并集，即 {1, 2, 3}。
        </font></font></p><p>Maps are said to make these diagrams commute. So, commutativity is
            the naturality, unless it’s the commutativity of the commutativity of
            their natural transformations in the country. So, if we have—what I mean
            by this is that if we have some two sets, <em>A</em> = {1, 2} and
            <em>Y</em> = {1, 3}, then—keep watching—consider the union, which is {1,
            2, 3}.
        </p>
        <h2 id="disjoint-union-and-pushouts"><font style="vertical-align:inherit"><font style="vertical-align:inherit">不相交联合和推出</font></font></h2><h2>Disjoint Union and Pushouts</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是不相交并集将元素“一”的这两个实例视为不同的。因此，我们可以考虑一个包含四个元素的集合。我们有一个来自集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X 的</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">元素一，好吧。因此，一种直观的思考方式可能是——我认为我们有一个包含两个点的集合，另一个包含三个点，并且有一种感觉，不相交并集或曲线乘积只是包含五个元素。</font></font></p><p>But the disjoint union considers these two instances of element “one”
            as distinct. So, we can consider, say, a set with four elements. We have
            a one coming from the set <em>X</em> to come, okay. So, a way to think
            of this visually may be—I think we have a set with two points, another
            three points, and there’s a sense that the disjoint union, or the curbed
            product, is just having the five elements.</p>
        <h2 id="visualizing-pushouts"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可视化推出</font></font></h2><h2>Visualizing Pushouts</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们将两袋点放入一个袋子中。我们如何从下一个秋天、从停车场到任何其他竞争对手获得这个函数，就是如果我们有其他具有函数</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">g</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的集合，我们可以像这样在这个承诺的唯一映射中定义这个唯一映射。因此，我们取不相交并集的一个元素。如果它是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">X</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Y</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">或
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的元素，则是活跃的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">b </font></font></em> <em><font style="vertical-align:inherit"><font style="vertical-align:inherit">g</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">，好的。这样，我们就会给我发送一封电子邮件。因此，再次重申，这个定义相当密集，属于使用常见扩展的任意元素的抽象定义。它非常密集，需要一段时间才能解开。因此，如果这样，或者——和竞争事物。
        </font></font></p><p>Let’s just take the two bags of dots and put them into a single bag.
            And how we get this function from, from next fall, from the carpark to
            any other competitor, say, is that if we have—if we have some other set
            with functions <em>f</em> and <em>g</em>, we can define this unique map
            in this promised unique map like this. So, we take an element of the
            disjoint union. If it’s an element of <em>X</em>, <em>Y</em>, or
            <em>f</em>, to be a lively <em>b</em> <em>g</em>, okay. So, that gives
            us an email to me. So, again, this definition is rather dense, of the
            sort of abstract definition of arbitrary elements using common
            extensions. It’s dense, and it takes a while to unpack. So, if such
            that, or—and the competing thing.
        </p>
        <h2 id="pushouts-and-equivalence-classes"><font style="vertical-align:inherit"><font style="vertical-align:inherit">推出和等价类</font></font></h2><h2>Pushouts and Equivalence
            Classes</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，请发表你的看法。推出是一个不相交联盟的问题，但是……</font></font></p><p>So, have your five cents. The pushout is a question of the disjoint
            union, but…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，推出等于我们取等价类的商。记得在第一讲中，我们讨论了分区。分区的一部分也称为等价类。因此，我们这里有一个包含所有这些元素的集合，如果</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">中某个元素的图像，我们说 1=2 —所以，我们说如果那不是相同元素的图像，就将其添加到某种传递闭包中。</font></font></p><p>So, pushout is equal to the quotient where we take equivalence
            classes. So, remember in the first lecture, we talked about partitions.
            So, a part of a partition is also known as an equivalence class. And so,
            we have the set here with all these elements, and we say that 1=2 if the
            image of some element of <em>A</em>—so, we say that if that weren’t the
            image of the same element to add it for some sort of transitive closure
            on this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在</font><em><font style="vertical-align:inherit">g (a) 中确定了</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (a) </font><font style="vertical-align:inherit">，然后追逐，就像我们在图上看到的，是</font><em><font style="vertical-align:inherit">b</font></em><font style="vertical-align:inherit">。因此，具体来说，例如，如果我画出 — — 那么就是推出。因此，这些 — — 这是这个映射中的两个元素，以及它在这个元素中的映射，是的。推出包括 — — 首先，我们考虑这个曲线乘积或这个不相交并集的六个元素，然后我们确定由某个元素的相同元素映射到的元素。</font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>So, we identified <em>f</em>(a) in <em>g</em>(a), and then chase
            around, like we saw on the diagram, is <em>b</em>. So, in particular,
            for example, if I draw—then the pushout. So, these—this is a two of this
            has two elements in this map, and what maps it here in this element us,
            yeah. Pushout consists of—it’s sort of first, we think of the six
            elements of this curbed product or this disjoint union, and then we
            identify ones that are mapped to by the same element of something
            up.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。所以，这个和这个是可以识别的，因为它们是同一事物的一部分，这个和这个也是。所以，事实上，它们最终有四个元素，因为这三块砖在同一个岛上。所以，在某种意义上，它所做的就是你可以把这些点看作是这个东西在拓扑上将连通的组件折叠成一个点。</font></font></p><p>Yes. So, this one and this one are identified because they’re part of
            the same thing, and so is this one and this one. So, in fact, they end
            up with four elements because these three bricks are on the same island.
            So, in some sense, what it’s doing is you can think of these points as
            being this thing topologically collapsing connected components to a
            point.</p>
        <h2 id="review-and-questions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">回顾与问题</font></font></h2><h2>Review and Questions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这三件事通过这里的部分连接起来，或者说将它们交换在一起，它们就变成了这里的这个。然后，就解决了。这就是推出的感觉，这也是本讲座中最重要的内容。</font></font></p><p>So, these three things were connected through parts in here, or sort
            of switched them together, and they became this one here. And then, work
            out. And this is sort of the flavor of pushouts, which is what’s going
            to be anything important in this lecture.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，复习完之后，我会给你一些问题。这是空集。所以，这些函数是微不足道的。好的。</font></font></p><p>So, after that review, let me give you some questions. That’s the
            empty set. So, those functions are the trivial ones. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，只需花几分钟与朋友聚聚，试着抓住这个微妙的时间，至少你可以大声喊出并说出这三件事中每件事需要推出多少个元素。</font></font></p><p>So, just a subtle time to friend up in your few minutes, trying to
            grab at least you can shout out and say how many elements to pushouts of
            each of these three things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第二个是人们无法在交叉点中间检测到足够的东西。所以，他说你没有理解正确的概念：我想要一个可以容纳项链的东西，容纳所有这些东西，或者他们想要的都在那里，但我没有，但我想要一个——无论它是否真的通过谎言实现——就像做每一个创新，只是一件事。是的。</font></font></p><p>Second one is one couldn’t detect the thing enough in the middle of
            the intersection. So, he said you don’t get right the concept is: I want
            something that can hold a necklace holds all of that, or all they want
            is there, but I don’t, but I want a—no matter whether it comes through
            actually come through lies—like just do one every one innovation, just
            be one thing. Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，当……A 是两栖动物，X 是陆生动物，Y 是水生动物。然后，我想要的只是——我不想把胎生动物算在内，你们所有的东西都算在一类中。这些都是一个类别对象。左边一个，右边一个，上面三个或四个，是一个作为符号集的痕迹。然后，它配备了两个功能。这是这些对象的副本。沉默。这个东西怎么样？</font></font></p><p>So, when… A is amphibians, X is land animals, and Y is water animals.
            Then, I wanted just—I don’t want to count viviparous, anything that’s in
            your all in one. These are all in one category object. One on the left,
            on the right, up, three or four side is a trace as a semiotic set. And
            then, it comes equipped with two functions. Here are the copies of these
            objects. Silence. What about this thing?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">原因是一切都通过这个图表连接起来，这是一种理解方式……哦，好的。</font></font></p><p>And the reason is that everything is connected through this diagram,
            and it’s one way to understand… Oh, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，最终的图像图表效率很低。我……这个类别，也就是图表的域，很好，不再活跃。</font></font></p><p>So, so inefficient final image diagram. I… this category, which is
            the domain of the diagram, that’s fine, active anymore.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一个很好的定理，有点像已经看到两个事物对初始对象的推动有一个初始目标，或者只是在这里他们理解这两个事物的推动只是由协议给出的。但事实上，即使是任何类别，如果我们转到 C，如果 C 总是有……所以无论 C 有一个初始对象和或任何图表都有……那么它都有一个有限的……它没有汽车如何停车。它有一切……</font></font></p><p>So, there’s a nice theorem, sort of already seeing that a push out of
            two things over the initial object to have an initial objective, or just
            here they understand the push out of these two things are just given by
            the protocol. But, in fact, even any category, if let’s go to C, if C
            always has… so whatever C has an initial object and or any diagram that
            has… then it has a finite… it doesn’t have just how the car parks as
            well. It has all…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你想展示某物有所有有限的极限，那么这是一个很好的事实。所以，这意味着你总是可以画出一个漂亮的任何图表，你可以实际绘制，我们会在上面找到它。正如你总是可以要求的那样。它是对它的总结的卷曲数学，以及它总是如此。只要你知道什么有推出和一个初始对象，每种颜色的一切都是唯一的，直到唯一的同构。</font></font></p><p>So, that’s a nice, nice fact to know if you want to showing something
            has all finite limits. So, it means that you can always draw a nice any
            diagram that you can actually draw, which will we find on it. As you can
            always ask for this. It’s curly math over the summary of it, and of what
            always is this. As long as you know what has pushouts and an initial
            object, everything every color would is unique up to unique
            isomorphism.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这意味着基本上是的，取决于一些重命名。空集实际上是唯一的，但像不相交并集这样的东西通常不是唯一的。在这方面，我实际上并没有告诉你构造这个集合 X 加 Y 的某种正式方法。所以，我本可以将集合的元素称为“一个素数”和“一”之类的。我曾让“一号先生”以一种方式退出，但任何合理的构造，对于任何构造，在尊重这些包含的元素之间总会存在一一对应关系。</font></font></p><p>What that means is basically yes, up to some renaming. The empty set
            is actually unique, but something like the disjoint union is not unique
            in general. In that, I haven’t actually told you some formal way to
            construct this set, X plus Y. So, I could have called the elements of
            the set like “one prime” and “one” or something. I’ve had “Mister One”
            exit one way, but any reasonable construction, for any construction,
            there will always be a one to one correspondence between the elements
            that respect these inclusions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，实际上你需要唯一性，直到重命名。你可以抽象地提出这个论点，所以它适用于任何类别。证明这种唯一性的存在，这意味着如果你有两个可能的余积——一个余积在这里，另一个余积——就会有到它的映射。从那里到那里会有含义。但因为这个东西是余积，所以没关系。因为这个东西是余积，它已经有一个唯一的映射了。而且它们必须再次同构，通过你再次传递逆，通过宇宙。所以，当人们谈论余极限和极限之类的东西时，他们经常会说极限、乘积、初始对象。只有一个并不严格地说是正确的。所以，这可能是一些戏剧性的，但它足够接近事实。这是一种思考事物的好方法。</font></font></p><p>So, it’s effectively you need unique up to renaming. You can make
            that argument abstractly, so it works in any category. Justified this
            sort of this sort of existence of the unique, that means that if you
            have two possible co products—a co product here and another co
            product—would have maps to it. And there will be a meaning that from
            there to there. But because this thing is a co product, that’s alright.
            Because this thing is a co product, it would have a unique map back down
            already. And they have to be isomorphisms again, by you pass the inverse
            again, by the universe. So, when people talk about colimits and limits
            and things like that, they’ll often say the limits, the product, the
            initial object. It’s just not strictly sort of true that there’s only
            one. So, it may be to be some drama, but it’s close enough to be true.
            It’s a good way to think about things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，所以这件事的必然结果是，因为我们告诉过你初始对象和推出对象属于类别，我说得好笑，我们看到了你的五种感觉。所有有限元素，它们又具有我们在那里看到的那种将事物粘合在一起的味道。好吧，我想，一个代表五个对象的图表的共同形象，我想我把我们的头放进去了，但我画了四个不同的函数，这只是将这个东西折叠成一些连通组件的集合。</font></font></p><p>Okay, so a corollary of that thing is that because we told you what
            initial objects and pushouts are in the category, funny I said, we see
            that kind of your five senses. All finite elements, and they have again
            this flavor that we saw there of just gluing things together. Well, the
            co image of a diagram, I guess, which represents five objects, and I
            guess I put our heads in, but I drew four different functions, is just
            going to be the collapsing of this thing into some set of connected
            components.</p>
        <h2 id="pushouts-and-car-limits"><font style="vertical-align:inherit"><font style="vertical-align:inherit">推出和车辆限制</font></font></h2><h2>Pushouts and Car Limits</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">您的查看器是什么样的？我们将其用作边。因此，具体来说，为了推出我这边的汽车，其极限将有五个元素。一辆车，但这辆车对应这辆车，这辆车，还有一辆车对应整个国家。对于其核心，您还需要从图表中进行这种自然转换。因此，在核心事件之间，每个集合都有一个函数，它可以跟踪您如何从这个大图表中走出来，或者如何取出每个小块并将其变成共同图像中的一个块。</font></font></p><p>What’s your viewer like this? We use as edges. So, in particular, to
            push out, my side of the car, limit of this will have five elements. One
            car, but this one corresponds to this one, this one car, this one, and
            one corresponding to this entire nation. You also, for the kernel of it,
            you want this natural transformation from the diagram. So, you have a
            function from each set here between the kernel event, that that sort of
            tracks how you went from this big diagram, or how you took out each of
            these small pieces and turn it into one piece in the co image.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这只是明显的投影图。所以，我想，这个大质量中的所有东西都映射到代表它的位置。这基本上也是我们之前讨论过的分区。由于我们研究的大多数类别都是基于类别的，或者至少固定的锦标赛通常有这种直觉，好吧。所以，在一些类别论文中，跨度只是一个花哨的名字，我们称跨度推出的东西为跨度。</font></font></p><p>And that’s just the obvious projection map. So, everything in this
            big mass maps to that represents it, I guess. It’s also essentially the
            partition that we talked about earlier. And since most categories we
            work in are based on the category, or at least set tournaments often
            have this intuition, okay. So, in some category papers, spans are just a
            fancy name we call things that we push out over spans.</p>
        <h2 id="span-and-symmetric-monoidal-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">跨度和对称幺半群类别</font></font></h2><h2>Span and Symmetric
            Monoidal Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">由于这些是同一类东西，我们报告的错误是更清晰的手。那么，就像你，那个露西亚的定义一样。因此，对于 5 xx 对象的诅咒粉丝，穆斯林，有一个对称的单子类别。所以，如果我想知道来自额外生命的嗡嗡声集合中有什么，这些是被诅咒的乐队。你为什么要把等价的东西刷到地毯下？是的，有一些办公室使徒，一个圣诞节。所以，这意味着如果我将 n 中所有这些元素的名称更改为两个不同的名称，那么它仍然是同一个人。</font></font></p><p>Since these are the same sort of thing, the errors we report are
            crisper hands. So, then, like a definition for you, that Lucia. So,
            there is a symmetric monoidal category for cursed fans of 5 xx objects,
            Muslims. So, if I want to know what is in the hum set from extra life,
            these are cursed bands. Why are you brushing the equivalent thing under
            the rug? Yes, there are some office apostles, a Christmas. So, what this
            means is that if I change the names of all these elements in n to two
            different names, then it’s still the same person.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，我告诉你是什么类别。我告诉你了态射中的对象。我需要像这样抛出组合规则。</font></font></p><p>And then, so I’m telling you what category. So, I told you the
            objects in the morphisms. I need to throw the composition rule like
            this.</p>
        <h2 id="composition-and-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">组成及分类</font></font></h2><h2>Composition and Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是为什么考虑范畴很重要。你可以用任何有有限元素的范畴来构造，但 Finn 说这里是这种范畴的代理，因为我们知道有限元素。啊，好问题。这是一个错误。哦，这个东西对于 y 的下一个是错误的。但你已经注意到，如果从 x 到 y 的箭头和从 y 到 x 的箭头之间存在某种作用，这是范畴结构的重要组成部分，你一直都在使用它。</font></font></p><p>This is why it’s important to consider categories. You can do this
            construction with any category with finite elements, but Finn said here
            is our proxy for such a category because we know our finite elements.
            Ah, good question. It’s an error. Oh, this thing is an error for next to
            y. But you’ve noticed that if there’s a sort of by action between arrows
            from x to y and arrows from y to x, and this is an important part of the
            categorical structure, all the way you always work with it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我有一个从 x 到 y 的箭头和一个从 y 到 z 的箭头，那么我该如何得到从 x 到 z 的单个诅咒、诅咒时间？单个箭头是什么？我希望从 x 到 z 到对象的箭头中有一些 ella 目标，以及我如何替换一些。所以，我想总结这些诅咒信息。我这样做的方法是将这个中间跨度推出。</font></font></p><p>So, if I have an arrow from x to y and an arrow from y to z, then how
            am I to get a single curse, curse time from x to z? In what a single
            arrow? I want some ella objective there in an arrow from x to the object
            in there from z to the home, and how I sub some. So, I want to summarize
            this cursed information. And the way I do that is I take the pushout of
            this middle span.</p>
        <h2 id="pushouts-and-associativity"><font style="vertical-align:inherit"><font style="vertical-align:inherit">推出和关联性</font></font></h2><h2>Pushouts and Associativity</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，推开，是的。不知怎么的。然后现在我可以将这两个东西组合在一起，从 x 到那个东西，从 c 到那个东西。所以，这是定理、另一个定义的原因在于，检查这个东西是否是结合组合并不是一件容易的事。身份就是身份。所以，是的。如果这三件事只是为了得到身份尖点，而另一个人从 x 跑到 x，你就把顶点，中心的东西 x，然后你把这两个函数，也就是另外两个函数。</font></font></p><p>Yeah, pushout, yeah. Somehow that. And then now I can compose these
            two things together, from x to that thing, from c to that thing. So, the
            reason this is a theorem, another definition, is that it’s non trivial
            to check that this thing is an associative composition. The identities
            are just identities. So, yeah. If these three things are just to get the
            identity cusp, and the other person runs from x to x, you make the apex,
            the center thing x, and you make the two functions, the other two
            functions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">事实证明，当你沿着恒等函数推出某个东西时，如果它保持不变，你就无法很好地总结这一点。这个东西，你真的可以做任何事情。所以，所有信息都相当快。好的。我告诉你一个对称幺半群类别。</font></font></p><p>Turns out, when you push out something along an identity function, if
            it remains the same, you can’t summarize that well. This thing, you can
            really do anything. So, all the information that’s rather quick. Okay.
            I’m telling you a symmetric monoidal category.</p>
        <h2 id="symmetric-monoidal-categories-and-coproducts"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对称幺半群范畴和余积</font></font></h2><h2>Symmetric Monoidal
            Categories and Coproducts</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我还想告诉你局部积。所以，是的，我们只使用曲线积。所以，只需连接事物。我有一对函数。好的，在对象上。在幺半群积中，余积实际上只是对象的核心积。所以我们取集合 X 和集合 Z，然后取破坏的联合态射。我们基本上可以做同样的事情。所以，浪漫图片粉丝，好吗？我可以有一个新的粉丝。</font></font></p><p>I also want to tell you the local product. So, yeah, we’re just going
            to use the curved products. So, just join, you know, things. I have a
            pair of functions. Okay, on objects. The coproduct, in the monoidal
            product, is really just the core product of objects. So we take set X
            and set Z, and we take the destroyed union morphisms. We can basically
            do the same thing. So, romantic picture fans, okay? I can just has a new
            fan.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是数据。对称单半群范畴有这些东西可以帮助你得到我们错过的东西：这些组合规则的结合律和单位分配。我不会向你展示它们，但定理是它们存在，而且它们一切都经过检验。这是一个结合组合。这是一个……让我回过头来。我给了你一张单半群乘积的示意图。</font></font></p><p>So that’s the data. The symmetric monoidal category has these things
            that help you have what we miss: the associativity and unit allottee of
            these composition rules. I’m not going to show you them, but the theorem
            is that they exist, and they are everything checks out. This is an
            associative composition. This is a… so let me go back. I’ve given you a
            schematic picture of the monoidal product.</p>
        <h2 id="visualizing-composition"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可视化构图</font></font></h2><h2>Visualizing Composition</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">让我也给你一张构图示意图。所以，我们的想法是，如果我们采取一些措施……那么这里有一个克里斯汀，第二个克里斯汀。</font></font></p><p>Let me also give you a schematic picture of composition. So, the idea
            is that if we take some sense… so here’s one Kristen and second
            Christine.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，那么这些玩具粉丝的概念是什么？这是一个诅咒。它是从 X 到 Z 的脆皮，然后那个顶点是这里内部锅的推出。所以，它是此部分的连接组件的数量。所以，这里有一个，这里有一个，这里还有一个。所以，那是四个。然后我们组合，然后从这里有一个规范映射，表示映射到相应的连接组件。如果我们关闭……所以如果我们将这里的每个东西都映射到这个，直到它连接起来，当我们看到这个第一个在表演的海岸之外，第二个在第二个之外，那个函数不是很有趣，从另一个方向回来，这是第一个连接组件的一部分，昨晚这三个或两个。</font></font></p><p>Okay, so what’s the concept of these toys fans? It’s a curse bad.
            It’s a crisp from X to Z, and then that apex is the pushout on this
            interior pot here. So, it’s the number of connected components of this
            section. So, that’s one here, one here, one here, and another one here.
            So, that’s four. And then we compose, and then there’s a canonical map
            from here that says that mapped to the corresponding connected
            component. And if we close… so if we map sort of each thing here through
            this and until it’s connected, when we see that this first off the coast
            of acting, second off Mr.&nbsp;Second one, that function was not very
            interesting and coming back the other way in this one is part of the
            thing that’s the first connected component, and these three or that two
            last night.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是 Chris Beck 的会议。因此，另一种可视化此事物的方法是让所有人联想到第二张图所示的直觉。</font></font></p><p>So, this is the conference at Chris Beck. So, another way to
            visualize this other thing is to appeal them all to an intuition that
            looks like the second diagram.</p>
        <h2 id="connectivity-and-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接和图表</font></font></h2><h2>Connectivity and Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我会认为 X 是一秒钟的边界。所以我设置了 X，它有四个部分。然后……这就是 X，而 Kristen 所做的就是将其中之一变成这个边界上的某个东西。为什么后面还有五件事？是的，谢谢。有人还活着。然后这个诅咒将这四件事、这五件事联系起来。所以，它说这个东西和那个东西相连，他和那个东西相连，或者一些……</font></font></p><p>So, instead, I’m going to think of X these things is the boundary of
            a second. So, I have some set X with this sort of four parts coming up.
            And then… so this is the X, and what a Kristen does is it takes one of
            these things and turns it into something on this boundary. Why were
            there five things after? Yes, thanks. Somebody’s alive. And this curse
            then then connects these sort of four things, these five things. So, it
            says that this thing is connected after that one, he’s connected, or
            some…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">而这个就出来了，消失了。所以，你可以把 X 看作是一种偏见，将你可能说的那个东西变成那个东西，然后把它推到某个东西上。对不起，推出去不好，但连接事情会发生，然后拉出来。我知道，重新做找到的连接。所以，它看起来像那样。然后同样地，从 Y 到 Z 更合适，你用同样的方式做。在头孢氨苄 C4 的边界上我应该有多少个 while 循环，然后在里面，我们有这三个组件和一些连接模式，Kirsten 的翻译会把它翻译成我们？然后，这很有趣，但如果我们只对连接模式感兴趣，我们可以总结一下。</font></font></p><p>and this one just kind of comes out, vanishes. So, you can view X as
            a bias of taking that something that you might spoke into that something
            and pushing it out to something. I’m sorry, pushing out is bad, but
            connecting things happen and pulling out. I know, redoing the
            connectivity found. So, it looks like that. And then similarly, it’s
            more fitting from Y to Z, you do it the same way. How many while loops
            should I have in the boundary of cephalexin C4, and then inside, we have
            these three components and some connectivity patterns that Kirsten’s
            translation translates into us? And then, it’s funny, but we can sort of
            summarize if we’re only interested in the connectivity pattern.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这些蓝线总结了内部和外部板之间的某种连接模式。如果我们只对连接模式感兴趣，那么我们可以总结一下这个图。为什么它现在可见？它是完全内部的，但我们可以总结端口 A、B、C 和 D 的这个东西。然后，首先断开连接，这些端口不会通向任何地方。在这三个端口中，连接到这个端口。所以，如果我们有一些直觉，比如说我们认为这些是将东西匹配在一起的理想线，更快地将导电端子匹配在一起，或者如果我们将其视为匹配变量的模式，这包括内部内容的商。那么，这正是这些边界变量之间相互作用或连接的新模式。所以，这个类别，这个对称的单子类别，当然，捕捉了变量或连接识别的概念。所以，你可以在此基础上创建一些有趣的新语法，以及各种形式的逻辑，这些逻辑在很大程度上是变量共享的想法。但是从这个角度来思考一组图表会更有视觉吸引力。</font></font></p><p>So, these blue wires sum up some sort of connectivity patterns
            between the inside and the outside boards. And if we’re only interested
            in the connectivity pattern, then we might summarize this diagram. Why
            is it now visible? It’s completely internal, but we might summarize this
            thing for ports A, B, C, and D. Then, this first for disconnect, there
            these ports don’t go anywhere. And in these three ports, connected to
            this port yet. So, if we have some intuition, say what we think of these
            as ideal wires that are matching things together, faster matching
            conductive terminals together, or maybe if we’re thinking of this as a
            pattern of matching variables, this includes a quotient out of the
            internal stuff. Then, this is exactly this new pattern of interaction or
            connectivity between these boundary variables. So, this category, this
            symmetric monoidal category, of course, bands captures this notion of
            identification of variables or connectivity. So, you can build upon that
            to do to create some interesting new syntax as well for various forms of
            logic across much the variable sharing idea. But something’s from more
            visually appealing is to think about a set of diagrams from this
            perspective.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">问题？</font></font></p><p>Questions?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，思考这些很有趣。它就像某种形式的输入和输出，或者超出了它的范畴？这很有趣。你可以从中得到一些哲学教训。嗯，这取决于你所说的输入和输出到底是什么意思。所以，如果你在思考，比如说，一个电路之类的东西——我不知道，就像一个电池——你可以说边界的重复就是有这两个点。你可以用一个 crisp 和/或一个 morphism 的定义域和余域来建模它。</font></font></p><p>Yeah, it’s interesting to think of these. It’s like something for
            some form of inputs and outputs, or is that outside of its? It’s
            interesting. You can draw some sort of philosophical lessons. Well, it
            depends what you mean by input and output really. And so, if you’re
            thinking about, say, something like a circuit—I don’t know, just like a
            battery—you can say that the repetition of boundary is just to have
            these two points. And you might model that with the domain and codomain
            of a crisp and/or of a morphism.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，您应该将哪一个视为输入和输出？这就像您可以做出的正式区分，即，好吧，将这个视为输入，因为它是域，另一个是输入，因为它是陪域。这是因为陪域而产生的输入。您可以用这种方法进行处理，这可能是对输入和输出一词的合理使用。但它实际上没有很强的语义内容。这是我们之前观察到的。</font></font></p><p>But which one should you consider the input and output? It’s like a
            formal distinction you could make that says, well, consider this one the
            input because of the domain, and the other one the input ’cause it’s the
            codomain. That’s an input ’cause of the codomain. And you can in sort of
            work with that, and that might be a sensible use of the word input and
            output. But it doesn’t really have strong semantic content. And that has
            been our observed earlier.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以以某种方式将这些共带组合起来。我会对其进行定向，以便你可以翻转它，你可以考虑输出、输入、输入、输出。这实际上不会产生语义差异。因此，它们有点像是处于这种特定结构中，其中有一层我们的内部专家，你可以考虑一下。但你也应该考虑定向性质与结构核心无关的方式。这就是我是否可以在此设置中放置输入和输出的一些讨论。</font></font></p><p>You can these these co bands somehow. I’ll orient it so you can flip
            this, and you can consider the output, input, input, the output. And it
            wouldn’t really make a semantic difference. So, they’re sort of in this
            particular structure, there’s a layer of our internists to it that you
            could think about. But you should also think about the ways that the
            oriented nature kind of irrelevant to the core of the structure. And
            that’s sort of some discussion of whether I can put an input and output
            in this setting.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个问题：图表。似乎我们可以在图表中将相同的信息表示为 X 和 Y 的关系。</font></font></p><p>Another question: diagrams. It seems like we could represent the same
            information in the diagram as a relation on X cross Y.</p>
        <h2 id="diagrams-and-relations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">图表和关系</font></font></h2><h2>Diagrams and Relations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是正确的吗？因为您可以直接说出哪些 X 和 Y 是相连的。是否有一些数据未在图中表示出来，这些数据对于海岸扇很重要，与 N 和您选择的态射有关？所以，这是在有限集中，这是一个很好的观察。因此，关系是跨度的一种特殊形式，在那些试图吞噬更多扩展的有限集上。</font></font></p><p>Is it correct? Because you can just say which X’s and Y’s are
            connected. Is there data that’s not represented in the diagram that’s
            important about a coast fan, that has to do with N and the morphisms
            that you’re choosing? So, this is in finite sets, and that’s a good
            observation. So, relations are a special form of span in the kind of
            your finite sets that are trying to eat more expand co well these.</p>
        <h2 id="relations-and-equivalence-relations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关系和等价关系</font></font></h2><h2>Relations and Equivalence
            Relations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这些海岸扇形就像是捐赠虾，它们与等价关系的联系更为紧密。这里所发生事情的区别就在于这种结构。但是，如果你只是把这些东西看作关系，你最终会对由此产生的等价关系感兴趣，因为你对连接模式感兴趣。看看如果你把它们组合成关系，你并不总是会得到等价关系。你需要采取关系的传递闭包来将其返回到相关性。</font></font></p><p>So, these coast fans are kind of the donor shrimp, and they’re much
            more closely connected to equivalence relations. And the difference
            between what’s going on here is this structure. But, if you just
            consider these things as relations, you’ll ultimately be interested in
            the equivalence relation that results because you’re interested in the
            connectivity pattern. And see if you compose them as relations, you
            don’t get an equivalence relation always. You need to take the
            transitive closure of the relation to return it to a correlation.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像你一次将一个关系与另一个关系连接起来一样。为什么，是的，是的，是的。你必须做一些追逐事情的事情。所以，让我们把讨论放在八度音阶中，但总结这些信息的一种方式是从关系类别到海岸粉丝类别的函数，或者一路绕着走。但没有正面或想象任何一个方向。只是很快，我还没有告诉你是否想要获得最大值，但你可能在某种程度上猜测如何。</font></font></p><p>Be like you join one relation with another one time. Why, yeah, yeah,
            yeah. You have to do some sort of chasing around things. So, let’s put
            in your discussion octave, but sort of a way of summarizing that
            information is that the sort of a function from the category of
            relations to the category of coast fans, or the all the way around. But
            there’s no front or imagine either direction. Just quickly, I haven’t
            told if you wanted maximum to get is yet, but you might be how to guess
            to some extent.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，它就像是一副拐杖，因为你知道，没有类别，节点类别有这种额外的数据。所以，我需要函子中的这种额外数据来关联新的神经结构。等等，然后是函数，另一个态射。我，嗯，我表示它处理这里的单位和这里的单位之间的关系。所以，具体来说，我有 D。我们还有 C，Sophie 是 D 中的一个态射，它将这两个东西关联起来。</font></font></p><p>So, it’s a little pair of crutches because you know, no categories,
            nodal categories has this sort of extra data floating around. So, I need
            this extra bit of data in the functor to relate the new neural
            structures. So, blah, and then functions, another morphism. I well, I
            represent which takes care of the relationship between the unit here and
            the unit here. So, in particular, how I have D. We also have C, and
            Sophie is a morphism in D that relates these two things.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后，无论你有什么 X、Y，我们还有一些将 X、Y 的图像与节点部分和 C 中的个体联系起来的东西。谢谢。好吧，这就是连贯性。所以，有些东西就像敏感性和亲密性，这些东西需要知道。这可能是我后悔的正确之处。对不起。所以，再说一次，这是超图类别的完整定义。</font></font></p><p>And then, whatever you have X, Y, we also have some things that
            relates the image of X, Y to the individuals in the nodal part and C.
            Thanks. Alright, that’s coherence. So, there are some things that just
            like sensitivity and an intimacy that these things need to know. That
            probably what I regret the proper. I’m sorry. So, again, that’s sort of
            a full definition of hypergraph category.</p>
        <h2 id="hypergraph-categories-and-functors"><font style="vertical-align:inherit"><font style="vertical-align:inherit">超图类别和函子</font></font></h2><h2>Hypergraph Categories and
            Functors</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">将允许对象承受它。但是因为这里的对象非常简单，所以它可以变得精确。那么，具体来说，这对于某种正常或秒数如何工作？那么，口号就像我的超图类别的秒数。所以应该有一个函子。我们如何看待它？它将一些 x 映射集放入秒数集中。例如，如果我们取一些四个元素的集合，这将匹配所有事物、东西、所有电路的集合。这些是具有边界或第二开路的独立组件。</font></font></p><p>Will allow objects to to bear it. But because objects here are quite
            simple, it’s like that can be made precise. So, in particular, how would
            this work for some sort of normal or seconds? So, the slogan then is
            something like seconds for my hypergraph category. And so there should
            be a functor. How do we think of this? It takes some set of x maps into
            the set of seconds. For example, if we took some set of four elements,
            this matches the set of all things, stuff, all circuits. These are these
            are separate components with boundary, or second open circuits.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是马戏团；他们有一些边界的概念。边界是元素样式，好吗？所以，这就是这个函数，马戏团，并不重要。为什么我要把这个结构组织成函子？原因是这些态射——我假设有一个 5 x x 的诅咒跨度——它将映射到 x 函数上的电路中的某种东西。所以，这里的态射是克里斯·范·达姆的终极函数。所以，让我们从集合一秒开始，一些 y 开始。</font></font></p><p>It’s a circus; they have some notion of boundary. In the boundary is
            for element style, okay? So, that’s what this function, circus, doesn’t
            matter. Why am I organizing this structure as a functor? The reason is
            because these morphisms—so I’m assuming there’s a curse span of 5 x
            x—it’s going to map to their some sort of thing from the circuits on x
            function. So, a morphism in here is a Chris van Damme ultimate here as a
            function. So, crisp and let’s go function from set one extra second,
            some y.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果我选择某种诅咒带，比如这样，那么这将变成一个函数，比如说，将电路带到第二个，一个带有电阻、灯泡和电池的六角形，然后映射到这里。它嵌入在那里，我们将其推出，所以它最终将这些连接起来。所以，这只是这个诅咒带的一个动作的一个例子，作为一个函数，它从分离状态持续两秒钟。</font></font></p><p>And so, if I pick some sort of curse band, say like this, then this
            turns into the function that, say, takes that circuit down here into the
            second, a hex with a resistor and a light bulb and a battery, and then
            maps up to this. It’s embedding inside there, which we push out, so it
            ends up connecting these. So, this is just this is just an example of
            one action of this curse band as a function from separates on for two
            seconds.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但从总体上看，这个类别形成了某种构图理论，遵循某种图解——图解，只是某种一般的语法概念。它告诉我们如何将事物结合在一起来创造新术语。然后，好吧，那么对象——让我更精确一点。</font></font></p><p>Into the overall picture, though, is that this category here forms
            some sort of theory of composition, following some sort of
            diagrammatic—a diagrammatic, just some sort of general notion of
            grammar. It says how we can just stick things together to create new
            terms. And then, well, so the objects—let me be more precise.</p>
        <h2 id="functors-and-grammatical-constructions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">函子和语法结构</font></font></h2><h2>Functors and Grammatical
            Constructions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对象是原型。所以，这里我们有类型四，它映射。好的，这里我们有类型四，这里我们有一些斜率。像这里的这种态射是采用类型四的项并创建类型二的项的方法。这是一个指定语言的函子。它采用这个语法并实例化它，并向它发送某些信息，说：“好的，我们有这个类型四。这是我所有类型的事物，我的类型四的项。这是我的类型二的项。”然后它取一个，允许语法构造，并说：“这个抽象句法结构是否采用类型的项？实例化这个特定项是否会转发到这个特定活动，等等。”</font></font></p><p>The objects are archetypes. So, here we have the type four, and it
            maps. Okay, here we have the type four, and here we have some slope. And
            the morphisms like this one here are ways of taking terms of type four
            and creating a term of type two. And this is a functor that specifies
            the language. It takes this grammar and instantiates it and sends it
            certain says, “Okay, we have this type four. Here are all my things of
            type, my terms of type four. And here are my terms of type two.” And
            then it takes one, allows for grammatical constructions, and says, “Is
            this abstract syntactic structure takes a term of type? Is instantiated
            this particular term will take forward to this particular activity, and
            so on.”</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这让我想到了阿尔法杆。因此，歌剧可以被认为是一种作曲理论。</font></font></p><p>So, that gets me to the idea of an alpha rod. So, an operatic can be
            thought of as a theory for composition.</p>
        <h2 id="operads-and-theories-of-composition"><font style="vertical-align:inherit"><font style="vertical-align:inherit">歌剧和作曲理论</font></font></h2><h2>Operads and Theories of
            Composition</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">到目前为止，我们已经看到了很多这样的组合理论。这是一个范畴的概念，我们可以同时接受两个分支并将它们组合起来。让我再举一个同态。我们有一个关于组合理论的范畴，其中这些盒子可以有多个分支，它们可以在魏茨曼带中并行。然后我们看到了基于超图利润的题词范畴的概念，这只是一个组合理论，其中我们在事物之间有任意的接线。</font></font></p><p>So, so far, we’ve seen many such theories of composition. This,
            there’s a notion of category where we can take both chasms and compose.
            Let me get another morphism. We have, you know, your categories about us
            to have a theory of composition where these boxes could have more than
            one impose that could be in parallel in the Weizmann swath. And then we
            see this notion of a hypergraph profit based epigraph category, which is
            just a theory of composition where we have arbitrary wirings between
            things.</p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这些取消大学的理论</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">模型的整体结构是什么</font><font style="vertical-align:inherit">，而是一般范畴论？然后，一旦我们有了这个，我们就会对此感兴趣，因为这样我们就可以开始调整……我们不只是考虑不同类型的类别；我们会尝试将结构置于我们的类别之上。我们可以从头开始创建新的组合理论，这些理论在某种程度上与这些结构的连贯性相同。</font></font></p><p>So, what is the overall structure of <em>not</em> a model of these
            theories of removing university, but the general category theory? Then,
            once we have this, the reason we would be interested in that is because
            then we can start adjusting… We don’t just consider different sorts of
            categories; we’ll try and throw structure on top of our categories. We
            can sort of from scratch create new theories of composition that are
            somehow coherent with respect to the same way that these structures are
            coherent.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，一个特别是这个由操作数提供的，这是一个粗略的定义。我会哭，我会哭。是的，哦，它是一个集合。Iza，好的。但通常是一个操作数，也是非常固定的类型。然后对于长度为 n 的对象的每个元组和函数，每个元组 t1、t2、tn，然后是另一个对象 t，一个集合，我们将其称为操作或态射。操作。然后是类别的某种关系。我们有对象和态射，但这里是态射采用域，它们采用域列表，我是 a。</font></font></p><p>So, one especially this is provided by an operad here’s a rough
            definition. I’ll cry, I’ll cry. Yes, oh, it is a set. Iza, okay. But
            often an operad, very holding types too. And then for every tuple of
            objects of length n, and function, every tuple t1, t2, tn, and then
            another object t, a set, which we’re going to call operations or the
            morphisms. Operations. Then there’s some relationship of a category.
            We’ve had objects and morphisms, but here it’s with morphisms being
            taking a domain, a, they take a list of domains and I’m a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在我们需要一个组合规则。组合规则。我们给定一个这种类型的态射，我们可以将这个东西的输出插入到应用程序组件中，将其列为我的子项的类型。这将获得一个单一的复合态射，它从空间态射、这种类型的这种类型运行，并返回一个随时间变化的态射。嘲笑那个位置。最后，转到身份。因此，对于每个类型 t，我们都有特殊元素，即身份。</font></font></p><p>So now we want a composition rule. So, composition rules. We have
            some given a morphism of this type and this type, we can kind of plug
            the output of this thing into the app component, listing as the types of
            my child. And this gets a single composite morphism, which runs from
            space morphism, this type of this type, and returns a morphism over this
            time. Laughing that position. And then lastly, move on to identities.
            So, for every type t, we have special elements, identity.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，这个设置了一个，一个代表一个。所以，就像类别对象、态射、成分身份一样，但我们的组合有点缺失，国家态射并不重要。所以它们都必须有加号。所以我们需要一个心态。所以，这是概念运算符。你会看到这些形成了我们的类型的操作符。</font></font></p><p>Yeah, this set up with one in for that one. So, just like the
            category objects, morphisms, constituent identity, but our composition
            is sort of absent, national morphism is is not important. And so they
            must both have plus. So, we need a mentality. So, this is the notional
            operator. You kind of see that these form operads where our types.</p>
        <h2 id="hypergraph-categories-and-operads"><font style="vertical-align:inherit"><font style="vertical-align:inherit">超图类别和操作符</font></font></h2><h2>Hypergraph Categories and
            Operads</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这是从某种类型、这种类型和这种类型到这种类型的单一事物的映射。因此，这是一种三领域，即 t1、教学 t3、多样性。因此，您可以将这些不同的定义用作类别的操作数，并对类别、不可操作的超图类别等进行测量操作。拓扑中有这些操作数，形成像小 n 立方体操作数，就像这样，但没有电线。</font></font></p><p>So, this is a map from sort of this type, this type, and this type to
            a single thing of this type. And so this is a sort of three area, this
            t1, teaching t3, this diversity. So, you can play with some of these
            different definitions as an operand for categories and operate for
            measurement over categories, inoperable hypergraph categories, and so
            on. There are these operads in topology, forming like the little n cubes
            operad, which is like this, but without the wires.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后从每个对称的类别中，你也会得到一个操作数的概念。所以，具体来说，我在这里为超图类别绘制的这个图形只是对应于对称的、另一个类别的操作数，当然，有限集带。但是，还有一个对应于集合类别的操作数，因为那也是一个假定的对称不可听集合类别。如果你不仅对你的合成理论感兴趣，而且对一个实际的类别或一个实际的超图类别感兴趣，那么你可以做同样的构造，在那里你取一堆……</font></font></p><p>And then from every symmetric whatever category, you also get a
            notion of operad. So, in particular, this I’ll graph here for hypergraph
            categories is just the operad corresponding to the symmetric, another
            category of course, bands of finite sets. But then to, there’s also an
            operad corresponding then to the category of sets, because that’s also a
            supposed symmetric inaudible category of sets. And if you’re interested
            not just in your theory of composition, but in an actual category or an
            actual hypergraph category, then you do this same sort of construction,
            where you take a bunch of…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在是一个操作符，一个函子——嗯，语义可以存在的地方。所以，206。所以，通常只有两组。所以，你有一组特定类型的术语。然后是音调集之间的转换。所以，这是一个大概的画面，实际上总结了我们过去三周所做的作曲结构。</font></font></p><p>and now an operad, a functor—well, where the semantics can live. So,
            206. So, just usually two sets. So, you’ve got a set of terms of your
            particular types out there. So, and then these transformations between
            sets of tones. So, that’s sort of a general picture, and which really
            sort of concludes this march through compositional structures that we’ve
            done over the past three weeks.</p>
        <h2 id="conclusion-and-future-lectures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">结论和未来讲座</font></font></h2><h2>Conclusion and Future
            Lectures</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">虽然在下一讲中我们会更多地讨论范畴论中的逻辑结构，但我对此仍然非常感兴趣。</font></font></p><p>Although, in the next lecture, we’ll be more, next two lectures will
            be a bit more about logical structures in category theory, which I’m
            still very interested in.</p>
        <h1 id="applied-category-theory.-chapter-7-lecture-1-spivak"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 7 章，第 1 讲（Spivak）</font></font></h1><h1>Applied
            Category Theory. Chapter 7, lecture 1 (Spivak)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 2 月 1 日) — 50:49 </font></font><a href="https://youtube.com/watch?v=Qp6b-XbPog0"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=Qp6b-XbPog0</font></font></a></p><p> 6
            years ago (Feb 1, 2019) — 50:49 <a href="https://youtube.com/watch?v=Qp6b-XbPog0">https://youtube.com/watch?v=Qp6b-XbPog0</a></p>
        <h2 id="summary-12"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本 MIT 18S097 课程由 David 和 Brendan Fong (Spifong) 教授，讨论了超图类别中的行为类型。本章探讨了行为如何成为随时间变化的可能性集合，并受到元素之间关系的约束。介绍了“拓扑”的概念，即具有特定属性的类别，以及如何将拓扑中关于对象的陈述解释为关于事物随时间或空间变化的陈述。视频最后解释了子对象分类器（拓扑中的一个关键概念）如何允许对行为类型进行逻辑陈述。</font></font></p><p>This MIT 18S097 Course, taught by David and Brendan Fong (Spifong),
            discusses behavior types in a hypergraphic category. The chapter
            explores how behaviors are sets of possibilities over time, constrained
            by relationships between elements. The concept of a “topos” is
            introduced, a category with specific properties, and how statements
            about objects in a topos can be interpreted as statements about things
            changing over time or through space. The video concludes by explaining
            how a sub-object classifier, a key concept in toposes, allows for
            logical statements about behavior types.</p>
        <h2 id="introduction-to-behavior-types"><font style="vertical-align:inherit"><font style="vertical-align:inherit">行为类型简介</font></font></h2><h2>Introduction to Behavior
            Types</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">今天我们讲的是最后一章，讨论的是行为类型和行为。这里有一些形态射的图片——超图类别中的图表网络。Brendan 上次谈到过，其中的线代表各种类型，这里的框是类型之间的形态射。因此，我们有一个传感器或控制器和一个电机，它们相互发送信息。我们在传感器内部，打开它，我们会看到实际上有两个传感器和一个处理器，它们都以某种方式运行。但问题是：行为是什么样的？</font></font></p><p>So, today we’re on the last chapter and talking about behavior types
            and behaviors. Here are some pictures of morphisms—a network of diagrams
            in a hypergraphic category. Brendan talked about last time, where the
            wires are, say, our various types, and the boxes here are kind of
            morphisms that go between types. And so, we have, say, a sensor or a
            controller and a motor, sending each other information. We have inside
            of the sensor, we open it up, and we see there’s actually two sensors
            and a processor, and they’re all behaving in some way. But the question
            is: what is behavior like?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，也许我会让你想一分钟。当你说这些事情必须有行为，并且它们有某些行为时，你在说什么？也许你自己想一分钟，或者你现在在做什么？你在表现。你也应该是其中之一。</font></font></p><p>So, maybe I’ll let you just think about it for a minute. When you say
            that these things are having to be doing behavior and they have certain
            behaviors, what is it that you’re talking about? Just maybe think about
            that for a minute, by yourself, or what are you doing right now? You’re
            behaving. You should also be one of these.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，有什么想法吗？您对行为有什么看法？那是什么样的事情？</font></font></p><p>So, any ideas? What can you say about behavior? What kind of thing is
            that?</p>
        <h2 id="temporal-aspects-of-behavior"><font style="vertical-align:inherit"><font style="vertical-align:inherit">行为的时间方面</font></font></h2><h2>Temporal Aspects of Behavior</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，好的。随着时间的推移，瞬时变化。那可能是——闲聊时间。我在那里看不到更好的女孩。所以，可能就这样了。</font></font></p><p>Yeah, okay. Instantaneous changes over time. And that might be—jabber
            time. I don’t see a girl better there. So, probably leave that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">传感器的输出可能基于一毫秒前到达传感器的信息。控制器可能会考虑十分钟前发生的事情。谁知道呢？或者处理器可能会考虑一些事情。当你观察我的行为时，你可以知道我——至少从外部——无论是内部还是外部发生的事情，你都可以看出五分钟前发生的事情仍然影响着我现在所说的话。</font></font></p><p>The output of the sensor may be based on things that came to the
            sensor a millisecond before. The controller might be taking into account
            things that happened ten minutes before. Who knows what? Or the
            processor might be taking things into account. When you look at my
            behavior, you can tell that I’m—at least from the outside—whether it’s
            whatever’s happening internally, outside, you can tell that things
            happened five minutes ago are still affecting what I’m saying now.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你看看我可以做的各种事情......所以，我想说的是，行为类型或行为是一组你可以——你需要的可能性。</font></font></p><p>So, if you look at the kinds of possible things I could do… So, what
            I want to say a behavior type is, or a behavior is, is that it’s a set
            of possibilities that you can—you need.</p>
        <h2 id="formal-definition-of-behavior-types"><font style="vertical-align:inherit"><font style="vertical-align:inherit">行为类型的正式定义</font></font></h2><h2>Formal Definition of
            Behavior Types</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，自行车行为的可能性有哪些呢？好吧，你可以说它有车轮速度、踏板速度、齿轮比等各种速度——我想，就像多米诺骨牌速度。你知道踏板速度乘以齿轮比小于或等于后轮速度。当你这样做时，如果你说我知道这是真的，那么你就限制了这种行为类型的可能性，说自行车就是这种狂热的东西。</font></font></p><p>So, what are the possibilities for a bicycle behavior? Well, you
            could say it has a wheel speed, it has a pedal speed, it has its
            various—domino speeds, I guess, in gear ratios. And you know that the
            pedal speed times a ratio is less than or equal to the back wheel speed.
            And when you do that, if you say I know that’s true, then you’re
            restricting the possibilities of that behavior type to say a bicycle is
            the kind of thing with this sort of mania.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当我给一个具有特定行为的类时，我就是其中之一。我不会只做我能做的任何可能的事情；我会做其中的一些。这就是我所说的行为类型——我能做的所有事情。当我做——我想是大卫——行为就是其中之一。处理器管理导出端口和所有端口（电机和传感器）上的事件之间的关系。我正在管理所有这些东西之间的关系。</font></font></p><p>And I am a sort of thing when I’m giving a class that has a certain
            kind of behavior. I don’t just do any of the possible things I can do; I
            do some of them. And so, that’s what I mean by behavior type—all the
            things I’m capable of doing. When I’m doing—David, I guess—and a
            behavior is one of those. The processor manages the relationship between
            events on the export ports and all ports (motor and sensor). And I’m
            managing a relationship between all that stuff.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我可以对我体内的任何东西进行这种操作。里面可能有一个反馈回路，因为我可以打开这个东西，看到各种疯狂的东西。是的，这是一组随时间变化的可能性。如果你说你想切断它的所有端口，比如那些满足某种关系的端口，那么这就是约束。所以，在自行车的所有车轮/车轮、踏板速度中，只有某些速度可以满足自行车完好无损的要求。</font></font></p><p>And I’m allowed to do it with anything inside of me that is there.
            There could be a feedback loop inside, ’cause I can open this thing up
            and see all sorts of crazy stuff. Yes, it’s a set of possibilities
            changing in time. And if you say that you want to cut out from all of
            its ports, say those that satisfy a certain relationship, then that
            would be the constraint. So, out of all the wheel/wheel, pedal speeds of
            a bicycle, only certain ones satisfy that the bicycle is intact.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，这就是我们所说的行为类型——一系列由时间间隔参数化的可能性。因为如果你把我能做的所有事情都考虑进去，那不是一微秒的事，而是时间间隔的事。所以，这就是我想要看待行为类型的方式。当我这么说的时候，我的看法是，有一种特定的脚趾姿势，每当我谈论它时，它都会被称为行为类型。</font></font></p><p>Okay, so that’s what we mean by behavior types—a bunch of
            possibilities parameterized by intervals of time. Because if you take
            all the things I’m capable of doing, it’s not in a microsecond; it’s
            over intervals of time. So, that’s the way I want to look at behavior
            types. And the way I’m looking at it when I say that is that there’s a
            certain toe pose where whenever I talk about it, tight, it’ll be called
            a behavior type.</p>
        <h2 id="toe-pose-as-a-category"><font style="vertical-align:inherit"><font style="vertical-align:inherit">脚趾姿势分类</font></font></h2><h2>Toe Pose as a Category</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因为我称其为“脚趾姿势”行为类型。因此，每当我谈论这种脚趾姿势的类型时，这种脚趾姿势的类型将是行为类型，而不是自然数或布尔值之类的类型。因此，此类别中的任何对象（脚趾姿势是一种类别）以及此类别中的任何对象都将是一种行为类型。并且此类别中存在的任何形态都将是一种将行为类型（如 A）转化为行为类型的方法。所以，这就是这门课的内容。这些是脚趾姿势关系的图片。您可以在任何脚趾姿势中形成关系，它们形成超图类别，这使得这些图表合法。因为 Brendan 上次谈到了关系或超图类别。但这些是在谈论行为类型及其之间的关系。好的。</font></font></p><p>Because I call it the behavior type “toe pose.” And so, whenever I
            talk about a type in this toe pose, instead of a type like the natural
            numbers or the booleans, the types in this toe pose will be behavior
            types. So, any object in this category—the toe pose is a kind of
            category—and any object in this category will be a type of behavior. And
            any morphism present in this category will be a way of taking types of
            behavior, like A, and turning them into types of behavior. So, that’s
            what this class is about. These are pictures of relations in toe pose.
            And you can form relations in any toe pose, and they form a hypergraph
            category, which makes these diagrams legitimate. Because Brendan talked
            about relations or hypergraph categories last time. But these are
            talking about behavior types and relationships between them. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们的想法是，我们要思考 - 我的意思是，如果我们想进入那个脚趾姿势，我可以创建一个脚趾姿势，你也可以。</font></font></p><p>So, the idea is we’re going to be thinking—I mean, if we want to go
            into that toe pose, I could create a toe pose, and you could too.</p>
        <h2 id="interpreting-mathematical-statements-in-toe-pose"><font style="vertical-align:inherit"><font style="vertical-align:inherit">解释足尖姿势中的数学陈述</font></font></h2><h2>Interpreting
            Mathematical Statements in Toe Pose</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">只要知道如何做，任何人都可以创建一个脚趾姿势。一旦你这样做了，你所做的任何陈述，任何数学陈述，你都可以用脚趾姿势来解释，而且它的含义相对明显。所以，假设我说我有一个组。然后，如果我用时间脚趾姿势来解释它，那将是一个随时间变化的组。如果我说我有一个环，那它就是一个随时间变化的环。</font></font></p><p>And anyone who wants to can create a toe pose if they know how. And
            once you do it, it makes it so that any statement you make, any
            mathematical statement you make, you can interpret it in a toe pose, and
            it will mean something relatively obvious. So, let’s say I say I have a
            group. Then, if I interpret it in the temporal toe pose, that would be a
            group changing in time. If I say I have a ring, it’s a ring changing in
            time.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我可以说它没有变化。我可以在没有环的情况下做出断言，说这个环始终是 R。或者我可以说这是一个可以随时间变化的环，就像发动机（那种响亮的发动机）可以随时间改变其行为一样。这是一种保持不变但会随时间变化的行为。所以，拓扑斯是一个数学世界。有一个可以解释数学语句的世界。比如，我有一个群。</font></font></p><p>I could say it’s not changing. I could make an assertion without my
            ring that says this ring is always R. Or I could say this is a ring that
            is allowed to change over time, in the same way a motor—the kind that’s
            loud—can change its behavior over time. It’s a type of behavior that
            remains the same but it changes through time. So, a topos is a
            mathematical world. There’s a world where mathematical statements can be
            interpreted. Like, I have a group.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我有一个群，如果我有一个拓扑空间的拓扑，那么这个群会随着空间而变化。它被允许随着空间而变化。所以，它们保留了大多数最常见的拓扑，即集合的元组，这就是我们今天要讨论的内容。</font></font></p><p>If I have a group, if I have a topos for a topological space, that
            group changes through the space. It is allowed to change through the
            space. So, they keep most, you’d most common toposes, the tuples of
            sets, and that’s what we’re talking about today.</p>
        <h2 id="motivation-and-project-background"><font style="vertical-align:inherit"><font style="vertical-align:inherit">动机和项目背景</font></font></h2><h2>Motivation and Project
            Background</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们今天讨论的所有这些高层次的东西，我的意思是，我开始的动机是在几年前我与 NASA 和霍尼韦尔合作的一个项目中产生的，我们在那里写下了直到平方，我在这里说的东西才有意义。所以，某种时间概念，非常像标准时间概念，不是相对论的，只是你钟表上的那种，我们讨论了这一切是如何工作的。但今天，我要讲，明天布伦丹将谈论一般的拓扑以及你可以在其中做的事情。</font></font></p><p>So, all this high level stuff we’re talking about today, I mean, that
            I started with kind of the motivation was worked out in a project I did
            with NASA and Honeywell a few years ago, where we kind of wrote out
            until for square the kinds of things I was saying here makes sense. So,
            a certain notion of time, very like standard notion of time, not
            relativistic, just kind of what you clocks where we discussed how this
            would all work. But today, I’m going to talk, and tomorrow Brendan will
            talk about kind of general toposes and the kinds of things you can do in
            them.</p>
        <h2 id="general-toe-poses-and-logical-statements"><font style="vertical-align:inherit"><font style="vertical-align:inherit">一般脚趾姿势和逻辑陈述</font></font></h2><h2>General Toe Poses and
            Logical Statements</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何在拓扑中做出逻辑陈述，并且它们会展开成关于事物随时间变化或随空间变化等的陈述。</font></font></p><p>How you can make logical statements in toposes, and they get kind of
            unfolded into statements about things changing in time or changing
            through space or whatever.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你已经听说过最常见的拓扑斯是子集拓扑斯。因此，集合类别中存在的许多结构（我们今天将要讨论的）在任何拓扑斯中都是正确的。如果有一个拓扑斯，如果有一个时间拓扑斯和一个空间拓扑斯，那么这个拓扑斯是做什么用的？这就是拓扑斯。它是做什么用的？原来它是与单个点相对应的拓扑斯。</font></font></p><p>The most common topos that you’ve already heard of is the topos of
            subsets. And so, all of a lot of the structures that hold in the
            category of sets, which is what we’ll talk about today, is true in any
            topos. And if if a topos, if there’s a topos for time and a topos for
            space and stuff, what is this one for? This is the topos. What’s it for?
            It turns out it’s the topos corresponding to a single point.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果你有一个大的拓扑空间，比如一个球体，里面包含了地球表面可能发生的所有事情，或者一个大的拓扑空间，比如时间，某种时间间隔，里面包含了随时间变化的所有事情，这些就是在空间和时间的某一点发生的事情。这样，逻辑上就反映出来了，当人们说出像命题</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">这样的陈述时，比如“四是偶数”，这在所有时间都是正确的。</font></font></p><p>So, if you have, instead of a big topological space, like a sphere,
            like all the things that can happen on the surface of the Earth, or a
            big topological space like time, some kind of intervals of time, all the
            things that can change through time, this is the stuff that happens at
            one point in space and time. And that way, that’s reflected in the logic
            is that when people say statements like a proposition <em>p</em>, like
            “four is even,” that’s true for all time.</p>
        <h2 id="truth-values-in-toe-poses"><font style="vertical-align:inherit"><font style="vertical-align:inherit">脚趾姿势的真值</font></font></h2><h2>Truth Values in Toe Poses</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它不是时间完整的事物，也不是空间完整的事物。你不必检查星期三的四是否为偶数，也不必检查非洲的四是否为偶数。四就是偶数，而天正在下雨。例如，在逻辑教科书中，他们喜欢说，“哦，我们可以将</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">作为任何谓词来询问，例如，‘天正在下雨吗？’”但这并不好，因为 p 既不是真也不是假。例如，在集合论中，对于任何命题，我们都有 p 或非 p 的陈述。</font></font></p><p>It’s not a time full thing, and it’s not a space full thing. You
            don’t check whether four is even now on Wednesday, or four is even in
            Africa. Four is just even, whereas it’s raining. Like, in logic
            textbooks, they like to say, “Oh, we can ask <em>p</em> as any
            predicate, like, ‘is it raining?’” But that’s not that’s not good,
            because that’s not true either true or false. In set theory, for
            example, we have the statement p or not p for any proposition.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">人可能会咬人，你可以假设我们不是人。这就是说，某件事要么永远正确，要么永远不正确，要么是偶数，要么不是。然而，星期三在地球上和那里的空中下雨是真的，星期四不是。这就是我们谈论集合论的时候，我们总是在谈论集合论。我们谈论的是永远正确的事情。关键是，我们在时间拓扑中讨论的任何事物都可以随着时间的推移而改变。而你——真值不仅仅是真或假，而是什么时候是真的？或者在哪里是真的？</font></font></p><p>People might bite people, and you could assume that we are not
            people. That’s saying that something’s either always true or never true,
            or is either even or it’s not. Whereas, it’s raining is true here on
            Earth and there on the air on Wednesday and not Thursday. And so
            that’s—that’s when we talk about set theory, which is what we always do.
            We’re talking about things that are always true. The point is that
            anything we’ll talk about in the temporal topos can kind of change
            through time. And you—a truth value is not just true or false, but when
            is it true? Or where is it true?</p>
        <h2 id="topos-and-truth-values"><font style="vertical-align:inherit"><font style="vertical-align:inherit">主题和真值</font></font></h2><h2>Topos and Truth Values</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在底特律和非洲，在这儿和那儿，在那个时间在那个地方。这些就是所谓的真值。每个拓扑都有真值的概念。它们比子集拓扑更具表现力。它们就像，它在哪里是真的？它是什么？</font></font></p><p>In Detroit and Africa and here and there and this time in that place.
            So those are what are called truth values. And every topos has the
            notion of truth value. And they’re much more expressive than they are in
            the topos of subsets. They’re like, where is it true? What is it
            true?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对此有什么问题吗？这是一种高层次的想法。这就是整个拓扑斯系列——我的意思是，这是一种思维方式，它让我——它让我感到快乐。对我来说，它就像是数学的瑰宝。是的。所以我希望你喜欢，我希望你仔细研究它，思考它。</font></font></p><p>Any questions about that? It’s kind of a high level idea. That’s the
            topos series of like the whole—I mean, it’s a—it’s a way of thinking
            that’s kind of—I don’t know—makes me—it makes me happy. It’s like a
            very—it’s like a jewel of mathematics to me. Yeah. So I hope you
            enjoyed, and I hope you look into it, think about it.</p>
        <h2 id="topos-of-subsets-and-generalizations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">子集和概括的拓扑</font></font></h2><h2>Topos of Subsets and
            Generalizations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">今天，我们将讨论子集的拓扑，以及符号点的最高点。很多东西都很简单，但它们具有普遍性。所以我今天要说的一切都可以推广到任意拓扑。这是不能推广到任意拓扑的一件事。这是一个额外的公理，你可以在 Coq 等证明助手中添加它，并说“我断言对于所有 p，要么是 p，要么不是 p。”你确实限制了你正在研究的内容的表达能力，但它为你提供了大量证明。</font></font></p><p>So today, we’ll talk about the topos of subsets, and which is the
            topmost of a symbol point. So a lot of things are very simple, but but
            they generalize. So everything I’ll say today generalizes to an
            arbitrary topos. This is one thing that doesn’t generalize to an
            arbitrary topos. This is an extra axiom you can add in a proof assistant
            like Coq and say, “I assert that for all p, either p or not p.” And
            you’ve really limited the expressivity of what you’re working on, but it
            gives you a lot of proof.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。所以，微型船——你拥有的东西可以对所有真值进行分类。如果你习惯于用证明助手来思考，那么这个东西可以称为 Prop，如果你来自纯数学，它可以被称为 Ω。这就是拓扑斯理论家或拓扑斯系列，但你可能默认称之为大多数。拓扑斯不仅仅是 Prop；它是 Prop 是其中一部分的世界。</font></font></p><p>Yeah. So, miniature boats—you have on something that classifies all
            your truth values. That thing could be called Prop if you’re used to
            thinking in terms of proof assistants, or it could be called Ω if you’re
            coming from pure math. That’s just what topos theorists or topos series,
            but you might call it most by default. The topos is not just Prop; it’s
            the world where Prop is one part.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们会讨论这个问题。好的。如果你想让我说的每件事都发生两次，你可以把我说的关于拓扑斯的每件事都用图的类别替换。你之前见过的图。它是从这个类别到 Set 的函子。或者你可以修复这里的任何类别——任何类型的数据库模式——并查看从那个东西到 Set 的所有函子，你就会得到一个拓扑斯。我谈到的所有内容，你可以问：图的极限和余极限是什么？</font></font></p><p>So we’ll talk about that. Okay. So if you want to like have
            everything I say happen twice, you could take everything I say about
            topos and replace it with the category of graphs. Graph you’ve seen
            before. It’s a functor from this category to Set. Or you can fix any
            category here—any kind of database schema—and look at all the functors
            from that thing to Set, and you’re going to get a topos. And everything
            I talked about, you could ask: what are the limits and colimits of
            graphs?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">或者，基于实例，Stata 中数据库的极限和余极限是什么？或者，图类别中的子对象分类器是什么？或者，这对特定模式的数据库实例类别中的分类器有何启示？因此，如果您发现我所说的关于集合的一切都很无聊并且已经知道了所有内容，那么只需上一级并选择一个任意拓扑即可。例如，他们拿了很多图并在那里思考，拓扑中的指数对象之一是什么？</font></font></p><p>Or, what are the limits and colimits of a database in Stata based on
            instances? Or, what is the subobject classifier in the category of
            graphs? Or, what does this say about your classifier in the category of
            database instances for a certain schema? So, if you find everything I’m
            saying about sets boring and already know it all, then just go up a
            level and pick an arbitrary topos. Like, they took lots of graphs and
            think there, what is the one of the exponential objects in the
            topos?</p>
        <h2 id="properties-of-arbitrary-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">任意拓扑的性质</font></font></h2><h2>Properties of Arbitrary
            Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">正轨道。所以，我要讨论的是任意拓扑的一些属性或属性和结构，除了集合。所以，我不知道该怎么说，但我会假装我在说集合。但如果你已经知道一些，那就得有总线，或者你想在我说“集合”这个词的时候就想想“拓扑中的对象”，好吗？</font></font></p><p>The positive tracks. So, what I’m going to talk about is some
            properties or properties and structures of arbitrary toposes, except
            only sets. So, I don’t know how to say that right, but I’ll pretend I’m
            saying sets. But if you already know some, gotta have buses, or you want
            to just take any time I say the word “set” and think “object in the
            topos,” okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，对于任何拓扑学来说什么都是真的呢？那么，极限和余极限。</font></font></p><p>So, what are true in any topos? So, limits and colimits.</p>
        <h2 id="limits-and-colimits-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的极限和余极限</font></font></h2><h2>Limits and Colimits in Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有极限和余极限。例如，你有一个终端对象，一个从其他所有事物接收映射的对象。抱歉，拓扑斯是一个类别。一个伟大的类别有对象和态射。它是一个具有某些属性的类别。</font></font></p><p>All limits and colimits. So, for example, you have a terminal object,
            an object that receives a map from everything else. Sorry, a topos is a
            category. And a great category has objects and morphisms. It’s a
            category with, with some properties.</p>
        <h2 id="properties-of-topos-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 的性质（续）</font></font></h2><h2>Properties of Topos
            (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以用各种方式定义拓扑图，但这里有它的一些属性。所以，它有所有极限，并且：它有一个终端对象，这意味着拓扑图中有一些对象，每个人都有一张图。它有乘积。所以，对于任何两个对象，都有一个乘积。或者任何有限或无限数量的对象，都有一个所有对象的乘积。它有回拉。这是什么意思？我在拓扑图中的三个对象中有两个对象。</font></font></p><p>And you can define toposes in various ways, but here are some
            properties of it. So, it has all limits and: it has a terminal object,
            which means there’s some object in that topos everyone has a map to. It
            has products. So, for any two objects, there’s a product. Or any finite
            or infinite number of objects, there is a product of all of them. It has
            pullbacks. What does that mean? I have two objects in the three objects
            in the topos.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于所有这样的图，都存在一个图，它是拉回的。无论如何，我们上次谈到过，每个图都有一个拉回。有一个初始对象。因此，拓扑是具有许多良好属性的类别。给出一个初始对象。如果是产品，它们就没有产品，是的。推出。因此，它们具有所有这些结构。并非每个类别都有。例如，流形类别没有所有的拉回或所有的推出。是的，那是因为我们在代码中拥有所有限制。</font></font></p><p>For all diagrams like this, there exists a diagram that is a
            pullback. Anyway, we talked about last time, every diagram has a
            pullback. There’s an initial object. So, toposes are categories with
            lots of nice properties. Give an initial object. If products, they have
            no products, yeah. Pushouts. So, they have all this structure in them.
            Not every category has that. For example, the category of manifolds
            doesn’t have all pullbacks or all pushouts. Yeah, that’s because we have
            all limits in code.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，就是这些。作为任何图表形状的图表，都有其限制。</font></font></p><p>Yes, these are the ones. As a diagram for any diagram shape, there is
            a limit.</p>
        <h2 id="image-factorizations-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的图像分解</font></font></h2><h2>Image Factorizations in
            Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里有一些，是的。好的，好的。它有图像分解。它们也被称为 epi mono 分解。所以，如果你考虑集合，你可以形成所有的极限和余极限。Brendan 上次告诉过我们。你可以从 a 到 b 取任何态射，任何函数，然后找到一个射影和一个注入来分解那个东西。你可以取映射的图像并对其进行分解。将映射分解为图像，就好像它被称为图像分解一样。射影后跟一个注入。</font></font></p><p>And here are some, yeah. Okay, okay. It has image factorization.
            They’re all also called epi mono factorizations. So, if you think about
            sets, you can form all limits and colimits. Brendan told us last time.
            And you can take any morphism from a to b, any function, and find them a
            surjection and an injection that factor that thing. You can take the
            image of the map and factor it. Factor your map as if it’s called image
            factorization. Surjection followed by an injection.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">任何拓扑结构都是如此。所以，每个态射都有图像分解。拓扑结构中的单射和复射，一个任意的范畴。当然，有很多不同的方法。我不知道是否要拯救最快的玩家。所以，我来谈谈我。蜜蜂是一种单射或——它被称为单态射。我认为“mono”的意思是“一”，就像一对一。我认为这就是他们得到“mono”这个词的地方——单态射。对于所有其他对象 x 和映射到 a 的对，比如 1/2，如果 I 1 l 等于眼对眼和单射，用态射表示。Fu 的意思是 2 是另一边的东西。所以，如果你能想象两个不同的映射到这里，这是一个首一单态射，并且认为这两个映射是相同的，那么它们就是相同的。好的，好的。</font></font></p><p>And that’s true in any topos. So, every morphism has image
            factorization. Surjections and injections in a topos, an arbitrary
            category. Sure, there are lots of different ways. I don’t know whether
            to save the fastest player. So, I’m at me. The bee dee is an injection
            or a—it’s called a monomorphism. I think “mono” means one, and that’s
            like one to one. I think that’s where they get the word “mono”—a
            monomorphism. For all other objects x and pairs of maps into a, like
            1/2, if I 1 l equals eye to eye and surjection, represented by a
            morphism. Fu meaning on 2 is is kind of things on the other side. So, if
            you can imagine two different maps into here, and this was a monic
            monomorphism, and this thought that those two maps were the same, then
            they are the same. Okay, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第三件事是它有内部 hom。</font></font></p><p>So, a third thing is that it has internal homs.</p>
        <h2 id="internal-homs-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">托波斯 (Topos) 的内部 Homs</font></font></h2><h2>Internal Homs in Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">用一种花哨的方式来说，值得了解这种花哨的方式，因为这就是你在互联网上搜索它的方式：笛卡尔闭类别。所以，标记我们的可可是笛卡尔闭的。每个拓扑都是分区闭的，你说它有内部 homs。这意味着如果你有两个对象和从 a 到 b 的映射——如果我有两个阿贝尔群——从一个到另一个的态射集合形成一个阿贝尔群。所以，它有内部 homs。我可以从你们其中一个群取任意两个态射到另一个群并将它们相加。有一个零态射。阿贝尔群不形成拓扑，但它们有一个带内部 homs 的类别。每个拓扑都有内部 homs。所以，在集合中，有一组从 a 到 b 的态射。有一组从 a 到 b 的函数。</font></font></p><p>So, in a fancy way to say it, and it’s worth knowing the fancy way
            because that’s how you search for it on the internet: Cartesian closed
            category. So, mark our cocoa’s is Cartesian closed. Every topos is
            partition closed, and you say it has internal homs. And what that means
            is that if you have two objects and maps from a to b—if I have two
            abelian groups—the set of morphisms from one to the other form an
            abelian group. So, it has internal homs. I can take any two morphisms
            from one of you a group to another and add them. There’s a zero
            morphism. Abelian groups do not form a topos, but they have a category
            with internal homs. Every topos has internal homs. So, in sets, there’s
            a set of morphisms from a to b. There’s a set of functions from a to
            b.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我们想写出一个好版本，我们会说对于所有——这就是内部 homs——一个集合。所以，对于我们 topos 中的所有 a，找到一个空白时间，比如说，将一个集合乘以一个集合，将自然数集乘以自然数集乘以 a。对吗？实际上，所以我们有一个集合，那个集合，我们有乘以 a，然后后面那个叫做空白的东西到 da，也就是……</font></font></p><p>And so, to write this, so you know, if we wanted to write the nice
            version of it, what we would say is for all—so this is what internal
            homs is—a set. So, for all a in our topos, the finds a blank time, say,
            taking a set to a set takes the set of naturals to the set of naturals
            times a. Has it right? Actually, so we have a set, that set, we have
            times a, and then the back which thing is called blank to da, which
            is…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，写出来，我想我已经准备好了。从 x 乘以 a 的映射集——该线同构于从 x 到 y 的函数集的映射集。这就是内部 homs 的意思。如果这个东西——它是简写——它有正确的基数。但原因是如果这个的基数是小 a，而这个的基数是小 y，那么这个的基数将是小 y 乘以小 a。</font></font></p><p>So, writing that out, I guess I’m ready here. The set of maps from x
            times a—the line is isomorphic to the set of maps from x to the set of
            functions from, like, y. That’s when internal homs means. If this thing
            is—it’s a shorthand for—it has the right cardinality. But the reason for
            it is if this has cardinality little a, and this has cardinality little
            y, this would have cardinality little y times little a.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，到目前为止我们有三个属性：笛卡尔闭集、每个首一分解极限和余极限。拓扑斯具有所有这些属性。所以，它就像集合一样。群没有这个属性。群不是笛卡尔闭集。阿贝尔群是一个类别。许多类别都是阿贝尔的。许多类别不是阿贝尔的。而两辆巴士是……所以最有趣的事情，也是 Brendan 认为书中最有趣的评论，是我们所说的来自外太空的超密集块，即子对象分类器。</font></font></p><p>Okay, so we have three properties so far: Cartesian closed, every
            monic factorization limits, and colimits. A topos has all those
            properties. So, it’s acting like sets. Groups don’t have this property.
            Groups are not Cartesian closed. Abelian groups are a category. Lots of
            categories are abelian. Lots of categories are not abelian. And two
            buses are… so the most interesting thing, and the thing that Brendan
            thought was the funniest remark in the book, is what we called a super
            dense nugget from outer space, which is the sub object classifier.</p>
        <h2 id="subobject-classifier-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的子对象分类器</font></font></h2><h2>Subobject Classifier in
            Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这个东西的威力惊人，但看起来却非常神秘。就好像我们从外太空收到了一个奇怪的卫星，科学家们花了几十年时间研究它。也许这就是那个东西。</font></font></p><p>So this thing is surprisingly powerful and yet very cryptic to look
            at. It’s like if we received this weird, like, satellite thing from
            outer space, and scientists were just studying it for decades. This is
            perhaps that thing.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，它是什么？它是 Atom 类别中的一个对象，或者……一个单态，或者一个 omega 的态射，我们称之为“真”。现在，在数学中，你不会轻易使用“真”这样的词，因为它就像你不是——你没有太多的名字空间。你不会重复不同的东西；它意味着被称为“真”的东西。所以，这就是——这是我们对这个东西最接近的名字。</font></font></p><p>So, what is it? It’s an object in the category Atom, or… and a
            monomorphism, or a morphism one to omega, that we’re going to call
            “true.” Now, you don’t use a word like “true” in mathematics very
            lightly, since it’s like you’re not—you don’t have very much name space.
            You’re not going to repeat different things; it means that thing that is
            called “true.” So, this is acting as—that’s our closest name for what
            this thing is.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是吗？那是……哦，该死。是的，我想那应该叫做单眼闭眼。这是个好观点。我得好好考虑一下。</font></font></p><p>Yeah? Is that… oh, shoot. Yeah, I guess that would be called a
            monoidal closed eye. It’s a good point. I’ll have to think about it.</p>
        <h2 id="subobject-classifier-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">子对象分类器（续）</font></font></h2><h2>Subobject Classifier
            (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，也许……对。那么，我们至少可以说 Topos Institute 不是笛卡尔封闭的，也许感觉群实际上是幺半封闭的。这听起来确实对。谢谢。好的。</font></font></p><p>So, perhaps… right. So, let’s just say at least Topos Institute is
            not Cartesian closed, and maybe feeling groups is actually monoidal
            closed. That does sound right. Thanks. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一个对象 omega 和一个同态 1 到 omega。这是一个旁注：在具有终端对象的任何类别中，从该终端对象到任何事物，到任何其他对象，都不是 — 它，存在单态。是所有 x 的注入，单态的拉回是首一的。所以，这是我可能应该在第一部分中提到的一件事。</font></font></p><p>So, this is an object omega and a morphism one to omega. And this is
            a side note: in any category with the terminal object, on that, from
            that terminal object to anything, to any other object, is not—it,
            there’s a monomorphism. Is an injection for all x, and the pullback of a
            monomorphism is monic. So, that’s one thing I probably should have said
            in Part One.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这意味着如果你有一个单态射 a 到 b，并且你还有另一个单态射——所以，如果这个是首一的，我用这个符号写下来，这是任何东西，那么我可以在这里对 b、c 进行任何次拉回。那么这将自动成为首一的。这在任何类别中都是正确的。</font></font></p><p>So, what that means is if you have a monomorphism a into b, and you
            have another morphism—so, if this one’s monic, and I write that with
            this symbol there, and this is anything, then I can take the pullback
            here any times over b, c.&nbsp;Then this will automatically be monic. That’s
            true in any category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以，我有一个从一到欧米伽的同态射，它属于类别——我的 Topos Institute 类别。它是一个类别。所以，我知道它是一个单态射。因此，对于任何 x 到欧米伽的映射的任何 pi，那么——如果我查看这里的子对象——抱歉，我不明白这个回调。对于所有 f，这个东西都是首一多项式。首一多项式不是吗？</font></font></p><p>Okay. So, I have a morphism from one to omega into categories—my
            categories of Topos Institute. It’s a category. So, I know it’s a
            monomorphism. And so, for any pi of any map x to omega, then—then if I
            look at the sub object here—sorry, I don’t get this pullback. For all f,
            this thing is a monic. Isn’t monic?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为了达到目的，我有一个态射。我有一个函数。任何从 x 到 omega 的映射，我通过拉回“真”来限制，我得到 x 的一个子对象。单态放大到 x 是 x 的一个子对象，或者更技术性地说，单态直到同构。那个点是我对 x 乘以 ω 的符号，但那个点只是拉回。好的，我的意思是，对于任何 x 到 ω，在这里我可以拉回 true 并得到 x 的一些子对象。</font></font></p><p>For purposes, so I have a morphism. I have a function from there. Any
            map from x to omega, I capped by pulling back “true,” I get a sub object
            of x. A monomorphic zoom into x is a sub object of x, or more
            technically, a monomorphism up to isomorphic. That dot is my notation
            for x times ω, but that dot is just the pullback. Okay, so what I’m
            saying is, for any x to ω, here I could pull back true and get some
            subobject of x.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">给定一个消色差ω，我得到一个 x 的子对象。如果有回调并且有终端对象，那么这在任何类别中都是正确的。你可以偷偷说出这句话。但是对于子对象分类器来说，其中什么是真的？不同之处在于——这是一个很好的小……所以我可以把它放得更好，这就是它能做一些对象分类器或子对象分类器、子对象类或……meron 的原因？是的。所以我还没有解开这个。所以，现在我要这么做。</font></font></p><p>Given an achromatic ω, I get a subobject of x. That’s true in any
            category if you have pullbacks and you have a terminal object. You can
            sneak the statement. But what’s true in it, for a sub object classifier?
            What’s different is that—is that this is a nice little… so I get to put
            it a nicer there, and that’s what makes it does some object classifier
            or a sub object classifier, or a sub object class, or… meron? Yeah. So,
            I haven’t unpacked this at all. So, now I’m going to do that.</p>
        <h2 id="subobject-classifier-in-sets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">集合中的子对象分类器</font></font></h2><h2>Subobject Classifier in Sets</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这到底在说什么呢？不知何故，在集合类别中，有一个对象——这个非常重要的对象——它有一个来自单元素集合的映射，名为“true”。有一个步骤，这个映射名为“true”。我们知道，如果我有任何其他东西映射这个步骤，我可以回溯并得到这个东西的某个子集，X 的某个子集。这个家伙说，对于任何子集，实际上，都有一个从 X 到 Ω 的映射。那么，这个特别的东西是什么？它似乎并不那么令人兴奋。你看到它是因为集合作为拓扑斯并不那么令人兴奋，但它是一个拓扑斯。所以，我们要得到一个。</font></font></p><p>Now, what is this talking about? Somehow, in the category of sets,
            there’s this object—this super important object—with a map called “true”
            from the one element sets. There’s a step with this map called “true.”
            And we know that if I have any other thing mapping of this step, I can
            pull back and get some subset of the thing, some subset of X. And this
            guy is saying that for any subset, in fact, there’s a map from X to Ω.
            So, what is that special thing? And it might not seem that exciting.
            What you see it because sets is not that exciting as a topos, but it is
            a topos. So, we’re going to get one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，有人知道答案吗？好的，答案是：如果子对象分类器用于集合，则它为真/假。这意味着，对于从 X 到 Ω 的任何映射，从 X 到 Ω 的映射称为谓词。这意味着这个谓词和子对象是相同的，或者是一个很好的总和，或者 X 上的谓词与 X 的子对象相同。</font></font></p><p>So, does anyone know the answer? Okay, the answer is: if the sub
            object classifier for sets, it is true/false. And what that means is,
            for any map from X to Ω, a map from X to Ω is called a predicate. And
            what this is saying is that this predicate and sub objects are the same,
            or are a nice sum, or predicate on X are the same as sub objects of
            X.</p>
        <h2 id="predicates-and-subobjects"><font style="vertical-align:inherit"><font style="vertical-align:inherit">谓词和子对象</font></font></h2><h2>Predicates and Subobjects</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">英语语法中的谓语是什么？如果是，则有一个主语句子，主语和谓语……鲍勃吃了糖果。好吗？因此，“吃了糖果”是从鲍勃的行为到子对象分类器的映射。对于任何鲍勃行为，您都会得到真/假。那么，给定……那么它的子对象是什么？它是鲍勃吃糖果的所有行为。</font></font></p><p>What’s a predicate in grammar, in English? If it’s you have a subject
            sentence and the subject and a predicate… Bob ate the candy. Okay? So,
            “ate the candy” is a map from Bob’s behavior to the sub object
            classifier. For any Bob behavior, you get true/false. So, given… so what
            sub object of that? It’s all the Bob behaviors where he eats the
            candy.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们再次尝试这样做。所以，这里我们说从 X 到真/假的映射——好吧，我可以查看子集，真，一个元素集，我坐在这里就像“真”。我可以进行回调。所以，如果我有一些从 X 到真/假的映射，我可以进行“真”的回调，那就是 X 和 X 的集合，使得 f(x) 作为布尔元素为真。这就是我们得到子对象的方式。这是一个回调。它说的是，对于上面的任何东西，Tibbet 都要去……好吧。好吧，他们一生的工作就是将这个东西同态化……对于 X 的任何子对象，所以 X 上有一个谓词可以将其切掉。</font></font></p><p>So, we’re trying to do that again. So, here we’re saying that a map
            from X to true/false—well, I can look at the subset, true, one element
            set, and I’m sitting here like “true.” And I can take the pullback. So,
            if I have some map from X to true/false, I can take the pullback of
            “true,” and that’s a set of X and X such that f(x) as an element of
            Boolean is true. And that’s how we get the sub object. That’s a
            pullback. And what it’s saying is that for any stuff up there, Tibbet’s
            to go… okay. Well, what this life’s work they did morphism this thing is
            it… for any sub object of X, so there’s a predicate on X that cuts it
            out.</p>
        <h2 id="examples-of-predicates"><font style="vertical-align:inherit"><font style="vertical-align:inherit">谓词示例</font></font></h2><h2>Examples of Predicates</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，现在让我们尝试一下。我让你们举例子。n 上的谓词是什么，使得……？（抱歉，我需要一些术语。）我们可以说，给定一个从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 Ω 的映射，我们可以看到它切出</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x的一个子对象并给它一个</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子对象
            </font><font style="vertical-align:inherit">。我们可以说它是由谓词分类的，并且它们是同构的。那么，自然数上的谓词是什么，它会切出某个子对象，即偶数？如果它切出小于 10 的数字，那么乘积是什么？
        </font></font></p><p>So, let’s give it a try now. I’ll let you guys work in example. What
            is the predicate on n such that …? (Sorry, I’m going to need some
            terminology.) We could say, given a map from <em>x</em> to Ω, we could
            see it cuts out a sub object of <em>x</em> and give it a sub object of
            <em>x</em>. We could say it’s classified by a predicate, and these are
            an isomorphism. So, what is the predicate on the natural numbers that
            cuts out a certain sub object, namely the evens? And what is the product
            if that cuts out the numbers less than 10?
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，让我们给你两分钟时间考虑一下我在这里问的是什么。你和那边的卷轴有关。我到底在问什么，这个问题的答案是什么？好吗？或者你需要一些帮助吗？你需要一些……我……是吗？</font></font></p><p>Okay, so let’s give you two minutes to think about what I’m even
            asking here. You have something to do with this scroll over there. What
            am I even asking, and what is the answer to that question? Okay? Or do
            you need some help? Do you need some… Am I… yes?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">并且任何类型都是自然数的集合。它是
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。所以……子对象分类器是一个特定的集合，即真/假。这样一个无定形的集合从 1 到 Ω，即选出真值。
        </font></font></p><p>And any of the type is the set of natural numbers. It’s an
            <em>x</em>. It’d be so… the sub object classifier is a certain set,
            namely true/false. Such an amorphous them from 1 to Ω, namely the one
            that picks out true.
        </p>
        <h2 id="subobject-classifier-in-topos-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的子对象分类器（续）</font></font></h2><h2>Subobject Classifier in
            Topos (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这样，对于任何集合</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x ，从</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 Ω的映射集与</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的子对象集（</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的幂集）是双射的</font><font style="vertical-align:inherit">。</font></font></p><p>Such a, for any set <em>x</em>, the set of maps from <em>x</em> to Ω
            is in bijection with the set of sub objects of <em>x</em>, the power set
            of <em>x</em>.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在您是自然数集，这是子集，这是子集。那么，什么谓词可以将它们排除在外？这就是问题所在。谓词是从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到真/假的函数。所以，这有点像谓词是“偶数”。如果这是一个英语语句，谓词可以说“小于 10”，那么从自然数到检索所有……是的，我不是说这很难。如果你看着它，就像“等等，这很难吗？”其实不是。只是你脑子里有定义吗？</font></font></p><p>And so now you’re the set of natural numbers, and here’s a subset,
            and here’s a subset. So, what predicate cuts them out? That’s the
            question. A predicate is a function from <em>x</em> to a true/false. So,
            it’s kind of like the predicate is “even.” If that’s an English
            statement that a predicate could say, “is less than 10,” is a map from
            naturals to retrieve all… yeah, I’m not saying this is hard. If you’re
            looking at this like, “Wait, is this hard?” It’s not that. Just a matter
            of do you have the definitions in mind?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，首先要明白我到底在问什么？我问的是：这是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">N的一个子集。所以，它位于</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的一个子集上</font><font style="vertical-align:inherit">，我应该以某种方式将其转换为从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 true/false 的映射。我所说的映射是指一个函数，当我回调 true 时，我会得到这个，与那个同构的东西。那么，这个问号是什么？它是一个函数。是“偶数”吗？那是什么意思呢？那么，它说了什么？它在哪里结束？当然是的。好的。</font></font></p><p>So, the first thing to understand is what am I even asking? And what
            I’m asking is: here’s a subset of <em>N</em>. So, it’s sitting there on
            a subset of <em>N</em>, and I’m supposed to turn that somehow into a map
            from <em>N</em> to true/false. And by map, I mean a function such that
            when I take the pullback of true, I get this, something isomorphic to
            that. So, what is this question mark? It’s a function. Is “even”? Well,
            what does that mean? So, what does it say? Where does it end? Sure, yes.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，它将其发送到 true。这是一个从 1 到这里函数。它始终为真。它始终为真。是的，它们对子对象的定义。我明白它不是那样，但是是的，它是这样的。所以，你将很多态射带入</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。但那是那些的类别。所以，我有一个单态射，还有另一个单态射。我可以将它们映射到它们之间，但我不想要两个类别。一组所有......这是关于它们的效果。所以，我总是采用态射类。</font></font></p><p>So, it sends it to true. It’s a function from 1 to here. It’s always
            true. It’s always true. Yeah, their definition for sub objects. I
            understand what it isn’t that, but yeah, it’s this. So, it’s you take a
            lot of morphisms into <em>x</em>. But that’s there’s a category of
            those. So, I have a monomorphism, have another monomorphism. I could
            have it mapped between them, but I don’t want two categories. One set of
            all… It’s about their effects. So, I take always morphism classes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这意味着该集合实际上与 n 的集合略有不同，使得函数 f(n) 为真。我的意思是，实际上，我想是另一个日记。它们是完全相同的集合，但我想我可以说，我想也许我会这样做。所以，它是 Z 中的 n 的集合，使得负 n 大于零且为偶数。我的意思是，用某种奇怪、愚蠢的方式来写同一个集合。它不是完全相同的集合，但这些是同构集。</font></font></p><p>So, this means the set is actually slightly different from the set of
            n such that the function f(n) is true. I mean, actually, another dairy,
            I guess. They’re exactly the same set, but I guess I could say, I think
            maybe I’ll do it this way. So, it’s the set of n in Z such that negative
            n is greater than zero and even. I mean, some weird, like, weird, stupid
            way of writing the same set. It’s not exactly the same set, but these
            are isomorphic sets.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你取任意一个数，并要求它是负数、正数和偶数，那么我可以把它展开，Gatien，然后进入这个通勤。所以，我——子对象是什么——它是一个单态，或者一个我们认为是正确的人的类。所以，对，我想这是外部的。所以，情况就是这样。这是从 x 到 ω 的映射集与 x 的子对象集通过射影相交，而子对象集恰好是集合内部的，但实际上不是集合内部的。一位贬低者告诉我们，他们不会写内部 otoko 来处理这个问题。这个东西是正确的东西，就像从 x 到 ω 的同态是通过射影相交的正确东西一样。这是我对集合之间的依赖。是的。不需要自然性。</font></font></p><p>If you take any number and ask it to be negative and positive and
            even, then I can send it to expand, Gatien, and go here in this commute.
            And so, I—what a sub object is—is it’s a monomorphism, or a class of one
            or more persons where we consider to be right. So, right, this is
            external, I guess. So, this is the case. This is the set of maps from x
            to ω is in by jection with the set of sub objects of x, which happens to
            be internal to set, but it’s not actually internal to their. A degrading
            told us they don’t write internal otoko’s to working with this. This
            thing is the right thing, like the homomorphism from x to ω is the right
            thing by jection. This is my addiction between sets. Yeah. No naturality
            required.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">他们的问题。如果某个对象只是根据单态来定义的，例如，由于整数具有与自然数相同的基数，那么整数不是自然数的子对象吗？如果你给我一个从整数到自然数的单态，那就给我一个子对象。好吧，我想有些人必须尊重包容性。我抽烟没有要求尊重包容性。因此，如果我有两个不同的自然数子对象，但它们之间不能很好地交换，那么我会将它们视为相同的子对象。</font></font></p><p>Their questions. If some object is just defined in terms of like
            monomorphism, like since, like, the integers have the same cardinality
            as the natural numbers, wouldn’t, like, the integers be a sub object of
            the natural numbers? If you give me a monomorphism from the integers to
            the natural view, give me a sub object. Okay, I suppose some have to
            respect the inclusion. I smoke didn’t ask to respect the inclusion. So,
            if I have two different sub objects of the naturals, but I’m not between
            them that commutes nicely, then I consider them the same sub object.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，第一天他就做了这个对分区。我们说这是一张地图，这是一个搜索动作。但如果我有另一个东西，那就是拒绝，但我想，它们之间有很好的工作，那么我会认为它们是相同的分区。x 的子对象——我的意思是，这就像说偶数集？只是一个子对象。它是自然数的对象吗？我想你是这么说的。它不是 x 的对象，因为 x 就像是一种类型，比如自然数。它是该类型的子对象。所以，它也不是集合的对象，除了其他对象，对象类。什么？是的，我是包含，对吧？</font></font></p><p>So, so he did this pair partitions on the first day. We said it’s a
            map, it’s a search action. But if I had another thing that was, it was
            rejecting to, but there was nice work, I suppose, in between them, then
            I would consider them the same partition. Where a sub object of x—I
            mean, that’s like saying is the set of evens? Just a sub object. Is it
            an object to the naturals? I think you said it like that. It’s not an
            object of x, because x is like it’s a type, like the naturals. It’s a
            sub object of that type. So, it’s not an object of set either, except
            other ones, class of objects. What? Yeah, I was inclusions, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，假设我们在图中。好的，让我们在图中再做一遍。我们有极限和：缺失图。我们有任何单态，你可以将其视为图映射的图像。图是笛卡尔封闭的。给定两个图，G 和 H，它们之间有一个映射图。如果 G 和 H 是图，则从 G 到 H 的映射图的顶点是从 G 到 H 的所有映射。抱歉，这些都是自反图。</font></font></p><p>So, let’s say we’re in graphs. Okay, let’s do this whole thing again
            in graphs. We have limits and: missing graphs. We have any monomorphisms
            that you can take the image of a graph map. Graphs are Cartesian closed.
            Given two graphs, G and H, there is a graph of maps between them. If G
            and H are the graphs, the vertices of the graph of maps from G to H are
            all the maps from G to H. Sorry, these are reflexive graphs.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">假设我说的是反射。顶点都是从 D 到 H 的映射，边是给定的。两个最大组 G 到 H。如果每个顶点之间都有一条边，我们在一个顶点和另一个顶点之间，那么它们之间就是映射图中的边。所以，我说的一切都得到了发展。最后，有一个叫做 Omega 的图。Omega，这个图，有一个从单顶点图到它的映射，这样对于任何其他图和该图的任何子对象（即子图），都有一个从该图到 Omega 的映射将其切出。</font></font></p><p>Let’s say I’m saying reflects. Address the vertices are all maps from
            D to H, and the edges are given. Two maximal group G to H. If there’s an
            edge between every vertex, and we’re in one and the other, then up and
            between them, those are the edges in the graph of maps. So, all the
            things I’m saying were progressed. And finally, there is a certain graph
            called Omega. Omega, the graph, has a map from the single vertex graph
            into it, such that for any other graph and any sub object of that
            graph—so, subgraph—there is a map from the graph to Omega that cuts it
            out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不知道你的问题是什么，因为我说了很久。好的。但所有这些东西在任何拓扑中都有效。然后，在任何拓扑中，我们将查看子图或子数据库实例或这里的子任何东西。我们将查看从该实例或从该图到此特殊图的所有映射的集合。我想我问的是：直观地说，集合的子对象是子集。</font></font></p><p>I don’t know what your question is anymore because I talked for a
            long time. Okay. But all this stuff works in any topos. And then, in any
            topos, we’re going to look at the subgraphs or the sub database
            instances or the sub whatever’s here. We’re going to look at the set of
            all maps from that instance or from that graph to this special graph. I
            guess what I was asking was: intuitively, a sub object of a set is a
            subset.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是你正式定义它的方式是将其作为单态的等价类……哦，是的。因为它不能接受理论。在集合论中，集合是非常特殊的东西。比如，我可以有一个只有一个元素的集合，但那个元素就像孪生素数的自然数。这就像一个单元素集。一个元素是孪生素数。从范畴论的角度来看，一个对象只是一个点。</font></font></p><p>But the way you would formally define it is as an equivalence class
            of monomorphisms into the… Oh, yes. So, because it can’t accept theory.
            In set theory, sets are very special things. Where, like, I could have a
            set with only one element, but that element was like the naturals that
            are twin primes. That’s like a one element set. One element is twin
            primes. That’s kind of, from a category theoretic point of view, that
            one object is just a dot.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它不是——一个元素只是一个点。它没有任何意义。从上往下。所以，我没有子集，我保留了它们的含义，我只是有一些点，没有结束，我不知道我从哪里得到了这些点。所以，如果我有一些点，如果你给我一些子子对象，我们的一些子集，其他人也这样做，只要它们是相同的，就像三年级一样。但你对术语的理解是，它不仅仅是对象，不仅仅是子集，而是包含其中。</font></font></p><p>It doesn’t—that one element is just a dot. It doesn’t mean anything.
            From the one up from. So, instead of having subsets where, like, I
            retain their meaning somehow, I just have some dots, and not over, and I
            can’t tell where I got these dots. So, if I have some dots, if you give
            me some sub sub object, some subset of us, and someone else does also,
            as long as they’re the same, like third grade. But what’s your sleeting
            about the terminology is that it’s not just the object, it’s not just
            the subset, it’s that the inclusion into that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我们的子对象在任何实际意义上都不是拓扑斯的对象。对吧？核心不是拓扑斯中的最小对象。它是拓扑斯中存在的单态。它是一类单态。它很奇怪。出于某种原因，它看起来像这样。你只需弄清楚它应该是什么，出于某种原因，它看起来像这样。我的意思是，我可以告诉你原因，但下课后你必须留下来。</font></font></p><p>So, our sub object is not, in any real sense, an object of the topos.
            Right? The nucleus is not the least object in the topos. It’s a
            monomorphism present in the topos. Where it’s a class of monomorphisms.
            It’s a pretty weird one. It looks like this for some reason. You just
            figure out what it has to be, and for some reason it looks like this. I
            mean, I can tell you the reason, but you’ll have to stay after
            class.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其他问题只是关于图形分类器……好的，还有其他问题吗？好的。现在我将告诉您我一直在说的很多东西，它们适用于任何拓扑结构。从我们这里的情况来看，上面的这个小块……不管它是什么……不管它在做什么，有点像一个连接点。当你第一次看到它时，你会想，“什么？为什么这对你们如此重要？”同样，为什么 Ω 如此重要？原因是它允许你进行逻辑推理。</font></font></p><p>Other questions just about the classifier for graphical… okay, other
            questions? Okay. So now I’ll tell you about lots of this stuff that I’ve
            been saying works in any topos. And from what we have here, this little
            nugget above… whatever this is… whatever this is doing, kind of like a
            junction. When you first see it, it’s like, “What? Why is that so
            important to you guys?” In the same way, why is Ω so important? The
            reason is because it allows you to do logic.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像真/假可以让你进行逻辑推理一样。如果没有真/假，你会从哪里开始逻辑推理呢？在时间类型理论中，当棋盘上的这些行为存在时，逻辑不是真/假。但什么时候不是呢？它并不总是正确或总是错误，而是像何时的逻辑。什么时候是真的？控制器什么时候出现故障？或者什么时候表现正常？例如，我有这个从 1 到 Ω 的任何拓扑图都是真的。但这给了我一个从 1 到 Ω × Ω 的映射，称为真真。</font></font></p><p>Just like true/false allows you to do logic. Where would you start
            with logic without true/false? In temporal type theory, where these
            behaviors on that board live, the logic is not true/false. But when
            isn’t it? It’s not always true or always false, but like the logic of
            when. When is it true? When was the controller acting up? Or when was it
            acting right? For example, I have this map all true from 1 to Ω in any
            topos. But that gives me a map from 1 to Ω × Ω called true true.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个子对象，因为任何事件在 1 处都是单态。所以如果我问……我知道对于任何单态，比如 true true，都有某种东西可以对其进行分类。有一个从 Ω × Ω 到 Ω 的映射，对 Ω × Ω 的子对象进行分类。分类意味着这将是一个回调。所以我得到了一个集合中的映射，例如，从 true/false × true/false 到 true/false。</font></font></p><p>And that’s a subobject because any event that at 1 is a monomorphism.
            So if I ask… I know that for any monomorphism like true true, there is a
            certain thing that classifies it. There’s a map from Ω × Ω to Ω
            classifying that subobject of Ω × Ω. Classifying means that this will be
            a pullback. And so I get a map in sets, for example, from true/false ×
            true/false to true/false.</p>
        <h2 id="binary-operations-and-classifiers"><font style="vertical-align:inherit"><font style="vertical-align:inherit">二元运算和分类器</font></font></h2><h2>Binary Operations and
            Classifiers</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是什么映射？是的，是合取吗？嗯，你说得对。任何从 true/false × true/false 到 true/false 的二元运算都会将 true/false × true/false 的某个子对象分类。而这个，我们知道它必须是 Ω × Ω 中所有元素 a、b（我猜是布尔值 1、布尔值 2）的集合，使得 f(b1,b2) = true。好吧，这应该会有所帮助。答案是：如果这个集合为 true，那么 f 就必须是，正如有人所说的那样。</font></font></p><p>What map is it? Yeah, is it the conjunction? Well, you’re right. Any
            binary operation from true/false × true/false to true/false classifies
            some subobject of true/false × true/false. And this one, we know that
            this has to be the set of all elements a, b (I guess, or boolean 1,
            boolean 2) in Ω × Ω such that f(b1,b2) = true. Okay, that’s
            supposed to help somehow. The answer is: if this is the set true true,
            then f has to be, as someone said, it.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">1 是所有……的集合，就像这里的映射可能……您可以将其写为真真，由真真对组成的单元素集。是的。任何子集……我需要将其作为回调。是的，是的。让我们试试看。</font></font></p><p>And 1 is the set of all… like this map here is probably… you can
            probably write it as a true true, the one element set consisting of the
            pair true true. Yeah. Any subset… I need this to be a pullback. Yeah,
            yeah. Let’s try it.</p>
        <h2 id="classifying-subsets-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在 Topos 中对子集进行分类</font></font></h2><h2>Classifying Subsets in Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，假设……所以这句话的意思是，真真假假是由合取来分类的。比如，如果我有一些 x，我有一个从 Ω × Ω 映射……感觉就像我给了自己 x 的每个元素两个真值，如果我想要当我穿过这个东西时，它们都是那样的，我就会得到两个真……那并不是说两者……我可以告诉你原因，但你下课后必须留下来。</font></font></p><p>Okay, let’s say… So what this is saying is that true true is
            classified by conjunction. Like, if I had some x and I had a map from Ω
            × Ω… it feels like I gave myself two truth values for every element of
            x, and if I want that when I go across this thing, they’re both like
            that, I get two true… that wouldn’t be saying that both of… I can tell
            you the reason, but you’ll have to stay after class.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">其他问题只是关于图形分类器。好的，还有其他问题吗？好的，现在我将告诉您这些东西在任何拓扑中是如何工作的。从我们这里的情况来看，上面的这个小块——不管它是什么——就像一个连接点。当你第一次看到它时，你会想，“为什么它如此重要？”同样，为什么 Ω 如此重要？原因是它允许你进行逻辑推理。就像真/假允许你进行逻辑推理一样，如果没有真/假，你会从哪里开始逻辑推理？</font></font></p><p>Other questions just about the classifier for graphical [stuff].
            Okay, other questions? Okay, so now I’ll tell you about how lots of this
            stuff works in any topos. From what we have here, this little nugget
            above—whatever this is—acts kind of like a junction. When you first see
            it, it’s like, “Why is that so important?” In the same way, why is Ω so
            important? The reason is because it allows you to do logic. Just like
            true/false allows you to do logic, where would you start with logic
            without true/false?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在时间类型理论中，当棋盘上的这些行为发生时，逻辑不是真/假。它并非总是真或总是假，而是</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">何时</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的逻辑——何时为真？控制器何时出现故障？或者何时表现正常？例如，我有这个从 1 到 Ω 的映射，在任何拓扑中都是真。但这给了我一个从 1 到 Ω × Ω 的映射，称为真真。这是一个子对象，因为任何为 1 的事件都是单态。</font></font></p><p>In temporal type theory, where these behaviors on that board live,
            the logic isn’t true/false. It’s not always true or always false, but
            the logic of <em>when</em>—when is it true? When was the controller
            acting up? Or when was it acting right? For example, I have this map all
            true from 1 to Ω in any topos. But that gives me a map from 1 to Ω × Ω
            called true true. And that’s a subobject because any event that’s at 1
            is a monomorphism.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果我问，我知道对于任何像 true true 这样的单态，都有某种东西可以对其进行分类。有一个从 Ω × Ω 到 Ω 的映射，对 Ω × Ω 的子对象进行分类。分类意味着这将是一个回调。因此，我得到了一个集合中的映射，例如，从 true/false × true/false 到 true/false。它是什么映射？是的，它是合取吗？好吧，你说得对，从 true/false × true/false 到 true/false 的任何二元运算都会对 true/false × true/false 的某个子对象进行分类。</font></font></p><p>So, if I ask, I know that for any monomorphism like true true,
            there’s a certain thing that classifies it. There’s a map from Ω × Ω to
            Ω classifying that subobject of Ω × Ω. Classifying means that this will
            be a pullback. And so I get a map in sets, for example, from true/false
            × true/false to true/false. What map is it? Yeah, is it the conjunction?
            Well, you’re right that any binary operation from true/false ×
            true/false to true/false classifies some subobject of true/false ×
            true/false.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">而这个，我们知道它必须是 Ω × Ω 中所有元素 (a, b) — 我猜，或者布尔值 1，布尔值 2 — 的集合，使得 f(b1,b2) = true。</font></font></p><p>And this one, we know that this has to be the set of all elements (a,
            b)—I guess, or boolean 1, boolean 2—in Ω × Ω such that f(b1,b2) =
            true.</p>
        <h2 id="classifying-binary-operations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">二元运算分类</font></font></h2><h2>Classifying Binary
            Operations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这应该能有所帮助。答案是，如果这是真真集合，那么 f 就必须是，就像有人说的那样，1 是所有集合的集合——就像这里的映射可能一样——你可以把它写成真真，由真真对组成的一个元素集。是的，任何子集。我需要这是一个回调。是的，是的，让我们试试。好的，让我们说……所以，这句话的意思是，真真是由合取分类的。</font></font></p><p>That’s supposed to help somehow. The answer is, if this is the set
            true true, then f has to be, as someone said, and 1 is the set of
            all—like this map here is probably—you can probably write it as a true
            true, the one element set consisting of the pair true true. Yeah, any
            subset. I need this to be a pullback. Yeah, yeah, let’s try it. Okay,
            let’s say… So, what this is saying is that true true is classified by
            conjunction.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">比如，如果我有某个 x 和一个 Ω × Ω 的映射，感觉就像我为 x 的每个元素赋予了两个真值，如果我希望当我遍历这个东西时，它们都是那样的，我就会得到两个真值。这并不是说这两个东西都是真的。就像我得到的两个东西是真和真。如果我得到的两个东西是真和真，我可以说它们是结束。</font></font></p><p>Like, if I had some x and a map from Ω × Ω, it feels like I gave
            myself two truth values for every element of x, and if I want that when
            I go across this thing, they’re both like that, I get two true. That
            wouldn’t be saying that both of those things are true. It’s like the two
            things I get are true and true. If the two things I get are true and
            true, I can say that the end of them.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我将其称为 p、q，那么这将被称为 p 和 q 的结束。因为你只设置了那些会变成 true 的事物的子集。可能这是更好的说法；就是这样。所以，我们可以取 omega 乘以 omega 的任何子集，并从那里得到一个映射。所以，例如，你可以说 omega 乘以 1，对不起，乘以 1，在第一部分通过我的身份映射到 omega x omega，并在第二部分进行证明。</font></font></p><p>So, if I call this p, q, then this would be called the end of p and
            q. Because you only set a subset of things that do that are those that
            go to true, true. Probably a nicer way to say this; that’s what it is.
            So, we could take any subset of omega times omega and get a map from
            there to there. So, for example, you could say omega times 1, sorry,
            times 1, mapping to omega x omega by my identity on the first part and
            prove on the second part.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这应该归类为什么？这是取两个真值 p 和 q，并要求我不关心第一个值的作用，但第二个值必须为真。所以，这基本上只是在问 p 是什么？它只是在第一个坐标下投影。但我设置它的原因是现在我将用 mega 乘以 1 加上或 1 乘以 omega 的乘积来做 omega x omega。在第一个因子上有一个映射，第一个因子是 omega 乘以真，在第二个因子上是真乘以 omega。</font></font></p><p>What would this be classified as? This is taking two truth values, p
            and q, and asking that I don’t care what the first one’s doing, but the
            second one has to be true. So, this is basically just asking what is p?
            It just projects under the first coordinate. But the reason I set this
            up is now I’ll do omega x omega with a mega times 1 plus or, the product
            of 1 times omega. There’s a map that on the first factor, the first
            factor is omega times true, and on the second factor is true times
            omega.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这会对所有对此进行分类的猜测进行分类。这是加号。所以，它表示我对一对特定的真值感到满意。满意意味着如果您在这一边或在这一边，则为真。要么您是任何事物并且是真的，要么您是真的并且是任何事物。所以，这实际上是标准的。所以，总而言之，我试图以适用于集合类别中的任何拓扑斯的方式编写它们。这要容易得多。我只会写，我喝了它，像真、假、真、真、假、真。这是一个集合，是的。也许变成 omega x omega，即真、假乘以真、假。这是分类器。这是通过或进行分类的。这是一种更具体的看待这种事情的方式。这是说任何事情成真或真成任何事情。</font></font></p><p>And that classifies any guesses that classify this. This is plus. So,
            it’s saying I am happy with a certain pair of truth values. Happy means
            goes to true if either you’re in this side or you’re in this side.
            Either you’re anything and true, or you’re true and anything. So, this
            is just actually standard. So, all up, I’m trying to write these in ways
            that would work for any topos in the category of sets. It’s much easier.
            I would just write, I drank it, something like true, false, true, true,
            false, true. That’s a set, yeah. Perhaps into omega x omega, which is
            true, false, times true, false. And this is the classifier. This is
            classified by or. And this is a much more concrete way of looking at
            this kind of thing. This is saying anything coming true or true coming
            anything.</p>
        <h2 id="subsets-and-classifiers-in-topos-continued"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的子集和分类器（续）</font></font></h2><h2>Subsets and
            Classifiers in Topos (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一个更抽象的概念。你可以写一个牙医丝带。它适用于任何地形。</font></font></p><p>So, this is a more abstractly. You can write a dentist ribbon. It
            works in any topos.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有什么问题吗？你大概明白了吗？其他人明白了吗？是的，好吧。你画这些图时是按照原样画的吗？它们似乎只是表明它们确实有 omega 交叉 omega 的子集。我有各种 omega 交叉 omega 的子集，我认为它们很重要，因为它们对操作进行分类，从 omega x omega 到 omega 的二元操作，我认为我们都认为它们很重要，比如 handed more。</font></font></p><p>Any questions? Are you following roughly? People following? Yeah,
            alright. Are you drawing these diagrams like they are? They seem to be
            just showing they do have subsets of omega cross omega. I have various
            subsets of omega cross omega that I think are important ones because
            they classify operations, binary operations from omega x omega to omega
            that I think we all agree are important, like handed more.</p>
        <h2 id="subsets-and-classifiers-in-topos-continued-1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的子集和分类器（续）</font></font></h2><h2>Subsets and
            Classifiers in Topos (continued)</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，你说得对，你说得对。我应该接受这个。好的。我选择了这个子因子。这是一个很好的观点。抱歉。回到这个问题，使用同态分解或图像分解并在这里取它的图像。这就是我想说的。这是一个很好的观点。谢谢。好的。那么，你是如何得到的——不是你是如何得到空集的，而是对不起，你是如何在任何拓扑中得到的？所以，False 是 Ω 的一个元素。</font></font></p><p>Oh, you’re right, you’re right. I’m supposed to take this. Okay. I
            chose this sub factor. This is a good point. Sorry. En route back to
            this, using an epimorphism factorization or image factorization and take
            its image in here. And that’s the thing I meant to say. Was a great
            point. Thanks. Back okay. So, how would you get—not how did you get the
            empty set, but I’m sorry, how did you get off in any topos? So, False is
            an element of Ω.</p>
        <h2 id="false-as-a-subset"><font style="vertical-align:inherit"><font style="vertical-align:inherit">False 作为子集</font></font></h2><h2>False as a Subset</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，如何得到 False？我们应该使用 Ω 的哪个子集来得到 False？是的，空子集，它始终是图像。它将是我们类别的初始对象。但实际上——我们可以直接算出这一点，因为它必须是这个图的回溯。所以，我取 1 中的事物集合，1 使得 False 等于 True，等等。你可以得到蕴涵。你可以得到——你实际上可以得到，因为所有的 都存在于任何拓扑中。</font></font></p><p>So, how would you get False? What subset of Ω should we use to get
            False? Yeah, the empty subset, which is always the image. It’ll be the
            initial object of our category. But it’s actually—we could figure this
            out directly because it has to be the pullback of this diagram. So, I
            take the set of things in 1, 1 such that False equals True, and so on.
            You can get implication. You can get—you can actually get, for all of
            exists in any topos.</p>
        <h2 id="logical-statements-in-topos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Topos 中的逻辑语句</font></font></h2><h2>Logical Statements in Topos</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可以写出“for all”和“exists”的含义。你开始看的地方会将它映射到 x，然后你要求从 Ω 到下一个 Ω 的映射。它会带我们到这个。这是什么东西？这是图、集合或拓扑斯的元素。拓扑斯是经典的，它涉及从 x 到 Ω 的所有映射，它们都是 Ω 上的谓词。记住，从 x 到 Ω（到 Ω）的映射是 Ω 上的谓词。</font></font></p><p>You can write what “for all” means and what “exists” means. Where you
            start looking at will map it to x, and you ask for maps from Ω to make
            it to next Ω. It takes us to this. What is this thing? This is the
            graph, or the set, or the element of the topos. Topos is the classic
            that is all about all maps from x to Ω, which are all predicates on Ω.
            Remember, a map from x to Ω—to Ω—is a predicate on Ω.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，对于 Ω 上的任何谓词，我们都可以要求“对于所有”为真。我们可以问，对于该谓词，无论我插入什么 x，它都是真的，这是真的吗？有一个分类器可以解决这个问题，还有一个分类器可以解决“存在”等问题。因此，这允许您在任何拓扑中采取任何逻辑语句（看起来像实数的定义或其他东西），并使用逻辑将其写出来。并且该逻辑会编译成拓扑中的某种含义。</font></font></p><p>So, for any predicate on Ω, we could ask for “for all” to be true. We
            could ask, is it true of that predicate that no matter what x I plug in,
            it is true? There is a classifier for that, and another one for
            “exists,” etc. And so, what that allows you to do is, in any topos, take
            any logical statement—seem like the definition of real numbers or
            something—and write that out using logic. And that logic compiles into
            some meaning in the topos.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。主板右下角。唤醒。好的。因此，网络的输出已启动。</font></font></p><p>Yeah. Lower right hand corner on the board. Wakes on. Okay. So, the
            network’s output is up.</p>
        <h2 id="neural-networks-and-functions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">神经网络和功能</font></font></h2><h2>Neural Networks and
            Functions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是 0、1 还是 — — 经过训练的神经网络，归根结底，只是一个从输入到输出的函数。这只是一个从输入到输出的函数。所以，我想是的。但它没有进行任何学习。所以，我总是觉得经过训练的神经网络的想法有点奇怪，因为它们只是有人以某种方式得到的函数。但是，是的，是的。好吧。如果我能通过经过训练的神经网络，那么我就可以对其进行分类。它对子对象进行分类，即那些像 — — 分割的神经网络知道如何理解橙子是否成熟。然后我选择成熟的橙子子集。</font></font></p><p>Is a 0, 1, or a—a trained neural network, at the end of the day, is
            just a function from inputs to outputs. And this is just a function from
            inputs to outputs. So, I suppose so. But it didn’t do any learning. So,
            I always find the idea of trained neural networks kind of weird, because
            they’re just functions someone got somehow. But yeah, yeah. And right.
            Okay. If I survived a trained neural network, then I could classify
            that. It classifies sub objects, namely those like—a divided neural
            network knows how to understand whether an orange is ripe or not. Then
            I’m taking the subset of oranges that are ripe.</p>
        <h2 id="concluding-remarks-and-seminar"><font style="vertical-align:inherit"><font style="vertical-align:inherit">结束语及研讨会</font></font></h2><h2>Concluding Remarks and
            Seminar</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">还有其他问题吗？好吧，我们到此为止。哦，顺便说一下，如果你参加研讨会，今天下午有一个关于博弈论的演讲，大约一个半小时。朱尔斯将做演讲。然后，是的，或者现在就留下来玩玩 topos。哦，两分钟后……</font></font></p><p>Other questions? Okay, well, let’s stop here. Oh, by the way, there’s
            a talk this afternoon if you’re sitting the seminar, about an hour and a
            half on game theory. Jules will be giving it. And then, yeah, or stick
            around now for fun with topos. Oh, in two…</p>
        <h1 id="applied-category-theory.-chapter-7-lecture-2-fong"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用范畴论。第 7 章，第 2 讲（Fong）</font></font></h1><h1>Applied
            Category Theory. Chapter 7, lecture 2 (Fong)</h1>
        <p><img src="data:image/jpeg;base64,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"><font style="vertical-align:inherit"><font style="vertical-align:inherit">6 年前 (2019 年 2 月 2 日) — 58:10 </font></font><a href="https://youtube.com/watch?v=wF-khda2i4c"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=wF-khda2i4c</font></font></a></p><p> 6
            years ago (Feb 2, 2019) — 58:10 <a href="https://youtube.com/watch?v=wF-khda2i4c">https://youtube.com/watch?v=wF-khda2i4c</a></p>
        <h2 id="summary-13"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这门麻省理工学院课程 18S097 由 David Spivak 和 Brendan Fong 在独立活动期间 (IAP) 讲授，讨论了类别，特别是拓扑。讲座探讨了形式定义背后的直观含义，并使用拓扑空间和层等示例来说明类别如何模拟逻辑和时间行为。该课程旨在将类别理论应用于实际问题。</font></font></p><p>This MIT Course, 18S097, taught by David Spivak and Brendan Fong
            during Independent Activities Period (IAP), discusses categories,
            specifically toposes. The lecture explores the intuitive meaning behind
            formal definitions, using examples like topological spaces and sheaves
            to illustrate how categories can model logic and temporal behavior. The
            course aims to apply category theory to practical problems.</p>
        <h2 id="introduction-to-purposes-and-categories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">目的和类别介绍</font></font></h2><h2>Introduction to
            Purposes and Categories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当然，是的。好的。欢迎来到本课的最后一讲。我们将进一步讨论类别。</font></font></p><p>Sure, yep. Okay. Welcome to the last lecture in this class. We’re
            going to talk more about categories.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你会注意到，随着课程的进行，定义变得越来越不精确。我们给了你一些可靠的定义，但随着结构的建立，定义变得越来越难以表述。需要花更多时间研究这种正式结构才能真正掌握定义的内容。类别的定义与直观的东西有关，但是……</font></font></p><p>You’ll notice that as this course comes on, it sort of got less and
            less precise about the definitions. We gave you some solid definitions,
            but as the structure kind of builds up, it becomes more and more
            difficult to state the definition. It requires more time sitting with
            that formal structure to really get a handle on what that definition
            has. A definition of a category links into something intuitive, but…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在最后两节课中，我们讨论了类别，但我们实际上并没有在机场定义它们。相反，我只是想让大家了解类别试图捕捉的内容。因为重要的是，在所有这些正式结构中，不要忽视我们试图捕捉的语言或核心的根本直觉。我们试图用这些想法来建模。</font></font></p><p>And so, in this last two lectures, we’re talking about categories,
            but we’re not actually defining them at airports. Instead, I just want
            to get the idea across about what a category is trying to capture.
            Because it’s important, with all these formal structures, not to lose
            sight of the underlying intuition about language or core that we’re
            trying to capture. What we’re trying to model with these ideas.</p>
        <h2 id="categorical-logic-and-truth-values"><font style="vertical-align:inherit"><font style="vertical-align:inherit">范畴逻辑和真值</font></font></h2><h2>Categorical Logic and Truth
            Values</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体来说，我们昨天遇到了两个口号。即类别就是类别。因此，我们在类别集合中看到了这些构造，但使用的是类别语言。稍后我将对此进行更详细的说明。</font></font></p><p>So, in particular, there are some two slogans that we came across
            yesterday. This is that a category is a category. So, we sort of saw
            these constructions in the category Set, but using the sort of language
            of categories. I’ll say more about that in a second.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">第二件要记住的事情是：为什么像 Set 这样的类别？好吧，我们在 Set 中做的事情之一就是逻辑。Set 是提取我的逻辑的好地方。因此，当我们说“Set”时，我们试图捕捉的是我们要捕捉可爱的方面。类别是你的直觉和我的逻辑（我的意思是，更准确地说，像一阶直觉逻辑）可以将其视为……的地方。</font></font></p><p>And the second thing to keep in mind is that: why are categories like
            Set? Well, one of the things we do in Set is logic. Set is a great place
            to pull my logic from. And so, what we’re trying to capture when we say
            “Set” is that we’re going to capture the lovable aspects. A category is
            a place in which your intuition and my logic here—I mean, more
            precisely, something like first order intuitionistic logic—see that as
            regards…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在没有定义的情况下，我们确实想知道，至少如果不确切知道类别在形式上是什么，会发生什么事情。</font></font></p><p>So, without a definition, we sort of do want to know, at least if not
            exactly what a category is formally, what sort of things happen.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这概括了这样一个事实：每个函数都可以看作是一次注入，然后是一次注入。它们有指数对象，或者 David，对吧？笛卡尔闭包。但这意味着：在类别集合中，表示从对象 X 到对象 Y 的函数的对象，本身形成一个集合。因此，我们想要类别中的这种属性。</font></font></p><p>This generalizes the fact that every function can be seen as an
            injection followed by an injection. They have exponential objects, or
            David, right? That Cartesian closed. But what this means is this: an
            object that represents, in the category Set, the functions from object X
            to object Y, form themselves a set. And so, we want that sort of
            property in categories.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后一件事是“Sally 分类器”。这是 David 所说的“超级密集”的东西，不是来自外太空，而是某种包含逻辑核心的东西。</font></font></p><p>And the last thing is the “sally classifier.” This was the thing that
            David called a “super dense” not going from outer space, but is
            something that sort of contains the core of a logic.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，如何用这种结构来表达逻辑呢？好吧，我失去了这两个元素。好吧，类别是一个对象，但也配备了来自终端对象的态射，它的存在是因为我们有极限。这就是我们在集合中挑选出元素“真”的方式。</font></font></p><p>So, how can logic be phrased in terms of this structure? Well, I lose
            the two elements. Well, a category is an object, but also equipped with
            a morphism from the terminal object, which exists because we have
            limits. And that’s how, in Set, we pick out the element “true.”</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一旦我们有了真值的概念，我们还能做什么……我们还想做逻辑，特别是二元逻辑运算。所以这些可以推广到从子对象分类器乘积到自身的映射。好的。</font></font></p><p>Once we had this notion of truth values, what else… Something else we
            want to do is logic, specifically binary logical operations. So these
            generalize to maps from the subobject classifier product with itself to
            itself. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">例如，AND 是从 Ω × Ω 到 Ω 的运算。True × True → True，True × False → False，False × True → False，False × False → False。但是我们如何构建这样的东西呢？对吧？我们如何抽象地掌握它，或者一些概念，一些我的护送的办公室，对吧？这个类别的结构也允许这样做，因为我们有这个从 1 到 Ω × Ω 的特殊映射。由于从 1 到 Ω × Ω 的乘积和映射，以及子对象分类器和子对象的属性，这给了我们 True × True → True，所以这恰好是一个函子，一个态射。所以它恰好表示一些对象和映射。对象的子对象与错误的映射相同……哦，我的天。</font></font></p><p>For example, AND is an operation from Ω × Ω to Ω. True × True → True,
            True × False → False, False × True → False, False × False → False. But
            how do we build something like this? Right? How do we get hold of it
            abstractly, or some notion, some office of my escort, and right? This is
            also permitted by the structure of this category, because we have this
            special map from one to Ω × Ω. And this gives us, because of products
            and maps from one to Ω × Ω, True × True → True, and by the property of
            subobject classifiers and a subobject, so this happens to be a functor,
            a morphism. So it happens to represent some object and maps. The
            subobjects of an object are the same as maps from the wrong… oh my
            god.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这个东西，我们在抽象结构中表达了我们希望每个拓扑结构都具有的东西，为我们提供了一个特殊的映射，或者说 AND，从 Ω × Ω 到 Ω。同样，当然，如果你想让我们所有这些都在很久以前，那么我们可以尝试构建这样一个映射。通过构造一个子对象来使用，也许这并不奇怪，因为我们讨论了交和连接，并且首先极限给了我们 AND 作为交，这是极限，或者由某种柯里化产品或卷曲米奇构造给出，这就像一个连接，但它是......我们必须更多地使用其产品的结构。这些东西中的每一个。好的，所以我们在这里得到了一个映射，但我们也有这个分解系统。所以我们可以将其分解以获得特定的子对象 × Ω，这就是我们得到 OR 的方式。这是你需要的吗？是的，这只是一个回拉正方形。这使得它成为一个回拉正方形。它是底部的。这个苹果，对不起。谢谢。谢谢。是的。好的。</font></font></p><p>So this thing, which we phrased in the abstract structure that we
            want every topos to have, gives us a special map, or AND, from Ω × Ω to
            Ω. Similarly, certainly, if you want all of us all of that to long ago,
            so we can try and construct such a map. Used by constructing a
            subobject, and perhaps it’s no surprise, given that our discussion of
            meets and joins and, and first the limits gave us AND as a meet, which
            is the limit, or is given by some sort of curried product, or curly
            Mickey construction, which is like a join, but it’s… we have to use more
            of the structure for its products. Each of these things. Okay, so we get
            a map here, but we also have this factorization system. So we can factor
            this to get a particular subobject × Ω, and that’s how we get OR. Is
            that you need? Yeah, that makes just a pullback square. And that makes
            this a pullback square. It’s the bottom one. This apple, sorry. Thanks.
            Thanks. Yes. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以如果你相信你的类别有这些东西，我可以告诉你我的真值是多少，我可以告诉你如何做 AND 和 OR，以及很多关于逻辑的知识，以及你想要的其他逻辑运算，比如全称量化、存在量化等等。根据这些东西的抽象属性，这些东西不仅会……所以我知道没有人得到二元运算，但这个二元运算的行为就像 AND，因为它以分布式方式与 OR 交互。</font></font></p><p>So if you believe your category has these things, and I can tell you
            what my truth value is up, and I can tell you how to do AND and OR, and
            sort of a whole lot about logic, aza other logical operations, you want,
            like universal quantification, existential quantification, and so on.
            And by the abstract properties that these things are, these things will
            not only… so I know nobody gets a binary operation, but this binary
            operation behaves like AND in the sense that it interacts with OR in a
            distributive way.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像如果它确实如此，你可以在任何拓扑中抽象地证明这一点。所以我试图公理化结构，告诉我我喜欢分类集的什么。但这没用，或者不那么有趣，除非我能给你更多的拓扑。如果唯一存在的群是自然数，没有人会试图公理化一个群。你不是在做群论。你只是在做数论，这与数论不相等。这不一致。</font></font></p><p>Like if it does so, you can prove this abstractly in any topos. So
            I’m trying to axiomatize the structure that tells me what I like about
            categorical sets. But this is not useful, or not not so interesting,
            unless I can give you more toposes. No one is trying to axiomatize a
            group if the only group that exists is the natural numbers. You’re not
            doing group theory here. You’re just doing number theory, which is not
            equal to that. What which does not agree.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它不是一个群。它不是一个真正自然的群，好吗？好吧，你反正不是在做群论。所以，现在的问题是如何构建服务。所以，我要绕个弯子来谈谈奶酪，特别是，我要谈谈拓扑空间。</font></font></p><p>Which is not a group. It’s a group under no really natural way, okay?
            Well, you’re not doing group theory anyway. So, the question now is how
            to construct services. So, I’m going to take what may seem like a bit of
            a detour to talk about cheese, and in particular, I’m going to talk
            about topological spaces.</p>
        <h2 id="topological-spaces-and-truth-values"><font style="vertical-align:inherit"><font style="vertical-align:inherit">拓扑空间和真值</font></font></h2><h2>Topological Spaces and
            Truth Values</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，你们应该都知道这些是什么，但我还是要重述一下。那么，什么是拓扑空间？空间是集合 X，然后是开放的子集 P。它是 X 的子集的集合，其中空集（X 的子集）存在于 P 中，并且所有集合也存在于 P 中。所以我只说它是开放的。所以，这两个集合是开放的。如果我们有两个集合，I 不适合交集，开放的。如果我们有一堆集合，所以由某个大集合 I 索引，这些都是开放的，并且是并集。因此，我的集合 X 上的拓扑集是包含空集（整个集合）的子集的集合，它在有限交集和任意并集下是封闭的。</font></font></p><p>So, expect many of you know what these are, but I’m going to recap.
            So, what is a topological space? A space is a set X, and then a subset P
            of opens. It’s a set of subsets of X such that the empty set, which is a
            subset of X, exists in P, and all sets are also in P. So, I’m just going
            to say it’s open. So, these two sets are open. If we have two sets, I
            don’t fit in the intersection, open. And if we have a bunch of sets, so
            indexed by some big set I, these are all open, and that union. So, a set
            of topology on my set X is a set of subsets that contains the empty set,
            the whole set, that’s closed under finite intersection and arbitrary
            union.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。我们应该注意到，这个开集是一个预序。它是一个预序，实际上是按包含排序的预序，这是作者从过去继承下来的。例如，你可以选一个例子，对于任何集合 X，你可以选一个开集作为幂集。它们都是子集。所以，这是一个，然后另一个众所周知的拓扑空间的例子是欧几里得空间，或者可能是任何 n 的 Rn，其中开集是由开区间生成的一些东西。</font></font></p><p>Okay. We should note that this set of opens is a pre order. It’s a
            pre order ordered by, in fact, it’s a preorder where we order things by
            inclusion, which is the author inherited from the past. So, for example,
            I mean, one example you can pick is for any set X, you can pick the set
            of opens to be the power set. They’re all subsets. So, this is a, and
            then another well known example of topological spaces is Euclidean
            space, or like possibly Rn for any n, where the open sets are some of
            these things that are generated by open intervals.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我猜，立方体是开集。现在，如果是 Ra，我们就有开区间的概念。因此，我要找到这些尖括号来表示拓扑，由它生成。我们说每个都有一条线，我们称它们为两个点，并考虑它们之间的所有东西。那么这就是一个开集，然后我们在并集和交集的运算下闭合。因此，我们不需要太担心这个图形中的交集。因此，我们与它相交并说，好吧，它仍然是一个区间，但我们可以在实数线上对它们进行并集。然后对于高维空间，您不是使用这些区间，而是使用……</font></font></p><p>So, open, I guess, of cubes. Now, so if it’s Ra, we have this notion
            of an open interval. So, the topology I’m going to find these angle
            brackets for, generated by. We say that every have a line, we say them
            two points, and consider everything included inside them between them.
            Then that’s an open set, and then we close under these operations of
            union and intersection. So, we don’t need to worry so much about the
            intersection in this graphic. So, we intersect to it and said, well,
            it’s still about an interval, but we can take unions on them in the real
            line. And then for high dimensional spaces, instead of using these
            intervals, you use…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，但是为什么这与我们在这里讨论的内容相关？这个想法是开放集概括了树。一种思考方式是：如果你考虑查询所在的空间，那么你可以问“哪里是真的东西？”。可能的答案是开放集。这个系统将你设置在 X 内部，这可能是你想要回答有关真实飞行的问题的方式。哪里下雨了？莫斯科周围地区正在下雨。但是要成为真值的海洋，真值的结构要比仅仅存在更多，对吗？它们的结构要比概念更多。你可以添加真值和更多真值，所以……那么这在这个开放集的世界中如何发挥作用？</font></font></p><p>Okay, but why is this relevant to what we’re talking about here? The
            idea is that the open sets generalize trees. One way to think of this
            is: if you consider a space where queries reside, then you can ask
            “where is something true?”. Possible answers are open sets. This system
            sets you inside X, and that’s some way you might want to answer
            questions about true flight. Where is it raining? It’s raining in this
            area around Moscow. But to be an ocean of truth value, truth values have
            more structure than just being there, right? They’d have more structure
            than just a concept. You can add truth values and more truth values, and
            so… so how does that play out in this world of well, open sets?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">资产可以被认为是真值，因为我们有这些东西。这里的感知不仅仅是一个人。它有一个顶部元素，有一个底部元素，它有交点和连接点，还有这五个元素。所以我们可以用这些来思考。我们之前已经看到了交点和连接点之间的类比，等等。所以我们用它将这些东西解释为真值。</font></font></p><p>Assets can be thought of as truth values because well, we have these
            things. This percept here is not just a person. That has a top element,
            has a bottom element, it has meets and has joins and these five
            elements. And so we can use these to think about. We’ve previously seen
            the analogy between meets and and and and joins at all, and so on. And
            so we use that to interpret these things as truth values.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，你可以将两个开集的交集视为询问“在右边？”如果你问“哪里下雨了？”答案是“这里”，你被问“电话在哪里？”答案是“那里”。那么在交集中，它值得训练。这种逻辑并不完全是你所习惯的布尔逻辑。这是一件好事，因为如果它具有布尔逻辑的所有相同属性，那么它就不再通用了。但我们可能失去的一个重要属性是排中律。</font></font></p><p>So you can think of the intersection of two open sets as asking, “At
            right?” If you ask, “Where is it raining?” and the answer is “here,”
            you’re asked, “Where is a call?” and the answer is “there.” Then in the
            intersection, it’s worth training. This logic is it’s not completely
            this sort of Boolean logic that you’re used to. And then that’s sort of
            a good thing because if it had all the same properties of Boolean logic,
            then it would be no more general. But probably one of the important
            properties that we lose is excluded middle.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">具体来说，让我告诉你什么是否定。如果你没有，你这里有一个开集，你在这里要求不是。所以这是一个从开集到开集的映射。我们的概念是，开集是 X 素数的内部。所以，这意味着如果我们考虑这里的补集，它是补集中包含的最大开集。好的。</font></font></p><p>So, in particular, let me tell you what negation is. So if you have
            not, you have some open set here, and you ask for not here. So this is a
            map from the opens to the opens. And what our conception to speak, it’s
            the open set is the interior of X prime. So I, that means that if we
            consider the complement of here, it’s the largest open set contained in
            the complement. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这部分是引理。如果我们设定了 Y，排中律是什么？哦，是的。一种表述方式是，对于布尔真值，不是某物不等于某物，对吗？某物不是不真实，而是真实。但你可以看到，在开集给出的逻辑结构中情况并非如此。</font></font></p><p>So, this part for a lemma. If we have set Y, what is the law of
            excluded middle? Oh, yeah. One way of stating that is that for Boolean
            truth values, not not something is equal to that thing, right? Something
            is not not true, it’s true. But you can see this is not the case in this
            logical structure given by open sets.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。如果我们只取实数，你可能会注意到，如果你用实数减去点零，那就是一个开集。它是二和二的并集，即正数和负数。如果我们取它的补数，那就是我对补数的符号，它就是零。它就是这个点。它里面没有开集。所以补数的内部是空的。所以空集等于整个集合。</font></font></p><p>Okay. So if we just take, say, the real numbers, you might notice
            that if you take the real numbers minus just the point zero, that’s an
            open set. It’s the union of two and two, the positive numbers and
            negative numbers. If we take the complement of that, that’s my notation
            of the complement, it’s zero. It’s just this point. And that has no open
            sets inside. So the interior of the complement is empty. So the empty
            set, which is equal to the whole set.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们看到了一些闭包。我们不确定这个开放集是什么。我们继续。这可能是也可能不是逻辑的一个坏属性，这取决于我们的应用，或者可能是逻辑的一个好属性，这取决于我们的应用。但它并不像你想象的那么不常见。例如，如果你也不承认，我很高兴。这和快乐不一样，对吧？所以我们应该自然地使用这些不遵循双重否定的表达式。我总是会通勤，好吗？一般来说，你意味着不是不是你。嘿，一般来说，你意味着知道你。是的。所以如果你有这个，那是真的。它在你的不是。哦，你很高兴。好的。</font></font></p><p>We see some closure. We’re not sure of what this open set is. We go.
            This may or may not be a bad property of logic, depending on, or good,
            probably, of logic, depending on our applications. But it’s not sort of
            as uncommon as you might maybe expect. For example, if you also don’t
            acknowledge, I’m happy. This is not really the same as happy, right? So
            we should naturally use these expressions that don’t obey this more of
            double negation. I’ll always commute, okay? And in general, you implies
            not not you. Hey, general, you implies know about you. Yeah. So if
            you’re having that, that’s true. It’s in your not. Oh, you’re happy.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，拓扑空间的概念，或者至少是开方百分比的概念，我想您可以称之为哈希代数，它为我们提供了一个概念，一个广义的真值概念。但逻辑不仅仅是关于真值，对吧？谓词逻辑或逻辑可能不是。我们在鱼子酱集合中还涉及谓词、命题、我们可以子集的东西、我们可以评估其真实性的东西。那么，一旦我们将真值概括出来，我们如何将其纳入其中？</font></font></p><p>So the idea of a topological space, or at least the idea of the
            percent of opens, which you might call the hashing algebra, I guess,
            gives us a notion, a generalized notion of truth values. But logic is
            not just about truth values, right? Predicate logic, or the logic, may
            not. We do in the caviar sets also involves like predicates,
            propositions, things that we can all subsets, things that we can
            evaluate the truth of. So how do we bring that into the picture once
            we’ll generalize the truth values?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以我们有……让我给你一串定义。这是拓扑空间上的预表，只是一个泵。它是通向相反方向的泵。所以这只是一个相当古老的支柱。开集不会预先排序。我们取相反方向。那么这有什么用呢？它取每一个开集，一种步骤的符号，我们可以将其视为可能的行为，可以存在于我们空间的那部分上的观察。所以，具体来说，这就是它作为一个函数会做的事情。</font></font></p><p>So we have… Let me give you a string of definitions. That’s a pre
            sheet on a topological space is just a pump. It’s a pump to the
            opposite. So this is just a pretty old buck up. Open sets won’t pre
            order. We take the opposite. So what does this do? It takes every open
            set, kind of signs of step, which we might think of as the possible
            behaviors, observations that can live on that part of our spaces. So, in
            particular, that’s what it would do as a function.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是现在我们还必须考虑是什么构成了函数。因此，请理解，Tony 不会为每个开集提供一组行为，但它会给我们一种方法。这里的顺序是什么？
            </font><font style="vertical-align:inherit">如果</font><em><font style="vertical-align:inherit">u包含，我们有一个从</font></em></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">u</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v 的态射……这意味着我们需要一个从这个东西来的函数，匹配一个从</font></font></em><font style="vertical-align:inherit"><em><font style="vertical-align:inherit">u</font></em><font style="vertical-align:inherit">处的行为集到</font><em><font style="vertical-align:inherit">v</font></em><font style="vertical-align:inherit">的行为集的函数</font><font style="vertical-align:inherit">。有点小了。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>But now we also have to think about what makes the function. And so
            appreciate, no Tony gives us a set of behaviors for every open set, but
            it gives us a way. What is the order here? We have a morphism from
            <em>u</em> to <em>v</em> if <em>u</em> contains… So what this means is
            we need a function from this thing, match to a function from the set of
            behaviors at <em>u</em> to the set of behaviors of <em>v</em>. Getting a
            bit small.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然后我们写出那个函数。如果我们</font><font style="vertical-align:inherit">这里有一些小的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s ，我们把那个函数写成函数的图像将</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            限制到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">。没有歧义，因为从</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">u</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">只有一个唯一的态射。所以我们从
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">m</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">快 1、2 和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v开始。所以如果我们从</font></font></em><font style="vertical-align:inherit"><em><font style="vertical-align:inherit">u</font></em><font style="vertical-align:inherit">的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">s</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">元素开始并想要</font><em><font style="vertical-align:inherit">v</font></em><font style="vertical-align:inherit">的
            </font><em><font style="vertical-align:inherit">s</font></em><font style="vertical-align:inherit">元素</font><font style="vertical-align:inherit">，那只是我们使用此因子的唯一方法。
        </font></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"></font></em><font style="vertical-align:inherit"></font></p><p>And we write that function. If we have some little <em>s</em> in
            here, we write that function as the image of the function has <em>s</em>
            restricted to <em>v</em>. There’s no ambiguity because there’s only a
            unique morphism from <em>u</em> to <em>v</em>. So we start with
            <em>m</em> faster 1, 2, and a <em>v</em>. So if we start with an element
            of <em>s</em> of <em>u</em> and want an element of <em>s</em> of
            <em>v</em>, that is only a unique method we have using this factor.
        </p>
        <p><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以我们把这个映射称为从u</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到
            </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的限制映射</font><font style="vertical-align:inherit">。现在。
        </font></font></p><p>Okay. So we call this this map the restriction map from <em>u</em> to
            <em>v</em>. Now.
        </p>
        <h2 id="sheaves-and-matching-families"><font style="vertical-align:inherit"><font style="vertical-align:inherit">捆包和匹配的家族</font></font></h2><h2>Sheaves and Matching
            Families</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">接下来，我想告诉你什么是封面……我想这实际上是，你能举个例子吗？好的。比如天气或交通，你知道如果你必须过去。比如你可以问，“这里的天气怎么样？”你会得到你想要的信息。你清理那个空间，它会告诉你它……它会告诉你里面发生的一切。但要知道北美发生了什么，就需要知道东北走廊发生了什么，对吧？所以，如果你知道北美的天气，有一个功能可以告诉你东北部的天气，好吗？</font></font></p><p>So next, I want to tell you what a cover… I guess it’s actually,
            could you just give an example of an example? Okay. Like weather or
            traffic, you know if you have to go over. Say you can ask, “What’s going
            on here in terms of weather?” and you’ll get your information. you clear
            that space, and it tells you it’s sort of… it tells you everything
            that’s going on in it. But knowing what’s going on in North America
            entails something that’s going on in the Northeast Corridor, right? So,
            if you know the weather in North America, there’s a function that will
            tell you the weather in the Northeast, okay?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想讨论的下一个概念是覆盖。我们假设类似的概念覆盖了并集。谢谢。所以，想象一下你有一堆工作集，它们构成了整个面。这有点几何，但这个概念让我们可以讨论匹配家族。所以，如果我们选择……如果我们喝一些……一些卡瓦酒……好吧。所以，如果我们选择某种颜色，我们说每个元素的选择要发现……</font></font></p><p>So, the next notion I want to talk about is a covering. Let’s just
            say we say similar concepts covers the union. Thank you. So, you imagine
            you have a bunch of working sets, and they come up sort of this entire
            is face. It’s sort of a very geometric, but what this notion allows us
            to talk about is a matching family. So, if we pick… if we kick some…
            some cava… okay. So, if we pick some color, we say that a choice of
            elements of each to discover…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，描述这个地区、这个地区、这个地区和这个地区的天气……所以我们说</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Si是一个匹配的家族。索引集。所有者将</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Ui</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的行为欺骗
            为与</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Uj</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的交集。这与论文中对</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Uj</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Uj</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的限制相同</font><font style="vertical-align:inherit">。所以，也就是说……如果我说这里是冬天，这里是夏天，那就没那么有趣了，但如果我……我知道这是……所以，这更有趣，对整个事情来说是一种小小的和平行为。
        </font></font></p><p>so, describing, say, that the weather over this region and this
            region and this region and this region… so, we say <em>Si</em> is a
            matching family. Indexing set. Owners tricked the behavior on
            <em>Ui</em> to its intersection with <em>Uj</em>. It’s the same as the
            restriction of the paper on <em>Uj</em> to <em>Uj</em>. So, that is…
            it’s not that interesting if I say it’s winter here and summer here, but
            if I… I know it’s… so, it’s more interesting, a small sort of peaceful
            behavior for the whole thing.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我们说这是工作场所的冬天，冬天不是一种天气……是的。我们在第一个图中取一种天气，在第二个图中取一种天气，当你看交叉点时，天气是一样的，是的。好吧，我们感兴趣并知道的是这些分段的世界观，我们只是知道这些分段的观点何时足够兼容，可以考虑形成一个整体的观点，对吧？所以，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Si</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">
            是我们的观察结果，</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Sj</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">是这里的观察结果，然后限制是……</font></font></p><p>If we say it’s the winter of workplaces, winter is not a weather…
            yeah. We take a weather in the first one, the weather in the second one
            to have the same weather when you look at the intersection, yeah. Well,
            we’re interested in and knowing is these piecewise views of the world,
            and we’re just knowing when these piecewise views are compatible enough
            to be to think about forming a total well view, right? So, <em>Si</em>
            is our observation here, and <em>Sj</em> is an observation here, and
            then the restriction is…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是重叠的。因此，我们有两个限制：一是限制</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Ui</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Uj</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">的正行为，一是限制它们是否一致。因此，这让我们讨论它们是否一致，然后我们想讨论粘合的概念，也就是说，如果你在 Pebble 应用程序上这里有一点和这里有一点一致，那么你……粘合是整个事物的一种行为，可以解释这一切。因此，再次说这里的</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">S ，也就是所有这些</font></font></em><font style="vertical-align:inherit"></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Ui</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">所覆盖的东西</font><font style="vertical-align:inherit">，是一种粘合。所有这些氧化物，照片匹配家族。我问的是，当我们限制到</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">Ui</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">时。</font></font></p><p>is overlap here. So, we have two restrictions: one, the restriction
            of positive behavior on <em>Ui</em> and <em>Uj</em>, one is the
            restriction on this thing to know that they agree. So, this lets us talk
            about if they do agree, we then want to talk about a notion of gluing,
            which says that if you have a bit here and here that agree on the pebble
            app, then you… then a gluing is a behavior on the entire thing that
            explains it all. So, again, say <em>S</em> in here, which is this thing
            covered by all these <em>Ui</em>, is a gluing. All these oxides, which
            photo matching family. I asked when we restrict to <em>Ui</em>.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我觉得我对</font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">i</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit">感到困惑。它在哪里？雨或太阳的内容在哪里？所以，它不是……它是函数。我们取一个开集。sᵢ 是 Uᵢ 的 S 元素。好的。所以我们有了这个集合的概念，或者说一个集合，它们匹配在一起以覆盖一个空间。然后，我们有关于每个绿色或匹配在一起的概念的局部分配。然后我们可以讨论尝试将局部映射拼凑成全局行为。Kashif 说，“如果每个匹配的家族都有，那么 S 就是 G，这意味着它恰好具有我们可能直观地知道的这个属性。如果我们知道所有事物的局部行为，那会怎样？那么这将唯一地决定全局行为。”好的。</font></font></p><p>I think I’m confused about what the <em>i</em>’s are like. Where is
            that? Where is the content of rain or sun? So, it’s not… it’s the
            function. We take an open set. sᵢ is an element of S of Uᵢ. Okay. So
            we’ve had this notion of a set of, or a collection that match together
            to cover a space. Then we have this thing about local assignments to
            each of the color green, or concepts that match together. And then we
            can talk about trying to piece together the local maps to a global
            behavior. Kashif says, “Appreciate S is a G if every matching family
            has, so this means that it precisely has this this property that we
            might intuitively. What if we know the local behaviors on everything?
            Then that uniquely determines the global behavior.” Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，在那一串定义之后，让我给你举个例子。这个集合显然有 12 个元素，每个应用程序都有一个函数可以直接映射事物。</font></font></p><p>So, after that string of definitions, let me give you an example. The
            set has apparently twelve elements, and there’s a function from each app
            that just maps things down directly.</p>
        <h2 id="examples-and-applications"><font style="vertical-align:inherit"><font style="vertical-align:inherit">示例和应用</font></font></h2><h2>Examples and Applications</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此这三个点回到 a，这四个点不存在，没什么可看的，等等。那么，我如何从中构建 C 的概念？所以我们要说我们要在 X 上取一个具有离散拓扑的层，因此用幂集作为其拓扑。</font></font></p><p>So these three points back to a, these four points not to be, nothing
            much to see, and so on. So, how do I build a notion of C from this? So
            we’re going to say we’re going to take a sheaf on X with discrete
            topology, so with a power set as its topology.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">对 Sam 来说，这个函数是什么？他们将把 X 的子集 U 发送到所谓的部分集。所以，这可能是解包。如果这是我的破集，那么部分，也就是 U 的 S 元素，就是为 a 和 b 选择 T 的一些元素的一种方式。有这个元素和这个元素，但我必须在这列中选择一些东西，因为它必须是我选择的情况。然后，如果我使用 f 向下投影，我会回到我开始的地方。所以我有这三个 a 的选择，这四个选择就没问题了。</font></font></p><p>To Sam, what is this function? They’re going to send a subset U of X
            to what’s called the set of sections. So, this is unpack that maybe. If
            this is my broken set, then a section, so an element of S of U, is a way
            of choosing some elements of T for a and b. There’s this element and
            this element, but I have to choose something in this column because it’s
            got to be the case that I’ve chosen. And then if I project back down
            using f, I get back to where I started with. So I have these three
            choices for a, and these four choices will be okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，什么是限制图谱，或者说限制图谱是什么？如果我有一些包含在 U 中的 B，我需要取一个函数，一个从 U 到 T 的部分，这是一个函数，然后将其转换为一个从 B 到 T 的函数，该函数遵循相同的分离属性。但我可以……那么，B 上有多少个部分？我稍后会问这个问题。</font></font></p><p>So, what is the restriction map, or what are the restriction maps? If
            I have some B contained in U, I need to take a function, a section from
            U, which is a function to T, and turn it into a function from B to T
            that obeys the same separation property. But I can… So, how many
            sections are there on B? I’ll ask that in a second.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。具体来说，如果我有从 U 到 T 的函数 S，那么我可以简单地将 S 限制到 V 并得到从 B 到 T 的函数。好的。</font></font></p><p>Okay. So, in particular, I can, if I have some function S from U to
            T, then I can just simply restrict S to V and get a function from B to
            T. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，正如 David 所问的，“是的，为什么不只是……？”这个问题本身就有很多定义。所以，我只是给每个人一点时间来思考这个问题。有多少……还有，具体描述了什么？这个条件在说什么？然后，如果你想在那之后思考一些事情，问题是，“我已经让你明白了，对吧？我告诉过它它是一个函子，它是一个函子，但我想讨论的是 S 和 Maya。”所以，我是一个朋友。</font></font></p><p>So, as David was asking, “Yeah, why not just…?” That question itself,
            there’s been a lot of definitions. So, I just give everyone a moment to
            think about the question. How many… Also, what is described in
            particular? What is this condition saying? And then, if you want to
            think about something after that, the question is, “I’ve given you
            appreciate, right? I’ve told it it’s a functor to do it’s a functor, but
            I want to discuss is S and Maya.” So, I’m a friend.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不知道其他人的机会是否重要，但你自己的问题才是最重要的，比如在德克萨斯州，那里的条件规定你上去后必须回来。你不能错过你应该去的电话。这就是为什么我认为它被称为部分。它有点像横截面。他说，“给我美国部分的强度。”可能她没有传票。所以也许，也许这个问题与阴影有关。我们知道这些部分在那里。从那里开始，所有的选择都是从这里开始的。好的。</font></font></p><p>I don’t know if anyone else’s chances matter, but your own problems,
            like in Texas, where the condition says you have to come back down when
            you go up. You can’t just miss the calling you’re supposed to go to.
            That’s why I think it’s called a section. It’s kind of like a cross
            section. He goes, “Give me that American strength of sections.” And
            probably she’s no subpoena. So maybe, maybe this question has something
            to do with the shadow. We know how these sections are there. From right
            there, just all choices of tears open from here. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，考虑到这一点，我们想知道 S 是首席吗？对吗？那么让我们首先考虑一下匹配家族可能是什么。所以，如果我还选择包含这两个东西的开放集，然后我踢出部分，那么匹配家族说对于这个第二集和第二集，我选择自由形状的元素，这意味着最多有例外。好的。说这个部分——这不是一个匹配的家族。有很多鼻子。原因是重叠是 B，对吗？</font></font></p><p>So, given that, we want to know is S chief? Right? So let’s first
            think about what a matching family might be. So, if I also pick the open
            set that contains these two things and I kick the section, so a matching
            family says for this second set and the second set, I pick elements of
            the free shape, which means up to exceptions. Okay. Say this
            section—this is not a matching family. There’s a lot of the nose. And
            the reason is that the overlap is B, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们需要弄清楚此部分对 A 到 B 的限制是什么，这只是将这个元素发送到这个元素的函数。我们还可以找出此处部分对 B 的限制，这是将其发送回此元素到其上方元素的函数。如果您注意到，这两个元素并不相同。因此限制不一致。因此，在匹配家族上，但我可以通过考虑此部分来映射以获得匹配家族。</font></font></p><p>So we need to figure out what the restriction of this section on A to
            B is, and that’s just the function that sends this element to this
            element. We can also figure out the restriction of the section here to
            B, which is the function that sends this back to this element to that
            above it. And if you notice, these two elements are not the same. So the
            restrictions do not agree. And so then, on the matching family, but I
            could get a matching family by mapping by considering this section
            instead.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以现在我有 A 到 B 的部分和 B 到 D 的部分，它们在重叠部分上达成一致，也就是 B。所以问题是，这是否有一个独特的元素和独特的部分，并且覆盖所有这些？在 A 到 B 到 D 的并集上是否有一个部分，将这两个函数限制在 A 到 B 和 B 到 D 上？答案是肯定的，因为我们做得对。这就是 — 这里。嗯，速度 — 这里现在是一个独特的选择。这就是 D — 这里。所以如果你在一般情况下提出这个论点，你会发现每个匹配的家族都有独特的粘合。</font></font></p><p>So now I have a section of A to B and a section of B to D that agree
            on the overlap, which is just B. So the question is, does this have a
            unique and unique elements and unique section over the union living over
            all of this? Is there a section on the union, which is A to B to D, that
            restricts to both these functions on A to B and B to D? And the answer
            is yes, because we’re just doing it right. And that’s a—here. Mmm,
            speed—here is a unique choice now. And that’s D—here. So if you make
            that argument in the general case, you see that every matching family
            has unique gluing.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，所以这个东西在这里找到捆，它有 4 个豁免。这里是我们所有的选择，这些都是我们可以拥有的价值观、行为类型。所以如果这些只是壁炉，比如说五个城市，这些都是那些经典的天气选择，而 CDC 的城市没有更好的，但 D 的气候足够好。所以它总是阳光明媚或阳光不足。他可以为波士顿效力，因为没关系。</font></font></p><p>Yeah, so this thing here to find the sheaf, and it has this waiver of
            4. Here are all our options down here, and these are all the sort of
            values, the behavior types, we could have. So if these were just
            fireplaces, say five cities, and these are those sort of classic weather
            options, and the city of some reason, CDC has no better, but D is a nice
            enough climate. So it’s always like sunny or less sunny. He can be for
            Boston because it’s okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果你写的是 S… 好的。你是说你洞穴的开放集或匹配的家庭可能是 S？S 是一个手提箱，用于一些限制。它只是一组开放集和一些安慰配件。所有这些，所以那些是不同的。我选择了这个。他在修复 UI 上方吗？大写的 I。这是 K。那里是大写的 I。他看着你。我，和 Iana。他正在修复一些，是的，是的。所以他在这里。不能举例。红色的东西是“我想要”，绿色的东西是“我知道”。它不必。人们都准备好了。事实上，这是一个更强大的条件，因为它不必适用于整个空间，对吧？我们必须……它必须有这种结构。好的。</font></font></p><p>So, if you wrote is S… okay. Are you saying you caves the open sets
            or matching family could be S? S is a suitcase for some restricting.
            It’s just a collection of open sets and some solace accessories. All of
            them, so those are different. I chose this. Is he’s fixing up above the
            UI? That capital I. This is K. It was a capital I there. He’s looking at
            you. I, with Iana. He’s fixing some, yeah, yeah. So here he’s over this.
            Can’t example. The red thing was “I want,” and the green thing was “I to
            know.” It doesn’t have to. People all set. In fact, it’s a much stronger
            condition because it doesn’t have to be for the whole space, right? We
            have to… it must have this structure. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一个简单的例子是......比如说切线束的关键部分。</font></font></p><p>So, another quick example is… is say the key folks sections of a
            tangent bundle.</p>
        <h2 id="sheaves-and-vector-fields"><font style="vertical-align:inherit"><font style="vertical-align:inherit">层和矢量场</font></font></h2><h2>Sheaves and Vector Fields</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，如果我们有某个地方……那就假设这是一个地球。对于地球上的每个点，我们都有一组切向量。对吧？这适用于任何流形。但每个点，我们都有一组向量，它们表示……并且风可以在这个点朝这个方向吹得这么强。所以，我们有这个源。对于每个点，我们都有这组向量。然后有一个映射，或者我们有所有这些向量，或者这些将形成这里集合的元素。</font></font></p><p>So, if we have some place… so that’s pretend this is a globe. To each
            point on the globe, we have a set of tangent vectors. Right? This works
            for any manifold. But every point, we have a set of vectors that say
            that… and that the wind can be blowing this strongly in this direction
            at this point. So, we have this source. For each point, we have this set
            of vectors. And then there’s a map, or we have all these vectors, or
            these will form the elements of this set here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个映射是底层流形。但是这个底层球体表示这个切向量附着在球体中的哪个点上？然后……所以有一个层具有类似的构造，即截面层。因此，对于每个……球体上的每个点，或者我们工作中的每个点（而不是球体），我们都希望在该子空间上分配一个矢量场集。这表示风在这个点上发生的情况。直到矢量场还具有不仅仅是一个函数的属性，而且它必须是一个连续映射。一个表示风在这里吹得这样的地图。这有点……我认为它与矢量有关系。这很好。</font></font></p><p>And this map down to is the underlying manifold. But this underlying
            globe says which point in the globe is this tangent vector attached to?
            And then… so there’s a sheaf that has a similar sort of construction,
            that is the sheaf of sections. So, for every… every point to the globe,
            or every point in our work instead of the globe, we want to assign the
            set of a vector field on that subspace. That says this is what’s
            happening with the wind on this point. Until vector field also has the
            property of not just being a function, but this must be a continuous
            map. A map that sort of says that the wind is blowing like this much
            here. And it’s a somewhat… I think there is a relation to the vector.
            That’s very good.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以，您说的是层向量场？是的。所有向量场都来自一个层，对吧？好的。所以，这有最好的……这有层的味道，是关于事物和集合的，我们将所有向量场的集合分配给一个开放集合。所以，行为的集合，我们可以在该集合上见证的所有事物的集合。所以这让我们回到我们的版本，我想，行为、炒作和……</font></font></p><p>Okay. So, you’re saying vector fields for my sheaf? Yes. All vector
            fields from one sheaf, right? Okay. So, that has the best… that this has
            this flavor of being a sheaf, being about things and sets where we
            assign to an open set the set of all vector fields. So, the set of
            behaviors, the set of all things that we can witness on that set. And so
            this leads us back to our versions of, I guess, behaviors, hype,
            and…</p>
        <h2 id="categories-of-sheaves-and-topoi"><font style="vertical-align:inherit"><font style="vertical-align:inherit">层和拓扑的分类</font></font></h2><h2>Categories of Sheaves and
            Topoi</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我是罗杰。</font></font></p><p>and I’m Roger.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，我们如何将所有这些勾选掉呢？给定一个拓扑空间 X，开集是该拓扑空间上的层类别。因此，有一个类别 X。这个对象和态射只是自然估计。所以，这个东西是一个类别定理，它说这些东西是层。事实上，我还没有谈论过它。插入只是使层理论令人困惑的事情之一；有两个术语定义，基本目的不正确，以及 dtraversals。如果你添加，如果你采用一个基本选择总线并添加一些额外的公理，你就会得到一个增长和伊藤总线。</font></font></p><p>So, how do we put a checkbox out of all of this? Given a topological
            space X, open sets is a category of sheaves on that topological space.
            So, there’s a category X. This objects and the morphisms are just
            natural estimations. So, this thing is a category theorem that says that
            these things are sheaves. In fact, I haven’t talked about it. Interpose
            is but one of the things that makes sheaf theory confusing; there are
            two definitions of terms, elementary purposes incorrect, and
            dtraversals. If you add, if you take an elementary choice bus and add a
            few extra axioms, you get a growth and Ito bus.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，总的来说，有一个很好的定理，它说所有这些额外的公理列表（不是我从偷来的照片）都具有逻辑性。我会更严格一点。这些都是每个老师课程都要讲的。她对拓扑空间的应用并不完全是拓扑空间，而是对拓扑空间进行了一些略微的概括，除非这些内部空间的想法在那种意义上，但要考虑到覆盖的特定概念。</font></font></p><p>But there’s a nice theorem in general that says that all of this
            extra list of axioms, which is not my photograph from stole, has a
            logical flavor. I’ll be at a more restrictive one. These are every
            teacher course is going to perform. She’s apps on not quite topological
            spaces with some slight generalization of a topological space that is
            given to capture sort of unless these ideas of inner space in that
            sense, but taking care of particular notions of covering.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它对于其他东西意味着什么，你能用任意拓扑替换它吗？你可以用很多东西替换集合。它们不需要是我们两个，即使在代数几何或其他东西中也是如此，你去得到它。艾米没有得到科科的，哦，把它拿到马。是的，是的。他们用任何绿松石设置并得到我们，但你不能用在卡尔加里和总是要干杯来代替它。是的，是的，是的，对，是的。如果你愿意，类别在这里根本不相关。你只是在拧它们。不，人们经常拿床单。所以我只是删除了分类器中的所有单词。</font></font></p><p>What it means for something else can you replace by an arbitrary
            topos? You can replace set by many things. They don’t need to be two of
            us, as even so in algebraic geometry or something, you go and get it.
            Amy didn’t get at Koko’s, oh, and get it to horse. Yeah, yeah. They set
            with any turquoise and get at us, but you can’t replace it with being in
            Calgary and always gonna toast. Yeah, yeah, yeah, right, yeah. And if
            you like, categories are not at all relevant here. You just wrenching
            them. No, people often do take sheets. So I’ve just erased the words all
            of the classifier.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你可能会问：X 是 topos 吗？子对象分类器是什么？我们说过，这是 topos 中非常重要的对象。这不是一个很长的电子版。为什么不呢？我们为什么不暂停一下？你的分类器是什么？你知道，X 的子对象分类器是什么？有什么猜测吗？真值，对吧？这是一个很好的猜测。所以，告诉你我们应该考虑子对象分类器。</font></font></p><p>One question you might have is: is X a topos? What object is the sub
            object classifier? We said that this is a really important object in
            topos. It’s not that long an electro. Why not? Why don’t we pause for a
            minute? What’s this about your classifier? You know, is what is the sub
            object classifier for X? Any guesses? The truth values, right? That’s a
            good guess. So, told you that we should be thinking the sub object
            classifier up.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是真正的破坏者，真值是开启的。好的，所以我们正在寻找设置每个开集。我们想设置称为 omega 的集合。那么，如果我们只是考虑，我们正在考虑整个空间呢？我会怎么做？现在我问一个问题，比如，我知道它走了什么路？空间的哪些部分会发生，对吧？看神智学是什么？真值是什么？所以，我的思想是存在的，是的。所以，它告诉你这个表达式在这个空间中何时何地为真。</font></font></p><p>It’s true saboteurs and the truth values are on. Okay, so we’re
            looking for to set every open set. We wanna set called omega. So, what
            if we’re just considering, we’re considering the entire space? How would
            I on? And now what I ask a question like, I know what’s it walk? What
            parts of the space to happen, right? What watching theosophy? What are
            the truth values? So, II thought is being, yeah. So, it tells you when,
            where this expression is true in this space.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这种行为是活生生的。所以，它将整个空间 X 发送到真值之一。我听说过同意。好的，但是这个子对象分类器的数据应该不多，不多，但实际上不会比这个函数多。但它应该是，它具有与我们递归才能相同的味道。所以，如果我们要求 jet 一个一般的开放集 U，我们可以在其中思考对你来说真实的事情。是的，是的，你。所以，X 的答案是我们可以通过给出任何书面集来回答问题。</font></font></p><p>That behavior is living on. So, it sends X, the entire space, to one
            of the truth values. I’ve heard consents. Okay, but the data of this sub
            object classifier should be no, not much, but not really any more than
            this function. But it should, it’s that has the same flavor as we
            recurse talents. So, if we ask for jet a general open set U, where we
            can think about things that are true on you. Yes, yes, you. So, the
            answer to X is that we can answer questions by giving any written
            set.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是现在我们要限制，我们只是说，鉴于此，我们考虑 U。我们的真值是什么？我们生活在 U 上吗？因此，真值将是开集，但它们不是开集，有点令人烦恼的是，开集位于一年内。但我需要一个函子，所以如果我有某种时尚宣言，它在 x 上在哪里调用，答案就是那个？但是我说，实际上，让我们将注意力限制在一年上，它在一年上在哪里调用，或者答案只是由一年和冷地方集的交集给出。所以，具体来说，这些限制函数可以是包含、英尺和最大值。所以，开集 U prime，一个新的首席，U prime 与 V 相交，这就是，从函数的角度考虑，限制特征函数。对吗？是的，好的。</font></font></p><p>But now we’re restricting, we’re just saying given this, we consider
            U. What are our truth values? Have we lived on U? So the truth values
            are going to be open sets, but they’re not open sets of a little vexed
            that the open set that’s lying inside a year. But I need a functor, and
            so if I have some sort of fashion statement, where is it called on x,
            and the answer to that is that? But then I say, actually, let’s restrict
            attention to a year, and where is it called on a year, or the answer to
            that is just given by the intersection of a year and the set of cold
            places. So, in particular, then, these restriction functions could be
            contains, feet, and max. So, open set U prime, a new chief, U prime
            intersect V, and that’s, which, think in terms of functions, is
            restricting the characteristic function. Right? Yes, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，现在我告诉你，拓扑空间总是形成一种类型......所以，如果正在寻找拓扑学课程，我们就正在寻找一种适合我们目的的魔法。</font></font></p><p>So, now I told you that a topological space always forms a type of…
            So, if looking for a topology course, we’re looking for a well to do
            sort of magic that suits our purposes.</p>
        <h2 id="temporal-behavior-and-topoi"><font style="vertical-align:inherit"><font style="vertical-align:inherit">时间行为和 Topoi</font></font></h2><h2>Temporal Behavior and Topoi</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们已经将问题简化为寻找合适的拓扑空间。因此，回到 David 开始的这个时间行为示例，昨天的甘露，我们希望找到欢迎回答和推理此类主题的主题。我们需要找到一个拓扑或拓扑空间，其中开放集以某种方式表示有关时间的问题的答案。因此，您可能会建议的一个答案就是实数。因此，您可以提出问题：“某事何时发生？”和“机器何时工作？”，它会返回一个开放的意义或间隔。</font></font></p><p>We’ve reduced the problem to finding an appropriate topological
            space. So, going back to this example of temporal behavior that David
            began, the nectar of yesterday, we want to find topics to welcome to
            answer and reason about that sort of subject. We need to find a topology
            or topological space where the open sets somehow represent answers to
            questions about time. So, one answer you might suggest is just the real
            numbers. So, you can ask questions: “When does something happen?” and
            “When is the machine working?” and it returns an open sense or
            interval.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">哦，抱歉，是实数的子集，是开子集。但这还不够，因为这是即时的。如果你问“机器什么时候工作？”，它会返回这些点，你不会感觉到连续的持续时间。好吗？最好说这台小机器是……如果你的真值可以说这台机器从下午 2 点到下午 3 点工作，或者类似这样的时间，你会得到更多信息。</font></font></p><p>Oh, sorry, a subset, an open subset of the real numbers. But that’s
            not quite enough, because that’s very instantaneous. And if you are sort
            of, “When is the machine working?” and it returns these points, you
            don’t get a sense of continuous duration. All right? It’s much better to
            say the little machine is… You get much more information if you’ll your
            truth values can say the machine was working from 2 p.m. to 3 p.m. or
            something like that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，相反，使用拓扑来处理和推理时间行为是有益的……因此，定义是，让我们……这已经足够了。底层集合是彼此精确的对，然后拓扑由……生成。如果某事在某个区间上是可能的或真实的，那么它在每个子区间都是真实的。所以，它是由包含……的这些开集生成的。因此，我们选择两个点，开集是严格包含在这两个点之间的所有区间的集合。</font></font></p><p>So, instead, what happens to be good for working with and reasoning
            about temporal behavior is to use the topology of a… So, the definition
            is, let us… It’s our enough. The underlying set is pairs for one precise
            another, and then the topology is generated by… If something is possible
            or true on some interval, then it is true in every sub interval. So,
            it’s generated by these open sets containing… So, we pick two points,
            and an open set is the set of all intervals that are strictly contained
            between those two points.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后，现在我们有了一个拓扑空间，其中的真值捕捉了我们所学知识的某种直觉，我们可以在这个拓扑空间上构建层，然后在这个拓扑中，在这个拓扑中，我们可以写出某种逻辑表达式。因此，我们可以为谓词写出表达式，因此这是拓扑中要查找的某个对象。</font></font></p><p>So, just to close now that we have a topological space where the
            truth values capture some sort of intuition of what we learned, we can
            build the sheaves on this topological space, and then in that
            topological, in that topology, we can write sort of logical expressions.
            So, we can write for predicates, and so this is some object in the
            topology to find.</p>
        <h2 id="modalities-and-safety-guarantees"><font style="vertical-align:inherit"><font style="vertical-align:inherit">方式和安全保障</font></font></h2><h2>Modalities and Safety
            Guarantees</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果驾驶员在时间 t 处于不利位置，则必须存在一个短暂的时间间隔 Δt，这样，在延迟 r 之后，控制装置（例如，手动控制装置或推力调节装置）将启动以调节速度。因此，重点在于，这是一阶逻辑中的某种陈述。我们可以表达这些事情。但是这些……所以这些东西，这个东西是外部课程中的一束对象。这就是所谓的模态。所以，这些东西是涡轮增压器所特有的。</font></font></p><p>If a driver is in a bad position at time t, a short time interval Δt
            must exist such that, after a delay of r, controls (e.g., hand controls
            or thrust adjustments) will be engaged to adjust speed. So, the point
            being that this is some sort of statement in first order logic. We can
            express these things. But these… so these things, this thing is an
            object of a sheaf in outer course. This is what’s known as a modality.
            So, these things are particular to the turbos.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是某种特定的态射，但所有这些东西都是根据拓扑斯的结构定义的。所以，就像在幺半群范畴中一样，我们可以像这样解释图表。一旦你告诉我什么盒子——如果你给我一些盒子里的东西——我就能告诉你这个盒子里有什么。这是清单的抽象语法。它说如果你告诉我这些盒子里有什么，对吧，展示的是优点的对象，那么我就能评估整个对象是什么。所以，给定一些关于位置和推进器的行为，它将返回你的安全保证方式，其中的东西是安全的，我希望它总是安全的。</font></font></p><p>This being some particular morphism, but all this stuff is just
            defined in terms of the structure of the topos. So, just like in, say, a
            monoidal category, we can interpret diagrams like this. Once you tell me
            what boxes—if you give me some things for these boxes—I can tell you
            what’s in this box. This is abstract syntax of a checklist. It says that
            if you tell me what’s in these boxes, right, exhibiting objects which
            are pros, then I can evaluate what this entire object is. So, that which
            will return, given some behaviors about position and the thrusters, will
            return your safety guarantee way out, where the thing is safe, which I
            hope is all the time.</p>
        <h2 id="conclusion-and-future-directions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">结论和未来方向</font></font></h2><h2>Conclusion and Future
            Directions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我讲得有点多了，但还是感谢您的到来。这对我们来说很有趣。如果您和我们一起闲逛并提问，尽管如果您有任何更基本的问题或与课程早期相关的问题，您可能……是的，如果您有任何后续问题，请告诉我们。我们希望围绕应用范畴论建立一个社区，所以如果您有项目想法或……是的，我们就在这里。我们想听听您的意见。所以，是的，谢谢大家。</font></font></p><p>Okay, so I’ve run a tiny bit over, but thanks for coming to this.
            Lots of fun for us. If you hang out with us and ask questions, although
            maybe if you have any more basic questions or sort of questions relating
            to earlier in the course, you might… yeah, please let us know if you
            have any questions going forward. Where we’d like to build a community
            around applied category theory, so if you have ideas for projects or…
            yeah, just we’re here. We want to hear from you. So, yeah, thanks
            everyone.</p>
        <h1 id="evan-patterson-realizing-applied-category-theory-in-julia"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Evan Patterson：在 Julia 中实现应用范畴论</font></font></h1><h1>Evan
            Patterson: Realizing Applied Category Theory in Julia</h1>
        <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2MBERISGBUYLxoaL2NCOEJjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY//AABEIAWgB4AMBIgACEQEDEQH/xAAbAAEAAwEBAQEAAAAAAAAAAAAAAQIDBAUGB//EAEQQAAIBAgMFAwcICAYDAQAAAAABAgMRBCExBRITQVEUYZEGIjJSVHGSFzRCYoGhsdIVIzVEcnPB0TNDgpPh8EVToiT/xAAYAQEBAQEBAAAAAAAAAAAAAAAAAQIDBP/EAB4RAQEBAQACAwEBAAAAAAAAAAABEQIDMRIhQVEi/9oADAMBAAIRAxEAPwD8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9h8nG2PacD8c/yj5ONse04H45/lA+PB9h8nG2PacD8c/yj5ONse04H45/lA+PB9h8nG2PacD8c/wAo+TjbHtOB+Of5QPjwfYfJxtj2nA/HP8o+TjbHtOB+Of5QPjwfYfJxtj2nA/HP8o+TjbHtOB+Of5QPjwfYfJxtj2nA/HP8o+TjbHtOB+Of5QPjwfYfJxtj2nA/HP8AKPk42x7Tgfjn+UD48H2HycbY9pwPxz/KPk42x7Tgfjn+UD48H0e1PIzaOy6MalethZKTstyUm/vijynsuuvpU/F/2A4QdbwFVO29Dxf9iOw1fWh4sDlB1dhq+tDxZHYqnrQ8WDHMDp7FU9aHiR2Op1j4hcc4OjsdT1o+I7HU9aPiEc4OjsdTrHxHY6nWPiBzg6OyT6x8SOyz6xAwBv2WfWJHZp9YgYg27PPrEdnn1iBiDXs8usR2efVAZA17PPqhwJ9YgZA14EuqHAl1QGQNODLqhwZdUBmDTgy6ojhS6oCgL8KXcTwpdUBmC/Cl1Q4T6oCgL8N9UOE+qAoC/CfVDhy6oCgL8J9UOG+qAoC/DfVDhvuAoCzi0RusCAWUG+hPDfcB++gAAAAAAAAAAAAAAAAAAAAPm/LX5hQ/mf0Phps+48t/2fQ/mf0PhJMkajGfpMhCfpFSiSAQQSQQAoAAgQ2GQAAIAEMMgCCCSABBJAAEACSAABAIAMglkAAAECCSAAACgAAAACASQwKS5EfSJlyI5hF1qAtSWB+8gAqAAAAAAAAAAAAAAAAAAA+Z8uP2fQ/mf0PhJH3Xlz+z8P8AzP6HwstSNRhP0ipM/SZUokgEASQCCCQyAFACAgAQAZAZAAgAAQSyAIAAAgkAVBLIZUGQSyCAAABBIAgAAAAAAAAhkkMCsuRXmTLUcwJWpYqtSxR+8gAIAAAAAAAAAAAAAAAAAAD5jy5/Z+H/AJn9D4WR915c/s+h/Mf4HwcmSNRhU9Nlblp+kyhRJAIAkEAAAQBNyLgggm5AAAgEAAAwIABUQCSCKAACGQSCohkEsggAAAAAIBIAgEkAAAADAYGctUPpEy1RHMonmWK8yxB+8gAqAAAAAAAAAAAAAAAAAAA+X8uvmGH/AJj/AAPg5H3nl18xw/8AMf4HwchFjmqNqbITZrKnGUJy5pox3feFTK6Vyu+TbvZXc+swLKSLJxfUzUGnfU3pOUnaNOLFGbcVzfgUckdWIw83T39yKfczicZdCC+8hvLqU3ZdGFHrfwKL3XUXKOHR3KZog2IM02TdlGhBVSYvLqQWFijnJMcR9ALEEb/cQ5FRYgjeRO8gAFwBBBYjIioBICIBJAAAAAAAIJIAEMkMCkuRBMuRBRPMsU5l0QfvIAKgAAAAAAAAAAAAAAAAAAPlvLp//iwy+u/wPhJH3fl18zw38cvwR8JIRYp/kVX3owOj92rfxROcRQtCLlJJcyp04SPnqQo7KmAhSw0G3eTuVw9DhNzitVbM7qtSM4QS5amVWScklojntaZuN0cWIw8N5SjkuaOucrIrBK+9JXS5dSo4nTa+i0Qqbb0O2rN1JOUs2zMujONJRzZadOjUWcc+qJbKNkFY4WDeSX2lpYJfVJUrcy/ETKOfske4t2OiqblvO65Jmzs+ZG73kHm1acbu1/tM9zvPVlR4iV1l1KrCRu09C6Y8zc7yNxnpuhFPTIngQ5oamPLVOT0VxuSvoewqVOMGlHNinRiqqla9hq486nga9T0Ym0NlVpK7aR6WLxM4wSgrM4JYms8m2TV+LaGy6ag1Oot73lZ7LoK36/dfiYuNSbUldmqb0lHdM7WsZV9muCvRrQqLpozhqUqlJ2mrM7atKcWnfJmU4uOTz7jcrNjluxvPqbqkpK68BwO4ussN4bx0rC3XMq8M87XGjDeG8acCfNPwKOFuYQ3kLorYboFrhsiwsBWfImEU73JsQyivMuit1dlkQfvIM9/uJ3+4aZVwU310J30NMWBXeXUneXUuokEX7wBIIJAAAAAAAAA+V8u/meG/jl+CPhZH3Xl58zw38cvwPhJCNQWeGre+JzM6If4GI/0/iczYglandhkcUNTtpZIlV08TdRXeyuzGUsyOJlYyNG7sN5FEw2Aciu8Q2QUS2UbDKgSTchRJdkBam8zpW7bQ47llNkHU5eBTidTHiMo5jBvKouhnKoZORFxgvvs3wkatfEQpUk5Tk7JHLFNvJXPq/JDZsZ1JY2etPzYLvtqF5n29SlsDDqjFVlvTtm+8rPyewbfQ9erfkc1SbXM5d3Hr5515VXYWFhHzJfceBj8E6WITV5RTPq5VVnd5HzW2sYo1WoWM822nkkkefJwcrOWZzVMPKacnln4mFWrvSvzCxU2rb+h2x5dRJOnLI6KbUoJ2MZTdWF27svQluqzCNt+xTzWZzdpFd+xUbK8Yu3Q5JU+43VUOUWEcrpEcKR0txCtYujkaa1IN6iyMdC6FitSLUi5Sp6QREIbzfcSVTs33koD9zB4C8r9mvVVl/p/5Lrys2U9Z1F74GW3uA8ZeVGyX/nyXvgzSPlJsqX70l74sYPVB5y2/sp/v1L7Sy23st6Y+h9sxg7wckdq7PlpjsN/uousfg3pjKD91Rf3A6CbsxWKw8vRxFJ+6aLqpB6Tj4kRe76kbz6kby6oAW35DfZAJtMTvscR9EVA+VXI+X8vZ3wmEX15fgj4ds+18vPm2E/il+CPiWzfLPpNP/BxHuX4o5mdFL0cQvqf1RzmoNKSuzsjkjmoo6L5EqotzKlm8rBIgsgyYkSYFAySjkAsTYrcJgWKstcrYCpFyWQwJvkQESkEVJsTY0obnGp8X/D3lve6+YWPU2PgamIw83SjvS30n7j6XA0FgePToSgpTe8le6j3GVHaODlFUMI4whFZJZEYOopYre3ctLonPknyzr09fPikmumG0K9LPFQjKF7b8CMTjKc6e9SkmTtTDuvgOFRunfeusj5yWDx1B3T3lzTyM+WcfL/JzbG+O2hw6UmnmfK4vEyrVLtnr4yW9TcasZU39ZZeJ4FRecxxHLy2ocrlWVFzq4JU2uZtTm8rs5zSinKRKa6tcyHoWsLEFMxmWsTZAVzCujVJFlCEl3kGGrJnSTjdEyhuyLRzyA5rGVT0jad1JroYT1NIrzLoo9TRaAe48PH/rI7PHqzy1iavrE9rq+saXXp9mXV+JHZl6zPO7bVXMjt1XqDXo9mfrsdmfrs8/t1XqStoVVzIa7+zT9cPDz9b7jhW0ahZbRqDDXZwavrIcKv6xy/pKa5E/pOXQGutdqjpUf2SZKr4+Oleov9bOWO0s81Ze4PaWbsrrrYYa7Fjtpx0xNb/cZeO1Nqx0xVb4zz/0l3D9JR9ULr01tzbEdMXW8S68odtL96qv3pf2PKjtCD+iS9oRWTgRNdO0tp7Q2jThDF1JVFB3V4pW8DzHCfRnT2+D+iR2um+oVnhf85P/ANbMVqdNKVOVWbpttypyumtMjnjCTzSuEb0tDZaGME0s0aJ5BUt5lloZ3LRZBosisnkRJ2M5OyAlyKSYuZydyi9yUZXaLKQRpvE3Md5mkXkBLIDKsgE3IKuVgLuRVSu0jJttm+FjTeIpca/D3lvW1sFj7GhsGMdm0Ib6Vb0pSXeejhMFDBUVHf33q2zzeLHCtLCSm4+pM6Z4yy8927jj1Pt7uc5mOrEY2FJW1PLxu1IbtkjHE4unOT5nkYiTlJskkL0Y3GucHE8iGHlWrKEbJyfPQ6qrVzooYWrWoXoUrvnJyt9h09OVnyrGpsrCKlJRx29WXLh+b4njPKR7+KisHhVTrOPFV3ZarojwHqa5uuXlknpKV2kdVKKprPUzo0/pM23eZa5Jc2V3mS2VAtmQ2yN5ohsC28yyk07mNzVNLVgXU97VF431S0Mt5ciXUtB2IMZu8m+bMJ+ka9TKZpFXqaIzepotAJWjIF7A0DKksgAAAgWWhV6l/ooCACAJARAE2KFr5kMCU7EuTlYqEFXRYqiUQdGC+cJdU19zM07SL4N2xVP3lJZSa7yfqumm7ouYU5NaF94Kl6lotlOZKYF3IykyzdyrCJ5FGW5FQKsBkFEo0TyMlqaEEtgglIghlGWk8ybZAZo6MKoqvSc/R31f3XMiUUfdYurhqqvBxiksrHg42rKcrKpdHkxxNSMNzfe70JjOUsk3c53l6J5JXdFqGcndnPia6foowlv3zuijDWqNts3jjK8IKEZuKWljJRKzyL7TcYYqrOpPz5OT6tlaVHnLwJvGVSxsa9OHV2mQy6i6JyDKtiHEuVbAq0VsS5EORQsLEbw3gi2iIkyrlci5FSjKepqjKepUVepdFHqXWgAEWYNAAAgAQBL1L3urFAFaODzy0K3V9Cd/O/dYqQA3cglFBEABEEkEhVkWKokg2wvzml/EhVyrTX1mRhnbEU39ZE4lWxNX+N/iT9VVPM1TMTaOgGlgiEyQqYgnkVuQLE5J5kNlb5hF3uXyQ83oUIbsBu5x3bJIzZlvlt64VYMghsISJveJV6Ew0AItYWOqjg6lWzturqwOVG2DputtHD0Y5OU0ejSwVGlZy8595XYdNVPKWDaygpNeBVntrtHCyjiJrcslz6nHTwbqO+iPpsdCM6rVs2c0qEaFF3y55nOvTJ9PDr0YUl7jyMTVzaR3bTxkZzcKefVnmKDk7muY499fkUi2ndG6qdS0KLXLM2jg5SVzWubDfNbbsLvnyK1cPKCusysJXykQS5Mo5M0cStijNtkXLtIhpBFUGSkGFQASAM56miKT1CKPUutCktS6A13qnX7hef1fAkFEXfOEX9hOX/riQSBP6vnSXiSuBzpP7JFABolhudKf2SLJYPnTqfEYkgbpYHnCv9jRZQ2c/aF4HKSTFdSo7Nf08Qv9K/uWWG2Y/wB5rr301/c5AMHX2PZz/fZr30mT+j8A/wDyFvfSZxgmX+js/RmDem06a98JEPZeH+jtLD/apL+hylWMv9HatjuX+HjcJPu4ln96IqbGxsItqmqiXOnJSOImMpRd4tp9U7D7E04OFaKkmmmsmaY6G5ja0ek2O1V5+bOrKS78zTaf7Qrd7uP0cqNE8jNFyi6Za5SJIGlyvMIhahUy0M2zV6GLCJTIk7gWAzbLRlYSiVsBqpNi5RaEpgWuWizM2wkOLiIQelwPVwODUYqpUzb0XQ7ckVTskispBFak8zLB1lgcV2lrWajforCbzMq1F16Cpxe63O9/sKsr3ZYmk5qtOolT1uzwduba7ZN08NeNNc3qzixktKcN504K0b8+84oQnUnZJomN3uphFyeWbOunh8k3qbUaMaatY6IxRNYY06C1Z0KNkSiXYisasFJHnV6G7Jyj4HqtowqRQg8u7G8bV6SXnR0Oc0ibkXIBUSQwAAAAlFJ6luZWRBRl0UZdaFGpKTaulkhKLi7STT7zq2dGU6zW9u0kr1G9N3mRXOqc3BzUW4rV8kUPSxVGrWqwo0IpYb/Ls8n3t9TgqU5U6koSWccnYSihKTk0krt5ILNpHUqCpYunT4qc7pvLJdCjk5kno4qjhqDqVGuJLiZR3rJp53y8Dz5NOTcY7qbyXQkuiCUVZKKiSCSGAJRAAkMBhVSCWQBK1OvanzxvrCL/APlHIjr2jnUpS60YP7jP6OREkIsii8dCUErACyEdRyIjqBaWhkzWWhi9QABaCu89AKSK3NqtnHIwAm+QjmwTHJgWtY69mK+Jv0RzSSsdmzF58mEesZTkWm7GLYEPNndicHGlsajV48d+rJy3Es7aHCiZSbSTbaWgHNKF1YzVNqXms6GiIRzApGMubNVkSVk8iKOdjOVQhszckBtB3d3kjKtiY33UrmU6jlknZHPe7yA3VSnLJw16nJUW7NrkaopW1TEGQJZBpAMACCSCQBWRcpLmBVlo6FWWWgHp7UqUsTOniKWTkt2celtH4WOONScYShF2jO28utjerj61SDjLdz1e6rnMZkVvg6/ZsVTq8ovM3hicNOrNzpqmqkLPVreve+RwAuC0rKTs011RBAKJJKkgAiDR0KipcTd8zqmsgKggBEgJXdjopyp9mqwm4xmtLxz8SKxKtnRWjQjhYyhUUqkmrxX0VbO/2nMBABBUSdmOzp4WXWil4NnGdmKd8FhH9WS+8zVciLR1KIuii9xcgcwNL5EIcirdkBfkUkTF3iVkBUXIbIAlsqAVAAAXTyzPS2WtXyPLPX2ct3DkHXN5mTZMmZ72YF0GUUm2XirgQ43RENDR6GeiZBEsjGpPMvORhKSCqyqWRhKpcirUWdjCMryRRtJ7tN9WZRdkWrPRFFoBbeE3eJUl+iwKsgMFQAAAAkCCsi5SYFWWjoVZaOgGpB0UqUVhp15q6T3Yx6stO1bCb26o1KVll9KL/sTVcpKi91ytksrl6VGdaTjTV2lex24TDOVLEUXKLU4+a4vJyWdl9gtwecDvxGDw2F3VVrVJOcVOG5FWs9LnAxLoEmmGlGFeLnT4i9XqTimnXlJfSztu7tu6wFKUOJJrnZtGtGpQVGUKqqJyfpQSeXQrhJKOKpt6Xs/cMRhauHk1ONkm1e90KMXa7tp3g3w2H7RO28opatmmMwdPDwUoV1O/KzuNGFGpGnVUpQU0uTbOjHU5yk69qapSd4brWnuMKKoO/GdRdFBI6L7Pha9HEyv1ml/Qg4gdc6uAcfMwtVPvq/8ABzSSbbinu9+di6KkAMqB11nfZ2HfqzmvwOQ69dlr6tb8V/wZquVF1oVii70KBK1KolagaFJ6E3yKSAvF5DIog3kBErXKgAAAVAAAStT1sNLdpWPLpK9SK7z0Kb1INpTKbxmEwreBroYU3mROsrtXCN5TyOedTz2VdQ5p1POZFdEpqWVzGeRzSqZlpYi0bNXGDKtlJkYfOois5qeZNDJs0i9R70yBbMkioJ5AICgJIKgSQSBBIJAMzmaGc9AKsvH0TNmtP0QO5Ymju1KXDk6E5b0VfODNpzo1tnyVG8alO19+15R7vceaST4qvSqzpS3oOzta5aliq1GKjCVlF3WWjMiC4L1as60rzk21ku5FAACbTusmbzrqpSUakN6cVZT3s7d5gAF7M6a+MVWnNKioyqO85Xbv/Y5WCYJTa0NamIlUgoONNJc1FJ+JiAN8HZ4mCaupeb4nVisNUqVoRgsoUY3byX/bnDSqOlVjOOsXdHpYvHShiXvQjOnUipLk7PNK/czN3VciwdW8lJKNob2bRaM4Qwzpyc4xqpO8c80+hviatSNCnWqqLlJtOFuT6nJKXGw8m7JxlvWWWTCOd65aAEGkSddLztm116s4v8TjOzCq+Cxa7ovwYqsIcwxHQhsAStSoTAu2VbIkyoFrkEEoIAEFEgqSBIIuANsP6bfRHVRl6RhQVqbl1NaTvcg2RD1JiVlqFXgctRtTZ0x0OessyIpObSRzzk2jSWaMXkyqo2L9SXHmijKg100NKPMyua0OYGtiUibF7WRFZMhEy1IAqQSQVAkgkASQAJ5Gc9C7KTAozal6BizSk7RLEXCAI0AlIhhEABAASQwBAAAAAC7qSkoqTuo5LuKAK7sXWpVcLT3Zee2t6NtLKxxMEkkFQSCog7dn5wxMetGT8MziO3ZWeM3PXhKPimS+lc/IqWeSsUAC5DARABJQJRBIAhkkMCATYmwFSUC0FeSQHQsqSXcaYfNMpNysXw2VNkVtHUpJ+cWjmZzykBotDGrnc0XomcgjnepSrA0a87PQi+9e4Vzp2YkkyZx3WQmVFGjfCq9zKSNMLffa7gN7ecXl6JVekWm8iKxZUuVYFbFS7KFRICIAAAoMrIlkSIM2XhoUeheGgGtyUc/Gl0Q40uiBrrTM2YcaXcONLuBrYGPFl0Q4suiA2uQZcWXREcWXRAbAx4su4niy6IDUGXGl0Q40uiA2sLGPGl0RPHl0QGwMONLohxpdEBuQzHjS6IcaXRAbHVsx7u0KD+ul955/Gl0Rejip0a0KkVFuDTV+4lNdNeO5XqR6SaMjOriZ1akpyUbybbKcaXRCGtyLGPGl0Q40uiKNkWSOfjS6Injy6IDdogx48+4jjS6IDoViW7nPx5dEOPLogOhxJSyOftE+kSO0T6IDZrM1w6/WXtojk48uiLQxc4aKIHdUqNfRRbDybpyucHbKnqw8CY42pFNKMM+5kNelBlKnpHCsdVX0YeDIeNqN33YeDBr0U8ijZw9tqerDwZHbKnSPgDXVU0ZjcyeKm9VEpxpdEDXU4qccjnkmmyI15x0SEq0paqINSmaUJbtTLmjncmyY1HF3RR3wV2Wqxainc4ViZp3tEtLGVJpJqOXcQ1tyKczLtE+kSvFl0QNdF4c39w/V9X4HNxH0Q4j6Io6f1XWQ/V9JHNxH3DiMDovTWsZeIcqfKD8Tn4khxHbkDWrkvV+8iUk1pYy3mRvMC5K0KbzG++4CoACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">5 年前 (2020 年 1 月 17 日) — 1:02:47 </font></font><a href="https://youtube.com/watch?v=7dmrDYQh4rc"><font style="vertical-align:inherit"><font style="vertical-align:inherit">https://youtube.com/watch?v=7dmrDYQh4rc</font></font></a></p><p> 5
            years ago (Jan 17, 2020) — 1:02:47 <a href="https://youtube.com/watch?v=7dmrDYQh4rc">https://youtube.com/watch?v=7dmrDYQh4rc</a></p>
        <h2 id="summary-14"><font style="vertical-align:inherit"><font style="vertical-align:inherit">概括</font></font></h2><h2>Summary</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">斯坦福大学博士生 Evan Patterson 介绍了一款名为 Catlabjl 的 Julia 软件包，用于应用计算范畴论。该软件包旨在提供用于处理范畴论的编程库、计算机代数系统和交互式计算环境。它允许用户将态射表示为符号表达式、接线图或代码，并在这些表示之间进行转换。演讲重点介绍了该软件包定义类别、操作接线图和从范畴表达式生成 Julia 代码的功能。简要讨论了数据科学、规划和模型转换中的应用。演讲者强调了应用范畴论需要更好的软件工具，以及 Julia 的功能有潜力促进这一点。</font></font></p><p>Evan Patterson, a Stanford PhD student, presented a Julia package
            called Catlabjl for applied computational category theory. The package
            aims to provide a programming library, computer algebra system, and
            interactive computing environment for working with category theory. It
            allows users to represent morphisms as symbolic expressions, wiring
            diagrams, or code, and to transform between these representations. The
            talk highlighted the package’s capabilities for defining categories,
            manipulating wiring diagrams, and generating Julia code from categorical
            expressions. Applications in data science, planning, and model
            transformation were briefly discussed. The speaker emphasized the need
            for better software tools in applied category theory and the potential
            for Julia’s features to facilitate this.</p>
        <h2 id="introduction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">介绍</font></font></h2><h2>Introduction</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我们很高兴邀请到来自斯坦福大学的 Evan Patterson 来谈论应用范畴论和 Julia。是的，感谢大家的到来。很高兴看到满座。是的，我是 Evan，我是斯坦福大学统计系五年级的博士生，今天我将向你们介绍我在 Julia 编程语言中应用和计算范畴论的一些持续努力。</font></font></p><p>Okay, so we’re pleased to have Evan Patterson from Stanford talking
            about applied category theory and Julia. Yeah, thanks everyone for
            coming. It’s great to see such a full room. Yes, so I’m Evan, I’m a
            fifth year PhD student in the Stats department at Stanford, and today
            I’m going to tell you about some of my ongoing efforts to do applied and
            computational category theory in the Julia programming language.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">据我所知，范畴论的应用，至少在纯数学之外，始于逻辑和编程语言理论，但现在它们已经扩展到各种不同的领域。我在这里只提到了一些，例如量子力学，数据库和知识表示的相关领域中有很多内容。最近，有关于控制理论和机器人的研究，以及更接近我名义上工作领域的概率和统计学。仅举几个例子。</font></font></p><p>So, as far as I know, applications of category theory, at least
            outside of pure math, started in sort of logic and programming language
            theory, but by now they’ve spread to all sorts of different areas. So,
            I’ve just mentioned a few here, such as quantum mechanics, it’s been a
            lot of stuff in databases, and in the related area of knowledge
            representation. Recently, there’s been work on control theory and
            robotics, and closer to where I nominally work, probability and
            statistics. Just to name a few.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我认为，原因在于范畴论确实为如何为组合事物建立数学模型提供了统一的视角。而这并不是我在这里真正要捍卫的主张；它更像是这项工作的前提，对吧？范畴论对于做到这一点很有用。</font></font></p><p>And I think the reason for this is that category theory really offers
            a unifying perspective on how to build mathematical models for things
            that are compositional. And that’s not a claim I’m really going to
            defend here; it’s more like a premise for this work, right? That
            category theory is useful for doing this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但在任何一种应用数学中，进行数学运算、创建数学模型只是故事的一部分。我的意思是，至少我相信，任何应用数学领域要想最终取得成功，都需要产生新的、更好的科学和计算方法。而在当今世界，软件是数学成为新技术的重要组成部分。</font></font></p><p>But in any kind of applied mathematics, doing the math, creating the
            mathematical model, is only part of the story. And I mean, at least I
            believe that for any field of applied math to ultimately be considered
            successful, it needs to feed into producing new and better scientific
            and computational methods. And in today’s world, software is a big part
            of how math becomes instantiated as new technologies.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">然而，我认为公平地说，目前存在的应用范畴论软件工具还不成熟。我的意思是，它们确实支离破碎，因为实际上没有任何标准可以做任何事情。我认为这对计算范畴论来说就像是狂野西部。</font></font></p><p>However, I think it’s fair to say that the software tools that exist
            for applied category theory right now are immature. I mean, they’re
            certainly fragmented in the sense that there aren’t really any standards
            for doing anything. It’s kind of, I think, it’s kind of the wild wild
            west for computational category theory.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我在这项工作中一直在探索的问题是，也是我们将在这次演讲中探讨的问题是：我们知道什么，在计算机上从应用范畴论实例化数学模型的系统的一些组成部分是什么？</font></font></p><p>So, the question that I’ve, you know, I’ve been exploring in this
            work, and that we’ll explore in this talk, is: We know what, what might
            be some components of a system for instantiating mathematical models
            from applied category theory on computers?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在，在我继续之前，我想清一下嗓子。</font></font></p><p>Now, before I go on, I want to clear my throat.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们不妨考虑一下范畴论和软件之间的关系。首先，你可以称之为用范畴进行设计。从这个角度来看，范畴论提供了一套思想工具箱，可以帮助你设计和构建程序。因此，你可能会想到这样的口号：嗯，它就像设计模式，但希望更好，因为它们基于已经在数学中取得成功的模式。</font></font></p><p>We might think of the relationship between category theory and
            software. So, the first, you might call it designing with categories.
            So, from this point of view, category theory offers a toolbox of ideas
            to help you design and structure programs. So, the slogan that you might
            have for this is like, well, it’s like design patterns, but hopefully
            better, because they’re based on patterns that have already been seen to
            be successful in mathematics.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">现在有一门正在进行的课程，你们中的许多人都在参加名为“使用类别进行编程”的讲座，我认为这是这门课程的哲学。这样说公平吗？另一件需要考虑的事情是如何计算作为代数结构的类别。计算机代数的类别理论需要什么数据结构和算法，更一般地说，计算类别需要什么数据结构和算法？这两个都很有趣，但关键是它们并不相同。实际上，这次演讲实际上是关于第二个。它是关于我们如何计算类别？好的。</font></font></p><p>So, there’s an ongoing course right now, many of you are attending
            the lectures called “Programming with Categories,” and I think this is
            kind of the philosophy of this course. Is it fair to say so? Another
            thing to consider is how to compute on categories as algebraic
            structures. What data structures and algorithms are required for
            computer algebra of category theory, and more generally, to compute on
            categories? Both of these are interesting, but the point is they are not
            the same. And in reality, so this talk is really about the second one.
            It’s about how do we compute on categories? Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，几年来，我断断续续地开发了这个名为 Catlab 的软件包，这是 MATLAB 的一个愚蠢的双关语。</font></font></p><p>And so, for several years, on and off now, I’ve been developing this
            package called Catlab, which is a stupid pun on MATLAB.</p>
        <h2 id="catlab-package"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Catlab 包</font></font></h2><h2>Catlab Package</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个 Julia 包，旨在做几件不同的事情。我的意思是，首先，它应该是一个编程库，其他人可以将其用作在其领域中应用范畴理论的起点。我希望它最终在每个类别中都具有计算机代数系统的方面，并且是一个交互式计算环境。虽然公平地说，在这种情况下，实际上是 Jupyter 在做这项工作。但是，您仍然可以在 Jupyter 笔记本中运行它并获取图表。</font></font></p><p>And it’s a Julia package that aims to do a couple of different
            things. I mean, in the first instance, it’s supposed to be a programming
            library that other people could use as a starting point to do applied
            category theory in their domain. I would like it to eventually have
            aspects of a computer algebra system per category and also to be an
            interactive computing environment. Although, to be fair, in this case,
            it’s really Jupyter that’s sort of doing the work here. But there is
            still, you know, you can run it in Jupyter notebooks and get
            diagrams.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，至少以某种形式存在的一些特定功能包括能够使用表示对象或态射的符号表达式，例如有限表示类别或幺半群类别。操纵、转换和可视化接线图的能力，以及从态射生成和解析代码的一些功能。</font></font></p><p>So, some specific features that already exist, at least in some form,
            are the ability to work with symbolic expressions that represent objects
            or morphisms, and, like, say, a finitely presented category or monoidal
            category. The ability to, you know, manipulate and transform and
            visualize wiring diagrams, as well as some capabilities for generating
            and parsing code from and to morphisms.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">稍微详细阐述一下，我的意思是，你知道，我希望这个项目有很多发展方向，但我认为今天它能做的最有用的事情之一就是在计算机上表示态射的不同方式之间进行转换，对吧？你做了多少，对吧？所以，你可以用这些符号表达式来表示它们，比如组合和单半群积之类的。你可以在单半群类别中表示态射，接线图，就像图形语法一样，你也可以用代码来表示它们。因此，Catlab 提供了在这三种不同表示之间进行转换的功能。我们将在后面的内容中看到这些不同箭头和此图的示例。好的。</font></font></p><p>To elaborate on this a little bit, I mean, you know, there are a lot
            of directions I’d like to see this project go, but I think today one of
            the most useful things that it can do is kind of move between these
            different ways of representing a morphism on a computer, right? How much
            you do that, right? So, you can represent them as these symbolic
            expressions in terms of, like, you know, composition and monoidal
            products and stuff. You can represent morphisms in monoidal categories,
            wiring diagrams, which is like a graphical syntax, and you can also
            represent them as code. And so, Catlab provides facilities for
            transforming between all these three different representations. And
            we’ll sort of see examples of these different arrows and this diagram as
            we go along. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我也想快速为 Julia 做个宣传。解释一下，比如，为什么是 Julia？</font></font></p><p>So, I also wanted to make a quick plug for Julia. Explain, like,
            well, what, why Julia?</p>
        <h2 id="julia-programming-language"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Julia 编程语言</font></font></h2><h2>Julia Programming Language</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">有很多不同的语言可以做事。我选择 Julia 有几个原因。一方面，Julia 是一种非常新的编程语言。它在许多方面都具有现代设计，特别是它有一些非常好的功能，特别是用于应用范畴论。所以，你有一个多重分派系统。你可以有一个通用函数</font></font><code>compose</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">，然后为各种类型重载它。所以你可以在许多不同的上下文中使用组合的概念。</font></font></p><p>There’s lots of different languages you can do things in. So, there
            are a couple of reasons why I chose Julia. So, on the one hand, Julia
            is, as you may know, a very—it’s a new programming language. It has a
            modern design in many ways, and in particular, it has some features
            which are quite nice, specifically for doing like applied category
            theory. So, one thing you have is a system for multiple dispatch. You
            can have a generic function like <code>compose</code>, and then overload
            it for various types. So you can use, like, the notion of composition in
            a lot of different contexts.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这确实很酷，但仍然很棒。您可以使用 Unicode 二进制运算符等，这样您就可以编写类似于普通数学符号的东西。而且，从更直观的角度来看，它有一个完整的宏系统。它实际上非常强大，并且会利用它为事物添加一些语法糖。所以，除了这些语言设计功能之外，Julia 确实是从头开始设计的，是一种实用的编程语言，并且运行速度很快。</font></font></p><p>This is really a cool thing, but it’s still nice. You can have, like,
            Unicode binary operators and stuff, so you can write things that kind of
            look like, you know, normal math notation. And less superficially, it
            has a full fledged macro system. It’s actually quite powerful, and will
            exploit that to put some syntactic sugar on things as well. So, but
            apart from these sort of, kind of, you know, language design features,
            Julia’s really was designed from the ground up to be a practical
            programming language and to perform fast.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在更传统的应用数学社区中，它正在成为一股日益壮大的力量。因此，这将包括数值线性代数、微分方程和偏微分方程、统计、机器学习等。你知道，在我看来——每个人都有自己的观点——但至少对我来说，我希望看到应用范畴论成为更广泛的应用数学社区的一部分。我认为使用 Julia 是一种与其他人在不同领域所做的事情联系起来的方式，因为人们使用 Julia 做很多事情。</font></font></p><p>And it’s a growing force in the sort of the more conventional
            community for applied math. So, this would include things like numerical
            linear algebra, ODEs, and PDEs, and stats, machine learning, and stuff.
            And, you know, the way I see it—and everyone comes from their own
            perspective—but for me at least, I’d like to see applied category theory
            be part of the broader applied math community. And I think using Julia’s
            one way to sort of connect to what other people are doing in different
            fields, because there’s a lot that people are using Julia for.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好吧，如果我不提一下其他人已经做过或正在做的其他项目，那就太失礼了。这绝不是一份完整的清单，但我只提几个。这个项目最初的灵感实际上来自 Jason Morton 早期的一个项目 Katina。它也是在 Julia 中实现的。它已经被废弃了一段时间，但我肯定从中获得了灵感。Connexus 和 Ryan Rose、Mineski、McDavid 等人创建了一种分类查询语言，它具有一些针对常规类别的计算机代数功能。还有一家初创公司 State Box，它正在做一些有趣的事情。他们似乎专注于形式化验证。在我的著名类别或更高级类别领域，也出现了许多重写器或证明助手。我在这里列出了一些。</font></font></p><p>Okay, so I’d be remiss not to just mention some of the other projects
            that people have done or are working on. This is by no means a complete
            list, but I’ll just mention a few. So, the original inspiration for this
            project actually came from an earlier project by Jason Morton called
            Katina. It was also implemented in Julia. It’s been abandoned for a
            while, but I certainly drew some inspiration from that. So, Connexus has
            created, you know, along with, you know, headed by Ryan Rose, Mineski,
            and McDavid, and others have created kind of a categorical query
            language that has some computer algebra capabilities for regular
            categories. There’s this startup, State Box, which is doing some
            interesting stuff. They seem to have kind of a focus on formal
            verification. And there’s also been a number of kind of rewriters or
            proof assistants in the area of, my notable categories, or higher
            categories. I’ve listed a few here.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我没有时间对这些不同的东西进行分析，并说明它们的作用。我会说，令人惊讶的是——至少在我看来——这些东西之间几乎没有重叠。所以，人们仍在试图弄清楚，什么是、应该是什么、我们希望计算范畴论具备哪些能力？所以，我认为人们有很大的探索空间，希望能互相学习一些东西。</font></font></p><p>So, I’m not going to have time to put a breakdown of all these
            different things and say what they do. I will say that they’re
            surprisingly—it seems to me at least—there’s surprisingly little overlap
            between a lot of these things. So, people are still trying to figure
            out, like, what, what is, what should be, is like the, like, what are
            the capabilities that we want to have in computational category theory?
            So, I think there’s a lot of room for people to explore and hopefully
            learn some things from each other.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，介绍就到此为止。在本次演讲的剩余部分，我将花大部分时间来演示 Catlab 的一些功能。我将向您展示一些代码片段，并向您展示它的功能。最后，我将提到一些应用程序，以及我和其他人尝试使用 Catlab 的一些功能。</font></font></p><p>Okay, so, so much for the introduction. For the remainder of this
            talk, I will spend most of my time demonstrating some of the things you
            can do with Catlab. I’m going to show you some code snippets and show
            you what it does. At the end, I’ll mention a few applications, some
            things that I and other people have tried to do with Catlab.</p>
        <h2 id="applications-of-catlab"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Catlab 的应用程序</font></font></h2><h2>Applications of Catlab</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这会相当简短。最后，我还会提到一些我希望该项目能开展的地方。好的。</font></font></p><p>That’ll be fairly brief. And at the end, I’ll mention also some of
            the places I’d like to see the project go. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，在 Catlab 中，您可以执行的基本操作之一就是定义某些代数结构的签名。稍后我会更精确地说明我所考虑的事情，但现在，我们先看看这个代码片段。因此，请关注签名块。</font></font></p><p>So, one of the basic things you can do in Catlab is define the
            signature of certain kinds of algebraic structures. I’ll be a little
            more precise later about the kind of things I have in mind, but for now,
            let’s just look at this code snippet. So, focus on the signature
            block.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我这里有一个名为的 Julia 宏</font></font><code>signature</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它允许我写下类别中的类型和操作。这不是非常有效的 Julia 代码，因为 Julia 没有像通常理解的那样具有依赖类型的概念。但我可以把它写下来，然后这个宏就会——我们会从中得到一些东西。</font></font></p><p>So, I have a Julia macro here called <code>signature</code>, which
            allows me to write down the types and operations that you have in a
            category. This is not quite valid Julia code because Julia doesn’t have
            a sort of like a notion of dependent types in the way that it’s normally
            understood. But I can write this down, and then this macro will—we’ll
            get something out of this.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，具体来说，它所做的一件事是——好吧，在我这么说之前，我应该说我把它包括在这里只是为了演示目的。类别的签名以及许多其他签名都包含在标准库中。但这里没有什么特别的。这或多或少就是官方所包含的内容。</font></font></p><p>And so, specifically, at what one thing it does is—well, before I go
            say that, I should say that I’ve included this here for sort of just
            demonstration purposes. A signature for categories, as well as many
            others, are included in sort of the standard library. But there’s
            nothing really special here. This is more or less what it is included in
            the official thing.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，通过调用此宏，将生成一些与该理论中的类型和术语相关的存根方法。对吗？对对象进行操作时，有一个恒等函数。对态射进行操作时，有定义域和余域，还有一个组合函数。因此，当您调用此实例宏时，软件会合成这些函数。然后，这些函数基本上可以通过不同的方式实例化。</font></font></p><p>So, by calling this, this generates some stub methods for the related
            to the types and the terms in this theory. Right? Operating on objects,
            there’s an identity function. Operating on morphisms, there’s the domain
            and codomain, and also a composed function. So, these are synthesized by
            the software when you when you call this instance macro. And then these
            can be basically instantiated in different ways.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这些还不能做任何事情，但我们可以定义不同的类别。因此，对于 Julia 中的特定具体数据类型，我们可以说这是一种类别的实例。这方面有点 Haskell 类型类或您熟悉的东西的味道。然后我们还可以在符号表达式系统中实例化签名。对吧？因此，就像表达式树一样，您可以使用它来操纵态射的表达式或计算机代数系统中的某些东西。</font></font></p><p>So, those don’t yet do anything, but we can define different
            categories. So, we can say for particular kinds of concrete data types
            in Julia, we can say that this is sort of an instance of a category. And
            this aspect has a little bit of the flavor of like Haskell type classes
            or something that you’re familiar with. And then we can also instantiate
            the signature in systems of symbolic expressions. Right? So, like
            expression trees that you can use to manipulate expressions for
            morphisms or something as in a computer algebra system.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。我将展示每个示例。这里我要说的是，我将创建一个类别签名的实例，其中的对象是</font></font><code>destruct</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">我创建的这些类型</font></font><code>matrix domain</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">。因此，它仅由矩阵将具有的元素类型（如整数或浮点数或其他）以及维度组成。然后，将使用 Julia 的内置</font></font><code>matrix</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">类型实例化态射，因此我不需要定义它。然后我提供了一些，我在这里提供了一些非常简单的实现。因此，矩阵类别中的组合只是矩阵乘法。例如，这就是最后出现的内容。好的。</font></font></p><p>Okay. So, I’ll show an example of each of these. So, here what I’m
            going to say is I’m going to create an instance of the category
            signature where the objects are these <code>destruct</code> type I’ve
            created called <code>matrix domain</code>. So, it just consists of like
            what element type the matrix is going to have—like integer or floating
            point or whatever—as well as a dimension. Then the morphisms will be
            instantiated using Julia’s built in <code>matrix</code> type, so I don’t
            need to define it. And then I’ve provided a few, I provided some very
            simple implementations here. So, composition in a category of matrices
            is just matrix multiplication. So, that’s what appears at the end here,
            for example. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">完成这些后，我可以像在 Julia 中一样创建一个矩阵，然后调用这些通用函数来为这种特定类别提供分类接口。所以，这就像您预期的那样。好的。</font></font></p><p>And so, having done that, I can create a matrix like I ordinarily
            would in Julia, and then I can call these generic functions to give
            basically a categorical interface for this particular kind of category.
            So, that sort of works as you might expect. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，是的。我会谈到这个。我会谈到这个。我会谈到这个。是的，谢谢。</font></font></p><p>Yes, yeah. I’ll come to that. I’ll come to that. I’ll come to that.
            Yeah, thanks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，实例化签名的另一种方法是创建语法系统。因此，这些是符号表达式，它们的类型是合适的。因此，默认情况下，您可以说，我不会为这些表达式提供任何简化逻辑。因此，如果我只是创建，如果我用空主体调用语法宏，我得到的只是基本上没有任何简化的表达式树，对吗？</font></font></p><p>So, the other way you can instantiate a signature is by creating like
            a syntax system. So, these are symbolic expressions that are sort of,
            you know, suitably typed. So, by default, you can just say, well, I’m
            not going to provide any simplification logic for these expressions. So,
            if I just create, if I call the syntax macro with an empty body, what I
            get are just basically expression trees that have no simplification
            whatsoever, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，如果我像那样将 fg 与 compose h 组合起来，括号将完全按照书写方式保留。所以，你也可以说，让我——好吧，让我，在讲到这个之前，让我提点其他事情。</font></font></p><p>So, if I do compose f g with compose h like that, that bracketing is
            preserved exactly as written. So, but you can also say, let me—well,
            okay, let me, before getting to that, let me mention something else.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这些不同的表达式都有类型。因此，如果您熟悉 Julia 编程语言，您会看到这些类型都带有操作的标记。因此，如果我有两个事物的组合，例如该树的头部附加了此 compose 标记，这意味着您实际上可以使用 Julia 语言对其进行分派。因此，如果您不熟悉 Julia，这不是一个非常重要的点。还有一种 Unicode 语法，因此您可以编写 fg 来表示组合，或 g 圆圈 f，或者使用相反的约定来表示组合，对吗？</font></font></p><p>So, these different expressions have types. So, if you’re familiar
            with the Julia programming language, you’ll see that these types are
            sort of tagged with like what the operation is. So, if I have a
            composition of two things, like the head of that tree has this compose
            tag attached to it, which means that you could actually dispatch on that
            in using a Julia language. So, if you’re not familiar with Julia, it’s
            not a super important point. There’s also kind of Unicode syntax, so you
            can write fg for a compose, or g circle f, or compose with the opposite
            convention for composition, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，正如我所指出的，默认情况下，没有任何简化，对吧？因此，结合律是不正确的，对吧？因此，这些表达式彼此不相等。但我们可以添加一些简化逻辑，对吧？</font></font></p><p>So, as I’ve noted, like there’s no, by default, there’s no kind of
            simplification, right? So, the associativity law is—it’s not true,
            right? So, these expressions are not equal to each other. But we can add
            some simplification logic, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里我使用 Catlab 内置的函数，它基本上可以处理结合律和单位律。例如，完成此操作后，现在结合律和单位律实际上对这些表达式是正确的，因为树正在自我简化。我只想说，这是内置的，但您可以定义自己的简化逻辑。因此，它应该是一个灵活的系统，对于不同类型的类别，您可以有不同类型的、多种类型的简化，具体取决于您的应用程序需要。</font></font></p><p>So, here I’m using a function which is built into Catlab that
            basically is going to handle both the associativity and the unitality.
            So, so, for example, having done this, it’s now the case that the
            associative law and the unitality laws are actually true for these
            expressions because the trees are simplifying themselves. And I just
            want to mention like this is built in, but you can kind of define your
            own simplification logic. So, it’s supposed to be a flexible system
            where for different kinds of categories, you can have different kinds
            of, multiple kinds of simplification, depending on what you need for
            your application.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，它在这里到底在做什么？它是无偏的。那么，你如何规范化结合性？它所做的是计算机代数中的经典技巧；你只需将其表示为一个更长的列表。所以，现在如果你有三个东西的组合，它就不是二叉树；它会被展平为一棵有三个子节点的树。好的。</font></font></p><p>And so, what is it actually doing here? It’s—it’s unbiased. So, how
            are you normalizing the associativity? What it’s doing is the classic
            trick from computer algebra; you just represent it as a longer list. So,
            now if you have a composite of three things, it’s not a binary tree; it
            gets flattened out into a tree with three children. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，让我在这里借助一点互联网的引导来解释一下，比如，我使用的形式主义、数学形式主义是什么。所以，这些——我一直称之为签名——实际上是基于这些被称为广义代数理论的东西，或者被亲切地称为 ghats。</font></font></p><p>So, let me take a little internet lead here to explain, like, what is
            the formalism, the mathematical formalism, I’m using for this. So,
            these—what I’ve been calling signatures—are actually based on these
            things called generalized algebraic theories, or known affectionately as
            ghats.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些是 John Cartmell 在他的博士论文中发明的，后来他发表了一篇论文。你可以将 ghats 视为类型代数理论，但你在其中添加了一些非常简单的依赖类型形式。所以，你可以说，经典的例子就像 hum 和它所依赖的类别，两个值，对吧？一个是域，另一个是余域。</font></font></p><p>These were invented by John Cartmell in his PhD thesis, and which he
            later published a paper on. You can think of ghats as being like typed
            algebraic theories, but you add into that some very simple form of
            dependent typing. So, you can say that, like, so, so the classic example
            is like the, the hum, and a category it depends on, to the value, two
            values, right? One, the domain and the codomain.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你熟悉的话，这是一个技术要点。它们基本上具有与所谓的代数理论相同的表达能力，至少在集合论模型中是如此。但这里的要点是，这可能是你能拥有的最简单的逻辑系统之一，其中可以公理化结构，如类别、单半群类别等。</font></font></p><p>And this is kind of a technical point if you’re familiar with it.
            These have basically the same expressivity as what has been called
            essentially algebraic theories, at least in set theoretic models. But
            the main point here is that this is maybe one of the simplest logical
            systems you could have, in which it’s possible to, like, axiomatize
            structures like categories, monoidal categories, and so on.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，现在回到你的问题，有一个警告。比如，Catlab 实际上只对理论签名进行操作。那么，结合性公理在哪里呢？它并没有强制执行它们。所以，现在，它甚至不让你把它们写下来。但在将来，我希望有一种方法来指定公理，甚至尝试以某种方式验证它们。但那是另一回事。</font></font></p><p>So, yeah, one caveat, getting to your question right now. Like,
            Catlab only really does anything with the signature of the theory. So,
            like, where are the associativity axioms? It’s not enforcing them. And
            so, right now, it doesn’t even let you write them down. But in the
            future, I’d like to have a way of specifying the axioms and maybe even
            trying to validate them in some way. But that’s sort of something
            else.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我认为，对我来说，一个更普遍的问题，我的意思是，我真的不知道这个问题的答案是什么：比如，如何正确地表示有时被称为不同类别（如类别、单半群类别、复类别）的学说，以及你希望能够利用这些理论将它们视为数据，从旧理论中创建新理论。那么，正确的思考方式是什么？这有点值得深思。但就目前而言，我正在研究这些理论。</font></font></p><p>And a more general question, I think, you know, to me, I mean, I
            don’t really know what the answer to this question is: like, what is the
            right way to represent the, what is sometimes called, doctrines for
            different kinds of categories—like categories, monoidal categories,
            complex categories—and you kind of want to be able to, you know, work
            with those theories to treat them as data, to create new ones from old
            ones. And what is the right way to think about that? That’s sort of food
            for thought. But for now, I’m sort of working with these ghats.</p>
        <h2 id="wiring-diagrams-1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图</font></font></h2><h2>Wiring Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，接下来我想讨论的是接线图。它们也被称为弦图，有时也被计算机科学家称为端口图。但它们是对称单子范畴中态射的图形语法。所以，如果你一直在应用范畴论领域工作，那么很多人可能以前见过类似的东西。但是，你知道，例如，这是态射的一种符号表达式：f 与 g 应用编织，然后与 h 组合，然后应用另一个编织。好吧，将其绘制为接线图要透明得多。但它们代表的是相同的态射。好的。</font></font></p><p>Okay, so the next thing I want to talk about is wiring diagrams. So,
            these are also known as string diagrams, and by computer scientists,
            sometimes also port graphs. But what they are is a graphical syntax for
            morphisms in symmetric monoidal categories. So, probably a lot of you
            have seen something like this before if you’ve been working in applied
            category theory. But, you know, for example, here is the kind of
            symbolic expression for a morphism: f with g applying a braiding, then
            composing with h, then applying another braiding. Well, it’s a lot more
            transparent to draw it as a wiring diagram. But those represent the same
            morphism. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，Catlab 对接线图有相当广泛的支持。所以我将总结一下他们可以做的一些事情。</font></font></p><p>So, Catlab has fairly extensive support for wiring diagrams. And so
            I’ll summarize some of the things they can do.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但在此之前，我想澄清一些事情。因此，对于接线图或串图，可能有两种概念。因此，您可以将它们视为组合的东西，就像图形一样，对吗？因此，那里没有几何图形。这就是我通常所说的接线图。它是一种数据结构；它不是可视化。但当然，您也确实想绘制它们。Catlab 有这样做的工具。但当我谈论接线图时，我通常指的是组合式接线图。好的。</font></font></p><p>So, but before that, I want to clarify something. So, there are two
            kinds of notions of what a wiring diagram or a string diagram might be.
            So, you can think of them as like combinatorial things, like just a
            graph, right? So, there’s no geometry there. And so that’s normally what
            I mean by a wiring diagram. It’s a data structure; it’s not a
            visualization. But of course, you also do want to draw them. And Catlab
            has facilities for doing that. But when I talk about wiring diagrams, I
            usually mean wiring diagrams that are a combinatorial thing. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想简单了解的另一个区别是，有时人们也会谈论无向接线图，这对于关系之类的事情很有用。目前，Catlab 有向图。但在未来，我还希望对无向图有所支持。好的。</font></font></p><p>Another distinction that I’d like to know briefly is that sometimes
            people also talk about undirected wiring diagrams, which are nice for
            things like relations. Right now, Catlab does directed diagrams. But in
            the future, I’d also like to have some support for the undirected
            flavor. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">那么，这些是如何作为数据结构实现的呢？我会解释一下。我的做法是，基本上在更简单的数据结构（即有向图）上构建接线图。</font></font></p><p>So, how are these implemented as a data structure? So, I’ll explain
            this. So, the way I do it is I basically have built the wiring diagrams
            on top of a simpler data structure, namely just a directed graph.</p>
        <h2 id="implementation-of-wiring-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图的实施</font></font></h2><h2>Implementation of Wiring
            Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为此，我使用 Julia 中用于处理图形的标准包，也就是所谓的</font></font><code>Graphs.jl</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">。在这种编码中，图表中的每个框基本上都映射到底层有向图中的一个顶点。然后我们要做的就是创建两个特殊的顶点来表示输入和输出，对吧？所以，如果我们回到这张图片，基本上会有一个特殊的顶点表示这些线要去哪里，还有一个特殊的顶点表示这些线是从哪里来的。好的。对的。</font></font></p><p>And for that, I use the standard package for working with graphs in
            Julia, which is this thing called <code>Graphs.jl</code>. And in this
            encoding, basically every box in your diagram maps to a vertex in the
            underlying directed graph. And then what we do is we create two special
            vertices that represent the inputs and the outputs, right? So, if we go
            back to this picture, there would be basically a special vertex
            representing where these wires are going and a special vertex where
            these are coming from. Okay. And right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">正如我所说，这是一种通用数据结构。它允许您将任何类型的数据附加到盒子、端口或电线上。因此，存储相关数据通常很方便。它允许您以任意方式执行此操作。好的。</font></font></p><p>And so, as I said, like this is kind of a generic data structure. And
            it allows you to attach whatever kind of data you want to the boxes or
            to the ports or to the wires. So, it’s often convenient to store
            relevant data. And it lets you do that more or less in an arbitrary way.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，有两种方法可以处理系统提供的接线图。一种方法是命令式方法，您只需发出命令即可，例如添加或移除一个盒子，或在此处添加电线或将电线移到那里。</font></font></p><p>So, there are two ways you can work with wiring diagrams that the
            system provides. One is like a very nuts and bolts imperative approach
            where you just issue commands to like add a box or remove a box or add a
            wire here or move a wire there.</p>
        <h2 id="imperative-approach-to-wiring-diagrams"><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图的命令式方法</font></font></h2><h2>Imperative Approach to
            Wiring Diagrams</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的意思是，还有一个更具分类性的接口，它本质上是功能性的，并使用单子类别的常规词汇，例如组合和保存等等。所以我们会看到它们两者。所以我想从命令式开始，因为它以非常实用的方式展示了如何使用这些东西。有时在低层次上这样做很方便。所以，我在这里重建了我之前展示的图表。你不需要详细研究它。</font></font></p><p>I mean, then there’s also a more categorical interface that is
            functional in nature and that uses the normal vocabulary of monoidal
            categories, so composing and conserving, and so forth. So, we’ll see
            both of them. So I want to start with the imperative one because it
            shows, in a very practical way, how to work with these things. Sometimes
            it’s convenient to do it this way at a low level. So, I’m reconstructing
            here the diagram that I showed earlier. You don’t need to study it in
            detail.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我只想指出，从表示中可以看出有五个顶点。其中两个对应于输入和输出，其他三个是三个框。所以，至少从概念上讲，这应该相当简单。虽然，通常，当接线图变大时，您不想尝试从这个表示中读取它。这有点陈词滥调；通常，以组合方式构建接线图更方便，对吧？所以，这里有一种方法可以做到这一点。</font></font></p><p>I just want to point out that you can see from the representation
            that there are five vertices. Two of them correspond to the inputs and
            the outputs, and then the other three are the three boxes. So,
            conceptually at least, that should be fairly straightforward. Although,
            you typically, when the wiring diagrams get big, you don’t want to try
            to read it from this representation. It’s kind of cliché; often it’s
            more convenient to build the wiring diagrams up compositionally, right?
            So, here’s one way to do that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">从一些单例图开始，我的意思是只包含一个框的图。然后，我可以将它们张紧在一起并进行编织、X' 等。所以在这里，我只是检查我使用此语法形成的接线图是否与我刚刚手工构建的接线图相同。</font></font></p><p>Start with some singleton diagrams, by which I mean a diagram just
            containing a single box. Then, I can tensor those together and do
            braiding, X’, and so on. And so here, I’m just checking that the wiring
            diagram I form using this syntax is the same one I just constructed by
            hand.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里的一点是，你知道，我之前谈到了实例。所以，对称单子范畴有一个签名，接线图都是该签名的实例。但你也可以有其他类型的学说的接线图，它们可能具有更多的结构。所以，如果你有一个笛卡尔单子范畴，其中有复制和删除的概念——自然概念——你可以拥有它。你基本上可以参数化类型，参数化接线图类型，比如说，“好吧，我有这个额外的结构。”所以，它让你这样做。</font></font></p><p>One point here is that, you know, I talked about instances earlier.
            So, there’s a signature for symmetric monoidal categories, and wiring
            diagrams are all instances of that signature. But you can also have
            wiring diagrams for other kinds of doctrines, which may have like more
            structure to them. So, like if you have a Cartesian monoidal category
            where you have notions—natural notions—of copying and deleting, you can
            have that. And you can basically parameterize the type, parameterize the
            wiring diagram type to say, like, “Okay, I have this extra structure.”
            So, it lets you do that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们已经将接线图视为类别。接线图也构成一个操作。</font></font></p><p>We’ve seen wiring diagrams as categories. Wiring diagrams also form
            an operad.</p>
        <h2 id="composition-and-substitution"><font style="vertical-align:inherit"><font style="vertical-align:inherit">合成与替代</font></font></h2><h2>Composition and Substitution</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，他们有一个分层的合成概念。合成概念就是替换。这是将图中的某些框替换为其他接线图以获得更大的图的操作。所以这就是替换。这确实是基本操作，对吧？它当然是实现方式，因为方式……</font></font></p><p>So, they have a hierarchical notion of composition. And this notion
            of composition is substitution. It’s the operation of taking some boxes
            in the diagram and replacing them with other wiring diagrams to get a
            larger diagram. And so it’s substitution. This is really the fundamental
            operation, right? It’s certainly in the way that it’s implemented,
            because the way…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">为了说明这一点，我想大致展示一下
            </font></font><code>compose</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">接线图库中实际是如何实现的。如何组合两个接线图？您需要先从一张空图开始。添加两个与这两个接线图相对应的框。好的，我现在有一张有两个框的图片。然后，将它们串联起来。然后所有的工作都通过替换来完成。如果这些是其他图表调用
            </font></font><code>substitute</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">，那么基本上会从我们的框中移除它们并为您提供一个大图表。所以，</font></font><code>substitute</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里真的完成了所有的工作。
        </font></font></p><p>To illustrate this, I want to show more or less exactly how
            <code>compose</code> is actually implemented in the library for wiring
            diagrams. How do you compose two wiring diagrams? What you do is you
            start with an empty diagram. You add two boxes corresponding to those
            two wiring diagrams. Okay, so I have a picture now with two boxes. Then,
            you wire them up in series. And then all the work happens by then
            substituting. If these are other diagrams calling
            <code>substitute</code>, then basically removes these out our boxes and
            gives you one big diagram. So, <code>substitute</code> really does all
            the work here.
        </p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我想说的是，有一种操作在某种程度上是与此相反的。我不知道它是否有标准名称。我称之为封装。换句话说，从接线图中取出一个子图并将其替换为一个框。所以你也可以这样做。好的。现在，回到我用三种不同的态射表示绘制的原始图片。所以我们现在有了这些符号态射表达式，我们也有接线图。很自然地，我们会问如何在这两种不同的表示之间来回传递？</font></font></p><p>I want to mention that there’s an operation which is somehow inverse
            to this. I don’t know if it has a standard name or not. I call it
            encapsulation. In other words, taking a subdiagram from a wiring diagram
            and replacing it with a single box. So you can also do that. Okay. So
            now, getting back to this original picture I drew with the three
            different representations of morphisms. So we now have these symbolic
            morphism expressions, and we also have wiring diagrams. It’s natural to
            ask how can we pass back and forth between these two different
            representations?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，从某种意义上说，这其实很容易。因此，从态射表达式到接线图，在概念上应该很简单，因为你知道，对于每个态射表达式，都有一个唯一的接线图来表示它。而要实现它，它也相当容易，因为一旦你将接线图定义为对称单子类别的一个实例，你所要做的就是让它们遍历表达式树并应用这些操作，它就会直接出现。</font></font></p><p>And so, in one direction, it’s actually easy. So to go from a
            morphism expression to a wiring diagram, it should be conceptually
            straightforward, because you know that to every morphism expression,
            there’s a unique wiring diagram that represents it. And to implement it,
            it turns out to be quite easy too, because once you’ve, you know,
            defined wiring diagrams as an instance of, say, a symmetric monoidal
            category, all you have to do is let them, like, walk that expression
            tree and apply those operations, and it just comes right out.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以另一个方向更难。对吧？所以从概念上讲更难，因为多个态射表达式可以对应相同的接线图。所以稍后你会看到一个具体的例子，但这基本上是……但你想在这里想象交换定律。对吧？所以，如果你不熟悉的话，我们稍后会看到它。</font></font></p><p>So it’s the other direction which is harder. Right? So it’s harder
            conceptually, because multiple morphism expressions can correspond to
            the same wiring diagram. So this is something you’ll see a concrete
            example of this later, but this is basically… But you want to think here
            of like the interchange law. Right? So, but we’ll see it later if you’re
            not familiar with that.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，Catlab 有一些算法可以实现这一点。它们在某种程度上受到了文献中关于串联平行有向图的启发。所以这可能有点不公平，但我认为串联平行有向图有点像单子范畴，但更糟。</font></font></p><p>And so, Catlab has some algorithms for doing this. They’re sort of
            inspired by what exists in the literature for series parallel digraphs.
            So this is maybe a little unfair, but I think of series parallel
            digraphs as being kind of like monoidal categories, but like worse.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里需要注意的是，我实际上并不真正了解该算法的所有数学属性。所以，我想说的一点是，通常当你开始思考如何将数学知识真正地在计算机上具体化时，你也会遇到新的数学问题。对吧？所以这是一个例子，你最终会遇到一个有趣的算法问题，而你可能不会想到这个问题。</font></font></p><p>And one caveat here is that like I don’t actually really understand
            all the mathematical properties of this algorithm. So this is, you know,
            one of the points that I’d like to make is that, you know, often when
            you start thinking about how do I take math and really make it concrete
            on a computer, you do actually encounter new mathematical problems as
            well. Right? So this is an example where you actually end up with an
            interesting sort of algorithmic question that you might not otherwise
            think about.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。也许我的意思是，重写有这样一种观点，就像你有点上升到更高的层次。对吧？所以，如果你重写态射，它们就像两个单元。这就是你想要的吗？或者我的意思是，我认为你可以这样想。就像一切都很弱，所以你就像一把高高的斧头。是的，是的。我并不完全了解这种观点的含义，但我认为它可能是一种有效的观点。也许值得思考。是的，是的，好的。是的。</font></font></p><p>Yeah. Maybe I mean, there is this perspective on rewriting where like
            you kind of shifted up to one level higher. Right? So like, if you’re
            rewriting morphisms, those are like two cells. Is that what you’re
            getting at? Or I mean, I think you, I think you can think of it that
            way. Is like it’s like where like everything is like weak, and so you’re
            like an axe higher. Yeah, yeah. I don’t know entirely what are the
            implications of that perspective, but yeah, I think it is probably a
            valid perspective. It might be worth thinking about. Yeah, yeah, okay.
            Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以这是一件值得稍后再讨论的事情。是的。为了让这一点更具体一点，我们将探讨往返时会发生什么。</font></font></p><p>So that’s a good thing to talk about more later. Yeah. So, to make
            this a little more concrete, so we’re going to explore what happens when
            you roundtrip.</p>
        <h2 id="roundtripping-between-representations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">表示之间的往返</font></font></h2><h2>Roundtripping Between
            Representations</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">你从一个表达式开始，将它转换为接线图，然后再将其转换回表达式。所以，实际上，我们只需调用两个接线图，然后在结果上，我们将调用两个家庭专家或两个态射表达式。我们确实需要告诉它我们想要使用什么符号系统。所以，我们将在这里使用笛卡尔单子范畴。</font></font></p><p>You start with an expression, convert it to a wiring diagram, and
            then convert it back to an expression. So, really, we just call two
            wiring diagrams, and then on the result, we’re going to call two home
            expert or two morphism expressions. And we do need to tell it what
            symbolic system we want to work with. So, we’re going to be working in
            here with a Cartesian monoidal category.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我在第一个块中创建了一个表达式，其中是产品的组合。如果我往返一次，我就会得到结果，实际上，交换定律最终会应用于此过程。此算法具有或它认为具有的属性之一是，它基本上倾向于尝试提供最大程度的并行分解。对吗？因此，它更喜欢这种形式而不是这种形式。</font></font></p><p>So, here I’m creating an expression in the first block, where this is
            a composition of products. And if I round trip that, I get back, in
            effect, the interchange law ends up being applied by this process. And
            one of the properties that this algorithm has, or which it believes it
            has, is that it prefers, basically, it tries to, like, give a maximally
            parallel decomposition. Right? So, like, it favors this form over this
            one.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果我把这个表达式再重复一遍，我得到的还是同样的结果。所以，在我看来，这在某种程度上是将其标准化了。但事实真是如此吗？它真的总是有效吗？是的，我不知道。好吧。</font></font></p><p>And if I were to take this expression and round trip it again, I just
            get back the same thing. So, somehow it seems to me to be normalizing
            that. But is it really? Does it really always work? Yeah, I don’t know.
            Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，你能从中看到的另一件事是，有时被称为......</font></font></p><p>So, another thing that you kind of can see coming out of this are,
            are what are sometimes called, like, the…</p>
        <h2 id="algorithms-for-roundtripping"><font style="vertical-align:inherit"><font style="vertical-align:inherit">往返算法</font></font></h2><h2>Algorithms for Roundtripping</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，是的。我还没有描述过，但基本上，简而言之，它是基于所谓的串联和并联归约。所以，你基本上会寻找可以执行的实例——如果你有串联的东西，它会将它们折叠成一个组合。同样，在并行中，它也会这样做。对于何时应用它们，有一定的规则。不过，还有一些微妙之处。你有时还必须做这种称为传递归约的事情，比如当你有身份时。所以，它有几个部分，这是一个很复杂的事情，我并没有在这里完整地描述它。是的。</font></font></p><p>Yes, yeah. So, I haven’t described it, but basically, what it does in
            a nutshell is it’s based on things called, like, series and parallel
            reductions. So, you basically look for instances where you can do—if you
            have things in series, it will collapse those into a composition. And
            likewise, in parallel, it will do that. And there are certain rules for
            when it will apply them. And then there are subtleties though. You
            sometimes also have to do this thing called transitive reduction, like
            when you have identities floating around. So, there are several pieces
            to it, and it’s kind of a complicated thing, and I’m not really
            describing it here in its entirety. Yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">但是，什么才是最好的？这是什么？这是最好的算法吗？我不知道。我的意思是，我认为很多这些问题，就像人们一样，你知道，这是一个开放性问题，可以更好地理解这些事情。我不知道有多少文献直接讨论了这个问题。所以，对。</font></font></p><p>But, like, what is the best? What is this though? Is this the best
            algorithm to do so? I don’t know. I mean, like, I think a lot of these
            questions, like people, you know, it’s like an open question to
            understand these things better. I don’t know much literature that
            addresses it directly. So, right.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们在这里可以看到的另一件事是——如果您不熟悉 como noids 的组合供应等，这部分可能不太清楚。但对于那些熟悉的人来说，如果您有……所以，这是一个复制操作。因此，您会发现我可以复制一个类型为 a 乘以 b 的乘积，得到类型为 a 乘以 b 乘以 b 的东西。当您往返时，您会恢复一个不同表示的版本。而这个过程会自动完成。因此，这两个表达式的质量是相等的。</font></font></p><p>So, another thing we can see here is that—so, if you’re not familiar
            with, like, combinatoric supplies of como noids and stuff, this part may
            be not clear. But for those who are, if you have, like… So, this is a
            copying operation. So, you find I can take a copy of something that’s a
            product of type a times b and get something of type a times b times b.
            And when you round trip that, you recover a version of a different
            representation for that. And that sort of falls out automatically for
            this process. And so, the quality of these two, these two expressions
            are equal.</p>
        <h2 id="formalism-and-generalized-algebraic-theories"><font style="vertical-align:inherit"><font style="vertical-align:inherit">形式主义和广义代数理论</font></font></h2><h2>Formalism and
            Generalized Algebraic Theories</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是 Brendan 和 David 所说的胶体供应的连贯性公理之一。你同样可以恢复另一个以进行删除。好的，好的。那么，让我看看我是否按时完成了。好的。我想……</font></font></p><p>That’s one of the coherence axioms for what Brendan and David have
            called a supply of colloids. You likewise recover the other one for
            deleting. Okay, okay. So, let me see how I’m doing on time. Okay. I
            would like to…</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">Catlab 中有很多不同的工具可用于绘制图片。你知道，每个人都喜欢图片。你希望能够生成图片。出于时间考虑，我不会解释这一切是如何运作的，但简而言之，你可以采取两种不同的途径。一种是考虑这种同态。我刚刚概述的获取接线图并为其创建符号表达式的过程可以看作是图形布局算法的第一步。</font></font></p><p>So, there are a lot of different facilities in Catlab for drawing
            pictures. You know, everyone likes pictures. You want to be able to
            generate them. I’m not going to, in the interest of time, I’m not going
            to explain how it all works, but in a nutshell, there are like two
            different kinds of pathways you can take. So, one is to think of this
            morphism. So, this process I just sketched of taking a wiring diagram
            and creating a symbolic expression for it can be seen as doing like the
            first step of a graph layout algorithm.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，您可以采用该表达式来生成布局。这是您可以尝试获取布局的一种方法。然后我们为此提供了一些不同的后端，例如，一个后端生成棒状图，另一个后端使用一种称为 Kaposi al 的东西生成 SVG，这是 Julia 的东西。还有一种完全不同的方法，即只采用接线图并将其传输到知道如何进行有向无环图 (DAG) 布局的其他工具。</font></font></p><p>So, you can take that and actually use that expression to produce a
            layout. So, that’s one way you can try to get layouts. And then we have
            some different backends for that, like one generates stick diagrams,
            another generates SVG using this thing called Kaposi al, which is a
            Julia thing. And there’s a totally different route you can take, which
            is to just take the wiring diagram and pipe it to some other tool which
            knows how to do layout of directed acyclic graphs (DAGs).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们支持... 图形是... 因此，这里有一些... 您可以切换许多不同的设置。因此，这里有一些东西。图形是... 以及 Compose.jl 和 TikZ。因此，我想我真正要说的是，即使您主要是一名数学家，并且对计算之类的东西不太感兴趣，您仍然可能会从绘制一些图片中受益，因为每个人都需要图片。因此，这些功能是存在的，并且它们正在不断改进。好的。让我们开始吧...</font></font></p><p>So, we have support for… graph is… So, here are some… there are lots
            of different, you know, settings you can toggle. So, here are some
            things. Graph is… and in Compose.jl and TikZ. So, I guess all I really
            say about this is that, you know, even if you’re a mathematician
            primarily and you’re not really too interested in like computational
            stuff, you might still benefit from drawing some pictures because
            everyone needs pictures. And so those capabilities are there, and
            they’re continually being improved. Okay. Let’s get this…</p>
        <h2 id="code-representation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">代码表示</font></font></h2><h2>Code Representation</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，我将稍微谈谈我提到的第三种态射表示的第三部分，即某种代码表示，对吧？Catlab 目前具有在 Julia 编程语言的某些片段与其他类型的态射表示之间进行转换的功能。但在我展示这一点之前，我们基本上可以方便地……我们将在这里介绍一个小类别。再次重申，这有一种宏，可以提供一些语法糖。所以，基本上，我只是……我将在这里使用某种数学函数，因为我最终想要生成 Julia 代码。所以我会有一些对象 R，它只表示实数、正弦、余弦、加法和乘法。</font></font></p><p>Okay, so I’m going to talk a little bit about the third part of the
            third representation for morphisms that I mentioned, which is some kind
            of code representation, right? So, Catlab currently has facilities to
            transform between certain fragments of the Julia programming language to
            and from other kinds of morphism representations. So, but before I show
            that, it will be convenient for us to basically… we’re going to present
            a little category here. So, again, there’s kind of a macro for this that
            provides some syntactic sugar. So, basically, I just… I’m going to kind
            of work with sort of kind of, you know, math functions here because I
            want to eventually generate Julia code. So, I’ll have some object R,
            which just represents the real numbers, and sine, and cosine, and
            addition, and multiplication.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的，然后我将编写一个小辅助函数来按名称获取这些生成器。我将首先创建……因此，在第一个块中，我将通过组合和张量等方式创建一个表达式。直接识别公式并不简单。是否可以使用程序的子模块将其编译成 Julia 函数？它生成显示输入 x 的代码，计算其正弦和余弦，将它们相乘，然后返回结果。所以，这只是计算函数 sin( </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ) × cos( </font></font><em><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></em><font style="vertical-align:inherit"><font style="vertical-align:inherit"> )。</font></font></p><p>Okay, and then I’ll write a little helper function to get those
            generators by name. And I’ll first create… and so in this first block,
            I’m creating an expression by, you know, composing and tensoring and all
            that stuff. It’s not straightforward to identify the formula directly.
            Is it possible to use the program’s submodule to compile this into a
            Julia function? It generates code that shows the input x, computes its
            sine and cosine, multiplies them together, and returns the result. So,
            this is just computing the function sin(<em>x</em>) ×
            cos(<em>x</em>).</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是一个方向，你也可以朝另一个方向走，只是我发现实际上转到这里的接线图更方便。所以，有一个工具可以采用 Julia 代码（不是任何旧的 Julia 代码，而是它的一些片段）并为其生成接线图。所以，这里我展示了相同的函数。我将从一些计算该函数的 Julia 代码转到这个图。有很多方法可以用 Julia 编写相同的函数。</font></font></p><p>So, that’s one direction, and you can also go in the other direction,
            except I found it more convenient to go actually to wiring diagrams
            here. So, there’s a facility to take Julia code—not any old Julia code,
            but some fragment of it—and to generate wiring diagrams for that. So,
            here I’m showing the same function. I’m going from some Julia code that
            computes that onto this, to this diagram. And there are lots of ways you
            could write the same function in Julia.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这是另一个更像 lambda 风格的语法，它自然会给你返回相同的图表。这就是我们在这个等式中检查的内容。是的，是的，是的。是的，是的。所以，有一件很酷的事情是，对于一个有循环的 Julia 程序，比如在类别 3 中，它通常由轨迹表示，比如绘制反馈循环的能力。所以，弄清楚如何将这些东西映射在一起会很酷，但我还没有这样做。所以，现在，这些程序，它们没有控制流，但这绝对是一件值得考虑的好事情。是的。好的。</font></font></p><p>So, here’s another one in sort of a more lambda style syntax, and in
            that naturally gives you the same diagram back. That’s what we’re
            checking here in this equality. Yes, yeah, yeah, yeah. It’s, it’s, it’s
            both. So, like one thing that would be cool is like for a Julia program
            with looping, like in Category 3, that’s often represented by like
            traces, like the ability to draw a feedback loop. So, it would be cool
            to figure out how to map those things together, but I haven’t done that
            yet. So, right now, like these programs, like they don’t have control
            flow, but that’s definitely a good thing to think of. Yeah. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，现在我想提一下，我想概述一下我和其他一些人使用 Catlab 完成的几个应用程序，只是为了让您了解它是如何使用的。</font></font></p><p>So, now I want to mention, I want to sketch a few applications that
            I, and also some other people, have done with Catlab, just to give you a
            flavor of how it’s been used.</p>
        <h2 id="applications-data-science"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用：数据科学</font></font></h2><h2>Applications: Data Science</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我无法公正地介绍这些内容，因为每个内容我只有一张幻灯片，但还是希望大家能有所领会。这是我在 IBM 研究部时开始的一个项目，后来我在斯坦福大学继续进行了一些工作。这个项目的想法是尝试获取数据科学代码（即进行数据分析或机器学习的代码），并提取其语义表示，这与所使用的底层语言和库无关。</font></font></p><p>And I won’t be able to do any of these justice because I just have a
            sort of one slide for each of them, but still, people hopefully give you
            some flavor. So, this is a project that I started when I was at IBM
            Research, and then I’ve continued some while at Stanford. The idea of
            this project was to try to take code for data science—so code doing data
            analysis or machine learning—and extract a semantic representation of
            that, which is independent of the underlying languages and libraries
            used.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我一直在探索一种基于本体论的方法。这里使用 Catlab 进行处理，但不必深入细节，它基本上是用来做程序分析的，它是一种语言特定的程序分析，与 Catlab 没有太大关系，它生成程序的数据流图表示。但是，你知道，我使用 Catlab 来处理这个东西，基本上就是对这些接线图进行转换。</font></font></p><p>So, there’s sort of a, there’s an ontology based approach to this
            that I’ve sort of been exploring. And the way, without getting into the
            details though, Catlab is used here to basically do the, you know,
            there’s a program analysis piece, which is sort of language specific,
            doesn’t have much to do with Catlab, that produces like a data flow
            graph representation of our program. But then, you know, I use Catlab to
            do the processing on this thing to do basically transformations on these
            wiring diagrams.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，这里没有什么太复杂的，只是使用接线图作为数据结构的一个示例。是的，这是一个非常有用的数据结构。基本上，我正在做一个单半群函子。对吧？所以，就像我有一些本体论，它说，“哦，R 中的这个函数扩展为这个程序和一些抽象的语义语言。”然后我基本上……所以它在概念上相当简单。就像，我只是用一个窗口敲击这个东西，它会函子并扩展其中一些框。</font></font></p><p>So, nothing too complex there, but just an example of using wiring
            diagrams as a data structure. A very useful data structure, yes.
            Basically, I’m doing a monoidal functor. Right? So, like, I have some
            ontology which says, like, “oh, this function in R expands to like this
            program and some abstract semantic language.” And then I basically… so
            it’s conceptually pretty straightforward. Like, I’m just kind of hitting
            this thing with a window, it’ll functor and expanding some of these
            boxes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个简单的例子，它并没有很好地展现出来，因为这些扩展都不太复杂。但这就是我的想法。是的。好吧，这个想法……这里的想法是……是的，我想我没有很好地解释动机。所以，但这里的想法是能够，比如，现在在数据科学中，语言、库和技术的真正激增。所以，这个项目背后的想法是尝试某种方法来创建语义表示，这将允许您在相同基础上比较使用不同工具进行的分析。至少这是动机的一部分。是的，是的。好的。</font></font></p><p>So, this is a simple example that doesn’t bring it out super well,
            because none of these expansions are too involved. But that’s kind of
            the idea. Yeah. Well, the idea… the idea here is that… yeah, I guess I
            didn’t explain the motivation too well. So, but the idea here is to be
            able to, like, so right now in data science, like, there’s a real
            proliferation of languages and libraries and technologies. So, the idea
            behind this project was to try to have some method for creating semantic
            representations, which would allow you to compare analyses conducted
            using different tools on the same footing. That’s part of the
            motivation, at least. Yeah, yeah. Okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，这是我与 Jade Master、Shaheen Use Fee 和 Archimedes Canítö 一起在西门子参与的另一个短期项目。</font></font></p><p>So, another short project that I was involved in, along with Jade
            Master, Shaheen Use Fee, and Archimedes Canítö, at Siemens.</p>
        <h2 id="applications-planning-problems"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用：规划问题</font></font></h2><h2>Applications: Planning
            Problems</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们做了……我的意思是，这在某种程度上有点像泰国项目，但它是一个概念验证。所以，我们基本上是在用弦图来研究规划问题。所以我们在工作，作为一种更现实的机器人组装领域的代理。我们正在使用乐高组装，我们在 Minecraft 中对其进行模拟。所以，我们会综合这些我们表示为接线图的计划，并有一种管道，我们可以从模型连通性的描述到计划，到不同类型的计划，到时间表的生成，最终到一些工人在 Minecraft 中组装这个东西。所以，当然是原型。但我认为，实际上，规划，就像，一般来说，是一个非常适合应用范畴论工作的领域。最近还有一些其他关于这方面的工作，我敢打赌还会有更多。</font></font></p><p>We did… I mean, it’s kind of a Thai project in a way, but it’s a
            proof of concept. So, we basically were playing around with planning
            problems using string diagrams. So, we were working in the, as sort of a
            proxy for a more realistic, you know, robot assembly domain. We were
            working with LEGO assembly, and we were sort of simulating it in
            Minecraft. So, we would synthesize these plans that we represented as
            wiring diagrams, and had a kind of a pipeline that we could do to go
            from some description of the connectivity of the model to a plan, to
            different kinds of plans, to the generation of a schedule, and
            ultimately to, like, the assembly of this thing in Minecraft by some
            number of workers. So, prototype for sure. But I think that actually,
            like, planning in, like, is in general, like, an area that’s like very
            ripe for applied category theory work. And there’s been some other works
            on this recently, and I bet there’ll be more.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后，我要提一下我没有参与的一个项目。所以我只能大致描述一下。</font></font></p><p>And lastly, I’ll mention a project I’m not involved in with this one.
            So, I can only sort of sketch it.</p>
        <h2 id="applications-model-transformation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应用：模型转换</font></font></h2><h2>Applications: Model
            Transformation</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">该项目由 GTRI 的 James Fairbanks 领导，实际上，我相信他会在某个时候来拜访你们。所以，我想这只是一个很小的预览。这个小组对语义表示感兴趣，特别是对各种科学模型的模型转换。对吧？所以，这个想法是，如果我能有一个好的科学模型的计算表示，我就可以自动化或至少记录你可以对模型进行的各种转换以获得新的转换。我认为，到目前为止，他们一直专注于流行病学模型，例如易感感染康复模型，既有基于代理的形式，也有 ODE。他们有一个 Julia 包，名为 SemanticModels.jl，我知道他们在后台使用 Catlab 来做一些事情，尽管我不知道细节。所以，你可以期待那次谈话，好的。</font></font></p><p>This project is being led by James Fairbanks, who’s at GTRI, and
            actually, I believe he’s due to come visit you guys at some point. So, I
            guess consider this a very small preview of that. This group is
            interested in basically semantic representation, and particularly like
            model transformation for all sorts of kinds of scientific models. Right?
            So, the idea is that, like, if I could have a good, you know,
            computational representation of a scientific model, I could, you know,
            sort of automate or at least, like, record different kinds of
            transformations you can do to models to get new ones. They’ve been
            focusing, I think, so far a lot on epidemiological models, such as
            susceptible infected recovered models, both in agent based form and
            ODEs. They have a Julia package for this called SemanticModels.jl, and I
            know that they’re using Catlab under the hood for some stuff, although I
            don’t know the details. So, you can look forward to that talk, okay.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，总结一下，我只想说一下我希望看到这个项目走向何处。</font></font></p><p>So, to wrap up here, I just want to mention I’m sort of where I’d
            like to see this project go.</p>
        <h2 id="future-directions-and-conclusion"><font style="vertical-align:inherit"><font style="vertical-align:inherit">未来方向和结论</font></font></h2><h2>Future Directions and
            Conclusion</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，还有很多不同的东西需要探索。我的意思是，就我现在所看到的情况而言，现有的功能就像是一种合理的基础。你已经可以做一些有用的事情，但还有很多你想要的功能还不存在，人们需要为此做数学、算法和实施工作。</font></font></p><p>So, and there’s a whole lot of different things to explore. I mean,
            the way I see it right now, like the functionality that exists, like
            it’s a kind of a, I think it’s a reasonable foundation. You can already
            do some useful stuff, but there’s a whole lot of capabilities that you
            would like to have that don’t yet exist, and for which people need to do
            mathematical, algorithmic, and also implementation work.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，一个是计算领域，比如计算机代数功能。所以，这里有很多东西你可能想要拥有。所以，能够重写符号表达式和接线图，有点像经典的计算机代数，但不知何故它不是——当你涉及到类别时，它就是一种扭曲，因为这些结构更复杂。能够做诸如解决文字问题之类的事情显然非常好，但也不容易。</font></font></p><p>So, one is sort of in the area of compute, like the kind of computer
            algebraic functionality. So, there’s a lot of stuff here you might want
            to have. So, the ability to do rewriting on both symbolic expressions
            and wiring diagrams, so kind of like classic computer algebra stuff, but
            somehow it’s not—it’s all it’s kind of a twist when you have categories
            involved because these structures are more complicated. Being able to do
            things like solve word problems is obviously really nice to have, also
            not easy.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我还想进一步探索，比如，像我之前提到的那样，什么样的形式才是正确的，还是其他什么？所以，这是一个领域。</font></font></p><p>I’d also like to explore more like what are the right sort of
            formalisms for this, like I mentioned earlier, like as it gets, or is it
            something else? So, that’s one area.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一件我非常喜欢做的事情，也是让其他人参与进来的事情，比如，我们是否可以创建一个标准库，包含一些范畴论的优秀应用？所以，人们可能已经做了一些数学运算，但我们能否真正使它变得有效并成为一种工具？</font></font></p><p>Another thing that I really like to do and have other people involved
            with this, like can we kind of create a standard library, if you will,
            of some of some nice applications of category theory? So, things where
            people have maybe already done some of the math, but like can we really
            make it effective and into a tool?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我要提到的第一个是线性代数。因此，根据您查看的节点积，您会得到两种不同的东西。例如，对于直接和，有这种图形线性代数，这非常酷，然后还涉及张量积，很多关于张量网络的东西。</font></font></p><p>So, the first one I’ll mention is linear algebra. So, there’s kind of
            two different things which you get depending on kind of which nodal
            product do you look at. So, like for the direct sum, there’s this
            graphical linear algebra, which is very cool, and then there’s also
            involving the tensor product, a lot of stuff about like tensor
            networks.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我想，而且我认为这是 Julia 真正大放异彩的领域——Julia 在数值线性代数方面拥有出色的能力。所以，我希望在明年的某个时候，我们能在这个领域推出一些东西来展示你的能力。然后，还有许多其他领域你可能想做点什么。我在这里只提到了其中的几个，但我的意思是，这有点超出了。</font></font></p><p>So, I would like to, and I think this is an area where Julia would
            really shine—Julia has excellent facilities for numerical linear
            algebra. So, I’m hoping that sometime in during the next year we’ll have
            something in this area kind of to showcase what you can do. And then
            there are many other areas that you might want to do things in. I’ve
            mentioned just a few of them here, but so I mean this, so kind of, you
            know, beyond.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我认为这也是由人们的兴趣所驱动的。好的，我以此结束。最后，我只想说，我肯定在寻找对使用 Catlab 感兴趣的人以及可能对开发它感兴趣的人。我很乐意以任何方式支持这一点，比如通过帮助人们或审查代码等等。所以，如果你对此感兴趣，一定要来找我谈谈。你可以在 GitHub 上这样做，或者我们现在在 Julia Slack 上有一个小型 Slack 频道。如果一切都失败了，你当然也可以给我发电子邮件。</font></font></p><p>So, I think this is also driven by what people are interested in.
            Okay, I’ll conclude with that. I just want to say here at the end that
            I’m definitely looking for people who are interested in using Catlab as
            well as people who might be interested in developing it. I’m happy to
            support that in any way that I can, like through helping people or
            reviewing code, and so forth. So, if that’s something that interests you
            at all, definitely come talk to me. You can do that on GitHub, or we now
            have a little Slack channel on the Julia Slack. And if all else fails,
            definitely you can also send me an email.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">非常感谢大家的关注。我很乐意回答任何问题。</font></font></p><p>Thanks a lot, everyone, for your attention. I’m happy to take any
            questions.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，有盒子和零件，我只是......是的，这个......是的，这对我和其他人来说一直是个问题。</font></font></p><p>Yeah, with boxes and parts, and I just… yeah, this… yeah, this has
            been a problem for me and other people for a long time.</p>
        <h2 id="discussion-and-open-questions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">讨论和未决问题</font></font></h2><h2>Discussion and Open
            Questions</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我不知道答案是什么，但这个问题总是会出现。比如，你经常会问他们，“那么，当你有两个单半群乘积结构时会发生什么？”这种情况总是会发生，我不知道一个好的答案。我不知道……我认为总的来说，这对人们来说是一件非常实际的事情，那就是弄清楚什么是处理这类情况的好方法。</font></font></p><p>I don’t know what the answer is, but it comes up all the time. Like,
            you often, often, one is like… and, and, or, like, you know, product,
            and someone’s asking them, like, “So, what happens when you have like
            two monoidal product structures floating around in it?” It happens all
            the time, and I don’t know of a good answer. And I don’t… it’s like I
            think in general, like that would be a very practical thing for people
            to try to figure out, is what’s a good way to handle those kinds of
            situations.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，就像如果你从接线图转到表达式再转到接线图，你应该总是得到相同的东西。所以，这不是……它不应该很有趣。是的，是的。唯一可能不是这种情况的是，顶点标签可能被切换了，但直到正确的平等概念，也就是同构，它们应该是相同的。是的，是的。哦，对于端口？是的，是的，是的。</font></font></p><p>Yeah, like if you go from wiring diagram to expression to wiring
            diagram, you should always get the same thing. So, it’s not… it
            shouldn’t be interesting. Yeah, yeah. The only thing that might not be
            the case is that like the vertex labels might have gotten switched, but
            up to like the right notion of equality, which is really isomorphism,
            they should be the same. Yeah, yeah. Oh, for like the ports? Yeah, yeah,
            yeah.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，现在我只使用索引。我今天早些时候确实和 David 谈过这个问题。我的意思是，有时有名字会很方便。所以，我认为最终支持两者会很好，但现在它只是端口的数字索引。话虽如此，您可以将额外的数据附加到端口，就像您可以将其放入其中一样，但它并不是那种一流的支持，可以这么说。</font></font></p><p>So, right now, I just use indices. I was actually talking to David
            about this earlier today. I mean, sometimes it’s convenient to have
            names. So, I think eventually it’d be nice to support both, but right
            now it’s just numerical indexing for the ports. Now, that being said,
            you can attach like extra data to the ports, like you could put it in
            there, but it’s not like kind of first class support for that, let’s
            say.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的。所以，你会注意到，对于代码生成，没有可用于组成变量名的信息。对吗？真的，我的意思是，如果你给端口贴上标签，你至少可以……你可以想出更好的变量名。是的，是的。我的意思是，你可以在这里使用任何变量名；它不会影响定义的函数，也不会影响它在另一端的解析方式。基本上，接线图和符号表达式都是无点的、无害的，所以没有变量。</font></font></p><p>Yeah. So, you’ll notice that for like code generation, there’s no
            information that you can use to make up variable names. Right? Really, I
            mean, like if you had the ports given some label, you could at least…
            you could come up with better variable names. Yeah, yeah. I mean, you
            could use any variable names here; it would not affect the function
            that’s defined, nor would it affect how it gets parsed on the other
            side. It’s basically the both the wiring diagrams and the symbolic
            expressions are both point free, innocent, so there are no
            variables.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">当你脱离这种表示时，所有变量都会消失。目前还不是，但实际上，这也是一种你希望能够写下来的公理。</font></font></p><p>All variables disappear when you move away from that representation.
            Not, not yet, but like that’s the sort of axiom that you’d also want to
            be able to like write down, actually.</p>
        <h2 id="additional-discussion-points"><font style="vertical-align:inherit"><font style="vertical-align:inherit">其他讨论要点</font></font></h2><h2>Additional Discussion Points</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">实际上，你可以在演示文稿中写下它允许你这样做，但现在你实际上什么都没做。它并没有真正帮助你做到这一点，所以，是的，这是一个领域，是的，如果有一些阅读材料会很好，但是，另一方面，我不想重新实施，弄清楚如何解决这个问题。是的，我不知道，因为你真的可以花很多年的时间做这些事情。是的，是的，是的，是的。这肯定是一件好事。是的，是的。抱歉，说得太快了。有没有特别的？</font></font></p><p>You, you can, okay, actually, in a presentation, you can write that
            it’ll let you, but right now you didn’t really do anything. It doesn’t
            really help you to do it, so, but yeah, that’s an area where it’s like,
            yeah, it’d be nice to have some read writing, but, but you know, on the
            other hand, I don’t want to like re implement to figuring out like what,
            how to break down that problem. Is, yeah, I don’t know, because you
            could really spend years and years just doing that stuff. Yeah, yeah,
            yeah, yeah. That would definitely be a nice thing to have, for sure.
            Yeah, yeah. Sorry, that was pretty fast. Is there is there one in
            particular?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，这是我最不了解的，但我可以尝试一下。我可以，是的，好的。所以，也许是这两个中的一个。我参与了这两个，所以我可能可以更好地解释。</font></font></p><p>Yeah, well, that’s the one I know least about, but I got, I can try.
            I could, yeah, okay. So, maybe one of these two. I was involved in these
            two, so I can probably explain things better.</p>
        <h2 id="planning-application-details"><font style="vertical-align:inherit"><font style="vertical-align:inherit">规划申请详情</font></font></h2><h2>Planning Application Details</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是规划吗？是的，好的。所以，对于规划，是的。所以，Catlab 的内容以几种不同的方式出现。所以，目前它里面没有任何东西可以真正形成这些接线图的计划，比如它提供数据结构和其他东西，但这些算法并没有内置在 Catlab 中，而这正是我希望看到你在那里有更多、一些成长的地方，因为你知道，我认为这些看起来不像规划的东西也可以被制定为规划，对吧？</font></font></p><p>Is the planning one? Yeah, okay. So, for the planning one, yeah. So,
            this the Catlab stuff comes in in a couple different ways. So, there’s
            nothing directly in it right now that actually forms these plans for
            wiring diagrams, like it provides the data structures and stuff, but
            those algorithms are not built into Catlab, and and that’s something
            where I’d actually like to see you like some more, some growth there,
            because you know, I think that these lots of things that don’t look like
            planning can also be kind of formulated as planning, right?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">就像，我有这种类型，我想从这里获取它，我可以执行一些操作，那么我该如何将它们组合在一起来实现呢？就像，这是一个相当通用的计算问题，如果能获得更多的东西就好了。但是，至少，现在我们正在使用 Catlab 来表示这些计划，然后我们实际上也，这部分有点有趣，我们还使用该功能将接线图转换为表达式作为调度部分的一部分。</font></font></p><p>Like, it’s like I have this type, and I want to get to it from here,
            and I have some operations I can do, and so how do I put them together
            to do that? Like, that’s a fairly generic computational problem that it
            would be nice to get more stuff for. But, at the very least, right now
            we’re using Catlab to represent these plans, and then we also are
            actually, this part’s a little interesting, we’re also using the
            functionality to go from wiring diagrams to expressions as part of the
            scheduling part.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，你可以将这种分解视为一个表达式，它告诉你哪些事情我想串联或并行执行，并且它比接线图更细粒度。接线图会告诉你你可以并行执行哪些操作，但不会真正说明你会这样做。因此，我认为这是一个领域，这些不同的态射实际上很有趣，因为它们对态射有不同的表示，因为它们编码了不同类型的更详细的表示，实际上，有时可能没有解释。</font></font></p><p>So, you can think of like this decomposition as a, as an expression
            is telling you like which things do I want to do in series or in
            parallel, and it had in a more fine grained way than what you get in the
            wiring diagram. The wiring diagram kind of tells you like what you could
            do in parallel without really saying like that you will. So, I think
            this is one area where these different morphisms is actually interesting
            to have different representations for morphisms, because they encode
            different kinds of like a more detailed representation, actually, like
            can be hasn’t have an interpretation sometimes.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这正是我想说的。这些都是通过简单的算法生成的。但是，要创建一个实际的时间表（指定所需的工人数量以及他们在每个时间步骤将执行的任务），还需要进一步的过程。这个人会做这件事，这个人会做这件事。”这就是我们实际上首先要使用的表达式，并用它来构建时间表。并行计划为您提供了更多的并行能力，例如，您可以像串行一样执行它。</font></font></p><p>That’s what I’m trying to say, you know. These are generated by a
            simple algorithm. However, to create an actual schedule—one that
            specifies the number of workers needed and the tasks they’ll perform at
            each time step—requires a further process. This person will do this
            thing, and this person will do this thing.” That’s where we’re actually
            first going to, like, expressions and using that to structure the
            schedule. What the parallel plan gives you is more capability for
            parallelism, like, you, you could, like, if you had, you could execute
            it like in serial.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">比如，如果你有一个工作者，你无论如何都会被迫将其序列化。所以，至少在我们解释这些接线图的方式上，这些就像所谓的并行计划具有更多的并行潜力，但我们实际获得的并行程度取决于你拥有哪些资源。但是，是的，可能还有其他方式来考虑这个问题。我的意思是，我会，你知道，是的。所以，你也可以做一个拓扑排序，这会给你一个线性排序，这并不一定会告诉你什么时候该做什么。</font></font></p><p>Like, if you had one worker, you would be forced to basically
            serialize it anyway. So, at least on the way we’re interpreting these
            wiring diagrams, these are like this so called, like, parallel plan has
            more potential for parallelism, but how much parallelism we actually get
            depends on what resources you have available. But yeah, there are
            probably other ways to think about this too. I mean, I’d be, you know,
            yeah. So, you could also do a topological sort, and that would give
            you—well, yeah, I mean, you would, yeah, it would give you a linear
            ordering, which wouldn’t necessarily tell you what to do when.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">它只会告诉你，只要在我做某件事之前，我已经做好了所有需要做的事情。你知道，这些并没有像我想象的那样在哈洛发生。有一种标准算法，比如，分类在哪里……是的，我的意思是，这方面有很多工作要做。所以，我的意思是，对我来说，我不想说，比如，我认为使用接线图来表示这些计划很有用，但我不想声称，比如，调度算法一定比现有的算法更好。</font></font></p><p>It would just tell you that as long as by the time I get to
            something, I’ve done everything else I need to beforehand. You know,
            these didn’t happen in Harlow, like I thought. There’s a sort of
            standard algorithms, like, where does category… Yeah, I mean, there’s a
            lot of work on this stuff. So, I mean, for me, I wouldn’t want to say
            that, like, I think it’s useful to use wiring diagrams to represent
            these plans, but I wouldn’t want to claim that, like, the scheduling
            algorithm is like necessarily that better than what’s out there.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这只是你有点……但它确实脱离了这些东西。是的。从编程角度来说，下一步推断某些参数和数据会是什么？</font></font></p><p>It’s just you kind of… but it does fall out of this stuff. Yeah. What
            would be kind of programmatically the next step to infer certain
            parameters and data?</p>
        <h2 id="further-discussion-on-planning"><font style="vertical-align:inherit"><font style="vertical-align:inherit">进一步讨论规划</font></font></h2><h2>Further Discussion on
            Planning</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">什么？是的，您指的是这种设置吗？是的。好吧，我猜您——这种计划表示和您实际上可以在模拟器中运行的东西之间缺少什么？它对我们来说就像一个离散的世界。在每个时间步骤，您都必须说，如果我有一定数量的工人，那么他们在那个时间步骤实际上在执行什么任务？而这不包括在计划的表示中。</font></font></p><p>What? Yeah, you mean like in this setting here? Yeah. Well, I guess
            what you—what’s missing between the like this representation of a plan
            and like something you could actually run in your simulators? It, like,
            well, mine craps sort of a discrete for us as like a discrete world
            basically. It’s right at every time step, you have to say, like, if I
            have some number of workers, like what tasks are they actually
            performing at that time step? And that’s not included in this
            representation of the plan.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，我们一直在讨论的是，如何将计划转化为时间表？这就是拓扑排序之类的东西开始发挥作用的地方。是的，你是指这项工作，还是亚洲人？好吧，在这个应用中，我认为很自然地将语义丰富过程视为一个函子。</font></font></p><p>And so what we’ve kind of been discussing is like, what are the—how
            can you—how could you get from a plan to a schedule? And so that’s where
            things like a topological sort or the other things start to come in.
            Yeah, you mean in this work here, or like, Asians? Well, in this
            application, I think it’s very natural to think of this like semantic
            enrichment process is just a functor.</p>
        <h2 id="semantic-enrichment-as-a-functor"><font style="vertical-align:inherit"><font style="vertical-align:inherit">语义丰富作为函子</font></font></h2><h2>Semantic Enrichment as a
            Functor</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">所以，我的意思是，你总是可以把某个用范畴论表达的东西编纂成范畴论。而且，而且，而且，如果你愿意的话，我的意思是，你知道，我看到这个观点的价值是什么？它并不总是，比如，范畴论不一定能给你一种没有范畴论就无法做到的能力，但它在说，比如，我希望得到什么？</font></font></p><p>So, I mean, you can always, you know, you can always take something
            expressed categorically and compile away the category theory. And, and,
            and, if you want to, so I mean, it’s, you know, what do I see the value
            of this perspective is being? It’s not always that, like, category
            theory is, it’s not like category theory is necessarily giving you a
            capability that you simply couldn’t do without category theory, but it’s
            saying that, like, like, what would I hope for?</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">比如 CatLab。某些类型的算法和程序在各种不同的领域都有出现，对吧？所以，如果你有一个适用于对称单子类别的通用规划算法，那么除了组装乐高积木之外，你还可以将其用于很多不同的事情，对吧？所以，对我来说，这就是这个视角的价值所在。我认为，有时问这样的问题并不总是正确的，比如“哦，嗯，你知道，类别理论让你做了什么以前做不到的事情？”更像是，它如何帮助你理解这一点并将其与其他事物联系起来？这是我个人的看法。</font></font></p><p>Like, CatLab. It’s like certain kinds of algorithms and procedures
            like occur in all sorts of different areas, right? So, like, if you can
            have a generic planning algorithm that works on symmetric monoidal
            categories, you could pursue, conceivably, use that for lots of
            different things besides, like, assembling Legos, right? So, like, that,
            to me, is like what the value in this perspective is. And I think it’s
            sometimes not always the right question to ask, like, “Oh, well, like,
            you know, what did category theory let you do that you couldn’t do
            before?” It’s more like, how does it help you understand that and
            connect it to other things? That’s my personal take.</p>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">是的，函数是节点，边是数据类型。</font></font></p><p>Yeah, the functions are the nodes, and the edges are the data
            types.</p>
        <h2 id="connecting-to-existing-software"><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接到现有软件</font></font></h2><h2>Connecting to Existing
            Software</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">好的。所以，函子就像是将一个态射（就像接线图）映射到另一个态射。所以，函子的特点是，你基本上可以通过取出每个态射，然后用函子对其进行处理，然后整个……所以，对。所以，我认为，这很有帮助，你知道，你绝对可以重写接线图，而不必考虑函子，但是，一旦你……</font></font></p><p>Okay. So, so the functor is like going, it’ll map, like, a morphism,
            which is like a wiring diagram, to another one. And so, and it’s, in
            what’s functorial about it is that, like, you get this thing basically
            by taking each of these and then hitting it with the functor and then
            that whole… So, right. So, the… and so it’s, I think, helpful to, you
            know, you can definitely rewrite the wiring diagrams without thinking
            about functors, but like, once you…</p>
        <h2 id="additional-discussion-points-1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">其他讨论要点</font></font></h2><h2>Additional Discussion
            Points</h2>
        <p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我认为这样思考会很有帮助，因为一旦你知道了这些词汇，你基本上可以用一句话说出它在做什么，人们就能理解它是什么。是的。你知道，这不是我熟悉的领域，但我认为我最后提到的这些应用程序的想法的一部分肯定是尝试将它连接到人们为这类东西编写的软件上，对吧？所以我熟悉的一件事是，比如一些色调处理库，对吧？先生，你能通过组合和执行我们可以做的事情，从中取出表示某种色调的态射表达式，然后将其转换为软件吗？我认为，我认为这些事情很酷。</font></font></p><p>it’s kind of, I think, helpful to think about it that way because
            once you know this vocabulary, you can basically say in one sentence
            what it’s doing, and people can understand what it is. Yes. Like, you
            know, it’s that’s not an area that I know well, but I think definitely
            part of the idea with these applications that I was mentioning at the
            end would be to try to connect it, like, to the software that people
            have written for those kinds of things, right? So, one thing I am
            familiar with is, like, some of the, like, tint manipulation libraries,
            right? Can you can you take a morphism expression representing some
            tint, sir, out of by composing and doing the things we can do and then
            translate that into, you know, the software? I think, I think those are
            the kind of things it’s cool to be able to do.</p>

    </div>



<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>