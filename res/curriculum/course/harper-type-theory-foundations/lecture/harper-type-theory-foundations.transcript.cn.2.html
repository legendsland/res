<!DOCTYPE html><html class="translated-ltr" style=""><!--
 Page saved with SingleFile 
 url: file:///home/zy/ws/res/res/curriculum/course/harper-type-theory-foundations/harper-type-theory-foundations.html 
 saved date: Sun Mar 30 2025 15:48:56 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/da9673539aeb71f05062aa813f1a8cb40f48a848">
<meta charset="utf-8"> <style>.VIpgJd-ZVi9od-ORHb-OEVmcd{left:0;top:0;height:39px;width:100%;z-index:10000001;position:fixed;border:none;border-bottom:1px solid #6B90DA;margin:0;box-shadow:0 0 8px 1px #999}.VIpgJd-ZVi9od-xl07Ob-OEVmcd{z-index:10000002;border:none;position:fixed;box-shadow:0 3px 8px 2px #999}.VIpgJd-ZVi9od-SmfZ-OEVmcd{z-index:10000000;border:none;margin:0}.goog-te-gadget{font-family:arial;font-size:11px;color:#666;white-space:nowrap}.goog-te-gadget img{vertical-align:middle;border:none}.goog-te-gadget-simple{background-color:#FFF;border-left:1px solid #D5D5D5;border-top:1px solid #9B9B9B;border-bottom:1px solid #E8E8E8;border-right:1px solid #D5D5D5;font-size:10pt;display:inline-block;padding-top:1px;padding-bottom:2px;cursor:pointer}.goog-te-gadget-icon{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.goog-te-combo{margin-left:4px;margin-right:4px;vertical-align:baseline}.goog-te-gadget .goog-te-combo{margin:4px 0}.VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-l4eHX-hSRGPd:link,.VIpgJd-ZVi9od-l4eHX-hSRGPd:visited,.VIpgJd-ZVi9od-l4eHX-hSRGPd:hover,.VIpgJd-ZVi9od-l4eHX-hSRGPd:active{font-size:12px;font-weight:bold;color:#444;text-decoration:none}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd,.VIpgJd-ZVi9od-TvD9Pc-hSRGPd{display:block;margin:0 10px}.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd{padding-top:2px;padding-left:4px}.goog-te-combo,.VIpgJd-ZVi9od-ORHb *,.VIpgJd-ZVi9od-SmfZ *,.VIpgJd-ZVi9od-xl07Ob *,.VIpgJd-ZVi9od-vH1Gmf *,.VIpgJd-ZVi9od-l9xktf *{font-family:arial;font-size:10pt}.VIpgJd-ZVi9od-ORHb{margin:0;background-color:#E4EFFB;overflow:hidden}.VIpgJd-ZVi9od-ORHb img{border:none}.VIpgJd-ZVi9od-ORHb-bN97Pc{color:#000}.VIpgJd-ZVi9od-ORHb-bN97Pc img{vertical-align:middle}.VIpgJd-ZVi9od-ORHb-Tswv1b{color:#666;vertical-align:top;margin-top:0;font-size:7pt}.VIpgJd-ZVi9od-ORHb-KE6vqe{width:8px}.VIpgJd-ZVi9od-LgbsSe{border-color:#E7E7E7;border-style:none solid solid none;border-width:0 1px 1px 0}.VIpgJd-ZVi9od-LgbsSe div{border-color:#CCC #999 #999 #CCC;border-right:1px solid #999;border-style:solid;border-width:1px;height:20px}.VIpgJd-ZVi9od-LgbsSe button{background:transparent;border:none;cursor:pointer;height:20px;overflow:hidden;margin:0;vertical-align:top;white-space:nowrap}.VIpgJd-ZVi9od-LgbsSe button:active{background:none repeat scroll 0 0#CCC}.VIpgJd-ZVi9od-SmfZ{margin:0;background-color:#FFF;white-space:nowrap}.VIpgJd-ZVi9od-SmfZ-hSRGPd{text-decoration:none;font-weight:bold;font-size:10pt;border:1px outset #888;padding:6px 10px;white-space:nowrap;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-SmfZ-hSRGPd img{margin-left:2px;margin-right:2px;width:19px;height:19px;border:none;vertical-align:middle}.VIpgJd-ZVi9od-SmfZ-hSRGPd span{text-decoration:underline;margin-left:2px;margin-right:2px;vertical-align:middle}.goog-te-float-top .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-top-width:0}.goog-te-float-bottom .VIpgJd-ZVi9od-SmfZ-hSRGPd{padding:2px;border-bottom-width:0}.VIpgJd-ZVi9od-xl07Ob-lTBxed{text-decoration:none;color:#00C;white-space:nowrap;margin-left:4px;margin-right:4px}.VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:underline}.VIpgJd-ZVi9od-xl07Ob-lTBxed img{margin-left:2px;margin-right:2px}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed{color:#000}.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed span{text-decoration:none}.VIpgJd-ZVi9od-xl07Ob{background-color:#FFF;text-decoration:none;border:2px solid #C3D9FF;overflow-y:scroll;overflow-x:hidden;position:absolute;left:0;top:0}.VIpgJd-ZVi9od-xl07Ob-ibnC6b{padding:3px;text-decoration:none}.VIpgJd-ZVi9od-xl07Ob-ibnC6b,.VIpgJd-ZVi9od-xl07Ob-ibnC6b:link{color:#00C;background:#FFF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:visited{color:#551A8B}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:hover{background:#C3D9FF}.VIpgJd-ZVi9od-xl07Ob-ibnC6b:active{color:#00C}.VIpgJd-ZVi9od-vH1Gmf{background-color:#FFF;text-decoration:none;border:1px solid #6B90DA;overflow:hidden;padding:4px}.VIpgJd-ZVi9od-vH1Gmf-KrhPNb{width:16px}.VIpgJd-ZVi9od-vH1Gmf-hgDUwe{margin:6px 0;height:1px;background-color:#aaa;overflow:hidden}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div{padding:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b .uDEFge{display:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .uDEFge{display:auto}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .fmcmS{padding-left:4px;padding-right:4px}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd{text-decoration:none}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:active div{color:#00C;background:#FFF}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:hover div{color:#FFF;background:#36C}.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:link div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:visited div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:hover div,.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:active div{color:#000;font-weight:bold}.VIpgJd-ZVi9od-l9xktf{background-color:#FFF;overflow:hidden;padding:8px;border:none;border-radius:10px}.VIpgJd-ZVi9od-l9xktf-OEVmcd{background-color:#FFF;border:1px solid #6B90DA;box-shadow:0 3px 8px 2px #999;border-radius:8px}.VIpgJd-ZVi9od-l9xktf img{border:none}.VIpgJd-ZVi9od-l9xktf-fmcmS{margin-top:6px}.VIpgJd-ZVi9od-l9xktf-VgwJlc{margin-top:6px;white-space:nowrap}.VIpgJd-ZVi9od-l9xktf-VgwJlc *{vertical-align:middle}.VIpgJd-ZVi9od-l9xktf-VgwJlc .DUGJie{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc .TdyTDe{background-image:url(data:,)}.VIpgJd-ZVi9od-l9xktf-VgwJlc span{color:#00C;text-decoration:underline;cursor:pointer;margin:0 4px}.VIpgJd-ZVi9od-l9xktf-I9GLp{margin:6px 0 0}.VIpgJd-ZVi9od-l9xktf-I9GLp form{margin:0}.VIpgJd-ZVi9od-l9xktf-I9GLp form textarea{margin-bottom:4px;width:100%}.VIpgJd-ZVi9od-l9xktf-yePe5c{margin:6px 0 4px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf{z-index:1000;position:fixed;-webkit-transition-delay:.6s;transition-delay:.6s;left:-1000px;top:-1000px}.VIpgJd-ZVi9od-aZ2wEe-wOHMyf-ti6hGc{-webkit-transition-delay:0s;transition-delay:0s;left:-14px;top:-14px}.VIpgJd-ZVi9od-aZ2wEe-OiiCO{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center;width:104px;height:104px;border-radius:50px;background:#FFF url(data:image/png;base64,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)50% 50%no-repeat;-webkit-transition:all .6s ease-in-out;transition:all .6s ease-in-out;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}.VIpgJd-ZVi9od-aZ2wEe-OiiCO-ti6hGc{-webkit-transform:scale(.5);transform:scale(.5);opacity:1}.VIpgJd-ZVi9od-aZ2wEe{margin:2px 0 0 2px;-webkit-animation:spinner-rotator 1.4s linear infinite;animation:spinner-rotator 1.4s linear infinite}@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}.VIpgJd-ZVi9od-aZ2wEe-Jt5cK{stroke-dasharray:187;stroke-dashoffset:0;stroke:#4285F4;-webkit-transform-origin:center;transform-origin:center;-webkit-animation:spinner-dash 1.4s ease-in-out infinite;animation:spinner-dash 1.4s ease-in-out infinite}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb html,.VIpgJd-yAWNEb-L7lbkb body,.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb h1,.VIpgJd-yAWNEb-L7lbkb h2,.VIpgJd-yAWNEb-L7lbkb h3,.VIpgJd-yAWNEb-L7lbkb h4,.VIpgJd-yAWNEb-L7lbkb h5,.VIpgJd-yAWNEb-L7lbkb h6,.VIpgJd-yAWNEb-L7lbkb p,.VIpgJd-yAWNEb-L7lbkb a,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul,.VIpgJd-yAWNEb-L7lbkb li,.VIpgJd-yAWNEb-L7lbkb table,.VIpgJd-yAWNEb-L7lbkb form,.VIpgJd-yAWNEb-L7lbkb tbody,.VIpgJd-yAWNEb-L7lbkb tr,.VIpgJd-yAWNEb-L7lbkb td{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb ol,.VIpgJd-yAWNEb-L7lbkb ul{list-style:none}.VIpgJd-yAWNEb-L7lbkb table{border-collapse:collapse;border-spacing:0}.VIpgJd-yAWNEb-L7lbkb caption,.VIpgJd-yAWNEb-L7lbkb th,.VIpgJd-yAWNEb-L7lbkb td{text-align:left;font-weight:normal}.VIpgJd-yAWNEb-L7lbkb input::-moz-focus-inner{border:0}div>.VIpgJd-yAWNEb-L7lbkb{padding:10px 14px}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-family:arial;font-size:10pt;width:420px;padding:12px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS,.VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{clear:both;font-size:10pt;position:relative;text-align:justify;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-r4nke{color:#999;font-family:arial,sans-serif;margin:4px 0;text-align:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TvD9Pc-LgbsSe{display:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-l4eHX{float:left;margin:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-PLDbbf{display:inline-block}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf{display:none;width:100%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-H9tDt{margin-top:20px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-LK5yu{float:left}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-qwU8Me{float:right}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-cGMI2b{min-height:15px;position:relative;height:1%}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-jOfkMb-Ne3sFf{background:-webkit-linear-gradient(top,#29910d 0,#20af0e 100%);background:-webkit-gradient(linear,left top,left bottom,from(#29910d),to(#20af0e));background:linear-gradient(top,#29910d 0,#20af0e 100%);background:#29910d;border-radius:4px;-moz-border-radius:4px;-webkit-border-radius:4px;box-shadow:inset 0 2px 2px #1e6609;-moz-box-shadow:inset 0 2px 2px #1e6609;-webkit-box-shadow:inset 0 2px 2px #1e6609;color:white;font-size:9pt;font-weight:bolder;margin-top:12px;padding:6px;text-shadow:1px 1px 1px #1e6609}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-hSRGPd{color:#15c;cursor:pointer;font-family:arial;font-size:11px;margin-right:15px;text-decoration:none}.VIpgJd-yAWNEb-L7lbkb>textarea{font-family:arial;resize:vertical;width:100%;margin-bottom:10px;border-radius:1px;border:1px solid #d9d9d9;border-top:1px solid silver;font-size:13px;height:auto;overflow-y:auto;padding:1px}.VIpgJd-yAWNEb-L7lbkb textarea:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);border:1px solid #4d90fe;outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-IbE0S{margin-right:10px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp{min-height:25px;vertical-align:middle;padding-top:8px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp{margin-bottom:5px;margin-bottom:0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input{display:inline-block;min-width:54px;*min-width:70px;border:1px solid #dcdcdc;border:1px solid rgba(0,0,0,.1);text-align:center;color:#444;font-size:11px;font-weight:bold;height:27px;outline:0;padding:0 8px;vertical-align:middle;line-height:27px;margin:0 16px 0 0;box-shadow:0 1px 2px rgba(0,0,0,.1);-moz-box-shadow:0 1px 2px rgba(0,0,0,.1);-webkit-box-shadow:0 1px 2px rgba(0,0,0,.1);border-radius:2px;-webkit-transition:all .218s;transition:all .218s;background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,from(#f5f5f5),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f5f5f5,#f1f1f1);background-image:linear-gradient(top,#f5f5f5,#f1f1f1);-webkit-user-select:none;-moz-user-select:none;cursor:default}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover{border:1px solid #c6c6c6;color:#222;-webkit-transition:all 0s;transition:all 0s;background-color:#f8f8f8;background-image:-webkit-gradient(linear,left top,left bottom,from(#f8f8f8),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f8f8f8,#f1f1f1);background-image:linear-gradient(top,#f8f8f8,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active{border:1px solid #c6c6c6;color:#333;background-color:#f6f6f6;background-image:-webkit-gradient(linear,left top,left bottom,from(#f6f6f6),to(#f1f1f1));background-image:-webkit-linear-gradient(top,#f6f6f6,#f1f1f1);background-image:linear-gradient(top,#f6f6f6,#f1f1f1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus:active{box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-webkit-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5);-moz-box-shadow:inset 0 0 0 1px rgba(255,255,255,.5)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe{outline:none;border:1px solid #4d90fe;z-index:4!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.gk6SMd{background-color:#eee;background-image:-webkit-gradient(linear,left top,left bottom,from(#eee),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#eee,#e0e0e0);background-image:linear-gradient(top,#eee,#e0e0e0);box-shadow:inset 0 1px 2px rgba(0,0,0,.1);border:1px solid #ccc;color:#333}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf{color:white;border-color:#3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active{border-color:#3079ed;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-webkit-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1);-moz-box-shadow:inset 0 0 0 1px #fff,0 1px 1px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover{border-color:#3079ed}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-mrxPge{color:#999;font-family:arial,sans-serif}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-W0vJo-fmcmS{color:#999;font-size:11px;font-family:arial,sans-serif;margin:15px 0 5px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-u0pjoe-fmcmS{color:#800;display:none;font-size:9pt}.VIpgJd-yAWNEb-VIpgJd-fmcmS-sn54Q{background-color:#c9d7f1;box-shadow:2px 2px 4px #99a;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-xl07Ob{background:#fff;border:1px solid #ddd;box-shadow:0 2px 4px #99a;min-width:0;outline:none;padding:0;position:absolute;z-index:2000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb{cursor:pointer;padding:2px 5px 5px;margin-right:0;border-style:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb:hover{background:#ddd}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb h1{font-size:100%;font-weight:bold;margin:4px 0}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb strong{color:#345aad}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:right;position:absolute;right:0;left:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-j7LFlb-SIsrTd .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo{text-align:left;position:absolute;left:0;right:auto}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-fmcmS,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#f1ea00;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;color:#f1ea00;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 2px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{color:#222}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe{color:white;position:absolute!important}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf,.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q{background-color:#c9d7f1;border-radius:4px 4px 0 0;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;box-shadow:rgba(0,0,0,.5) 3px 3px 4px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;cursor:pointer;margin:-2px -2px -2px -3px;padding:2px 2px 3px 3px;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-DyVDA{background-color:transparent;border:1px solid #4d90fe;border-radius:0;-webkit-border-radius:0;-moz-border-radius:0;margin:-2px;padding:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-LzX3ef{border-left:2px solid red;margin-left:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-YIAiIb{border-right:2px solid red;margin-right:-2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf{padding:2px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS{font-size:11px;padding:2px 2px 3px;margin:0;background-color:#fff;color:#333;border:1px solid #d9d9d9;border-top:1px solid #c0c0c0;display:inline-block;vertical-align:top;height:21px;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-border-radius:1px}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:hover{border:1px solid #b9b9b9;border-top:1px solid #a0a0a0;box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:focus{box-shadow:inset 0 1px 2px rgba(0,0,0,.3);outline:none;border:1px solid #4d90fe}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-sFeBqf{font-size:11px;padding:2px 6px 3px;margin:0 0 0 2px;height:21px}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-SIsrTd{position:absolute;top:10px;right:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c,.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd .VIpgJd-yAWNEb-hvhgNd-IuizWc{text-align:right;margin:0 36px 0 0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-UTujCb{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{text-align:right}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 .VIpgJd-yAWNEb-SIsrTd{left:5px;right:auto}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}sentinel{}</style><meta name="referrer" content="no-referrer"><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>

<body>
    <div id="book-container">

        <h1 id="type-theory-foundations-1.0-robert-harper">类型理论基础 1.0 — Robert Harper</h1><h1>Type Theory
            Foundations 1.0 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 3 日) — 37:14 <a href="https://youtube.com/watch?v=9SnefrwBIDc">https://youtube.com/watch?v=9SnefrwBIDc</a></p><p> 11
            years ago (Jan 3, 2014) — 37:14 <a href="https://youtube.com/watch?v=9SnefrwBIDc">https://youtube.com/watch?v=9SnefrwBIDc</a></p>
        <h2 id="summary">概括</h2><h2>Summary</h2>
        <p>本讲座介绍直觉逻辑，重点介绍作为数学对象的证明。主讲人罗伯特·哈珀概述了连接证明理论、代数和类型理论的框架。他强调了证明作为知识交流的重要性，以及只有存在证明，命题才为真的观点。本讲座将探讨证明相等的概念及其与证明的代数结构的关系，最终将证明与计算机程序联系起来。</p><p>This lecture introduces intuitionistic logic, focusing on proofs as
            mathematical objects. The speaker, Robert Harper, outlines a framework
            connecting proof theory, algebra, and type theory. He emphasizes the
            importance of proofs as communication of knowledge and the idea that a
            proposition is true only if a proof exists. The lecture will explore the
            concept of equality of proofs and how this relates to the algebraic
            structure of proofs, ultimately connecting proofs to computer
            programs.</p>
        <h2 id="introduction-and-overview">简介和概述</h2><h2>Introduction and Overview</h2>
        <p>什么都对吗？现在我知道你的意思了。好的，好的。让我们看看。那么，今天我想开始讲我的第一堂课。从很多方面来说，这将是我脑海中的后续课程的概述和设置，以及弗兰克的课程，这些课程正在我做某事时进行。我希望技术问题消失。我们没问题吗？好的，很好。</p><p>What’s got it all right? And now I know what you mean. Okay, okay.
            Let’s see. So, the thing that I would like to do to start is my first
            lecture today. It is, in many ways, going to be an overview and a setup
            for my own subsequent lectures, which I have in mind, plus Frank’s
            lectures, which are happening as I—not do something—okay. I wish away
            for the technical. Are we okay? Okay, good.</p>
        <p>因此，我将进行概述，为我自己的讲座做准备。本周剩余时间的内容很多。我们还将为 Frank 的讲座做准备，还有 Steve 的讲座——我已经没见过他了——所以他会参加这些讲座。好吧，这一切都会非常快速——这一部分将是对后续内容的快速概述。我们还将让我谈论一个关键问题，这将为我们关于依赖类型的讨论提供参考。所以，这就是我本周的主要主题：谈论依赖类型。也许你们中的一些人对此感兴趣，但我不能假设你们都具备——我认为我不应该假设你们都具备理解依赖类型理论所需的背景知识。</p><p>So, what I’m going to do is give a kind of overview, which will set
            up for my own lecture. It’s a lot for the rest of this week. We’ll also
            set up for Frank’s lectures, and also Steve—already, I haven’t seen him
            here—so he’ll be in these lectures. Well, this will all be kind of a
            really fast—this part of it will be a very fast overview of what’s going
            to come later. And we’ll also put me in a position to talk about a
            critical issue that will inform our discussion of dependent types. So,
            that’s my major theme for the week: talking about dependent types. Which
            perhaps some of you are interested in, but I can’t assume that you all
            have—I don’t think I should assume that you all have the background that
            you need in order to appreciate what’s going on with the theory of
            dependent types.</p>
        <h2 id="intuitionistic-logic-algebraic-and-proof-theoretic-perspectives">直觉逻辑：代数和证明论视角</h2><h2>Intuitionistic
            Logic: Algebraic and Proof-Theoretic Perspectives</h2>
        <p>所以，我想先从速成课程开始，也就是对直觉逻辑这一主题的概述。我将同时从代数和证明理论的角度来探讨这一主题。好的，这就是接下来要讲的内容。</p><p>So, what I want to do is I want to start out with just a bit of a
            crash course, sort of overview, of a topic called intuitionistic logic.
            Which I’m going to broach simultaneously from an algebraic and a proof
            theoretic perspective. Okay, so that’s what’s going to happen.</p>
        <p>所以，我喜欢用直觉逻辑来描述这一点——也许你以前从未听说过这个术语——但我喜欢用半开玩笑的方式，但只是半开玩笑地认为，这是一种逻辑，就好像人很重要一样。</p><p>So, the way I like to describe this is I think of intuitionistic
            logic—maybe you haven’t ever heard that term before—but the way I like
            to, half jokingly, but only half think of it as, is logic as if people
            mattered.</p>
        <h2 id="intuitionistic-logic-and-the-importance-of-proofs">直觉逻辑和证明的重要性</h2><h2>Intuitionistic
            Logic and the Importance of Proofs</h2>
        <p>好的，这就是我对直觉逻辑的看法。我之所以这样介绍它，是因为如果人们很重要，因为它非常关注数学和计算机科学的过程，最终是一个交流的过程。这一切都是关于知识的交流。好的，这就是我们想要的：知识交流。这是基本思想。</p><p>Okay, this is my view about what intuitionistic logic is all about.
            And the reason it’s all about that, and why I present it that way, is if
            people matter, is because it is very much focused on the idea of the
            process of doing math and doing, eventually, doing computer science is a
            process of communication. It’s all about communication of knowledge.
            Okay, this is what we want: communication of knowledge. This is the
            basic idea.</p>
        <p>所以，我的意思是，我们在逻辑中有一个基本概念——我们感兴趣的主要内容是表达 a 是否是一个命题。弗兰克将详细阐述这一点。这意味着 a 是一种合理的断言。让我在这里写上“合理的”。但是，作为一个合理的断言，写下来是有意义的。然后关键的是
            <em>a</em>是真的，这是你在学校学到的东西。
        </p><p>And so, what I mean by this is we have the primitive notion in
            logic—the main thing we’re interested in is expressing whether a is a
            proposition. And Frank is going to go into a lot of this in great
            detail. Which says that a is sort of a sensible assertion. Let me just
            write “sensible” here on the writing. But, as a sensible assertion, it
            makes sense to write this down. And then the crucial thing is that
            <em>a</em> is true, which is the kind of thing you learned in
            school.
        </p>
        <p>因此，断言为真，这意味着——这是重点——我知道一个 的证明<em>。</em>因此，这个想法只是教科书中的语法，在教科书中，你写“定理”。你知道有无数个素数，例如，无数个素数。你说的是，我们将其称为 a。好的，给它起个名字。A，只是为了对齐符号。当我说“定理 a”时，这意味着我声称 a 为真。</p><p>So, an assertion is true, and what it means is that—and this is the
            important part—I know a proof of <em>a</em>. So the idea is that this is
            just syntax for what, in a textbook, in a textbook, you write “theorem.”
            You know there are infinitely many primes, infinitely many primes, for
            example. What you are saying is, we’ll call this a. Okay, give that a
            name. A, just to line up the notation. And when I say “theorem a,” it
            means I claim that a is true.</p>
        <p>当然，这就是它的意思。但是如果你在写一本数学书，你不能只是——或者在你的家庭作业或什么的——你无法断言某件事是真的。或者你可以这样做，但需要一定的可信度才能做到这一点，因为隐含的——好吧，隐含的——是你知道它的证明的想法。所以，在你陈述定理之后，总是有一个证明，有某种论据，有某种证明标记。好的，这就是事实的概念。所以这里的想法是，只有凭借你有——有——有证明，某件事才会是真的。这是关键的想法。</p><p>Of course, that’s what it means. But if you’re doing a math book, you
            don’t get to just sort of—or in your homework or something—you don’t
            just get to assert that something is true. Or you do, but it takes a
            certain amount of credibility to get away with that, because
            implicitly—all right, implicitly—is the idea that you know a proof of
            it. And so invariably, what comes after here, after your state theorem,
            is there’s a proof, and there’s some sort of an argument, and some sort
            of a proof marker. Okay, that goes on here. So that’s the notion of
            truth. So the idea here is that something gets to be true only by virtue
            of your having—of having—having a proof. That is the critical idea.</p>
        <p>所以这和你很久以前在学校学到的东西有点不同。我猜是吧，因为它相当标准。可能在某个时候，人们会和你谈论真值表。至少，我的经历是在我十几岁的时候。在几何课上，我们花了一些时间学习所有逻辑连接词的真值表。你经历了所有这些事情，然后他们似乎完全改变了主题，开始做欧几里得几何，其中的思想和重点是编织一个证明。你有图表形式的裙摆，你在那里写下推论。在某种程度上，它并没有非常紧密地联系在一起。关于真值表和布尔表达式和位的这个故事与证明的写作有什么关系？证明的语法是什么？</p><p>So this is a little bit different from like what you probably learned
            in school a long time ago. I’m sort of guessing, because it’s fairly
            standard. Probably somewhere along the way, people talk to you about
            truth tables. At least, my experience was when I was like a young
            teenager. We, in geometry class, we spent some time learning the truth
            tables for all the logical connectives. And you go through all these
            things, and then seemingly they completely change the subject and start
            doing Euclidean geometry, where the idea, the emphasis, is on braiding a
            proof. And you have the skirt of chart form, where you’re writing down a
            deduction. And in some way, it’s not really very strongly connected up.
            What is this story about truth tables and Boolean expressions and bits
            have to do with the writing of the proof? And what is the grammar of
            proof?</p>
        <h2 id="proof-theory-and-formal-grammar-of-proof">证明理论和证明形式语法</h2><h2>Proof Theory and
            Formal Grammar of Proof</h2>
        <p>这就是中心思想。</p><p>And that is a central idea.</p>
        <p>因此，在某种程度上，我们将在这里讨论证明理论——弗兰克将会谈论很多——好的，证明理论实际上是在谈论一种形式化或精确的证明语法。你可能会这么说。好的，如果你想适应它，那就是一个符号系统。你可以把它看作是一个符号系统，一个证明符号。好的。此外，它将涉及等价性或证明执行的概念，证明的平等性。</p><p>So proof theory, in some way, which we’re going to talk about
            here—Frank is going to talk about a lot—okay, proof theory is really
            talking about a formal or precise grammar of proof. You might say that.
            Okay, that is a notation system, if you want to fit it. You can think of
            it as a notation system, a notation for proofs. Okay. And moreover, it’s
            going to involve a notion of equivalence or execution of proofs,
            equality of proofs.</p>
        <h2 id="equality-of-proofs-and-algebra-of-proofs">证明相等性和证明代数</h2><h2>Equality of Proofs and
            Algebra of Proofs</h2>
        <p>事实上，证明相等性这个概念正是我在本讲座中要尝试阐述的。在讲到这一点之前，它会让你了解两个证明何时相同，这将激发我讲其他东西。让我先提一下语法证明。可能你们中的许多人，在座的许多人，可能——对于在座的听众来说，我可能没有——这不是最好的例子，但对于许多人来说，在他们职业生涯的某个阶段，很难理解什么是有效证明。</p><p>And in fact, this idea of equality of proofs is where I’m going to
            try to get to in this lecture. It gives you a notion of when two proofs
            are the same, before I get to that, and that will motivate something
            else. Let me just mention something about grammar proofs. Probably many
            of you, a lot of you here, may be—it’s possible that for this audience,
            I don’t have—this isn’t the best example, but for many people at some
            stage in their career, have a lot of trouble understanding what is a
            valid proof.</p>
        <p>好吗？这是——这是，我从在大学教书很长一段时间以来知道，很多学生都很难理解这一点。所以，解决这个问题的一种方法——解决这个问题的方法有很多——就是把它想象成一种英语作文课，而证明理论是一种数学作文课，其目的是让我们弄清楚构成证明的确切机制。好吗？这就是将要发生的事情。</p><p>Okay? This is—this is, I know from teaching at university for quite a
            long time that many students have a hard time getting it. So, one way to
            address the problem—there are many ways to address the problem—is to
            think of it like a kind of English composition class, and sort of proof
            theory is kind of the math composition class, where the idea is to let’s
            get the mechanics down of exactly what it is to constitute a proof.
            Okay? That’s what’s going to happen.</p>
        <p>所以，证明理论的想法就是这样，为我们提供证明的正式符号，然后它将引发——在我的讲座结束时我将回到这个问题——一个重要的证明相等性问题，这将直接引出证明代数的想法。</p><p>So, the idea about proof theory is to do that, to give us a formal
            notation for proofs, and then it will raise—and I’m going to get to
            this, back to this, by the end of my lecture—an important issue of
            equality of proofs, which leads directly to the idea of an algebra of
            proofs.</p>
        <h2 id="algebraic-structure-of-proofs-and-the-notion-of-calculation">证明的代数结构和计算概念</h2><h2>Algebraic
            Structure of Proofs and the Notion of Calculation</h2>
        <p>因为请记住，我之前提到的这种代数观点，非常不错。因为请记住，在代数中，代数的基本思想是计算一个表达式是否等于另一个表达式。也许吧。所以，当你在学校学习初等代数时，你正在学习操作多项式。所以，你有各种形式的表达，你想知道它们何时相等？或者，如果你看更抽象的代数结构、群或类似的东西，它们是由方程、公理给出的。所以，你担心平等。好吗？你总是在处理平等问题。</p><p>Because remember that the—so, pretty huh, sort—which is this
            algebraic view that I was alluding to before. Because remember, in
            algebra, the basic idea of an out in algebra is you’re calculating
            whether one expression is equal to another. Maybe. So, when you learn,
            you know, elementary algebra in school, you’re learning to manipulate
            polynomials, for example. So, you have various forms of expression, and
            you want to know when are they equal? Or, if you look at more abstract
            algebraic structures, groups, or something, they’re given by equations,
            axioms. So, you’re worried about equality. Okay? You’re always dealing
            with equality.</p>
        <p>接下来，我会稍微阐述一下。证明理论会给我们一个符号，代数会给我们一些推理方法，来判断两个证明何时相等。这样做的原因是让我们了解我们正在讨论的抽象对象是什么。你看，因为如果你给出证明符号的概念，那就很好了，但你会发现，正如我们很快就会看到的那样，你可以在证明中加入一些小的变化，你会想知道，哪些变化很重要，哪些不重要？你会想通过一些等价关系来消除这些变化。我将讨论这样做的不同程度，关于等价关系，以便将证明的抽象特征分离为某种数学对象。</p><p>So, what is going to happen is I’ll motivate this a little bit. So,
            proof theory will give us a notation, and the algebra will give us some
            way of reasoning about when our two proofs are equal. So, the reason to
            do that is to give us a concept of what abstract object are we talking
            about? You see, because if you give some idea of just a notation for
            proofs, that’s well and good, but then you’ll find, as we’ll see
            shortly, you know, there are little variations you can put into a proof,
            and you wonder, well, which ones matter, and which ones don’t? And
            you’re sort of would like to quotient out by some equivalence relations.
            And I’ll talk about various degrees of doing that, about the equivalence
            relation in order to—in order to isolate the abstract character of the
            proofs as some kind of mathematical objects.</p>
        <h2 id="proofs-as-mathematical-objects-and-their-equivalence">证明作为数学对象及其等价性</h2><h2>Proofs as
            Mathematical Objects and their Equivalence</h2>
        <p>因此，我们最终得出的结论是，证明是数学对象，这对直觉逻辑非常重要。好吧。我必须说是数学对象。我试图非常强调地解释这一点，因为传统的故事，就像我很久以前学过的和向你们解释过的几何故事一样，提出了这些……你知道，布尔变量。游戏中的数学对象是点、欧几里得平面和各种几何图形。这些就是你玩的对象。</p><p>So, what we wind up with at this point, which is very important to
            intuitionistic logic, is the idea that proofs are mathematical objects.
            Okay. I have to say mathematical object. I’m trying to be very emphatic
            in explaining this because the conventional story, like the one I
            learned and explained to you about geometry long ago, presents these…
            you know, Boolean variables. The mathematical objects in play are the
            points and the Euclidean plane and various geometric figures. Those are
            the objects you play with.</p>
        <p>证明就是你谈论它们的方式。明白吗？你学习如何写下这些东西，以及如何写出令人信服的论据来表明两个三角形是全等的，等等。好吧，就目前而言，这很好，但有趣的是，当你参与证明理论并最终开发代数证明时，证明本身就变成了数学对象。明白吗？有些东西与其他所有数学对象具有完全相同的地位：平面上的点、空间中的函数、几何图形。因为所有证明都变成了数学对象。</p><p>The proofs are just the way you talk about them. Okay? And you learn
            how to write those things down and how to write a convincing argument
            that shows the two triangles are congruent, or so on and so forth. Well,
            that’s fine as far as it goes, but the interesting thing here, when you,
            when you engage in proof theory and, in the end, develop the algebra
            proofs, is that the proofs themselves become mathematical objects. Okay?
            There are things that have exactly the same status as every other
            mathematical object: as points in the plane, as functions in space, as
            geometric figures. As all the proofs become mathematical objects.</p>
        <p>现在，这并不是说，对于你们这些人来说——显然，你们都是计算机科学的人或有志于成为计算机科学的人——这并不是说由于等价关系，事物可以被引用并用作字符串，对吧？所以，这个想法是：证明是数学对象。我甚至要强调的是，尽管有过度重复的风险，我还是要再次强调这一点：它们是抽象的数学对象。我的意思是它们以代数为特征；它们之间有某种等价概念。</p><p>Now, this is not to say, for those of you—obviously, you’re all
            computer science people or aspiring computer science people—this is not
            to say the trivial thing that things can be quoted and used as strings
            because of the equivalence relation, right? So, the idea is: proofs are
            mathematical objects. And I would even emphasize that, at the risk of
            being overly redundant, I’ll just double emphasize this point: they’re
            abstract mathematical objects. By which I mean they’re characterized by
            an algebra; they have some kind of notion of equivalence between
            them.</p>
        <p>因此，有趣的一点是，相等证明必须在所有情况下都可以互换。因此，这比仅仅谈论字符串之类的东西要微妙得多。所以，我不希望你马上跑开说：“哦，是的，我知道所有关于引用和字符串的知识”，因为这几乎无关紧要。好吗？我们稍后再讨论这个问题。我的意思是，你可以这样做，我对此没有异议，但这不是有趣的事情；这不是行动所在。</p><p>And thereby, the interesting point will be that equal proofs have to
            be interchangeable in all contexts. So, then it’s a much more subtle
            business than just talking about something like strings. So, I don’t
            want you to get off, you know, run off and say, “Oh, yeah, I know all
            about quoting and strings,” because it’s pretty much irrelevant. Okay?
            And we’ll come back to that in a moment. I mean, you can do that, and
            I’m not disputing that, but that’s not the interesting thing; that’s not
            where the action is.</p>
        <h2 id="intuitionistic-logic-and-the-role-of-proofs-in-computer-science">直觉逻辑和证明在计算机科学中的作用</h2><h2>Intuitionistic
            Logic and the Role of Proofs in Computer Science</h2>
        <p>好的？</p><p>Okay?</p>
        <p>所以，我们会看到这一点。直觉逻辑的理念是，你非常非常认真地对待证明的理念，比任何其他逻辑分支都要认真得多。这样做是有回报的。这样做的原因——这样做有很多回报——我们将在这里花整整几周的时间来阐述这一事实的含义。但我可以立即说的是：如果你思考你在代数中学到的东西，当你学习代数时，你会得到的东西之一，事实上，最初的代数这个词的起源来自一个阿拉伯词，意思是……</p><p>So, we’re going to see this. So, the idea of intuitionistic logic is
            you take the idea of a proof very, very, very seriously, much more so
            than any other branch of logic. And there’s a payoff to this. And the
            reason for this—there are many payoffs to this—we’ll spend the whole
            couple of weeks here drawing out the implications of this fact. But the
            one that I can say straight away that comes out of this is: if you think
            about what you learned in algebra, when you learn in algebra, one of the
            things you get, and in fact, the original, the origin of the word
            algebra comes from an Arabic word meaning…</p>
        <p>会说阿拉伯语的人可以看看我的计算方法。好的，这就是它的来源。作为<em>算法</em>，我认为它起源于 13 世纪。所以它意味着一种计算方法。好的，这就是这个想法。所以，最初，像大多数数学分支一样，这些方法的发明基本上是为了找出赚钱的方法。好吗？这就是概率的计算方式。它就是为此而发明的。代数是用来计算测量值等的方法。所以，它是一种计算方法，在这种情况下，我们将其视为计算。好吗？</p><p>Someone who speaks Arabic can check my calculation method. Okay,
            that’s where it comes from. As <em>algorism</em>, it’s worked from, I
            think, like the 13th century. So it means a method of calculation. Okay,
            that’s the idea. So, originally, like most branches of mathematics, with
            these methods were invented and were basically in order to figure out
            ways to make money. Okay? This is the way you know probability was done.
            This was, like, was invented for this reason. Algebra was done as ways
            of doing calculations of measurements, and so on. So, it’s a method of
            calculation, which in this case, we will think of as computation.
            Okay?</p>
        <p>所以，这是一个重要的观点。通过将证明视为具有代数结构，该代数结构会产生计算的概念。计算的概念是计算的模型。好吗？</p><p>So, that’s an important point. Is that by thinking of proofs as
            having an algebraic structure, that algebraic structure gives rise to a
            notion of calculation. That notion of calculation is a model of
            computation. Okay?</p>
        <p>所以，我们将要得到的是，我们将有一个概念，其中证明就是程序。</p><p>So, what we’re going to have then is we’re going to have a notion
            where proofs are programs.</p>
        <h2 id="proofs-as-programs-and-the-holy-trinity-of-computer-science">证明即程序和计算机科学的三位一体</h2><h2>Proofs
            as Programs and the Holy Trinity of Computer Science</h2>
        <p>这就是这个想法。所以，这是一种计算方法。证明是数学项目，事实上，证明只不过是程序——计算机程序——可以执行或计算的东西。好吗？</p><p>So, this is the idea. So, it’s a method of calculation. Proofs are
            mathematical projects, and in fact, proofs are nothing other than
            programs—computer programs—things that can be executed or it can be
            calculated with. Okay?</p>
        <p>所以，有程序。里面有程序。用一个行话来预示我稍后要用到的行话，它们将是程序。行话的说法是外延的，或者从外延的角度来看，或者这是行话的说法。我稍后会解释这是什么意思，或者作为抽象对象。</p><p>So, there are programs. There are programs in it. To use a jargon to
            foreshadow a jargon that I’m going to use a little bit later, they’re
            going to be programs. The jargony way of saying it is in extension, or
            viewed extensionally, or that’s the jargony way of saying it. I’ll
            explain later what that means, or as abstract objects.</p>
        <p>所以，如果我过于强调的话，请原谅，但我必须强调这不是引用的问题。不要这样想。好吗？所以，这实际上是将程序视为抽象的数学对象。所以，这就是直觉逻辑的基本设置。</p><p>So, I have to excuse me if I’m being overly emphatic, but I do have
            to emphasize it’s not an issue about quoting. Don’t get that idea. Okay?
            So, it’s really treating programs as abstract mathematical objects. So,
            that’s the basic, the basic setup of how, of how what intuitionistic
            logic is all about.</p>
        <h2 id="intuitionistic-logic-and-the-study-of-programming-languages">直觉逻辑与编程语言研究</h2><h2>Intuitionistic
            Logic and the Study of Programming Languages</h2>
        <p>好的？</p><p>Okay?</p>
        <p>弗兰克将要认真讨论证明理论，我会给你一点提示，因为我需要为你做些准备。史蒂夫将要讨论的是证明代数或范畴论。而大家谈论的其实只是计算机编程。好吗？</p><p>And what Frank is going to be doing is talking a lot seriously about
            proof theory, and I’m going to give you a little kind of foreshadow of
            that because I need to set up some things for you. And what Steve
            already is going to be talking about is the algebra of proofs or
            category theory. And what everybody is talking about is really just
            computer programming. Okay?</p>
        <p>所以，我喜欢把这个东西称为计算机科学的三位一体。好吗？</p><p>So, there is this thing which I like to call the sort of holy trinity
            here of computer science. Okay?</p>
        <p>所以，我们应该把这个放在一边，我喜欢称之为三位一体，即证明理论（逻辑和证明理论）、代数和范畴论之间的对应关系。然后计算机科学方面的主题是程序或类型理论。它们是同一件事。好吗？</p><p>So, well, we should keep this over the side, which is I like to call
            the holy trinity, which is the correspondences between proof theory,
            which is sort of the theory of logic and proofs, algebra, and category
            theory. And then the subject in the computer science side is programs or
            type theory. Those are the same thing. Okay?</p>
        <p>这些都有着紧密的对应关系。这就像她所说的意大利语中的计算三位一体论，也就是我们所拥有的三位一体计算原则。计算概念的想法可能源自计算的概念，但也可能来自其他来源。同样的概念也可能出现在代数中，也可能出现在逻辑中。事实上，我会反过来赋予它更规范的力量，并且说你不知道你在说什么，直到你想出一个想法——直到你从这三个方面理解它：作为计算的概念，作为证明的概念，作为代数结构的概念。</p><p>And these all have tight correspondences. This is like what Italian
            she called the doctrine of computational trinitarianism, which is the
            computing in three persons principle that we have. The idea of a
            computational concept arises perhaps as a notion of computing, but it
            may also arise from other sources. The same concept may also arise in
            algebra, and it may also arise in logic. In fact, I would turn that the
            other way around and give it a more normative force and say you don’t
            know what you’re talking about until whatever idea you come up
            with—until you understand it in all three ways: as a notion of
            computation, as a notion of proof, and as a notion of algebraic
            structure.</p>
        <p>如果你发现某件事在这三个方面都有很好的意义，那么你就有了所谓的真正的科学发现。到那时，你就做了一件永恒的事情；你真的创造了永恒的东西，永恒的东西。你真的发现了一些重要的东西；你有了真正的发现。如果你只是涵盖了一些从这三个角度都有意义的概念。所以，它的美妙之处在于，我喜欢这样思考，这是一种让解决这些问题变得有意义的方式，值得去做。</p><p>If you find something that has good meaning in all three senses, you
            have what I would call a proper scientific discovery. At that point,
            you’ve done something which is permanent; you’ve really made something
            permanent, something that will last to eternity. You’ve really
            discovered something significant; you’ve got a real discovery. If you
            just cover some conception that makes sense from all three points of
            view. So, the beauty of this is that the way I like to think about it is
            it’s a way of making working on these problems in a certain way
            meaningful, are worth doing.</p>
        <p>就我个人而言，你的看法可能有所不同。我发现没有什么比试图追随某个公司的某个笨蛋的最新趋势更无聊的了，他告诉我们，我们应该用某种东西做一些面向对象的胡言乱语。好吧，这就像，我对此不感兴趣。好吧，这对我来说完全不重要。这些都是来来去去的技术变幻莫测，它们之所以流行是因为某个大公司说它们很流行，然后它们就不再流行了，因为那个大公司倒闭了或者其他什么原因。</p><p>I, you know, personally, your opinion may certainly vary. I find
            nothing more dreary than trying to chase around the recent trends of
            some bozo at some company who was telling us that we ought to be doing
            some object oriented mumbo jumbo with something or other. Okay, this is
            like, I’m not interested in this. Okay, this is like completely
            unimportant to me. These are the vagaries of technology that come and
            go, and they’re popular because some big company says they’re popular,
            and then they’re not because that big company goes out of business or
            whatever.</p>
        <p>这都是废话，对吧？所以，如果你对科学感兴趣，也许你会感兴趣，但如果你对科学感兴趣，这就是谈论编程语言的科学框架，这就是我们正在做的事情。所以，我之所以希望从谈论逻辑开始，是因为这是一个切入点，我们将围绕我、弗兰克和史蒂夫·奥迪之间的这个圈子展开讨论。我们将围绕这个圈子向你们展示我们正在做的事情的各个方面。好的，这就是计划。所以，这就是为什么我认为这些概念对于编程语言的研究非常重要——也就是说，这就是我所说的，你知道的，对编程语言的真正研究。好的，这是真正的内容。我们要讨论计算的基本原理是什么，这就是它的想法。好的，这就是正在发生的事情。好的，很好。</p><p>That’s a load of nonsense, right? So, if you’re interested in
            science, maybe or not, but if you’re interested in science, this is the
            scientific framework for talking about programming languages, and this
            is what we’re doing. So, the reason I wish to start out by talking about
            logic is because, well, it’s an entry point, and we’ll run around this
            circle between me, Frank, and Steve Audi. We’ll run around this circle
            and show you all the aspects of what we’re doing. Okay, so that’s the
            plan. So, that’s why I think these concepts are very central to the
            study of programming languages—that is, and this is what I would call,
            you know, the the real study of programming languages. Okay, this is the
            real the real stuff. We’re down to like what are the fundamental
            principles of computation, and that’s the idea of it. Okay, that’s
            what’s going on. Okay, so good.</p>
        <p>现在，我想说一下这是如何设置的，以便到达某个地方，开始，这样我就可以讲些什么。</p><p>Now, I want to say a few things about how this is sort of set up in
            order to get to, to get somewhere, to get started, so that I can say
            something.</p>
        <h2 id="setting-up-for-equality-of-proofs">建立证明平等</h2><h2>Setting Up for Equality of
            Proofs</h2>
        <p>今天最后我想谈谈证明相等性的概念。为此，我需要建立一些机制。弗兰克会开发一些东西，我会在证明理论方面用图表概述它们。我需要利用这一点开始，我需要在代数方面做到这一点。我在这里。为了阐明我的观点，我将展示史蒂夫·奥迪将要讨论的内容的一种略微退化的形式。</p><p>What I want to end up today is saying something about the notion of
            equality of proofs. To do this, I need to set up some machinery. Frank
            will develop a few things, which I’ll outline in a chart on the proof
            theory side. I need to use this to get going, and I need to do this on
            the algebra side. And I’m here. I’m going to—what I’m going to do for
            the purposes of making my point is I’m going to present a slightly
            degenerate form of what Steve Odie will be talking about.</p>
        <p>因此，我将在此背景下研究一种以预序形式呈现的范畴论的有限表述。</p><p>So I will be looking at a kind of limited formulation of category
            theory in this setting, in the form of pre order.</p>
        <h2 id="preorders-and-category-theory">预序与范畴论</h2><h2>Preorders and Category
            Theory</h2>
        <p>因此，我将研究某些结构化预序的结构。这就是我们要讨论的内容，稍后我将向您展示我的意思。史蒂夫将做的是将其正确地发展为范畴论。因此，范畴论可以 — — 一种看待它的方式是，您知道，至少可以说，它是预序概念的广义概括，或者反过来：预序是范畴的一种非常退化的形式。但让我们让史蒂夫详细讨论这个问题。好的。</p><p>So I’m going to be looking at the structure of certain structured pre
            orders. This is what we’re going to get to, and I’ll show you what I
            mean by that in a minute. What Steve will do is to develop this properly
            into the theory of categories. So the theory of categories can—one way
            of seeing it is as a, you know, substantially, to say the least,
            generalized generalization of the idea of a pre order, or the other way
            around: a pre order is a very substantially degenerate form of a
            category. But let’s let’s leave Steve to talk about that in detail.
            Okay.</p>
        <p>所以我只想让你们领略一下。对应关系的要素之一是以下要素，我想在这张图表中展示出来，也就是回到我之前所说的想法：这种对真理的原始判断。现在我想简要地谈谈。</p><p>So I just want to give you a flavor. So one of the elements of the
            correspondence is the following one, which is that I want to want to
            bring out in this chart, which is the idea of going back to what I said
            before: this primitive judgment of truth. I would now like to talk about
            briefly.</p>
        <h2 id="logical-entailment-and-hypotheses">逻辑蕴涵和假设</h2><h2>Logical Entailment and
            Hypotheses</h2>
        <p>我需要在这里谈谈蕴涵的概念。我想把它看作是这个想法，或者也称为逻辑结果。所以弗兰克会详细阐述这一点，但我需要给你一点铺垫，让你知道发生了什么。这个想法是这样的：我们一开始说，我们感兴趣的是判断——用术语来说——某个命题是否正确。但在现实中，你通常不会直接说某个命题是正确的，而是说它在假设下是正确的。</p><p>I need to talk about it here. The notion of entailment. So I want to
            think of this as the idea, or which is also known as a logical
            consequence. So Frank is going to go into this in great detail, but I
            need to give you a little foreshadowing, a little bit of what’s going
            on. And the idea is this: We started out with saying, well, we’re
            interested in judging—as the terminology will go—whether a certain
            proposition is true. But in reality, it’s not so often that you just say
            outright that a certain proposition is true, but rather you say that
            it’s true under hypotheses.</p>
        <p>所以你要做的就是，你有一些所谓的假设，或者可能被称为假定，好吧，或者诸如此类的词。这是你的结论，好吧。这是一个典型的术语。你想说的是，本质上，给定一个， <em>a</em>是真的——现在一切都存在于“给定”中。给定
            <em>1</em>是真的，以及其他各种事物，<em>a</em> m 是真的，这是对此的基本解读。对于那些不熟悉的人来说，这就是所谓的旋转栅门，它就是这样的。
        </p><p>So what you do is you have what are variously called hypotheses, or
            maybe they’re called assumptions, okay, or words like that. And this is
            your conclusion, okay. And that’s a typical terminology. And the idea is
            you want to say is that essentially that <em>a</em> is true given
            that—and now everything resides in the “given that.” Given that
            <em>a</em>1 is true, and various other things, <em>a</em>m is true,
            that’s the basic, basic reading of this. And this is, for those of you
            who are not familiar, that’s called a turnstile, and it is what it
            is.
        </p>
        <p>这就是人们使用的符号。这种符号可以追溯到 19 世纪末的弗雷格。好吧？这就是想法。所以，我们有这个逻辑蕴涵的想法。我想指出的关于逻辑蕴涵的有趣之处——只是为了在中间画出这些对应关系——在中间，我最终要在这里写的是类型。所以，让我们把它放在中间。但在起点，我要做的是走到两端，然后我们会——我们会让它在中间相遇。</p><p>That’s what people use it. That notation goes back to Frege in the
            late 19th century. Okay? Is the idea. So, what we have is this idea of
            logical entailment. The interesting thing that I want to point out about
            logical entailment—just to draw these correspondences between—and in the
            middle, what I’m going to end up writing here are types. So, let’s put
            it in the middle. But in the starting point, what I’m going to do is go
            on the ends, and then we’ll—we’ll make it meet in the middle.</p>
        <p>这就是我的计划。好的。那么，我来给你介绍一下。好的，那么，这里是介绍一下。那么，介绍一下：如果你看一下这个结构，我想指出关于这个蕴涵概念的几点。我稍微挥了挥手。好的，但原因是，我将进行迭代深化。所以，这应该像一个高级介绍。所以，所有细节都会浮现出来，但让我稍微挥挥手。</p><p>That’s my plan. Okay. So, I’ll just give you a flavor. Okay, so
            here’s a flavor. So, the flavor is: if you look at this structure, I
            want to point out a couple of things about this notion of entailment. I
            am hand waving a little bit. Okay, but the reason is, I’m going to be
            doing an iterative deepening. So, this is supposed to be like a high
            level intro. So, all the details will emerge, but let me hand wave a
            bit.</p>
        <p>好的，稍微挥挥手。根据我之前提到的解读，你会认为如果你假设某事是真的，那么它就是真的。好的，这就是反身性原理。好的，那将是——这是挥手的部分。好的，所以我挥挥手，从某种代数或序论的角度来看，这应该是蕴涵的含义的一部分。这可以理解为 a 小于或等于 a。</p><p>Okay, so hand waving a little bit. Given the reading that I mentioned
            to you before, you would expect that if you assume something is true,
            then it’s true. Okay, which is the principle of reflexivity. Okay, that
            would—this is the hand wavy part. Okay, so I’m hand waving that ought to
            be part of the meaning of entailment from a sort of algebraic or order
            theoretic point of view. That can be read as saying a is less than or
            equal to a.</p>
        <p>好的。所以，这是一个顺序。换句话说，我们可以把这个东西看作是一种小于关系。事实上，我们要把它看作是一种映射关系。这就是后面要发生的事情。所以，在范畴论方面，我说我不会这么做，但我会稍微补充一下。</p><p>Okay. So, it’s an order. In other words, we can read this thing as
            being a kind of less than relation. And in fact, what we’re going to
            read it as is a kind of mapping relation. That’s what’s going to happen
            later. So, on the category theoretic side, I said I wasn’t going to do
            this, but I’ll fill it in a little bit.</p>
        <h2 id="correspondence-between-entailment-and-mapping-relations">蕴涵和映射关系之间的对应关系</h2><h2>Correspondence
            Between Entailment and Mapping Relations</h2>
        <p>对于任何对象 a，您都有一个映射。您有一个从 a 到其自身的恒等映射。这就是最终将要发生的事情。嗯。它不适合我的板子。从预排序的角度来看，它只是说 a 小于或等于 a。</p><p>You have a map for any object a. You have the identity map from a to
            itself. That’s eventually what’s going to happen. Huh. It doesn’t fit on
            my board. From a pre order point of view, it just says a is less than or
            equal to a.</p>
        <p>另一个有趣的事实是——这可以称为反身性——另一个有趣的事实是传递性，或引理规则。这告诉你我们可以——有各种方法可以写下来，但再次重申，就像我说的，我给出一个小概述。如果 b 基于 a 为真，a 基于 c 为真，那么我们可以得出结论——这就是我们写它的方式——那……我在这里做了什么？那……那 b 基于 c 为真。&nbsp;</p><p>Another interesting fact that you get—so this might be called
            reflexivity—another interesting fact is transitivity, or the lemma rule.
            And this tells you we can—there are various ways to write this down, but
            again, like I say, I’m giving a little overview. If b is true on the
            basis of a, and a is true on the basis of c, then we can conclude—and
            that’s the way in which we write it—that… what did I do here? That… that
            b is true on the basis of c.&nbsp;</p>
        <p>如果我做对了。好的。如果我更好地选择字母，它会看起来更漂亮。好的。所以，好的。所以，这是一个原则，我们可以将其解读为传递性原则。对，因为如果 a ≤ b 且 b ≤ c，它说什么？所以我搞砸了。那么 a 小于或等于 c。我在这里做错了什么？让我们，让我们做点什么让它看起来更好。好的。我想。</p><p>If I did that right. Okay. And if I chose my letters better, it would
            look nicer. Okay. So, okay. So, that’s a principle, and we can read this
            as a principle of transitivity. Right, because what is it saying if a ≤
            b and b ≤ c? So that I messed it up. Then a is less than or equal to
            c.&nbsp;What did I do wrong here? Let’s, let’s do it to make it look better.
            Okay. I want to.</p>
        <p>A 小于 b，小于 c。我们这样做吧。我运行字母，然后它就会小于 c。这样就行了。好的，很好。这样符号就行了。然后 a 小于或等于 c。这只是想法。如果你看一个类别，如果你有一个从 a 到 b 的映射，如果你有一个从 b 到 c 的映射，那么你可以把它们组合起来，对吧？</p><p>A less than b, be less than c.&nbsp;Let’s do it like that. I got my
            letters run, and then it will be a less than c.&nbsp;That way it’ll work.
            Okay, good. So then the notation will work. Then a is less than or equal
            to c.&nbsp;And this is just the idea. If you look in a category, if you have
            a map from a to b, and if you have a map from b to c, then you can
            compose them, right?</p>
        <p>您可以在 f 之后执行 g，然后获得从 a 到 c 的映射。这就是类别中即将出现的内容。好的。但这里是传递性原则。好的。所以我们已经可以看到某种看起来很熟悉的结构。好的，正在出现。好的。这就是这个想法。所以你在证明理论方面看到的。那么这对应于什么？如果你从逻辑推理的角度来思考这个问题。好的。如果你认为这是逻辑推理，那么它对应于我所说的引理规则，对吗？</p><p>You can do g after f and get a map from a to c.&nbsp;That’s the what will
            be coming up in categories. Okay. But here it’s the principle of
            transitivity. Okay. So already we can see some sort of familiar looking
            structure. Okay, is emerging. All right. That’s the that’s the idea. So
            what you see on the proof theory side. So what does this correspond to?
            If you think of this in terms of logical reasoning. Okay. If you think
            of this as logical reasoning, then it corresponds to what I would call
            the lemma rule, right?</p>
        <p>这句话的意思就是，我想证明 c。你总是基于某些假设来做事。好吧。D，一般来说，我们稍后会讨论退化的情况，但假设我们总是基于假设来做事。我们试图证明 c。然后你可以把它分解，然后说，嗯，b 对 c 来说就足够了。然后你给出一个论证，然后单独证明 b。好的。这就是引理规则。这就是这里发生的事情。</p><p>It sort of says, I want to prove c.&nbsp;You’re always working in the
            basis of some assumptions. All right. D, generally we’ll get to the
            degenerate cases a little later, but let’s say we’re always working
            under assumptions. We’re trying to show c.&nbsp;Then what you can do is you
            can break it down and say, well, b is sufficient for c.&nbsp;And you give an
            argument, and then you separately prove b. Okay. So that’s the lemma
            rule. That’s what’s going on here.</p>
        <p>好的。这就是引理的概念，诉诸引理。好的。因此，这个逻辑原理实际上可以代数地转换为这个预序的传递性。好的。这是两个例子。我还可以举出其他例子。让我检查一下我的符号。好的。是的，我会这样做。给我一点时间。我必须考虑一下我想怎么做。好的。我马上就讲到。</p><p>Okay. So this is the idea of a lemma, appealing to a lemma. Okay. And
            and and so that logical principle is really can be cast algebraically as
            the transitivity of this preorder. Okay. So those are two examples.
            There are other examples I can give. Let me just check my notation.
            Okay. Which, yes, I will do that. Give me a second here. I have to think
            about how I want to do that. Okay. I’ll get to that in a second.</p>
        <p>好的。到目前为止还有其他问题吗？好的。没有，有什么问题吗？没有。你们都跟我一起。你们之前都见过这一切。我不认识你们中的任何人，可能除了你们中的一两个人。这一切都非常熟悉。好的。也许，也许不是。好的。好吧，请打断我，随时提问。如果你跳进去，对每个人来说都会更有趣。好的。所以我现在想做的是，这就是结构的开始。</p><p>All right. Other any questions so far? Okay. No, any questions?
            No.&nbsp;You’re all with me. You’ve all seen all of this before. I don’t know
            any of you, except possibly one or two of you. It’s all completely
            familiar. Okay. Maybe, maybe not. All right. Well, please interrupt me
            and ask questions as they as they arise. It’s more fun for everyone if
            you jump in. Okay. So what I want to do now is, like, so that’s the
            beginnings of the structure.</p>
        <p>现在我想稍微充实一下这个结构。让我从头开始。我需要让它保持可见。让我发布它，然后我会在一分钟后返回。好的。那么，让我再为您观察一下。我在这里处于非常高层次的事情，只是想给您一些我的主要想法。好的。所以，这是这种手势。那么，我们现在来看看。</p><p>So now I want to look at fleshing out this structure a little bit.
            And so let me do it by starting. I need this to stay visible. Let me
            post it, and I’ll return to it in a minute. Okay. So, let me observe
            something for you again. I’m at the level of a very high level thing
            here, of just trying to give you some of my main ideas. Okay. So, here’s
            this kind of hand wavy thing. So, let’s look now.</p>
        <p>如果我们——让我们暂时换一下话题。我想要做的是展示思想的相互作用。</p><p>If we’re—let’s, for a moment, let’s switch over. What I want to do is
            I want to show the interplay of ideas.</p>
        <h2 id="meets-and-conjunctions-in-order-theory-and-logic">序理论和逻辑中的交集和合集</h2><h2>Meets and
            Conjunctions in Order Theory and Logic</h2>
        <p>那么，让我们从代数方面开始，这里是预序结构。你们中的一些人可能已经听说过交集的概念。好的。交集操作，或者你可以称之为最大下限，如果你愿意的话。让我们看看它是什么。首先，在预序中。假设预序是自反和传递二元关系。所以，这就是我们目前所得到的。我想说预序有交集。好的。交集。如果你给我两个元素，它们有一个最大下限。这是交集的通常定义。你也可以用连接来做到这一点，我稍后会这样做。好的。</p><p>So, let’s start on the algebra side here, where they have, over here,
            for the pre order structure. So, some of you may have come across the
            idea of a meet. Okay. A meet operation, or you could call this a
            greatest lower bound, if you want. Let’s just look at what that is. So,
            first of all, in a pre order. So, say a pre order is a reflexive and
            transitive binary relation. So, that’s what we’ve got so far. And I want
            to say that a pre order has meets. Okay. Meets. If you give me two
            elements, they have a greatest lower bound. That’s the usual, usual
            definition of a meet. You can do this also with join, and I’ll do that
            in a moment. Okay.</p>
        <p>那么，什么是交集的概念呢？嗯，我们的想法是，我们有这样一个二元运算，给定两个元素 a 和 b，形成另一个元素，写为 a ∧ b。好的。它具有这样的特征：它是 a 的下限，也是 b 的下限，而且，它是最大的下限。这是什么意思呢？也就是说，如果 a 和 b 有任何其他下限，那么我想知道交集至少有那么大。它就是这样写的。所以，这就是交集的条件。好的。这是交集的定义。所以，如果我们有二元交集，那么我们也可以有一个平凡的、平凡的零元交集。好的。我们可以——让我们看看我——我希望如何解释这一点？</p><p>So, what is the idea of a meet? Well, the idea is that we have this
            binary operation that, given two elements of the order, a and b, forms
            another element, which is written a ∧ b. Okay. Which has the
            characteristic that it’s a lower bound for a, it’s a lower bound for b,
            and moreover, it’s the greatest such thing. And what does that mean?
            That says if you have any other lower bound for a and b, then I want to
            know that the meet is at least that large. And it’s written like that.
            So, this is the—so these are the conditions of what it means to be a
            meet. Okay. This is the definition of a meet. So, that if we have if we
            have binary meets, and then we can also have a trivial, a trivial
            nullary meet. Okay. And we can—let’s see if I—how do I wish to explain
            that?</p>
        <p>因此，零元交集不接受任何事物并形成一个对象，这是零的最大下限。因此，零元交集意味着对于任何 c，c 都小于或等于 t，也就是 — — 它通常称为 t，或 top，即格的顶部元素。所以，这就是零元交集。这是零元情况，对吧？这是二元情况。所以，这是二元交集。好的。我之所以提到这一点，是因为如果你有二元交集和零元交集，所有二元交集和所有二元交集和零元交集，那么你就有所有有限交集。</p><p>So, the nullary meet takes no things and forms an object, which is
            the greatest lower bound of nothing. So, the nullary meet means that for
            any c, c is less than or equal to t, which is—it’s usually called t, or
            top, which is the top element of the lattice. So, this is the nullary
            meet. This is the zero case, right? And this is the two case. So, this
            is the binary meet. Okay. And the reason I bring that up is because if
            you have binary and nullary meets, all binary and all binary meets and
            nullary meet, then you have all finite meets.</p>
        <p>好的。这就是想法。任何有限子集都有一个最大下界。这就是想法。好的。现在，这个结构的一个有趣方面是……所以，这个结构可以称为下半格。好吗？这将是这样的一个术语，因为它有交点。</p><p>Okay. That’s the idea. Any finite subset has a greatest lower bound.
            That’s the idea. Okay. Now, an interesting aspect of this structure is…
            So, that structure would be called a lower semi lattice. Okay? That
            would be the jargon, okay, for such a thing, because it has meets.</p>
        <h2 id="lower-semi-lattices-and-conjunctions-in-proof-theory">证明论中的下半格和合取</h2><h2>Lower
            Semi-Lattices and Conjunctions in Proof Theory</h2>
        <p>如果你反过来做，即有连接，那么我稍后会再谈到这一点，你可以这样做。这些东西，然后你会得到一个上半格。所以，这被称为下半格。所以，我现在要做的是跳回到证明理论方面，告诉你，好吧，我刚才说了什么——我的意思是什么？比如，这在证明理论方面对应什么？好吧，我认为它对应的是命题的结合的概念。</p><p>If you do it around the other way, where you have joins, so I’ll come
            back to that later, you can do that. These things, then you get an upper
            semi lattice. So, this is called the lower semi lattice. So, what I want
            to do now is jump back over on the proof theory side and tell you, well,
            what did I say when I—what did I mean? Like, what does that correspond
            to over on the proof theory side? Well, I claim what it corresponds to
            is the idea of conjunction of propositions.</p>
        <p>这个想法是这样的。让我们想想第一件事在说什么。它说的是，如果 a 和 b 为真，那么 a 肯定为真。这就是合取的意思。如果 a 和 b 为真——这就是我们的蕴涵——那么 b 肯定为真。最后，这是最重要的一点，如果我们可以这样看待它：如果 c 为真意味着 a 为真——所以 a 从 c 推出——而 b 也从 c 推出，你会从同一个引理得到两个结果，然后你就可以从同一个引理得到它们的合取。这只是从这个秩序理论方面转移到逻辑方面。我所做的就是重写它，好吗？这就是我所说的，好吗？所以，这就是我在这里所做的，好吗？所以，这是一个例子。</p><p>And here is the idea. Let’s think about what the first thing is
            saying. It’s saying that if a and b is true, then surely a is true.
            That’s what it means to be a conjunction. And if a and b is true—that’s
            our entailment—then surely b is true. And finally, and this is the
            important thing, if we can look at it like this: if c is true entails
            that a is true—so a follows from c—and b also follows from c, you get
            two results from the same lemma, then you can get their conjunction from
            that same lemma. That’s just transposing from this order theoretic side
            over into the logic side. All I do is rewrite it, okay? And—and this is
            what I—what I have said, okay? So, this is what I—what I’ve done here,
            okay? So, that’s an example.</p>
        <p>现在，还有一件有用的事情。所以，你现在可以看到，显然在交点和合取之间有一些对应的开端。所以，顺序理论中的最大下限之类的概念在逻辑环境中转换为某种逻辑连接词，比如合取。我想在某个地方画一幅图。看看我是否能找到——找到这个。我可以画一幅有用的图。我想把它留在这里，好吗？所以，让我们这样写，好吗。</p><p>Now, another thing that is useful. So, you can see now that there’s
            obviously some beginnings of a correspondence between the idea of meets
            and conjunctions. So, order theoretic ideas like greatest lower bounds
            transpose over to sort of logical connectives like conjunction in a
            logical setting. And I wanted to draw a picture somewhere. See if I can
            find—find this. There’s a useful picture I can draw. I would like to
            leave this up here, okay? So, let’s write it like that, okay.</p>
        <h2 id="product-diagrams-and-their-relation-to-logical-reasoning">产品图及其与逻辑推理的关系</h2><h2>Product
            Diagrams and their Relation to Logical Reasoning</h2>
        <p>这就是哈斯图的思想。你可能对这个想法很熟悉。因此，我们的特征图是这样的：这意味着我必须考虑要绘制哪个方向，好吗？因此，如果我取 a 和 b，我们会说 a 和 b 小于或等于 a。你可以这样画。而 b 小于或等于 b。因此，这就是我们的小于或等于。</p><p>Which is the idea of a Hasse diagram. You’re probably familiar with
            this idea. So, the characteristic diagram we have is this: that says I
            can have to think of which direction I want to draw, okay? So, if I take
            a and b, what we will say is a and b is less than or equal to a. You can
            draw it like that. And b is less than or equal to b. So, this is our
            less than or equal to.</p>
        <p>这就是我所说的小于或等于。如果 c 小于或等于 a，并且 c 小于或等于 b，那么 c 小于或等于与 a 楔形 b 相交。所以，我在这里画的这幅图对应于我在这里写的这三个语句。这是一个例子。如果我们限制预订，那就是范畴论中所谓的产品图的一个例子，史蒂夫将对此进行更详细的介绍。但就是这样。所以，无论你在哪里看到箭头，你都应该认为“小于或等于”，或者箭头只是意味着它存在，或者它不存在——它小于或等于它不存在的地方。</p><p>That’s what I mean by less than or equal to. And if c, okay, is less
            than or equal to a and c is less than or equal to b, then c is less than
            or equal to the meet a wedge b. So, this picture here that I’ve drawn,
            okay, corresponds to these three statements that I’ve written here. And
            that’s an instance. If we were restricting to preorders, that’s an
            instance of what is known as a product diagram in category theory, and
            Steve will go into a lot more detail on this. But that’s it. So,
            everywhere you see an arrow, you’re supposed to think “less than or
            equals to,” or the arrow just means it exists, or it doesn’t—it’s less
            than or equal to where it’s not.</p>
        <p>我们有这个图，重点是实线箭头是某种全称量化的。对于任何像这样的“小于”关系，都存在虚线箭头——像这样的关系。这就是这里所说的。好的。</p><p>We have this diagram, and the point is that the solid arrows are sort
            of universally quantified. For any “to less than” relations like this,
            there exist that’s the dashed arrow—a relation like this. That’s what is
            being said here. Okay.</p>
        <p>所以，这在某种程度上与那相对应。好的，这是一张值得记住的好图片，你会经常用到它。好的。</p><p>So, this in some way corresponds to that. Okay, so that’s a good
            picture to keep in mind, and you’ll use that picture a lot. Okay.</p>
        <p>现在，为了讨论依赖类型，我首先需要讨论类型。</p><p>Now, in order to set up for talking about dependent types, I first
            need to talk about types.</p>
        <h2 id="types-and-their-correspondence-to-proofs">类型及其与证明的对应关系</h2><h2>Types and their
            Correspondence to Proofs</h2>
        <p>所以，我想要做的是 — — 请注意，为了让你们稍微了解一下，我们很快会更详细地阐述这一点 — — 好吧，我想要做的是回过头来展示这些想法和编程语言之间的对应关系。</p><p>So, what I want to do—so notice, to give you a little bit of a
            flavor, a lot of this will get developed in much more detail
            shortly—well, what I want to do is I want to go back and now show a
            correspondence between these ideas and programming languages.</p>
        <p>好的。想法如下：</p><p>Okay. And the idea is the following:</p>
        <p>首先，我想做的不是谈论……这是一个蕴涵的概念，或者我们可以说……让我想想在哪里写这些。不要滑，这有点不方便。好吧，所以我必须腾出空间。</p><p>One, what I want to do is instead of talking about… This is a notion
            of entailment, or we could say… Let me figure out where to write these.
            Don’t slide that’s a little inconvenient. Okay, so I have to make
            room.</p>
        <p>好的，那么我要说什么呢？我失去了思路。哦，是的，对。所以，我们的想法是说“真”是“有证据”。我知道证据。好的，有证据，哪里是可证明的？这里有一点担心。</p><p>Okay, so what was I going to say? I lost my thread. Oh, yes, right.
            So, the idea was we said a “true” is a “has a proof.” I know a proof.
            Okay, has a proof, where is provable? There’s a little worry here.</p>
        <p>好吧。我必须——弗兰克会边讲边向你解释清楚，但在计算机科学和逻辑分支中，“可证明”一词被严重滥用，这让事情变得非常混乱。所以，在这里我只是说有一个数学证明。我最终……我到底想说什么？我的意思不是“在某个预先定义的固定意义上有一个证明”。这只是意味着我知道一个证明。这是一个我们任何人都能理解的有说服力的论点。这是直觉逻辑的人性方面。这是沟通的原则，无论某种东西是有效或合法的沟通，无论它是否有效，无论我是否成功地将某种东西作为社会结构教给你——它都不是固定规则定义的。有规则，有已知有效的东西，但谁知道会出现什么发明？</p><p>Okay. I have to—Frank will make this very clear to you as he goes
            along, but there are gross abuses of the word “provable” in computer
            science and branches of logic that confuse matters a lot. So, here I
            just mean have a mathematical proof. By which I end up… What am I
            driving at? I do not mean “has a proof in some predefined fixed sense of
            the word.” It just means I know a proof. It’s a cogent argument that any
            of us can understand. This is the human aspect of intuitionistic logic.
            It’s a principle of communication, and whether something is a valid or
            legitimate communication, whether it works, whether I succeed in
            teaching you something as a social construct—it’s not defined by fixed
            rules. There are rules, there are things that are known to work, but who
            knows what invention might come up?</p>
        <p>好的，这就是这里最重要的。请谨慎使用这些词。不幸的是，您将陷入基于对“可证明”一词的误解的疯狂、无聊的讨论。我知道现在可能很难理解，但随着事情的发展，请重新审视这个问题。我希望弗兰克能进一步阐述我的观点。我相信他非常了解我的意思。所以，但我想说的是：它是否具有存在力，这意味着它全是关于“存在”某物。</p><p>Okay, so this is what’s important here. Be careful about these words.
            Unfortunately, you’re going to get into crazy, inane discussions based
            on misunderstandings of the word “provable.” I know it might be hard to
            grasp now, but as things develop, revisit the issue. I hope Frank will
            amplify my point. I’m sure he knows very well what I mean. And so, but
            the thing I want to get at is: is it has existential force, meaning that
            it’s all about “there exists” something.</p>
        <h2 id="proofs-as-existential-objects">作为存在对象的证明</h2><h2>Proofs as Existential
            Objects</h2>
        <p>你知道，我有一个证明。存在一个证明；它是可证明的，对吧？它是一个碗。好吧，所以它们里面有一种存在的力量。所以，我想做的是，我想稍微改变一下，谈谈它实际上意味着什么。</p><p>You know, I have a proof. There exists a proof; it is provable,
            right? It’s a bowl. Okay, so there’s an existential, some kind of
            existential force in them. So, what I want to do is I want to just
            change this a little bit and talk about what it means to actually be a
            proof.</p>
        <h2 id="notation-for-proofs-and-type-theory">证明符号和类型理论</h2><h2>Notation for Proofs and
            Type Theory</h2>
        <p>它是这样写的，这就是我们得到类型理论的对应关系的地方。所以，想法会说，“M 是 A 的证明。”好的，这就是想法。所以，我将有一个证明符号。所以，现在我们谈到我之前对你说的关于证明符号的内容。证明现在变得非常……有一种引导你走上这条路。当我和你讲完的时候，你——世界在你眼中看起来会与以前大不相同。如果那是真的，那就太好了。这就是重点。所以，所以我……</p><p>And it’s written like this, and this is where we get the
            correspondence to type theory. So, the ideas will say, “M is a proof of
            A.” Okay, that is the idea. So, I’m going to have a notation for proof.
            So, this is now where we get to what I was saying to you before about
            having a notation for proofs. That the proofs become now very… there’s a
            sort of leading you down this path. And by the time I’m through with
            you, you—the world will look rather different to you than it might have
            done before. And if that’s—if that’s true, that’s good. That’s the whole
            point. So, so what I’m…</p>
        <h1 id="type-theory-foundations-1.1-robert-harper">类型理论基础 1.1 — Robert Harper</h1><h1>Type Theory
            Foundations 1.1 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 3 日) — 37:02 <a href="https://youtube.com/watch?v=RZfY9FAzF7I">https://youtube.com/watch?v=RZfY9FAzF7I</a></p><p> 11
            years ago (Jan 3, 2014) — 37:02 <a href="https://youtube.com/watch?v=RZfY9FAzF7I">https://youtube.com/watch?v=RZfY9FAzF7I</a></p>
        <h2 id="summary-1">概括</h2><h2>Summary</h2>
        <p>该视频讨论了类型理论，重点关注了证明作为对象的概念。它解释了如何为程序（证明）分配类型，与变量的概念相似，以及替换（链接编辑）如何发挥关键作用。该视频还介绍了证明的定义相等和指称相等的概念，强调了意义相等和指称相等之间的区别。演讲者可能是罗伯特·哈珀，他强调了这些区别在依赖类型背景下的重要性。</p><p>The video discusses type theory, focusing on the concept of proofs as
            objects. It explains how programs (proofs) can be assigned types,
            drawing parallels to the idea of variables, and how substitution (link
            editing) plays a crucial role. The video also introduces the concepts of
            definitional and denotational equality of proofs, highlighting the
            difference between equality of sense and equality of reference. The
            speaker, likely Robert Harper, emphasizes the importance of these
            distinctions in the context of dependent types.</p>
        <h2 id="introduction-to-proofs-and-variables">证明和变量简介</h2><h2>Introduction to Proofs and
            Variables</h2>
        <p>希望能够引导您进入兔子洞，然后您将意识到外面还有另一个世界，我想您将再也不会以同样的方式看待事物。好的。</p><p>Hoping to do is to lead you down the rabbit hole, and then you will
            realize like there’s a whole other world out there, and I think you’ll
            never look at things the same way again. Okay.</p>
        <p>所以，这个想法是这样的：m 是 a 的证明。那么，让我们回到这个问题。所以，这个想法就是这样。哦，换句话说，m 被认为是一个对象，可以说是 a 类型。好的。这只是一个问题：你可以根据这个想法来考虑这个程序 m，对吧？程序 m 是 a 类型，或者 m 是命题 a 的证明。这没关系；你可以用任何一种方式看待它。这是同一件事。好的。</p><p>So, here’s the idea: m is a proof of a. So, let’s go back to this.
            So, this is the idea. Oh, so another way of saying it is that m, thought
            of as an object, can be said to be of type a. Okay. It’s just a question
            of: you can think of this program m, by this idea in, right? The program
            m is of type a, or m is a proof of proposition a. It doesn’t matter; you
            can look at it either way. It’s the same thing. Okay.</p>
        <p>所以，这就是想法。那么，这对应什么呢？好吧，这也回到了 Al Khwarizmi。（我看错了。</p><p>So, that’s the idea. So, what does this correspond to? Well, this
            also goes back to Al Khwarizmi. (I’m on the wrong page.</p>
        <h2 id="variables-and-al-khwarizmi">变量和花剌子米</h2><h2>Variables and Al-Khwarizmi</h2>
        <p>我已经滚动了。所以，我想转到这里。）这是变量概念的核心思想。因此，人类历史上最伟大的智力成就之一就是发明了变量的概念。所以，我们在这里要做的是使用变量这个概念。变量的概念是：如果我要有一个蕴涵，说明某事是某事的证明，假设我有一个某事的证明……好吧，如果你假设你有某事，但你只知道……你只知道它。我假设我有一个大于 100 的奇素数。我不知道它到底是什么，但我知道它是一个奇素数，而且我知道它大于 100。好的。</p><p>I already scrolled. So, I want to go here.) Which is the central idea
            of the notion of a variable. So, one of the greatest intellectual
            achievements of human history is inventing the idea of a variable. And
            so, what we’re going to do here is we’re going to use this notion of a
            variable. And the idea of a variable is: if I’m going to have an
            entailment that says something is a proof of a, on the assumption that I
            have a proof of a… well, if you assume that you have something, but you
            only know… you only know about it. I assume I have an odd prime greater
            than 100. I don’t know what it is exactly, but I know it’s an odd prime,
            and I know it’s greater than 100. Okay.</p>
        <p>这就是变量的概念。变量对象。所以，你要做的是，你不是假设 a 为真，而是假设我有一个 a 的证明。我们把它称为 a；给它起个名字。叫它 x。在数学书中，它通常是括号 10.3，对吧？好的。但我们将使用一个更友好的符号表示法，符号表示法。所以，我们将使用 x。好的。这是一个变量，就像你在学校学的一样，好吗？如果假设 x 是 a 的证明，那么 a，当然就是 a 的证明。这样，我们就得到了蕴涵的概念。这个真给出真的想法意味着我可以使用变量。所以，这是第一件事。所以，这是一个变量的概念。</p><p>So, this is what the idea of a variable is for. A variable object.
            So, what you do is you say, well, rather than assume a is true, I will
            assume that I have a proof of a. Let’s call it a; give it a name. Call
            it x. In a math book, it’s usually parentheses 10.3, right? Okay. But
            we’ll use a notation that is a little nicer, symbolic notation. So,
            we’ll use x. All right. Which is a variable, just like you did in
            school, all right? And if x is assumed to be a proof of a, then a,
            bloody well, is a proof of a. And so, we get this idea of the
            entailment. This idea that a true gives a true means that I can use a
            variable. And so, that’s a first thing. So, this is a notion of
            variable.</p>
        <p>那么，变量的概念是什么呢？变量的概念在计算机科学中被严重滥用。</p><p>Now, what is the notion of a variable? Well, the notion of a variable
            is grossly abused in computer science.</p>
        <h2 id="notion-of-variables-in-computer-science">计算机科学中的变量概念</h2><h2>Notion of Variables in
            Computer Science</h2>
        <p>所以，我要坚持……所以，这是我要坚持的另一个观点，即谨慎使用我们的术语。正如我即将证明的那样，我要坚持认为变量的概念——几乎任何你能想到的编程语言中都称之为变量的东西——不是变量。什么是变量？是你在学校学到的东西，好吧。你九岁时就学对了，好吧。然后有人搞砸了，好吧。</p><p>And so, I’m going to insist… So, this is another point in which I
            want to insist on being careful about our terminology. Just as I was
            about to prove it, I want to insist that the idea of a variable—that
            thing called a variable in practically any programming language you can
            think of—is not a variable. What is a variable? Is the thing you learned
            in school, okay. You had it right when you were nine years old, okay.
            And then somebody screwed you up, okay.</p>
        <p>我只是说你一开始就是对的。那么让我们回到你九岁的时候，变量的概念是什么？我不知道你是怎么想的，但当我第一次学习变量时，我们使用了一些小的几何图形，例如：盒子 + 3 = 7。盒子里有什么？你知道，好吧。这就是我们在这里用变量做的事情。这是花剌子模的发明，我想也是古印度数学家的发明。他的名字是什么？Brahmagupta。是吗？我说得对吗？有人能告诉我吗？对吗？我发明了变量这个概念，好吧。</p><p>And I’m just saying you were right in the first place. So let’s go
            back to like when you were nine years old, and what is the idea of a
            variable? I don’t know about you, but when I first learned about
            variables, we used little geometric figures, like: box + 3 = 7. What
            goes in the box? You know, okay. So this is what, what, what we’re doing
            here with variables. And this is the invention of al Khwarizmi, and I
            think also the ancient Hindu mathematicians. What is his name?
            Brahmagupta. Yes? Am I right? Somebody can somebody tell me? Is that
            right? I invented this notion of a variable, okay.</p>
        <p>所以，这就是我要说的：我想看看传递性这个概念是什么，因为我要说的是插入的概念，好吧。</p><p>And so, here’s where I’m getting at: I want to look at what this idea
            of transitivity is, because what I’m getting at is the idea of plugging
            in, okay.</p>
        <h2 id="plugging-in-variables">插入变量</h2><h2>Plugging in Variables</h2>
        <p>那么现在会发生什么？看我又把字母搞砸了。假设，基于 A 的假定但未知的证明，我可以建立 B 的证明。这就是第一行所说的。基于——我们称之为 Y——我不必这样做，但我会基于 B 的未知假定证明，我有一个 C 的证明。然后我想把它们结合起来。基于 A 的未知证明，我想以某种方式将它们组合成 C 的证明。</p><p>So what’s going to happen here now? Watch me screw my letters up
            again. So let’s say, on the basis of an assumed but unknown proof of A,
            I can build a proof of B. That’s what the first line says. And on the
            basis of—let’s call this one Y—I don’t have to, but I will, on the basis
            of an unknown, presumed proof of B, I have a proof of C. Then I want to
            combine these. On the basis of an unknown proof of A, I want to combine
            them in some way into a proof of C.</p>
        <p>我在这里做什么？我插入。如果我——如果我的字母正确——我将 N 称为 X、M，现在这称为替换或插入。稍后您将了解所有细节。我，我，我告诉过你。我挥动双手。这里的想法是，你就像在学校时一样。你知道，你有……我……哦，我搞砸了……我每次都搞砸了，好吧。我搞砸了。M 代表 X，N，对不起。转置字母是理所当然的。我不知道该告诉你什么。我现在做对了吗？这样可以吗？不，我没有。M 代表 Y。谢谢。好的，很好。是的，我只是想看看你是否醒了，好吧。</p><p>And what do I do here? I plug in. If I just—if I got my letters
            right—what I’ll call N for X, M, and this is called substitution or
            plugging in for now. You’ll get all of the details on this later. I, I,
            I sort of told you. I’m waving my hands. The idea here is you’re just
            like you did in school. You know, you have… Did I… Oh, that I messed… I
            every time I mess it up, okay. I messed it up. M for X, N, sorry.
            Transposing letters goes with the turf. I don’t know what to tell you.
            Did I do it right now? Is that all right? No, I didn’t. M for Y. Thanks.
            Okay, good. Yes, I just wanted to see if you’re awake, okay.</p>
        <p>这就是你在学校做的代数运算。你有一个多项式，其中一件事——可能你很小的时候就喜欢这样做——代入一些东西并进行计算，这很酷，对吧？当你第一次想到代数时，它真的很有趣。你会想，“哦，天哪，这太神奇了！”所以，这就是我们要做的。我们只是从计算机科学的角度描述代数的过程。这个的通俗术语是什么？事实上，有关于这个规则的诺顿书。它是什么？</p><p>So this is the plugging in that you did in school. You have a
            polynomial, and one of the things—probably you enjoyed this when you
            were really young—plugging in stuff and calculating is cool, like hell,
            right? It’s really fun when you first think of algebra. You think, “Oh
            my god, that’s amazing!” So, here’s what we’re doing. We’re just
            describing the process of plugging in from a computer science point of
            view. What is the pedestrian term for this? In fact, there are Norton
            books written about this rule. What is it?</p>
        <p>从计算机科学的角度来看，它应该叫什么？哦，嘘，你最好能告诉我。不，变量的概念，插入的想法，它对应什么？还有，你知道，诺顿书之类的东西，奥莱利书，不管它们叫什么，你知道，贸易书。不，我听不出来。在某种程度上，没有涉及任何函数，但你确实走在正确的轨道上。</p><p>What should it be called from a computer science point of view? Oh,
            boo, you better be able to tell me this. No, the notion of a variable,
            the idea of plugging in, what does it correspond to? And sort of, you
            know, Norton book kind of, kind of stuff, O’Reilly books, whatever
            they’re called, you know, trade books. No, I can’t hear. In a way, there
            are no functions involved, but you’re on the right track, really.</p>
        <h2 id="substitution-and-link-editing">替换和链接编辑</h2><h2>Substitution and Link
            Editing</h2>
        <p>是的，有人看看链接编辑。这被称为——我将其称为 ld 规则，只是为了挑衅——或链接编辑。链接编辑器所做的唯一一件事就是使用世界上最怪诞的语法执行替换。好的。点 o 文件是一些令人难以置信的神秘语法，但它们所实现的是替换。好的。这就是正在发生的事情。好的。所以，我称之为 ld 规则，只是为了好玩。好的，就像 Unix ld。好的。这就是正在发生的事情——这就是这里正在做的事情。</p><p>Someone, yes, look at link editing. This is called the—I’ll call this
            the ld rule, just to be provocative about it—or link editing. The only
            thing a linkage editor is doing is performing substitution with the
            world’s most grotesque syntax. Okay. Dot o files are some unbelievably
            arcane syntax, but what they’re achieving is substitution. Okay. This is
            what is going on. Okay. So, this I call the ld rule, just for fun. Okay,
            like Unix ld. Okay. That is what is being—that’s what is being done
            here.</p>
        <p>这只是替代。好的。再次注意，存在这种对应关系。因此，现在中间部分介于证明论方面和顺序论方面之间，我们在这里，或者最终是范畴论方面。这是类型论的观点。</p><p>It’s just substitution. Okay. And notice that again, there’s this
            kind of correspondence. So, this in the middle now is mediating, you
            might say, between the proof theoretic side and the order theoretic
            side, and we have here, or eventually, the category theoretic side. And
            this is the type theoretic view.</p>
        <h2 id="programs-as-variables-and-products">程序作为变量和产品</h2><h2>Programs as Variables and
            Products</h2>
        <p>所以，这里的想法是，我正在做元素，关于什么是程序的最基本的事情？好吧，变量是程序，我可以将它们插入另一个。我还没有给你任何真正的程序。好吧。所以，我要做的是给你一个真正的程序。好的。好的。我会在这张图表上做，我会把它放在这里。好吧，这将是——这些通常被称为产品或元组，我们不会用其他名字来称呼它们。</p><p>So, here the idea is that I’m doing the element, the most rudimentary
            things about what are programs? Well, variables are programs, and I can
            plug one into another. I still haven’t given you any honest to god
            programs. All right. So, what I’m going to do is give you an honest to
            god program. Okay. Okay. Which I will do on this chart, which I will put
            in here. Well, this will be—these are usually called products or tuples,
            and we won’t call them something else that I could call them.</p>
        <p>好的。那么，让我们弄清楚它应该是什么样子。好的。那么，我们可以用任何我们想要的方式来看待它。如果我从这里开始怎么样？好的。我从这个开始。那么，让我们看看这在程序方面意味着什么。它说，如果给定一个 x，它是 c，如果你能给我一个 m，它是 a，我就像在这里做这件事一样，对吗？如果你给了 ay，它是 c——事实上，我会坚持称它为 x，如果我这样做会让我的生活更轻松——然后给我一个 n，它是 b。</p><p>Okay. So, let’s figure out what that must look like. Okay. So, we can
            look at this any old way we want. How about if I start here? All right.
            I’ll start with this one. So, let’s look at what this means in terms of
            programs. It says, well, if given an x, which is of c, if you can give
            me an m, which is of a, I’m just like doing the doing the thing here,
            right? And if you’re given a y, which is of c—in fact, I’m going to
            insist on calling it x, going to make my life easier if I do that—then
            give me an n, which is of b.</p>
        <p>好的。所以，如果你从引理中得到了 a 的证明，如果你从同一个引理中得到了 b 的证明，那么基于这个引理，对不起，你就得到了 a 的证明，以及通常写成十字形或星号或哈希之类的东西，这取决于语言。</p><p>Okay. So, if you have a proof of a from the lemma, if you have a
            proof of b from the same lemma, then on the basis of that lemma, excuse
            me, you have a proof of a and what’s usually written cross or star or
            something, hash, and it depends on the language.</p>
        <h2 id="conjunctions-and-notations">连词和符号</h2><h2>Conjunctions and Notations</h2>
        <p>好的，乘以 b。那会是什么？那么，m 和 n 的内容是什么？这个合取的内容是什么？事实上，它们都是二的证明。合取应该是两个证明，我们将其写成有序对，并像这样写。这里发生的事情是，如果你假设一个合取，那么你可以通过引用它来获得第一个合取，比如说，x 的第一个，以及通过引用 x 的第二个，b 来获得第二个合取。</p><p>Okay, times b. What would that be? Well, what is the content of m and
            n? What is the content of this conjunction? It’s the fact that they’re
            both a proof of two. A conjunction ought to be two proofs, which we’ll
            write as an ordered pair, and write it like that. And what is going on
            here is if you assume a conjunction, then you can get the first conjunct
            by referring to it, let’s say, first of x, and the second conjunct by,
            say, second of x, b.</p>
        <p>哦，如果我要使用不同的符号，那就是符号问题。你会遇到的一件事是，每个独立字段都有既定的符号约定，所以当你试图让它们协调一致时，你会遇到一些小问题。所以在编程语言中使用楔形符号并不常见，但你可以。所以我就把它写成十字形。好的，因为这是更常见的做法。</p><p>Oh, and then if I’m going to use different notation, that that is
            there’s a notational thing right there. There are one thing you do run
            into is there are established notational conventions in each independent
            field, and so when you’re trying to make them all harmonize, you get
            into little creases. So it’s not so common to use a wedge in a
            programming language, but you could. So I’ll just write it as a cross.
            Okay, because that’s the more, more usual way of doing it.</p>
        <p>同样，把 meet 写成 cross 看起来会很奇怪，尽管你完全可以这么做。这只是其中之一；不同的传统汇聚在一起，然后相互碰撞。好的。所以我们有一个看起来像这样的符号。好的，这就是基本的架构。我的时间段是什么？嗯？哦，好的，很好。我状态很好。好的，很好。通常，会有一瓶水。是吗？</p><p>And by the same token, it would be rather weird looking to write a
            meet as a cross, although you perfectly well could. It’s just one of
            those things; there are different traditions that flowed together and
            then crashed into each other. Okay. So we have a notation that looks
            like that. Okay, so that’s like the basic architecture. What is my time
            slot? Huh? Oh, okay, good. I’m in good shape. Okay, good. Usually,
            there’s a bottle of water. Is it?</p>
        <p>某处有水吗？Jamboard Jim 走了吗？我需要一些水。他走了。好的，好的。那么，我刚才说什么了？好的，这是整体架构的说明。好的，这就是我们要做的，而且会非常丰富地开发。</p><p>Is there water somewhere? Does Jamboard Jim go? I need some water.
            He’s gone. Okay, okay. So, whatever was I saying? Okay, this is an
            illustrative of the overall architecture. Okay, so this is what we’re
            going to do, and this is going to be very richly developed.</p>
        <h2 id="overall-architecture-of-logic-type-theory-and-category-theory">逻辑、类型论、范畴论的总体架构</h2><h2>Overall
            Architecture of Logic, Type Theory, and Category Theory</h2>
        <p>但现在我想说一个切入点。好的。切入点与这些证明的方程性质有关。好的。所以我首先要讲的是整体架构，这些部分是如何组合在一起的。这样我们就有了逻辑或证明理论、类型理论和范畴理论的概念，或者我们在这里写的预序，这种代数结构。我想让你们看到这种很好的对应关系。</p><p>But now I want to get to a jumping off point. Okay. And the jumping
            off point has to do with the equational properties of these proofs.
            Okay. So the first thing I want to get across is is the overall
            architecture, how these parts fit together. So that we have the notion
            of logic or proof theory, type theory, and category theory, or pre
            orders that we’re writing over here, this kind of algebraic structure.
            And I wanted you to see the nice correspondence.</p>
        <p>当然，我已经向你展示了——谢谢你，弗兰克——我已经向你展示了，你知道，我已经向你展示了最简洁、最直接、最直接的情况。关于这一点还有很多话要说，我们将在下一节课开始。但在我们之前——让我跳过笔记中的几件事，因为我至少想设置一个特定的问题。哦，好的。是的。有两件事我想和你一起解决。</p><p>Of course, I’ve shown you—thank you, Frank—I’ve shown you the, you
            know, I’ve shown you the neatest, most straightforward, most direct
            case. There’s a hell of a lot more to say about that, which we’ll get
            started on in the next lecture. But before we—so let me just skip a few
            things in my notes because I would like to at least set up a particular
            problem. Oh, okay. Yes. There are two things that I would like to set up
            with you.</p>
        <p>给我一点时间。我得想一想。我得想一想我在这里想做什么。弗兰克，你打算谈谈否定吗？好的。好的，好吧。那么，我现在想做的是过一分钟再回到这个问题上。</p><p>Give me a moment here. I have to think. I have to think about what I
            want to do here. Frank, you’re planning to talk about negation? Okay.
            Okay, so all right. So, what I would like to do now is come back to that
            in a minute.</p>
        <h2 id="equivalence-of-proofs-and-dependent-types">证明和依赖类型的等价性</h2><h2>Equivalence of Proofs
            and Dependent Types</h2>
        <p>所以，我现在想做的是开始谈论证明等价性的开端。这就是我谈论依赖类型的正确起点。这就是我需要这个的原因——这部分是为了作为概述，部分是为了为接下来需要讨论的内容做准备。</p><p>So, what I would like to do now is start talking a little bit about
            the beginnings of equivalence of proofs. And this is where is the
            right—the right jumping off point for me to talk about dependent types.
            That’s why I needed this—this is partly to serve as an overview and
            partly to set up for what I need to talk about next.</p>
        <p>所以，我想要解决的问题——我现在就要开始研究——是：什么时候两个证明是相等的？</p><p>So, the question I want to get at—and I’m going to begin looking at
            right now—is the idea: When are two proofs equal?</p>
        <h2 id="equality-of-proofs">证明平等</h2><h2>Equality of Proofs</h2>
        <p>让我们这样写：m = n, a。这表示：什么时候是 m 和 n，或者说断言是：m 和 n 表达相同的证明吗？这就是我们在这里所做的。好的。</p><p>And let’s write it like this: m = n, a. Which is expressing: When are
            m and n, or just say that the assertion is: Are m and n expressing the
            same proof? This is what we’re doing here. Okay.</p>
        <p>因此，我们将有证明相等的概念。因此，这就是我们开始认识到证明是数学对象的想法的地方。好的。我们表达这个想法的方式之一是讨论其中两个证明相等的情况。好的。</p><p>So, we’re going to have the notion of equality of proofs. So, this is
            where we begin to get to the idea that proofs are mathematical objects.
            Okay. And one of the ways in which we express that idea is we talk about
            when two of them are equal. Okay.</p>
        <p>我现在想提出的是平等问题，以及证明平等的概念是什么？这最终成为依赖类型理论的核心，这就是我在这里的原因。好的。</p><p>And what I want to set up now is the—the questions of equality and
            what is the notion of equality of proofs? This ends up being completely
            central to the theory of dependent types, which is why I am where I am.
            Okay.</p>
        <p>到目前为止，你还听得懂吗？那么，我要说的是——这不是正确的话题。请稍等一下。这是一个比你想象的更微妙的问题。所以，我要做的是检查一下我在这里写下的术语。哦，是的。好的。好的。好的。好的。好的。</p><p>All right, with me so far? So, what I’m going to do is I’m going to
            talk about—that’s not the right spot. Give me a moment. This is a more
            subtle issue than you might think. So, what I want to do is check the
            terminology that I wrote down here. Oh, yes. Okay. Right. Okay. All
            right. Okay.</p>
        <h2 id="synthetic-and-analytic-judgments">综合判断和分析判断</h2><h2>Synthetic and Analytic
            Judgments</h2>
        <p>在我开始讨论平等之前，我需要先介绍一些其他概念，因为它对我们有很大帮助。好的。那么，让我们开始吧。我想介绍一下所谓的综合判断（你们马上就会明白这一点）和分析判断之间的区别。我们已经在黑板上举了一个例子，黑板上的一个例子就是我们说“a 为真”。这就是所谓的综合判断的一个例子。</p><p>Before I do what I need to do next about equality, I need to say
            some—I need to introduce some other—another concept because it will—it
            will help us a lot. Okay. So, let’s do this. So, what I want to do is I
            want to introduce a distinction between what is called a synthetic
            judgment—you’re going to see what the point of this in a minute—and an
            analytic judgment. And we’ve already have an example on the board—an
            example on the board is when we say “a is true.” It’s an example of what
            is called a synthetic judgment.</p>
        <p>这是与所谓的分析判断相对的术语。其思想是——这又回到了存在力量这一点——关键思想是它需要证据。在判断为真的情况下，证据就是证明。好的。在这种情况下，以及其他情况下，要正确地断言一个定理为真，你必须有证据。你说，“哦，你说它是真的。”那么，那是什么——给我看证据。如果你没有证据，你就只是在胡说八道。</p><p>This is the terminology versus what is called an analytic judgment.
            And the idea is—and this goes back to this point of having existential
            force—the key idea is that it requires evidence. Which, in the case of
            the judgment being true, is a proof. Okay. In this case, and others, to
            correctly assert that a theorem is true, you have to have evidence for
            it. You say, “Oh, you say it’s true.” Well, then what’s the—show me the
            proof. If you don’t have the proof, you’re just talking trash.</p>
        <p>音频的其余部分丢失了。除了正确地断言 A 为真之外，任何事情都需要证据。你必须真正去弄清楚它的含义，就像有些人证明某事为真一样。我想将其与我们的另一个判断进行对比，这里写为 M:A，这被称为分析判断。这通常被称为分析判断。可以说它是不言而喻的。我的意思是什么？这是在这个特定领域中证明搜索和证明检查之间的传统区别。好的。</p><p>The remainder of the audio is missing. Anything but to correctly
            assert that A is true requires evidence. You have to actually look to
            figure out what it means, as some and prove that something is true. I
            want to contrast that with our other judgment, which is written M:A
            here, which is called an analytic judgment. This is generally said to be
            analytic. Could be said to mean it’s self evident. What do I mean by
            that? This is the traditional distinction, in this particular domain,
            between proof search and proof checking. Okay.</p>
        <p>要确定 A 是否为真，我必须寻找证据。我的意思是，如果你愿意，你可以把它看作是一个机械过程。但你也可以把它看作是在你的办公桌上努力找出某个断言的证明。好吧。所以这是一个搜索的过程，没有办法绕过它。这有点痛苦。而这就是检查的想法。好吧，检查证明。如果我告诉你，不仅仅是今天是真的，这是证据。所以这是标准的教科书格式：模数语法 M:A。这就是你得到的。你可以将论证与它应该证明的东西进行比较，并检查它是否是事实。</p><p>To determine whether A is true, I have to search for a proof. I mean,
            you can think of that as a mechanical procedure, if you want. But you
            can also think of it as suffering, you know, in your over your desk,
            trying to figure out a proof of some assertion. Okay. So there’s a
            process of search, and there’s no, like, there’s no getting around that.
            That’s sort of a painful thing. Whereas this is the idea of checking.
            Okay, checking a proof. And if I, because if I say to you, not merely
            today is true, but here’s the proof. So that’s the standard textbook
            format: modulo syntax M:A. That’s what you get. You can compare the
            argument against the thing that it supposedly proves and check whether
            or not it’s the case.</p>
        <p>好的。所以它是不言而喻的。换句话说，它不需要进一步的证据。对吗？除了判断本身已有的东西之外，不需要任何证据。所以你需要的所有信息就在你面前。这就是你用来检查的信息。而在这里，你需要的信息，即证明，并不在你面前。你必须找到它。好的。这就是综合判断和分析判断之间的区别。这将在我和我所说的证明等价性中发挥作用。</p><p>Okay. So it’s self evident. In other words, it requires no further
            evidence. Right? Nothing in addition to what is present in the judgment
            itself. So all the information you need is right there in front of you.
            And that’s the information you use to do the check. Whereas here, the
            information you need, namely a proof, is not there in front of you. You
            have to find it. Okay. So that’s the distinction between a synthetic and
            an analytic judgment. This is going to play a role in what I and what I
            say about equivalence of proofs.</p>
        <p>是的。那又是什么？这些词……所以，在这种情况下，它们是由马丁·路德在一篇名为……的论文中分析的。那篇关于菜单逻辑常数的论文叫什么名字？以及逻辑定律的论证。那是一篇论文。另一篇论文叫做关于命题证明、判断证据的论文。就像这样。我现在忘了它叫什么了。马丁·路德有一些论文。我没想到我脑子里没有这些。我们会查一下的。</p><p>Yeah. What’s that again? The words… So, in this context, they were
            analyzed by, given by Martin Luther in a paper called… What is the name
            of that paper on the menu’s logical constants? And the justification for
            the logical laws. That’s one paper. And another one is called something
            about proof of proposition, evidence for a judgment. Something like
            this. I’ve forgotten what it’s called right now. There are some papers
            by Martin Luther. I didn’t expect I didn’t have them in the front of my
            mind. We’ll look them up.</p>
        <p>马丁·路德也有一些论文。我在这里所说的大部分内容都来自瑞典数学家马丁·路德，他的著作来自许多来源。但我想特别指出的是荷兰数学家布劳威尔，他对马丁·路德的著作产生了非常强大的影响。事实上，你可以认为马丁·路德对布劳威尔 1930 年代的初始思想进行了全面、全面的发展。</p><p>So, there are some papers by Martin Luther. Most of what I’m saying
            here is derived from Martin Luther, the Swedish mathematician, and his
            work is kind of derived from many sources. But I would say, in
            particular, the Dutch mathematician Brouwer, and it was a very, you
            know, powerful influence on Martin Luther’s work. In fact, you could
            look at Martin Luther as having really given full, full development of
            Brouwer’s beginning ideas from the 1930s.</p>
        <p>好的。这就是你想要的答案。这有什么合成的？这只是术语。用过吗？让我，让我这么说，我的意思是，术语是反对的，对吧？我不知道确切的原因，我不知道为什么我会<em>选择</em>这个特定的词语。好的，但是是的，这个的参考点是 Martin Löf。</p><p>Okay. That was the answer you wanted. What’s synthetic about it? It’s
            just the terminology. is that used? Let me, let me just say that, I
            mean, the terminology goes to cons, right? And I don’t know exactly, I
            don’t know exactly the <em>why</em> that particular choice of words off
            the top of my head. Okay, but yes, the reference point for this is
            Martin Löf.</p>
        <p>好的，现在，为了讨论依赖类型，我必须讨论证明的等价性。所以，我想讨论两个证明何时相等。有各种各样的概念。这就是有趣的地方。两个证明相等是什么意思？我们所说的相等是什么意思？这是另一种说法。相等是什么意思？这不是那么明显。它不是那么明显，因为，我的意思是，从本质上讲，它不是很明显。我不认为这个问题的答案应该是什么。而且，因为数学中的传统一直是忽略证明，认为它是我们出于某些随机原因写下来的东西，它们不是实际的数学对象。没有人真正研究过它们。好的。</p><p>Okay, so now, in order to talk about dependent types at all, I have
            to talk about the equivalence of proofs. So, I want to talk about when
            are two proofs equal. And there are various notions. That’s what’s
            interesting. What are two proofs equal? And what do we mean by equality?
            That’s another way of saying it. What is equality for it? It’s not so
            obvious. And it’s not so obvious because, I mean, intrinsically, it’s
            not very obvious. I don’t think what the answer to this should be. And
            moreover, because the tradition in mathematics has been to ignore proofs
            as being whatever it is we write down for some random reason, and
            they’re not actual mathematical objects. Nobody’s really studied them
            very much. Okay.</p>
        <p>因此，对两个证明相同的含义进行全面的科学研究属于证明理论、计算机科学和范畴论的主题。好的。</p><p>And so, it falls into the subject of proof theory and computer
            science and category theory to give a full scientific study of what it
            means for two proofs to be the same. Okay.</p>
        <p>所以，我想先开始。我将介绍三种层次。当我们讲完所有内容时，这将非常重要。好的。当我们讲完所有内容时，我们将讨论第三层次。我马上就讲到。好的。</p><p>So, what I want to do is to start out. I’m going to introduce kind of
            three kind of levels. And this is going to be very important by the time
            we get all finished. Okay. At by the time we’re done, we’ll be talking
            at the third level here. And I’ll get to that in a minute. Okay.</p>
        <h2 id="definitional-equality-and-equality-of-sense">定义平等与意义平等</h2><h2>Definitional
            Equality and Equality of Sense</h2>
        <p>因此，我将首先讨论定义平等。这是术语。好的。这只是术语。这将是一个分析性判断。很多时候人们会使用三条杠符号。但说实话，没有真正建立的惯例，每个人都完全遵守。所以，我写的任何东西都会有点类似，不是完全没有标准。所以，但有一种标准。好的。</p><p>So, the first one, of which I will call, is definitional equality.
            That’s the terminology. Okay. That’s just the term. And this is going to
            be, this is going to be an analytic judgment. A lot of times people will
            use the notation triple bars. But to be perfectly honest, there’s no
            real like established conventions that are completely adhered to by
            everybody. So, anything I write is always going to be a little bit like,
            not quite nothing is standard. So, so, but there’s a kind of standard.
            Okay.</p>
        <p>所以，我想谈的第一件事是定义平等。所以，我们不习惯这些想法。除非你有类型理论方面的经验，否则我不习惯，但如果你没有类型理论方面的经验，你可能不习惯这些区别。所以，现在我必须做一些事情，我必须花点时间，因为这有点棘手，对你来说可能看起来不太熟悉。当你开始做机械化时，你会遇到这个问题，例如。所以，这将是值得的。你会同意我的观点，是的。理解我的意思将是值得的。</p><p>So, the first thing I want to talk about is definitional equality.
            So, we’re not used to these ideas. I don’t, unless you have experience
            in type theory, but if if you don’t have experience in type theory,
            you’re probably not used to these distinctions. So, now I have to do
            something that I have to take my time here because it’s kind of tricky
            and might not look so familiar to you. And you’re going to run into this
            when you start doing mechanizations, for example, in. So, it’s going to
            be worth your while. You’ll agree with me, yes. It’s going to be worth
            your while to understand what I mean here.</p>
        <p>因此，我将这种定义平等的思想称为这种基线。对此有不同的解释方式。一种思考方式是将其视为意义平等，如果你遇到过这个术语的话。这与我接下来要做的完全不同，我将其称为——我必须想一个词，但没有标准词——外延平等。</p><p>So, this idea of definitional equality, I would call this sort of
            baseline. And there are different ways of explaining this. One way to
            think of it is as equality of sense, if you’ve encountered that term.
            This is distinct from what I’ll do next, which I’ll call—I had to think
            of a word, and there’s no standard word—denotational equality.</p>
        <h2 id="denotational-equality-and-equality-of-reference">指称相等和指称相等</h2><h2>Denotational
            Equality and Equality of Reference</h2>
        <p>我们稍后再讨论这个问题，它将变成综合的，并且它将是指称的平等。这就是——这就是我想讨论的术语：区别。这是弗雷格对意义和指称的区别。好的。</p><p>We’ll come back to that in a minute, which is going, and it’s going
            to turn out to be synthetic, and it’s going to be equality of reference.
            This is—this is the terminology I would like to get on the table: the
            distinction. This is Frege’s distinction between sense and reference.
            Okay.</p>
        <p>因此，弗雷格的著名例子是——有两个——这是从自然的，或者说不是特别数学的背景中得出的——晨星和昏星。两者都是金星。所以，它们无论如何都不是星星，但它们被称为晨星和昏星。它们有相同的指称；它们都指金星，但它们有不同的含义。它们承载着不同的含义，不同的信息内容。好的。</p><p>So, the famous example of Frege’s is the—there’s two—this is from a
            natural, like, or not not particularly mathematical context—is the
            morning star and the evening star. Both turn out to be the planet Venus.
            So, they’re not stars anyway, but they’re called the morning star and
            the evening star. They have the same reference; they both refer to
            Venus, but they have a different sense. They carry a different meaning,
            different information content. Okay.</p>
        <p>我不能——我不想花上几个小时讲解弗雷格对意义和指称的区别，但我希望你能理解，挑选数字的方式是有信息内容的。好的。</p><p>I can’t—I don’t want to give you know, hours and hours of lectures on
            Frege’s distinction between sense and reference, but I kind of hope you
            can feel okay that there is information content to how you pick out a
            number. Okay.</p>
        <p>举个例子。我再举一个我认为更令人信服的例子。在传统的逻辑处理中，世界上只有两个命题：真和假。好吧。所以，每一个数学定理要么表示——它指的是——真，要么指的是假。好吧。但很明显，这意味着，特别是，所有真实的定理都是等价的。但很明显，对吧？我的意思是，是的，这在某种程度上显然是正确的，但算术基本定理和微积分基本定理之间的信息内容存在巨大差异，它们都是正确的。</p><p>So, here’s an example. I’ll give you an example that I think is even
            more compelling. In the conventional treatments of logic, there are only
            two propositions in the world: true and false. Okay. So, every single
            mathematical theorem either denotes—it refers to—true or refers to
            false. Okay. But obviously, so it means, in particular, all true
            theorems are equivalent. But obviously, right? I mean, yeah, that’s
            obviously true in a way, but there’s a vast difference in information
            content between the Fundamental Theorem of Arithmetic and, let’s say,
            the Fundamental Theorem of Calculus, which are both true.</p>
        <p>好的。它们都是布尔值的复杂书写方式——非常复杂且截然不同的书写方式。但您可以说：“哦，好吧，它们都只是噪音；就像一场代表真值的沙尘暴。”好吧，这就是传统的故事。为什么？因为传统的故事完全无视意义。因为传统的故事并不重视证明本身在您的理论中的地位。好的。一旦您将证明本身带入画面，您就可以以非正式的方式感觉到，这个证明和那个证明是完全不同的东西，即使它们都代表真值。好的。这就是想法。好的。</p><p>Okay. They’re both complicated ways of writing down the Boolean
            one—very complicated ways of writing them down that are vastly
            different. But you could say, “Oh, well, they’re all just noise; it’s
            just like a big fat, you know, dust storm standing for true.” Well,
            that’s the conventional story. Why? Because the conventional story
            completely disregards sense. Because the conventional story gives no
            pride of place in your theory to the proof itself. Okay. As soon as you
            bring the proof itself into the picture, you can sense, in the informal
            way, that this proof and that proof are pretty different things, even
            though they both stand for true. Okay. That is the idea. All right.</p>
        <p>因此，对于定义相等，我们要做的就是尝试理解意义相等的概念，而指称相等是指称相等。然后，我们将得到一个更弱的概念，我将其称为等价或弱等价或同伦等价。我们将讨论这个概念。好的。这也是一个综合概念。今天我不会过多谈论这个概念，或者我只是稍微触及这个主题。</p><p>So, what we’re going to be doing with definitional equality is we’re
            trying to get at this idea of equality of sense, whereas this
            denotational equality is going to be equality of reference. And then
            we’re going to have an even weaker notion, which I will call equivalence
            or weak equivalence or homotopy equivalence. And we’ll get to that.
            Okay. And this will also be a synthetic notion. I will not say much
            about that today, or I will just barely touch on the subject.</p>
        <p>但是，等到我们在这些讲座中变得熟练和成熟时，你就会像天生就会一样使用这些内容，好吗？所以我会向你展示这一切是如何运作的。但让我们从真正的基础开始。那么，我所说的定义平等或意义质量是什么意思呢？即使我给了你这种感觉，我仍然没有把它固定下来。</p><p>But by the time we get good and sophisticated in the course of these
            lectures, you’ll be slinging the stuff around like you were born with
            it, okay? So I’ll show you how that all works. But let’s start out with
            the real real basics. So what do I mean by definitional equality or
            quality of sense? Even if I’ve given you that flavor, I still haven’t
            pinned it down.</p>
        <h2 id="example-of-definitional-equality">定义平等的例子</h2><h2>Example of Definitional
            Equality</h2>
        <p>我还没有确切地定义它是什么。所以，我给你举个例子。这是弗兰克将要详细阐述的东西。这个例子将从我这里黑板上的内容中得出。这个想法是这样的：它最容易解释。讨论可以在这边或那边进行，但最好还是努力一下。从符号上讲，使用类型理论符号是最方便的。所以，这就是我现在这样设置的原因，好吗？因为我希望证明是对象，所以我得到了它们，好吗？</p><p>I haven’t defined exactly what it is. So, I’ll give you a little bit
            of example. This is the kind of thing that Frank is going to develop in
            a lot of detail. The example is going to be derived from what I have on
            the board here. The idea is this: it’s most easy to explain. The
            discussion can be had on either this side or over here, but it’s best to
            work at it. It’s notationally the most convenient to work with the type
            theoretic notation. So, that’s why I’ve set it up the way it is now,
            okay? Because I want the proofs to be objects, so I’ve got them,
            okay?</p>
        <p>举个例子：如果你...如果你就是组合。那么这个想法就是：假设我用那条规则组合这条规则。组合这两条规则意味着什么呢？这意味着执行替换，我在板子上面已经提到了。那么假设这是我脑海中的<em>m ，这是上面的整体</em><em>m</em>，我将把它代入<em>n</em>中。n是<em>x</em>的第一个。因此，如果我将这个项（即<em>a </em><em>× b</em>）代入这个变量（即<em>a × b</em>），在这个表达式<em>m</em>中——m代表
            <em>y</em>，我把它写在那里<em>——m</em><em>代表</em>y <em>, </em><em>n</em>，那么我会得到什么？
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>An example of this is: if you… if you is the composition. So, the
            idea is: suppose I compose this rule with that rule. What does it mean
            to compose those two rules? It means to perform the substitution, which
            I have above the board here. So, suppose this is my <em>m</em>, okay,
            that I have in mind—this is the overall <em>m</em> up here—and I’m going
            to plug it into the <em>n</em>. The <em>n</em> is first of <em>x</em>.
            So, if I plug this term, which is <em>a × b</em>, for this variable,
            which is <em>a × b</em>, in this expression <em>m</em>—<em>m</em> for
            <em>y</em>, I wrote it there—<em>m</em> for <em>y</em>, <em>n</em>, then
            what do I get?
        </p>
        <p>好吧，如果我把这两个组合起来，我会得到<em>mn的第一个将是</em><em>a</em>的证明，假设这是
            <em>a的证明，这是</em><em>b</em>的证明，对吗？如果你……如果你正确计算出来，你看到了吗？如果你……如果你采用这条规则、这条规则和那条规则，并使用我在这里描述的替换原理，将这两个放在一起，你会得到这个复合表达式，因为这是正式的……这是用 mn<em>对</em>替换表达式<em>x的第一个中的</em><em>x</em>。如果你用我没有指定的波浪规则手工计算出来，但把它代入，你会得到它，好吗？
        <em></em></p><p>Well, if I compose those two, I will get first of <em>m n</em> will
            be a proof of <em>a</em> under the assumptions that this is a proof of
            <em>a</em> and this is a proof of <em>b</em>, right? If you… if you work
            it out right, do you see that? If you… if you take this rule and this
            rule and that rule and use the principle of substitution, which I
            described here, and you put those two together, you will get this
            compound expression, because this is formally… this is substitute the
            pair <em>m n</em> for <em>x</em> in the expression first of <em>x</em>.
            And if you calculate that out by hand, using wavy rules that I haven’t
            specified, but plug it in, you’ll get that, okay?
        </p>
        <p>现在，事情是这样的。我认为你可以用很多不同的方式来思考这个问题。一种思考方式是将其视为一个证明原理：我证明了这是<em>a</em>和<em>b</em>，所以我证明了<em>a</em>和
            <em>b</em>，然后我转过身来说，因此
            <em>a</em>。显然，这有点奇怪，因为我证明了 A ，证明了 B ，然后我说，“哦，顺便说一下，因此 A 。”你会说，“好吧，好吧。”我不能反对，但这有点荒谬的证明。
        </p><p>So, now here’s the thing. I think you can think of this in many
            different ways. One way to think of it as a principle of proof: I proved
            this is <em>a</em> and <em>b</em>, so I proved <em>a</em> and
            <em>b</em>, and then I turned right around and said, therefore
            <em>a</em>. Obviously, it’s a little strange because I prove A, I prove
            B, and then I say, “Oh, and by the way, therefore A.” You say, “Okay,
            okay.” I can’t object to that, but it’s sort of a cockamamie proof.
        </p>
        <h2 id="principles-of-definitional-equivalence">定义等价原则</h2><h2>Principles of
            Definitional Equivalence</h2>
        <p>原因是，让我在这里腾出空间，你不妨说这和 m 等价。这就是为什么不简化它的原因？我的意思是，你绕着谷仓走了一圈。你证明了两件事，以便提取出你证明的第一件事。好吧，管他结局如何；忘掉整个事情，只是把它简化成那样。按照类似的推理，你可以说，好吧，你证明了两件事，然后你转身从中抽出一件。那么为什么不只证明第二件事，然后就完事了呢？不要理会第一件事。所以我们得到了这个等价。所以这两个原则是谈论任何证明相等概念的起点。这些被称为定义相等，好吗？</p><p>And the reason is, and let me make room here, you might as well say
            that this is just as equivalent to m. That is why not just simplify
            that? I mean, you kind of went all the way around the barn here. You
            proved two things in order to extract out the first thing you proved.
            Well, the hell with the end; just forget about the whole business and
            just simplify it to be that. And by a similar line of reasoning, you can
            say, well, you proved two things, then you turned right around and
            pulled one out of it. So why not just prove the second thing and be done
            with it? Don’t bother with the first. And so we get this equivalence. So
            these two principles are kind of a starting point, okay, for talking
            about any notion of equality of proofs. And these are called
            definitional equalities, okay?</p>
        <p>另一种思考方式是，它是意义的平等。我们也可以将其视为，用计算机科学术语来说，我们可以将其视为符号执行。这有点像你在高中代数中学到的东西。你的计算概念包括，例如，为变量代入数字，然后应用算术规则。取 x² + 2x + 1，代入 7。7 乘以 7 等于 49，等等。然后你进行算术运算，得到结果。</p><p>Another way to think of this is that it’s, or equality of sense. We
            can also think of this as, to use computer science terminology, we can
            think of it as symbolic execution. This is kind of what you learned in
            high school algebra. Your notion of calculation involves, for example,
            plugging in numbers for variables and then applying the rules of
            arithmetic. You take x² + 2x + 1, you put in 7. 7 times 7 is 49, etc.
            And you do the arithmetic, and you get your result.</p>
        <p>所以这里有一个执行模型。也就是说，当人们教你代数时，不幸的是，他们没有——我很确定他们没有把这个给你。但他们在教你一门编程语言。事实上，所有编程语言，如果做得正确，都只是大而广义的多项式，好吗？这就是这里发生的事情。这就是它的想法。我只是要通过计算来概括这个计算的想法。如果你这样做，那么你就会得到这些美丽的对应关系，好吧，它们会一直延续下去，一切都很好。所以这就是我所认为的——暑期学校的全部意义，好吗？</p><p>So there’s an execution model there. That is, when people were
            teaching you algebra, unfortunately, they didn’t—I’m pretty sure they
            didn’t bring this out for you. But what they were doing is they were
            teaching you a programming language. And in fact, all programming
            languages, done properly, are just big, ass, generalized polynomials,
            okay? That’s what’s going on here. That’s the idea of it. I’m just going
            to generalize this idea of computing by calculation. If you do that,
            then you get these beautiful correspondences, okay, which go on and on
            and on, and everything is really nice. So that’s the thing that I sort
            of—the whole point of the summer school, okay?</p>
        <p>因此，这是定义等价性证明的两个原则。定义等价性的其他一些原则是什么？好吧，我甚至没有说它应该是等价关系，这是理所当然的。所以我们就在这里写 RST，这对所有这些原则都是正确的。</p><p>So these are two principles of proof of definitional equivalence.
            What are some other principles of definitional equivalence? Well, the
            ones that I kind of took for granted without even saying is it ought to
            be an equivalence relation. So let’s just write RST here, and that will
            be true for all of these.</p>
        <h2 id="congruence-principles">一致性原则</h2><h2>Congruence Principles</h2>
        <p>这些都应该是等价关系。所以很明显，无论你对定义等价、等价性的看法是什么，它都应该是一个等价关系。每个证明都是对称和传递地等于其自身，这完全说得通。好的，另外我们可以补充一点……这些被称为类似 beta 的规则。这就是为什么你稍后会看到它们。如果这种符号/术语对你没有吸引力，在你多学一点之后你就会喜欢的。好的。这些是符号执行规则。这是一种符号执行。你可以想——我不喜欢这个词，但人们经常使用它。我的意思是，没有——除了一些——我不知道他们到底在说什么，但我知道人们通常会这么说，所以我就这么说吧。好的，好的，好的。所以，好的，这就是第一和第二。</p><p>These are all supposed to be equivalence relations. So clearly,
            whatever your notion of definitional equivalence, equality is, it ought
            to be an equivalence relation. Every proof is equal to itself
            symmetrically and transitively, which makes perfect sense. Okay, plus we
            can add in… these are called, sort of, beta like rules. That’s why
            you’ll see them a little bit later. If that notation/terminology doesn’t
            appeal to you, it will after you learn a bit more. Okay. These are the
            symbolic execution rules. This is a symbolic execution. You can think—I
            don’t like that word, but people use it a lot. I mean, there’s
            no—there’s no other form of execution besides some—I don’t know what the
            hell they’re talking about, but I know that people usually say that, so
            I’ll say it. Okay, all right, okay. So, okay, so that’s first and
            second.</p>
        <p>现在，另一个有趣的事情是，你会期望它是所谓的一致性。一致性属性。例如，如果 m 和 m 素数是合取或乘积的相同证明，那么 m 素数的第一个和 m 素数的第一个应该是相同的证明。第二个也是一样。所以，我们会在这里写“第二个”、“第二个”和“b”。我们会有这样的一致性原则。此外，我们期望有进一步的一致性原则，例如，如果 m 与 m 素数相同，并且如果 n 与 n 素数相同，那么对 m、n 和 m 素数、n 素数应该是相同的。所以，那是——我说得对吗？是的，那应该是——那应该是相同的。好的。那些应该是相同的证明。所以，我们有这些所谓的一致性原则。</p><p>Now, the other interesting thing is, you would expect it to be what
            is called a congruence. Congruence properties. So, for example, if m and
            m prime are the same proof of, let’s say, a conjunction or product, then
            first of m and first of m prime ought to be the same proof. And
            similarly for second. So, we would write “second,” “second,” and “b”
            here. We would have principles of congruence like that. And moreover, we
            would expect to have further principles of congruence like if m is the
            same as m prime and if n is the same as n prime, then the pairs m, n and
            m prime, n prime ought to be the same. So, that’s—did I get it right?
            Yeah, that ought to be—that ought to be the same. Okay. Those should be
            the same proof. So, we have these are called congruence principles.</p>
        <p>好的。它可以在任何地方用等式替换等式。好的。所以我们当然应该有这个。现在出现了一个有趣的问题。那么，到目前为止你明白我的意思了吗？好的。因为没有这些规则，就没有明显的——我的意思是，我不会仓促下结论。如果我没有具体地提出这些规则，就没有理由认为它们成立。好的。我希望你——我希望你明白，如果你只是说这些方程成立，再加上它是一个等价关系，这并不意味着你可以在任何地方用等式替换等式。</p><p>Okay. It can replace equals by equals anywhere you see it. Okay. So,
            we should certainly have that. And now an interesting question comes up.
            So, are you with me so far? Okay. Because without these rules, there’s
            no obvious—I mean, I don’t jump to conclusions. If I didn’t put these
            rules in specifically, there would be no reason to think that they hold.
            Okay. I want you to—I want you to see that if you just say these
            equations hold, plus it’s an equivalence relation, it does not imply
            that you can replace equals by equals anywhere.</p>
        <h2 id="operators-respecting-definitional-equivalence">尊重定义等价性的运算符</h2><h2>Operators
            Respecting Definitional Equivalence</h2>
        <p>这是附加条件。好的。另一种说法是——这是一个口号——所有运算符都尊重定义等价性。好的。这是一个想法。好的。</p><p>It’s an additional condition. Okay. And another way of saying it
            is—is that this is a slogan y way to say it—all operators respect
            definitional equivalence. Okay. That’s an idea. Okay.</p>
        <p>这就是这些一致性规则的含义。因此，第一和第二，作为运算符，尊重定义等价性，这意味着如果你给它们等价的参数，它们会给你等价的结果。配对运算符也是如此。好的。</p><p>So, that’s the meaning of these congruence rules. So, first and
            second, as operators, respect definitional equivalence, meaning if you
            give them equivalent arguments, they give you equivalent results. And
            the same here for the pairing operator. Okay.</p>
        <p>现在，我想区分一下——然后我就结束了——定义平等和我称之为指称平等之间的区别。为了做到这一点，我需要再挥挥手，因为这只是讲座时间的问题。所以，一切都会在适当的时候揭晓。但我必须——比如，稍微含糊一下，因为你知道，你必须做点什么才能开始。</p><p>Now, I want to draw the distinction between—and then I’ll
            finish—between definitional equality and this, what I’ll call
            denotational equality. In order to do this, I need to wave my hands a
            little bit again, because it’s just a question of the timing of the
            lecture. So, everything will come out in due course. But I have to—like,
            a little bit fudge, because you know, you got to do something to get
            started.</p>
        <h2 id="denotational-equality-and-addition">外延相等和加法</h2><h2>Denotational Equality and
            Addition</h2>
        <p>好的。下面是我希望你们理解的例子。接下来的例子对于你们接下来在这里所做的一切都至关重要，特别是你们的机械化，它会让你发疯。好的，让我们看看。这个例子有点超出范围；它不是我开发的材料。好的。我们很快就会开发适当的材料，但这是这个想法。假设我们用递归方程定义加法如下。</p><p>Okay. So, here’s the example that I want you to understand. This next
            example is of the utmost importance for everything you’ll do the rest of
            the time you’re here, particularly with your mechanizations, and it’s
            going to drive you crazy. Okay, so let’s watch. So, this example is a
            little out of band; it’s not material I’ve developed yet. Okay. We’ll
            develop the appropriate material shortly, but here is the idea. So,
            let’s say we define addition by recursion equations as follows.</p>
        <p>在其他地方，一定有人做过——嗯，一定做过这样的事情——他们会说 a + 0 = a，他们会说 a + b 的后继就是 a + b 的后继。所以，这些是生成自然数的 0 和后继。这是一种非常简单的方法。好的，但我们假设我们以这种方式定义加法。所以，这是我们的定义。好的，这就是我们定义它的方式。所以，这是自然数加法的定义，它由零和后继生成。</p><p>Somewhere else, somebody must have—well, it must have done
            this—they’ll say a + 0 = a, and they’ll say a + the successor of b is
            the successor of a + b. So, these are 0 and successor for generating the
            natural numbers. This is a very simple way of doing it. Okay, but let’s
            just say we define addition in this manner. So, this is our definition.
            Okay, this is how we define it. So, this is the definition of addition
            on natural numbers, which are generated by zero and successor.</p>
        <p>好的，下面是我想向你们展示的重要内容。你们到目前为止明白了吗？我想区分意义平等和参考平等。所以，这就是我的想法。</p><p>Okay, so here’s the thing that I want to show you that’s important.
            Are you with me so far? I want to distinguish equality of sense and
            equality of reference. So, here is the idea.</p>
        <h1 id="type-theory-foundations-1.2-robert-harper">类型理论基础 1.2 — Robert Harper</h1><h1>Type Theory
            Foundations 1.2 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 9:57 <a href="https://youtube.com/watch?v=5XxefXAYsew">https://youtube.com/watch?v=5XxefXAYsew</a></p><p> 11
            years ago (Jan 2, 2014) — 9:57 <a href="https://youtube.com/watch?v=5XxefXAYsew">https://youtube.com/watch?v=5XxefXAYsew</a></p>
        <h2 id="summary-2">概括</h2><h2>Summary</h2>
        <p>本讲座讨论了数学基础中的定义相等与引用相等。罗伯特·哈珀解释说，虽然有些等式（如 2 + 2 = 4）在定义上是等价的，但其他等式（如 x + 0 = x 与 0 + x = x）则不是。区别在于定义的归纳性质以及某些等价关系需要通过归纳证明。演讲者强调，这些区别在计算机科学中很重要，对于更深入地理解依赖类型至关重要。</p><p>This lecture discusses definitional equality versus equality of
            reference in mathematical foundations. Robert Harper explains that while
            some equations, like 2 + 2 = 4, are definitionally equivalent, others,
            like x + 0 = x versus 0 + x = x, are not. The difference lies in the
            inductive nature of the definitions and the need for proof by induction
            for some equivalences. The speaker emphasizes that these distinctions
            matter in computer science and are crucial for a deeper understanding of
            dependent types.</p>
        <h2 id="definitional-equivalence-and-its-limits">定义等价及其局限性</h2><h2>Definitional
            Equivalence and its Limits</h2>
        <p>因此，首先，如果我写了类似二加二这样的数字，我声称这应该被视为在定义上等于四。让我不要每次都写冒号 n；让我这样写。对于自然数，应该是冒号 n，但我就这样写。这是一个真正的、正确的定义等价。好的。</p><p>So, first of all, if I wrote something like two plus two, I claim
            that this should be considered to be definitionally equal to four. Let
            me not write colon n every time; let me just write it like this.
            Supposed to be colon n for the natural numbers, but let me just write it
            like this. This is a true, correct definitional equivalence. Okay.</p>
        <p>嗯，因为二意味着，你知道，零的后继，对吧？这是四次，如果你应用这些方程，我们将它们视为定义等价，那么你就会得到一个正确的定义等价。这完全没有问题。</p><p>Well, because two means, you know, a successor of zero, right? This
            is the four times if you apply these equations, and we treat those as
            definitional equivalences as stated, then you’ll get this as a correct
            definitional equivalence. That’s no problem at all.</p>
        <p>现在开始变得有点棘手了。对于任何 x 和 n，好吗？通过蕴涵，你还可以证明，例如，x 加 0 在定义上等于 x。好吗？如果你愿意，我会把 n 放在这里，但我倾向于把它去掉。好吗？为什么？因为它是定义：x 加 0 等于 x。这是定义：它说如果你看到这种模式，它就等同于那个。所以，那就是 x。我故意选择 x 作为这里的变量，原因将在下一行中变得明显。但是，如果我有 x 和 n，那么 0 加 x 在定义上等同于 x 的情况并非如此。事实并非如此。你不会喜欢那样的。</p><p>Here’s where it starts to get a little sticky. For any x and n, okay?
            With entailment, you will also be able to show that, for example, x plus
            0 is definitionally equal to x. Okay? If you want, I’ll put n here, but
            I’ll tend to drop that off. Okay? Why? Because it’s the definition: x
            plus 0 is equal to x. Here’s the definition: it says if you see this
            pattern, it’s equivalent to that. So, that’s x. I deliberately chose x
            to be a variable here for the reason it will become apparent in the next
            line. However, it is not the case that if I have x and n, that 0 plus x
            is definitionally equivalent to x. This is not the case. You’re not
            going to like that.</p>
        <p>好的。原因是：定义等价的概念是仅由定义引起的等价关系。它是所涉及的运算符的定义给出的最小一致性。因此，对于第一个例子，我使用第一和第二。我通过这个方程定义运算符。我取最小一致性。在这里，我通过这些方程定义加法，我取最小一致性。这不会在那个关系中。</p><p>Okay. And the reason is: the notion of definitional equivalence is
            the equivalence relation that’s induced by the definitions only. It’s
            the least congruence given by the definitions of the operators involved.
            So, with respect to the first example, I use first and second. I define
            the operators by this equation. That I take the least congruence. Here,
            I define addition by these equations, and I take the least congruence.
            This will not be in that relation.</p>
        <p>好的。原因是：这在右边是归纳性的，你无能为力。这只是一个变量。没有定义规则适用，因为 x 是一个变量。它不是零。它不是后继。</p><p>Okay. The reason is: this is inductive on the right, and there’s
            nothing you can do. This is just a variable. No definitional rule
            applies because x is a variable. It’s not zero. It’s not a
            successor.</p>
        <p>然而，为了证明这一点，你可能会说：“但等一下。它们代表的是同一个东西。”哦，没错。它们具有指称性质；它们都指称 x，无论 x 是什么。明白吗？它们具有相同的指称，但它们在定义上并不等同。</p><p>In order to prove, however, you might say, “But wait a minute. They
            stand for the same thing.” Oh, that’s true. They have the quality of
            reference; they both refer to x, whatever x may be. Okay? They have the
            same reference, but they are not definitionally equivalent.</p>
        <p>然后，还有更多介于两者之间的例子，可能会让人抓狂。例如，你将能够证明——我在这里写了一个很好的例子，看起来很迷人。我写了什么？哦，是的。x 的后继在定义上等价于 x 加一。这是有效的。为什么？因为定义等价是对称的。因为它是对称的。x 加一意味着 x 加零的后继。x 加零的后继是 x 加 0 的后继，而 x 加 0 在定义上等于 x。它起作用了。但看起来非常相似的东西不能作为定义相等的原则。例如，x 加——不，对不起——x 的后继不幸在定义上不等于一加 x。你不会喜欢这个；它们在定义上不相等，好吗？</p><p>Then, there are more kind of in betweeny kind of examples which can
            be maddening. So, for example, you will be able to prove—I had a nice
            one written down here that looked beguiling. What did I write down? Oh,
            yeah. That the successor of x is definitionally equivalent to x plus
            one. This is valid. Why? Because definitional equivalence is symmetric.
            Because it’s symmetric. x plus one means x plus successor of zero. x
            plus successor of zero is successor of x plus 0, and x plus 0 is
            definitionally equal to x. It worked. But things that look very similar
            to that do not work as principles of definitional equality. So, for
            example, x plus—no, excuse me—the successor of x is unfortunately not
            definitionally equal to one plus x. You’re not going to like that; those
            are not definitionally equal, okay?</p>
        <p>原因是，我可以向你证明这一点，但我还没有开发出这些方法。我可以向你证明这一点，但事实并非如此。原因是，你不可能修改它来使这些规则之一适用，因为这是一个变量，好吗？</p><p>And the reason is, there are ways I can prove this to you, which I
            have not developed. I can prove this to you, but it is not the case. And
            the reason is, there’s no way you’re going to massage this around to
            make one of these rules apply, because that’s a variable, okay?</p>
        <p>然后，更糟糕的例子开始出现。例如，如果你给我两个变量 x 和 y，你不能指望 x 加 y 在定义上等于 y 加 x。事实并非如此。原因是，从定义上讲，没有办法修改这个等式，使这些规则之一适用，并使等式成立。缺少什么？</p><p>And even worse examples then start coming up. For example, if you
            give me two variables, x and y, you cannot expect x plus y to be
            definitionally equal to y plus x. It’s not. The reason is,
            definitionally speaking, there’s no way to massage this equation to make
            one of these rules apply and to get the equation to be there. What is
            missing?</p>
        <h2 id="proof-by-induction-and-analytic-judgments">归纳证明和分析判断</h2><h2>Proof by Induction
            and Analytic Judgments</h2>
        <p>所以，在所有失败的证明中，这个是失败的。它缺少的是归纳证明的原理，好吗？因为归纳证明的作用是，如果你有一个涉及变量的方程，那么证明它对所有基本实例都成立就足够了。如果它对零、一、二、三、四、五、六等等都成立，直到所有自然数，如果所有这些都是真的，那么它对变量也成立。但这是一种证据形式，而证据形式正是​​你在分析判断中没有的东西，好吗？</p><p>So, from the ones that fail, this one has failed. What is missing is
            a principle of proof by induction, okay? Because what proof by induction
            does is it says if you have an equation involving a variable, it’s
            sufficient to show that it holds for all the ground instances. If it
            holds for zero, and for one, and for two, and for three, and for four,
            and for five, and for six, and so on, through all the natural numbers,
            if all of those things are true, then it holds for the variable. But
            that’s a form of evidence, and a form of evidence is exactly what you
            don’t have for an analytic judgment, okay?</p>
        <h2 id="equality-of-reference-vs.-definitional-equality">引用相等与定义相等</h2><h2>Equality of
            Reference vs.&nbsp;Definitional Equality</h2>
        <p>因此，定义等价是分析性的。它必须是不言而喻的。任何需要额外证据的东西，比如归纳证明，都是综合的。最好的综合等价将被称为——我称之为指称等价或指称相等。因此，从指称相等的意义上来说，它们是相等的，但它们在定义上并不相等。然后我就可以去掉 x 了。</p><p>So, a definitional equivalence is analytic. It has to be self
            evident. Anything that requires additional evidence, like a proof by
            induction, is going to be synthetic. And the finest synthetic
            equivalence is going to be called—I’ll call it denotational equivalence
            or equality of reference. So, it will be true, then, in the sense of
            equality of reference, that these are equal, but they’re not
            definitionally equal. Then I can get rid of the x’s.</p>
        <p>瞧，我警告你，我的符号——没有人的符号是标准的。所以，我只是使用我认为有吸引力的符号，好吗？</p><p>See, and I’m warning you that my notation—nobody’s notation is
            standard. So, I’m just using a notation at the moment that I find
            appealing, okay?</p>
        <p>所以，从引用相等的意义上来说，这些是有效的方程。从定义相等的意义上来说，它们不是有效的方程，明白吗？</p><p>So, those are valid equations in the sense of equality of reference.
            They are not valid equations in the sense of definitional equality,
            okay?</p>
        <p>所以，这是我想讲的第一点。</p><p>So, that is the first point I would like to get at.</p>
        <h2 id="homotopic-equivalence-and-dependent-types">同伦等价与依赖类型</h2><h2>Homotopic Equivalence
            and Dependent Types</h2>
        <p>我们会说——我们会——我认为我已经完成了。我将通过引入同伦的概念在这个方向上走得更远。我们稍后会谈到这个。所以，这是高维或同伦等价，我稍后会谈到。我不会这样做。我不会这样做。我现在不会这样做。我会回到那个问题，好吗？或者，是否可能因为某些定义没有得到解决而做得很好？</p><p>And we’ll call—we’ll—I’ll consider myself to be finished. I’m going
            to go even further in this direction by introducing the notion of a
            homotopy. And we’re going to get to that a little bit later. So, this is
            higher dimensional or homotopic equivalence, and I’ll get to that later.
            I’m not going to do that. I’m not going to do that. I’m not going to do
            that right now. I’ll get back to that, okay? Or is it possible to do
            well because some of the definitions aren’t committed?</p>
        <h2 id="well-definedness-and-the-murkiness-of-definitions">定义明确与定义模糊</h2><h2>Well-Definedness
            and the Murkiness of Definitions</h2>
        <p>哦，是的，问题是，你知道，在某个时候你必须以一种清晰的方式写下一个定义，一个定义良好的定义。所以，我使用了一个特定的定义原则，我告诉你：我用这些方程来定义加法。你同意我的观点，这是一个有效的定义吗？如果你开始检查越来越多的条件，好吗？很快，它就变得不清楚了。也许你没有定义你想要的函数。也许现在一切都相等了。</p><p>Oh yeah, well, the question is, you know, at some point you have to
            write down a definition in a way that’s clear, that it’s well defined.
            So, I’m using a particular principle of definition where I say to you:
            I’m defining addition by these equations. You agree with me that it’s a
            valid definition? If you start checking in more and more conditions,
            okay? Pretty soon, it becomes unclear. Maybe you didn’t define the
            function you wanted to. Maybe everything is equal to everything now.</p>
        <p>也许它仍然被定义为多个值，并且变得模糊。所以，我所做的是……所以你会遇到的情况是：情况总是如此。会有一些公认的定义形式，然后一旦你确定了这些形式，你就会遇到这种区别。换句话说，这个例子没有什么特别之处。它很好地说明了你会一次又一次遇到的事情，好吗？</p><p>Maybe it’s still defined as multiple values, and it becomes murky.
            So, what I was doing is… so what will happen to you is: it’s always
            going to be the case. There’s going to be some accepted forms of
            definition, and then as soon as you set those down, then you’re going to
            run into distinctions of this flavor. In other words, there’s nothing
            rigged or special about this example. It’s quite illustrative of the
            thing you’re going to run into over and over and over again, okay?</p>
        <p>这会成为你做研究时的祸根，好吗？它会让你发疯。我向你保证，好吗？这是一个大问题。我们在传统的教科书数学中不习惯它。一切都是平等的，均衡的。没有人关心平等的形式和细微的区别。在传统环境中，也就是我们正在做的事情中，这很重要，因为一个可以根据另一个来计算，因为它们表示相同的东西。这很重要，就像……意义，好吗？对计算机科学家来说很重要。这就是我们从事这一行业的原因，好吗？</p><p>And it’s going to be the bane of your existence when you’re doing
            your research, okay? It will drive you crazy. I promise you, okay? It’s
            a major issue. We’re not used to it in conventional, like textbook math.
            It’s all equal, equilibrium. Nobody cares about forms of equality and
            fine grained distinctions. In a traditional setting, which is what we’re
            doing, it matters because one can be computed in terms of the other is
            different from they denote the same thing. And that matters, like the…
            the sense, okay? Matters a lot to a computer scientist. And so that’s
            why we’re in that business, okay?</p>
        <h2 id="computer-science-perspective-on-equality">计算机科学视角下的平等</h2><h2>Computer Science
            Perspective on Equality</h2>
        <p>所以，从计算机科学的角度来看，这没问题。我们对程序本身感兴趣。证明是数学对象。我关心这些区别。我不能只是敷衍了事，这是常规做法。此外，我们很多人认为这是一种更好的数学方法，好吗？但这是一个更有争议的问题，好吗？但无论如何，我们关心这些区别。所以，你会注意到，当我们在这里完成所有工作时，有很多类似这种细节工作。但正是这些让整个事情联系在一起，让人如此满意，你知道吗？这一切都很重要。所以，这真的……我希望你会看到它非常漂亮。</p><p>So, from a computer science point of view, it’s okay. We’re
            interested in the programs themselves. The proofs are mathematical
            objects. I care about such distinctions. I can’t just gloss over them,
            which is the conventional thing to do. Moreover, a lot of us believe
            this is a better way to do math anyway, okay? But that’s a bit more
            contentious issue, okay? But, but at any rate, okay, we care about these
            distinctions. So, you’ll notice that as we go through all of our work
            here, there’s a lot of like this kind of detail work in a way. But it’s
            that’s what leads to the whole thing hanging together and being so
            satisfying, you know? It all matters. And so, it’s really… I hope that
            you’ll see that it’s quite beautiful.</p>
        <p>所以，下次我会继续讨论指称相等和意义相等。我可能会说一些关于同态等价的事情，但那会稍微提到一点。我必须开发很多机器才能真正做到这一点。所以，我会给你介绍一下。然后我会谈论依赖类型。所以从现在开始我会分开讨论。但相等的概念对于理解依赖类型的工作原理和含义至关重要。这就是为什么我需要在这堂课中介绍它。好的，这是对你将要做的事情的概述，也是我将要做的事情的起点。好的。谢谢你的关注。</p><p>So, what I’ll do is I’ll pick up next time in talking about equality
            of reference and equality of sense. I might say a few things about
            homomorphic equivalence, but that will come up a little. I have to
            develop a lot of machinery before I can really do that justice. So, but
            I’ll give you a flavor about it. And then I will then be talking about
            dependent types. And so I will be diverging, okay, from this point on.
            But the idea of equality is central to understanding how dependent types
            work and what they’re about. That’s why I needed to cover this in this
            lecture. Okay, so this is an overview of the kind of thing you’ll be
            doing, and a starting point for what I’ll be doing. All right. Thanks
            for your attention.</p>
        <h1 id="type-theory-foundations-2.0-robert-harper">类型理论基础 2.0 — Robert Harper</h1><h1>Type Theory
            Foundations 2.0 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 37:13 <a href="https://youtube.com/watch?v=upWuoYAvXVA">https://youtube.com/watch?v=upWuoYAvXVA</a></p><p> 11
            years ago (Jan 2, 2014) — 37:13 <a href="https://youtube.com/watch?v=upWuoYAvXVA">https://youtube.com/watch?v=upWuoYAvXVA</a></p>
        <h2 id="summary-3">概括</h2><h2>Summary</h2>
        <p>视频讨论了有序结构，并将其与证明理论进行了比较。介绍了具有最大和最小元素以及蕴涵关系的格结构。演讲者将这些与直觉命题逻辑联系起来，强调了 Heyting 代数的代数结构。这是一个笛卡尔封闭预序，视频将其与布尔代数进行了对比，强调并非所有命题在直觉逻辑中都是可判定的。还讨论了蕴涵的结构属性，如弱化、收缩和交换。演讲者认为这些概念是类型理论和逻辑的基础。</p><p>The video discusses ordered structures, comparing them to proof
            theory. A lattice structure, with greatest and least elements, and
            entailment relations, is presented. The speaker connects these to
            intuitionistic propositional logic, highlighting the algebraic structure
            of a Heyting algebra. This is a Cartesian closed pre-order, and the
            video contrasts it with Boolean algebra, emphasizing that not all
            propositions are decidable in intuitionistic logic. Structural
            properties of entailment, like weakening, contraction, and exchange, are
            also discussed. The speaker argues that these concepts are fundamental
            to type theory and logic.</p>
        <h2 id="ordered-structures-and-proof-theory">有序结构与证明理论</h2><h2>Ordered Structures and
            Proof Theory</h2>
        <p>是的，现在弗兰克已经有机会发言了，我可以更好地完成我今天早上提出的几个观点。</p><p>Yeah, now that Frank has had a chance to speak, I’m in a better
            position to finish off a few points that I began to make this
            morning.</p>
        <p>所以，我们正在研究的是这些类型的有序结构。我们正在研究一类有序结构，并将它们与证明理论进行比较。我们正在研究这里，我想为您稍微充实一下，以便您了解发生了什么。</p><p>So, what we’re looking at are these kinds of ordered structures. We
            had a certain class of ordered structures that I was looking at,
            comparing them to proof theory. We’re looking over here, and I want to
            just flesh this out a little bit for you so that you can see what’s
            going on.</p>
        <p>我们建立的想法是，我们有一个小于或等于，它是自反的和传递的。我就写 RT 在那里。好的。这里我们有一个要处理的蕴涵关系。</p><p>What we set up was the idea that we have, well, we have a less than
            or equal to, which is reflexive and transitive. I’ll just write RT
            there. Okay. And here we have an entailment relation that we’re dealing
            with.</p>
        <p>因此，我们说的是，我们有一个最大的元素，我们称之为“top”。有一个小于或等于 top 的元素，从理论上讲，如果仅从“真”的角度来看，那么无论“a”何时为真，“top”在每种情况下都是真的。也就是说，它是平凡真命题。</p><p>So, what we said is, well, we have something—a greatest element,
            which we call “top.” There’s a less than or equal to top, which, on the
            first theoretic side, if you just look at it in terms of “true,” would
            be that regardless of whenever “a” is true, nevertheless, “top” is true
            in every single case. Which is, it’s the trivially true proposition.</p>
        <h2 id="semilattice-structure-and-eliminationintroduction-rules">半格结构和消除/引入规则</h2><h2>Semilattice
            Structure and Elimination/Introduction Rules</h2>
        <p>所以，我们有了这个。然后我们谈到了“相遇”。所以，我们有这个半格子结构。所以，我们有——嘿，让我们——这部分是今天早上的重复。好的。我们写了这个——所以我们在这里写成：“a”和“b”为真意味着“a”为真和“b”为真。</p><p>So, we had that. Then we spoke of having “meet.” So, we have this
            semi lattice structure. So, we have—hey, let’s—this part is a repeat of
            this morning. Okay. And we wrote this—so we wrote that over here as: “a”
            and “b” true entails “a” true and “b” true.</p>
        <p>所以，我们有了这个。然后我们说这是最大的下限。所以，我们有这个——在那之前应该是“b”。所以，“c”小于或等于“a”楔“b”。所以，这就是规则。这就是——这些对应于弗兰克所说的消除规则。</p><p>So, we had that. And then we said it was the greatest lower bound.
            So, we have this—before that should be “b.” So, then “c” is less than or
            equal to “a” wedge “b.” So, that’s the rule. This is the—these
            corresponded to what Frank called the elimination rules.</p>
        <p>然后介绍规则是：如果“a”为真，则结果为“b”，让我们看看……让我们这样做，使它们对齐。好的。“c”为真，则结果为“a”为真，而“c”为真，则结果为“b”为真，然后“c”为真，则结果为“a”和“b”为真。所以，这就是我们今天早上所说的。</p><p>And then the introduction rule is: if “a” true gives us “b,” let’s
            see… let’s do this so it lines up. Okay. “c” true gives us “a” true, and
            “c” true gives us “b” true, then “c” true gives us “a” and “b” true. So,
            that’s where we said this morning.</p>
        <p>然后，如果你加上 Frank 和你一起做的这些额外事情，那么我们还有“a”。所以，我们可以把它们看作公理。我会在它们上面写一条线。它们是没有前提的规则。</p><p>Then, if you add in this additional stuff that Frank did with you,
            then we also have “a.” So, we can think of these as just axioms. I’ll
            write a line over them. They’re rules with no premises.</p>
        <h2 id="dualization-and-join">对偶化和连接</h2><h2>Dualization and Join</h2>
        <p>所以，我们就得到了它的对偶化。所以，我们有一个最小元素。我们知道一切都小于“a”，但底部小于“a”。这就是如果“假”为真，那么对于任何“a”来说，任何事情都是真的。所以，这就是消去形式。</p><p>So, then we have the dualization of that. So, we have a least
            element. We have that everything is less than “a,” but the bottom is
            less than “a.” And that’s just the idea that if “false” is true, then
            anything is true for any “a.” So, that’s the elimination form.</p>
        <p>然后我们想到了“连接”的概念——所以这是零元连接。我们有 a ≤ a 或 b，且 b ≤ a 或 b。a 连接 b，因为如果将其视为最小上界，它高于所有上界。因此，作为上界，它意味着 a 为真意味着 a 或 b 为真，而 b 为真意味着 a 或 b 为真。所以，到目前为止你已经明白了。然后它是所有上界中最小的，对吗？</p><p>And then we have the idea that the idea of “join”—so this is the
            nullary join. We have that a ≤ a or b, and b ≤ a or b. a join b, because
            if considered as the least upper bound, it is above all upper bounds.
            So, being an upper bound, it means that a is true entails a or b is
            true, and b is true entails a or b is true. So, you’ve got that so far.
            And then it’s the least of all the upper bounds, right?</p>
        <p>因此，如果 a 小于或等于 c 且 b 小于或等于 c，那么如果 c 是 a 和 b 的上限，则 c 必须至少与 a 或 b 小于或等于 c 的连接一样大。正如您在 Frank 的讲座中看到的，我在这里就写出来了，这对应于这个想法：如果 a 为真则意味着 c 为真，如果 b 为真则意味着 c 为真，那么 a 或 b 为真则意味着 c 为真。</p><p>So, that says if a is less than or equal to c and b is less than or
            equal to c, so if c is an upper bound for a and b, then c has to be at
            least as big as the join a or b is less than or equal to c.&nbsp;And as you
            saw in Frank’s lecture, I’ll just write it over here, that corresponds
            to the idea: if a is true entails c is true, and if b is true entails c
            is true, then a or b is true entails c is true.</p>
        <p>所以，它们是相同的；这是我们在那里看到的完全相同的结构。</p><p>So, that’s the same; this is the exact same structure, okay, that we
            have there.</p>
        <h2 id="lattice-structure-and-implication-rules">格结构与蕴涵规则</h2><h2>Lattice Structure and
            Implication Rules</h2>
        <p>现在，我没有给自己留出足够的空间，好吧。所以，这解决了……所以，现在，我们有一个格的结构，好吗？这是术语。所以，它是所有有限交点和连接的预序，好吗？所以，这只是根据定义。这在很多时候被称为格，特别是在计算机科学中，人们随意使用“格”这个词，认为它可以表示他们喜欢的任何意思，比如他们会在 Java 或其他语言中提到子类型格，但它不是格。</p><p>And now, I didn’t quite leave myself enough room, okay. So, that
            takes care of… So, at this point, we have the structure of a lattice,
            okay? That’s the terminology. So, it’s a pre order with all finite meets
            and joins, okay? So, that’s just by definition. That’s called a lattice
            a lot of times, especially in computer science, that people throw around
            the word “lattice” and think that it can mean anything that they feel
            like it meaning, like they’ll refer to the subtyping lattice in, you
            know, Java or something, and it’s not a lattice.</p>
        <p>你没有连接，好吗？所以，我们最好坚持既定的、有意义的术语。这就是格的含义。所以，这是一个格结构。此外，弗兰克有一些蕴涵规则，我想这样做……</p><p>You don’t have joins, okay? So, it’s better if we stick to
            established and meaningful terminology. So, this is what is meant by
            what is meant by a lattice. So, this is a lattice structure. And then,
            in addition, Frank had some rules for implication, and the way I want to
            do that…</p>
        <h2 id="different-versions-of-implication">不同版本的暗示</h2><h2>Different Versions of
            Implication</h2>
        <p>我们可以采用不同的方法。让我先找到我在 gym 上写下的内容。我需要一点时间才能找到方法。好的，我马上就去。好的，它去哪儿了？哦，在那里，对吧？好的。因此，我想清楚地写下不同版本中的一个版本。因此，这对应于以下想法。因此，一种是，如果我们……一种写下它的方法是说，如果我们知道 a 为真，并且我们还知道 a 意味着 b 为真，那么我们就知道 b 为真。</p><p>there’s different ways we can do it. Let me just find what I wrote
            down here on the gym. It’s going to give me a second while I find my
            way. All right, I’ll get to that in a minute. Okay, where did it go? Oh,
            there it is, right? Okay. So, one version of the different versions of
            it, I wanted to write it down clearly. So, which corresponds to the
            following idea. So, one is that if we… one way to write this down is to
            say if we know a is true, and we also know that a implies b is true,
            then we know b is true.</p>
        <p>这是一条公理。另一条公理是另一条规则，它表示如果 c 为真且 a 为真，则 b 为真，然后考虑到 c 为真，我们知道 a 意味着 b 为真。所以，这是蕴涵引入，而以某种形式，这是蕴涵消除。有略微不同的方法来表述它。例如，你可以用它作为前提，然后应用蕴涵。我的意思是，它有不同的表述，但它们都等同于同一件事。好的。</p><p>That’s an axiom. And another axiom is another rule that comes up here
            that says if c is true together with a is true gives us that b is true,
            then with the ambient c is true, we know that a implies b is true. So,
            this was the implication introduction, and in one form or another, this
            is the implication elimination. There are slight different ways to
            formulate it. For example, you could use this as a premise and then
            apply entailment. I mean, there are different formulations of it, but it
            all sort of amounts to the same thing. Okay.</p>
        <p>从序理论的角度来看，这句话的意思就是，你可以用两种方式之一来表达。一种是说 a ∧ b ≤ c 当且仅当 a ≤ (b → c)，或者另一种写法是 cb。好的，这就是结构，它唯一地描述了这个蕴涵联结词，它决定了它的同构性，在这种情况下，它的序恒等式是前序的诱导等价关系……的……的。</p><p>From an order theoretic point of view, what that’s saying is you can
            phrase this in one of two ways. One is to say that a ∧ b ≤ c if and only
            if a ≤ (b → c), or another way that this gets written is cb. Okay,
            that’s the structure, and that uniquely characterizes this implication
            connective that determines it up to isomorphism, and in this case, up to
            its order identity being the induced equivalence relation of the… of
            the… of the pre order.</p>
        <p>另一种看待这个问题的方式……所以这是其中一种说法。但是如果你举个例子，我们可以从中得到什么……如果我们……我想说什么？给我一点时间。好吧，无论如何，是的，我认为这是我想说的主要内容。</p><p>Another way to sort of see this… so that’s one way to say it. But if
            you take, for example, what we can get out of this is… if we take… what
            do I want to say? Give me a moment. Well, anyway, yeah, that I think
            that’s the main thing I want to say.</p>
        <p>我也可以将其写成以下形式：也就是说，如果我取 a ∧ (a → b)（不好意思，或 ba），那么它小于或等于 b。这是一种排序方法。如果 c ∧ i ≤ b，那么 c ≤ a → b 或 ba。好的。这是一种等效方法。我们可以采用这个定义。</p><p>And I could also write this down in the following form: that says if
            I take a ∧ (a → b) (excuse me, or ba), then that’s less than or equal to
            b. That’s one way to order it. And if c ∧ i ≤ b, then c ≤ a → b or ba.
            Okay. That’s an equivalent way. We could either take this
            definition.</p>
        <p>好的。首先，当史蒂夫讲话时，他也会解释这件事的所有细节。我们确实会这样做，好吗？</p><p>Okay. One, and when Steve talks, he will explain all the ins and outs
            of this too. And we do, we do that, okay?</p>
        <h2 id="heightening-algebra-and-cartesian-closed-preorder">加强代数和笛卡尔封闭预序</h2><h2>Heightening
            Algebra and Cartesian Closed Preorder</h2>
        <p>换句话说，蕴涵对应于一个额外的闭包条件。所以我们有交，有交和连接，还有一个 x，也就是所谓的指数。好的。这就是指数对象，cb。这里有一个这样的结构，我们在这里进行......我只需画一条线。这个结构......我的董事会纪律不是最好的......这形成了所谓的 Heyting 代数的结构。这就是定义。</p><p>So, in other words, the implication corresponds to an additional
            closure condition. So we have meet, we have meets and joins, and we also
            have an x, what’s called an exponential. Okay. So this is the
            exponential object, cb. And such a structure here, which we have going
            on here… I’ll just draw a line. This structure… my board discipline
            isn’t the greatest… this forms the structure of what’s called a Heyting
            algebra. That’s the definition.</p>
        <p>你要做的是……我们要……所以重点是，这里写的证明理论概念，即直觉命题逻辑，写成与、或、真、假和蕴涵。直觉命题逻辑在代数上对应于 Heyting 代数的概念。所以这是第一件事。所以这是代数结构，Heyting 代数是笛卡尔封闭预序的一个例子。</p><p>And what you’re going to do is… we’re going… so the point being that
            the proof theoretic concepts, which are written here, which is this is
            intuitionistic propositional logic that is written out with, you know,
            and, or, true, false, and implication. Intuitionistic propositional
            logic corresponds algebraically to this, to the concept of a Heyting
            algebra. So that’s the sort of first thing. So this is the sort of
            algebraic structure, and Heyting algebras are an instance of what is
            this is called a cartesian closed pre order.</p>
        <p>好的。C 会告诉你很多关于这方面的内容。这是类别作为预序的一个特例，正如我之前提到的。笛卡尔积满足前面提到和图示的条件。封闭意味着它有一个满足此条件的指数。它是一个指数，所以它相对于笛卡尔结构是封闭的。所以整个东西被称为笛卡尔封闭预序。好的，这就是这个想法。</p><p>Okay. And C will tell you a lot about that. This is a particular case
            of a category as a pre order, as I mentioned to you before. A Cartesian
            product satisfies the conditions previously mentioned and diagrammed.
            Being closed means it has an exponential satisfying this condition. And
            it’s an exponential, so it’s closed with respect to the Cartesian
            structure. And so that whole thing is called a Cartesian closed pre
            order. Okay, so that’s the idea.</p>
        <p>好的，一般来说，在这种情况下，“封闭”意味着映射——小于或等于关系，即 a 和 b 之间的映射，a 小于或等于 b——可以认为到 b 的映射被内化为特定类型的元素或类别中的对象，即指数对象。这被称为封闭结构。</p><p>Okay, so generally in this context, “closed” means that the maps—the
            less than or equal to relation, which is the maps between a and b, a
            less than or equal to b—it can be thought of as the maps to b are
            internalized as elements of a particular type or an object in the
            category, which is the exponential object. And that’s called a closed
            structure.</p>
        <p>有些情况——我不记得这次是否有人​​讲授子结构逻辑——但如果他们讲授的话，那么你会遇到所谓的单半群闭结构，你也会遇到其他形式的闭结构。我不确定这是否会在这次暑期学校的例子中出现。</p><p>And there are situations—I don’t remember whether anyone’s lecturing
            on substructural logic this time—but if they were to, then you would run
            into things called monoidal closed structures, and you would run into
            other forms of closed structures. I’m not sure if that’ll come up in
            this instance of the summer school.</p>
        <p>好的，这就是增强代数的概念。隐藏代数的概念与布尔代数的概念极其密切相关。</p><p>Okay, so that’s the notion of a heightening algebra. And the notion
            of a hiding algebra is extremely closely related to the notion of a
            Boolean algebra.</p>
        <h2 id="boolean-algebra-and-intuitionistic-logic">布尔代数和直觉逻辑</h2><h2>Boolean Algebra and
            Intuitionistic Logic</h2>
        <p>唯一的区别是，让我们看看，你是否有补语。</p><p>The only difference is, let’s look here, is whether you have a
            complement.</p>
        <p>所以，记住，我们在这里注意到了——如果你看一下——让我在这里稍微看一下我的笔记。到目前为止，你明白了吗？哦，是的。我想说一些关于……提醒我谈谈结构特性。</p><p>So, remember, so what we notice here—if you look at—let me touch my
            notes here for a second. Are you with me so far? Oh, yeah. I want to say
            something about… remind me to say something about structural
            properties.</p>
        <p>好的，这就是补语的概念。所以我们定义——我认为他是这样写的——不是 a，根据定义，a 意味着假。好的，或者有时人们使用的符号可能是条形。好的，在某些情况下，人们喜欢这种符号。所以你可以写其中一个。</p><p>Okay, so here’s the idea of a complement. So we define—I think he
            wrote it like this—not a, by definition, to be a implies false. Okay, or
            sometimes a notation that people use is a bar, maybe. Okay, in certain
            situations, people like that notation. So you can write one or the
            other.</p>
        <p>这有一个特点——好吧——我们知道，如果我们取 a 和 a bar，如果你用代数的方式看它，它小于或等于 false。小于或等于 bottom。由于 bottom 小于或等于一切，你可以说它等于 bottom。</p><p>And this has the feature—okay—that we know that if we take a and a
            bar, if you look at it algebraically, it’s less than or equal to false.
            Less than or equal to bottom. Since bottom is less than or equal to
            everything, you can really just say it’s equal to bottom.</p>
        <p>好的，这是该规则的一个简单例子。如果你在这里采用这个原则，并让它成为意味着假，那么你小于或等于假。假小于或等于一切。所以两者结合起来会给你一个等式，或者诱导等价——也就是等价——前序诱导等价。但我们就这样写吧。</p><p>Okay, this is a trivial instance of this rule. If you take this
            principle here and you make it be a implies false, then your less than
            or equal to false. False is less than or equal to everything. So the two
            together will give you an equation, or the induced equivalence—that is,
            the equivalence—the induced equivalence of the pre order. But let’s just
            write it like this.</p>
        <p>所以这个想法就是，这有一些否定的味道。好的。这叫做否定。好的。事实上，这就是——这就是它的定义方式。你会注意到的另一件事是，这是以下一种介绍原则。这是一种肢体规则，表示如果 c 加 a 小于或等于底部。如果这是矛盾的，那么 c 小于或等于一个条形，或者不是 a，这取决于你如何看待它。</p><p>So the idea is that this has some of the flavor of negation. Okay.
            This is called negation. Okay. In fact, that’s the—that’s the way this
            is—that’s the way this is defined. And the other thing you’ll notice is
            that is the following kind of intro principle. This is a kind of limb
            rule that says if c plus a is less than or equal to the bottom. If
            that’s contradictory, then c is less than or equal to a bar, or not a,
            depending on how you look at it.</p>
        <p>好的。所以，这有点像否定的引入规则，这有点像否定的消除规则。好的。现在，我想让你看到的，我想在这里提出的……好的，让我赶上这个。</p><p>Okay. So, this is sort of the introduction rule for negation, and
            this is kind of the elimination rule for negation. Okay. Now, the thing
            I want you to see, the thing I want to bring out here… okay, let me
            catch up to this.</p>
        <h2 id="negation-and-structural-properties">否定和结构属性</h2><h2>Negation and Structural
            Properties</h2>
        <p>我想提出这一点的原因……好吧，是因为……好吧。那么，到目前为止你明白了吗？好的。所以，这是一个参与的概念。因此，任何 Heyting 代数都配备了一个否定的概念，根据这个定义，它满足这些原则。好的。因为你有……因为你有一个指数。所以，这就是我在这里要说的。然而，关于这一点，有些话值得一提，因为它是直觉的本质。它就像逻辑，我们不知道……</p><p>The reason I want to bring this out… okay, is that… okay. So, you’re
            with me so far? Okay. So, that’s a notion of engagement. So, any Heyting
            algebra comes equipped with a notion of negation satisfying these
            principles by virtue of this definition. Okay. Because you have… because
            you have an exponential. So, that’s what I’m saying here. However,
            there’s something to say about this that is worth bringing out because
            it is of the essence of intuition. It’s like logic, which we do not…</p>
        <p>因此，从代数的角度来看，否定是这样定义的。Heyting 代数中的内部否定通常不是补语。这就是它的意思。如果我们没有——尽管最好的说法是——我们——则不存在 top 小于或等于 a 或非 a 的情况。这就是说法。好的。就预序而言……好的。从逻辑上讲，它表示我们不希望能够证明 a 或——好吧，如果我们用逻辑符号写出来——a 或非 a 在没有假设的基础上为真。</p><p>So, from an algebraic point of view, is the negation so defined. The
            internal negation in a Heyting algebra is not a complement in general.
            That is what this means. Is we do not have—although the best, or the
            best way to say it is, we—it is not the case that top is less than or
            equal to a or not a. That’s the way to say it. Okay. In terms of the pre
            order… okay. In terms of logic, it says we do not expect to be able to
            prove a or—well, if we write it in logical notation—a or not a is true
            on the basis of no hypothesis.</p>
        <p>这就是这里发生的事情。没有假设。所以，top 在这里——假设，如果你把它看作一个假设，你什么都没有假设——或者在序理论结构方面，某事绝对正确意味着 top 小于或等于它。好的。这就是定义。一切都小于或等于 top。所以，如果 top 小于或等于它，它就是真的。这是绝对正确的。并不是对于每一个 a，a 或非 a——a 或其互补 a 或非 a——都是真的。</p><p>That’s what is going on here. On the basis of no hypothesis. So, top
            being here—assuming, if you think about it as an assumption, you’re
            assuming nothing—or in terms of the order theoretic structure, something
            is absolutely true means the top is less than or equal to it. Okay.
            That’s the definition. Everything is less than or equal to the top. So,
            if top is less than or equal to it, it’s true. It’s absolutely true.
            It’s not the case that for every single a, a or not a—a or its
            complementary a or not a—comes out to be true.</p>
        <p>如果真是这样，那么你就得到了所谓的布尔代数。好的。因此，布尔代数是具有互补否定的 Heyting 代数。这就是否定作为补语表现的地方。我们有这个条件。好的。但这是一个非常特殊的情况。为什么它是一个非常特殊的情况？因为现在这是一个很好的机会，让我来谈谈建设性逻辑的本质，从今天早上的举手表决来看，我怀疑你们中的一些人要么已经知道，要么已经凭直觉知道了。</p><p>If that were the case, you would have what is called a Boolean
            algebra. Okay. So, a Boolean algebra is a Heyting algebra with a
            complementary negation. That is where the negation behaves as a
            complement. We have this condition. Okay. But that’s a very special
            case. And why is it a very special case? Because now this is a nice
            opportunity for me to make a point about the nature of constructive
            logic, which, from the show of hands this morning, I have a suspicion
            that some of you either already know or have intuited.</p>
        <p>但无论如何，让我为你阐述一下。好的。因为我认为值得这么做。这是想法……这是以下想法。</p><p>But anyway, let me articulate it for you. Okay. Because I think it’s
            worth doing it. Which is the idea… which is the following idea.</p>
        <h2 id="decidability-and-intuitionistic-logic">可判定性和直觉逻辑</h2><h2>Decidability and
            Intuitionistic Logic</h2>
        <p>由于我不期望在这种直观的环境中一个命题通常是正确的，所以这似乎是一种损失。似乎缺少了你期望为真的东西，这让人感觉很糟糕，因为这是一种损失。我说，恰恰相反，这是布劳威尔在 20 世纪 30 年代提出的观点，当时没有人理解他。人们花了很长时间才明白他在说什么，也就是说，不，不，不，不，不，不，不，不，不，不，这根本不是一种损失。</p><p>Since I don’t expect a proposition to be true in general in this
            intuitive setting, it seems like a loss. Something appears to be missing
            that you expect to be true, and this feels bad because it’s a loss. I
            say, on the contrary, and this was the point that Brouwer made in the
            1930s, and no one understood him then. It took a long time for people to
            understand what he was talking about, which is to say that no, no, no,
            no, no, no, no, no, no, this is not a loss at all.</p>
        <p>这是一个纯粹的游戏，好吗？这是一个纯粹的游戏。为什么？因为我们可以定义，我们可以说，看：一个命题，根据定义，我们会说一个命题是可判定的，当且仅当它或它的否定为真。所以，直觉逻辑所发生的一切就是，我们并不是说我们所说的不是每个命题都是可判定的。如果你接受这个原则，因为 a 或非 a 并不总是正确的，如果你考虑一下，如果你考虑一下我从一开始就告诉你的，我们在做逻辑时就像人一样重要，这意味着什么，对吧？如果存在不可判定命题这一事实是简单地观察到存在未解决的问题，那么存在我们既没有证据也没有反驳的问题。根据这个定义，反驳是一种函数，它将你认为拥有的任何证据转化为虚假的证明。所以，我们称之为反驳。所以，我们要说的是，如果一个命题有一个证明或一个反驳，那么它就是可判定的。</p><p>What it is is a pure game, okay? It is a pure game. Why? Because we
            can define, we can say, look: a proposition, by definition, we’ll say a
            proposition is decidable if and only if either it or its negation is
            true. So, all that’s happening with intuitionistic logic is we’re not
            saying what we’re saying is not every proposition is decidable. And if
            you take this principle, because it’s not always the case that a or not
            a is true, if you think about that for a minute, if you think about what
            I was telling you right from the beginning that we’re doing logic as if
            people matter, what this means is, right? If the fact that there are
            undecidable propositions is the simple observation that there are
            unsolved problems, there are problems for which we neither have a proof
            nor refutation. A refutation is a function, by this definition, that
            transforms any proof you think you have into a proof of falsehood. So,
            we’ll call that a refutation. So, what we’re saying is that a
            proposition is decidable if it has either a proof or a refutation.</p>
        <p>例如，如果你看一下自然数上的相等性，那么如果我们有 x、y 和 n，现在我开始讨论依赖类型，但我现在只是在这里松散地讨论。不好意思。这是一个命题，好吗？所以，这是一个命题，一个二元命题，它应该是相等的。我声称这个命题是可判定的。这就是这个想法。给定两个数字，很明显一个数字是否等于另一个数字。</p><p>So, if you look at, for example, equality over the natural numbers,
            so if we have x, y, and n, and now I’m starting to get toward dependent
            types, but I’ll just do it loosely here at the moment. Excuse me. This
            is a proposition, okay? So, this is a proposition, a two place
            proposition, and it’s supposed to be equality. I claim that this
            proposition is decidable. That is the idea. Given two numbers, it’s
            clear whether one is equal to the other or not.</p>
        <p>好的。另一方面，如果或实数上的，那么你也可以有一个命题。所以，让我们在这里写下 sub n 只是为了明确说明，这样我们就不会对符号感到困惑。如果我们有相等性，这是另一个命题。我声称这应该是可判定的。这是不可判定的。我可以给出一个证明，我不会在黑板上这样做，但直觉是正确的。你可以编写图灵机计算来表示数字的十进制展开或有理数的柯西序列。计算是否在某个点远离零对应于机器是否停止。没有办法做出这个停止决定。这只是一种说法，就像一个启发式指南，说明证明是什么。好的。</p><p>Okay. If, on the other hand, or over the reals, then you also could
            have a proposition. So, let’s write sub n here just to make it explicit
            that we’re so we don’t get confused by the notation. If we have
            equality, here’s another proposition. I claim that this should be
            decidable. This is not decidable. I can give a proof of that, which I’m
            not going to do here at the board, but the intuition is right. You can
            code up Turing machine computations to represent the decimal expansion
            of a number or as a Cauchy sequence of rationals. Whether the
            computation moves away from zero at some point corresponds to whether
            the machine halts. There is no way to make this halting decision. That’s
            just a way of saying it, like a heuristic guide to what a proof would
            be. Okay.</p>
        <p>所以，重点是，或者说另一个重点是著名的 P 等于 NP 猜想，它表达了一个非常好的命题。但尚不清楚它是真还是假。好的。</p><p>So, the point is, or here’s another one, is the famous P is equal to
            NP conjecture, which expresses a perfectly good proposition. And it’s
            not known whether that is true or false. Okay.</p>
        <p>所以，理解这一点非常重要，因为您会看到，假设每一个……那个否定是互补的，就是假设一切都是可判定的。每个命题都是可判定的。一切都是真或假。</p><p>So, it is very important to understand this point, because you see
            the assumption that every… that that negation is complementary is the
            brute assumption that everything is decidable. Every proposition is
            decidable. Everything is either true or false.</p>
        <p>因此，人们将传统逻辑（比如基于布尔代数的逻辑）描述为无所不知的逻辑，因为这种逻辑似乎与人无关。比喻就是，你知道，上帝知道它的方向。因此，每个命题要么是真要么是假。这只是我们是否知道的问题。</p><p>So, this is what leads people to characterize conventional logic,
            done with, like, on the basis of a Boolean algebra, as kind of
            omniscient, because it’s logic as if people don’t matter. The metaphor
            being, you know, God knows which way it is. So, every proposition is
            either true or false. It’s just a matter of whether we know it or
            not.</p>
        <p>因此，从我们作为有限存在的角度来看，从我们的角度来看，并不是每个命题都是可判定的。</p><p>So, from our point of view, as finite beings, from our point of view,
            it is simply not the case that every proposition is decidable.</p>
        <p>现在，有一个有趣的结果。这里有一个有趣的微妙之处，我想指出来，以确保你们理解。那就是，未能肯定每个命题的可判定性与驳斥每个命题的可判定性完全不同。好吧，保持警惕。</p><p>Now, there’s an interesting consequence. There’s an interesting
            subtlety here, which I would like to draw out to make sure you
            understand. Which is the idea that failing to affirm the decidability of
            every proposition is not the same at all as refuting the decidability of
            every proposition. Okay, be on your toes.</p>
        <p>好的，你明白我说的话了吗？好的。不是每个命题都是可判定的，这和说每个命题都是不可判定的不是一回事。这是两码事。事实上，这是一个定理。我会把这个当作练习给你。直觉逻辑定理是，一般来说，对于每个 a——这是一般的 a——好的，不是航空的 a——情况并非如此。换句话说，你必须注意你是如何阅读的，因为我不想让你认为这只是某种任意游戏。这是一个有意义的陈述。它说直觉逻辑不能反驳排中律。好的，这才是重要的。它没有肯定它，但它肯定不会反驳它。众所周知，它不会反驳它。</p><p>Okay, did you understand what I said? Okay. The fact that not every
            proposition is decidable is not the same thing as saying that every
            proposition is undecidable. That’s a different thing. And as a matter of
            fact, it’s a theorem. And I’ll give this to you as an exercise. The
            theorem of intuitionistic logic that it is not the case that, in
            general, for every a—this is a for generic a—okay, not aeronautic. In
            other words, you have to watch how you how you read this, because I
            don’t want you to think this is just like some arbitrary game. This is a
            meaningful statement. It says intuitionistic logic does not refute the
            law of excluded middle. Okay, that’s what’s important. It doesn’t affirm
            it, but it positively does not refute it. It is known not to refute
            it.</p>
        <p>那么，这有什么有趣的呢？</p><p>So, what is so interesting about this?</p>
        <p>证明是一个练习。这是一个非常有趣的练习。你已经拥有找到这个证明所需的一切。也就是说，弗兰克告诉你的一切都足以解决这个练习。但我怀疑你会发现它有点棘手。它不是那么简单。好吧。事实上，当你找到它时，你会觉得你不确定自己是否作弊，好吧，直到你重复几次。好吧。</p><p>The proof is an exercise. This is a very interesting exercise. You
            have everything you need to find this proof. That is, everything that
            Frank has told you is sufficient to solve this exercise. But I suspect
            you’ll find it a little tricky. It’s not that straightforward. Okay. In
            fact, when you do find it, you’ll think you’ll be uncertain whether
            you’re cheating or not, okay, until you go through it a few times.
            Okay.</p>
        <p>所以，我把它留作练习。但这为什么重要？这很重要，因为即使我们没有证据证明一个命题是可判定的，我们也可以启发式地假设它。因为，你看，直觉逻辑不会反驳可判定性。好吧，这就是想法。它不会——如果它反驳了任何任意命题的可判定性，那么如果你假设它是可判定的，那么自动地，或者在罪恶的状态下，一切都是不一致的。然后它就一团糟了。</p><p>So, I’ll leave it as an exercise. But why is this important? It’s
            important because the importance of this is that we can always
            heuristically assume a proposition is decidable, even if we don’t have a
            proof that it is. Because, you see, intuitionistic logic is not going to
            refute the decidability. Okay, that’s the idea. It doesn’t—if it refuted
            the decidability of any arbitrary proposition, then if you threw in the
            assumption that it was decidable, then automatically, or in a state of
            sin, everything is inconsistent. Then it’s a mess.</p>
        <p>但在这里，我们可以做的是做出假设。我们可以说，“好吧，假设我们考虑实数上的等式，让实数上的不等式是可判定的。”然后我们可以描述，例如，牛顿法通过一种二分搜索程序来寻找函数的根，这种程序需要知道——好吧，我们相对于 x 轴的位置在哪里？”让我们说。你实际上不能这样做。那是假的。好吧，这不是真的。好吧。但直觉逻辑不会反驳它。所以我可以提出这个假设，然后假装它是真的。</p><p>But here, what we can do is we can make assumptions. We can say,
            “Well, suppose we consider that equality on the real numbers, let the
            inequality on the real numbers be decidable.” Then we can describe, for
            example, Newton’s method for finding roots of a function by a kind of
            binary search procedure that requires knowing—okay, where are we
            relative to the x axis?” Let us say. You can’t actually do that. That’s
            bogus. Okay, it’s not true. Okay. But intuitionistic logic doesn’t
            refute it. So I can throw in that assumption and then act as though it
            were true.</p>
        <p>换句话说，直觉逻辑的明显局限性——这是可怜的布劳威尔永远无法向任何人解释清楚的——直觉逻辑的明显局限性正是其力量的源泉，它增强了直觉逻辑的表达能力、力量和表现力。你看，如果你强加一个笼统的假设，认为一切都是可判定的，那只是纯粹的损失，因为你现在无法区分哪些场景是可判定的，哪些场景不是。一切都是强加给你的。</p><p>So, in other words, the apparent limitations—so this is something
            that poor Brouwer—they could never—the poor Brouwer could never get
            across to anyone—the apparent limitations of intuitionistic logic are
            the very source of its strength, and it’s strengthened its expressive
            power, strength, and expressiveness. You see, just pure loss if you
            impose the blanket assumption that everything is decidable, because you
            now are unable to draw the distinction between scenarios in which things
            are decidable and in which they’re not. Everything has been forced on
            you.</p>
        <p>好的。所以你无法区分。而使用直觉逻辑，我可以根据特定情况下的偏好有选择地引入可判定性假设。也许我想讨论牛顿法，这是一个很好的算法，但事实上你不能比较实数的不等式。好的，所以这是一件值得考虑的明智之举。而如果你坚持认为这是纯粹逻辑的问题，那么你就出局了。你甚至不能玩这个游戏。</p><p>Okay. So you can’t draw the distinction. Whereas with intuitionistic
            logic, I can selectively introduce decidability assumptions according to
            my preference in a particular situation. Maybe I wish to discuss
            Newton’s method, and it’s a nice algorithm, but for the fact that you
            can’t compare real numbers for inequality. Okay, so it’s a sensible
            thing to entertain. Whereas if you insist on that holding as a matter of
            pure logic, then you’re out of the game. You can’t even play this
            game.</p>
        <p>这一点有很多含义，事实上，当我们讲到最后时，我和史蒂夫以及其他人会讨论我之前提到的类型理论的最新进展，这些进展完全有可能就是因为这个原因。好的。它之所以有效，之所以如此美妙，正是因为这个和相关概念——这个想法。好的。所以我认为这是一个非常关键的想法。使用海廷代数而不是布尔代数是件好事。</p><p>There are many implications of this point, and in fact, when we get
            to the end, some combination of me and Steve and others will talk about
            recent advances in type theory that I alluded to earlier that are
            entirely possible exactly for this reason. Okay. The only reason it
            works, the reason it’s such a beautiful way to go, is exactly because of
            this and related concepts—this idea. Okay. So I think that’s a really
            critical idea to get across. It’s good to be working with a Heyting
            algebra, not a Boolean algebra.</p>
        <p>某种程度上，这意味着你所知道的一切都是错的。这让我这个老师的处境很尴尬。明白吗？你必须重新开始。所以，每个人都告诉你这个关于布尔代数的故事。忘掉它吧。明白吗？那是一个错误。明白吗？他们把你带上了错误的道路。他们是好心人，但他们把你带上了错误的道路。明白吗？所以，为了理解编程语言的真正理论和它的工作原理，必须进行一定程度的撤销。所以，这就是其中之一——习惯这个核心思想。一旦你掌握了这个想法，并开始摆弄它，就像我之前说的，你会想，“天哪，这些人都疯了。”这是真的。他们的确是疯了。你会弄清楚的。明白吗？</p><p>This means, in a way, that everything you know is wrong. It puts me
            in an awkward position as a teacher. Okay? You have to start over. So,
            everybody told you this story about Boolean algebra. Just forget it.
            Okay? It was a mistake. Okay? They led you down the wrong path. They’re
            good meaning people, but they led you down the wrong path. Okay? So,
            there’s a certain amount of undoing that has to happen in order to
            understand the real theory of programming languages and how it all
            works. And so, this is one of them—getting used to this like core idea.
            Once you get the idea and start playing around with it, as I say before,
            very long, you’ll think, “Oh my god, these other people are crazy.” And
            that’s true. They are. And you’ll figure that out. Okay?</p>
        <p>所以，这有点像。我想总结一下代数的故事，因为我想引入布尔代数的概念，并将其与卫生代数的概念进行比较。</p><p>So, that’s like a little bit. I wanted to wrap up a little bit that
            algebraic story because I wanted to bring in the notion of Boolean
            algebra and compare it to the notion of hygiene algebra.</p>
        <h2 id="conclusion-and-further-remarks">结论和进一步评论</h2><h2>Conclusion and Further
            Remarks</h2>
        <p>为了做到这一点，我们需要开发更多的逻辑，以便我们能够了解它的工作原理。顺便说一下，如果你现在看看，如果你现在去读一本传统的教科书，你可以从亚马逊下载，我认为你将能够把诸如命题逻辑的完整性证明之类的东西看起来会有很大不同，对你来说可能比以前更清晰、更清晰。好吗？</p><p>In order to do that, we needed to develop a bit more of logic so we
            can see how it works. So, now, if you look at that, by the way, if you
            now go to a, you know, a conventional textbook that you can, you know,
            download from Amazon, I think you’ll be able to put things like the
            completeness proof for propositional logic will look a lot different, a
            lot clearer and cleaner to you than maybe they have before. Okay?</p>
        <p>是的，但如果我们不知道，我们能知道吗？好的。所以，它还有许多其他类似的变化。但我想在这里提醒大家注意的是，从历史上看，这是第一步，从某些技术意义上讲，这是一个非常重要的位置。但这并不是说这是你唯一能做的举动。好吗？</p><p>Yes, but do we know if we don’t? Okay. So, it goes on in many other
            such variations. But what I want to be calling attention to here is this
            was historically the first move, and in certain technical senses is a
            very important spot. But it’s not to say it’s the only move you could
            make. Okay?</p>
        <p>那么，现在我要讲第二点。好吗？那么，我现在就讲到这一点，以便结束这一部分。好吗？那么，事情是这样的……</p><p>So, there, and now that brings me to a second point. Okay? So, I’ll
            say it now in order to wrap this up. Okay? So, the thing…</p>
        <p>所以，我会这样回答你的问题。所以，你还有一件事……我想表达的是——我只是想通过提出顺序结构，将教科书上的逻辑处理与这种证明理论处理联系起来。在我看来，很多教科书的处理都不太好，因为它们没有将小于与蕴涵的概念联系起来，而且它们通常没有自然演绎的机制，这就是弗兰克之前向你解释的。这让整个事情看起来自然而不可避免。这只是我个人的看法，关于为什么我觉得在通常的处理中，这种对应关系如此尴尬。但无论如何，现在你可以很清楚地看到这种对应关系到底是什么，以及它为什么存在。</p><p>So, I will answer your question in this way. So, the other thing that
            you… So, the thing I wanted to get across too is just—I just wanted to
            relate like textbook treatments of logic to this proof theoretic
            treatment by bringing out the order structure. A lot of the textbook
            treatments are not so good, in my opinion, at explaining this idea very
            well because they don’t connect the less than to the idea of entailment,
            and they don’t have at their disposal, typically, the machinery of
            natural deduction, which is what Frank was explaining to you before.
            Which makes the whole thing seem natural and inevitable. That’s just a
            personal opinion about why I feel it’s so awkward in the usual, in the
            usual treatments. But anyway, now you can see pretty clearly what that
            correspondence is all about and why that’s there.</p>
        <p>我想再说一点关于蕴涵性质的事情。所以，如果你看一下……有一件事我之前有点含糊其辞。我是故意这样做的。那就是蕴涵有多个假设的想法。所以，如果你从代数的角度来看待这个问题，这里讨论的小于或等于这个是什么？嗯，它是所有这些事情的核心。好的。所以，你要做的就是我们可以把这个和那个联系起来。好的。这就是这个想法。我们可以把它看作是核心。我提起这个的原因是我想展示，我想谈谈所谓的蕴涵的结构性质。</p><p>I wanted to say one other thing about the properties of entailment.
            So, if you look at it… There’s one thing I was a little bit fudging
            earlier. I did that deliberately. Was the idea that entailment has
            multiple hypotheses. So, if you look at this from an algebraic point of
            view, what—what is the less than or equal to that is in question here?
            Well, what it is is it’s the meat of all of these things. Okay. So, what
            you do is we can just relate this to that. Okay. That’s the idea. We can
            think of that as the meat. The reason I bring it up is I want to show, I
            want to talk about what are called the structural properties of
            entailment.</p>
        <h2 id="structural-properties-of-entailment">蕴涵的结构属性</h2><h2>Structural Properties of
            Entailment</h2>
        <p>这实际上就是对刚才提出的问题的回答。好的。</p><p>And this is, in fact, an answer to the question that was just asked.
            Okay.</p>
        <p>所以，我们到目前为止讨论的结构属性——就不重复了——反身性和传递性。但一般来说，我们还有一个额外的属性。其中之一叫做弱化，<em>w</em>，通常写成这样。如果你不介意的话，我将开始使用传统的符号。写成γ。好的。</p><p>So, the structural properties we talked about so far—won’t
            repeat—reflexivity and transitivity. But in general, we have an
            additional one. And one of them is called weakening, <em>w</em>, which
            is usually written like this. If you don’t mind, I’ll start using the
            conventional notation. Write that γ. Okay.</p>
        <p>因此，我们通常会说，如果<em>a</em>基于 γ 为真，那么<em>a</em>基于 γ 和其他与任何事情都无关的随机引理也一定为真。好的。这被称为弱化原理。好的。这就是这个想法。</p><p>So, what we do is usually say well, if <em>a</em> is true on the
            basis of γ, then surely <em>a</em> is true on the basis of γ and some
            other random lemma that has nothing to do with anything. Okay. That’s
            called the principle of weakening. Okay. So, that’s the idea.</p>
        <p>那么，就预序而言，让我们看看发生了什么。也就是说，如果 γ 小于或等于<em>a</em>，那么 γ 和<em>b</em>
            小于或等于<em>a</em>。嗯，当然，因为——这就是我想说的吗？是的。如果 γ 小于或等于<em>a</em>，原因是 γ 本身——不，我刚才说到哪里了？我脑子里有这样的想法，我想表明这显然是事实。</p><p>So, in terms of a pre order, let’s look at what’s going on. That’s
            saying if γ is less than or equal to <em>a</em>, then γ and <em>b</em>
            is less than or equal to <em>a</em>. Well, for sure, because—is that
            what I want to say? Yes. If γ is less than or equal to <em>a</em>, the
            reason is that γ itself—no, where did I go here? I had—I had the thing
            in my head I wanted to show that this is obviously the case.</p>
        <p>所以，这个想法是——哦，是的，对。所以，γ 和<em>b</em>是
            <em>a</em>。这是关键。所以，它小于或等于 γ ，具体来说，并且根据假设，小于或等于
            <em>a</em>。那么，这到底是什么？哦，我感到困惑的原因是因为我写错了字母。我在想我该怎么做。好的。对不起。好的。你——你试试这个，站在这里，你就会明白。好的。所以，好的，是的。所以，我像往常一样搞砸了。好的。
        </p><p>So, the idea is that—oh, yes, right. So, γ and <em>b</em> is
            <em>a</em>. It’s the meat. So, it’s less than or equal to γ, in
            particular, and that, by assumption, is less than or equal to
            <em>a</em>. So, what the hell is that? Oh, so the reason I got confused
            because I wrote the wrong letter. I’m thinking how am I going to do
            this. Okay. Excuse me. Okay. You—you try this and stand up here, and
            you’ll see. Okay. So, okay, yeah. So, I screwed that up, as usual.
            Okay.
        </p>
        <p>所以，这小于 γ，也就是小于或等于<em>假设</em>。所以，你会得到线下的东西。所以，这是肉的性质，这使得它成为现实。还有其他规则，称为收缩和交换。收缩——你可能以前见过。这说明——这是一个有趣的规则。这说明——让我把它写下来，然后我可以向你解释。它看起来有点奇怪。</p><p>So, this is less than γ, which is less than or equal to <em>a</em> by
            hypothesis. So, you’ll get the thing below the line. So, it’s a property
            of the meat that that makes that come out to be true. There are other
            rules, which are called contraction and exchange. And contraction—you
            might have seen this before. That says—this is an interesting one. That
            says—let me let me write it down, then I can explain it to you. It
            almost looks a little weird.</p>
        <p>如果我能够基于同一引理的两个副本得到 B，那么我就可以基于该引理的一个副本得到 B。明白吗？这就是它的意思；这就是为什么它被称为收缩。所以，你几乎可以说它是——在这条规则的存在下，顶部和底部没有区别。但在某种程度上，你可以说，如果我两次援引特定引理<em>a</em>的证明，那么你可以援引它一次并使用结果两次。你知道，这本质上就是它的意思。</p><p>If I can get B on the basis of two copies of the same lemma, then I
            can get B on the basis of one copy of that lemma. Okay? That’s what that
            is saying; that’s why it’s called contraction. So, you can almost say
            it’s—it’s in the presence of this rule, there’s no distinction between
            the top and the bottom. But in a certain way, you can say if I appealed
            to the proof to a particular lemma <em>a</em> twice, then you can sort
            of appeal to it once and use the result twice. You know, that’s
            essentially what it’s saying.</p>
        <p>因此，从序理论的角度来看，这只是说，如果你有<em>γ</em>和<em>a</em>和<em>a</em>，并且如果它们小于或等于<em>b ，那么</em><em>γ</em>和<em>a</em>肯定小于或等于<em>b</em>。那么，为什么呢？原因和我之前给出的一样。因此，这个东西小于那个东西，那个东西小于或等于<em>b</em>，因此根据传递性，那个东西小于或等于<em>b</em> 
            。所以，这很简单。</p><p>So, from an order theoretic point of view, this is simply saying if
            you have <em>γ</em> and <em>a</em> and <em>a</em>, and if that’s less
            than or equal to <em>b</em>, then surely <em>γ</em> and <em>a</em> is
            less than or equal to <em>b</em>. Well, why? For the same reason I gave
            before. So, this thing is less than that thing, which is less than or
            equal to <em>b</em>, which is therefore less than or equal to <em>b</em>
            by transitivity. So, that’s an easy one.</p>
        <p>然后还有交换。交换说——我们会这样写，以尽可能地通用——也就是说假设的顺序并不重要。你可以做任何——任何排列都可以写成交换的组合，对吧？所以，我只需要处理这两个交换。</p><p>And then there’s also exchange. Exchange says—and we’ll write it like
            this to be as general as I can think of doing—which is to say that the
            order of the hypotheses doesn’t matter. You can do any—any permutation
            can be written as a composition of swaps, right? So, I just have to work
            with the two swaps.</p>
        <p>因此，从序理论的角度来看，你可以再写出来。你可以说，这个和<em>a</em>和<em>b</em>和
            <em>δ</em>，如果这个小于或等于<em>c</em>，那么这个和这个和这个，哎呀，<em>δ</em>小于或等于
            <em>c</em>。原因是这些左边的每一个都小于另一个，你也可以作为练习来证明这一点。
        </p><p>So, from an order theoretic point of view, you can write it out
            again. You can say well, this and <em>a</em> and <em>b</em> and
            <em>δ</em>, if this is less than or equal to <em>c</em>, then this and
            this and this and, whoops, and <em>δ</em> is less than or equal to
            <em>c</em>. And the reason is each one of these left hand sides is less
            than the other, and you can prove that as an exercise as well.
        </p>
        <p>这是一项练习，一项练习，一项我一分钟前给你的关于排中律的练习。这些被称为蕴涵的结构性质，它们是顺序的性质。也就是说，它们将在任何 Heyting 代数中成立，因为我们假设这是一个乘积，它是一个笛卡尔预序。如果它只是一个幺半群结构——它需要更少的肉；它不再是肉了——那么这些东西就变得有趣了。好吗？它们一点也不自由。事实上，然后人们可以开始引入一些东西，比如，如果你不想让顺序变得重要，那么这就叫做对称幺半群结构。好吗？我可以交换这些东西。这涉及到对称性。所以，这是一个你可以玩的游戏。</p><p>So, an exercise—an exercise—an exercise that I gave you about
            excluded middle a minute ago. So, these are called the structural
            properties of entailment, and they’re properties of an order, of an
            ordering. That is, they’re going to hold in any Heyting algebra by
            virtue of the fact that we assume that this is a product, that it’s a
            Cartesian pre order. If it were merely a monoidal structure—which is
            requiring less of the meat; it’s not a meat anymore—then these things
            become interesting. Okay? They’re not free in any way. In fact, then one
            can start introducing things like, if you don’t want the order to
            matter, then that’s called the symmetric monoidal structure. Okay? Where
            I can swap those things around. There’s a symmetry involved. So, that’s
            a game you can play.</p>
        <p>因此，在回答这个问题时，这些原则的各种组合（这一个、这一个和这一个）都是可以否认的。你可以决定不允许它们。我认为，除非你有预先的顺序，否则你不会有任何明智的想法。如果你要有任何蕴涵的概念，它必须是反身的和不及物的；否则，我不知道我们在谈论什么。好的。这就是我要说的。这就是为什么类别的公理——它们唯一假设的是组合中的身份。</p><p>And so, what happens is, in answer to the question, is various
            combinations of these principles—this one, this one, and this one—are
            deniable. You can decide not to allow them. I claim you don’t have
            anything even remotely sensible unless you have a pre order. If you’re
            going to have any notion of entailment at all, it has to be reflexive
            and intransitive; otherwise, I don’t know what we’re talking about.
            Okay. That would be what I would say. That’s why the axioms of a
            category—the only thing they assume are identities in composition.</p>
        <p>如果你没有这些，那么，这似乎不是很有趣。好吧。所以你必须有反身性和传递性，但弱化、收缩和交换——这些都是可以争取的。你可以用它们做各种事情。所以，回答你的问题，根据我否认的哪一个，我得到了逻辑的版本——其他受限制的版本，但它们具有相同的一般风格，相同的一般原则，即这些限制是可供性。</p><p>If you don’t have that—if, like, well, that seems to be not very
            interesting. Okay. So you have to have reflexivity and transitivity, but
            weakening, contraction, and exchange—those are up for grabs. You can do
            various things with those. And so, in answer to your question, depending
            on which of these I deny, I get versions—other restricted versions—of
            logic, but they have the same general flavor, the same general
            principle, which is these restrictions are affordances.</p>
        <h2 id="summary-and-relation-to-category-theory">总结以及与范畴论的关系</h2><h2>Summary and Relation to
            Category Theory</h2>
        <p>对吧？如果我没有弱化，那么我可以选择性地重新引入它。如果我没有自动收缩，我可以选择性地重新引入它。你会获得更大的表达能力；它会成为一个更敏锐的工具。好的。这就是为什么人们对这些所谓的——所谓的——子结构逻辑感兴趣。在这些逻辑中，你只采用了这些结构属性的一个子集。你可能会错过弱化，或者错过收缩等等——其他各种各样的东西。好的。好的。所以这就像一个一般性的，就像一些一般性的评论。</p><p>Right? If I don’t have weakening, then I can selectively reintroduce
            it. If I don’t have contraction automatically, I can selectively
            reintroduce it. You get greater expressive power; it becomes a sharper
            instrument. Okay. So that’s why people are interested in these so
            called—so what are called—substructural logics. They are ones in which
            you take only a subset of these structural properties. You maybe miss
            out weakening, or you miss out contraction, etc.—other various things.
            Okay. All right. So that’s like a general, like some general
            remarks.</p>
        <p>所以我想完善与预订单的关系，然后史蒂夫会接手并全力以赴，在类别的背景下使用和处理它。所以，从我们的角度来看，在这几周里，类别论是谈论类型论的另一种方式，类型论是谈论逻辑的另一种方式。好的。这就是我们正在做的事情。所以这些东西都是一个整体。好的。这就是想法。好的。</p><p>So I wanted to round out the relation to pre orders, and then Steve
            will pick this up and go full gas on it, using and treating it in the
            context of categories. So, from our point of view, for these couple of
            weeks, category theory is another way of talking about type theory,
            which is another way of talking about logic. Okay. So that’s what we’re
            doing. So these things are all of a piece. Okay. So that’s the idea.
            Okay.</p>
        <p>所以现在我想回到这些等价的想法。</p><p>So now I want to go back to these ideas of equivalence.</p>
        <h2 id="undecidable-propositions-and-pnp">不可判定命题和 P=NP</h2><h2>Undecidable Propositions and
            P=NP</h2>
        <p>哦，对不起。众所周知，我们知道……所以这是一个目前尚未决定的命题的例子。换句话说，我无法证明 p 等于 nb 或 b 不等于 np，因为我既不能证明它，也不能反驳它。我既不知道非决定论的一切都是无用的，也不知道肯定存在一个定义是——主动脉是否真实的例子。是的，目前是的。</p><p>Oh, sorry. Famously, we know… So that’s an example of a proposition
            that at the moment is not decided. So, in other words, I cannot prove
            either p equals n b or b is not equal to n p, because I can neither
            prove it nor can I refute it. I neither know that everything that non
            determinism is useless, nor do I know that there’s definitely a case
            where the definition is—whether the—whether the aorta is true. Yes, at
            this moment, yes.</p>
        <h1 id="type-theory-foundations-2.1-robert-harper">类型理论基础 2.1 — Robert Harper</h1><h1>Type Theory
            Foundations 2.1 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 37:02 <a href="https://youtube.com/watch?v=0hxqrb0689c">https://youtube.com/watch?v=0hxqrb0689c</a></p><p> 11
            years ago (Jan 2, 2014) — 37:02 <a href="https://youtube.com/watch?v=0hxqrb0689c">https://youtube.com/watch?v=0hxqrb0689c</a></p>
        <h2 id="summary-4">概括</h2><h2>Summary</h2>
        <p>本视频讲座讨论了依赖类型理论，重点关注相等性和等价性。演讲者 Robert Harper 使用 x + 0 = x 等示例解释了定义相等性（意义相等）和指称相等性（指称相等）。他介绍了类型系列的概念、概括谓词，并说明了如何通过变量对这些系列进行索引。讲座强调，在这种情况下，相等性对于理解依赖类型及其在编程和数学中的应用至关重要。</p><p>This video lecture discusses dependent type theory, focusing on
            equality and equivalence. The speaker, Robert Harper, explains
            definitional equality (equality of sense) and denotational equality
            (equality of reference) using examples like x + 0 = x. He introduces the
            concept of families of types, generalizing predicates, and illustrates
            how these families can be indexed by variables. The lecture emphasizes
            that equality in this context is crucial for understanding dependent
            types and their applications in programming and mathematics.</p>
        <h2 id="refuting-and-affirming-propositions">驳斥和肯定命题</h2><h2>Refuting and Affirming
            Propositions</h2>
        <p>情况并非如此，它驳斥了它；而是肯定了它。好的。它是绝对无可辩驳的。那么我知道这是一个定理，你要证明这一点。好的，好的。但那是另一回事。好的。所以这是肯定的。好的。但是有很多命题，我们不知道它是否正确，是否正确或者可以被驳斥——正确或错误。</p><p>Is not the case that it refutes it; it affirms it. Okay. It is
            positively irrefutable. Then I know that’s a theorem you’re going to
            prove that. Okay, okay. But that’s a different thing. Okay. So that is
            for sure. Okay. And but there are plenty of propositions for which it’s
            not known one way or the other whether it’s true, whether it’s true or
            can be refuted—true or false.</p>
        <h2 id="stable-propositions">稳定的主张</h2><h2>Stable Propositions</h2>
        <p>所以它是不可判定的。好的。这就是这个想法。所以这就是——除了这个，我不知道还有更好的方法来解释它。是的，在后面。</p><p>And so it’s undecidable. Okay. So that’s the idea. So that’s the—I
            don’t know a better way to explain that beyond that. Yes, in the
            back.</p>
        <p>转到二阶。然后，如果你把那个——如果你转到二阶——如果你把那个完整量词放在里面，这就是这里发生的事情。如果你把它放在里面，那么它就无法证明，对吧？嗯，我不知道。所以，对所有 a 的双重否定——那些不应该，因为我认为你有车与先生悖论或类似的东西。那很好。我不是——因为它不包含 a。没错。如果你愿意，你可以证明这一点。</p><p>Go to second order. Then, if you put that—if you go to a second
            order—if you put that full quantifier to the inside, that’s what’s going
            on here. If you put it to the inside, then it’s not provable, right?
            Well, I don’t know. So, double negation of all a—a—those should no,
            because I think you have the rook and sir paradox or something like
            that. And that was good. I’m not—because it entails not a. True. If you
            wish, you can prove that.</p>
        <p>证明这一点很容易，但总体来说比较弱。</p><p>Prove that quite easily, but this is in general weaker.</p>
        <h2 id="exercise-on-stable-propositions">稳定命题练习</h2><h2>Exercise on Stable
            Propositions</h2>
        <p>好的。我们说 a 在定义上是稳定的，当且仅当——这是一个定义——当且仅当不非 a 意味着 a。并非每个命题都是稳定的。在经典逻辑中，双重否定是稳定的。当你做出这些一般假设时，它就是这样。特别是，你可以说在排中律的存在下，每个命题都是稳定的。这当然是正确的。好的。</p><p>Okay. And we say that a is stable by definition if and only if—this
            is a definition—if and only if not not a implies a. Not every
            proposition is stable. Double negation stable in classical logic. When
            you make these general assumptions, then it is so. In particular, you
            can say in the presence of the law of excluded middle, then every
            proposition is stable. That is certainly true. Okay.</p>
        <p>所以，但一般情况下情况并非如此。所以，这是——但这是真的。这是一个较弱的——所以，就像在一般情况下一样，这是一个严格较弱的陈述。当你说某事——你知道，某事不可能是假的——与知道它是真的不同。是的，就是这样。好的。</p><p>So, but it is not the case in general. So, this is—but this is true.
            This is a weaker—so, as in a general situation, this is a strictly
            weaker statement. When you’re saying that something—you know, something
            can’t possibly be false—is different from knowing that it’s true. Yes,
            that’s exactly, yeah. Okay.</p>
        <h2 id="another-exercise">另一项练习</h2><h2>Another Exercise</h2>
        <p>所以，这是另一个练习，现在它开始看起来有点荒谬，但事实就是如此。但事实就是如此。好的。情况确实如此。一，一，一，一。是的。一。对不起。是的。一。从这里看，另一种方式很明显，但这个方向——情况就是这样。</p><p>So, here’s another exercise, which is now it starts to look kind of
            absurd, but it is the case. But that is the case. Okay. That definitely
            is the case. One, one, one, one. Yeah. One. Sorry. Yeah. One. The other
            way is obvious from here, but this direction—this is the case.</p>
        <h2 id="negated-propositions-and-stability">否定命题与稳定性</h2><h2>Negated Propositions and
            Stability</h2>
        <p>好的。原因是——那么，那句话怎么说的？它告诉我们否定命题是稳定的。好的。所以，这基本上就是说的。好的。我也把这留给你练习。这些事情并不难，但它们——我们分道扬镳了。我们——我跑题了。所以我宁愿——我希望把我们拉回来。我们为什么不把这个留到练习部分呢？好的。进一步讨论。好的。好的。</p><p>Okay. The reason to—so, what what is that saying? What it’s telling
            us is that negated propositions are stable. Okay. So, that’s what that’s
            what it is basically saying. Okay. And I’ll leave that as an exercise
            for you as well. These things are not hard, but they’re—we’re diverging.
            We’re—I’m getting off on a tangent. So, I’d rather—I’m hoping to corral
            us back. Why don’t we leave this for the exercise section? Okay. To talk
            about further. Okay. All right.</p>
        <p>好的。那么，让我回到我的正题上。</p><p>Okay. So, let me get back on my intended track.</p>
        <h2 id="equality-notions-in-type-theory">类型论中的相等概念</h2><h2>Equality Notions in Type
            Theory</h2>
        <p>哦，让我们看看我要写什么？好的。好的。那么，我们说到哪里了？我们所做的将很有意义，你知道它会及时汇集在一起​​。我们现在正在谈论各种平等概念。我只是提醒你，这是有原因的——我想提醒你，因为这对接下来的内容非常重要。事实上，这些平等问题在处理依赖类型时是至关重要的。</p><p>Oh, let’s see what am I going to write with? Okay. All right. So,
            where were we? What we were doing will make good sense, and you know it
            will come together in time. What we’re doing now was talking about
            various notions of equality. I’ll just remind you, and there’s a reason
            why this—I want to remind you because it’s very essential to what comes
            next. In fact, these issues of equality are completely of the essence
            when dealing with dependent types.</p>
        <h2 id="definitional-and-denotational-equality">定义和外延平等</h2><h2>Definitional and
            Denotational Equality</h2>
        <p>这就是我们要讨论的内容。让我们提醒自己。</p><p>So that’s what we’ll talk about. So let’s remind ourselves.</p>
        <p>因此，我们有了定义相等的概念。我们解释了——我倾向于警告你们，这不是很常规，但我使用这种符号时也适当警告说，这不是完全标准的符号，因为没有什么是好的。</p><p>So we have this notion of definitional equality. And we explained—and
            I was tending, I was warning you that it’s not very conventional, but I
            was using that notation with appropriate warnings that it’s not
            completely standard notation because nothing goes okay.</p>
        <p>所以让我们假设，记住这应该是意义相等或某种计算相等。记住一个例子——我会以一种能唤起你记忆的形式写下来——你知道，对于任何<em>x</em>，<em>x</em> + 0 在定义上等于
            <em>x</em>，给出我对 + 的定义。
        </p><p>So let us say, remember this was supposed to be equality of sense or
            some kind of computational equality. And so an example to keep in
            mind—I’ll just write it in a form that jogs your memory—you know, for
            any <em>x</em>, sort of <em>x</em> + 0 is definitionally equal to
            <em>x</em>, given the definition I gave for +.
        </p>
        <h2 id="examples-of-equality">平等的例子</h2><h2>Examples of Equality</h2>
        <p>您需要知道我如何定义 + 才能知道，因为这就是定义相等的本质。</p><p>You need to know how I define + in order to know because it’s that’s
            the nature of definitional equality.</p>
        <p>然后我编了一个词。好吧，这完全是——我在思考这些讲座时编的。这不是标准的，但我需要一个词，我称之为指称相等，即指称相等。所以我就把它写成这样写的平等。好的。</p><p>And then I made up a word. Okay, this is completely—I made it up when
            I was thinking about these lectures. This is not standard, but I needed
            a word, which I’ll call denotational equality, which is equality of
            reference. And so I was just writing that as equality written like that.
            Okay.</p>
        <p>我们在那里给出的例子，只是为了唤起你的记忆，也许是<em>x</em>、<em>y</em>和
            <em>n</em>，<em>x</em> + <em>y</em>等于<em>y</em> + <em>x</em>，但不是定义上的，你知道，不是定义上的。好的。它们指的是相同的映射。所以如果你把它看作是
            <em>n</em> × <em>n</em> → <em>n</em>的映射，我们就有两个映射。如果你不介意我的松散符号，<em>x</em> + <em>y</em>是一个映射，<em>y</em> + <em>x</em>是另一个映射。我的意思是将<em>x </em> <em>y</em>对发送到<em>x</em> + <em>y</em>，等等。好的。我有两个不同的映射。所以我可以像这样写它们。
        </p><p>And the example that we gave there, just to, like, the kind of thing
            that should jog your memory, is maybe with <em>x</em>, <em>y</em>, and
            <em>n</em>, <em>x</em> + <em>y</em> is equal to <em>y</em> + <em>x</em>,
            but not definitionally, you know, but not definitionally. Okay. They
            refer to the same mapping. So if you think of this as a mapping from
            <em>n</em> × <em>n</em> → <em>n</em>, we have two mappings. We have, if
            you’ll don’t mind my loose notation, <em>x</em> + <em>y</em> is one
            mapping, and <em>y</em> + <em>x</em> is another. What I mean is send the
            pair <em>x</em> <em>y</em> to <em>x</em> + <em>y</em>, et cetera. Okay.
            I have two different mappings. So I could write them like this.
        </p>
        <h2 id="proof-of-equality-by-induction">归纳证明相等性</h2><h2>Proof of Equality by
            Induction</h2>
        <p>好的。那里有两种不同的映射，但它们是相同的映射。好的。</p><p>Okay. There are two different mappings that go there, and they’re the
            same mapping. Okay.</p>
        <p>那么，为什么它们相同呢？嗯，根据数学归纳法的证明论证。我可以做双重归纳法。这里有两个数字。我可以使用归纳假设和证明，对 0，0；0，后继；后继，0；后继，后继进行所有可能的情况，我不会在黑板上这样做，但你可以根据我给出的 + 定义自己算出来。所以，如果我采用我定义的定义相等性，加上数学归纳法，我只会写 MI，就会给你这个证明，证明它们是相等的。</p><p>Well, why are they the same? Well, by virtue of—by an argument by
            proof by mathematical induction. I can do a double induction. Here’s two
            numbers. I can go all the possible cases on 0, 0; 0, successor;
            successor, 0; successor, successor, using the inductive hypothesis and
            proof, which I won’t do here at the board, but you could work it out
            just for yourself on the basis of the definition I gave for +. So if I
            take definitional equality as I defined it, plus mathematical induction,
            and I’ll just write MI, will give you this proof that those are
            equal.</p>
        <p>你也可以把它当作练习，只是为了了解机器是如何工作的。这根本不难。只是看看如何让机器工作。好的。是的，它们指的是同一张地图。所以我觉得这很方便，就像启发式的东西一样，可以提醒我在谈论什么。</p><p>You can do that as an exercise as well, just just to, just so you
            know how the machine works. It’s not difficult at all. It’s just to see
            how to make the machine work. Okay. Yes, they refer to the same map. So
            that’s like I find this like handy, like heuristic thing to remind me
            which thing I’m talking about.</p>
        <h2 id="notion-of-equivalence">等价概念</h2><h2>Notion of Equivalence</h2>
        <p>然后我们将讨论等价的概念。稍后会提到：弱等价或同伦等价。稍后会提到。但下面是一个例子：</p><p>And then we’re going to have a notion of equivalence. This is going
            to come up a little bit later: weak equivalence or homotopic
            equivalence. And this will come up later. But an example of this will
            be:</p>
        <p>首先，当我激励这个时，我将使用的符号看起来是这样的，好的。这方面的一个例子是——这将是——这应该是同伦等价或弱等价。而我们要做的——这应该意味着什么——我们可以做的一个例子是以下想法。它涉及最容易激励的例子。还有其他的例子，但你能想到的最简单的例子是考虑集合的同构，即集合的双射。</p><p>One, the notation I’m going to use when I motivate this is going to
            look like that, okay. Which is an example of this would be—and this is
            going to be—this is supposed to be homotopic equivalence or weak
            equivalence. And the way we’re going to do—what this is supposed to
            mean—an example of this that we can do is the following idea. It’s
            involved the easiest example to motivate. There are others, but the most
            simple one you can possibly think of is to think of isomorphism of sets,
            which is bijection of sets.</p>
        <h2 id="isomorphism-of-sets">集合的同构</h2><h2>Isomorphism of Sets</h2>
        <p>举个例子，我们可以取二，也就是一加一。你知道，真、真或真，你知道，布尔值使用类型定义理论上是一加一。二在两个方面与二同构：通过身份和——我就写在这里——以及通过 not 函数，好吧。因为没有 not——它只是交换真和假。它是它自己的逆，好吧。身份让它们保持不变，好吧。</p><p>So, an example would be that we can take two, which is one plus one.
            You know, true, true, or true, you know, the booleans defined using type
            theoretically as one plus one. Two is isomorphic to two in two different
            ways: by the identity and—I’ll just write it over here—and via the not
            function, okay. Because there’s not not—it’s just swapping true and
            false. And it is its own inverse, okay. The identity leaves them alone,
            okay.</p>
        <p>所以，我们有两个映射。所以，我们这里有两个，这是两个的另一个副本。我们有这个映射，我们有这个映射，好的，它们相交。所以，这些集合将是同构的，但它们同构的原因有两个。所以，我们可以这样写：我们可以——我们可以说——让我——我的符号太可爱了，所以让我们这样写，好的。</p><p>So, we have two mappings. So, we have here’s two, here’s another copy
            of two. We have this mapping and we have this mapping, okay, which
            crosses them up. So, these sets are going to be isomorphic, but there
            are two different reasons why they’re isomorphic. So, the way we can
            write that is: we can—we can really say—let me—my notation was too cute,
            so let’s write it like this, okay.</p>
        <h2 id="evidence-for-equivalence">等效性证据</h2><h2>Evidence for Equivalence</h2>
        <p>如果我们有一种类型的集合，那么二就是一个特殊的集合，即一加一。而恒等和非恒等是这些是同构类型的证据形式。这就是图景。所以，这是某种等价的证据。我会这样写，抱歉。这是等价的。符号再次不固定，但通常就是这样写的，好吧。看起来像那样。所以，这就是等价的证据，好吧。</p><p>If we had a type of sets, then two would be a particular set that’s
            one plus one. And identity and not are forms of evidence that these are
            isomorphic types. That’s the picture. So, this is evidence for some kind
            of equivalent. I’ll write it like that, sorry. And this is for
            equivalence. The notation is again not fixed, but something like that is
            usually the way it’s written, okay. Looking like that. So, that’s
            evidence for equivalence, okay.</p>
        <h2 id="generalization-of-equality-to-equivalence">等式推广到等价</h2><h2>Generalization of
            Equality to Equivalence</h2>
        <p>我们稍后再讨论这个问题，但我想在这里表达的是——这是对今天上午会议上提出的一个问题的半间接回答——这里的想法是，我将平等的想法推广到等价的想法，其中有等价形式的证据。这里发生的事情是，这是一个特定的休息点，好吧。</p><p>We’ll come back to that a little bit later, but the thing I wanted to
            get across here—and this is a semi oblique answer to a question that was
            asked in this morning’s session—which is the idea here that the one, the
            thing that is going on here is that I have generalized this idea of
            equality to one of equivalence, in which one has evidence for the forms
            of equivalence. And the thing that is going on here is that this is a
            particular resting point, okay.</p>
        <p>这是一个特别有用的点，适用于我们最终称之为离散集的东西。</p><p>This is a particularly useful point that applies to what we will end
            up calling discrete sets.</p>
        <h2 id="discrete-sets-and-judgments">离散集与判断</h2><h2>Discrete Sets and Judgments</h2>
        <p>我想我会等到稍后再完整解释这句话。但你只想从表面上看，我们只是将其陈述为一个命题：m = n。在冒号 a 中，只是一个判断，没有进一步的证据。原因是唯一形式的证据是一个代表反身性的简单标记；它们是相同的映射。这里我们有一些其他形式的证据，也就是说，除了身份或反身性之外，比如否定，这是两个事物可以被视为相等的另一个原因。</p><p>I think I’ll wait to fully explain that remark a little later. But
            the thing you want to see just superficially is that we state this just
            as a proposition: m = n.&nbsp;In colon a, just as a judgment, as it is, with
            no further evidence. The reason being that the only form of evidence is
            a trivial token, which represents reflexivity; that these are the same
            map. And here we have some other forms of evidence, that is, other than
            identity or reflexivity, like negation, which is a different reason why
            two things can be considered equal.</p>
        <p>这里最多只有一件事。因此，我们的想法是，我们压制了琐碎的证据，这些证据始终是反身性。这就是与 OTT 相关的东西——有人问我关于 OTT 的问题——它与 OTT 或身份相关。</p><p>Here, there’s at most one thing. So the idea is that we’re
            suppressing the trivial evidence, which is always reflexivity. And this
            is what is related to—someone asked me about OTT—and it’s related to
            OTT, or the identity.</p>
        <h2 id="ott-and-identity">OTT 和身份</h2><h2>OTT and Identity</h2>
        <p>它与此相关。好的，我稍后会再谈这个问题，但这就是——这确实是这里的想法。这是一个例子，其中 α 始终是反身性。但习惯上只关注这一点，因为在某些受限制的低维设置中，它会出现这种情况。在低维设置中，这本身就完全足够了。在更高维度中，你需要更多的东西。</p><p>It’s related to that. Okay, so I’ll come back to this a little bit
            later, but that’s the—that is the idea that’s going on here, really.
            This is an instance of that, in which α is always reflexivity. But it’s
            customary to just focus on this, because in certain restricted low
            dimensional settings, that’s the way it will come out. In low
            dimensional settings, then this is perfectly adequate for itself. In
            higher dimensions, it is—you need something more.</p>
        <h2 id="framework-for-higher-dimensional-type-theory">高维类型理论框架</h2><h2>Framework for
            Higher Dimensional Type Theory</h2>
        <p>所以我正在做的是，我正在尝试建立一个可扩展到更高维度类型理论的框架。这就是我正在做的。所以这是过去几年的新发展，我正试图以与这些发展一致的方式做每件事。这就是我的想法。好的。</p><p>So what I’m doing is I’m setting up, I’m trying to establish a
            framework that scales to higher dimensional type theory. That’s what I’m
            doing. So this is a new, like a new development, the last couple of
            years, and I’m trying to do everything in a way that is consistent with
            those developments. So that’s the idea about it. Okay.</p>
        <p>那么，我为什么要这么大惊小怪地谈论相等性呢？这和任何事情有什么关系呢？好吧，首先，这是一个有趣的问题——对不起，尤金，过敏——当两个证明相等时，这是一个有趣的问题。</p><p>So, why do I make such a big deal about equality? What does that have
            to do with anything? Well, first of all, it is an interesting question
            to talk about—excuse me, Eugene, allergies—it’s an interesting question
            to talk about when two proofs are equal.</p>
        <h2 id="equality-of-proofs-and-dependent-types">证明相等和依赖类型</h2><h2>Equality of Proofs and
            Dependent Types</h2>
        <p>但是，我要用依赖类型理论来处理的是这样一种情况，即两个证明是否相等不仅仅是智力上的重要性，而且是技术上的重要性。</p><p>But what I’m going to do with the theory of dependent types is a
            situation where whether two proofs are equal or not is something of
            prime technical importance, not merely of intellectual importance.</p>
        <p>好的。所以你可以在命题层面上理解它。两个证明是否相等，这只是一个智力上有趣的问题。并了解它们何时应该相等。当我们转到依赖类型理论时，就像我现在要做的那样，它变成了具有技术重要性的东西，而不仅仅是智力上的重要性。好的。</p><p>Okay. So you can have it at the propositional level. It’s just an
            intellectually interesting question that whether two proofs are equal.
            And to understand when they should be equal. When we pass to the theory
            of dependent types, as I’m going to do now, it becomes something that is
            of technical importance, and not just merely intellectual importance.
            Okay.</p>
        <p>所以，这就是我们想要做的。好的。那么，到目前为止我做了什么，只是为了让我们知道？</p><p>So, here’s what we want to do. Okay. So, what have I done so far,
            just so that we—we know?</p>
        <h2 id="type-theory-as-a-catalog-of-computations">类型理论作为计算的目录</h2><h2>Type Theory as a
            Catalog of Computations</h2>
        <p>所以，我到目前为止所做的，只是为了再次提醒你，我们专注于类型理论。最初，我们所做的是将其设置为证明的符号。但同样，我们可以做的是，我们可以将类型理论视为各种计算概念的目录。好的。我们引入了各种类型和形式的类型结构。</p><p>So, what I’ve done so far, just to remind you yet again, we’re
            focusing on type theory. And initially, what we’ve done is we’ve set it
            up as a notation for proofs. But equivalently, what we can do is we can
            think of type theory as being a catalog of a variety of notions of
            computation. Okay. We introduce various types and forms of type
            structures.</p>
        <h2 id="type-structure-and-programming-languages">类型结构和编程语言</h2><h2>Type Structure and
            Programming Languages</h2>
        <p>类型结构决定了编程语言的特性。例如，您是否具有高阶函数就等于说“您有指数类型吗？”好吗？您是否具有结构或元组就等于说“您有笛卡尔积类型吗？”您是否具有选择或多个数据类型对应于您是否具有某些类型，等等。换句话说，编程语言实际上只是类型的集合，对吗？类型结构决定了语言结构到底是什么。</p><p>The type structure determines the programming language features. So,
            for example, whether you have higher order functions amounts to saying,
            “Do you have exponential types?” Okay? Whether you have structs or
            tuples amounts to saying, “Do you have Cartesian product types?” Whether
            you have choices or multiple classes of data corresponds to whether you
            have some types, and so forth. So, in other words, a programming
            language is really just a collection of types, right? The type structure
            determines what the language structure really is.</p>
        <h2 id="type-theory-as-a-theory-of-constructions">类型理论作为构造理论</h2><h2>Type Theory as a
            Theory of Constructions</h2>
        <p>因此，人们说类型理论是一种构造理论。它是你可以构建的东西 — — 你可以用它做数学题或编程的小玩具。</p><p>So, what people have said is that the idea of type theory is that
            it’s a theory of constructions. It’s the things you can build—your
            little tinker toys that you can build with to do your math, or
            equivalently, your programming.</p>
        <p>因此，类型理论是一种构造理论。从这个角度来看，逻辑是类型理论的一种应用，因为存在与证明相对应的特定构造。但还有其他构造，如自然数本身或几何对象的构造，它们并不对应于特定命题的证明；它们只是数学构造。</p><p>So, type theory is a theory of constructions. From that point of
            view, logic is an application of type theory because there are
            particular constructions which correspond to proofs. But there are other
            constructions, like of the natural numbers themselves or geometric
            objects, that don’t correspond to proofs of particular propositions;
            they’re just mathematical constructions.</p>
        <p>所以，我们感兴趣的是数学构造的一般概念。好吗？顺便说一下，这就是“构造演算”这个术语的由来。好。这就是起源。</p><p>So, what we’re doing is we’re interested in the general concept of
            what is a mathematical construction. Okay? And that’s where the
            terminology “calculus of constructions” comes from, by the way. Okay.
            This is the origin.</p>
        <h2 id="constructive-logic-and-computer-science">构造逻辑与计算机科学</h2><h2>Constructive Logic and
            Computer Science</h2>
        <p>事实上，这就是为什么直觉主义逻辑有时被称为建设性逻辑，或者该学说有时被称为建构主义，因为布劳威尔强调了我所描述的意义上的建构思想。</p><p>And in fact, that’s why intuitionistic logic is sometimes called
            constructive logic, or the doctrine is sometimes called constructivism,
            because Brouwer emphasized the idea of a construction in the sense I’m
            describing.</p>
        <p>事实上，布劳威尔的名言是这样的思想，这个原则，即数学——而不是数学是逻辑的进一步发展——即数学建立在逻辑之上——这是反过来的。逻辑只是数学的一个特定角落。我想说，从现代的角度来看，它实际上只是计算机科学的一个特定角落，因为数学本身就是计算机科学的一个角落。好吧。不，这就是想法。因为计算机科学是基于计算构造的思想，而布劳威尔的观点是，你可以在构造的思想上构建所有的数学，也就是计算机程序的思想。所以，实际上，这都是计算机科学。好吧。如果你问我，计算机科学是科学之王。好吧。过去人们认为它是数学，但事实并非如此。好吧。它实际上是计算机科学。所以，这就是我们在这里谈论直觉逻辑时试图做的重点。</p><p>And in fact, Brouwer’s dictum is the idea, the principle, that
            mathematics—rather than mathematics being sort of a further development
            of logic—that is, mathematics builds on logic—that’s the other way
            around. That logic is just a particular corner of mathematics. And I
            would say, from a modern perspective, actually, it’s just a particular
            corner of computer science, because math itself is just a corner of
            computer science. Okay. No, that’s the idea. Because computer science is
            based on the idea of constructions in computing, and Brouwer’s point is
            that you can build all the mathematics on the idea of construction,
            which is the idea of a computer program. So, really, it’s all computer
            science. Okay. Computer science is the queen of sciences, if you ask me.
            Okay. It used to be people thought it was math, but it’s not. Okay. It’s
            actually computer science. So, that’s the thrust of what we’re trying to
            do here in talking about intuitionistic logic.</p>
        <p>这就是为什么我认为编程语言的结构不是可以随意改变的。好的。这是一个科学发现的问题。它不是“哦，随便吧，你知道，某个地方某个很有魅力的男人或女人想出了一些疯狂的东西，因此它是好的。”好的。这不是我们要讨论的。好的。所以，这就像是对编程语言的不同看法。好的，到目前为止，我们已经建立了命题逻辑。</p><p>And this is the reason why I have the point of view that the
            structure of programming languages is not up for grabs. Okay. It’s a
            matter of scientific discovery. It’s not like, “Oh, whatever, you know,
            some guy or gal somewhere who’s very charismatic comes up with some
            crazy ass thing, and therefore it’s good.” Okay. That’s like not what
            we’re about. Okay. So, it’s like a different perspective on what
            programming languages are about. Okay, so far we’ve set up propositional
            logic.</p>
        <h2 id="elementary-constructions-in-type-theory">类型论中的基本构造</h2><h2>Elementary
            Constructions in Type Theory</h2>
        <p>这些是基本构造，各种构造。这些类型。我们有空类型，零，一，十字 b，加号 b，箭头 b。好的。从逻辑上讲，它们是假、真、合取、析取和蕴涵。好的。这就是我们目前所拥有的，以及与之相关的所有术语。这是很好的东西。但现在还会有一些其他的东西。我想在这里谈论的是类型家族的概念。</p><p>So these are kind of elementary constructions, various kinds of
            constructions. So these types. So what we have is the empty type, zero,
            we have one, we have a cross b, a plus b, a arrow b. Okay. Which, in
            logical terms, are false, true, conjunction, disjunction, and
            implication. Okay. So this is what we have so far, and all the terms
            associated with it. So that’s a good bit of stuff. But now there’s going
            to be some other stuff. And the thing that I want to talk about here is
            the notion of a family of types.</p>
        <h2 id="family-of-types-and-predicates">类型和谓词系列</h2><h2>Family of Types and
            Predicates</h2>
        <p>好的。这很关键。这就是——你可以把它看作是对谓词或关系概念的概括——你可以把它看作是谓词或关系概念的概括。好的。</p><p>Okay. This is critical. And what this is is this is—you can think of
            it as a formulation over a generalization of—you can think of it as a
            generalization really of the concept of a predicate or a relation, as it
            comes up. Okay.</p>
        <p>例如，如果我们看一下数字 x 为偶数的基本性质。好的。事实上，为了强调这一点，这是正确的。假设我们有自然数。我还没有谈到我们如何做到这一点。好的。但我们可以说有一个关于 x 的偶数命题。这个命题是偶数。我的想法是，我想把它看作一个命题函数。</p><p>So, for example, if we look at the elementary property of a number x
            being even. Okay. And in fact, to be emphatic about it, that’s right.
            Let’s assume we have the natural numbers around. I haven’t gotten yet to
            talking about how we do that. Okay. But we can say there’s a proposition
            even of x. The proposition is even. The idea is I want to think of this
            as a propositional function.</p>
        <h2 id="propositional-functions-and-families-of-types">命题函数和类型族</h2><h2>Propositional
            Functions and Families of Types</h2>
        <p>因此，这可以被认为是一个谓词。这是通常的思考方式。但是因为我们处于一个建设性环境中，所以它不是一个谓词。因此，这就像人们做的另一件有害、令人讨厌的事情，因为他们将命题的概念等同于布尔值的概念，因此他们将谓词的概念等同于返回真或假的函数。这是错得不能再错了。这是错的。因此，像 C 中的断言语句或类似的东西——这是一种——这是一种非常滥用的术语，因为它们的本质是返回布尔值的函数和正确的谓词之间存在差异。我稍后会再谈到这一点。</p><p>So this can be thought of as a predicate. That’s the usual way to
            think about it. But because we’re in a constructive setting, it’s not a
            predicate. So this is like another pernicious, annoying thing that
            people do, which is because they equate the idea of a proposition with
            the idea of a boolean, they therefore equate the idea of a predicate
            with a function that returns either true or false. This is as wrong as
            wrong can be. It’s just wrong. So things like assert statements in C or
            something like this—that’s a—like that’s a very, it’s an abusive use of
            the terminology because what they are is there’s a difference between a
            function that returns a boolean and a proper predicate. I’ll come back
            to that later.</p>
        <p>所以这可以被认为是一个谓词，对吧？这是通常的情况。但它也可以被认为是一个命题函数。好吧。命题函数，因为你可以把它想象成描述一个映射——只要把它变成一个大长箭头——对于 N 中的每个 x，即使是 x 也是一个命题。它是当应用于数字时产生命题的东西。所以它是一个命题函数。让我这样写，这样你就能清楚地看到这一点。</p><p>So this can be thought of as a predicate, right? That’s the usual
            thing. But it can also be thought of as a propositional function. All
            right. Propositional function, because you can think of this as
            describing a mapping—just make that be a big long arrow—for every x in
            N, even of x is a proposition. It’s something that yields a proposition
            when applied to a number. So it’s a propositional function. So let me
            write it like that, so you can see that clearly.</p>
        <p>或者换句话说，在本例中，它是一个类型系列，由 N 索引。这很有趣。因为我们可以想到它——另一种表示法。我不会真的用这个，但你可以这样看：即使是 x 也是一个 prop。它可以被认为是一个家族。对于每个 xn，这是一个看起来很熟悉的表示法，与我在这里写的一样。好的。</p><p>Or another way to say it is it’s a family of types in this case,
            indexed by N. That’s the interesting one. Because we can think of
            it—another notation for that. I’m not really going to use this, but you
            can look at it like this: even of x is a prop. It can be thought of as a
            family. For every xn, which is a familiar looking notation for the same
            thing as what I’ve written here. Okay.</p>
        <p>那么，为什么这是一个重要或有趣的想法呢？为什么这个观点很有趣？</p><p>Now, why is this an important or interesting idea? Why is this
            perspective interesting?</p>
        <p>嗯，这是因为过程类型原理。记住，某事物为真与拥有一个居民有关。真实意味着我有一个证明。证明是一个对象。因此，有了证明，有了这种类型的元素，我就可以拥有——我可以说，我可以陈述某些数字何时为偶数。好的。我可能可以泛化地，在 x 中，在关于 x 的一些附加条件下，这个想法将是……好的。所以，这个想法是，当我这样做时，我所做的就是展示一个类型系列。在那里，如果你给我任何特定的数字选择，它都会给我一个有居民或没有居民的命题。</p><p>Well, it’s because of the process types principle. Remember the idea
            of something being true is identified with having an inhabitant. Truth
            means I have a proof. A proof is an object. So, having a proof, an
            element of this type, so I can have—I can say, you know, I can make
            statements about when certain numbers are even. Okay. And I can maybe
            generically, in x, under some additional conditions about x, and the
            idea will be… okay. So, the idea is that when I do that, what I’m doing
            is I’m exhibiting a family of types. In that, if you give me any
            particular choice of number, it’s going to give me back a proposition
            which has inhabitants or not.</p>
        <p>例如，三的偶数将无人居住。这就是我们要说的。假设我给出了偶数的定义，您将无法找到这种类型的术语。到目前为止，我实际上还没有这样做。我正在粗略地制定总体计划。即使两个也会有人居住。这将是一个例子。一般来说，我们将有无数个命题贯穿这里，表达每个自然数的均匀性。所以，这些都是由自然数索引的。所以，这是0到这里，1到这里，2到这里，等等。好的。</p><p>For example, even of three will be uninhabited. That’s what we’re
            going to say. You won’t be able to find a term of that type, assuming I
            gave a definition of even. I didn’t actually do this so far. I’m
            roughing out the general plan. Even if two will be inhabited. That will
            be an example. And in general, we’re going to have an infinity of
            propositions going across here, expressing the evenness of each of the
            natural numbers all the way across. So, these are all indexed by the
            natural numbers. So, this is over 0 goes to here, 1 goes to here, 2 goes
            to here, and so forth. Okay.</p>
        <p>还有另一种思考方式。思考此图的另一种方式是将其视为一个很大的、相当大总和。我们所做的就是将每个数字上的纤维分离出来。因此，我们的想法是，我们在这里看，你可以将其视为一个大——我将使用一个稍后会定义的符号——偶数的大总和。这个想法是，在我绘制的这幅图中，我在任何地方都会有一个数字，好吧，还有一个证明，我们称之为 p，证明该数字是偶数。</p><p>There’s another way to think about this. Another way to think about
            this diagram is to think of it as a big, kind of fat sum over here. And
            what we do is we isolate what are called the fibers over each number.
            So, the idea is that what we do is we look here, and what this is is you
            can think of this as the big—I’m going to use a notation which I’ll
            define later—the big sum of even. The idea is that in this picture that
            I’m drawing, what I will have at any spot is a number, okay, together
            with a proof, let’s call it p, that that number is even.</p>
        <p>如果该数字不是偶数，则其中不会有这样的对。因此，如果我在这里选择任何数字，比如说这里的 2，我可以查看整个切片——这个小切片——所谓的，这称为光纤，好的。我可以查看 2 上的光纤，它由所有以逗号形式出现的对组成，好的，就是这样写的。这对应于——该光纤对应于该家族的实例，对应于 x 等于 2。</p><p>And if that number isn’t even, there won’t be such a pair in it. So,
            if I pick any number here, okay, like let’s say two down here, I can
            look at all of the slice—this little slice—the so called, this is called
            the fiber, okay. I can look at the fiber over two, consists of all the
            pairs of the form two comma something, okay, are written like that. And
            that corresponds—that fiber corresponds to the instance of this family
            corresponding to x being equal to 2.</p>
        <p>如果我想查看与 x 为 3 对应的家族实例，它就是那个光纤。对于每个数字，都会有另一个光纤，无论我们想要哪个。在某些情况下，图中的光纤有点误导，因为光纤是空的；没有。好的。没有理由说它必须具有任何特定的大小，但直觉是，你看这个所谓的总空间，好吗？</p><p>And if I want to look at the instance of the family corresponding to
            x being 3, it will be that fiber. And there will be another fiber all
            the way over for each of the numbers, whichever ones we want. In some
            cases, the fiber in the picture is a little misleading because the fiber
            will be empty; there will be none. Okay. There’s no reason why it has to
            have any particular size, but the intuition is that you look at this big
            so called total space, okay?</p>
        <p>然后你看看那些向下投射的东西，在这种情况下，通过第一个投射，它们投射到一个特定的数字上。所有向下投射的东西都被认为是彼此叠在一起的；它们在同一个垂直维度上。所以有一个，一个在这里，一个在这里，一个在这里，一个在这里，一个在这里。也许没有，好吗？但不管它们是谁，这些都是四的形式，p，它们都位于四之上。</p><p>And then you look at the things that project down, in this case, by
            the first projection, that project down onto a particular number. And
            all the ones that project down are to be thought of as sitting on top of
            each other; they’re in the same vertical dimension. So there’s one, one
            here, and one here, and one here, and one here, one here. Maybe there
            are none, okay? But whoever they are, these are all the things of the
            form four, p, and they all sit above four.</p>
        <p>这就是所谓的四维纤维。这是另一种思考类型家族的方式。所以它是一个命题函数，它是一个类型家族，或者用这个术语来说，它是一种振动，好吗？</p><p>So that’s called the fiber over four. So that’s another way to think
            about what a family of types looks like. So it’s a propositional
            function, it’s a family of types, or as this terminology goes, it’s a
            vibration, okay?</p>
        <h2 id="vibrations-and-families-of-types">振动和类型系列</h2><h2>Vibrations and Families of
            Types</h2>
        <p>这是另一种思考方式。因此，即使在这种情况下，人们也会将其描述为振动。当他们将其描述为振动时，这就是他们脑海中的想法，好吗？这就是他们脑海中的那种画面，好吗？没错，就是这样。因此，这些只是思考同一概念的不同方式。</p><p>That’s another another way to think about it. So people will
            describe, even in this kind of context, they’ll describe it as a
            vibration. When they describe it as a vibration, this is what they have
            in mind, okay? This is the kind, the kind of picture that they have in
            mind, okay? Right, that’s going on. So these are just different ways of
            thinking about the same concept.</p>
        <p>现在，这种平等在这种情况下如此重要的原因在于应该称之为功能性、功能性或尊重平等的原则。</p><p>Now, the reason that this equality is so important in this setting is
            because of the principle of what should be called, which is called
            functionality or functoriality or respect for equality.</p>
        <h2 id="functionality-and-respect-for-equality">功能性和尊重平等</h2><h2>Functionality and
            Respect for Equality</h2>
        <p>因此，功能性在各种意义上等同于尊重平等。这是核心概念。其理念是，如果总而言之，aᵢ 具有 b，而 b 具有，假设我将在其中放置一个小 x 来表示它随 x 而变化，则是一种类型，它是这样写的。如果您给我，那么，我们将要写下的所有各种东西，那么我们首先要写下的是这个，如果您给我 m，它是 a 类型，那么您可以为 x 形成一个实例 m，b — 你知道，bᵢₓ 将进入这里 — 将是一种类型。</p><p>So functionality equals respect for equality in various senses. This
            is the central notion. And the idea of this is that if, in sum, aᵢ has
            b, which has, let’s say, I’ll put a little x there to indicate it varies
            with x, is a type, it’s written like that. And if you give me, so one,
            all the various things we’re going to write down, so first thing we’ll
            write down is this, and if you give me m, which is of type a, then you
            can form an instance m for x, b—you know, bᵢₓ will go in here—is going
            to be a type.</p>
        <h2 id="definitional-equality-of-types">类型定义相等性</h2><h2>Definitional Equality of
            Types</h2>
        <p>这是第一件事。所以这个想法是，如果你有一个域上的谓词，好吗？这是一种思考方式，因为你有一个由类型索引的类型系列。所以它是域上的谓词。如果我有这个域的一个实例，那么这个谓词可以专门用于这个特定的实例。但功能条件说得更多。它说如果你有这样的东西，你给我相等的东西——现在问题来了，当然是定义上相等的东西——这是一个起点——那么我就会知道这些实例在定义上是相等的。</p><p>So that’s the first thing. So the idea is if you have a predicate
            over a domain, all right? That’s one way, one way to think about this,
            because you have a family of types indexed by a type. So it’s a
            predicate over a domain. If I have an instance of this domain, then that
            predicate can be specialized to that particular instance. But the
            functionality condition says more. It says if you have such a thing and
            you give me equal—and now here’s the issue, certainly definitionally
            equal things—that’s a starting point—then I will know that the instances
            are definitionally equal.</p>
        <p>这是第一条原则，即建立类型定义相等的概念。因此，在均匀性的情况下，您现在可以看到，我们有这样的想法：普通变量（即跨类型的变量）可以出现在类型内。</p><p>That’s the first principle, establishing the notion of definitional
            equality of types. So, in the case of evenness, you see now that we have
            the idea that an ordinary, that is, a variable ranging over a type, can
            occur within a type.</p>
        <h2 id="typing-and-definitional-equality">类型和定义平等</h2><h2>Typing and Definitional
            Equality</h2>
        <p>嗯，这是一个命题或类型；你知道，我现在交替使用它们。那么，这个想法就是你有一个可以在这里出现的变量。所以，如果我给你定义相等的实例，那么它们将是定义相等的类型。定义相等类型的重要性在于类型尊重定义相等。好的。</p><p>Well, this is a proposition or a type; you know, I use them
            interchangeably at the moment. Then, the idea is that you have this
            variable that can occur in here. So, if I give you definitionally equal
            instances, then they are going to be definitionally equal types. And the
            importance of being definitionally equal types is that typing respects
            definitional equality. Okay.</p>
        <p>所以，我假设你已经记下了。既然我们开始建立一些相当大的机器，那么让我写下一些东西。现在，让我试着小心地把所有东西都正确地写下来。所以，我们将把 γ 作为一个上下文。</p><p>So, I assume you’ve written this down. So, let me write down a few
            things now that we’re starting to establish some fairly large machinery.
            Now, so let me try to be careful about writing everything down properly.
            So, we’re going to have the idea of γ being a context.</p>
        <h2 id="context-families-and-elements">背景、家庭和元素</h2><h2>Context, Families, and
            Elements</h2>
        <p>我们将了解定义等价上下文的概念。我们将了解由 γ 索引的类型系列的概念。我们将了解定义等价类型、类型系列的概念。我们将了解类型元素的概念以及该类型的定义等价元素的概念。这是我们需要的最基本设置。好的。</p><p>We’re going to have the idea of definitionally equivalent contexts.
            We’re going to have the idea of a family of types indexed by γ. And
            we’re going to have the idea of definitionally equivalent types,
            families of types. And we’re going to have the idea of an element of the
            type and the idea of definitionally equivalent elements of that type.
            This is the most basic setup that we need. Okay.</p>
        <p>所以，这就是框架。目前这里最重要的是定义相等的类型对相同元素进行分类。我们在这里写 b。</p><p>So, this is the framework. The most important thing here at the
            moment is definitionally equal types classify the same elements. Let’s
            write b here.</p>
        <h2 id="definitional-equality-and-classifiers">定义平等和分类器</h2><h2>Definitional Equality and
            Classifiers</h2>
        <p>如果 a 等同于 b，这很重要。好的。因此，定义上等价的类型对相同的术语进行分类。因此，如果您可以证明这两种类型在定义上是等价的，那么如果您有一种类型的术语，那么您也会有与另一种类型的术语完全相同的术语，即 b。好的。</p><p>If a is equivalent to b, this is important. Okay. So, definitionally
            equivalent types classify the same terms. So, if you can show the two
            types are definitionally equivalent, then if you have a term of one
            type, then you also have a term of the exact same thing as a term of the
            other type, b. Okay.</p>
        <p>所以，这是一个核心原则。我还没有告诉你，除了替换之外，类型定义相等的原则到底是什么。所以，还有替换原则。所以，对于——我在这里使用它们。好的。所以，我在这里使用它，当我替换 x 时，我会从特定实例中得到一个类型。所以，一般来说，我们将有如下所示的替换规则，其中 x 在 a 中。</p><p>So, that’s a central principle. I haven’t told you what exactly are
            the principles of definitional equality of types other than by
            substitution. So, there are substitution principles going on. So,
            for—and I use them here. Okay. So, I used it here when I substitute for
            x, I get a type out of the particular instance. So, in general, right,
            we’re going to have substitution rules that look like this, with x’s in
            a.</p>
        <h2 id="substitution-rules-and-instances">替换规则和实例</h2><h2>Substitution Rules and
            Instances</h2>
        <p>如果我知道 b 是一种类型，那么我知道如果 m 是 a，它与这个东西相关，那么我知道 xb 的 m 就是类型。这些是实例。好的。</p><p>If I know that b is a type, then I know if m is an a, it’s related to
            this thing, then I know that m for x b is the type. Those are instances.
            Okay.</p>
        <p>就像之前一样，我说过有些事情是一个问题。</p><p>Like earlier on, I said something is a problem.</p>
        <h2 id="dependent-types-and-families-of-types">依赖类型和类型系列</h2><h2>Dependent Types and
            Families of Types</h2>
        <p>我现在以紧凑的速度做所有事情。好的。如果愿意，我可以用命题语言来做，但我决定确定中心概念的构造，因此我使用类型术语来做所有事情。所以，这些很重要，但我试图通过这个谓词来激发它们，然后另一条规则 - 我不会再写了 - 是这条规则。那条规则是这条规则，也是这条规则。所以，如果你想真正完整地写出来，它会说：如果你有一个类型系列<em>b ，由</em><em>a</em>索引，并且如果<em>m</em>
            和<em>n</em>是定义上相等的索引元素，那么你得到的类型在定义上是相等的 - 那应该是<em>b</em>。</p><p>I’m now doing everything in tight speed. Okay. I can do it in
            propositional speak if I want, but I’ve decided to settle on
            constructions for the central notion, and so I’m doing everything using
            type terminology. So, these are important, but I was trying to motivate
            them by, like, of this predicate, and then the other rule—I won’t write
            it again—is this rule. That rule is this rule, and also this rule. So,
            if you wanted to really write it out fully, it says: If you have a
            family of types, <em>b</em>, indexed by <em>a</em>, and if <em>m</em>
            and <em>n</em> are definitionally equal index elements, then the types
            you get back are definitionally equal—that should be <em>b</em>.</p>
        <p>因此，根据这条规则，它们可以互换为分类器。所以，不知何故，一切都由该特定规则驱动。好的。所以，这开始是依赖类型概念的开始——这是一切的开始，好的。现在，我还没有——我甚至有点把它
            <em>当成</em>一个原始概念。事实上，它是可定义的，但它需要一些机制——归纳定义——我还没有。所以，我将对具体哪些是事物稍微宽泛一点，除了一种情况，接下来会介绍。好的。我们会这样做。我将讨论身份类型。
        </p><p>And therefore, by this rule, they’re interchangeable as classifiers.
            So, somehow, everything is driven by that particular rule. Okay. So,
            that starts to be the beginning—this is the beginnings of it all,
            okay—of the idea of dependent types. Now, I haven’t—I sort of acted like
            <em>even</em> was a primitive notion. In fact, it’ll be definable, but
            it needs a little machinery—that of inductive definitions—that I don’t
            have yet. So, I’m going to be a little loose about exactly which are the
            things, except in one case, which is coming up next. Okay. We’ll do
            that. I’ll talk about the identity type.
        </p>
        <h2 id="identity-type-and-families-of-types">身份类型和类型系列</h2><h2>Identity Type and Families
            of Types</h2>
        <p>好的，让我花一分钟检查一下这里发生了什么。我想确保我在这里说的是正确的话，对吧？好的。我必须找出合适的时机来介绍这一点。好的。所以，这是一般理论，所以我的第一点是：一旦你有了一个类型家族的概念。</p><p>Okay, so let me check for a minute what’s going on here. I want to
            make sure I say the right thing here, right? Okay. I have to figure out
            the right moment to bring this in. Okay. So, this is the general theory,
            and so the my my first point is: as soon as you have the idea of a
            family of types.</p>
        <h2 id="families-of-types-and-relations">类型和关系系列</h2><h2>Families of Types and
            Relations</h2>
        <p><em>所以，</em>这表达了类型家族的概念，因为
            <em>γ</em>是什么？<em>γ</em>是一堆变量声明。所以，<em>γ通常具有</em><em>x₁a₁</em>
            到<em>xₙaₙ</em>的形式。这就是我之前提到的符号。好的。这就是这个想法。所以，这说明这是一个由<em>γ</em>中的变量索引的类型家族。所以，正如我提到的，如果<em>x</em> — 那么让我们再做一次 — 假设如果
            <em>x</em>、<em>y</em>或<em>n</em> — 那是两个变量。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>So, this is expressing the idea of a family of types, because
            <em>γ</em> is what is <em>γ</em>? <em>γ</em> is a bunch of declarations
            of variables. So, <em>γ</em> generally has the form <em>x₁a₁</em>
            through <em>xₙaₙ</em>. That’s the notation I mentioned that before, up
            here. Okay. So, that’s the idea. So, what this says is that this is a
            family of types indexed by the variables in <em>γ</em>. So, we have, as
            I mentioned, if <em>x</em>—so let’s do another one—let’s say if
            <em>x</em>, <em>y</em>, or <em>n</em>—those are two variables.
        </p>
        <p>那么也许<em>x ≤ n</em>。我只需将<em>n</em>写在那里即可——或者我将它写在这里；写在哪里并不重要。我们就把它写在这里吧。好的。它将是一种类型。所以，这是一个关系的例子——关系是一个双参数命题函数，或者是一个由两个变量索引的类型族。对吗？对于<em>x的每一个选择和</em><em>y</em>的每一个选择（范围在
            <em>n上），我都会得到一个类型——对于特定的</em><em>x</em>和<em>y</em>的选择，<em>x ≤ y</em>的证明类型。好的。这才是最重要的。
        <em></em><em></em></p><p>Then maybe <em>x ≤ n</em>. And I’ll just write the <em>n</em> on
            there just to be—or I’ll put it over here; it doesn’t matter where I
            write it. Let’s put it here. Okay. It’s going to be a type. So, that is
            an example of a relation—a relation is a two argument propositional
            function, or a family of types indexed by two variables. Right? For
            every choice of <em>x</em> and every choice of <em>y</em> ranging over
            <em>n</em>, I get back a type—the type of proofs that <em>x ≤ y</em> for
            that particular choice of <em>x</em> and <em>y</em>. Okay. That’s what’s
            important.
        </p>
        <p>所以，我想要向你们灌输的是消除你们的布尔偏见。</p><p>So, the thing that I’m trying to inculcate in you is to stamp out
            your Boolean prejudices.</p>
        <h2 id="inhabitation-of-types-and-predicates">类型和谓词的栖居</h2><h2>Inhabitation of Types and
            Predicates</h2>
        <p>好的。谓词不像布尔值那样代表；这就像是你必须取消那个想法。好的。谓词是一类类型，当你实例化它时，你得到的是一个分类器，它是该类实例的所有证明的分类。好的。因为“三小于或等于七”是一个谓词，所以它是一种类型。它是这个数字小于那个数字的证明类型。</p><p>Okay. Predicates don’t stand for like a Boolean; that’s like you have
            to undo that thought. Okay. A predicate is a family of types, and what
            you do is when you instantiate it, what you get back is a classifier,
            which is the classification of all the proofs of that instance of the
            family. Okay. Since “three is less than or equal to seven” is a
            predicate, it is a type. It’s the type of proofs that this number is
            less than that number.</p>
        <p>好的。你必须这样建设性地思考。没有别的方法。好的。你必须这样思考。一旦你开始习惯了，很多事情对你来说就会更有意义。事实上，坦率地说，这种思维的力量是惊人的。在我的职业生涯中，我有一些最惊人的经历，这些经历都取决于这种建设性的观点。所以我认为这就是要传达的东西。好的。那么到目前为止你同意我的观点吗？好的。</p><p>Okay. This is the way you must think constructively. There’s no other
            way. Okay. You must think in those terms. As soon as you start getting
            used to that, then a lot of things will make more sense to you. And in
            fact, the power of this thinking is, to be quite honest, breathtaking.
            In the course of my career, I’ve had some of the most astonishing
            experiences that are kind of hinge on this kind of constructive
            perspective. So I think that is the thing to get across. Okay. So you’re
            with me so far on that? Okay.</p>
        <p>所以，三比七不是布尔值；它是一种类型。好的。所以，是的，哦，当然。所以还有另一种类型。让我擦掉，因为我不会被占用。好的。你不会知道那种类型的证明。因此，作为一个命题，你将无法说它是真的。好的。这就是这个想法。是的。所以它是类型的占用。我的意思是，这才是最重要的，因为这可以追溯到我的基本原则：真意味着我知道一个证明。同样，相关联的类型……</p><p>So, three less than seven is not a boolean; it’s a type. All right.
            So, yeah, oh absolutely. So there’s another type. Let me just erase
            because I will not be inhabited. Okay. You won’t know a proof of that
            type. Therefore, thought of as a proposition, you will not be able to
            say that it’s true. Okay. So that’s the idea. Yeah. So it’s the
            inhabitation of the type. I mean, that’s the thing that matters because
            this goes back to my basic principle of: true means I know a proof.
            Equivalently, that the type associated…</p>
        <h1 id="type-theory-foundations-2.2-robert-harper">类型理论基础 2.2 — Robert Harper</h1><h1>Type Theory
            Foundations 2.2 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 5:51 <a href="https://youtube.com/watch?v=0RROK_-pAlQ">https://youtube.com/watch?v=0RROK_-pAlQ</a></p><p> 11
            years ago (Jan 2, 2014) — 5:51 <a href="https://youtube.com/watch?v=0RROK_-pAlQ">https://youtube.com/watch?v=0RROK_-pAlQ</a></p>
        <h2 id="summary-5">概括</h2><h2>Summary</h2>
        <p>本视频讨论了类型理论的基础，重点介绍了类型内的相等性概念。Robert Harper 探讨了不同类型（如子范围类型）之间的关系。演讲者强调了定义相等性和命题相等性之间的区别，以及这对类型之间的关系有何影响。视频最后提出了一个关于意向性与外延性类型理论的诱人问题，暗示了未来关于函数性的讨论。</p><p>This video discusses the foundations of Type Theory, focusing on the
            concept of equality within types. Robert Harper explores how different
            types, like sub-range types, relate to each other. The speaker
            highlights the distinction between definitional and propositional
            equality, and how this impacts the relationship between types. The video
            concludes with a tantalizing question about intentional versus
            extensional type theory, hinting at a future discussion on
            functoriality.</p>
        <h2 id="inhabited-types-and-conceptual-economy">居住类型和概念经济</h2><h2>Inhabited Types and
            Conceptual Economy</h2>
        <p>对于断言，是一种有人居住的类型。啊，好的。所以有一个很好的，另一种思考方式是，存在一个概念经济。各种看似不同的东西都归结为一件事。好吗？这很好，对吧？这总是好的。好的。其他问题？好的。我现在应该去几点？是的，这几乎是我的时间。好的。然后，让我——让我——我想让我们在一个合适的休息点离开。这不是——这不是坏事。</p><p>To the assertion, is an inhabited type. Ah, okay. So there’s a nice,
            another way to think about it is there’s a conceptual economy. All sorts
            of seemingly disparate things collapse down to one thing. Okay? And
            that’s good, right? That’s always good. All right. Other questions?
            Okay. What time am I supposed to go to now? Yes, this is pretty much my
            slot. Okay. Then, let me—let me—I want to leave us at a decent resting
            point. This is not—this is not bad.</p>
        <p>好的。另一件事是休息点。我想说的另一件事是。好的。这是第一个一般设置。现在进入下一个问题，即重新审视平等的概念，特别是参考平等的概念。</p><p>Okay. The other thing is a resting point. The other thing I want to
            say though about it is this. Okay. So that’s the first general setup.
            Now becomes the next question, which is to revisit this notion of
            equality and, in particular, the idea of equality of reference.</p>
        <h2 id="equality-of-reference-and-example">参照与实例的平等</h2><h2>Equality of Reference and
            Example</h2>
        <p>因为我想说什么？我想说的是——这是我要给你的一个例子——一个非常著名的例子。好的。这个例子出现过很多次，因为每个天真的语言设计师都会想出这个想法，然后，就像是一败涂地。好的。但这个想法是这样的。你可以把它想象成——有些人——有各种各样的写法。我们可以说，哎呀，让我给自己留点空间。</p><p>Because what do I want to say? What I want to get to is—and this is a
            kind of example I’m going to give you—is a very famous one. Okay. That
            has come up many times, because every naive language designer comes up
            with this idea and then, like, falls flat on his face. Okay. But here’s
            the idea. You can think of this as—some people—there are various ways to
            write it. We can say, oops, let me leave myself some room.</p>
        <p>我们的想法是，我们可以看看类型，也许 0…x，将是一种类型。</p><p>The idea is that we can look at the type, maybe 0…x, is going to be a
            type.</p>
        <h2 id="subrange-types-and-predicates">子范围类型和谓词</h2><h2>Subrange Types and
            Predicates</h2>
        <p>而这应该被认为是——你应该——这个想法是，它应该是，你知道，0、1、2，直到，比如说，x 1。类似的东西。好的，或者 x。我真的不在乎，无论你想做什么。好的。我只是——我只是从众多例子中挑选一个。好的。所以人们已经尝试过这样做。好的。这些有时被称为子范围类型或类似的东西。所以关键的想法是——或者你可以把它看作一个谓词。</p><p>And that’s supposed to be thought of as—you’re supposed—the idea is
            it’s supposed to be, you know, 0, 1, 2, up to, let us say, x 1.
            Something like that. Okay, or x. I don’t care really, whatever you want
            to do. Okay. I’m just—I’m just picking one of many examples out. Okay.
            So people have tried to do this. Okay. These are sometimes called sub
            range types or various things like this. So the critical idea is that—or
            you can think of as a predicate.</p>
        <p>您可以将其视为表达谓词，即您正在表达谓词。您可以将其视为
            <em>y</em>中的谓词，它表示，给定<em>y</em>和<em>n</em>，如果<em>y</em>介于 0 和<em>x</em>之间，假设我在<em>n</em>中这样做，那么它表达的就是这个意思。好的。这是针对某个固定的<em>x</em>的。好的。这是一种思考方式。所以这应该是一种类型。好的。这就是人们所反对的东西。
        </p><p>You can think of this as expressing the predicate that the—that
            you’re expressing a predicate. You can think of this as a predicate in
            <em>y</em> that says, well, given <em>y</em> and <em>n</em>, if the idea
            that <em>y</em> lies between 0 and <em>x</em>, let’s say, if I did it
            like that in <em>n</em>, that’s equivalently what it’s expressing. Okay.
            This is for some fixed <em>x</em>. All right. That’s a way of thinking
            about it. So that’s supposed to be a type. Okay. So here is the kind of
            thing that people run afoul of.
        </p>
        <h2 id="relationship-between-types-0-to-xy-and-0-to-yx">0 至 x+y 和 0 至 y+x 类型之间的关系</h2><h2>Relationship
            Between Types 0 to x+y and 0 to y+x</h2>
        <p>问题是：假设我现在有<em>x</em>、<em>y</em>和
            <em>n</em>，我想说一下类型 0 到<em>x</em> + <em>y与类型 0 到</em><em>y</em> + <em>x</em>之间的关系——我就写成与——它们之间的关系。它们之间的关系是什么？好的。因为这是在此基础上的类型，假设我有加号和其他东西，就像我通常做的那样，这就是类型。真的，写 0. 只是一种礼貌。如果你愿意的话，我可以把它称为 two of x。好的，但无论如何，很多时候人们会用这种符号来写它。对吗？这只是一种呈现方式。好的。
        </p><p>And the question is: Suppose I have now <em>x</em>, <em>y</em>, and
            <em>n</em>, and I want to say something about the relationship between
            the type 0 to <em>x</em> + <em>y</em> versus—I’ll just write versus—the
            type 0 to <em>y</em> + <em>x</em>. And what is the relation—what is the
            relationship between them? Okay. Because this is a type on this base,
            assuming I had pluses around and other things like I usually do, this is
            the type. Really, writing 0. is just a nicety. I could have called this
            up two of x, if you want. Okay, but anyway, a lot of times people will
            write it in this notation. Right? It’s just a way of presenting it.
            Okay.
        </p>
        <p>问题是：它们是同一种类型吗？它们是不同类型吗？或者它们之间有什么关系？这最终会变得非常烦人。好吧。这真的是一个大问题。</p><p>The question is: are these the same type? Are these different types?
            Or what’s the relationship between them? This ends up being incredibly
            annoying. Okay. It becomes a really major problem.</p>
        <h2 id="definitional-vs.-propositional-equality">定义平等与命题平等</h2><h2>Definitional
            vs.&nbsp;Propositional Equality</h2>
        <p>原因就是我们之前讨论过的：在我给出的设置中，x + y 在定义上并不等于 y + x。这不是定义上的相等。事实上，这是一个命题上的相等。也就是说，这必须通过归纳法来证明。所以，这不是真的。这是真的，但它需要归纳法。它需要证据，而证据将影响这两种类型之间的关系。</p><p>The reason is that we talked about before: x + y is not
            definitionally equal to y + x in the setup that I gave you. It’s not a
            definitional equality. It’s in fact a propositional equality. That is,
            this has to be proved by induction. So, this is not true. This is true,
            but it requires an induction. It needs evidence, and the evidence is
            going to influence what is the relationship between these two types.</p>
        <h2 id="intentional-vs.-extensional-type-theory">意向类型理论与外延类型理论</h2><h2>Intentional
            vs.&nbsp;Extensional Type Theory</h2>
        <p>所以，这是一个关键问题，区分所谓的意向性类型理论和外延性类型理论，我将对此进行解释。我想我下次再解释。所以，这会成为你的一个诱惑，因为我已经到了最后。</p><p>And so, that is a critical question, distinguishing what are called
            intentional versus extensional type theory, which I’m going to explain.
            I guess I will explain next time. So, this will serve as a tantalizer
            for you, since I’m at the end.</p>
        <p>所以，我想要说明的问题是：一旦你有了类型家族，那么你就会知道术语是通过替换原则进入类型，并且这些家族应该是有功能的。</p><p>So, the issue I want to get at is: once you have families of types,
            then you have the idea that terms make their way into types via the
            substitution principle, and that those families should be
            functional.</p>
        <h2 id="families-of-types-and-substitution">类型系列和替代</h2><h2>Families of Types and
            Substitution</h2>
        <p>也就是说，它们应该尊重定义上的平等。当然，问题是：它们是否应该尊重其他形式的平等，比如指称等价或指称等价？它们是相同的映射。所以，也许这两种类型应该相等，对吧？为什么不呢？也许它们应该在类型上相等。如果它们在类型上相等，那将非常非常方便，因为只要你有这种类型的元素，你也会有这种类型的元素。这一切都会变得非常容易和简单。但这比所有这些都更棘手。下次我会开始解释这一点。</p><p>That is, they should respect definitional equality. Certainly, the
            question is: should they respect other forms of equality, like a
            referential or a denotational equivalence? These are the same mapping.
            So, maybe these two types should be equal, right? Why not? Maybe they
            should be equal as types. And if they were equal as types, that would be
            pretty, pretty damn convenient, because anytime you had an element of
            this type, then you’d have an element of this type as well. And it would
            be all nice and easy and very simple. But it’s a little stickier than
            all that. And I’ll start to explain that next time.</p>
        <h2 id="handling-type-relationships">处理类型关系</h2><h2>Handling Type Relationships</h2>
        <p>所以，那将是明天的事了。我会开始谈论这个问题。所以，现在，我会把它留作一个谜题让你们思考。</p><p>So, that’ll be tomorrow. I’ll start talking about this. So, right
            now, I’ll leave it as a puzzle for you to think about.</p>
        <p>好的。如何处理这种情况，以及它将如何发生？我们要做的就是将功能性的概念推广到函数性的概念。这将让我们对这里要做的事情有所了解。好吧。这就是我现在想说的。那么，我们就到此为止吧。</p><p>Okay. How to handle this kind of a situation, and how it’s going to
            happen? What we’re going to do is we’re going to generalize the idea of
            functionality to the idea of functoriality. And that will give us some
            idea of what we’re going to do here. So, all right. So, that’s what I
            want to say right now. So, let’s stop there.</p>
        <h1 id="type-theory-foundations-3.0-robert-harper">类型理论基础 3.0 — Robert Harper</h1><h1>Type Theory
            Foundations 3.0 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 37:14 <a href="https://youtube.com/watch?v=gR52ZJSfTPk">https://youtube.com/watch?v=gR52ZJSfTPk</a></p><p> 11
            years ago (Jan 2, 2014) — 37:14 <a href="https://youtube.com/watch?v=gR52ZJSfTPk">https://youtube.com/watch?v=gR52ZJSfTPk</a></p>
        <h2 id="summary-6">概括</h2><h2>Summary</h2>
        <p>本视频讨论了依赖类型理论，重点介绍了类型索引的类型系列。类型系列将一种类型分配给另一种类型的每个元素。Robert Harper 解释说，相等的索引会产生相等的类型（功能）。示例包括给定长度的序列。讨论涉及上下文、上下文中的类型以及类型和上下文的定义相等性。视频还涉及类型理论与逻辑之间的关系，重点介绍了类型如何表示命题和证明。视频最后讨论了结构原理、替换和计算规则。</p><p>This video discusses dependent type theory, focusing on type-indexed
            families of types. A family of types assigns a type to each element of
            another type. Robert Harper explains that equal indices produce equal
            types (functionality). Examples include sequences of a given length. The
            discussion involves contexts, types within contexts, and definitional
            equality of types and contexts. The video also touches on the
            relationship between type theory and logic, highlighting how types can
            represent propositions and proofs. The video concludes with a discussion
            of structural principles, substitution, and computation rules.</p>
        <h2 id="central-notion-of-type-indexed-families">类型索引家族的中心概念</h2><h2>Central Notion of
            Type-Indexed Families</h2>
        <p>上次，我们讨论了类型家族的核心概念，即类型索引——让我这样写——类型索引类型家族的核心概念。这是依赖类型理论的核心思想。好的。</p><p>Last time, as we were looking at the central notion of the idea of a
            family, a type index—let me write it like this—the central notion of a
            type indexed family of types. This is a central idea of dependent type
            theory. Okay.</p>
        <p>我们可以用各种方式来写下它。例如，我们可以考虑类型系列，让我们这样写：b(x)，其中 x 的范围是其他类型 a。这是您可能会看到的一种典型符号，看起来像是集合系列的传统符号。所以，这将是一个集合索引的集合系列。或者，正如我们倾向于写的那样，我们会说，给定 x 和 a，我们会说 b — 有时我会强调那里有一个 x 或没有 x，这取决于具体情况 — 但这是一个类型系列。我们可以将其视为一种映射。我们可以将其视为分配给 a 中的每个 m 的东西，它将它转换为其替换实例，这是一种特定类型。好的。所以，这将是一个类型。因此，它将 a 的每个元素发送到一个类型。</p><p>And we could write this down in various ways. For example, we can
            think of the family of types, let’s write this: b(x), where x sort of
            ranges over some other type a. That’s a typical sort of notation you
            might see, that looks like conventional notation for a family of sets.
            So, this would be a set indexed family of sets. Or, as we’ll tend to
            write this, we’ll say, given x and a, we’ll say that b—sometimes I’ll
            emphasize that there’s an x there or not according to the situation—but
            it’s a family of types. And we can think of this as a kind of mapping.
            We can think of this as something that assigns to each m in a, it turns
            it into its substitution instance, which is a particular type. Okay. So,
            this is going to be a type. So, it sends every element of a to a
            type.</p>
        <p>此外，这种尊重平等或功能的反射原理——对不起——是说，如果我们有，让我们称之为 m 和 n，如果我们有相等的索引元素——至少是定义上相等的索引元素——那么这些应该诱导定义上相等的类型。</p><p>Moreover, this principle of reflection—excuse me—of respect for
            equality or functionality says, if we have, let’s call it m and n, if we
            have equal index elements—at least definitionally equal index
            elements—then those should induce definitionally equal types.</p>
        <h2 id="respect-for-equality-and-functionality">尊重平等和功能</h2><h2>Respect for Equality and
            Functionality</h2>
        <p>好的。所以，它们在类型上是相等的。这个概念，这个尊重平等的想法，被称为功能性，这是这方面的一个典型术语。它是指关系是功能性的，这意味着它将相等的参数发送给相等的结果。好的。</p><p>Okay. So, these would be equal as types. And this notion, this idea
            of respect for equality here, is called functionality, as a typical,
            typical, typical term for this. It’s the idea that the relationship is
            functional, meaning that it sends equal arguments to equal results.
            Okay.</p>
        <p>所以，或者换句话说：我们无法制定一个区分定义上等价的指标的类型系列。好的。这是另一种说法。所以，一个家族……所以，如果我……所以，如果我有，例如，一个类型系列……</p><p>So, and, or another way of saying it is: we cannot formulate a family
            of types that distinguishes between definitionally equivalent indices.
            Okay. That’s another way of saying it. So, a family… so, if I… so, if I
            had, for example, a family of types…</p>
        <h2 id="examples-of-families-of-types">类型系列示例</h2><h2>Examples of Families of
            Types</h2>
        <p>我们谈到了……我们上次谈到了……这个不太好用……我们讨论过看看它是否可行……这个……我们讨论的是类型家族，比如……哦，一个可能是长度为 n 的序列。所以，假设我们有自然数，那么我可能会讨论长度为 n 的序列——假设是自然数的序列，这是我能想到的最简洁的描述。所以，这可能是一个类型家族。</p><p>we talked to… we talked last time about… this is not working too
            well… we talked to see whether that works… this out of the way… we talk
            about a family of types like… oh, one thing might be the sequences of
            length n.&nbsp;So, let’s say if we have the natural numbers, then I might
            talk about the sequences of length n—the sequences, let’s say, of
            natural numbers, just to be as minimalistic about this as I can think
            of. So, this might be a family of types.</p>
        <p>因此，我们期望，例如……例如，基于我们之前的讨论，我们会说，长度为 2 加 2 的序列的类型可能与长度为 1 加 3 的序列的类型相同。好的。它们是一样的。特别是，它们对相同的术语进行分类。好的。因此，它们对相同的术语进行分类。好的。这是一个例子。这就是功能性的概念。尊重平等。因此，为了——我们在这里看到的是，为了开始这个讨论并谈论这些事情，我需要有各种各样的概念。</p><p>And so, we’re expecting, for example… so, for example, based on our
            preceding discussion, that we would say that the types, you know, a
            sequence of length two plus two would be the same type as a sequence of
            length one plus three, maybe. Okay. That would be the same. And, in
            particular, they classify the same terms. Okay. So, therefore, they
            classify the same terms. Okay. So, that’s an example. That’s the notion
            of functionality. There’s a respect for equality. So, in order to—so
            what we see here is, in order to even get this discussion going and to
            talk about these things, I needed to have a variety of notions.</p>
        <h2 id="notions-for-dependent-type-theory">依赖类型理论的概念</h2><h2>Notions for Dependent Type
            Theory</h2>
        <p>好吗？我需要的概念是：我有上下文的概念，我有上下文中的类型的概念。所以，这是为了归纳，我的意思是我们可以有迭代依赖关系。例如，我可以——我可以给出一个类型系列<em>b</em>，像这样。然后我可以谈论一个双重索引的类型系列。然后，为了强调，我可以在这里放一个<em>x</em>来表示这是依赖的。然后我可以有<em>c ，</em>其中<em>x</em>和
            <em>y</em>是一个类型，这将是一个双重索引的类型系列。因此，它由<em>a</em>的元素索引，然后由<em>b的元素索引</em><em>a</em>的元素。好的，这样它就以这种方式迭代，依此类推。
        </p><p>Okay? And the notions I needed are: I have the notion of a context, I
            have the notion of a type in a context. So, this is for the sake of the
            induction, by which I mean we can have iterated dependencies. So, for
            example, I could—I could have given a family of types, <em>b</em>, like
            this. I could then talk about a doubly indexed family of types. And
            then, just to be emphatic, I can put an <em>x</em> here to indicate that
            this is dependent. Then I can have <em>c</em> with <em>x</em> and
            <em>y</em> being a type, and that would be a doubly indexed family of
            types. So, it’s indexed by elements of <em>a</em> and then by elements
            of <em>b</em> for that element of <em>a</em>. Okay, so that it’s
            iterated in this manner and so forth.
        </p>
        <p>因此，为了便于归纳，我们一般会有一个上下文——好吧——这里有一堆变量，并且我们有依赖于这些变量的类型。所以，这就是类型家族的概念。然后，我们对特定类型的术语进行分类，如下所示。</p><p>So, for the sake of the induction, we have, in general, a context—all
            right—a bunch of variables here, and we have types that are dependent on
            those variables. So, this is the idea of a family of types. And then we
            have the classification of terms of a particular type, looking like
            this.</p>
        <h2 id="classification-of-terms-and-definitional-equality">术语分类和定义平等</h2><h2>Classification of
            Terms and Definitional Equality</h2>
        <p>然后，相应地，我们需要定义相等的概念。我们的出发点是类型元素的定义相等。</p><p>And then, correspondingly, we needed notions of definitional
            equality. And our starting point was definitional equality of elements
            of a type.</p>
        <p>因此，我通过以下说法激发了整个讨论：即使我们只有（当我们没有依赖类型时）命题类型，只有简单类型而没有任何依赖关系，讨论特定类型的证明之间的等价性仍然很有趣。但是，一旦我们允许依赖关系，这个概念就变得特别重要，原因正是我在这里提到的原则。因此，这引发了类型定义相等的概念。有时我会在这里写“类型”，有时不会。可以吗？然后，就其本身而言，它引发了上下文定义等价的概念。可以吗？</p><p>So, I motivated the whole discussion by saying, well, even when we
            have only—when we don’t have dependent types—when we have only
            propositional, only simple types without any dependency, it’s
            nevertheless interesting to talk about the equivalences between proofs
            of a particular type. But that this concept becomes particularly
            significant as soon as we allow dependency, for the very reason of the
            principles that I was mentioning here. So, that then induces notions of
            definitional equality of types. Sometimes I’ll write “type” here, and
            sometimes I won’t. Okay? And then that, in itself, point wise, it
            induces a notion of definitional equivalence of context. Okay?</p>
        <p>因此，我们有如下写法：</p><p>So, we have kind of the formations and the equivalences written like
            this.</p>
        <h2 id="economical-formulations-and-intuitive-clarity">经济的配方和直观的清晰度</h2><h2>Economical
            Formulations and Intuitive Clarity</h2>
        <p>现在，当人们研究类型理论的形式主义时，他们经常会玩一些巧妙的小把戏和小把戏来节省公式。所以，我宁愿不在这里这样做，因为这样做在数学上很方便，但在教学上却没有多大帮助。因为，例如，你可以认为成员资格是由相等的反身实例定义的。然后你就可以只定义相等。但这有点像是聪明过头了。</p><p>Now, for when people study formalisms for type theory, they’ll often
            play subtle little games and tricks with these things to economize on
            the formulation. So, I would rather not do that here, because it can be
            mathematically handy to do that, but it’s pedagogically not very
            helpful. Because, for example, you could think of membership as being
            defined by the reflexive instance of equality. And then you can kind of
            get away with only defining equality. But that’s a little like too
            clever by half, sort of thing.</p>
        <p>因此，我将坚持使用更直观清晰的表述，尽管我承认可以引入某些类型的经济，而且人们确实在文献中引入了它们，通常是出于元理论的原因。好的。所以，这是基本设置，你暂时应该记住的是类型家族的概念。</p><p>And so I’ll stick with a more intuitively clear formulation, even
            though I admit that certain kinds of economies can be introduced, and
            people do introduce them in the literature, usually for metatheoretical
            reasons. Okay. So, that’s the basic setup, and the kind of thing that
            you should keep in mind for the time being is the notion of a family of
            types.</p>
        <h2 id="families-of-types-as-relations-and-predicates">作为关系和谓词的类型系列</h2><h2>Families of Types
            as Relations and Predicates</h2>
        <p>例如，给定的、指定长度的数字序列，或其他类似的东西，或者各种像谓词或关系一样出现的东西。因此，例如，写下 m、n 和自然数，我们可以对 m 和 n 相等有一些了解，稍后我将更详细地介绍这一点。那将是一种类型。可以这样理解，它是证明 m 和 n 相等的类型。</p><p>For example, the sequences of numbers of a given, specified length,
            or other such, or various things like relation things that come up as
            predicates or relations. So, for example, writing m, n, and the natural
            numbers, we could have some idea of equality of m and n, which I will
            come back to in more detail later. That would be a type. The way to
            think of that is it’s the type of proofs that m and n are equal.</p>
        <p>现在，就自然数而言，因为我们倾向于将自然数视为一个集合，也就是说，元素是离散的；它们只是一些点，是这个空间中的孤立点，如果你愿意这样想的话。因此，这里考虑的类型基本上要么是空的，要么包含一个元素。也就是说，它们相等这一事实是自反性的一个例子。</p><p>Now, in the case of the natural numbers, because we tend to think of
            the natural numbers—and the terminology I will use—we tend to think of
            them as a set, meaning that the elements are discrete; they’re just sort
            of points, isolated points in this space, if you like to think of it
            that way. And so, what’s going to happen is the types that are being
            considered here are basically either empty or contain one element. That
            is, the fact that they’re equal is an instance of reflexivity.</p>
        <p>如果它们不同，那么它们就是不同的，并且不存在这种类型的元素。但是，重要的是要考虑它们是相等的证明类型，即使在证明可能不平凡的情况下，或者在这种情况下可能是平凡的。它们可能相当平凡，但即便如此，我们还是想把它看作是其证明的类型。并且可能还有其他东西；可能有其他关系的证明，小于或等于，等等。</p><p>And if they’re different, then they’re different, and there’s no
            element of that type. But it’s nevertheless important to think in terms
            of it’s the type of proofs that they’re equal, even in cases where the
            proofs may be maybe non trivial, or maybe trivial in this case. They may
            be quite trivial, but even so, we want to think of that as the type of
            its proofs. And there could be other things; there could be proofs of
            other relationships, less than or equal to, and so on.</p>
        <p>所以，一般来说，你知道，这种东西代表一种——你可以同时把它看作一种关系、一种谓词或一种类型系列，或者像我之前提到的那样，一种振动——这种其他类型的结构，你可以把它看作某种大的不相交联合。你把所有的——对于 A 中的每个 x，你把所有的小 b 子 a 联合起来，然后你看看某个特定 a 上的东西。</p><p>So, in general, you know, this sort of thing represents a kind of—you
            can think of it simultaneously as a relation or as a predicate or as a
            family of types, or as I mentioned before, as a vibration—as this kind
            of other sort of structure where you think of this as being some kind of
            big disjoint union. You take all of the—for each x in A, you sort of
            union up all the little b sub a’s, and then you look at the things that
            are over a particular a.</p>
        <h2 id="fibered-viewpoint-and-functional-mappings">纤维视点和功能映射</h2><h2>Fibered Viewpoint and
            Functional Mappings</h2>
        <p>因此，如果您看一下——如果您只是使用一些集合论符号——如果您形成某种大的不相交联合。抱歉，笔。a 在 A 中除以 b 子 a，对吗？所以，有一个大的联合。我们称之为 B，对吗？我们会定义它。然后有一个自然投影 P，它会向下到 A。它的作用是，对于这个大不相交联合中的每个元素，它会告诉您它位于哪个 a 上。好的，投影结束了。它是哪一个？所以，如果我给你一个大的，大块的元素，对吧，这个大的，所谓的总空间……抱歉，有人可以帮我拿笔吗？这不太好。好的。</p><p>So, if you look at—if you just use some set theoretic notation—if you
            form like some sort of big disjoint union. Sorry about the pen. Where a
            is in A over b sub a, right? So, there’s this big fat union. We’ll call
            that B, right? And we’ll define that. Then there’s a natural projection
            P which goes down onto A. And what it does is for each element in this
            big disjoint union, it tells you which a does it sit over. Okay, the
            projection is over. Which is it? So, if I give you an element of the
            big, the big clump, right, this big, so called total space… Sorry, can
            someone help me with the pen here? This is not working out very well.
            Okay.</p>
        <p>因此，如果你取所谓的总空间，那么这里的投影就会告诉我们我们位于哪个元素之上，因为你可以将这个不相交联合的这些元素视为 a 和 b，其中 b 在 b 子 a 中。</p><p>So, if you take the, what is called, the total space, then this
            projection here is telling us over which element we sit, because you can
            think of these elements of this disjoint union as being like a and b,
            where b is in b sub a.</p>
        <p>然后，正如我上次提到的那样，如果您查看逆图像，如果您取任何特定的 a 并查看它被发送到哪里，这个投影的原像，a 的原像，可以被认为是所谓的纤维，好的，在整个空间中。</p><p>And then, as I mentioned last time, if you look at the inverse image,
            if you take any particular a and you look at where it is sent under the,
            the pre image of the, this projection, the pre image of a, that can be
            thought of as a, what is called, a fiber, okay, in the total space.</p>
        <p>所以，这些是垂直排列在这里的所有元素。我们像这样垂直写它们，它们是通过 p 向下投影到 a 上的元素，投影到给定的 a 上。对于每个 a 的选择，都有另一个纤维。所以，有一个素数上的纤维，还有一个双素数上的纤维。这是我们上次给出的描述。</p><p>So, these are all the elements lined up here vertically. We write
            them vertically like this, which are the ones that project down by p
            onto a, onto a given a. And for each choice of a, there’s another fiber.
            So, there’s a fiber over a prime, and there’s the fiber over a double
            prime. And that was the description we gave last time.</p>
        <p>因此，这是两种不同的观察方式。因此，这是一种纤维化的观点，好吧。这是一种功能性的观点，可以将其视为一种家族，一种功能，一种将类型的元素发送到类型类的映射。您可以将类型家族视为一种特殊的映射，p，称为振动。我现在不会指出振动的确切定义，但您可以将其视为这种风格的投影。这是一个很好的经验法则，就像如何思考它一样。然后，通过这种方式，特定事物的元素由这里的预图像给出，好吧。</p><p>So, these are kind of two different ways of looking, looking at. So,
            this is the sort of, sort of fibered viewpoint, okay. And this is a kind
            of functional viewpoint to think of it as a kind of family, as a kind of
            function, a mapping that sends elements of a type to the class of types.
            And this, you can think of a family of types instead is a special sort
            of mapping, p, which is called the vibration. I won’t right now indicate
            what the exact definition of a vibration is, but you can think of it as
            this kind of a projection of this style. It’s a good rule of thumb, like
            how to think about it. And then that way, the elements of the particular
            thing are given by the, are given by the pre images here, okay.</p>
        <p>所以，这就是我们正在使用的框架。然后我们处理这些东西的方式就是将其关闭。我的意思是，我们对类型系列感兴趣的原因是，还记得我们一开始所做的事情吗？</p><p>So, that’s the, that’s the like the framework that we’re working in.
            And then what we do with this stuff is we close it up. I mean, the
            reason we’re interested in families of types is, remember the things we
            sort of start with, right?</p>
        <h2 id="type-theory-and-logic-motivations-and-connections">类型理论和逻辑：动机和联系</h2><h2>Type Theory
            and Logic: Motivations and Connections</h2>
        <p>那么，我们从哪里开始呢？</p><p>So, what did we start with?</p>
        <p>所以，我们一开始使用的类型都是由逻辑驱动的。所以我们有一、零、与或、或、交叉、加法，无论你怎么看，蕴涵、函数空间，好吧。</p><p>So, the types we started with were motivated by logic. So, we had
            one, zero, and or, or, you know, cross, crossing, plus, however you look
            at it, implication, function space, okay.</p>
        <p>所以，如果我想让我的符号合理一致，我们可以这样写，好吧。所以，我们从这些东西开始，好吧。然后我们观察到我们可以添加其他类型。有些东西不是由逻辑驱动的，所以它们会沿着这条线走。所以，也许自然数会是一，等等。然后也许其他类型可以放在这里，就目前而言，自然数。稍后我将添加一些不对应的其他东西；它们缺乏逻辑对应性。它们只是类型，这就是为什么人们认为整个主题实际上是类型理论的原因。</p><p>So, if I want to make my notation be reasonably consistent, we can
            write it like this, okay. So, we started out with those things, okay.
            Then we observe that we could add additional types. There are things
            that are not motivated by logic, so they would sort of go on this line.
            So, maybe the natural numbers would be one, and and so on. And then
            perhaps other types might go in here, for the natural numbers, for now.
            I’ll add some other things in a moment that don’t correspond; they lack
            a logical correspondence. They’re merely types, and this is the reason
            why people kind of think of the whole subject as being really type
            theory.</p>
        <p>逻辑只是类型理论的一种使用模式。这是 Brouwer 的格言，即逻辑是数学的一个分支；他是这样说的，而不是反过来。好的，这就是这个想法。所以我们从这个基本概念开始。所以现在我们要做的是开始用其他有趣的类型填充它。</p><p>And logic is just a mode of use of type theory. Which is Brouwer’s
            dictum that, that about a logic being a branch of mathematics; that’s
            the way he would say it, rather than the other way around. Okay, so, so
            that’s the idea. And so we started with that basic notion. So now what
            we want to do is start populating it with other interesting types.</p>
        <h2 id="populating-type-theory-with-base-types">使用基类型填充类型理论</h2><h2>Populating Type Theory
            with Base Types</h2>
        <p>我要做的第一件事是——好吧，我们研究了一些小东西，比如序列。它将有各种长度为<em>n</em>的序列，从这个符号可以理解，我必须以某种方式表明它的范围是<em>n</em>。然后我可能会有其他东西，比如等式。我们讨论的是自然数上的等式。所以这些是类型的形式。好的，这些可以放在这里，它们可以被认为是一种基类型，对吧？</p><p>And the first ones I’m going to do are going to—well, we looked at
            little things like sequences. That will have various, like, sequences of
            length <em>n</em>, where it’s understood from this notation somehow I
            have to indicate that this is ranging over <em>n</em>. And then I could
            have other things like equalities. We were talking about equalities over
            the natural numbers. So these are forms of types. Okay, that can go in
            along here, and those can be thought of as, as, as kind of base types,
            right?</p>
        <p>它们可以被认为是；它们没有任何进一步的结构。它们只是我构建的类型，就像方程证明的类型、有限序列的类型。好的。也许这真的可以用其他方式来表示。我将在一分钟内展示如何做到这一点，但目前，我们将其视为一个原始概念。我们可以将其视为一个原始概念。然后我们想要做的是有一些闭包条件。</p><p>They can be thought of as; they don’t have any further structure.
            They’re just types that I’m building in, like the type of proofs of
            equations, the type of finite sequences. Okay. Maybe this could really
            be represented in some other way. I’ll show how to do that in a minute,
            but for the moment, we’ll take that as a primitive notion. We can think
            of it as a primitive notion. And then what we want to do is have some
            closure conditions.</p>
        <p>换句话说，我们从事家庭事业的全部原因就是为了能够与他们一起做点什么。我们想要做的主要事情就是所谓的形成总和。</p><p>In other words, the whole reason for getting into this business about
            having families is to, is to be able to do something with them. And the
            main thing that we want to do are what are called forming the general
            product and sum.</p>
        <h2 id="dependent-product-and-sum-types">依赖乘积和和类型</h2><h2>Dependent Product and Sum
            Types</h2>
        <p>因此，我们这里有各种符号，但 π <em>x</em>和
            <em>a </em> <em>b</em>，我将写为 σ <em>x</em>和<em>a </em>
            <em>b</em>。因此，它们有时被称为 π 类型、σ 类型。它们被称为乘积类型、和类型。它们有时被称为依赖函数类型。这有时被称为依赖乘积类型，这非常令人困惑，因为在某些情况下可以将其称为乘积，但在其他情况下可以将其称为乘积，这就变得很混乱。好的，所以再次重申，术语传统彼此冲突。好的。
        </p><p>So what we have here—there are various notations—but π <em>x</em> and
            <em>a</em> <em>b</em>, and I’ll write σ <em>x</em> and <em>a</em>
            <em>b</em>. So they’re sometimes called π types, σ types. They’re called
            product types, sum types. They’re called—this is sometimes called a
            dependent function type. This is sometimes called a dependent product
            type, which is very confusing because that in certain situations can be
            called a product, but in other situations that can be called a product,
            and that gets messy. Okay, so it’s again, there are terminological
            traditions that collided with one another. Okay.
        </p>
        <p>现在，这方面的特殊情况包括——我们回到逻辑方面——某种类型的全称量化，我会在这里写
            <em>p</em>或其他东西。
        </p><p>Now, special cases of this include—we go back to the logic side
            here—universal quantification over a type, and I’ll write here
            <em>p</em> or something.
        </p>
        <h2 id="quantifiers-and-logical-correspondences">量词和逻辑对应关系</h2><h2>Quantifiers and Logical
            Correspondences</h2>
        <p>我只写<em>b</em>。好的。这里的想法是对类型的存在量化，但我们必须小心一点。好的。这些是逻辑对应关系。这些是正确的，但要小心一点。在一阶算术中，通常的定义更加严格；不要考虑任何类型的情况。例如，我们考虑算术。我们只考虑自然数的量化。我们确定有一个量词专门用于此目的：自然数的量化。</p><p>I’ll just write <em>b</em>. Okay. And the idea here of existential
            quantification over a type, but we have to be a little bit careful.
            Okay. These are these are the kind of logical correspondences. Those are
            correct, but be a little careful. In first order arithmetic, the usual
            definition is more restrictive; don’t consider it over any type. We
            consider it, for example, an arithmetic. We consider only quantification
            over the natural numbers. And we fix that there’s a quantifier that is
            dedicated to that purpose: quantification over the natural numbers.</p>
        <p>但更一般地，我们可以将其概括并考虑其他类型的量化。特别是，当我们开始承认函数类型时，它开始迅速超出一阶逻辑或传统一阶逻辑的范围。因为那时我们可以谈论函数的量化。我们可以谈论，对于从<em>ℕ</em>到<em>ℕ的每个</em><em>f</em>，都存在一个从<em>ℕ</em>到<em>ℕ</em><em>的 f</em>。这超出了通常在一阶逻辑中考虑的范围。<em></em><em></em><em></em><em></em><em></em></p><p>But more generally, than one can generalize that and consider
            quantification over other types. And, in particular, it starts to
            quickly get outside the realm of first order logic, or conventional
            first order logic, when we start admitting, for example, function types.
            Because then we can talk about quantification over functions. And we can
            talk about, for every <em>f</em> from <em>ℕ</em> to <em>ℕ</em>, and
            exists an <em>f</em> from <em>ℕ</em> to <em>ℕ</em>. Which is outside the
            realm of what you usually consider in, like, first order logic.</p>
        <p>好的。所以，它们就像一阶量词，但它们并不完全一样——它们有点更通用。但这是一种类比。我将通过告诉您执行 sigma 和 pi 的规则来解释为什么这是一个很好的类比。这里还会讨论另一个关于存在量化行为的问题。众所周知，这是有问题的。因此，这些类型的问题，这些类型的对应关系，必须谨慎对待，因为有许多复杂的问题需要讨论。好的。</p><p>Okay. So, they are like the first order quantifiers, but they’re not
            exactly—they’re a bit more generalized. But that is the kind of analogy.
            And I’ll explain why that’s a good analogy by telling you what the rules
            are for performing the sigma and the pi. There’s going to be another
            issue about the behavior of existential quantification that will come up
            here as well. That is known to be problematic. So, these kinds of
            issues, these kinds of correspondences, have to be taken somewhat with a
            grain of salt, because there are many complicating issues to be
            discussed. Okay.</p>
        <p>所以，我在这里要做的是开始填充我们的类型理论。</p><p>So, what I want to then do here is to start populating our type
            theory.</p>
        <h2 id="structural-principles-and-variable-behavior">结构原理与变量行为</h2><h2>Structural
            Principles and Variable Behavior</h2>
        <p>现在，请更认真地考虑一下，并制定出形成这些所谓的依赖类型的原则。现在，我要提醒自己，我们有一堆免费提供的结构原则。我不会把它们全部写下来。我给了你参考文献，你可以在其中查找类型理论和内容的正式定义，因为如果我写出几十条规则和内容，那将非常乏味，每个人都会去睡觉。</p><p>Now, be more serious about it and formulate what are the principles
            of forming these so called dependent types. Now, I’ll remind ourselves
            that we have a bunch of structural principles that sort of come along
            for free. I won’t write down all of them. I’ve given you references to
            the literature where you can look up the formal definitions of the type
            theories and stuff, because it would be awfully dreary for me to write
            out several dozen rules and stuff, and everyone would go to sleep.</p>
        <p>所以，我只想指出一些重要的事情。例如，你总是可以使用其类型的变量。好的。这就是结构原则的一个例子：变量的使用和行为。好的。替代原则。好吧，有或多或少通用的方式来表达这一点，但其中一种版本是这样的。它说：如果<em>x</em> :
             <em>Δ</em>给我们——好吧，现在的问题是右边会发生什么。
        </p><p>So, I’m just going to point out the, you know, main things that are
            important. So, for example, you can always, you know, you can always use
            a variable at its type. Okay. So, that’s that’s an example of a
            structural principle: the use and behavior of variables. Okay. The
            principle of substitution. Well, there are more or less general ways to
            say this, but one version of it is this. It says: if <em>x</em> :
            <em>Δ</em> gives us—well, now the question is what goes on the
            right.
        </p>
        <p>所以，我在这里作弊，写一个判断<em>j</em>，你马上就会看到我要做什么。它说：如果我有一个类型为<em>a 的</em><em>m</em>，那么在实例中——记住它们可以是顺序依赖的——所以我可以将它们代入<em>Δ</em>，然后我可以将 *m**x* 代入<em>j</em>。我在这里稍微作弊了，因为 'j' 代表这些判断中的任何一个，可以是类型判断或类型形成判断。所以，我在这里使用黑板经济学来简明扼要地解释这些事情，但实际上，我的意思是，这里有一堆规则，每个选择一条规则对应一个判断
            <em>j</em>。
        <em></em><em></em><em></em><em></em></p><p>So, I’ll cheat here and I’ll write a judgment <em>j</em>, and I’ll
            you’ll see what I’m going to do here in a minute. And it says: if I have
            an <em>m</em> which is of type <em>a</em>, then in the instance—remember
            these can be sequentially dependent—so I can plug those into <em>Δ</em>,
            and then I can plug that *m**x* in for <em>j</em>. I’m slightly cheating
            here because ‘j’ stands for any of these judgments, which could be a
            typing judgment or a type formation judgment. So, I’m using a blackboard
            economy here to, you know, explain these things concisely, but really, I
            mean, a bunch of rules here, one for each choice of those judgment
            <em>j</em>.
        </p>
        <p>但这是替换原则。所以，这些是关于变量的基本思想，对吧？变量是类型的未知元素，你可以通过替换、代入来赋予变量意义。这就是变量的本质和用途。这就是我们的做法。功能性原则规定，每个判断在这三个自由变量中都是功能性的。所以，在这里我必须把它写出来。</p><p>But this is the principle of substitution. So, these are the
            fundamental ideas about variables, right? That a variable is an unknown
            element of a type, and you can give meaning to variables by
            substitution, by plugging in for them. That’s what variables are and
            what they’re for. This is how we do it. The principles of functionality
            say every judgment is going to be functional in those three, in its free
            variables. So, here I have to actually write this out.</p>
        <p>除了直接写出，没有其他简单的方法可以写出来。所以，我们写一下，假设这里是<em>n</em> : <em>b</em>。如果我们有相等的元素——哦，我不应该叫它<em>m</em>，好吧，我就叫它们<em>m</em>和<em>m'</em>好了，就这样。然后我们会想知道——好吧，我们会想知道很多事情。让我们看一个具体的实例。让我们只看最后一个变量。技术细节就是技术细节。我想在这里得到的是，<em>x </em><em>n</em>的<em>m</em>应该等于
            <em>x </em><em>n</em>的<em>m'</em>。
        <em></em> <em></em><em></em><em></em> <em></em></p><p>There’s no easy way to write this out other than directly. So, let’s
            write, let’s say <em>n</em>: <em>b</em> here. And if we have equal
            elements—oh, I shouldn’t have called it <em>m</em> and well, let me just
            call them <em>m</em> and <em>m’</em> okay, like that. Then we’re going
            to want to know—well, there are various things we’re going to want to
            know. Let’s look at a specific instance. Let’s just look at the last
            variable. The technicalities are technicalities. The thing I want to get
            in here is that <em>m</em> for <em>x</em> <em>n</em> should be equal to
            <em>m’</em> for <em>x</em> <em>n</em>.
        </p>
        <p><em>在m</em> for <em>x </em> <em>b</em>中，请原谅我挤压了它。要点是，根据类似的规则（我不会写下来），相等的实例将提供相等的类型。因此，我在这里选择
            <em>m</em> for <em>x </em> <em>b</em>并不重要，因为它在定义上等于<em>m'</em> for <em>x </em>
            <em>b</em>。正如我们之前所说的那样，其他结构规则开始发挥作用。有弱化的规则，好吧，我不会在这里写出来。
        </p><p>In <em>m</em> for <em>x</em> <em>b</em>, excuse me for squeezing that
            goes there. And the point being, by a similar rule, which I won’t write
            down, equal instances will give us equal type. So, the fact that I chose
            <em>m</em> for <em>x</em> <em>b</em> here is immaterial because that’s
            going to be definitionally equal to <em>m’</em> for <em>x</em>
            <em>b</em>. And the way in which we spoke before, other structural rules
            come into play. There are rules for weakening, okay, which I won’t write
            out here.
        </p>
        <p>我们上次讨论过。收缩、交换是替代，这实际上需要作为规则纳入其中。好吧，我假设我已经为所有人定义了它。我并没有真正给你这个定义。所以，这就是我没有做的，好吗？我没有做的是致力于某种特定的形式主义。我试图给你正在发生的语义原则。然后，由于对元理论的各种考虑，人们以不同的方式表述了它。</p><p>We talked about it last time. Contraction, exchange, is substitution,
            something that actually needs to be included as a rule. Well, I’m
            assuming I’ve defined it for all. I haven’t really given that definition
            to you. It’s so, this is what I am not doing, okay? What I’m not doing
            is committing to some specific formalism. I’m trying to give you the
            semantic principles that are going on. And then, for because of various
            considerations of meta theory, people formulated it in different
            ways.</p>
        <p>这就是我之前所说的。有许多不同的表述，没有一种是正确的、规范的、最好的或别的什么。它们只是不同的做法。所以，我为了教学的目的试图给你提供想法，我不会承诺说这是规则，那不是规则，这是可以接受的，那是不可接受的。我不会担心这些，因为我不会做任何元理论。如果我在做元理论，我会格外小心。我试图做到一丝不苟，但我承认我有点松散。我很松散，但我忠于事实。你可以查看我为故事的各种形式提供的参考资料。好的。</p><p>That’s what I was saying before. There are many different
            formulations, none of which is right or canonical or best or anything.
            They’re just different ways of doing it. So, what I’m trying to do for
            the purpose of teaching is to give you the ideas, and I’m not committing
            to like, this is a rule and that’s not a rule, and this is admissible
            and that’s not admissible. I’m not going to worry about that because I’m
            not going to be doing any meta theory. If I were doing metatheory, I
            would be extra careful. I’m trying to be meticulous, but I admit I’m
            being a little loose. I’m being loose, but I’m being faithful to the
            truth. You can check the references I’ve provided for the various forms
            of the story. Okay.</p>
        <p>因此，我们会经历弱化、收缩和交换。我不会费心把它们写下来作为规则，但这些原则无论如何都应该是有效的——要么是可接受的规则，要么你明确地把它们写进去。我们不要讨论你为什么要这样做，但假设我们要这样做。</p><p>So, we’ll have weakening, we’ll have contraction, we’ll have
            exchange. I won’t bother to write them down as rules, but those should
            be valid principles in one way or another—either they’re admissible
            rules or you put them in explicitly. And let’s not discuss why you do
            one or the other, but let’s say we’re going to do this.</p>
        <p>然后，我上次提到，除了其他许多事情之外，还有对等价性的尊重，即定义上相等的类型对相同的术语进行分类，等等——比如相等的东西，这种类型在那种类型上是相等的，等等。所以，我在这里只写等等，因为我不想——把每件事都写下来实在是太无聊了。好的。</p><p>And then, I mentioned last time, amongst many other things, there’s
            the respect for equivalence as well, which says definitionally equal
            types classify the same terms, and etc.—like equal things, that this
            type will be equal at that type, and so forth. So, I’ll just write etc.
            here because I don’t want to—it’s really too boring to write down every
            single thing. Okay.</p>
        <p>这就是火焰，但我想说的是，这些是结构原则，对吧？这就是理论发挥作用的原因。这是通用的东西，主要是关于行为变量和定义平等的概念。</p><p>So, that’s the flame, but the point I want to say here is that these
            are the structural principles, right? This is what makes the theory
            work. This is the generic stuff, and mostly it’s about the behavior
            variables and the notion of definitional equality.</p>
        <p>因此，具体来说，每当您有一个开放术语时（每当您有某种形式，例如，如果这是一个类型判断或类型），每当您在这里有一些具有一些自由变量的开放判断时，经验法则是它是一个在这三个变量中起作用的映射。好的。这就是想法。</p><p>So, in particular, whenever you have an open term—whenever you have
            some form of, like, if this is a typing judgment or or it’s a
            type—whenever you have some open judgment here that has some free
            variables, the rule of thumb is it’s a mapping that is functional in
            those three variables. Okay. That is the idea.</p>
        <p>我担心笔的问题。我真的不喜欢白板，但非常讨厌内部技术。没有粉笔就无法好好教学。谢谢，但没关系。</p><p>I’m worried about the pen. I really dislike whiteboards, but very
            interior technology. You can’t teach properly without chalk. Thanks, but
            all right.</p>
        <p>所以，这些是结构原则，它们主要与行为变量有关。这基本上就是正在发生的事情。所以我们有这些。它们就像是继承的。这些是我们工作的环境，因为它们为我们定义了家庭的含义。</p><p>So, so these are the structural principles, and they are primarily
            about the behavior variables. That’s essentially what is going on. And
            so, so we have those. Those are like inherited. Those are for—those are
            the contexts in which we’re working, because they define for us what we
            mean by family.</p>
        <h2 id="type-as-range-of-significance">类型作为重要性范围</h2><h2>Type as Range of
            Significance</h2>
        <p>好的。这是函数依赖性的想法。</p><p>Okay. This idea of functional dependency.</p>
        <p>现在，我想说的另一件事是，还有另一种看待这个问题的方式。这是同一件事，但你也可以这样看待它，这就是类型概念的起源，可以追溯到罗素和怀特海的著作。类型是变量的意义范围吗？这是另一种看待它的方式。好的。</p><p>Now, the other thing I would like to say is that there’s another way
            of looking at this. It’s the same thing, but you could also look at it
            this way, which is the origin of the notion of type, which goes back to
            Russell and Whitehead’s work. Is that a type is the range of
            significance of a variable? That’s another way of looking at it.
            Okay.</p>
        <p>每当你有变量时，你必须隐式或显式地指定它的范围是什么？它的范围称为类型。这就是类型的概念。好的。</p><p>Whenever you have a variable, you must implicitly or explicitly
            specify what does it range over? And the thing that it ranges over is
            called a type. That’s the notion of a type. Okay.</p>
        <p>所以，在学校里，所有变量的范围都是实数。好吧。没有人——我的意思是，这是明确指定的，但你并没有真正写下来，因为一切都默认在实数范围内。所以，我们要指定变量的显着范围。这是一条一般的经验法则。只要你有变量，你就必须有类型，因为它们是一起的。这是该变量的显着范围，你必须指定其显着范围。</p><p>So, in school, way back when, all of the variables ranged over the
            real numbers. Okay. And nobody ever—I mean, that was clearly specified,
            but you don’t really write it down because everything is tacitly ranging
            over the real numbers. So, we’re going to specify the range of
            significance of a variable. There’s a general rule of thumb. Whenever
            you have variables, you have to have types because they go together. It
            is the range of significance of that variable, and you must specify its
            range of significance.</p>
        <p>所以，这就是为什么所有这些事情都以它们的方式结合在一起。好的，很好。所以，这就是总体框架。现在，我想要做的是开始稍微实例化它。</p><p>So, that’s why all these things kind of fit together in the way that
            they do. Okay, good. So, that’s the general framework. And now, what I
            would like to do is start instantiating this a little bit.</p>
        <h2 id="type-theory-and-quantifiers">类型理论和量词</h2><h2>Type Theory and Quantifiers</h2>
        <p>好的。我可以说几件事。好的。那么，让我们看看量词的行为。我将深入研究并将它们作为类型构造函数，然后我会即时将其与逻辑进行类比。事实上，我可以继续我之前给你的整个讨论，但同时进行会变得复杂。所以，现在我要像类型理论一样。好的。然后我会将类型与逻辑进行类比。</p><p>Okay. So, I can say a few things. All right. So, let’s look at the
            behavior of the quantifiers. And I’m just going to dive in and do them
            as type constructors, and then I’ll draw the analogies to logic on the
            fly. I could, in fact, continue this whole discussion I was giving you
            before, but carrying it out in parallel starts to get complicated. So,
            now I’m going to just do like type theory. Okay. And then I’ll make the
            analogies to types as to logic.</p>
        <p>史蒂夫，我想我们来谈谈与范畴论的联系。当你开始更多地使用量化时，与范畴的联系就开始变得复杂起来，而我很难在工作中做到这一点。所以，让史蒂夫来做这件事会很好。好的。让我们看看产品的例子。所以，从某种程度上来说，这就是所有行动所在。所以，我们要——我承认我从中间开始。</p><p>And Steve, I think we’ll talk about the connections with category
            theory. The connections to categories are at this point when you have
            quantification start to become more involved, and it’s a little hard for
            me to do that just on the fly. So, it’ll be nice to set Steve up for
            doing that. Okay. So, let’s look at, for example, the product. So, this
            is the, in some way, where all the action is. So, we’re going to—I am
            admittedly starting in the middle.</p>
        <p>我会在适当的时候把所有东西拼凑起来，但我认为最好这样做。所以，我要说的是，在什么条件下这是一种类型？好吧，在什么条件下，它是一种类型？嗯<em>，实际上，在什么条件下，它是一种由</em><em>γ</em>索引的类型系列。好的。因为在归纳法中，那是——我们总是考虑，我们只考虑系列。如果这个恰好是空的，好的，那没关系。</p><p>I will piece everything together in due course, but I think it’s best
            to do it like this. So, what I’m going to do is I’m going to say under
            what conditions is that a type? Well, the conditions under which it’s a
            type are that <em>a</em> is a type. Well, really, under which it’s a
            family of types indexed by <em>γ</em>. Okay. Because in the induction,
            that’s—we always consider, we only ever consider families. If this
            happens to be empty, okay, that’s fine.</p>
        <p>那么它就是一个封闭类型。是的。这没什么——我在这里什么也做不了。好的。我的意思是，我现在正在尽力。好的。好的。所以，一切都应被视为由
            <em>γ</em>索引的类型系列。我们会继续这样做。因此，<em>a</em>将是一种类型，嗯，相对于<em>γ</em>。所以，当然，会有一个类型系列，然后还有一个额外的变化级别，我们说
            <em>b必须是由</em><em>a</em>索引的类型系列。
        </p><p>Then it’s a closed type. Yeah. It’s—there’s nothing—there’s nothing I
            can do here. Okay. I mean, I’m doing my best for now. Okay. All right.
            So, everything is to be thought of as a family of types indexed by
            <em>γ</em>. We’ll carry that along. So, <em>a</em> will be a type, well,
            relative to <em>γ</em>. So, of course, there’s going to be a family of
            types, and then there’s an additional level of variation where we say
            <em>b</em> has to be a family of types indexed by <em>a</em>.
        </p>
        <p>所以，它会像这样写。好的。所以，如果你
            暂时固定<em>γ ，就像你可以把它想象成柯里化——以你喜欢的方式实例化</em><em>γ</em>，修复该实例。然后那就是——橙色，是的。好的。好的。好的。我会把它放在我的后口袋里。好的。好的。所以你修复了 γ，你就没问题了。然后我得到的是，对于固定的 γ，一个类型和一个由 A 的元素索引的类型系列。这就是——这被称为大笛卡尔积。所以这在很多时候被称为 pi 形成规则，写成这样。</p><p>So, it’ll be written like that. Okay. So, if you hold the <em>γ</em>
            fixed for a moment, like you could think of it as like a
            currying—instantiate <em>γ</em> however you like, fix that instance.
            Then that’s—orange, yeah. Okay. All right. All right. I’ll put that in
            my back pocket. Okay. All right. So you fix γ, and you’re okay. Then
            what I have is, for the fixed γ, a type and a family of types indexed by
            the elements of A. So that’s—and this is called the big Cartesian
            product. So this is called the pi formation rule a lot of times, written
            like that.</p>
        <p>因此，如果你用类比法来看这个问题，如果你现在从逻辑的角度来思考这个问题，我会在这里用铅笔写下——也许这就是橙色的用处——我会在这里用铅笔写下的是，这是一个命题，这是一个命题。但是如果你把它看作逻辑，它仍然是一种类型。换句话说，在传统的逻辑中——这也是最好做类型理论而不是试图把所有东西都与逻辑联系起来的原因——因为在某些方面，逻辑已经退化了，而从类型理论的角度来看，逻辑已经退化了。其中一个维度是逻辑，你通常不会，在你所查阅的传统教科书逻辑中，人们从不考虑命题的量化，因为证明不是数学对象。这完全行不通。</p><p>So, if you look at this by analogy, if you think of this now from the
            point of view of logic, what I would kind of pencil in here—maybe that’s
            what orange is good for—what I would pencil in here is this would be a
            proposition, and this would be a proposition. But if you’re thinking of
            it as logic, that would remain being a type. In other words, in
            conventionally in logic—and this is partly where it’s better to do type
            theory than it is to try to relate everything to logic—because in
            certain, certain, in certain dimensions, logic has remained degenerate
            in ways that it’s not when it’s presented from the point of view of type
            theory. And one of those dimensions is in logic, you don’t normally, in,
            you know, conventional textbook logic that you look up, one never
            considers quantification over propositions because proofs are not
            mathematical objects. That’s completely out of the game.</p>
        <p>因此，您有类型的概念，即量化的领域。好吗？然后，您可以针对特定类型形成命题或谓词。在某些非常退化的逻辑形式中，永远只有一种类型。好吗？也许它是一种自然数类型。可能只有一种类型。但可能会有很多种。如果有，那么出于某种原因，它被称为多重排序。好吗？然后，您有按该类型索引的命题概念。但在类型理论的背景下，我们只是说：“哦，命题，类型。”您知道，这只是您的观点问题。好吗？命题和类型之间没有真正的区别；它们是同一件事。</p><p>So, you have a notion of type, which is your domains of
            quantification. Okay? And then you can form propositions or predicates
            over a particular type. And in certain really degenerate forms of logic,
            there’s only one type ever. Okay? Maybe it’s a type of natural numbers.
            Possibly, there’s only one type. But there could be many. If you have
            then it’s called multi sorted, for some reason. Okay? And then you have
            a notion of a proposition indexed by that type. But in the context of
            type theory, we just say, “Oh, propositions, types.” You know, that’s
            just like a matter of your point of view. Okay? There’s no real
            difference between a proposition and a type; they’re the same thing.</p>
        <p>所以，这会产生一些后果。这意味着，特别是，我们量化的东西实际上可能看起来更像一个命题。好吗？我的意思是，当然，这取决于你如何看待它，但它可能具有仅涉及逻辑连接词的形式。然后它看起来像你正在量化证明。原因是，证明是数学对象，就像所有其他对象一样。类型对所有数学对象进行分类，这就是我们量化的内容。因此，顺便说一句，我们得到了证明量化证明。所以，一切都很顺利。</p><p>So, that has some consequences. It means, in particular, that the
            thing we’re quantifying over could very well look more like a
            proposition really. Okay? I mean, it’s a matter of how you look at it,
            of course, but it would could have the form, you know, involving only
            logical connectives. And then it looks like you’re quantifying over
            proofs. And the reason being, proofs are mathematical objects, just like
            all the others. Types classify all the mathematical objects, and that’s
            what we quantify over. So, in passant, we get proof quantification over
            proofs. So, it all sort of works out smoothly.</p>
        <p>传统的故事有点……从类型论的角度来看，传统的故事有点牵强，因为在我看来，类型论是第一种对逻辑的全面理解。好吧？好吧。但它看起来就是这样。然后，如果它是一本逻辑书，你会倾向于把它写成“对于所有 x”。你会区分那是一种类型，这是一个命题，然后把它写成“对于所有”语句。所以，这是一般事物的一个特例。好吧。</p><p>The conventional story is a bit… the conventional story is a bit
            contrived when you see it from a type theoretical point of view, because
            type theory was the first sort of comprehensive understanding of logic,
            in my opinion. Okay? So, okay. But that’s what it would look like. And
            then, if it were a logic book, you would tend to write this as “for all
            x.” You would make the distinction that that’s a type, this is a
            proposition, and then write it as a “for all” statement. So, that’s a
            special case of the general thing. All right.</p>
        <p>然后，继续按照自然推理的模式，我们必须决定这种类型的元素是什么。让我们看看介绍，好吗？让我们考虑一下。我想说某样东西或其他东西是这种类型的元素。</p><p>And then, continuing in the pattern of natural deduction, then we
            have to decide what are the elements of this type. So let’s look at the
            introduction, all right? So let’s think about this. So I want to say
            something or other is an element of this type.</p>
        <h2 id="elements-of-pi-types-and-lambda-abstractions">Pi 类型和 Lambda 抽象的元素</h2><h2>Elements of Pi
            Types and Lambda Abstractions</h2>
        <p>我还必须说相等之类的东西，但我会讲到这个。πx 和 a，b，好的。</p><p>I’m also going to have to say equality and stuff, but I’ll get to
            that. πx and a, b, okay.</p>
        <p>所以，如果你只是想想你的集合论经验，那么如果我看一下——你可能已经看过了——我会把它记在一边——πx 和 a，b(x) 的概念，其中这是一个由 a 索引的类型系列。这就是我们所描述的。这被描述为无限序列——是一个 a 索引元素。所以它基本上是 ba、ba'、oops、ba'' 等等，对于每个可能的 a' 选择。人们有时会这样写，或者有各种方法可以表示它，好吗？</p><p>So if you just think of your set theoretic experience, then if I look
            at—you may well have seen—I’ll jot it up here on the side—the idea of πx
            and a, b(x), where this is a family of types indexed by a. That’s what
            we’re describing. And this is variously described as being in infinite
            sequences like that—is an a indexed element. So it’s basically
            ba,ba’, oops, ba’‘, et cetera, for each possible choice of a’.
            People sometimes write it like that, or there are various ways you can
            notate it, okay?</p>
        <p>嗯，实际上，这是一个函数；它是一个映射，它将这里相应实例的元素分配给每个元素。所以我们要这样写，它表示，“好吧，给定一个量化域的元素，我希望你给我”——让我在这里放一个小 x，只是为了表示变量类型的变量元素，好吗？所以这是一个知道 x 的元素，这是一个知道 x 的类型，好吗。</p><p>Well, really, what’s going on is it’s a function; it’s a mapping that
            assigns to every element of a an element of the corresponding instance
            here. So the way we’re going to write that, it says, “Well, given an
            element of the domain of quantification, I expect you to give me”—and
            let me put a little x here just to indicate a variable element of the
            variable type, okay? So this is an element that knows about x, and this
            is a type that knows about x, okay.</p>
        <p>然后，你在这里说的意思是这是一个映射，对吧？这是一个映射，它为每个 x 分配一个小 a，每个元素 a 中的小 a 都分配一个 ma，其类型为 ba。如果我将所有这些形式的集合放在一起，就会得到一个元素。这就是 lambda 抽象。所以这将写成 λx.a。如果我想强调，我可以写成 mx，好吗？然后在这种情况下，我会写成 bx，它看起来就像这样。这就是 π 引入规则。</p><p>And then the idea is what you’re saying here is this is a mapping,
            right? This is a mapping that assigns to each x, each element little a
            in a, it assigns ma, which is of type ba. And the collection of all of
            those forms, if I put those all together, that will give me an element
            here. And that’s a lambda abstraction. So this will be written λx.a. If
            I wanted to emphasize, I could write mx, okay? And then in that case, I
            would write bx, and it would look like that. So that’s the π
            introduction rule.</p>
        <p>所以重点是，它是一个函数。这也可以表示为将 x ∈ a 发送到 mx。您可以这样写，也可以写成 x | x ∈ a&gt;。我的意思是，人们有各种表示它的方法，但计算机科学家当然使用 λ。所以我们将使用 λ 来表示，好吗？这是引理形式。然后是消除形式，这是典型的，是的，下棋盘，是的。所以，我想说的是，我想让我们尝试一下。</p><p>So the point is, it’s a function. And this could also be notated send
            x ∈ a to mx. You could write it like that, or you could write it as, you
            know, x | x ∈ a&gt;. I mean, there are various ways of like people
            notate it, but computer scientists use λ, of course. So we’ll write it
            using a λ, okay? So that’s the introductory form. Then the elimination
            form, and this is a characteristic thing, yep, lower board, yeah. So,
            what I was trying to do is I was trying to say I was trying to give us a
            little try.</p>
        <p>如果我们愿意，你可以把它写成两列，两行。所以，我这样做了。我们从各种命题开始，然后在这些命题和类型之间进行类比。然后我们忘乎所以，开始写下许多与命题不对应的类型。然后它们又有点像我解释的那样。这不是——与传统事物的对应并不完全一致，因为从类型理论的角度来看，传统事物奇怪地不完整。</p><p>You could write this in two columns if we want, two rows if we want.
            So, I had. We started out with various propositions, and then we drew
            analogies between those propositions and types. And then we got carried
            away and started writing down a lot of types that didn’t correspond to
            propositions. And then they kind of do again, in the way that I have
            been explaining. That’s not the—the correspondence is to traditional
            things are not exact because traditional things are weirdly incomplete
            from the point of view of type theory.</p>
        <p>这是否回答了你的问题？什么？因为它们不是——我的意思是，因为某些类型与命题不对应，而你在书中找到的某些叙述或命题只是类型的片段。哦，我为什么要使用注释？你说，嗯，正如我所说，因为量词只存在。这是一种传统。这是一种符号传统。我的意思是，这是一件基本的事情。我可以告诉你。我想强调这个想法，命题的建设性内容。因为命题只不过是一堆证明的类型。</p><p>Does that answer your question as one? What? Because they’re not—I
            mean, because certain types do not correspond to propositions, and
            certain accounts or propositions like you find in books are only
            fragments of the types. Oh, why do I use annotation? You’re saying,
            well, as I say, because the quantifiers only exist. It’s a tradition.
            It’s a notational tradition. I mean, it’s a basic thing. I can tell you.
            I want to emphasize the idea, the constructive content of propositions.
            As being a proposition is nothing other than the type of a bunch of
            proofs.</p>
        <p>因此，通过用这种 π 和 σ 符号来书写，强调了它的缺点——它是一种构造。是的，好吧。我不知道我还能把它进一步发展到什么程度。不，正如我所提到的，术语和符号的冲突已经持续了一个多世纪。我试图弄清楚这些对应关系。但我内心深处真正关心的是类型理论。</p><p>And so, by writing it in this kind of notation of pi and sigma,
            stresses the cons—the idea that it’s a construction. Yes, okay. I don’t
            know what further—how much further I can—I can take it. No, it’s, you
            know, there are, as I’ve mentioned, there’s a collision of terminology
            and notations that have arisen over, you know, a century or more. And
            I’m trying to make clear the correspondences. But what I really care
            about in my heart of hearts is type theory.</p>
        <p>所以，我写下类型理论，然后尽可能地进行类比。这是我能为你做的最好的事情。相信我，你会遇到一些非常可怕的符号冲突，这可能会非常令人困惑。好的。现在怎么办？好的。这似乎有效。好的。所以，是的，这就是——好吧，我的意思是，这是最好的，如果它没有帮助——好吧，我很抱歉。</p><p>And so, I’m writing down, you know, type theory, and then trying to
            draw the analogies as much as I can. That’s the best I can do for you.
            There are, believe me, there are some really horrendous notational
            collisions that you’ll run into that can be very confusing. Okay. What
            now? Okay. That seems to work. Okay. So, so, yeah, that’s that’s
            the—well, that’s the best I mean, if it’s not helpful—well, I’m
            sorry.</p>
        <h2 id="elimination-forms-and-application">消除表格及申请</h2><h2>Elimination Forms and
            Application</h2>
        <p>我只是想帮忙。所以，我不知道。好的。那么，接下来，我们想看看消去形式。所以我们想说，我们如何处理这个元素？如果我有一个 πx 和 ab 元素，你会如何处理它？好吧，记住，它可以被认为是一个函数或一个无限序列或其他什么，无论你喜欢哪种符号。所以我能做的就是我可以实例化它。</p><p>I’m just trying to be helpful. So, I don’t know. Okay. So, going on,
            we want to look at the elimination forms. So, we want to say, what do we
            do with an element of this? If I have an element of πx and a b, what do
            you do with that guy? Well, remember, it’s to be thought of as perhaps
            as a function or an infinite sequence or whatever, whichever these kind
            of notations you like to think. So, what I can do is I can instantiate
            it.</p>
        <p>通过实例化它，我实例化了其域中的特定元素。所以，我要说的是，如果你给我域中的特定元素，那么……好的，我需要一个符号。然后它通常只是一个应用程序，你从序列 m 中取出第 n 个元素。这是一种思考方式，或者你可以认为它是将函数 m 应用于参数 n。这没关系。你得到的是该系列的相应实例。这就是这里的关键思想：当你从这个序列中选择一个特定的东西 n 并将其插入时，你得到的东西就在那条纤维中。好的，所以它在这里；这就是它所属的地方。这是一个典型的特征。</p><p>And by instantiating it, I instantiated a particular element of its
            domain. So, what I do is I say, if you give me a particular element of
            the domain, then… Okay, I need a notation. Then it’s typically just an
            application where you take the nth element of the sequence m. That’s a
            way to think about it, or you can think of it as applying the function m
            to the argument n.&nbsp;It doesn’t matter. And what you get back is a
            corresponding instance of that family. And this is the critical,
            critical idea here, that goes on: the fact that when you choose from
            this sequence a particular thing n and you plug that in, the thing you
            get is in that fiber. Okay, so it’s here; that’s where this belongs. And
            that’s a characteristic, characteristic feature.</p>
        <p>然后，如果我们再次看一下我迄今为止谈到的定义相等的原则，那么我们就会发现，基本理解，你记得，是计算的想法 - 这些类似 beta 的规则，我认为它们代表了弗兰克可能所说的反转原理。</p><p>Then, if we look again at those principles of definitional equality
            that I talked about so far, then we will get that the baseline
            understanding, you recall, is the idea of computation—these beta like
            rules, which are representing what Frank, I think, probably called the
            inversion principle.</p>
        <h2 id="definitional-equality-and-computation">定义平等和计算</h2><h2>Definitional Equality and
            Computation</h2>
        <p>消除规则颠倒了引入规则。也就是说，如果我取一个明确引入的元素（就这么写吧），然后消除它，将其应用到其中，这应该与代入相同，在本例中，n 代表 x 和 m。在适当的前提下，其类型将是 n 代表 x 和 b，例如 a 是类型，m 是类型 b 族的元素族。好的，就是这样。这是一种类似于 beta 的规则。如果你愿意的话，这也可以称为 pi 计算。</p><p>The idea that the elimination rules invert the introduction rules.
            So, it says if I take something which I have explicitly introduced—so
            let’s write it like that—and I then eliminate it, do it an application,
            that should be the same as just plugging in, in this case, n for x in m.
            And its type will be n for x and b, under suitable premises, like a is a
            type and m is a family of elements of the family of types b. Okay, like
            that. And this is the sort of beta like rule. And this can also be
            called pi computation, if you will.</p>
        <p>好的，这就是定义等价的基本原则之一。</p><p>All right, so that’s that’s like one of the basic principles of
            definitional equivalence.</p>
        <p>现在，我知道弗兰克的讨论中提到了是否应该有其他定义平等原则。目前，我暂时不打算讨论这个问题。</p><p>Now, I know that it has come up in Frank’s discussion whether there
            should be other principles of definitional equality. And for the time
            being, I’m just not going to go there.</p>
        <p>好的。我之前说过，定义平等的确切概念有些难以确定。它并不完全清楚。我认为弗兰克可能为你提出了不同的规则，我不会正式采纳，因为我有其他处理方式。但你也可以考虑——我只打个问号——一条相反的规则。这是局部健全性；所以这就是弗兰克所说的局部完整性。所以，如果你把引入放在消除之后，这也应该是无操作。对吧？那些应该取消。我就不提了。这叫做 eta 规则。我会，我会，我会暂时把它放在一边。我当然要求，至少……</p><p>Okay. There is some—I said to you before—the exact idea of what is
            definitional equality is a little bit up for grabs. It’s not completely
            clear. I think that Frank might have postulated for you a different
            rule, which I won’t officially take because I have other ways of dealing
            with this. But one might consider, as well—I’ll just put a question
            mark—a rule that says the other way around. This is the local soundness;
            so it’s what Frank calls a local completeness. So, if you put the
            introduction after the elimination, that somehow should also be a no op.
            Right? That those should cancel. And I’ll just leave that. That’s called
            the eta rule. I will, I will, I will leave that aside for the time
            being. I certainly demand, at a minimum, …</p>
        <h1 id="type-theory-foundations-3.1-robert-harper">类型理论基础 3.1 — Robert Harper</h1><h1>Type Theory
            Foundations 3.1 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 2 日) — 37:02 <a href="https://youtube.com/watch?v=Mr_VqlHcxyM">https://youtube.com/watch?v=Mr_VqlHcxyM</a></p><p> 11
            years ago (Jan 2, 2014) — 37:02 <a href="https://youtube.com/watch?v=Mr_VqlHcxyM">https://youtube.com/watch?v=Mr_VqlHcxyM</a></p>
        <h2 id="summary-7">概括</h2><h2>Summary</h2>
        <p>本视频讨论了类型理论，并将其与传统逻辑进行了对比。演讲者解释了产品（类似于全称量化）和 sigma 类型（类似于存在量化）的类型理论规则与标准逻辑公式的显著不同。Robert Harper 强调，证明是类型理论中的对象，允许更完整、更精确地表示逻辑概念，包括选择公理，它成为定理而不是公理。该视频重点介绍了两种方法之间的根本区别以及类型理论的优势。</p><p>This video discusses type theory, contrasting it with traditional
            logic. The speaker explains how type-theoretic rules for products
            (similar to universal quantification) and sigma types (similar to
            existential quantification) differ significantly from standard logical
            formulations. Robert Harper emphasizes that proofs are objects in type
            theory, allowing for a more complete and precise representation of
            logical concepts, including the axiom of choice, which becomes a theorem
            rather than an axiom. The video highlights the foundational differences
            between the two approaches and the advantages of type theory.</p>
        <h2 id="betalike-rules-and-definitional-equality">Betalike 规则和定义平等</h2><h2>Betalike Rules and
            Definitional Equality</h2>
        <p>类似 beta 的规则，与以下想法一致：定义相等应该表示定义的结果的方程式推导，或者只是符号执行，好的。</p><p>The beta like rules, which are consistent with the idea that
            definitional equality should be representing equational deduction as a
            consequence of the definitions, or just symbolic execution, okay.</p>
        <p>因此，如果我们以此作为我们的基线，即我们对定义等价性的基本理解，我们当然想要它。而这在某种程度上是一种不同的东西。这是一种归纳原理。它说该类型的每个元素都采用 lambda 的形式。因此，就像数学归纳法说自然数的每个元素都具有零或后继的形式一样，它有点像那样。</p><p>So, if we take that as our baseline, our baseline understanding of
            definitional equivalence, certainly we want that. And this somehow is a
            different sort of thing. This is a kind of induction principle. It says
            every element of the type is in the form of a lambda. So, in the same
            way that mathematical induction says every element of the natural
            numbers has the form of either a zero or a successor, it’s a little bit
            like that.</p>
        <p>所以，我有点不想，你知道，我可能真的不想去那里介绍这个作为定义平等的原则，好吧。但是，我承认这不是硬性规定。这就像，你知道，我给你一些感觉，好吧。</p><p>So, I kind of don’t want to, you know, I probably don’t really want
            to go there and introduce this as a principle of definitional equality,
            okay. However, I will admit it’s not like hard and fast rules here. This
            is like, you know, I’m giving you some feeling, okay.</p>
        <h2 id="product-type-and-universal-quantification">产品类型和通用量化</h2><h2>Product Type and
            Universal Quantification</h2>
        <p>好吧，这就是乘积的概念。顺便说一句，你可以看到，这——我应该早点说——与你期望看到的全称量化规则有点对应。因为，在传统逻辑中，你不必太担心证明的形式。但如果我们说<em>x</em>的<em>b</em>
            对于每个<em>x</em>和<em>a</em>都为真，那么就忽略这一点，只读作x 的 b 对于<em>a</em>中的每个<em>x</em>都为真，那么我们在传统逻辑中忽略的某件事，就会证明对于 a 中的每个<em>x</em>，
             x
            <em>的</em>b<em>为</em>真<em>。</em>换句话说，它<em>的</em>含义就是它在<em>x中一致为真。这样写的话</em><em>，</em>它看起来就像是传统的逻辑规则。这里也是一样，如果我们将其读作对于<em>a</em>中的
            每个<em>x</em>，<em>b</em>都是真的。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>All right, so that’s the notion of the product, okay. And you can
            see, by the way, that this—I should have said this before—corresponds a
            little bit to the rules that you would expect to see for like universal
            quantification. Because, well, in traditional logic, you don’t worry too
            much about the forms of proofs. But if we said <em>b</em> of <em>x</em>
            is true for every <em>x</em> and <em>a</em>, so suppress this and just
            read that as <em>b</em> of <em>x</em> is true for every <em>x</em> in
            <em>a</em>, then something or other, which we suppress in the
            traditional accounts of logic, witnesses that for every <em>x</em> in
            <em>a</em>, <em>b</em> of <em>x</em> is true. In other words, the
            meaning is just exactly that it is true uniformly in <em>x</em>. And
            then that looks exactly like a conventional rule of logic when written
            like that. The same here, if we read that as, for every <em>x</em> in
            <em>a</em>, <em>b</em> is true.
        </p>
        <p>因此，如果我们读到这个，就忘记<em>m</em>本身，只关心它存在的事实。如果这是真的，并且我有域的一个特定元素，那么，在传统逻辑中，我们不必担心如何表示它，但我们得到的是<em>n</em> for
             <em>x</em> , <em>b</em>为真。也就是说，如果我量化<em>x</em>
            并代入特定的<em>x</em>，那么该实例为真，并且该应用程序证明了它的真实性，好吧。
        </p><p>So, if we read that, forget the <em>m</em> itself and just worry
            about the fact that it exists. If this is true, and I have a particular
            element of the domain, then, well, in traditional logic, we don’t worry
            about how to notate it, but what we get is the fact that <em>n</em> for
            <em>x</em>, <em>b</em> is true. That is, if I quantify over <em>x</em>
            and I plug in a particular <em>x</em>, then that instance is true, and
            the truth of it is witnessed by this application, okay.
        </p>
        <p>然后，在传统逻辑中，因为我们不担心证明是研究对象，所以我们也不担心它们何时相等。所以，这些都不会出现，好吧。很遗憾，但事实就是这样，好吧。</p><p>And then, in traditional logic, because we don’t worry about proofs
            as being objects of study, then we don’t worry about when they’re equal
            either. So, none of this comes up, okay. It’s a pity, but that’s the way
            it is, okay.</p>
        <p>因此，一旦你从类型理论的角度学习了逻辑，你就再也无法用同样的方式看待逻辑了，因为它在你看来会非常不完整，因为不知何故，故事的一半已经完全被省略了。你知道，事实就是这样。这是类型理论进步的一部分。为什么它很重要？为什么类型理论很重要，为什么它在这个领域取得了前所未有的进步？所以它也不能很好地消除。好的。好的。就是这样。现在让我们看看 sigma 类型，它看起来有点形式上相似。</p><p>So, once you learn logic from the point of view of type theory,
            you’ll never be able to look at logic the same way again, because it
            will look very kind of broken to you, because it somehow half the story
            has been completely omitted for some unknown reason. And, you know,
            that’s the way it is. That’s part of the advance of type theory. Why is
            it important? Why is type theory important, and why has it made advances
            in the field that haven’t been made before? So it doesn’t erase very
            well either. Okay. All right. So, that’s that. So, now let’s also look
            at the sigma type, which is, you know, looks sort of formally
            similar.</p>
        <h2 id="sigma-type-introduction-and-elimination">Sigma 类型的引入和消除</h2><h2>Sigma Type Introduction
            and Elimination</h2>
        <p>所以，这个想法是，这是一个很大的和。所以我们要说，我们有<em>一个</em>类型<em>bx家族的和。我会在这里写下来，这意味着当</em><em>a</em>是一个类型时，它就会是一个类型
            。所以，你有一个量化的域，<em>b</em>是类型。形成条件是相同的。所以，这是 sigma 形成。</p><p>So, the idea is this is a big sum. So, we’re going to say we have the
            sum over <em>a</em> of a family of types <em>bx</em>. I’ll write that
            here, and that means that’s going to be a type exactly when <em>a</em>
            is a type. So, you have a domain of quantification, and <em>b</em> is
            the type. The formation conditions are the same. So, this is sigma
            formation.</p>
        <p>好的，然后我们将进行介绍和淘汰。</p><p>Okay, and then we’re going to have the introduction and the
            elimination.</p>
        <p>好的。那么，介绍是：元素 sigma <em>x</em>和<em>b</em>是什么意思？如果我想强调依赖关系，我可以在那里写<em>x 。</em></p><p>Okay. So, the introduction is: What does it mean to have an element
            of sigma <em>x</em> and <em>b</em>? I can write the <em>x</em> there if
            I want just to emphasize the dependence.</p>
        <p>好的。那么，什么是元素？好吧，这应该被认为是由<em>a索引的大不相交并集。好的。所以，它是类型</em><em>bx</em>的每个元素对类型
            <em>a</em>的大和。因此，该类型的元素可以被认为是由索引元素<em>a组成——比如说，“嘿，这是我正在谈论的</em><em>a</em>的特定元素”——以及元素
            <em>n</em>组成，元素 n 的类型为<em>m</em> ，其中<em>x</em> ∈ <em>b</em>。在这种情况下，对<em>n成为 sigma </em><em>x</em>
            和<em>b</em>的元素。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>Okay. So, what is an element? Well, this is supposed to be thought of
            as the big disjoint union indexed by <em>a</em>. Okay. So, it’s the big
            sum over the type <em>a</em> of each of the elements of type
            <em>bx</em>. So, the elements of that type can be thought of as
            consisting of an index element <em>a</em>—say, “Hey, I’m over this is
            the particular element of <em>a</em> I’m talking about”—and an element
            <em>n</em> whose type is <em>m</em> for <em>x</em> ∈ <em>b</em>. And in
            that case, the pair <em>n</em> becomes an element of sigma <em>x</em>
            and <em>b</em>.
        </p>
        <p>而这正是另一个术语混淆出现的地方，因为和的元素是成对的。所以，人们会说，“哦，所以我们应该把它称为依赖乘积，因为它很像乘积，只是它是依赖的。”这是真的，但它很令人困惑。好吧。所以，术语并不——这是一个长期存在的术语问题。但我只向你们解释一下那是什么。</p><p>And this is where another terminological confusion comes up, because
            the elements of the sum are pairs. So, then people say, “Oh, so we
            should call this the dependent product after all, because it’s a lot
            like a product except that it’s dependent.” And that’s true, but it’s
            confusing. Okay. So, the terminology doesn’t—it’s a long standing issue
            here about the terminology. But I’ll just explain to you what that
            is.</p>
        <p>如果我们把这些事物的大不相交并集暂时视为集合，那就会产生误导。这里的集合论解释是低维的，我们稍后会讨论高维解释。但在低维设置中，这些只是集合。所以，这是一个由集合索引的集合族的大不相交并集。所以，这些只是我们用来写下该并集元素的正式符号。</p><p>If we’re taking this big disjoint union of a bunch of things, if we
            think temporarily of these as sets, it’s misleading. The set theoretic
            interpretation here is low dimensional, and we’re going to be talking
            about higher dimensional interpretations later. But in the low
            dimensional setting, these are just sets. So, this is a big disjoint
            union of a family of sets indexed by a set. So, these are just the
            formal notations we have for writing down the elements of that
            union.</p>
        <p>现在，我想说，这对应着——再次强调，这种对应关系有点尴尬，因为它与一些教科书并不完全一致，我稍后会告诉你原因——但它在某种程度上对应于存在量化。对吧？它将是这样的……当你看的时候，你可以清楚地看到这一点……这被称为 sigma 引入规则。如果你认为这是一个存在量词。它说，如果我想知道，如果我想向你展示存在一个 x 和一个 a，并且 x 的 b 为真，那么我所做的就是展示一个特定的 a，它是存在性的见证，然后我告诉你这是 b 对那个特定实例为真的特定实例。</p><p>Now, I want to say that this corresponds—and again, the
            correspondence is a little awkward because it doesn’t line up with some
            textbooks exactly, and I’ll tell you why in a minute—but it sort of
            corresponds to an existential quantification. Right? It’s going to be
            the idea that…and you can see this nicely when you look at…this is
            called the sigma introduction rule. If you consider this to be an
            existential quantifier. It says, if I want to know that, if I want to
            show you that there exists an x and an a such that b of x is true, then
            what I do is I exhibit a particular a that’s the witness to the
            existential, and then I tell you that this is that particular instance
            that b is true for that particular instance.</p>
        <p>因此，您可以看到普通逻辑中存在量化的对应关系。正如我所说，证明对象被隐藏了，因此您唯一看到的是术语，即特定证人。因此，如果您在进行算术运算，那将是一个数字或其他东西，然后您将根据逻辑规则证明 b 的实例为真，然后您得出结论，存在一个。好的，这就是，这就是当您意识到，正如我再次重申的那样，在类型理论中，a 现在可以涵盖更多事物时，对应关系开始中断的地方。在下一条规则中，接下来的两个规则，即 sigma elim，即 L1 和 sigma lim2，对应关系开始真正中断。然后我会给你布置一个作业。好的，好的。</p><p>And so you can see the correspondence to existential quantification
            in ordinary logic. As I say, the proof objects are suppressed, so the
            only thing you see is the term, the particular witness. So, if you’re
            working in arithmetic, that would be a number or something, and then you
            would show that that instance of b is true by the rules of logic, and
            then you conclude that there exists one. Okay, so that’s the, that’s the
            where that correspondence starts to break down as soon as you realize,
            as I mentioned again to reiterate, in type theory, a can range over more
            things now. The correspondence starts to really break in the next rule,
            the next two rules, which are the sigma elim, which are L1 and sigma
            lim2. And then I’m going to give you an assignment. Okay, all right.</p>
        <p>这就是我们在这里要做的事情。我想要做的是颠覆入门规则。</p><p>So, this is what we do here. So, what I want to do is I want to
            invert the introductory rules.</p>
        <h2 id="sigma-type-projections-and-definitional-equivalence">Sigma 类型投影和定义等价性</h2><h2>Sigma Type
            Projections and Definitional Equivalence</h2>
        <p>我想说，好吧，如果你给我一个 sigma 类型的元素，对吧，就像那样，我能用它做什么？好吧，它的原理是，引入规则告诉我们元素是什么：它们是有序对。所以，如果我把两个东西放进去，那么根据证明守恒定律，我应该能够把这两个东西从里面拉出来。好的，这就是想法。所以，这是唯一的，这就是为什么。</p><p>I want to say, well, if you give me an element of the sigma type,
            right, like that, what can I do with that guy? Well, the principle of it
            is that the introduction rule tells us what the elements are: they’re
            ordered pairs. So, if I put two things into it, then by the principle of
            conservation of proof, I should be able to pull those two things back
            out of it. Okay, that’s the idea. So, this is the only, this is why.</p>
        <p>因此，我将 m 放入其中。我们知道，我放入其中的东西最终必须是这种形式。因此，我们将介绍投影。因此，人们使用不同的符号。一种是 m 的 π 1，即 a，然后在相同条件下，将 π x 和 aex 放在这里，然后我们将得到 m 的 π 2，现在这是关键的事情，m、x、b 的 π 1。这非常关键。好的。</p><p>So, I put m is something that I put into it. We know that ultimately
            what I put into it must be in this form. So, we’ll introduce
            projections. So, there are different notations people use. One is pi one
            of m, which is a, and then under the same conditions, put here pi x and
            a e x, and then we will have that pi two of m is, and now this is the
            critical thing, pi one for m, x, b. That’s very critical. Okay.</p>
        <p>因此，然后我们就有了定义等价规则。如果您不介意我稍微乱写一下，我不会仔细地写出来。很明显，这应该是 m，这应该是 n。顺便说一句，局部完备性的逆命题会说，如果你这样做，你应该有 m，但我不会在这里将其视为定义等价的原则。我不会这样做，但这与我们之前所得到的类似。</p><p>So, and then we would have definitional equivalence rules. And if you
            don’t mind me slightly just scribbling, I won’t write it all out
            carefully. It’s the obvious ones that this should be m and this should
            be n.&nbsp;As an aside, the converse of the local completeness would say, if
            you do this, you should have m, but I won’t consider that here as a
            principle of definitional equivalence. I won’t do that, but that’s a
            similar analogy to what we had before.</p>
        <p>所以，这些对于计算来说很重要。好的，现在的问题是，与普通逻辑相比，这看起来如何。</p><p>So, these are the important ones for computation. Okay, now the
            question is how this looks compared to ordinary logic.</p>
        <h2 id="comparison-to-ordinary-logic-and-axiom-of-choice">与普通逻辑和选择公理的比较</h2><h2>Comparison to
            Ordinary Logic and Axiom of Choice</h2>
        <p>答案是：与普通逻辑相比，它看起来不太好。而这正是我喜欢看到的地方——哦，是的——这是传统的做法吗？或者有可能，或者曾经做过，写出来好吗？第二，好的。所以，这就是——这就是——这是一个冲突点。所以，对我来说，好吧，我会告诉你我的观点：逻辑只能解释为类型理论的一种使用模式。</p><p>The answer is: it doesn’t look very good compared to ordinary logic.
            And this is a spot where the way I like to see it—oh, yeah—is it is this
            like the traditional way of doing it, or is it possible, or ever done,
            to write it okay? Second, okay. So, so here’s the—here’s the—here’s a
            collision point. So, for me, okay, I’ll tell you my point of view: logic
            can only be explained as a mode of use of type theory.</p>
        <p>好吧，但是人们尝试过不借助类型理论来解释它，结果却遇到了麻烦。这就是你遇到麻烦的地方，我会告诉你为什么，好吗？</p><p>Okay, but people have tried to explain it without the benefit of type
            theory, and you get into trouble. And this is a spot where you get into
            trouble, and I’ll tell you why, okay?</p>
        <p>假设我们将其视为存在量词。好吧。如果这个存在公式是真的——我们应该这样思考——那么，你现在得到的就是一个术语，一个将证明转化为量化域对象的术语。所以，现在，为了具体起见，让我们假设 a 是自然数。然后你要做的就是说，“给我一个证明，证明 x 存在于 a 中，并且 b 是 x，我将从该证明中提取一个术语——一个数字。”你不能用普通的传统逻辑来做到这一点，因为证明不是对象。好吗？你甚至无法表达这一点。这是行不通的。甚至没有办法这么说。</p><p>So, suppose we think of this as an existential quantifier. Okay. So,
            if this existential formula is true—that’s the way we’re supposed to
            think about it—well, one thing you’ve got now is a term, a term that
            takes a proof and turns it into an object of the domain of
            quantification. So, at the moment, let’s say, just for concreteness,
            let’s think of a as being the natural numbers. Then what you’re doing is
            you’re saying, “Give me a proof of exists x in a such that b of x, and
            I’ll extract from that proof a term—a number.” You can’t do that in
            ordinary, conventional logic because the proofs are not objects. Okay?
            You’re not able to even express this. This is a non starter. There’s no
            way to even say this.</p>
        <p>因此，这不符合传统逻辑中的规则。如果你把它变成存在量词，情况会更糟。所以，你所做的就是说，冒号 m 表示这个命题是真的。然后，你可以从另一个证明中提取，这个证明证明量化公式对于特定证人 m 的 π₁ 是正确的。我不知道 m 的 π₁ 是什么。例如，m 可能是一个变量。所以，我不知道 m 是什么。M 不一定是我知道的元组。它可能是一个变量。但可以肯定的是，x 的 π₁ 是 a 的一个元素，因此这个公式是真的。这也不能用普通逻辑来表达，对吧？没有办法说它们不完全对应。</p><p>So, this does not correspond to a rule in conventional logic. And
            this one is only worse if you make this into an existential quantifier.
            So, that what you’re doing is you’re saying, well, the m colon means
            this proposition is true. Then you’re able to extract from another
            proof, which is a proof that the quantified formula is true for that
            particular witness, π₁ of m. I don’t know what π₁ of m is. For example,
            m could be a variable. So, I don’t know what m is. M is not necessarily
            a tuple that I know. It could be a variable. But certainly, π₁ of x is
            an element of a such that this formula is true. That cannot be expressed
            in ordinary logic either, right? There’s no way to say these do not
            correspond exactly.</p>
        <p>现在，我要说这些是存在量化的正确规则。我需要一个地方来写。我会在这里写。好的。但是它们不是你通常得到的规则。那么，你通常得到的规则是什么呢？我会请你推导它们。你通常得到的规则看起来像这样。它说，好吧，让我们把它写成类型理论。所以，我们会这样做。如果 σx ∈ a ∧ bx，或者等效地，如果存在一个 x 使得 x ∈ a 和 x ∈ b，那么存在性陈述就是真的。那么你的理由如下：你说，“好吧，给定 a 中的 x，给出一个证明，证明 b 对于特定的 x 成立。”因为你的推理方式是，你说，“如果我知道存在一个具有某种属性的数字，我会说，‘好吧，让 x 成为具有该属性的数字。’而‘具有该属性’部分意味着引入一个代表证明的变量，好的，当你在建设性环境中工作时，你就有了这个证明，然后你就可以推导出其他命题的证明，好吗？”这是典型情况，其中该命题在周围语境 γ 中具有外在意义，然后你说了一些东西或其他东西见证了 c 的真实性。&nbsp;</p><p>Now, I would argue that these are the correct rules for existential
            quantification. I need a spot in which to write. I’ll go over here.
            Okay. And but they’re not the ones you usually get. So, what are the
            ones you usually get? And I’m going to ask you to derive them. The ones
            you usually get is something that looks like this. It says, well, let’s
            write it as if it were type theory. So, we’ll do it like this. If σx ∈ a
            ∧ bx, or equivalently, if there exists an x such that x ∈ a and x ∈ b,
            then the existential statement is true. Then your reason is as follows:
            you say, “Well, given x in a, given a proof that b holds for that
            particular x.” Because the way you reason is, you say, “If I know that
            there exists a number with a certain property, I say, ‘Well, let x be a
            number with that property.’ And the ‘with that property’ part means
            introduce a variable standing for the proof, okay, that you have when
            you’re working in the constructive setting, and then you derive a proof
            of some other proposition, okay?” This is the typical thing where that
            proposition is extrinsically meaningful in the ambient context γ, and
            then you say something or other witnesses the truth of c.&nbsp;</p>
        <p>这是一种——你可以——有很多种写法，但它相当于“让 x, y 在 n, n 中为 m”。这应该说“对不起”。好吧。n，n，好的。就是这样。这将是你的典型模式，抑制证明对象。这将是你在典型逻辑公式中的典型推理模式。你的练习是证明这是可推导的，好吗？所以我们会这样做，这样你就可以在这些原则的基础上得到它。</p><p>And it’s a kind of—let—you can—there are many ways to write this, but
            it amounts to something like, “Let x, y be m in n, n.” That should have
            said, “Excuse me.” All right. n, n, okay. Would be like that. That would
            be your typical mode, suppressing the proof objects. That would be your
            typical mode of reasoning in a typical formulation of logic. Your
            exercise is to show that that’s derivable, okay? So we’ll we’ll do it
            like that, so you can get it on the basis of these principles.</p>
        <p>但是这些原则，你知道，要强大得多。我的意思是，这些原则说得好，它们说的是正确的，好吗？一阶逻辑或像这样的传统逻辑处理必须绕开它，因为它们没有办法。这里的这个物体是一个外星野兽，它是外星的，因为你用一个证明来制造一个数字，而什么是证明，好吗？你明白了吗？正因为如此，好吧，这是一个非常重要的概念，我现在要利用这个概念给你举一个小例子，好吗？</p><p>But these principles are, you know, much stronger. I mean, these are
            saying well, they’re saying the right thing, okay? First order logic or
            conventional treatments of logic like this have to talk around it
            because they have no way. This object here is an alien beast, that’s as
            alien as alien could be, because you’re making a number out of a proof,
            and what’s a proof, okay? You see? And because of that, okay, that is a
            very important concept, which I’m now going to exploit by giving you a
            little example, okay?</p>
        <p>这就是我要做的，好吧。这就是规则。那么让我用这两条规则向你们展示一些我认为很重要的量化知识，好吗？到目前为止，你们明白了吗？这样可以吗？好的，好的。那么让我总结一下。现在我想谈谈一些事情——这是传统上、目前最应该谈论的事情。我将谈论一种叫做——我会用引号引起来——选择公理的东西。</p><p>So that’s what I’m going to do, all right. So that’s the rule. So let
            me use these two rules to show you something about quantification that I
            think is important, okay? Are you with me so far? Is this okay? Okay,
            all right. So let me roll that up. So now I want to talk about
            something—this is, this is the traditionally, at this moment, the right
            thing to talk about. I’ll talk about something called—I’ll put it in
            quotes—the axiom of choice.</p>
        <p>好的，实际上它是选择<em>定理</em>。好的，这就是我要做的。好的。有很多方法可以表述它。</p><p>Okay, and actually what it is is the <em>theorem</em> of choice.
            Okay, and that’s what I’m going to—what I’m going to do. Okay. There are
            many ways to formulate it.</p>
        <h2 id="axiom-of-choice-in-type-theory">类型论中的选择公理</h2><h2>Axiom of Choice in Type
            Theory</h2>
        <p>所以，我要做的是，我要——我要——我要以一种让传统解释看起来很糟糕的形式向你们描述这一点，因为我认为传统解释很糟糕。好的。那么，我将向你们解释如下。好的。因此，选择公理的传统解释——该公理有许多等效的表述。我相信，如果你愿意的话，你可以说出十几个，但一个非常基本的是：每个总关系、二元关系都包含一个函数。好的。那么，你怎么说呢？</p><p>So, what I’m going to do is I’m going to—I’m going to—I’m going to
            portray this to you in a form that makes the traditional accounts look
            bad because I think the traditional accounts are bad. Okay. So, I will
            explain it to you as follows. Okay. So, the traditional account of the
            axiom of choice—there are many equivalent formulations of the axiom. I’m
            sure that may—you could rattle off a dozen of them if you want, but a
            very basic one is: every total relation, binary relation, contains a
            function. Okay. So, how do you say that?</p>
        <p>一种说法是：你说每一个完全二元关系——让我们用英语写出来——都包含一个函数。</p><p>One way to say it is: you say every total binary relation—let’s write
            it out sort of in English—contains a function.</p>
        <p>那么，这是什么意思呢？如果我有一个二元关系<em>r</em>，它是完全的——也就是说，无论它的域是什么，每个<em>x都与某个</em><em>y</em>相关——好吧，它是完全的。我要从<em>r</em>中选择一个子集，这将是一个函数。所以，我可以像这样写出来。</p><p>So, what does that mean? If I have a binary relation <em>r</em>,
            which is total—that is, whatever its domain is, every <em>x</em> is
            related to some <em>y</em>—okay, it’s total. I’m going to select from
            that <em>r</em> a subset, which is going to be a function. So, I can
            write it out like this.</p>
        <p>所以，你要说的是：好的，如果对于每个<em>x ，我们来看看</em><em>a</em>和<em>b</em>之间的关系。所以，如果对于<em>a</em>中的
            每个<em>x</em>，我们都会这样写，存在一个<em>y</em>在
            <em>b</em>中，使得<em>r(x, y)</em>。这就是整体。好的，这就是你用逻辑符号写出来的方式，对吧？关系<em>r</em>的总体意味着对于<em>r</em>中的每个<em>x ， </em><em>a</em>和<em>b</em>之间的关系，所以对于
            <em>a</em>中的每个<em>x</em>，哦，<em>y，</em>是的，那么我一直这样做。那么就存在一个通过<em>r</em>与它相关的
            <em>y</em>。这就是整体。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>So, what you say is: okay, if for every <em>x</em>, let’s look over a
            relation over <em>a</em> and <em>b</em>. So, if for every <em>x</em> in
            <em>a</em>, we’ll write it like that, there exists a <em>y</em> in
            <em>b</em> such that <em>r(x, y)</em>. That’s totality. Okay, that’s how
            you would write it out like in, you know, logical notation, right?
            Relation <em>r</em>’s total means for every <em>x</em> in <em>r</em>’s
            relation between <em>a</em> and <em>b</em>, so between, for every
            <em>x</em> in <em>a</em>, oh, <em>y</em> yeah, then I do this all the
            time. Then there exists a <em>y</em> that is related to it by
            <em>r</em>. That’s what totality is.
        </p>
        <p>你所做的就是实际的，所谓的选择公理表明，这意味着存在一个选择函数，该函数见证了该关系的总体。这可以表达为：好吧，我可以用最简单的方式稍微修饰一下，但最简单的表述是：你看起来像这样。存在一个<em>f</em>，对于<em>a</em>中的每个<em>x</em>，我都会选择<em>y</em>。<em>f是选择</em><em>y 的</em>选择函数。所以，这被称为选择函数，好吧，它选择与关系
            <em>r中的</em><em>x</em>相对应的<em>y</em>。好吧，这就是逻辑原理的表述。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>And what you do is the actual, the so called axiom of choice says
            this implies that there’s a choice function that is a function which
            witnesses the totality of that relation. Which can be expressed as
            saying: well, the simplest possible way I can actually jazz this up a
            little bit, but the simplest formulation is: you look like this. That
            there exists an <em>f</em> such that for every <em>x</em> in <em>a</em>,
            I choose the <em>y</em>. <em>f</em> is the choice function which chooses
            the <em>y</em>. So, this is called the choice function, okay, which
            chooses the <em>y</em> that corresponds to <em>x</em> in the relation
            <em>r</em>. Okay, so that’s what it would be stated as a principle of
            logic.
        </p>
        <p>再说一遍？我可以再犯一次错误吗？<em>f(x)</em>？是的，天啊，我真的很差劲。是的。好的。是的。对不起。</p><p>Say again? Can I make a mistake again? <em>f(x)</em>? Yeah, geez,
            god, I’m really terrible with that. Yeah. Okay. Yep. Sorry.</p>
        <p>好的，就是这样。所以，这个说法是合理的。我希望。</p><p>Okay, so that’s the way. So, the statement is sensible. I hope.</p>
        <p>注意，为了表达这一点，我需要对函数进行存在量化，因​​为我必须有一个选择函数，而这个选择函数<em>是</em>一个函数。所以，我必须能够表达这一点。</p><p>Notice, in order to say it, I needed to have existential
            quantification over functions because I have to have a choice function
            that <em>is</em> a function. So, I have to be able to express that.</p>
        <p>好的，所以很多时候这是在集合论中表述的，其中所有的——实际上只有一种类型。它是集合的类型。好的，然后你把所有的东西都放在那一种类型中。这是一种很荒谬的做法，但这就是你要做的。好的。这就是那个理论的做法。它具有任何单一类型的编程或数学方法的所有缺陷。你有很多编码，这真的很不愉快。</p><p>Okay, so a lot of times this is formulated in set theory, where all
            of the—there’s really only one type. It’s the type of sets. Okay, and
            then you work everything inside that one type. And it’s a kind of
            cockamamie way to do things, but it’s what you do. Okay. That’s the way
            it’s done in that theory. It enjoys all of the deficiencies of any uni
            typed approach to programming or to doing mathematics. You have a lot of
            codings, and it’s really unpleasant.</p>
        <p>好的，类型理论的理念就是直接提出现有的结构，而不是试图隐藏它。好的。所以，我在这里这样做。我通过明确类型来提出现有的结构。好的。所以，我有这个。所以，正如你所知，无论你如何表述它，这都被假定为集合论的公理。好的。众所周知，它必须通过一个非常复杂的论证被假定为公理，这个论证表明它独立于集合论的所有其他公理。</p><p>Okay, so the idea about type theory is to just bring out the
            structure that’s there, rather than trying to hide it. Okay. So, here I
            do that. I bring out the structure that’s there by being explicit about
            the typing. Okay. So, I have this. So, as you very well know, no matter
            how the variations of how you formulate this, this is postulated as an
            axiom of, for example, set theory. Okay. And it’s known that it has to
            be postulated as an axiom by a very complicated argument, which says
            that it’s independent of all of the other axioms of set theory.</p>
        <p>所以，你真的必须直接假设它。但这很奇怪，因为人们觉得它值得怀疑，因为它具有存在力，对吧？它告诉我们某些东西存在，否则就不存在。换句话说，如果你写下集合论的规则，并且你有一个函数的概念，它源于幂集和哒哒哒的概念，你把它全部写下来，一切看起来都很好，然后你突然意识到你错过了一些重要的函数。所以，你在集合论中这样做的方式是，你说，“哦，见鬼去吧。你直接假设它。没有完整的结构。你只是说，‘我们把那个也扔进去。’”好吧。这就是选择公理。这就是你做的。嗯，这就是人们做的。你知道，它对某些值有效。</p><p>So, you really have to, you know, postulate it outright. But it’s a
            weird thing because, and people find it questionable because it has
            existential force, right? It tells us that certain things exist, which
            so to speak otherwise don’t exist. In other words, if you write down the
            rules of set theory and you have a notion of function that arises from
            the idea of power set and da da da, and you write it all down and
            everything looks really good to you, and then you suddenly realize that
            you’ve missed some important functions. And so, the way you do it in set
            theory is you say, “Oh, hell with it. You just postulate it outright. No
            whole cloth. You just say, ‘We’ll throw that one in there too.’” Okay.
            And that’s the axiom of choice. That’s what you do. Well, that’s what
            people do. And, you know, it works for some value.</p>
        <p>不过，我想指出的是，在建设性环境中，它不必是公理。它实际上是一个定理。</p><p>The thing I want to point out here, though, is that in the
            constructive setting, it doesn’t need to be an axiom. It’s actually,
            it’s actually a theorem.</p>
        <h2 id="constructive-interpretation-of-axiom-of-choice">选择公理的建设性解释</h2><h2>Constructive
            Interpretation of Axiom of Choice</h2>
        <p>我认为这很有帮助。我——这是一个人——我接下来要做的是一个纯粹的心理动作，可能有用也可能没用，就是把它看作类型理论内部的一个构造。所以，它说如果你——我要写下一个函数，这个函数被赋予一个大不相交的并集元素。你要做的就是你想这样想它。好的。所以，它被赋予了这个构造，它被赋予了这个不相交并集的一个元素作为参数。好的。然后它想要返回，它想要产生这个不相交并集的一个元素。现在，我所做的只是改变符号。我是，但我试图强调对此的建设性解读。这就是我这样做的原因。好的。如果你不喜欢它，那就忽略这一行。它和上一​​个一样。好的。</p><p>And I think it’s helpful. I—this is a person—that’s what I’m going to
            do next is a purely psychological move that may be helpful or not
            helpful, which is to think of this as a construction inside of type
            theory. So, it says if you—I’m going to write down a function that is
            given an element of the big disjoint union. And what you want to do is
            you want to think it like this. Okay. So, it’s given this construction,
            it’s given an element of this disjoint union as an argument. Okay. And
            then it wants to deliver back, it wants to produce an element of this
            disjoint union. Now, all I’m doing is changing the notation. I am, but
            I’m trying to stress the constructive reading of this. That’s why I’m
            doing that. Okay. If you don’t like it, then just ignore this line. It’s
            the same as the previous one. Okay.</p>
        <p>好吧。哦，我又搞砸了吗？我现在做了什么？太多人同时说话。哦，是的。这是 Σ 中的 πx。是的。这很奇怪。我会告诉你，当你站在黑板前时，很难把这些事情做对。好的。所以，好的。所以，这就是我要做的事情的重述。我将向你展示术语 m 的存在。好吗？我会告诉你这个术语是什么。</p><p>All right. Oh, did I screw it up again? What did I do now? Too many
            people talking at once. Oh, yeah. That’s a πx in a Σ. Yep. It’s weird.
            I’ll tell you, it’s hard to get these things right when you’re up at the
            board. Okay. So, okay. So, that’s that’s a restatement of what I’m going
            to do. I am going to show you that the term m exists. Okay? And I’m
            going to tell you what that term is.</p>
        <p>好吗？因此，我要给你一个证明。好吗？这是一个定理。这就是我要做的。那么，我该怎么做呢？我要做的是，我将用你唯一能想到的方法定义<em>m</em>。所以，你要做的是，你说，好，我要把一个证明作为一个论据，我们称之为<em>t</em>（只是因为我碰巧想到了这一点）。一个关系是完全的证明<em>t</em>。你明白了吗？我把证明作为一个论据。看，这就是这一切真正巧妙和聪明的地方。好。</p><p>Okay? And therefore, I’m going to give you a proof. Okay? That this
            is a theorem. That’s what I’m doing. So, how do I do that? What I’m
            going to do is I’m going to define <em>m</em> in sort of the only way
            you possibly can. So, what you do is you say, okay, I’m going to take in
            as an argument a proof, let’s call it <em>t</em> (just because that’s
            what I happen to think of). A proof <em>t</em> that a relation is total.
            You see? I get the proof as an argument. See, that’s what’s really slick
            and clever about all of this. Okay.</p>
        <p>瞧，你对我说：这意味着……当你说“这意味着”时，这意味着你有办法将这个证明转换成那个证明。所以，我要做的就是写下那段代码。好吗？我要写下一个函数，lambda，它接受一个整体证明，我想发出——我想从这个东西中得到——一个函数。所以，我要在这里写下一个由一个函数和一个证明组成的对，它们的工作原理就是这样的。</p><p>Look, you’re saying to me: this implies that… when you say “this
            implies that,” it means that you have a way of transforming a proof of
            this into a proof of that. So, what I’m going to do is I’m going to
            write down that code. Okay? I’m going to write down a function, lambda,
            that takes in a proof of totality, and I want to emit—I want to get out
            of this thing—a function. So, I’m going to write down here a pair
            consisting of a function and a proof that works like that.</p>
        <p>所以，我需要在这里写下一个类型为<em>a → b</em>的函数。所以，这将写为 lambda <em>x</em>，和<em>a</em>某物。可以吗？然后这将是对每个<em>x</em>中的<em>a</em>
            某物或其他东西都成立的证明。所以，这必须是一个 lambda，然后这将是将在这里填写的某物。就像，我们同意这几乎就是你必须做的，对吧？我必须——显然，我会在这里的某个地方使用<em>t</em>。但是，这个家伙必须是一个函数，对吧？这里有一个存在量词，所以我必须向你展示这个函数。我要把它写下来。然后我必须给你一个证明，它是一个函数，因为它是一个“对所有”语句。它是一个<em>π</em>。可以吗？所以，我可以把它写下来。</p><p>So, I need to write down a function here of type <em>a → b</em>. So,
            this will be written lambda <em>x</em>, and <em>a</em> something. Okay?
            And then this will be a proof that for every <em>x</em> in <em>a</em>
            something or other holds. So, this will have to be a lambda, and then
            this will be something that will get filled in here. Like, we agree that
            that’s pretty much what you have to do, right? Is I have to—I’m going to
            use <em>t</em> in here somewhere, obviously. But, but this guy has to be
            a function, right? There’s an existential quantifier here, so I’ve got
            to show you the function. I’m going to write that down. And then I have
            to give you a proof, which is a function, because it’s a “for all”
            statement. It’s a <em>π</em>. Okay? So, I can write that down.</p>
        <p>那么，我该怎么做？好吧，如果你向我声称……那么，我想做什么？我想说，给定<em>a</em>中的<em>x</em>，我想使用此信息<em>t</em>提取<em>b</em>的一个元素，使得<em>b与该元素相关——提取的元素将与</em><em>a</em>相关。好吗？这就是我要做的。嗯，这非常明显，因为我知道对于<em>a</em>中的
            每个<em>x</em>，都有一个<em>b</em>。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>So, what do I do? Well, if you claim to me… So, what do I want to do?
            I want to say, given <em>x</em> in <em>a</em>, I want to use this
            information <em>t</em> to extract an element of <em>b</em> in such a way
            that <em>b</em> will be related to that—that extracted element will be
            related to <em>a</em>. Okay? That’s what I’m going to do. Well, that’s
            pretty damn obvious, because I’m given that for every <em>x</em> in
            <em>a</em>, there is a <em>b</em>.
        </p>
        <p>所以，我要做的就是取<em>π</em> 1 of <em>t</em> (x)。我做对了吗？好的。我想我做对了。π 1 of <em>π</em> 1 of
             <em>t</em> (x)。因为如果我取<em>t</em>，即整体的证明（这就是我称之为关系的<em>t的原因），并将其赋予特定</em><em>的</em><em>x ，它会发出假设，证明会发出见证和它与我们的</em><em>x</em>相关的证明。x 与该见证通过 r 相关。所以让我们把它拉出来。
        <em></em><em></em><em></em><em></em><em></em></p><p>So, what I’ll do is I’ll just take—take <em>π</em>1 of <em>t</em>(x).
            Did I do that right? Okay. I think I did. <em>π</em>1 of <em>π</em>1 of
            <em>t</em>(x). Because if I take <em>t</em>, which is a proof of
            totality (that’s why I call it <em>t</em> of the relation), and give it
            to a particular <em>x</em>, it emits the assumption, the proof emits a
            witness and a proof that it is related to our <em>x</em>. x is related
            to that witness by r. So let’s pull that back out.
        </p>
        <p>那就是π1(t(x))。然后我在这里做什么呢？我在这里要做的是证明对于每个 x 和 a，它们都是相关的。那么，我在这里做什么呢？好吧，那只是π2(t(x))。如果我没有犯错的话。为什么？因为π2(t(x))的类型是用π1(t(x))代替r(x, y)中的y，这正是我想要的。换句话说，我想要r(x,π1(t(x)))。而π1(t(x))是将这个家伙应用于x的结果。</p><p>That’s π1(t(x)). And then what do I do over here? What I do over here
            is I want to prove that for every x and a, they’re related. Well, what
            do I do there? Well, that’s just π2(t(x)). If I didn’t make a mistake.
            Why? Because the type of π2(t(x)) is substitute π1(t(x)) in for y in
            r(x, y), which is exactly what I want. In other words, I want r(x,
            π1(t(x))). And π1(t(x)) is the result of applying this guy to x.</p>
        <p>我想我讲完了。好的。如果我没搞砸的话，这是一个正确的证明术语。所以这应该被称为选择定理。好的。这是一个非常了不起的事情。是什么让它起作用的？好的。关键是证明是数学对象。这就是我在一开始就告诉你的，一开始就告诉你的。</p><p>I believe I am done. Okay. And that is, if I didn’t screw it up,
            that’s a correct proof term. So this should be called the Theorem of
            Choice. Okay. And that’s this is a very remarkable thing. What makes
            this work? Okay. The key is that proofs are mathematical objects. This
            is what I said to you in the beginning, the very beginning.</p>
        <h2 id="proofs-as-mathematical-objects">证明作为数学对象</h2><h2>Proofs as Mathematical
            Objects</h2>
        <p>好吧，逻辑，就好像人很重要一样。我们从证明开始。我们将证明视为理论中的对象。我可以提取。我有 t(x) 作为证明，我从证明中提取一个对象。所以这是从证明中提取证人。所以在选择公理的通常表述中发生的事情是你无法获得证明。所以你应该从任何地方得到 f。好的。你应该——f 必须毫无理由地神奇地出现，因为没有办法得到那个 f 是什么，因为没有办法检查假设，这是一个证明。</p><p>Well, logic, as if people matter. We start out with proofs. We treat
            proofs as objects in our theory. That I’m able to extract. I have t(x)
            as a proof, and I extract an object from the proof. So this is extract
            the witness from the proof. So what’s happening in the usual
            formulations of the Axiom of Choice is you don’t have access to the
            proof. So you’re supposed to get the f out of nowhere at all. Okay.
            You’re supposed to—the f has to magically appear for no good reason
            whatsoever, because there’s no way to get at what that f is, because
            there’s no way to examine the hypothesis, which is a proof.</p>
        <p>当你有了可用的证明对象时，你只需对它们进行修改，它就会变成一个定理。因此，该理论完全自给自足，并且出于一般原因而有效。它不需要任何线索。好的，让它发挥作用。我有点将集合中的选择动作视为<em>cluj</em>。好的。这就是正在发生的事情。你写了一大堆代码，你建立了这个大装置，然后有些东西不起作用了。所以你<em>cluj</em>做了一点修复。</p><p>When you have the proof objects available, you just hack around with
            them, and it becomes a theorem. So the theory is completely self
            sufficient and self contained and works for general reasons. It doesn’t
            require any clues. Okay, to make it work. I sort of view the action of
            choice in sets as a <em>cluj</em>. Okay. That’s what’s happening. You
            wrote a whole bunch of code, and you erected this big apparatus, and
            then something doesn’t work. So you <em>cluj</em> in a little fix.</p>
        <p>好的。这就是你要做的。所以这是<em>克鲁日</em>。所以这里不是——它出于一般原因而起作用。所以另一种说法，也就是我所说的隐含的说法，是在建设性环境中证明的唯一方法——这有点微妙。</p><p>Okay. So that’s what you do. So it’s <em>cluj</em>. So here it’s
            not—it works for general reasons. So another way of saying this, which
            is implicit in what I’m saying, is the only way in a constructive
            setting to prove—and this is a little more subtle.</p>
        <h2 id="type-theory-as-a-foundation-for-logic">类型理论作为逻辑的基础</h2><h2>Type Theory as a
            Foundation for Logic</h2>
        <p>我希望我能把这一点表达清楚。另一种解释是，在建设性环境中证明关系的完整性的唯一方法是展示一个函数。让我们看看我是否能解释原因。换句话说，我在这里真正想说的是，完整性的证明中隐含着一个函数。我将明确说明这个函数。这就是它的意思。那么，为什么完整性的证明中隐含着一个函数呢？</p><p>I hope I can get this across. Another way to interpret this is that
            the only way to prove the totality of a relation in a constructive
            setting is to exhibit a function. Let’s see if I can explain why. In
            other words, what I’m really saying here is implicit in the proof of
            totality is a function. And I’m going to make that function explicit.
            That’s what it is saying. So, why is there a function implicit in the
            proof of totality?</p>
        <p>正是因为量化规则告诉我们，通用量词的证明必须在<em>x</em>中起作用。为什么？因为在这里，你要给我一个在<em>x</em>中统一的证明，根据结构相等的原则，这尊重域中的相等性。所以，这定义了一个映射；它是一个函数。所以，证明必须是一个以<em>x</em>为参数的函数，对于任何<em>x</em>，都会给我们一个有序对作为函数。好的。</p><p>Exactly because the rules of quantification tell us that a proof of a
            universal quantifier has to be functional in <em>x</em>. Why? Because
            here, you’re going to give me a proof uniformly in <em>x</em>, and by
            the principles of structural equality, this respects equality in the
            domain. So, this defines a mapping; it’s a function. So, the proof has
            to be a function that takes <em>x</em> and, for any <em>x</em>, gives
            us, as a function, this ordered pair. Okay.</p>
        <p>所以，关键在于，为了证明所有存在，你在写证明时必须有一个隐含的功能选择。你必须已经做出了那个选择。而这一切所做的就是从证明中提取你已经做出的选择。好的。所以，这是关键的想法。这就是真正发生的事情。</p><p>So, the point is that in order to prove for all exists, you must,
            when you write the proof, have an implicit functional choice. You must
            have made that choice already. And all this is doing is extracting from
            the proof the choice you already made. Okay. So, that’s the critical
            idea. That’s what’s really going on.</p>
        <h2 id="topological-interpretation-of-types">类型的拓扑解释</h2><h2>Topological Interpretation
            of Types</h2>
        <p>现在，还有另一个更美妙的想法，我认为 Steve Aoudi 会对此进行更多讨论。那就是我们可以将类型解释为一种拓扑空间。然后，全称量化所发生的事情是，这里的对的选择是<em>x</em>函数的连续依赖性。因此，这本质上将是一个连续函数。不会有不连续性。</p><p>Now, there’s another, even more beautiful idea going on, which I
            think Steve Aoudi will talk more about. Is that we can interpret types
            as kind of topological spaces. And then, what is happening with the
            universal quantification is a continuous dependency of the choice of the
            pair here as a function of <em>x</em>. So, that this will intrinsically
            come out as a continuous function. There will be no discontinuities.</p>
        <p>好的。事实上，类型理论的一大优点是，类型理论的建立方式如此统一和流畅，以至于你可以将整个理论解释为谈论拓扑空间上的连续函数。这具有重大意义。我们稍后会对此进行更详细的介绍。但它是构造性所固有的。正是这种想法——我向你们解释的建设性想法——使整个引擎运转起来。好的。理解这一点非常重要。所以，我想至少在这里强调一下构造性。我们稍后会回到连续性和拓扑解释，以及它与同伦理论的关系。我们会谈到这一点。好的。</p><p>Okay. And in fact, one of the beauties about type theory is that the
            type theory is set up in such a uniform and smooth way that you can
            consistently interpret the entire thing as speaking about continuous
            functions over topological spaces. And this has an enormous
            significance. And we’ll say a little bit more about that later. But it’s
            intrinsic in the constructivity. It’s the idea—the constructive ideas
            that I’m explaining to you—are what make that whole engine work. Okay.
            And it’s really important to understand that. So, I want to emphasize at
            least here the constructivity. And we’ll get back to the continuity and
            topological interpretation later, and its relation to homotopy theory.
            We’ll get to that. Okay.</p>
        <p>对所谓的选择公理有疑问吗？是的。</p><p>Questions about the so called axiom of choice? Yes.</p>
        <p>存在量词来自证明，因为<em>t</em>是一个证明。我的意思是，在类型理论中，我反复说过，没有证明和非证明的区别。但如果我们考虑它——我想通过将其视为逻辑来引导您理解它。所以，如果我将其视为逻辑，那么<em>t</em>应该被视为对所有存在句子的证明。好的。然后，我正在做的是写下一个类型的术语。</p><p>Of the existential quantifier from a proof, because <em>t</em> is a
            proof. I mean, in type theory, I’ve said over and over, there’s no
            distinction between proofs and not proofs. But if we think of it—I
            wanted to draw you through it by thinking of it as logic. So, if I think
            of this as logic, then <em>t</em> should be thought of as a proof of a
            for all exists sentence. Okay. And then, what I’m doing is I’m writing
            down a term of a type.</p>
        <p>好的。所以，也许这是一个 n → n 函数。将 a 和 b 视为自然数。我写下通过对证明进行投影而获得的特定自然数。整个概念在一阶逻辑中完全不存在。而通常的逻辑教科书，看看其中任何一个；没有一个，好吧。类型理论是唯一一个将证明放在首位的理论，这是一件美妙的事情。</p><p>Okay. So, maybe this is an n → n function. Think of a and b as
            natural numbers. I’m writing down a specific natural number obtained by
            running the projection on a proof. That whole concept is completely non
            existent in first order logic. And the usual textbook accounts of logic,
            look at any of them; there isn’t a single one, okay. Type theory is the
            only one that gives pride of place to proofs, and that is a thing of
            beauty.</p>
        <p>这是我所知道的最华丽的智慧理念，其含义是戏剧性的。是的，有时我认为人们宁愿不采取选择的态度。好吧，在集合论中，他们确实有选择的态度，但这是因为集合论的问题。我的意思是，好吧，所以，就你的想法而言，你知道，除了那些研究另一种理论或试图将各种事故相互联系起来的人之外，还有人不想这样做。</p><p>It is the most gorgeous intellectual idea that I know, and its
            implications are dramatic. Yes, sometimes I think people prefer not to
            have the attitude of choice. Well, in set theory, they do, but that’s
            because of the problems of set theory. I mean, okay, so that you, as far
            as you think, know the people, people who, you know, so to say, don’t
            want other than people doing another theory or like trying to relate
            various accidents to each other.</p>
        <p>让我们忘掉这种做法吧。人们说他们不想要它的唯一原因是，它是一种毫无根据的赤裸裸的存在陈述。好吧。你只需说，“存在这样的函数。”就这样。这是一个线索。我的意思是，这是对它是一个线索这一事实的承认。基本上，每个人都知道这是一个线索，有些人会写出“我无法打开它”，有些人会在他们的论文中写出他们是否依赖这个线索，因为他们有点感到内疚。</p><p>Let’s forget about that very practice. The only reason people would
            say they don’t want it is because it’s a bald existence statement that
            has no justification whatsoever. Okay. You just say, “There exists such
            a function.” Period. It’s a clue. I mean, it’s a recognition of the fact
            that it’s a clue. Basically, everybody knows it’s a clue, and some
            people will write out, “I can’t get this open,” for some, and some
            people will write out in their papers whether they relied on that clue
            or not, because they sort of feel guilty.</p>
        <p>在我看来，这从来就不是一件舒服的事。好吧，但问题在于集合论基础。它们真的没有多大意义。好吧，从长远来看，这一切都会消失。好吧。是的，在我给出的公式中，你可以，因为如果我能找到棋盘，这就是我偶然化 sigma 类型的方式。这是消除形式提取它吗？我强烈强调，这是类型理论的一个不寻常的特征。只有在类型理论的背景下，你才能接受这个概念。这就是这里的思考方式。好吧，这就是 sigma 和 pi 类型的情况。这是一个很好的例子。</p><p>In my opinion, it’s never been comfortable. Okay, but the problem is
            the set theoretic foundations. They don’t really make much sense. Okay,
            and in the long run, that’ll all go away. Okay. Yes, in the, in the
            formulation I’ve given here, you can, because if I can find the board,
            this is how I accidentalize the sigma type. Is that the elimination form
            extracts it? And I’m strongly emphasizing that this is a, you know, an
            unusual feature of type theory. It’s only possible because you’re in the
            setting of type theory that you can even entertain the notion. That’s
            what’s that’s the that’s the way to think about it here. Okay, so that’s
            what’s going on with sigma and pi types. And this is a very good
            example.</p>
        <h2 id="further-generalizations-and-exercises">进一步概括和练习</h2><h2>Further Generalizations
            and Exercises</h2>
        <p>好的。</p><p>Okay.</p>
        <p>关于 sigma pi 类型，有多种方法可以概括这一点。您可以将其概括为允许依赖关系，在这种情况下，这将变成 pi。所以你可以这样做。这是一个小的概括。好的。你可以，你可以这样做。我想首先做点简单的事情。好的。这当然是一种形式，并且有许多等效的重新表述可以写下来并证明。好的。很好。您可能做的另一件事是，如果您仅将其作为 sigma 的消除形式，您将无法尝试证明选择公理。</p><p>About sigma pi types, there are various ways to generalize this. You
            can generalize it to allowing a dependency here, in which case this
            would become a pi. So you can do that. That’s a minor generalization.
            Okay. You could, you could do that. I thought I would do something
            simple first of all. Okay. So that’s certainly a form, and there are
            many equivalent reformulations of this that can be written down and
            proved. Okay. So good. Another thing you might do is if you only had
            this as your elimination form for sigma, you will fail in trying to give
            a proof of the axiom of choice.</p>
        <p>尝试一下。好的，看看为什么它不起作用。好的。嗯，是的，整个理论都是建设性的。我的意思是，好吧，这个问题有点难回答，因为经典逻辑是一种使用建设性逻辑的模式，其中我假设所有谓词都是可判定命题的公理。</p><p>Try to do it. Okay, and see why it doesn’t work. Okay. Well, yes, the
            whole theory is constructive. I mean, okay, that’s a little bit hard to
            answer because classical logic is a mode of using constructive logic in
            which I postulate as an axiom that all predicates are decidable
            propositions.</p>
        <h2 id="classical-logic-as-a-heuristic">古典逻辑作为启发式方法</h2><h2>Classical Logic as a
            Heuristic</h2>
        <p>所以，从这个意义上说，它是完全经典的。只是当你用经典逻辑做某事时，你使用的方式，嗯，我会说这是一种启发式假设。有一种启发式假设，它可以对某些人有所帮助。就像我说的，如果你考虑牛顿法，牛顿法是一种非常好的算法，但事实上你不能真正比较实数并决定一个是小于另一个还是等于零。好吗？所以你做了一个启发式假设。你说，“让我们在一个方便的假设下工作，即实数是离散的原子，我们可以比较它们并将它们视为数据。”现在让我们在这个假设下工作。这就是——然后牛顿法的理由就是这样。好的。是的，是的，没错。</p><p>So, in that sense, it’s perfectly classical. It’s just that when you
            do something in classical logic, you’re using, well, a way I would say
            it is a heuristic assumption. There’s a heuristic assumption that it can
            be helpful to someone. Like I said, if you think about Newton’s method,
            Newton’s method is a really good algorithm, but for the fact that you
            can’t actually compare real numbers and decide whether one is less than
            the other or equal to zero. Okay? So, you make a heuristic assumption.
            You say, “Let’s work under the convenient assumption that the real
            numbers are, you know, atoms that are discrete, that we can compare and
            treat them like data.” And now let’s work under that assumption. That’s
            what—and then the justification for Newton’s method is exactly that.
            Okay. Yes, yes, that’s right.</p>
        <p>如果直觉逻辑被表述为类型理论，我知道你正在寻找——我知道我正在尝试。</p><p>If intuitionistic logic is formulated as type theory, I know you’re
            finding—I know I’m trying.</p>
        <h2 id="limitations-of-conventional-logic">传统逻辑的局限性</h2><h2>Limitations of Conventional
            Logic</h2>
        <p>我的解释部分基于这样的假设：你已经看过其他逻辑处理方法。我不知道你是否真的看过。好吧。如果你看看教科书上对直觉和心理学的处理，你会发现它不是这样的。然后，好吧，它不能正常工作。你将无法做到这一点。这一举动将不可用。</p><p>My explanations are partly based on the assumption that you’ve seen
            other treatments of logic. I don’t know whether you have actually. Okay.
            If you look at the textbook treatment of even intuition and psychology,
            it is not done like this. And then, okay, it doesn’t work properly. You
            won’t be able to do that. This move will not be available.</p>
        <p>好的，如果您采用一种逻辑版本 — — 如果您尝试写下一种一阶逻辑的规则，比如说一种多排序的一阶逻辑，甚至是一种单一排序的一阶逻辑，您对其进行了一次或多次修改，然后您写下了这些规则 — — 您写下的其中一条规则会以橙色写在左边的板上。</p><p>Okay, so if you took a version of logic—if you try to write down the
            rules for a kind of first order logic, let’s say a multi sorted first
            order logic, even a single sort of first order logic where you modify it
            one or more times, and you write those rules down—one of the rules
            you’ll write down goes on the left hand board in orange.</p>
        <h2 id="inversion-principle-and-sigma-rules">反转原理和 Sigma 规则</h2><h2>Inversion Principle and
            Sigma Rules</h2>
        <p>好的。这就是它的样子。公式化。你将无法在公式中推导，因为它在增长，因为它被打破了。好吗？因为你无法完全表达反转原理——我在这里给出的规则完全表达了现在模糊的规则。因为 sigma 规则是完全表达的；它们反转了介绍——这些是介绍规则。这是正确的表达。原因是，为了正确地表达它们，需要一个彻底的举动。你必须改变逻辑的执行方式，以便证明成为理论的对象，然后你就可以正确地制定逻辑。这就是 Brouwer 在 1930 年代所说的：逻辑只是数学的一个分支，而在此之前每个人都说你从原理中推导出数学。是的，你可以，但你——传统的公式化将不是局部健全的。这就是关键所在。</p><p>Okay. And that’s what it will look like. Formulation. You will not be
            able to carry off the derivation in that—in that formula because it’s
            growing, because it’s broken. Okay? Because you cannot fully express the
            inversion principle—the idea that the rules I’ve given here fully
            express the ones that are now obscured. For the sigma rules are fully
            expressed; they invert the introductory—these are introductory rules.
            That is the proper expression. And the reason is, in order to express
            them properly, requires a radical move. You have to change the way in
            which logic is done so that the proofs become objects of the theory, and
            then you can formulate logic properly. This is what Brouwer was saying
            back in the 1930s: that logic is just a branch of mathematics, whereas
            everyone up to that point was saying you derive mathematics from the
            principles. Yes, you will be able to, but you—the conventional
            formulation will not be locally sound. That’s the point.</p>
        <h1 id="type-theory-foundations-4.0-robert-harper">类型理论基础 4.0 — Robert Harper</h1><h1>Type Theory
            Foundations 4.0 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 3 日) — 37:14 <a href="https://youtube.com/watch?v=eJxuTboJ0rM">https://youtube.com/watch?v=eJxuTboJ0rM</a></p><p> 11
            years ago (Jan 3, 2014) — 37:14 <a href="https://youtube.com/watch?v=eJxuTboJ0rM">https://youtube.com/watch?v=eJxuTboJ0rM</a></p>
        <h2 id="summary-8">概括</h2><h2>Summary</h2>
        <p>讲师 Robert Harper 将代替另一位讲师。第 2 讲将讨论序列演算，从推理到类型理论中的逻辑连接词。该讲座将探讨依赖类型理论的基础，包括依赖和、依赖积和身份类型，它们被视为空间中的路径。将强调命题作为类型的原则和证明相关性。该讲座还将涉及类型的等价性和单价公理，它将等价类型等同起来。</p><p>The lecturer, Robert Harper, will be substituting for another
            lecturer. Lecture 2 will discuss sequent calculus, moving from inference
            to logical connectives in type theory. The lecture will explore the
            foundations of dependent type theory, including dependent sums,
            dependent products, and identity types, which are viewed as paths in a
            space. The propositions-as-types principle and proof relevance will be
            emphasized. The lecture will also touch on equivalences of types and the
            univalence axiom, which equates equivalent types.</p>
        <p>我当时也在场。昨天骑自行车有点不顺。看来鲍勃可能睡过头了，这意味着我们只能交换两个讲座的时间了。</p><p>And I was on it. The bike ride yesterday was a little bit rough. It
            seems like Bob might have overslept, which means that we’ll just swap
            our two lectures.</p>
        <h2 id="lecture-swap-and-preparation">课程交换和准备</h2><h2>Lecture Swap and Preparation</h2>
        <p>所以我现在就去，鲍勃今天下午就去。因为我还没有准备讲座，这意味着我需要你们比平时更多的帮助。所以我们会在进行过程中解决这个问题。</p><p>So I’ll go now, and Bob will go this afternoon. So, because I didn’t
            prepare the lecture yet, it means I need even more help than usual from
            you guys. So we’ll figure this out as we go along.</p>
        <h2 id="sequent-calculus-introduction">序贯微积分简介</h2><h2>Sequent Calculus
            Introduction</h2>
        <p>那么，我要讲什么呢？第二讲是序列演算，如果你愿意的话，有一个副标题，就是在这堂课中，我们实际上将从推理的概念转到逻辑连接词。所以，从推理到逻辑连接词。这其中有趣的一点是，如果你知道我们在证明论和类型论中用来定义逻辑的技术，我们实际思考写下连接词含义的方式等等，那么线性逻辑中的一切都从我们在上一讲中学到的这个非常简单的种子开始。</p><p>So, what I’m going to talk about? Lecture 2 is sequent calculus, and
            there’s a subtitle, if you will, which is that in this lecture we’ll
            actually go from this notion of inference to logical connectives. So,
            from inference to logical connectives. And an interesting aspect of this
            is that if you know the techniques that we use in proof theory and type
            theory in order to define logics, the way we actually think about
            writing down the meaning of the connectives and so on, then everything
            in linear logic just starts from this very simple seed that we had in
            the last lecture.</p>
        <h2 id="linear-logic-and-simple-seed">线性逻辑和简单种子</h2><h2>Linear Logic and Simple Seed</h2>
        <p>好的。</p><p>Okay.</p>
        <p>所以，从现在开始，基本上没有那么多的灵活性。你没有那么多余地来定义事物。好的。所以，你只能说，你只需遵循我们知道如何遵循的策略。</p><p>So, from now on, basically, there isn’t that much flexibility. You
            don’t have that much leeway into how you go about defining things. Okay.
            So, you just say, you just follow the strategy that we know how to
            follow.</p>
        <p>是的，但你想交换我们的两个讲座吗？或者……好的，当然。好的。所以，这是一个预览。好的。两点钟，我会告诉你这件事。</p><p>Yeah, but do you want to swap our two lectures? Or… okay, sure. Okay.
            So, this was a preview. Okay. At two o’clock, I’ll tell you about
            this.</p>
        <p>哦，现在来谈谈完全不同的事情。好的。感谢收看。抱歉，我迟到了。哦，我需要放……好的。</p><p>Oh, so now for something completely different. All right. Thanks for
            tuning in. Sorry, I’m late. Oh, I need to put… okay.</p>
        <h2 id="dependent-type-theory-ingredients">依赖类型理论成分</h2><h2>Dependent Type Theory
            Ingredients</h2>
        <p>好的。抱歉，切换上下文。我们上次讨论的是，现在我们开始获得一些真正的关注，因为我们已经引入了依赖类型理论的基本要素或独特要素，也就是我们讨论过的广义或依赖和。您可以解决这个问题，我们可以将其称为依赖……依赖乘积更为典型。我们开始讨论身份类型，它的写法如下。这是身份，或者您可以将其解释为相等，或者正如我将很快解释的那样，它是一种抽象类型，即空间中的路径。</p><p>All right. So, or sorry, switching context. So, where we were last
            time is we had started to get now some real traction because we have
            introduced the essential ingredients, or distinctive ingredients, of
            dependent type theory, which is the, as we talked about, the generalized
            or the dependent sum. You could solve this, and we can call this a
            dependent… the dependent product is more typical. And we began to talk
            about the identity type, which is written like this. And this is
            identity, or you could explain it as equality, or as I will explain
            shortly, it’s sort of an abstract type of what are called paths in a
            space.</p>
        <p>因此，我上次提到的有趣的事情，我认为很重要的一点是，我们倾向于同时拥有两者——我，由于缺乏更好的方式来描述它，我们倾向于同时拥有一个命题，也许我不知道我该说些什么......</p><p>And so, the interesting thing about it that I was mentioning last
            time that I think is important is that we tend to have both—I, for lack
            of a better way of describing it, we tend to have both a propositional
            and maybe I don’t know what should I say…</p>
        <h2 id="propositions-as-types-and-proofs">命题的类型和证明</h2><h2>Propositions as Types and
            Proofs</h2>
        <p>典型的态度……对这种类型、身份类型的态度。除非你恰好是经历过类型理论的人，否则这对你来说似乎很陌生。但我会说——我是在向那些没有经历过的人讲话——所以我要说这会让人感觉有点奇怪。我今天所说的一切都将是技术上微妙的，我可能会搞砸，但我会尽量避免。除了技术细节之外，我只希望它能呈现出与你们许多人习惯的不同的逻辑和证明视角。</p><p>typical attitude… attitude toward this type, the identity type. And
            this is going to seem unfamiliar to you unless you happen to be somebody
            who’s experiencing type theory. But this will—I’m addressing people who
            aren’t—so I’m going to say that this is going to feel a little odd.
            Everything I say today is going to be technically delicate, and I’m
            probably going to screw it up, but I will try not to. And I, beyond the
            technical details, hope only that it will present a different
            perspective on logic and proof than many of you are used to.</p>
        <h2 id="conventional-vs.-type-theoretic-equality">传统平等与类型理论平等</h2><h2>Conventional
            vs.&nbsp;Type-Theoretic Equality</h2>
        <p>就符号而言，因为我们经常将其视为一种类型（实际上，从技术上讲，是一类类型），但也将其视为一个命题，所以我们有另一种符号：等号上有一个“a”，有时甚至不写“a”，或者可能在这里写上“a”以强调其位置。所以，我们经常会写这种符号。</p><p>As a matter of notation, because we’ve so often taken an attitude
            toward this as a type (a family of types, actually, technically), but
            also as a proposition, we have another notation: the equal sign with an
            ‘a’ here, or sometimes not even writing the ‘a’ or possibly writing it
            over here to emphasize its position. So, we’ll frequently write this
            notation.</p>
        <p>现在，这就是让您感到困惑的地方，因为您——它——我要说的实际上是一种有效的表示。它是平等原则的有效表示。它是一种平等的概念，但这种平等的概念非常关键地利用了证明相关性的概念。因为我们将把它看作我之前和您讨论过的那种标识类型。所以，我们可以把它看作标识的类型，或者，正如我将很快解释的那样，空间中的路径的概念，对吗？类型中的标识或路径或类型中的空间。好的，这就是我们要考虑这个问题的方式。</p><p>Now, this is what is going to confuse you, because you’re—it—what I’m
            going to say is, in fact, a valid representation. It is a valid
            representation of a principle of equality. It is a notion of equality,
            but it’s a notion of equality which exploits very critically the notion
            of proof relevance. Because we’re going to think of this as the type of
            identifications I talked to you about before. So, we can think of this
            as the type of identifications, or, as I will shortly explain, the idea
            of paths in a space, right? Identifications or paths in a type or a
            space in a type. Okay, that’s the way we’re going to think about
            this.</p>
        <p>因此，它是某种类型的类型，换句话说，是类型“a”中的类型。因此，根据命题作为类型原则，如果存在“a”和“b”的标识，那么我们会说“a”和“b”相等。这就是想法。因此，“a”=“b”将为真，或者当存在标识时，我们只会说“a”等于“b”。因此，这与我们关于命题作为类型的所有其他内容保持一致。居住表达了这种真理观念。</p><p>So, it’s a type in some type, in other words, in the type ‘a’. So, by
            the propositions as types principle, if there exists an identification
            of ‘a’ and ‘b’, then we will say ‘a’ and ‘b’ are equal. And that’s the
            idea. So, ‘a’ = ‘b’ will be true, or we will just say ‘a’ is equal to
            ‘b’ when there exists an identification. So, that’s in keeping with
            everything else we have said about propositions as types. The
            inhabitation expresses this idea of truth.</p>
        <p>然而，在进行与证明相关的数学时，命题对其证明进行分类，那么命题证明的结构就成为讨论的主题。因此，我们不会像往常一样讨论某种类型是否可证明，命题是否可证明，是否有证明，是否真实，而是会讨论该命题的证明空间的结构。因此，我们将拥有比我们习惯的更精细的概念。</p><p>However, in the setting where you’re doing proof relevant
            mathematics, where the propositions classify their proofs, then the
            structure of the proofs of a proposition becomes a topic of discourse.
            So, rather than, as usual, speaking about whether a type is provable, or
            a proposition is provable, or has a proof, or is true, we will also talk
            about the structure of the space of proofs of that proposition. So,
            we’ll have a much more highly refined notion than what we’re used
            to.</p>
        <p>具体来说，我们会发现，与其证明某些事情，不如像通常那样，人们可能会说，好吧，所以我要在这里写一些示意图，而不是具体的例子。我们最终可能会说，嗯，一个陈述，比如，你知道，某种“a”等于“b”当且仅当，“c”等于“d”，或者类似的东西。这种事情可能会经常出现。</p><p>In particular, we will find that rather than prove things—so, like a
            usual sort of set kind of fact that one might do is might end up saying,
            well, so I’m going to write something schematic here, rather than a
            specific example. We might end up saying, well, a statement like, you
            know, some sort of ‘a’ is equal to ‘b’ if and only if, you know, ‘c’ is
            equal to ‘d’, or something like this. This kind of thing could come up a
            lot.</p>
        <p>“所以我就把它写成‘a’，我想做个区分。在传统数学中，我们经常考虑这些是否是命题。”当我们想说这两个命题是等价的，我们会说 a 当且仅当 b。所以，事实上，我没有理由坚持它们是等式。所以，在典型情况下，我们通常会证明 a 当且仅当 b。好吧，这是很常见的，或者 a 意味着 b，或者 b 意味着 a，随便什么。</p><p>“So I’ll just put that as ‘a’ and I want to draw a distinction. In
            conventional mathematics, we often think about whether these are
            propositions.” When we want to say the two propositions are equivalent,
            we say a if and only if b. So, as a matter of fact, there’s no reason
            for me to insist on these being equations. So, in a typical situation,
            we’ll often prove a if and only if b. All right, that’s a very common,
            or a implies b, or b implies a, whatever.</p>
        <p>但我仅以此为例，因为我想将其与平等联系起来。很多时候，定理被表述为：两个命题是等价的。</p><p>But let me just take that as an example because I want to connect it
            with equality. So, a lot of times, a theorem is stated as something: two
            propositions are equivalent.</p>
        <h2 id="equivalence-of-types">类型等价性</h2><h2>Equivalence of Types</h2>
        <p>没问题。如果我们将其呈现为命题类型，那么这意味着在任一方向上都有映射。好吗？也就是说，存在一个 f，它将任何 a 的证明转换为 b 的证明，并且存在 ag，它将 b 的证明转换为 a 的证明。所以，这就是它的意思。所以，当你在传统环境中说当且仅当时，当你将其通过过程类型转换为类型理论中的命题时，这意味着在任一方向上都有映射。</p><p>That’s fine. If we render this as propositions as types, what this is
            saying is that there are maps in either direction. Okay? Which is to say
            there exists an f which transforms any proof of a into a proof of b, and
            there exists a g which transforms the proof of b into a proof of a. So,
            that’s what that means. So, when you say if and only if in a
            conventional setting, when you transpose that into proposition by
            process types into type theory, it means there are maps in either
            direction.</p>
        <p>但这是一个相对较弱的想法，因为我们实际上可以做得更好。因此，现代观点，同伦类型理论观点或类型理论观点，就是说，只要有可能，而且通常是可能的，我们感兴趣的不仅仅是这里的所有内容是否可以映射到这里的某个东西或向后映射，还在于 a 的证明结构与 b 的证明结构之间的关系性质。</p><p>But that is a relatively weak idea because we can actually do better.
            So, the sort of modern, sort of view, the homotopy type theory view, or
            the type theoretic view, is to say, well, wherever possible, and
            frequently it is possible, we’re interested not merely in whether
            everything here could be mapped to something in here or back, but in the
            nature of the relationship of the structure of the proofs of a to the
            structure of the proofs of b.</p>
        <h2 id="homotopy-type-theory-view">同伦类型理论观点</h2><h2>Homotopy Type Theory View</h2>
        <p>我们经常会说，我们将证明 a 和 b 是等价的。所以，这被称为类型等价。我们需要花一点时间来解释什么是等价，但这个想法是，你可以把它看作是同构到同构。这就像一句口号。所以，这个想法就是我们最终会到达的地方，我会到达那里。</p><p>And what we’ll often end up saying is we will be proving that a and b
            are an equivalent. So, this is called an equivalence of types. And it
            will take us a little bit to explain what an equivalence is, but the
            idea will be you can think of it as an isomorphism up to isomorphism.
            That is like a little kind of slogan. So, the idea will be that where
            we’re going to get to eventually, and I will, I will get there.</p>
        <p>我们最终会到达那里，我们将有来回的映射。好吗？所以，我们将有这个条件。让我不只是把它写出来，而且，我们有理由相信它们在以下意义上是彼此的逆。我们将写出恒等式和 g，某个 g 的恒等式。好吗？其中相等是……之间的相等，好吧，你必须研究一下相等的类型应该是什么，才能使这些相等有意义。</p><p>We’ll get there eventually, is that we’re going to have maps back and
            forth. Okay? So, we’ll have this condition. Let me not just write it
            out, but moreover, we will have reason to believe that these are
            inverses to one another in the following sense. We will write the
            identity and g, the identity for some g. Okay? Where the equality is an
            equality between… well, you have to look at work out what the type
            should be for the equal for these equalities to make sense.</p>
        <p>好吗？这就是我们的想法。我们将要提出的是，不仅存在来回的证明，而且这些证明是相互逆的，从而产生类型等价的概念。这就是我们要发展的核心思想之一。同伦类型理论中的某些定理甚至某些公理被表述为类型之间的等价，这比双条件更强，好吗。这就是——我只是想给你一个预示，让我们稍微了解一下我们将要做的事情。所以这很常见。</p><p>Okay? This will be the idea. There will be an idea that not only are
            there proofs back and forth, but these proofs are mutually inverse,
            inducing a notion of type equivalence. So that’s one of the central
            ideas that we’re going to be developing. And certain theorems and even
            certain axioms in homotopy type theory are stated as, are expressed as
            equivalences between types, which are stronger than biconditionals,
            okay. So that’s the—I just want to give you a flavor to foreshadow a
            little bit like the kind of thing we’re going to be doing. And so this
            is very common.</p>
        <p>现在，另一件将要发生的事情是，我们最终将讨论等价和相等之间的关系。我只是为了提起这件事，我现在就提一下，这样你就能找到方向。我们最终会有一个叫做单价公理的东西，它说，对于一个宇宙，如果 a 和 b 在宇宙中是等价的，你会说，至少当且仅当 a 和 b 在那个宇宙中是相等的。</p><p>Now, another thing that will happen is we are going to eventually
            talk about what is the relationship between an equivalence and equality
            in general. And I’ll just, for the sake of, just for the sake of
            bringing it up, I will mention it right now just so you can kind of get
            your bearings. We will eventually have something called the univalence
            axiom, which says that with respect to a universe, if a and b are
            equivalent in a universe, you would kind of like to say, well, at least
            if and only if a and b are equal in that universe.</p>
        <h2 id="univalence-axiom">单价公理</h2><h2>Univalence Axiom</h2>
        <p>因此，相等类型就是我在这里概述的意义上等价的类型——不是很精确，但我会更精确。但实际上它比这更强。单价公理不仅这么说，而且它还说，事实上，这些事物之间存在等价性，好吧。所以等价空间——这就是你看到的类型。有趣的是，这将是一个大类型，因为这些事物等价意味着什么？</p><p>So equal types are ones which are equivalent in the sense that I’m
            sketching here—not very precisely, but I will make more precise. But
            it’s actually even stronger than that. The univalence axiom not only
            says that, but it says, in fact, there’s an equivalence between these
            things, okay. So that the space of equivalences—this is the types you
            see. The interesting thing is this is going to be a big type, because
            what does it mean for these things to be equivalent?</p>
        <p>嗯，这是一个 sigma 类型，表示这里有一个 f，这里有一个 ag，还有一些附加数据，稍后我会再谈到。所以它是一种类型。你会看到像“a 和 b 是等价的”这样的陈述是一种类型，因为我们有命题作为类型。所以它是一个特定形式的空间，我们想将它与某种特定形式的其他空间联系起来，也就是——嗯，最终会成为宇宙中的路径，或者宇宙中的标识，或者它们相等的证明，等等。我之所以做铺垫，是因为我使用了很多我还没有完全开发的想法，但我觉得说，这就是我要去的地方，会很好。所以会有一些关于这个的想法，这是同伦类型理论的一个特征，是 Voevodsky 提出的这个公理，说我们应该把等价类型视为相等，好吧。</p><p>Well, it’s a sigma type that says there’s an f here and there’s a g
            here and some additional data, which I will get back to later. So it’s a
            type. You see statements like “a and b are equivalent” is a type,
            because we have propositions as types. So it’s a space of a certain
            form, and we want to relate it to some other space of a certain form,
            namely the space of—well, what will turn out to be paths in the universe
            or are identifications in the universe or proofs of their equality, sort
            of. I’m foreshadowing because I’m using a lot of ideas that I haven’t
            fully developed yet, but I thought it would be kind of nice to say, you
            know, this is this is where I’m heading. So there’s going to be some
            ideas about this, and this is a characteristic feature, okay, of
            homotopy type theory, is this axiom that Voevodsky proposed, saying that
            we should take equivalent types to be equal, okay.</p>
        <p>在你理解这句话的意思之前，我现在必须先阐述一下身份类型是什么，然后我们再来谈谈一个更好的方法，这样你就能更好地理解这里所说的内容。但我觉得最好还是告诉你我要讲什么。</p><p>Before you can grasp the meaning of that, I really now have to
            develop the idea of what is the identity type, and then we’ll come back
            to a better—a better way of you’ll be able to appreciate what is being
            said here a little bit more. But I thought it might be nice just to tell
            you where I’m going.</p>
        <h2 id="identity-type-and-its-properties">身份类型及其属性</h2><h2>Identity Type and its
            Properties</h2>
        <p>现在，我将开始讨论身份类型，但在此之前，我想先在你们的脑海中勾勒出一幅画面。好吗？我要勾勒出一幅画面。这样可以吗？每个人都明白了吗？我要在你们的脑海中勾勒出一幅画面，这在稍后会有所帮助。所以现在就把这幅画面植入脑海会很好。我想看一下我们称之为的（你们也可以称之为）类型系列的两种观点。</p><p>So, I’m going to start talking about identity types, but before I do,
            I want to fix a picture in your mind. Okay? I’m going to fix a picture.
            Is this okay? Everyone got this? I’m going to fix a picture in your
            mind, which will be helpful in a little while. So it’ll be nice to plant
            the picture right now. I want to look at, sort of, what we’ll call
            the—what you might call—two views of what is a family of types.</p>
        <p>好的，我们一直在研究的那个说，类型系列本质上是从某种类型<em>a</em>到宇宙
            <em>u</em>的映射。
        </p><p>Okay, so the one that we’ve been working with says that a family of
            types is essentially a mapping from some type <em>a</em> into a universe
            <em>u</em>.
        </p>
        <h2 id="family-of-types-two-views">类型系列：两种视图</h2><h2>Family of Types: Two Views</h2>
        <p>因为，记住，我们说过给定<em>x</em>在...<em>中</em>，所以，家族——哦，我们把它称为<em>f</em>。好的，所以它——我们可以说
            <em>x</em>的<em>f</em> ——也就是说，<em>f</em>中有一个<em>x——</em>在...什么？我也听不见。哦，好吧，你想让我用什么笔？我有一支看起来不太好的红笔。那是一支红笔。那是一支绿色的笔。你想让我做什么？好的，它是绿色的。
        <em></em><em></em><em></em></p><p>Because, remember, we said given <em>x</em> in <em>a</em>… so,
            family—oh, let’s call that <em>f</em>. Okay, so it—we can say that
            <em>f</em> of <em>x</em>—that is, <em>f</em> has an <em>x</em> in it—is
            at… What? I can’t hear you too. Oh, well, what pen do you want me to
            use? I have a red pen that doesn’t look too good. That’s a red pen.
            That’s a green pen. What do you want me to do? All right, it’s
            green.
        </p>
        <p>好的，所以我们有两个家庭视图。让我们看看这是否有帮助。这是否更具可读性？好的，就像这样。这只是，你知道，我正在使用函数空间。有点，你知道，你可以这样写。</p><p>Okay, so we have two views of a family. Let’s see if this helps. Is
            this more readable? Okay, like this. Which is just, you know, I’m using
            the function space. It’s a little, you know, you can write it like
            that.</p>
        <p>因此，我们在开始时说，一个家族是一种类型。因此，我们将类型呈现为宇宙<em>u</em>的成员，由一个范围覆盖其他类型的变量参数化。因此，它是一个
            <em>索引</em>类型的家族，或者实际上是一个<em>索引的</em><em>u</em>成员家族，我们将其视为类型。
        </p><p>So what we said in the beginning is that a family is a type. So
            we—we’re rendering a type as being a member of the universe <em>u</em>,
            parameterized by a variable ranging over some other type. So it’s an
            <em>a</em> indexed family of types, or really an <em>a</em> indexed
            family of members of <em>u</em>, which we’re going to consider to be
            types.
        </p>
        <p>因此，我们可以将视图视为一个家族。我们可以将家族视为这样的函数或映射。因此，它导致了以下类型的图。好的。图是：这里有<em>一个</em>，
             <em>a</em>中有一些点。我们将它们称为<em>a1</em>和
            <em>a2</em>。好的。只需挑选两个感兴趣的点。当然，它可能甚至没有任何点，但我们只需在其中放入几个点即可。
        </p><p>So we can think of a view as a family. We can view a family as such a
            function or a mapping like this. So it leads to the following kind of
            picture. All right. The picture is: you’ve got <em>a</em> here, and
            <em>a</em> has got some points in it. Let’s call them <em>a1</em> and
            <em>a2</em>. All right. Just to pick out two that would be of interest.
            Of course, it might not even have any, but let’s just put a couple of
            points in there.
        </p>
        <p>然后，您会看到这样的画面：<em>a1</em>被发送到它自己的气球，也就是<em>f</em> (a1)，而<em>a2</em>
            被发送到它自己的气球，也就是<em>f</em> (a2)。这也是一种类型，对吧，就是这么写的。好的。所以，当您将一个家族视为一个函数时，您会看到这样的画面。您可以将其视为从一种类型到类型宇宙的函数。这就是为什么宇宙非常重要，因为它为我提供了一种指定范围的方法。我这样做的原因是，它为我提供了一种指定家族范围的方法，以便将其视为一个函数。如果我想将一个家族视为一个函数，我需要它去往某个地方，而这个地方必须是一个类型。所以它要去的地方是一个类型的宇宙，好吗？</p><p>And then the picture you kind of have is that <em>a1</em> gets sent
            to its own balloon, which is sort of <em>f</em>(a1), and <em>a2</em>
            gets sent to its own balloon, which is <em>f</em>(a2). And this is also
            a type, right, written like that. Okay. So that’s the kind of picture
            you have when you are thinking of a family as a function. You can sort
            of think of it as a function from a type into a universe of types. This
            is why a universe is very important, because it gives me a way of
            specifying the range. The reason I did it is it gives me a way to
            specify the range of a family in order to think of it as a function. If
            I want to think of a family as a function, I need it to be going
            somewhere, which has to be a type. And so the place that it’s going is a
            universe of types, okay?</p>
        <p>所以这个想法就是，你可以在这里说这件事。如果我画一个盒子，这就是你必须习惯的思维方式。这些单独的气球，如果你把它们涂黑并缩小，就是<em>U</em>中的点，好吗？对吧？这些单独的气球，
             <em>f(a1)</em>和<em>f(a2)</em>，仅仅是<em>U</em>中的点，好吗？但是当我们放大时，因为<em>U</em>是什么，当我们放大这些点时，它们本身就是其他点的分类器。它们是类型，好吗？这就是我想说的，特别是我在这里向你解释的方式——我想说的，你知道，这可能是你对类型家族的基本直觉。但还有另一种思考方式，好吗，即所谓的家族总空间。
        </p><p>So the idea is that you can say this business here. If I draw a box,
            this is the kind of thinking you’re going to have to get used to. These
            individual balloons, if you just black them out and shrink them down,
            are points in <em>U</em>, okay? Right? Those individual balloons,
            <em>f(a1)</em> and <em>f(a2)</em>, are merely points in <em>U</em>,
            okay? But when we zoom in, because of what <em>U</em> is, when we zoom
            in on those points, they are themselves classifiers, okay, of other
            points. They are types, okay? So that’s—this is what I would say,
            particularly the way I’ve—the path I’ve taken here that I’ve explained
            to you—this is what I would say is, you know, probably your basic
            intuition about what is a family of types. But there is another way to
            think about it, okay, which is by something called the total space of
            the family.
        </p>
        <h2 id="total-space-of-a-family">家庭总空间</h2><h2>Total Space of a Family</h2>
        <p>我们可以将这个函数<em>f</em>与一个类型关联起来，“
            在<em>a中存在</em><em>x</em>，<em>f(x)</em> ”。这被称为全空间。你马上就会明白为什么，为什么会这样想，为什么这是正确的术语。
        <em></em><em></em></p><p>We can associate with this function <em>f</em> a type, “exists
            <em>x</em> in <em>a</em>, <em>f(x)</em>.” And this is called the total
            space. And you’ll see why in a second, why think of that as that, why
            that’s the right terminology.
        </p>
        <p>所以，如果你还记得，大西格玛是一个总和，好吗？所以这是所有这些<em>f(a1)</em>和<em>f(a2)</em>以及所有
            <em>f(as)的总和。它是所有</em><em>f(as)</em>的总和，其中
            <em>a 的</em>范围为<em>a</em>。所以我在想的是，我正在形成一个由——你看，<em>U</em>非常大，这里可能有一个气球，它不在
            <em>f</em>的图像中。没有理由认为它以任何方式进入，对吧？
             <em>U</em>是一个类型的宇宙，也许这里是类型
            <em>nat</em>。而且很可能，对于这个特定的<em>f</em>，它不会落在那里。没有办法——我的意思是，它很有可能，对吧？只是这个想法不一定是进入的。但这里发生的事情是，我把所有实际出现的气球粘在一起，形成一个单一的空间。
        </p><p>So, if you remember the big sigma is a sum, okay? So this is the sum
            of all of these <em>f(a1)</em>s and <em>f(a2)</em>s and whatever all the
            <em>f(as)</em>s are. It’s the sum of all of the <em>f(as)</em>s, where
            <em>a</em> ranges over <em>a</em>. So what I’m thinking of is I’m
            forming a type that consists—see, <em>U</em> is pretty big, and there
            might be like a balloon over here that is not in the image of
            <em>f</em>. There’s no reason to think that it’s onto in any way, right?
            <em>U</em> is a universe of types, and maybe here is the type
            <em>nat</em>. And quite possibly, for this particular <em>f</em>, it
            doesn’t land on that. There’s no way—I mean, it could very well be,
            right? It’s just the idea that it’s not necessarily onto. But what’s
            happening here is I’m gluing together all the balloons that actually
            arise and forming a single space.
        </p>
        <p>所以你可以想想这些东西，我要画一张图。这就是所谓的家庭总空间。它配备的东西之一是投影，称为——首先，我们谈到了向下延伸到，称为<em>显示</em>，称为显示图，好吗？它的作用是告诉我们，如果你把这个大数目——比如，你可能会倾向于认为这是一个并集，但它不是一个并集。我不是在合并。所以，正如我昨天对一位学生提到的，有一件事很重要：抛弃你的集合论观点。好吗？你必须摆脱它。好吗？因为它没有帮助。好吗？它只会误导人。所以，这不是一个并集，而是一个——你可以说它是一个不相交的并集，或者真的，正确地说，它是一个总和。这是一个大的总和。</p><p>So you can think of these things, and there’s a picture that I’m
            going to draw. So that’s called the total space of the family. And one
            of the things that this is equipped with is a projection, called—first,
            we talked of that goes down to <em>a</em>, which is called the display,
            called a display map, okay? And what that thing is doing is it’s telling
            us if you take this big sum—like, you might be tempted to think of this
            as a union, but it’s not a union. I’m not unioning up. So, as I
            mentioned to one student yesterday, you know one thing that’s important:
            jettison your set theoretic view of things. Okay? You’ve got to get rid
            of that. Okay? Because it’s not helpful. Okay? It’s only misleading. So,
            this is not a union, but it’s a—you could say it’s a disjoint union, or
            really, properly, it’s a sum. It’s a big sum.</p>
        <p>所以，这个想法是：该类型的元素是什么？我们只需要知道，对吧？该类型的元素是由元素<em>a</em>和 a 组成的对，加上——我们称之为<em>b</em> ——我不知道哪个在<em>f(a)中。请注意， </em><em>b</em>所在的依赖关系
            取决于你所在的子空间。所以，我将拥有这个元素，并且我将拥有这个元素在总空间中。但总空间中的这个元素将被标记为在
            <em>a1</em>中，而总空间中的这个元素将被标记为<em>a2</em>。
        </p><p>So, the idea is that: what are the elements of that type? Just so we
            know, right? The elements of that type are pairs consisting of an
            element <em>a</em> and a, together with—let’s call it <em>b</em>—I don’t
            know which is in <em>f(a)</em>. And notice the dependency where
            <em>b</em> lives depends on which sub and you’re in. So, I will have
            this element, and I will have this element will be in the total space.
            But this element in the total space will be marked as being in
            <em>a1</em>, and this element in the total space will be marked as being
            an <em>a2</em>.
        </p>
        <p>这样我就知道它来自哪里。显示图正在恢复该信息。因为显示图要做的是将其发送到<em>。</em>它会说，“请为我显示索引空间（有时称为家族的基本空间）的哪个元素结束了吗？”所以，我像这样垂直写地图，它导致了下面的图片，我发现它非常有用，我们很快就会发现它很有用。</p><p>So that I know where it came from. And the display map is recovering
            that information. Because what the display map is going to do is send
            that to <em>a</em>. It’s going to say, “Please display for me what
            element of the index space—the base space of the family, is it sometimes
            called?—is it over?” So, I write the map vertically like that, and it
            leads to the following picture, which I find very useful, and we’re
            going to find useful very shortly.</p>
        <p>当我开始更多地谈论相等性时，如果我们考虑总空间——这里写的是我的总空间——那么这就是那个大和，好的，Σ，我写在这里。如果我们将<em>a</em>视为在这里，那么我们首先有这个映射——首先是
            <em>a</em> ——然后，就像我们在这里所做的那样，让我们​​专注于两个，只是为了讨论，<em>a内的两个不同点。所以，我们有</em><em>a</em>的两个不同元素。
        </p><p>And when I start talking more about equality, if we think of the
            total space—this is my total space being written here—so this is that
            big sum, okay, Σ, which I write here. And if we think of <em>a</em> as
            being down here, so that we have this mapping first—first of
            <em>a</em>—and then, just like we had over here, let us focus on two,
            just for the sake of discussion, two different points within <em>a</em>.
            So, we have two different elements of <em>a</em>.
        </p>
        <p>就这么说吧，只是为了讨论，好吗？描述这种情况的方法，描述这里发生的事情的方法，非常非常有助于视觉化，就是把它想象成——把整个空间想象成有垂直段。我的绘画技巧不是最好的，所以让我把<em>a</em>扩大一点，让它看起来更宽一点。所以，我会把
            <em>a2</em>放在这里，我会把<em>a1</em>放在这里。这条线被认为是<em>f(a1)</em>，这条线被认为是<em>f(a2)</em>。
        </p><p>Let’s say, just for the sake of discussion, okay? The way to depict
            this, to depict what is going on here, that is very, very visually
            helpful, is to think of this as—think of the total space as having
            vertical segments. My drawing skills are not the best, so let me let me
            broaden out <em>a</em> and make it look a little wider. So, I will put
            <em>a2</em> here, and I will put <em>a1</em> here. And this line here is
            to be thought of as this is <em>f(a1)</em>, and this line here is to be
            thought of as <em>f(a2)</em>.
        </p>
        <p>因为我们要做的是将这条线上的所有内容都发送到<em>a1</em>；这就是我这样画的原因。这条线上的所有内容都发送到<em>a2</em>。换句话说，我们可以直观地组织整个空间，以便所有标记为 a1 的项目都垂直堆叠，所有标记为 a2 的项目都垂直堆叠。然后，这个想法就是这条线位于 a1 上方。所以，这被称为术语——取决于你是否是英国人，它要么是纤维，要么反过来——在 f 的纤维上，在 a1 上，这是在 a2 上的纤维，好吗？</p><p>Because what we’re doing is we’re saying everything in this line is
            sent down to <em>a1</em>; that’s why I drew it like that. And everything
            in this line is being sent down to <em>a2</em>. In other words, we can
            visually organize the total space so that all items labeled a1 are
            stacked vertically, and all items labeled a2 are stacked vertically.
            Then, the idea is that this line, okay, lives over a1. So, this is
            called the terminology—depending whether you’re British or not, it’s
            either fiber or the other way around—over the fiber of f over a1, and
            this is the fiber over a2, okay?</p>
        <p>这就是想法，好吗？所以，这是我们要回顾的图片。我会经常需要这张图片，但当我有一系列类型时，它在视觉上很有用。一种思考方式是，所有这些东西都被画成一条长线，并像这样垂直书写。这个气球就是写在一条长线上。没有任何几何关系；这只是一种思维方式，一种可视化方式。所以，所有这些事情都是——所有这些都是 a1 的 f 的所有元素，它们都写在彼此之上。这些都是 a2 的 f 的所有 f 元素，它们都写在彼此之上，并且它们具有通过显示图发送到 a1 的特性。所以，首先将我们送到这里，首先将我们送到这里。</p><p>So, that’s the idea, okay? So, this is a picture we’re going to come
            back to. I’m going to need this picture fairly often, but it’s just kind
            of useful visually to say when I have a family of types. One way to
            think about it is all this stuff gets drawn out into a long line and
            it’s written vertically like this. This balloon just is written out in a
            long line. There’s nothing geometric going on; it’s just a way of
            thinking, a way of visualizing it. So, all of this thing gets—all these
            are all the elements of f of a1 written all above each other. These are
            all the f elements of f of a2 written all above each other, and they
            have the characteristic that they’re sent to a1 by the display map. So,
            first sends us down here, and first sends us down here.</p>
        <p>另一种思考方式是，这条线是原像——这有点像 a1 的第一个逆。不管我的意思是什么，好吗？稍后我会解释我的意思。这可以被认为是 a2 的原像；也就是说，它是所有首先发送给 a2 的东西。好吗？也就是说，它是所有首先发送给 a1 的东西，这是总空间中所有首先发送给 a2 的东西，好吗？这是另一种思考方式，好吗？所以，这有点像总空间组织了所有这些逆像，并将它们放在某种很好的组织中，好吗？这是一种思考方式。</p><p>Another way to think about it is that this line is the pre image—this
            is something like first inverse of a1. Whatever I mean by that, okay?
            And I’m going to say in a little while what I mean by that. And this can
            be thought of as the pre image of a2; that is, it’s all the things that
            first sends to a2. Okay? That is, it’s all the things that first sends
            to a1, and this is all the things in the total space that first sends to
            a2, okay? That’s another way of thinking about it, okay? So, it’s sort
            of like the total space organizes all those inverse images and puts them
            in like some nice organization for you, okay? That’s a way of thinking
            about it.</p>
        <p>是的。这两种不同的观点——我没听说过。什么？世嘉？所以，这两种观点，是的，从某种意义上说，你只是在颠倒——哦，你在那里颠倒了。所以，问题是，这两种观点在某种意义上是双重的，这实际上是相当正确的。有趣的是，这里 a 扮演着在域中的角色，而这里 a 扮演的角色是在 co 域中。所以，这是相当正确的，好吗？</p><p>Yes. Those two different views—I didn’t hear that. What? Sega? So,
            those two views, yes, you are in a sense because you’re just reversing
            the—oh, you are reversing there. So, the question was, those two views
            are dual in a sense, and that’s actually quite true. The thing that’s
            kind of funny about it is that here a plays a role as being in the
            domain, and here a, the role that a plays is in the co domain. And so,
            that’s this is quite true, okay?</p>
        <p>你可以在这两种表示之间来回切换，我现在不打算讨论这个问题，但我们经常这样写。当人们这样思考时，他们经常使用不同的术语。他们可能将一个家庭称为“家庭”，将一个振动称为“振动”，因为它会产生纤维。这是对家庭内部发生的事情的“纤维视图”。现在，纤维化有非常重要的一点，我马上就会讲到，这与 a1 和 a2 之间存在认同时的行为有关。</p><p>And you can go back and forth between these two representations, and
            I’m not going to deal with that right now, but it happens a lot that we
            write it like this. When people think this way, they often use different
            terms. They might call a family a “family” and a vibration “a vibration”
            because it creates fibers. This is a “fiber view” of what’s happening
            within the family. Now, there’s something very important about a
            fibration, which I have—I’m going to get to in a minute—which has to do
            with the behavior when there is an identification between a1 and a2.</p>
        <h2 id="fibration-and-path-lifting-property">纤维化和路径提升特性</h2><h2>Fibration and Path Lifting
            Property</h2>
        <p>不管怎样，都会出现一个有趣的问题。好吧，但让我再说一遍——我决定，我昨天在准备演讲时费了很大力气。如果我讲得太技术化，你知道，我会试图在所有技术细节之间找到一条界线，这会让每个人都昏昏欲睡，而且只是胡说八道，我也不想这样做。所以，我想以某种方式找到正确的路径，这样你就能理解主要思想。所以，让我们看看我有多成功。</p><p>In either case, there’s going to be an interesting question that
            comes up. All right, but let me just again—I, I decided, I, I struggled
            mightily yesterday in preparing my lectures. If I get too technical, you
            know, there’s—I’m trying to walk a line between all the technical
            details, which will put everyone to sleep, and being just BS ing, and I
            don’t want to do that either. So, I wanted to somehow find the right,
            the right path here, so you get the main ideas. So, let’s see how
            successful I am.</p>
        <p>因此，本讲座中很快就会出现一个有趣的问题：当 a1 和 a2 之间存在某种等同关系时，当它们被视为相等时，该怎么说？如果你认为它是从 a 到 U 的函数，那么你很可能会预料到这两个气球之间必须存在某种等同关系。而这种等同关系自然会被认为是它们之间的某种等价关系，好吗？我们在这里写的这两个人应该是等价的，对吧？这两个气球——如果 a1 被视为与 a2 相同，我已经将它们等同了——那么与 a1 相关的气球在某种意义上应该与与 a2 相关的气球相同。</p><p>So, there’s going to be an interesting question, which will come up
            very shortly in this lecture: What to say when there is an
            identification between a1 and a2, when those are to be considered equal?
            If you take this view that it’s a function from a into U, you might very
            well anticipate that there must therefore be some sort of identification
            between these two balloons. And that identification would naturally be
            thought of as some kind of an equivalence between them, okay? That these
            two guys that we’ve written here should be equivalent, right? That those
            two balloons—if a1 is to be regarded as the same as a2, I’ve identified
            them—then the balloon associated with a1 should, in some sense, be the
            same as the balloon associated with a2.</p>
        <p>但现在到了重点。U 确实是一种类型，而这些气球，如果你把气球拉远，比如从一万英尺的高度看，它们只是 U 中的点。所以，你可能会说 a1 和 a2 之间的同一性会导致 a1 的点 f 和 a2 的点 f 之间的同一性。这是真的。但重点是这些东西有结构。它们不仅仅是点——没有内部结构的抽象点。它们不是小原子。它们本身有结构。所以，它们被同一性意味着，在某种意义上，它们之间存在等价性——也就是说，存在相互逆向的来回映射，这告诉我们，可以说，一点一点地，这里的一切都与这里的某些东西相对应，好吗？反之亦然，以一种完全系统的方式。</p><p>But now comes the important point. It’s true that U is a type, and
            these balloons, if you just, you know, zoom out far enough, if from ten
            thousand feet, they’re just points in U. So, you might say an
            identification between a1 and a2 induces an identification between the
            point f of a1 and the point f of a2. And that is true. But the point is
            that these things have structure. They’re not just points—abstract
            points that have no internal structure. They’re not somehow little
            atoms. They themselves have structure. So, what it means for them to be
            identified should mean that, in some sense, there’s an equivalence
            between them—that is, there’s mappings that go back and forth that are
            mutually inverse to each other that tell us, point so to say, point by
            point, everything here corresponds to something here, okay? And vice
            versa, in a completely systematic way.</p>
        <p>如果你们当中有人学过范畴论，我所暗示的是范畴等价的概念。范畴等价是同构到同构的同构。好吧。如果你将范畴定义为代数结构，类似于群或幺半群，你自然会考虑它们之间的同态。这些同态被称为函子。然后，我们说可逆的同态被称为同构。这个概念在范畴论中不是很有用。原因是范畴在某种程度上不仅仅是一个点。我们没有分析它本身的结构。所以，我们想要做的是，我们想要弱化这两个气球相等的概念，通过说相等应该是等价来解释这种结构。</p><p>If any of you have ever studied category theory, what I’m hinting at
            is the notion of an equivalence of a category. Equivalence of categories
            is an isomorphism up to isomorphism. Okay. If you define a category as
            an algebraic structure, something similar to a group or monoid, you’d
            naturally consider homomorphisms between them. These homomorphisms are
            called functors. Then, we say homomorphisms that are invertible would be
            called isomorphisms. That notion is not very useful in category theory.
            The reason is because the category is not, somehow, just a point thing.
            That we’re not analyzing it itself has structure. So, what we want to do
            is we want to weaken the notion of when these two balloons are equal to
            account for that structure by saying that that equality should be an
            equivalence.</p>
        <p>因此，在范畴论中，范畴的同构之间存在区别，据我所知，这很少有用。也许有些专家知道，但在我看来，这很少有用。极其经常有用的是范畴等价的概念，即同构到同构。所以，我们稍后再讨论这个问题。好的。</p><p>So, in category theory, there’s a distinction between an isomorphism
            of categories, which is rarely useful, as far as I know. Maybe some
            experts know, but it seems to me rarely useful. The thing that is
            extremely often useful is a notion of an equivalence of categories,
            which is an isomorphism up to isomorphism. So, we will get back to that
            in a minute. Okay.</p>
        <p>如果这是我们要得到的那种图像，那么类似的事情也必须发生。类似的事情也必须发生在这一侧。好的。必须有某种方式来表达，如果我将家庭视为一种振动，那么我就有一个投影，一个从总空间到基空间的显示图，如果 a1 和 a2 这些元素之间存在某种标识，那么应该存在某种提升属性。好的。这将标识提升到这里。</p><p>A similar thing has to happen if this is the kind of picture we’re
            going to have here. A similar thing has to happen on this side. Okay.
            There has to be some way of saying that if I think of the family as a
            vibration, so I have a projection, a display map from the total space to
            the base space, and if there is some kind of identification between
            these elements of a1 and a2, then there should be some kind of lifting
            property. Okay. That lifts the identification here up to here.</p>
        <p>所以，让我删除一些小注释，给自己留出一些空间。好的。好的。</p><p>So, let me erase the little annotations to make some room for myself.
            Okay. All right.</p>
        <p>所以，请记住，纤维，这些穿过整个空间的垂直切片，这些纤维应该被认为是由 f(a1) 的点和 f(a2) 的点组成的。它们都排在那里。好的。这就是思考的方式，对吧？</p><p>So, remember that the fibers, these vertical slices through the
            through the through the total space, those fibers are to be thought of
            as consisting of the points of f(a1) and the points of f(a2). They’re
            all lined up there. Okay. That’s the way to think about it, right?</p>
        <p>所以，你可能会想到类似这样的东西。如果 a1 等同于 a2，我想要做的就是，我想要采取这个东西，我最终会称之为路径 b，我想要将这条路径提升到纤维中，这样这里的一切都会以一种很好的系统、可逆的方式与这里的一切相对应。好的。这就是我要说的。这被称为路径提升属性。</p><p>So, you might think something like this. If a1 is identified with a2,
            what I want to do is I want to take this thing, which I will eventually
            call a path b, and I want to lift that path up to the fibers in such a
            way that everything over here somehow corresponds to everything over
            here in a nice systematic, invertible way. Okay. That’s what I’m going
            to get at. And this is called the path lifting property.</p>
        <p>事实上，在公理处理中，比如同伦理论，振动的定义是满足纤维路径提升性质的映射。这就是它完成的方式。好的。我从类型理论的角度来激励它。所以，这就是正在发生的事情。所以，应该有一些关联，通常称为 p 下星，它以某种方式说明了这里和那里发生的事情。现在，它将如何运作，我们将……我将向您展示它将如何运作。这幅图中会有一些微妙之处，但让我们记住这一点，作为正在发生的事情的动机，好吗？</p><p>And, in fact, in axiomatic treatments, like of homotopy theory, the
            definition of a vibration is a map that satisfies this fiber path
            lifting property. That’s just the way it’s done. Okay. I’m motivating it
            here from the point of view of type theory. So, this is what’s
            happening. So, there should be some correlate, which is usually called p
            lower star, which somehow says something about what happens over here
            and over here. Now, the way that’s going to work, we’re going to… I’m
            going to show you how this will work. There will be some subtleties in
            this picture, but let’s keep that in mind as motivation for what’s
            happening, okay?</p>
        <h2 id="motivation-and-overview">动机和概述</h2><h2>Motivation and Overview</h2>
        <p>所以我们很快就会讲到所有细节，好的。这些图片很适合印在你的脑海里，因为它会帮助我激励自己想做的事情。好的。</p><p>So we’ll get to all the details very shortly, okay. These pictures
            are good to fix in your mind because it’ll help me motivate what I want
            to do. All right.</p>
        <p>所以现在，让我们让它安定下来。我想把它种下，好的，足够早，好的。这样当我稍后回来时，你会说，“哦，是的，我认识到了这一点。”所以这很好。</p><p>So now, let’s just let that settle. I wanted to sort of plant it,
            okay, early enough, okay. So then when I come back to it later, you’ll
            say, “Oh, yes, I recognize that.” So that’s good.</p>
        <p>顺便说一句，我应该说，一价公理的作用就是说，把它们看作被识别的点，就等于说，把它们看作气球，它们就是等价的。这就是一价公理的思想，好吧。所以，我们要说的是宇宙中识别的本质，好吧。</p><p>And by the way, the role of the univalence axiom—I should have
            said—is exactly to say that thinking of these as points being identified
            is exactly the same as saying that, thought of as balloons, they’re
            equivalent. That’s the idea of the univalent axiom, okay. So it’s the
            nature of identifications in a universe that’s what we’re going to get
            at, okay.</p>
        <p>啊，好的，就是这样。这就是我们要去的地方。所以让我们——这是下一组技术细节的重大概述。现在，我必须做一些更涉及技术的工作。</p><p>Ah, there it is, okay. So that’s like where we’re heading. So
            let’s—that’s like the big, big overview of the next set of technical
            details. Now, I have to do some more technically involved work.</p>
        <p>现在让我们回过头来考虑身份类型的本质。</p><p>So let’s go back now to considering the nature of the identity
            type.</p>
        <h2 id="extensional-identity">外延身份</h2><h2>Extensional Identity</h2>
        <p>正如我所提到的，从历史上看，关于身份类型的概念有两种。一种是所谓的外延身份，好吧，它……</p><p>As I mentioned, historically, there have been two notions of what to
            do about the identity type. There’s the so called extensional identity,
            okay, which has…</p>
        <p>因此，它们之间的共同点是，类型理论，无论你如何看待它，它们都具有这样的原则：如果<em>a</em>属于<em>A</em>，那么<em>A在</em><em>a</em>处的反身性就是<em>a</em>与其自身的同一性
            。或者，就像我很快会开始写的那样，我会说<em>a = a</em>。你必须习惯于你倾向于持有根深蒂固的命题态度的东西。你必须始终记住，在类型理论中，任何你持有命题态度的东西实际上都是对某些术语进行分类的类型。这是你必须克服的主要障碍，好吗？因为这就是类型理论观点的独特之处——正如我所说，我想我是在针对你们大多数人。
        </p><p>So what they share—the type theories, regardless of how you look at
            it—they share the principle that if <em>a</em> is in <em>A</em>, then
            reflexivity in <em>A</em> at <em>a</em> is an identification between
            <em>a</em> and itself. Or, as I will very soon start writing, I’ll just
            say <em>a = a</em>. You’re going to have to get used to something to
            which you tend to have a very deeply baked in propositional attitude.
            You must always remember that in type theory, anything toward which you
            have the attitude of a proposition is really a type that classifies some
            terms. That’s the main hump you’ve got to get over, okay? Because that’s
            the thing—as I say, I’m addressing I think the majority of you—that’s
            the thing that is distinctive about the type theoretic view.
        </p>
        <p>好了，平等。你会被绊倒，因为你将开始像你一生中一直做的那样思考这个问题。这是对平等的概括。这是思考平等的最好方式——概括。所以这是平等的介绍，好吧。</p><p>So, alright, equality. And you’re going to get tripped up because
            you’re going to start thinking of this like you’ve always done in your
            whole life. And it’s a generalization of that. That’s the best way to
            think about it—the generalization. So this is the equality introduction,
            okay.</p>
        <p>因此，我们将分享将有其他形式的相等性引入。不幸的是，我把它删掉了。像单价公理将是另一种形式的相等性引入。所以这是反身性的一个相等性引入。所以所有的类型理论都同意，在身份认同中，一个可以有反身性。我们都同意它会存在。</p><p>So we’re going to share that there’s going to be other forms of
            equality introduction. I unfortunately erased it. Like the univalence
            axiom will be another form of equality introduction. So this is the one
            equality introduction for reflexivity. So all the type theories agree
            that amongst the identifications, one could have reflexivity. We all
            agree it’s going to exist.</p>
        <h1 id="type-theory-foundations-4.1-robert-harper">类型理论基础 4.1 — Robert Harper</h1><h1>Type Theory
            Foundations 4.1 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 3 日) — 37:02 <a href="https://youtube.com/watch?v=jy428DF5BEU">https://youtube.com/watch?v=jy428DF5BEU</a></p><p> 11
            years ago (Jan 3, 2014) — 37:02 <a href="https://youtube.com/watch?v=jy428DF5BEU">https://youtube.com/watch?v=jy428DF5BEU</a></p>
        <h2 id="summary-9">概括</h2><h2>Summary</h2>
        <p>本视频讨论了类型理论中的意向身份类型。它将其与外延身份进行了对比，强调意向身份将身份视为数据，而不仅仅是命题。该视频介绍了一种新的消除规则，称为路径归纳，用于推理身份类型。该规则基于反身性，视频解释了如何使用它来证明关于相等的属性。演讲者罗伯特·哈珀强调了这种方法对于理解相等类型的重要性。</p><p>This video discusses intentional identity types in type theory. It
            contrasts this with extensional identity, emphasizing that intentional
            identity treats identity as data, not just a proposition. The video
            introduces a new elimination rule, called path induction, for reasoning
            about identity types. This rule is based on reflexivity, and the video
            explains how it’s used to prove properties about equality. The speaker,
            Robert Harper, highlights the importance of this approach for
            understanding equality as a type.</p>
        <h2 id="extensional-identity-1">外延身份</h2><h2>Extensional Identity</h2>
        <p>现在有一个问题，除了外延恒等式类型之外，还应该存在哪些其他恒等式，正如我们上次提到的那样。我们所做的是，我们说——好吧，只是提醒你——我们说如果我们有任何证据<em>p</em>证明<em>a</em>等于<em>b</em>，那么我们就说<em>a</em>在<em>a</em>中等于<em>b</em>。所以，这是外延形式的相等消元法。好的。它可以这样写。所以，我们上次谈到了这一点，它有许多重要的、非常有用的实际好处，因为它说如果你能向我证明这两件事是相等的，那么从这个意义上讲，它们就是相等的。<em></em></p><p>And now there’s a question about what other identifications ought to
            exist, but with the extensional identity type, as we mentioned last
            time. What we do is, we say—well, just to remind you—we say if we have
            any proof <em>p</em> that <em>a</em> is equal to <em>b</em>, then we
            just say that <em>a</em> is equal to <em>b</em> in <em>a</em>. So, this
            is the equality elimination in the extensional form. Okay. It could be
            written like that. So, we talked about this last time, and it has a
            number of practical benefits that are important, that are very useful,
            because it says if you can prove to me the two things are equal, then
            they’re equal in this sense.</p>
        <p>它阻止我们做任何——我们不能再将判断相等视为定义性的。这不仅仅是计算
            <em>a</em>和<em>b</em>来计算同一个东西的问题。这是语义问题。这与证明有关。我们必须这样做，但我们可以这样做。然后，我给你布置了一个练习，你可以用这条规则来证明，例如，由此得出——我记得，我想我这样做了——λx. x =ℕ→ℕ λx. zero + x。
        </p><p>It prevents us from any—we can no longer think of the judgmental
            equality as definitional. It’s not a matter of just calculating
            <em>a</em> and <em>b</em> to calculate the same thing. It’s semantic. It
            has to do with a matter of proof. We have to do this, but we can do
            this. And then, I set you as an exercise that you can use this rule to
            prove, for example, it follows that—I remember, I think I did this—λx. x
            =ℕ→ℕ λx. zero + x.
        </p>
        <p>我认为我给出了类似的例子。好的。事实上，由于我可以证明它在命题上相等，因此它将在定义上相等或判断上相等。这就是我们将使用的术语。好的。所以，它是命题相等。所以，你将能够证明这一点，这会带来各种美好、令人愉快和有用的后果，因为定义或判断平等的原则表明它是一致的。所以，你可以在任何地方用相等替换相等，就你而言，这和那是——你无法分辨出两者的区别——你可以随意在任何地方用一个替换另一个。好的。这很令人愉快，但它限制了类型理论的适用范围，而这可以通过不将其作为我们的公理来实现。</p><p>I think I think I gave an example of something like that. Okay. In
            fact, it’s going to be definitionally equal or judgmentally equal by
            virtue of the fact that I can show that it is propositionally equal.
            That’s the terminology we’ll use. Okay. So, it’s a propositionally
            equal. So, you’ll be able to prove that, and that has all sorts of nice
            and pleasant and useful consequences, because the principles of
            definitional or judgmental equality say that it’s a congruence. So, you
            can replace equals by equals anywhere, and as far as you’re concerned,
            this and that are either—you couldn’t tell the difference for all the
            world—and you can replace one by the other anywhere you like, willy
            nilly. Okay. It’s very pleasant, but it limits the range of
            applicability of the type theory in a way that is made possible by not
            taking that as our axiom.</p>
        <h2 id="intentional-identity">有意身份</h2><h2>Intentional Identity</h2>
        <p>另一个是所谓的有意身份，这是我们要去的地方——我们要从中获得一些好处。所以，这里的想法是，它强调——你可以说强调的是身份作为数据。这是我唯一知道如何向你解释激励我下一步行动的心态的方式。好的。</p><p>So, the other one is what is called intentional identity, and this is
            the one where we’re going to—where we’re going to get some mileage. So,
            here the idea is that it stresses—you could say the stress is on
            identity as data. That’s the only way I know how to explain to you like
            the mindset that motivates what I’m going to do next. Okay.</p>
        <p>因此，意向性的观点——外延恒等式在某种程度上表明，恒等式类型应该被纯粹地视为命题。我们只关心它是否有人居住。我们把线下的居住者
            <em>p</em>扔掉，然后我们就说它们是相等的。所以，这完全强调了我们将把这种类型视为纯粹命题的想法。这就像坚定地承诺这种类型仅仅是一个命题，因为进入它的证明被丢弃了。好吗？
        </p><p>So, the point of intentional—the extensional identity kind of says
            the identity type should be thought of purely propositionally. We only
            care about whether it’s inhabited. We throw away the inhabitant
            <em>p</em> below the line, and we just say they’re equal. So, it’s
            totally stressing the idea that we’re going to treat this type as, I
            say, purely propositionally. It’s like a firm commitment to the idea
            that this type is merely a proposition because the proofs that go into
            it are discarded. Okay?
        </p>
        <p>因此，一种说法是：要么事物相等，要么事物不相等；要么你有证据，要么你没有。好吗？这不是建设性的有效性，但它是一种思考正在发生的事情的方式。当你有证据时，你可以说它们是相等的。所以，这是对此的强烈承诺。这里强调的是身份，我们最终会称之为一个单纯的命题，在这里是数据。所以，身份是一个完整的类型——我认为，这是描述我正在做的事情和我现在要做的事情背后的心态的一种非常合理的方式。</p><p>So, a way of saying it is: either things are equal or they’re not;
            either you have a proof or you don’t. Okay? That’s not constructively
            valid, but it’s a way of thinking about what’s going on. When you do
            have a proof, then you can say that they’re equal. So, it’s a strong
            commitment to this. The stress here is on identity as a, what we will
            eventually call, a mere proposition, and here as data. So, the identity
            as a full throated type—that’s, I think, a perfectly reasonable way to
            describe the mindset that underlies what I’m doing, what I’m going to do
            now.</p>
        <h2 id="introduction-rule">引言规则</h2><h2>Introduction Rule</h2>
        <p>好的？</p><p>Okay?</p>
        <p>那么，你明白了吗？好的。那么，这是介绍规则。我要用这个介绍规则做什么——我——我将会这样做。我的心态——我希望这对你有帮助——我的心态是这样的：这只是一个数据结构。我不知道，它是某种该死的类型，称之为 x。好吗？我不在乎。对吧？它只是一个抽象类型，只有一个介绍规则，即反身性。</p><p>So, are you with me? Okay. So, here’s the introduction rule. What I
            want to do with this introduction rule—I’m—I’m going to be. My mindset—I
            hope this is helpful to you—my mindset is this: this is just a data
            structure. I don’t know, it’s some damn type, call it x. Okay? I don’t
            care. Right? It’s just an abstract type, and there’s only one
            introduction rule, which is reflexivity.</p>
        <p>所以，现在我想做的是颠倒这个规则。我想给出一个消除形式，表达出身份类型中唯一的东西是反身性的想法。</p><p>So, now what I would like to do is to invert this rule. I would like
            to give an elimination form that expresses the idea that the only thing
            that’s in the identity type is reflexivity.</p>
        <h2 id="elimination-form">淘汰表</h2><h2>Elimination Form</h2>
        <p>好吗？这就是我想要做的。所以，我不想说——我不想从中得出这样的想法：既然它是反身性的——好吧，我最好不要这么说，因为我说的每句话都有可能被误解。让我就这样说吧。好吗？</p><p>Okay? That’s what I want to do. So, I don’t want to say—I don’t want
            to extract from it the idea that since it’s reflexivity—well, I better
            not say that because everything I say has a possibility of me being
            misinterpreted. Let me leave it like that. Okay?</p>
        <p>所以，这就是我想要做的。那么，我们一直以来的设置是什么？一直是：我们说，“好吧，假设你有一个证明 a 等于 b。”我要在这里画一条线。好的。这将是平等——哦，我在这里写了“i”。这可以——哦，那是扩展的，是的。平等消除，这将被称为“elim”或其他什么，有意的。好吗？这就是我要在这里做的。这是两种类型理论形式的鲜明区别。好的。</p><p>So, here’s what I want to do. So, what is our setup all the way
            along? Has been: we say, “Well, suppose you have a proof that a is equal
            to b.” I’m going to draw a line here. Okay. And this is going to be the
            equality—oh, I wrote “i” here. This could—oh, that’s the extension one,
            yeah. The equality elimination, and this will be called “elim” or
            something, the intentional one. Okay? That’s what I’m going to do here.
            This is a sharp distinction between two forms of type theory. Okay.</p>
        <p>好的。所以，一般模式是消除规则。特别是当你认为——就像我说的，把它看作一种对数据进行分类的类型时。</p><p>All right. So, the general pattern is of an elimination rule.
            Especially when you think—like, as I say, think of it as a type that
            classifies data.</p>
        <h2 id="induction-principle">诱导原理</h2><h2>Induction Principle</h2>
        <p>如果你给我一些<em>p</em>，也就是身份证明，我想要做的是陈述一个归纳原理，该原理从 a 等于 b 这一事实推理而来。你已经写过，你知道我有一个 a 等于 b 的证明。因此，从 a 等于 b 推理而来。为了帮助那些做笔记的人，我会在这里留一些空间。我会说，“从这个推理意味着我们称它们为 x 和 y。”你能读懂我写的所有内容吗？我有一个属性 P，我留了一点空间来证明 z。可以吗？</p><p>If you come along and give me some <em>p</em>, which is a proof of
            identity, what I want to do is I want to state an induction principle
            that reasons from—okay, the fact that a is equal to b. Has written, you
            know that I have a proof that a is equal to b. So, on a reason from a is
            equal to b. To help those taking notes, I’ll leave some space here. I’ll
            say, “Reasoning from this means let’s call these x and y.” Can you read
            everything I’m writing? I have a property P, and I’m leaving a little
            space that I want to prove about z. Okay?</p>
        <p>所以，接下来会发生什么呢？我会得到某个东西的 P，末尾有一个小 p。好吗？所以我把它设置为归纳原理。从你得到一个相等类型的元素这一事实出发，我想对所有这样的元素说点什么，不管这个元素是什么。我想说点什么，使得大写 P 对它来说是正确的。好吗？</p><p>So, what’s going to happen is here I’m going to have P of something
            or other, and little p at the end. Okay? So, I’m setting it up as an
            induction principle. Your reasoning from the fact that you’ve got an
            element of the equality type—I want to say something about all such
            elements, whatever that element is. I want to say something such that
            capital P is true of it. Okay?</p>
        <p>因此，我要做的是表达基于反身性公理的归纳原理。也就是说，考虑一下，按情况分解就足够了。看看所有的介绍形式。因此，通过数学归纳法，我们有两个前提：一个是零，一个是后继。</p><p>So, what I’m going to do is I’m going to express an induction
            principle that is based on the reflexivity axiom. That says, well, it’s
            enough to consider, break it down by cases. Look at all the intro forms.
            So, with mathematical induction, we had two premises: one for zero and
            one for successor.</p>
        <h2 id="case-analysis">案例分析</h2><h2>Case Analysis</h2>
        <p>就前任而言，这里我没有任何身份类型中的前任。没有前任的概念。所以，这是一个案例分析，不仅是一个案例分析，而且是一个单向案例分析。好吗？只有一个案例需要考虑。对吧？这是一种归纳类型。你可以认为它只有一个。只有一个案例需要考虑。接下来是重大的微妙之处，但我们会讲到的。好的。</p><p>In terms of the predecessor, here I don’t have any predecessor within
            the identity type. There’s no idea of a predecessor. So, it’s a case
            analysis, and not only is it a case analysis, but it’s a one way case
            analysis. Okay? There’s only one case to consider. Right? This is an
            inductive type. You can think of it as that has only one. There’s only
            one case to consider. There’s a major league subtlety coming up, but
            we’ll get there. Okay.</p>
        <p>回到这个问题——这是一个技术问题。我希望这个 P 成立。它是关于 a 中任何身份类型的谓词。所以，它被写成 P(x, y, z)，因为，你知道，否则 x 和 y 就会悬空。如果我只是说 P 是相等性证明的谓词。好的。那么，x 和 y 会是什么？好的。</p><p>Back to this—this is a technical point. What I want this P to be is I
            want this P to hold. It’s a predicate about any identity type in a. So,
            it’s written P(x, y, z), because, you know, otherwise the x and y would
            be dangling. If I just said P is a predicate on proofs of equality.
            Okay. This then, what would the x and y be? Okay.</p>
        <h2 id="mathematical-induction-analogy">数学归纳法类比</h2><h2>Mathematical Induction
            Analogy</h2>
        <p>所以，我知道的唯一类比方法就是当你在做数学归纳法时，归纳假设考虑一个任意自然数，使得 IH 成立，然后推断它对后继成立。对吧？所以，你有一个参数，x，它是一个任意自然数，你从 x 到 x + 1。所以，这里我有一个参数 x 和 y，这是一个证明，一个参数，x 和 y 相等。</p><p>So, just as the only way I know how to draw the analogy is just as
            when you’re doing a principle of mathematical induction, the inductive
            hypothesis considers an arbitrary natural number such that the IH holds,
            and then deduces that it holds for the successor. Right? So, you have a
            parameter there, x, which is an arbitrary natural number, and you go
            from x to x + 1. So, here I have a parameter as x and y, and this is,
            and a proof, a parameter that x and y are equal.</p>
        <p>然后我将证明一个具有三个位置的属性：x、y 和 z。</p><p>And then I’m going to prove a property that has three positions in
            it: x, y, and z.</p>
        <h2 id="ternary-relation">三元关系</h2><h2>Ternary Relation</h2>
        <p>好吗？那么，我将导出一个三元关系——最一般的情况我会导出一个三元关系。好的。从中——我要开始。那么，我们这里要讨论的是 a、b 和 P。如果我有一个特定的等式——如果你给我其中一个，我想证明它对那个特定场景的 a、b 和 P 都成立。这就是我想要做的。那么，现在出现了一个重要的问题：什么在这里，什么在线上？我认为对于你们大多数人来说，这需要一些时间来适应，因为我的经验是它很令人困惑。事实上，我昨天在写笔记时感到困惑，所以我知道它会令人困惑。好的，所以这个想法是这样的：</p><p>Okay? So, I’m going to derive a ternary—the most general cases I
            derive a ternary relation. Okay. Out of the—I’m going to drive. And so,
            what we’ll go here will be a, b, and P. So, if I have a particular
            equal—if you give me one of these, I want to show that it holds for a,
            b, and P for that particular scenario. That’s what I want to do. So, now
            comes the important question: what goes here and what goes above the
            line? This is going to take some getting used to, I think, for most of
            you, because my experience has been that it’s confusing. In fact, I was
            writing my notes yesterday and got confused, so I know that it’ll be
            confusing. Okay, so the idea is this:</p>
        <p>考虑反身性就足够了，就像数学归纳法一样。</p><p>It’s enough to consider reflexivity, just like in mathematical
            induction.</p>
        <h2 id="reflexivity">反身性</h2><h2>Reflexivity</h2>
        <p>当你想证明某个任意自然数的某个性质时，只要证明它对每个数字都成立就足够了。简洁的说法是：你直接证明它对零成立，并证明它在后继者下保持不变。这样，你就知道，如果你给我任何数字——s 的 s 的 s 的 s 的 s 的 s 的 s 的 s 的 s 为零——该性质将成立。实际上，你是说你正在对每个数字进行无限案例分析。这就是数学归纳法所做的。</p><p>When you want to prove something about an arbitrary natural number,
            it’s enough to show that it holds for every numeral. The concise way to
            say that is: you show outright that it holds for zero and show that it’s
            preserved under the successor. That way, you know that if you give me
            any numeral—s of s of s of s of s of s of s of s of zero—that the
            property will hold for that. In effect, you’re saying you’re doing an
            infinitary case analysis, one for each numeral. That’s what mathematical
            induction is doing.</p>
        <p>所以，我在这里做一个一元格分析，每个介绍形式一个。只有一条规则。所以，我所做的是，我说这足以表明，对于 A 中的任何 x，你有一个证明——我称之为 Q，证明什么？证明 p(x, x) 和 x 的反身性。</p><p>So, here I’m doing a unary case analysis, one for each introductory
            form. There’s only one rule. So, what I do is I say it’s enough to show,
            for any x in A, you have a proof—I’ll call it Q of what? Of p(x, x) and
            reflexivity of x.</p>
        <h2 id="proof-term">证明期限</h2><h2>Proof Term</h2>
        <p>如果我能做到这一点，那么我这里就有一个证明项，传统上写成 J。J 带有一个参数；它是参数化的。很多时候我会忽略它，但现在，让我把它写下来。</p><p>And if I can do that, then what I have is a proof term here, which is
            traditionally written J. And J takes an argument; it’s parameterized. A
            lot of times I’ll miss it out, but right now, let me just write it
            down.</p>
        <p>所以，这是家族。你必须记住你瞄准的是哪个家族？所以，这是一种论证。好的。然后你使用 xq 作为你的证明，也就是说，你的归纳步骤，因为没有更好的术语。好的。你使用 p 作为它的论证。所以，这就是……</p><p>So, here’s the family. You have to remember what family are you
            aiming toward? So, that’s some kind of an argument. Okay. And then you
            are using x.q as your proof, so to say, your inductive step, for lack of
            a better terminology. Okay. And you are using p as the argument to it.
            So, that is the…</p>
        <p>这也可以写成，有时在更系统的描述中是这样的：这是身份的递归器。</p><p>This could also be written as, and it sometimes is in a more
            systematic account: this is the recursor for the identity.</p>
        <h2 id="recurser-for-identity">身份的递归器</h2><h2>Recurser for Identity</h2>
        <p>就像我上次所说的 rec 是自然数的递归函数一样。好吗？是的。</p><p>In the same way that what I called rec last time is the recursor for
            the natural numbers. All right? Yes.</p>
        <p>哦，这只是我个人的符号。有各种各样的人。有时人们会写 J <sub>x、y、z、p</sub>。这在某种程度上传达了它有点辅助的意思。我只是想小心谨慎。我真的需要告诉 J 家人在努力什么，然后它就需要……不知何故，肉就是……嗯，我不知道该怎么称呼它。诱导步骤，我想你应该这么称呼它。然后……</p><p>Oh, it’s just my personal notation. There are various people.
            Sometimes people will write J<sub>x, y, z, p</sub>. It’s somehow getting
            across the idea that it’s a bit ancillary. I’m just like to be careful
            and thorough. I really need to inform J what family is working toward,
            and then it takes as… somehow the meat is the proof of the… well, I
            don’t know what to call it. The induction step, I guess that’s what you
            should call it. And then…</p>
        <p>然后是您正在研究的路径或证明。有不同的符号。事实上，在实践中，我们经常会忽略它们。但是，正如我即将向您展示的那样，前几次，您肯定希望将其写下来，这样您就不会迷路，您可以观看。我要搞砸一个证明。我已经写过好几次了，我知道我会搞砸它，因为我总是这样。所以，我会尽量不搞砸它，但你会发现这是保持方向的方法。</p><p>and then the path or the proof that you’re working on. There are
            different notations. And in fact, in practice, we’ll often leave those
            out. But, as I’m about to show you, the first few times, you definitely
            want to write this down so you don’t get lost and you can watch. I’m
            going to screw up a proof. I’ve written it out several times, and I know
            I’m going to screw it up because I always do. So, I’ll try not to screw
            it up, but you’ll see that this is the way to keep your bearings.</p>
        <p>现在，有一件重要的事情。有一个定义上的平等。是的。那又是什么？它和你使用的不同吗？这个
            <em>j</em>是一种符号技巧，它是一个不同的
            <em>j</em>？所以你可以折叠判断。我不知道你的意思。我不确定我是否理解了。我不认为我之前在桌子上放过<em>j 。好的。哦，一个任意判断。哦，好的。是的，对不起。这是一个脚本</em><em>j</em>，无论我是否这样写。唯一的方法，唯一的方法，我——这只是传统。马丁路德称它为<em>j</em>。所以没有明显的理由称它为<em>j</em>，除非它位于
            <em>i</em>之后或类似的东西。我不知道。它，但你认为它是身份的递归。它是一个特定的形成常数的术语。它是……
        </p><p>Now, there’s an important thing. There’s a definitional equality.
            Yes. What’s that again? Is it different than what you use? This
            <em>j</em> as a kind of notational trick, which is a different
            <em>j</em>? So you can sort of collapse the judgments. I don’t know what
            you mean by that. I’m not sure I’m getting at that. What I don’t think I
            had a <em>j</em> on the table before. Okay. Oh, an arbitrary judgment.
            Oh, okay. Yeah, sorry. That was a script <em>j</em>, whether I wrote it
            that way or not. The only way, the only way, I—it’s just that this is
            the tradition. Martin Luther called it <em>j</em>. So there’s no like
            obviously good reason to call it <em>j</em>, except that it comes after
            <em>i</em> or something. I don’t know. It, but you think is the recursor
            for the identity. It’s a particular term forming constant. It’s the…
        </p>
        <h2 id="path-induction">路径诱导</h2><h2>Path Induction</h2>
        <p>好的。顺便说一下，出于我稍后要解释的原因，这个原理被称为路径诱导。</p><p>Okay. And this principle, by the way, for reasons which I’m going to
            explain now in a minute, is called path induction.</p>
        <p>好的，所以有一个问题。那么可能有很多……</p><p>Okay, so there was a question. Then there probably, probably are
            many…</p>
        <p>好的。因为记住归纳原理的一般模式是你从一种兴趣出发对某事进行推理。</p><p>Okay. Well, because remember the general pattern of induction
            principle is your reasoning from a type of interest towards
            something.</p>
        <h2 id="induction-principle-reasoning">归纳推理</h2><h2>Induction Principle
            Reasoning</h2>
        <p>所以我要推理的是这个<em>p</em>。<em>p</em>
            有三个参数：左端点和右端点，以及它们相等的证明。这就像说，你知道，如果你有一个关于<em>x</em>、<em>y</em>和
            <em>z</em>的谓词，你想证明其中<em>x</em>和<em>y</em>相等，并且它们证明了<em>z</em>的这一事实，这足以表明，只要<em>x</em>和<em>y</em>相同，你就可以证明<em>p</em>，并且所讨论的证明确实是反身性。这就是它的意思。是的。你有一个<em>p</em>？是的，就是这样。这就像只是数据。我……
        <em></em><em></em><em></em></p><p>So the thing I’m reasoning toward is this <em>p</em>. And <em>p</em>
            has three arguments: the left and right endpoint, and the proof that
            they’re equal. This is just like saying, you know, if you have a
            predicate that you want to prove about <em>x</em>, <em>y</em>, and
            <em>z</em> for any <em>x</em> and <em>y</em> which are equal, and they
            prove <em>z</em> of that fact, it’s enough to show that you have, you
            can prove <em>p</em> given that <em>x</em> and <em>y</em> are identical,
            and that the proof in question really is reflexivity. That’s what this
            is saying. Yeah. You have a <em>p</em>? Yeah, that’s all. That’s like
            just the data. Did I…
        </p>
        <p>好的。哦，是的，抱歉。哦，也许这就是让人们感到困惑的地方。是的。所以这是一种类型，这是在呼唤你。是的。是的。谢谢。是的，这正是我搞砸的事情。是的，抱歉。是的，是的，对此感到抱歉。是的，是的，抱歉。</p><p>Okay. Oh, yeah, sorry. Oh, maybe that’s what’s confusing people.
            Yeah. So that’s a type, and this is calling you. Yeah. Yep. Thank you.
            Yeah, that’s exactly what I messed up. Yeah, sorry. Yeah, yeah, sorry
            about that. Yeah, yeah, sorry.</p>
        <p>是的。为什么？什么？为什么我要把它放在括号里？那是<em>q</em>，而
            <em>p</em>是起点，是<em>a</em>等于<em>b 的</em>证明。p在这里，<em>q</em>在这里。q
            <em>中</em>有一个变量<em>x ，而</em><em>p只是相等的直接证明。那是什么？对不起。两个？是的。是的，没错</em><em>。</em>是的，是的。
        <em></em></p><p>Yeah. Why? What? Why did I put it in braces? That’s a <em>q</em>, and
            <em>p</em> is the starting point, which is the proof that <em>a</em> is
            equal to <em>b</em>. <em>p</em> is here, and <em>q</em> is here.
            <em>q</em> has a variable <em>x</em> in it, and <em>p</em> is just an
            outright proof of equality. That what? Sorry. Two? Yeah. Yes, exactly.
            Yeah, yeah.
        </p>
        <p>嗯，实际上，从术语上来说，它是析构函数，但是是的，它是任何肢体形式。是的。继续。您如何读取<em>j</em>？我怎么做？您读什么？您如何读取它？是的。好吧，也许我……也许我要说的会对您有所帮助。所以，我要说的是：适用于此的定义相等原则是什么？计算规则是什么？也许这就是您要说的。您如何用它进行计算？好的。</p><p>Well, as a destructor, actually, in the terminology, but yes, it’s
            any limb form. Yes. Go ahead. How do you read the <em>j</em>? How do I?
            What do you read? How do you read it? Yes. Well, maybe what I’m… Perhaps
            what I’m about to say will help you. So, what I’m about to say is: What
            is the principle of definitional equality that applies to this? What is
            the computation rule? Maybe that’s what you’re getting at. How do you
            compute with it? Okay.</p>
        <p>那么，让我们来写一下。让我省略下标。人们通常就是这么做的。好的。您已经得到了对任何
            <em>x</em>和<em>q</em>都成立的证明。如果您真的给我<em>refl</em> ，那么这应该与为<em>x</em>
            和<em>q代入</em><em>a</em>相同，如果您看一下，这意味着这是
            <em>p(a)</em>类型。查看规则的第二行：<em>p(a)、a 和 riffle(a, a)</em>，就是这个。所以，如果这是我的<em>p</em>，那么这就是我的<em>p</em>。好的。p介于
            <em>a</em>和<em>a之间。</em><em>这就是控制</em><em>j</em>的定义相等的概念。好的。所以，它们是……是的，这就是相等的定义。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>So, let’s write it. Let me just miss out the subscripts. That’s what
            people typically do. Okay. You’ve got a proof that holds for any
            <em>x</em> and <em>q</em>. And if you actually give me <em>refl</em>,
            then that should be the same as plugging in <em>a</em> for <em>x</em>
            and <em>q</em>, and if you look, that means that this is of type
            <em>p(a)</em>. Look in the second line there of the rule: <em>p(a), a,
                and riffle(a, a)</em>, which is this guy. So, if this is my <em>p</em>,
            then this is my <em>p</em> here. Okay. And <em>p</em> is between
            <em>a</em> and <em>a</em>. That’s the notion of definitional equality
            that governs the <em>j</em>. Okay. So, that they are… yeah, that’s the
            definition of equality.
        </p>
        <p>所以，它是一个<em>递归器</em>。它没有任何真正合适的归纳结构。所以，它实际上是一个案例分析，并且只有一个案例。所以，它只能是一个案例。</p><p>So, it’s a <em>recurser</em>. It doesn’t have any real proper
            inductive structure. So, it’s really a case analysis, and it only has
            one case. So, there’s only one case it could be.</p>
        <p>如果您查看我上次给出的 plus（用于 sum）的
            <em>递归程序，或者其他程序，它有一个案例分析。它有两种情况，因为这是您考虑 sum 的方式。它有两件事。我们给出了</em><em>abort</em>，这是基于零个案例的案例分析。好的，因为这里的空类型中没有任何内容。我们正在根据一个案例进行案例分析。这是一项微妙的业务。
        </p><p>If you look at the <em>recurser</em> for plus (for sum) that I gave
            last time, or whatever, it had a case analysis. It had two cases because
            that was how you think about the sum. It has two things. We gave
            <em>abort</em>, which was a case analysis based on zero cases. Okay,
            because there’s nothing in the empty type here. We’re doing a case
            analysis based on one case. This is a subtle business.
        </p>
        <p>所以，现在，我纯粹从形式上来处理这个问题。也就是说，我只是说，如果这是入门规则，而你认为​​它是一个数据结构，那么基本上，你必须把它作为你的
            <em>limerel</em>。这就像使用我迄今为止开发的推理模式强加给你一样。好吗？明白了吗？
        </p><p>So, right now, I’m approaching it purely formally. That is, I’m just
            saying if that’s the intro rule, and you think of it as a data
            structure, pretty much, you’ve got to give this as your
            <em>limerel</em>. That’s like pretty well forced on you just by using
            the patterns of reasoning that I’ve developed so far. Okay? Got me?
        </p>
        <p>好吧。现在我们真的要惹上大麻烦了。好吗？</p><p>All right. Now, we’re going to really get ourselves into a lot of
            trouble. Okay?</p>
        <p>是的，<em>x</em>绑定在<em>q</em>内。是的，是的。嗯，它不是免费的；它就在这里被这个绑定器绑定。好的。</p><p>Yes, <em>x</em> is bound within <em>q</em>. Yeah, yeah. Well, it’s
            not free; it’s bound right here by this, by this binder. Okay.</p>
        <p>所以，本质上，是的。所以，他被省略了，因为，你知道，实际上没有 lambda。如果你愿意，把它放在那里，你知道。它们是绑定器。所以，括号中的<em>x</em>，或者换句话说，你知道，lambda 只是一般场景的一个实例。如果你有 lambda，它需要一个参数<em>x</em>，点，你知道，<em>a</em>。你还有其他东西，比如<em>case</em>，它需要几个参数，绑定不同的位置，<em>y</em>点
            <em>b</em>，然后它还有一个<em>c</em>，等等。好的。
        </p><p>So, so essentially, yeah. So, like, he’s omitted because, you know,
            there isn’t actually a lambda. If you like, stick it in there, you know.
            They’re binders. So, the <em>x</em>s in the brackets, or to put it
            another way, you know, lambda is just an instance of the general
            scenario. If you have lambda, it takes one argument <em>x</em>, dot, you
            know, <em>a</em>. You have other things like <em>case</em>, which takes
            several arguments, which bind different positions, <em>y</em> dot
            <em>b</em>, and then it also has a <em>c</em>, etc. Okay.
        </p>
        <p>这就是理论。我所做的是使用逻辑框架中的想法，这就像二阶抽象语法的想法。所以，你可以——我希望——就像我说的，有些事情我会一笔带过，因为这是不可避免的。好的，当然。如果我详细介绍我所做的一切，我肯定会让你们都睡着的。所以，好的，好的。所以，这就是 J。现在有一件非常有趣的事情要做。好的。所以，这就是身份类型的肢体形式。</p><p>So, that’s the theory. So, what I’m doing is I’m using ideas from
            logical frameworks, and this is like the idea of second order abstract
            syntax. So, you can—I hope—like I said, there are certain things I’m
            glossing over because it’s unavoidable. Okay, absolutely. Positively, I
            would put you all to sleep if I went through all the details of
            everything I’m doing. So, okay, okay. So, that’s the J. So, now comes a
            very interesting thing to do. Okay. So, that’s the limb form for the
            identity type.</p>
        <p>所以，我一直称这个东西为恒等类型。好的。我一直在强调它表达的是平等。所以，它肯定最好是一个等价关系。好的。所以，这是最重要的。所以，我想说的第一件事是，事实上，这有点令人惊讶。你看，如果你看任何公理说明，比如任何事物的一阶逻辑，比如代数理论或几乎任何可见的东西，他们会说，“哦，是的，有一种叫做平等的关系，它是……”公理告诉你它是自反的、对称的、传递的，等等。但无论如何，这就是他们会告诉你的。好的。在这个公式中没有对称性或传递性的公理，因为它是一个定理。这应该会让你感到惊讶，因为它并不明显。好的。</p><p>So, I’ve been calling this thing the identity type. Okay. And I’ve
            been stressing that it expresses equality. So, surely it had better be
            an equivalence relation. Okay. So, that’s the important thing. So, I
            would like to say the first thing I want to say is, in fact, this is
            kind of surprising. See, if you look in any axiomatic account, like in
            first order logic of any kind of thing, like an algebraic theory or
            practically anything in sight, somewhere, they will say, “Oh, yes,
            there’s this relation called equality, and it’s re…” and the axioms tell
            you it’s reflexive, symmetric, and transitive, amongst other things. But
            anyway, that’s what they’ll tell you. Okay. There’s no axiom for
            symmetry or transitivity in this formulation because it’s a theorem. And
            that should surprise you because it’s not obvious. Okay.</p>
        <p>那么，我将向你展示它是如何工作的。它通过路径感应工作。所以，你会这样说——我将用三种不同的方式来强调这里发生的事情——我可以松散地说，“a 处的相等是对称的”，或者更准确地说，“对于 a 中的每个 x 和 y，如果 x 等于 y，则 y 等于 x。”或者，我可以用英语写出来。你必须习惯的事情——这在我看来很美，好吧，就像我喜欢的东西——是你所做的数学陈述是类型，你写的证明是这种类型的程序。</p><p>So, I’ll show you how it works. It works by path induction. So, the
            way you would say it is—I’m going to write it in three different ways to
            emphasize what’s going on here—I could just say loosely, “Equality at a
            is symmetric,” or a little bit more precisely, “For every x and y in a,
            if x is equal to y, then y is equal to x.” Or, I could write that in
            English. The thing that you’re going to have to get used to—that is
            beautiful in my mind, okay, like something I love—is the idea that the
            math statements you make are types, and the proofs you write are
            programs of that type.</p>
        <h2 id="data-as-types-and-proofs-as-programs">数据作为类型，证明作为程序</h2><h2>Data as Types and Proofs
            as Programs</h2>
        <p>所以，我需要编写一个这种类型的程序。如果你愿意，你可以说，“对于 a 中的所有 x 和 y，如果 x 等于 y，那么 y 等于 x。”这就是我在这里表达的意思。好的。这就是我要做的。我真正的意思是，当我这样写出来时，我真正的意思是这里存在一个元素；它有一个元素；有某种类型的元素。这就是说这是真的。通过命题类型转录到这里。当我说这是真的时……</p><p>So, I need to write a program of that type. If you wanted, you could
            say, “For all x and y in a, if x equals y, then y equals x.” That’s what
            I’m expressing here. Okay. That’s what I’m doing. And what I really mean
            is, when I write that out like that, I really mean there exists an
            element here; it has an element; there’s some kind of element of that
            type. That’s what it means to say that this is true. Is transcribed into
            here by a propositional type into a type. And when I say that this is
            true…</p>
        <p>所以，让我把它写成“blah blah blah true”。我不会经常这样做，但我会这样做，因为你知道在传统数学中，当你写定理 a 时，你会在这里说出一些大命题。这只是判断 a 为真的传统符号。好的。当你在证明后面写小 a 时，这只是 a 在 a 中的传统符号。好的。所以，我们会经常这样做。好的。</p><p>So, let me just write it as “blah blah blah true.” I won’t do that
            very often, but I’ll do that because you see what happens is, in the
            conventional math, when you write theorem a, you say some big
            proposition here. That’s just the conventional notation for the judgment
            a true. Okay. And when you write after that proof little a, that’s just
            the conventional notation for a is in a. Okay. So, we’re going to do
            that a lot. Okay.</p>
        <p>所以，会有很多内容要写，但一旦你意识到它解锁了许多以前未开发的可能性，它就会打开。所以，我要做的是，这是一种表达方式。这就是我要说的：有一个这样的函数，但另一种表达相同内容的方式是：如果我在 A 中有 x，在 A 中有 y，并且我有一个证明 x 等于 y，那么我就有一个证明——我会在这里填写——y 等于 x。</p><p>So, a lot will be written, but it opens up as soon as you realize it
            unlocks many previously untapped possibilities. So, what I’m going to do
            is here is a way to say this. This is what I’m going to say: is there’s
            a function like this, but another way to write the same thing is to say:
            if I have x in A, and I have y in A, and I have a proof that x is equal
            to y, then I have a proof—which I will fill in here—that y is equal to
            x.</p>
        <h2 id="symmetry-of-equality">平等的对称性</h2><h2>Symmetry of Equality</h2>
        <p>这显然已经足够了，因为如果你看看规则，这就是你需要证明的，好吗？我需要一个名字。我要给这个东西起个名字。</p><p>This is clearly sufficient for that, because if you look at the
            rules, that’s exactly what you need to prove in order to prove that,
            okay? And I need a name. I’m going to give a name for this thing
            here.</p>
        <h2 id="symmetrization">对称化</h2><h2>Symmetrization</h2>
        <p>我们可以称其为 sym — z 的对称化。但很快，出于显而易见的原因，我们有时也会将其写为 z 逆，好吗？这就是这个概念。是的，这就是对称化的概念。所以，这是我将要感兴趣的。所以，我真正想说的是，存在一个这样的术语，其中 — 这是我所需要知道的 — 或者说是这样的。让我写“这样的”。这将非常重要。</p><p>We could call it sym—the symmetrization of z. But very shortly, for
            reasons that will become apparent, we’ll also sometimes write this as z
            inverse, okay? So, this is what this is—the idea. Yeah, so this is the
            idea of symmetrization. So, this is the one I’m going to be interested
            in. So, what I’m really saying is there exists a term like that,
            where—and here’s what I need to know—or such that. Let me write “such
            that.” This will be very important.</p>
        <p>我会在这里写。所以，存在这样一个术语，如果我对称化反身性，我就会得到定义上的反身性。这是一种说法：如果你认为反身性是——这种特殊的符号被广泛使用，但它有点误导。</p><p>I’ll write it over here. So, there exists such a term such that if I
            symmetrize reflexivity, I get back definitionally reflexivity. Which is
            a way of saying: if you think of reflexivity as—this particular notation
            is used a lot, but it’s a little misleading.</p>
        <h2 id="definitional-equality">定义平等</h2><h2>Definitional Equality</h2>
        <p>没关系。id inverse 等于 id，因为如果我们想——如果你想写 sub A，那没问题。这种符号的问题在于它与恒等函数相混淆。所以，这实际上只是 reffl 的符号。实际上，很多时候人们会写 id，但这很令人困惑，因为他们也会为恒等函数写 id，好吗？那是——我很抱歉。所以，我会尝试在这里写 reffl，而不是经常写 id。id，但你最好习惯这样一个事实，即出现的符号滥用之一是将 reffl 写为 id，好吗？</p><p>It’s all right. id inverse is equal to id, because if we think—and if
            you want to write sub A, that’s okay. The problem with this notation is
            it confuses it with the identity function. So, this is really just a
            notation for reffl. And really, a lot of times people will write id, but
            it’s confusing because they’ll also write id for the identity function,
            okay? And that’s—I’m sorry. So, I’ll try to write reffl here and not
            write id. id very often, but you might as well get used to the fact that
            one of the notational abuses that comes up is writing id for reffl,
            okay?</p>
        <p>所以，这就是这个定理最有趣的部分。这就像是一种渐进式的细化，尽可能精确地表达相等对称性的信息内容。这意味着存在一个映射。所以，这就是我要说的。好的。这就是我如此关心这个问题的原因。让我——我需要把那张图片留在那里。所以，让我们在这里供大家参考。好的。好的。所以，我们将要得到的图片是这样的。</p><p>So, this is this is the interesting part of the theorem. This is like
            a progressive refinement of expressing as precisely as I know how the
            information content of the symmetry of equality. It means there’s a
            mapping. So, here’s what I’m—here’s what I’m heading toward. Okay.
            Here’s why I care so much about this. And let me—I need to leave that
            picture there. So, let’s go over here for your reference. Okay. Okay.
            So, the picture that we’re going to have is this.</p>
        <p>我们将有——我们有空间 A 这个概念，并且我们将一般性地考虑两个元素之间的识别概念。</p><p>We’re going to have—we have this notion of a space A, and we’re going
            to consider in general the notion of identifications between two
            elements.</p>
        <h2 id="identifications-as-paths">路径标识</h2><h2>Identifications as Paths</h2>
        <p>假设 a1a_1a1​ a1a_1a1​a1a_1a1​a1a_1a1​a1​a1​a1​a1​a1​a1​1​1​1111​和 a2a_2a2​ a2a_2a2​a2a_2a2​a2a_2a2​a2​a2​a2​2​2​2222​为所讨论的对象。我们将连接它们的线表示为 ppp，ppppppppppp，这证明 a1a_1a1​ a1a_1a1​a1a_1a1​a1a_1a1​a1​a1​a1​1​1​1111​和 a2a_2a2​ a2a_2a2​a2a_2a2​a2a_2a2​a2​a2​a2​a2​2​2222​是相同的。或者，如果你愿意，看起来有点杂乱。我可以把它写成一条线。它在黑板上看起来不太好，但在书上，我们把它写成双线，好吧，有点像说它等同于 A₁ 和 A₂。其他时候，根据你的特定心情和场景，人们会写成波浪线，好吧。</p><p>Let a1a_1a1​ a1a_1a1​a1a_1a1​a1a_1a1​a1​a1​a1​1​1​1111​and a2a_2a2​
            a2a_2a2​a2a_2a2​a2a_2a2​a2​a2​a2​2​2​2222​be the objects in question. We will
            denote the line connecting them as ppp, pppppppppppwhich is a proof that
            a1a_1a1​ a1a_1a1​a1a_1a1​a1a_1a1​a1​a1​a1​1​1​1111​and a2a_2a2​
            a2a_2a2​a2a_2a2​a2a_2a2​a2​a2​a2​2​2​2222​are identical. Or, if you like, that
            looks a little cluttered. I can write it as a line. It won’t look too
            good on the board, but in the book, we write it as a double line, okay,
            to sort of say it equates A₁ and A₂. Another times, depending on your
            particular mood and scenario, people will write like a squiggly line,
            okay.</p>
        <p>这个想法就是，人们会思考这个问题。身份认同被认为是空间中的路径。我会告诉你为什么。路径。为什么它是一条路径？好吧，我会把它看作是从 A₁ 走到 A₂ 的一条路径。这是一种说法。另一种说法，我们将会看到，因为我在那里预言的关于振动的想法将利用所有这些，但我将进行一些迭代深化。</p><p>And the idea is that this thing will be thought of. Identifications
            are to be thought of as paths in the space. And I’m going to tell you
            why. Path. Why is it a path? Well, I’m going to think of it as a way of,
            you might say, walking from A₁ to A₂. That’s one way to say it. Another
            way to say it, and we’ll—we’ll see—because that idea I presaged there
            about vibrations will exploit all of this, but I’m going to do some
            iterative deepening.</p>
        <p>这就是我在这里做的。所以你可以把它想象成从这里走到这里。你也可以认为空间是可以变形的，通过沿着那条线移动 A₁，我可以把它一直移动到 A₂。一直移动到 A₁，或者反过来，从 A₁ 移动到 A₂。好的，把那条路径变成一个循环。所以我可以变形它，这样这条路径就变成了这里的一个循环，或者它变成了这里的一个循环，因为识别是一种路径，通过它我可以变形空间，使端点相同。好的。这就是这个想法。</p><p>That’s what I’m doing here. So you can think of it as walking from
            here to here. You can also think that the space is deformable in such a
            way that by moving A₁ along that line, I can move it all the way over to
            A₂. All the way over to A₁ or, conversely, A₁ over to A₂. Okay, to turn
            that path into a loop. So I can deform this so that this path becomes a
            loop here, or it becomes a loop here, because the identification is a
            pathway by which I can deform the space to make the endpoints be
            identical. Okay. That’s going to be the idea.</p>
        <h2 id="paths-in-homotopy-theory">同伦理论中的路径</h2><h2>Paths in Homotopy Theory</h2>
        <p>为什么我将其称为路径，为什么我要这样做？</p><p>And why do I call this paths, and why am I doing this?</p>
        <p>所以，如果你看一下这个自循环……那么现在，现在有一个符号问题。有一个符号问题，即如何符号化。让我把它缩小一点。好吧，假设我们不管它。这就像我把它看作变形一样。但与每个点相关的是——嗯，一个小循环。对不起，没有其他方法可以画出来。有一个小循环，就是那个哪儿也不去的循环。所以问题是，我画不出来。那个哪儿也不去的循环。我一画东西，就去了某个地方。所以，我——你必须明白我把它写成一个小循环，好吗？这就是我的意思。它就是那个哪儿也不去的循环。我不知道还有其他什么方法可以符号化这个该死的东西。</p><p>So, if you look at this self loop… So then now, now there is a
            notational problem. There’s a notational problem, which is how to
            notate. Let me make this smaller. Well, okay, let’s say we’ll leave that
            alone. That’s like I was thinking of that as the deformation. But
            associated with each point is—well, a little loop. I’m sorry, there’s no
            other way to draw it. There’s a little loop, which is the one that
            doesn’t go anywhere. So the problem is, I can’t draw that. The one that
            doesn’t go anywhere. As soon as I draw something, I’ve gone somewhere.
            So, I—you have to understand when I write it as a little one, okay?
            That’s what I mean. It’s the one that doesn’t go anywhere. I don’t know
            any other way to notate the damn thing.</p>
        <p>因此，路径的一个概念是你不——你甚至一步也不迈。你什么都不做，现在你已经从你所在的地方走到了你所在的地方。好的。这就是反身性。是的。那又是什么？你可以说它是一条长度为零的路径。是的，没错。是的，只是在同伦理论中没有长度的概念。所以，这个想法……你知道，这个想法。我也应该提到这一点，因为它是相关的。你必须明白，我们正在从任何几何考虑中抽象出来。</p><p>So, one notion of a path is you don’t—you don’t even take one step.
            You do nothing whatsoever, and now you’ve gone from where you are to
            where you are. Okay. So that’s the reflexivity. Yes. What’s that again?
            You could say it’s a path of length zero. Yes, exactly. Yes, it’s just
            that there’s no notion of length in in homotopy theory. So, the idea…
            you know, this idea. I should mention this as well, because it’s
            germane. You have to understand that we’re abstracting away from any
            kind of geometric considerations.</p>
        <p>没有长度的概念，也没有角度的概念。明白吗？一切都可以随意变形、扭曲、挤压和拉伸，而且永远不会不改变任何东西，因为我们抽象出了任何关于某物有多长或角度可能是什么的概念，这是另一种事物的度量。所有几何考虑都被消除了。所以，我们只关心可能性。但我们经常会使用看起来有点几何的符号和图表。我稍后会给出一个具体的例子。</p><p>There’s no notion of length, and there’s no notion of angle. Okay?
            Everything can be deformed and twisted and squashed and stretched at
            will, and never without changing a thing, because we abstract away from
            any concept of how long something is or what an angle might be, which is
            another kind of measure of things. All the geometric considerations are
            eliminated. So, we’re only concerned with the possibility. But we’ll
            often use notations and diagrams that look a little, you know, geometric
            in a way. I’ll give a specific example of that shortly.</p>
        <p>所以，事情是这样的：总有一条路不会通向任何地方。你可以说它是一个空白的零。没问题。好吗？只要我们明白长度在几何上没有任何意义；它只是惯例。</p><p>So, here’s the thing: there’s always the path that doesn’t go
            anywhere. You could say it’s a blank zero. That’s fine. Okay? As long as
            we understand that length has no meaning geometrically; it’s just
            convention.</p>
        <h2 id="reflexivity-as-null-path">反身性作为零路径</h2><h2>Reflexivity as Null Path</h2>
        <p>所以，那条不通向任何地方的路径就是反身性。如果我有一条从 a1 到 a2 的路径，我可以将其反转。这就是对称性所说的。实际上，我的意思是，如果你可以从 a1 走到 a2，那么就有一条向后走的路径。好吗？它沿着那条路径向后走。我会用这种方式给它一个方向。</p><p>So, the path that doesn’t go anywhere is reflexivity. If I have a
            path from a1 to a2, I can reverse it. That’s what symmetry is saying.
            And really, what I’m saying is, if you can go from a1 to a2, then
            there’s a path that goes backward. Okay? That follows that path
            backward. I’ll give it a direction in this way.</p>
        <p>然后，第三件事是，如果我有另一个点 a3，那么如果有一条从 a1 到 a2 的路径和一条从 a2 到 a3 的路径，那么就有一条路径——即这两条路径的组合——它到这里又到这里，代表了那条路径。</p><p>And then, the third thing is, if I have another point a3, then if
            there’s a path from a1 to a2 and a path from a2 to a3, then there’s a
            path—namely, the composition of these two—which goes over to here and
            goes over to here, which represents that path.</p>
        <h2 id="transitivity-of-paths">路径的传递性</h2><h2>Transitivity of Paths</h2>
        <p>可以吗？我可以这样写。</p><p>Okay? I can write it like that.</p>
        <p>现在，有趣的是，零路径可能性的反身性（我们姑且这么称呼它）意味着，如果我们将这些等同视为等式，那么相等就意味着相等是反身性的。相等对称性的可能性表达了这样一个事实：如果你能走到这里，你总是可以走回来。明白吗？你撒上面包屑，然后跟着它们走回来。明白吗？</p><p>Now, the interesting thing is that the reflexivity of the possibility
            of the null path—let’s call it that—means that equality, if we think of
            these identifications as equalities, means that equality is reflexive.
            The possibility of the symmetry of equality expresses the fact that if
            you can walk over to here, you can always walk backward. Okay? You lay
            your bread crumbs, and you follow them back. Okay?</p>
        <p>传递性，我稍后会解释，即相等的传递性，表示你可以组合路径。原因：如果 a1 等于 a2，因为有一条路径，并且 a2 等于 a3，因为有一条路径，那么 a1 等于 a3，因为有一条路径。但我不会仅仅说如果存在，那么就存在。我说的是，如果你给我路径 p，你给我路径 q，那么这里的路径称为 p ⋅ q（p 后跟 q）。这是路径 p-1，即从 p 向后走。好吗？</p><p>The transitivity, which I’m going to explain in a minute—the
            transitivity of equality—says that you can compose paths. The reason: if
            a1 is equal to a2 because there’s a path, and a2 is equal to a3 because
            there’s a path, then a1 is equal to a3 because there’s a path. But I
            don’t merely say if there exists, then there exists. I say if you give
            me the path p, and you give me the path q, then the path that’s here is
            called p ⋅ q (p followed by q). And this is the path p−1, which is walk
            p backward. Okay?</p>
        <p>所以，这是我们的第一个想法。我们马上就要深入讨论这个问题了。好吗？我还没说够。关于这一点，还有更多要说的，但这就是证明相关数学的美妙之处。好的，所以我们要说，这个属性是有方法的，这很有趣。如果你采用零路径——抱歉，你知道，考虑到我在绘制零路径时遇到的问题——如果这是零路径，如果我把它倒过来，我可以反转它，这意味着我可以从这里到这里，它仍然是零路径。这就是它的意思，好吗？因为我从来没有去过任何地方，所以反向操作仍然不会去任何地方，好吗？这就是这个想法，好吗？是的。这里是……是的。所以这是一个三重等式，是的。这就是你的意思吗？不管是谁说的，我不知道。</p><p>So, this is our first idea. We’re going to get—we’re going to deepen
            this momentarily. Okay? It’s not even—I still haven’t said enough.
            There’s even more to say okay about this, but it’s the beauty of proof
            relevant math. Okay, so we’re going to say there is a way with this
            property, and that’s the interesting thing. If you take the null
            path—sorry, that you know, given my problems with drawing the null
            path—if that’s the null path, and if I run it back, where I can reverse
            that, which means I can go from here to here, it’s still the null path.
            That’s what this is saying, okay? Because I never went anywhere, so
            doing it backward is still not going anywhere, okay? So that’s the idea,
            okay? Yes. Right here is… yeah. So this is a triple equals, yep. Is that
            what you meant? Whoever’s saying that, I don’t know.</p>
        <h2 id="path-induction-for-symmetry">对称性的路径归纳</h2><h2>Path Induction for Symmetry</h2>
        <p>是的，是的。所以，是的。那么，我们如何证明这一点呢？</p><p>Yeah, yeah. So, yes. So, how do we prove this?</p>
        <p>好的。我们要做的是使用路径归纳法来证明这一点。那么，路径归纳法告诉我们什么呢？路径归纳法告诉我们，如果你想展示这些端点之间任意路径的某些东西，展示反身性就足够了。因此，非正式地，假设
            <em>z</em>在<em>a</em>处具有反身性就足够了，其中<em>a</em>等于
            <em>b</em>；它们是相同的。好吧，现在我有一个问题。好的。在<em>x</em>处的反身性，我们称之为在<em>x</em>处的反身性，好吗？这到底是怎么回事？这就是路径归纳法的思想。
        </p><p>Okay. So, what we do is we prove it by path induction. So, what does
            path induction tell us? Path induction tells us that if you want to show
            something about an arbitrary path between these endpoints, it’s enough
            to show it for reflexivity. So, informally, it suffices to assume that
            <em>z</em> is reflexivity at <em>a</em>, where <em>a</em> is equal to
            <em>b</em>; they’re the same. Well, now I have a problem. Okay.
            Reflexivity at <em>x</em>, let’s call it reflexivity at <em>x</em>,
            okay? Which is what is going on? That’s the idea of path induction.
        </p>
        <p>好的。因为如果我想证明某个属性对任意的成立……那么我的属性，对吧，这里的属性就是这个，好吗？所以，我有一个假设，好的，<em>x</em> ……换句话说，这将变成一个<em>j</em>项。这将是我要推导的某个
            <em>j</em>。这就是将要发生的事情，好吗？所以，我要做的是证明我的<em>p 。这将在这里扮演</em><em>p</em>的角色，我们
            稍后会看到<em>p</em>到底是什么。p实际上根本不依赖于<em>z</em>；它只依赖于<em>x</em>和<em>y</em>。所以，这将是我的<em>p(x, y)</em>。它是一个二进制……就像是一个退化的依赖关系。一般来说，属性可以说明 z 的一些情况<em>，</em><em>但</em>我不需要。有问题的属性，即它是<em>y = x</em>的证明，没有提到<em>z</em>。所以，我不……我会把它去掉。所以，这就是我的<em>p(x, y)</em>，好吗？
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>Okay. Because if I want to show some property holds for an arbitrary…
            so my my property here, right, the property here is this guy, okay? So,
            I have an assumption, okay, that <em>x</em>… So, in other words, this is
            going to turn out to be a <em>j</em> term. This is going to be some
            <em>j</em> that I’m going to derive. That’s what’s going to happen,
            okay? So, what I’m going to do is I’m going to prove my <em>p</em>. This
            is going to play the role of <em>p</em> here, and we’ll see exactly what
            <em>p</em> is here in a moment. The <em>p</em> doesn’t actually depend
            on <em>z</em> at all; it depends only on <em>x</em> and <em>y</em>. So,
            this will be my <em>p(x, y)</em>. It’s a binary… it’s like it’s a
            degenerate dependency. In general, the property gets to say something
            about <em>z</em>, but I don’t need to. The property in question, that it
            is a proof of <em>y = x</em>, doesn’t mention <em>z</em>. So, I don’t…
            I’ll drop that out. So, that’ll be my <em>p(x, y)</em>, okay?
        </p>
        <p>因此，这个想法是，只要证明给定<em>a</em>中的
            <em>x</em>就足够了，我需要证明<em>p(x, y)</em>
            对<em>x</em>和<em>x</em>成立。就在这里。由于
            <em>z</em>不起作用，因此只要证明<em>p对</em><em>x</em>和<em>x</em>成立就足够了。因此，我需要证明存在一个<em>x = x类型的元素。当然，有；它是反身性，好吗？所以，我有它。因此，我可以定义</em><em>z</em>的对称性，就像这里写的那样。可以定义为您正在执行<em>j</em> ...哦，顺便说一下，这个东西被称为归纳的动机。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>So, the idea is it’s enough to show that given <em>x</em> in
            <em>a</em>, I need to show that there’s a proof that <em>p(x, y)</em>
            holds for <em>x</em> and <em>x</em>. That’s right here. Since the
            <em>z</em> is not playing a role, it’s enough to show <em>p</em> holds
            for <em>x</em> and <em>x</em>. So, I need to show that there is an
            element of the type <em>x = x</em>. And of course, there is; it’s
            reflexivity, okay? So, I have that. So, therefore, I can define the
            symmetrization of <em>z</em> as it’s written here. Can be defined as
            you’re doing a <em>j</em>… oh, by the way, this thing is called the
            motive for the induction.
        </p>
        <h1 id="type-theory-foundations-4.2-robert-harper">类型理论基础 4.2 — Robert Harper</h1><h1>Type Theory
            Foundations 4.2 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2MBERISGBUYLxoaL2NCOEJjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY//AABEIAWgB4AMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAAAQIDBAYFB//EAFEQAAIBAgMDBwcHCAgEBQUAAAABAgMRBBIhBTFBExRRYZGS0RUiUlNUcdIGBxcjMoGTFjNCRHKhseEkQ1VigqLB8CU0Y3NkZaPi8TVFdIOy/8QAGAEBAQEBAQAAAAAAAAAAAAAAAAECAwT/xAAiEQEBAQADAAICAwEBAAAAAAAAARECEiExQQNRE3GBYSL/2gAMAwEAAhEDEQA/APn4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPXpfJzGVakYRqULydtZPwPT/ACA2ra/OMH35fCScpfhrrXKg6SPyJ2lKtKkq+EzR3+fK3/8AJsL5vdrNf8xgu/P4S/CZXJg6x/N7tZfrGC78/hC+b7az/WMF35/CDrXJg6xfN7tZ/rGC78/hJ+jza3tGC78/hJsMrkgdb9Hm1vaMF35/CPo82t7Rgu/P4RsMrkgdb9Hm1vaMF35/CR9H21vaMF35/CN0yuTB1n0fbW0/pGC1/vz+EP5vtrLfiMF35/CNhlcmDrfo82t7Rgu/P4R9Hm1vaMF35/CNhlckDq38gNqxaTxGC13efP4RL5vtrRV3iMF35/CNMcoDrZfN5taFr4nBa/35/CVl8321opXxGC1dvtz+EbEcoDrZfN5teMU+cYJ36Jz+EfR5tb2jBd+fwjYuVyQOtXzebXc3HnGCulf7c/hH0ebXvZ18Eutzl8I7RHJA65/N3tdW/pGC78/hC+bva7v/AEjBaf35/CO0MciDrfo82unriMEv8cvhJXzd7Xbf9IwWn9+fwjtFxyIOufzdbXX6xgn/AI5/CF83e127c5wN/wBufwjtEciDrvo72vf/AJnA9+fwkS+bva8bXxOB1/vz+EdoOSB1svm82tFXeIwX3Tn8JP0dbX9owXfn8I7RcciDrY/N5taW7EYLvz+El/N1tdfrOB78/hHaI5EHX/R1te9uc4Hvz+Eh/N3tdb8Tge/P4R2i45EHXP5u9rrfiMD35/CPo72v6/BW/bn8I7RHIg6/6Odr+0YHvz+EL5utrv8AWcD35/CTtByAOtj83e15bsRgu/P4S30c7X9pwPfn8Je0XHIA6/6Odr+04Hvz+EfRztf2nA9+fwk7RHIA6/6Odr+04Hvz+EfRztf2nA9+fwjtByAOv+jna/tOB78/hH0c7X9pwPfn8I7QcgDr/o52v7Tge/P4R9HO1/acD35/CO0HIA69fN1td/rGB78/hH0c7X9pwPfn8I7QcgDr383W11+s4Hvz+Ej6O9r+04Hvz+EdoORB130dbX9pwPfn8I+jva/tGB78/hLsTXIg676O9r+0YLvz+Eq/m92sv1jBd+fwjtFelgV/SqT/ALyOxv5hxmDl/Sadn+kjsb3p/ccvw/b01pUX/wARq/d/BHpxvbeeXQ/+o1Pu/gj043sdqxF9ZJ7gvN3lbkt3JikXYur8TGy2+7Rm+0qFUfKNb0XV3fh0FU1e9lusVb100Gb8JIUoTi25NNPrJUOThJqOaXBGS5Vtom2+JiHFyp3kraW9wSTTsrWErohJvcXFz7WixKVmiUrESV3uHlol04rWSu+HUReLtoUcpa7rKxkSjrfg7E39ppnWSSSuyq33auJpRSaejJje13ue4f0eLKNoRzXzW6SUr/cUVRSV79pLm/MyJedvMs7F5NPdoVnln5rTstSW0+hFZaPTV2uFyfbJdtJW3lY3hfMt5ClpdPQN6AxaLiuAzxjwKhpPePPsxbSTvFkU2vOfaMilG3QVjSyKzd7k+mffhkVrdJLaa01McqLkksxNsiW5e4E9S5J70mTGV+BQvBdKFasVqK9rKxLnfVLRdJZ6SvwsVtmDG+4tF3JauNEFoiKWXQL3Q0KQWWUkt3BBFyGnwCkmE73twCoy5V5urLFeUhe19RnTg5R6LipupbsGm9xilVUrpLVPiRCpJtKWhc8TtGbMiTBTee+Z6loq1OVusWJxurybtpp7yVNNpLoua83vSet/3Fo3hK1tEtC5p29xnDIW5X3kmGmO2WUnchVLtrjwJtJyburdBZJaFZVjO7afAlax0JcU0FGysDLqtPWJaxjhJXS6jK2KSRVqyMM2rGZsxSStYNV8/wAJdYqn+0jtU7017jicLK+Kp/tI7NfYRr8TvyatJ/8AEKlur+B6kHoeRSdsfUv1fwPUVRJJ2Z1rC9yzKKV9baDMm9732M2rvq4TIi7olW6hq6IpCbmpPLly9PHrLEq6Lb+kqtVzdSLj+j5zLVm+Skl9q2hF2tGxe4nExaLkl9ZZvqKV7um8ry26C6KzWaLW65n7L7MXjJZVvEWVgrRs3d72yyX3ET6VjFKcpNJ3SSFm80XdqXWS5K5GZF9qYPVZWvN3Frq8YJaJEZosm619xPhUShGWVW+zqi0KcVHzbpxWlyuYtddJKnWK04upTvN5XuaRkTy9dlYpdDNqX5OvupTyoJ5kQ2mRdXCslyYyS3oxp3ZZkRaN9RrKTtuF0OBE1Lmr8SPtbr/eUtqLuLSTWrAvlJgzHy0XUyLVrfu0K8q80Ur2fUE3WblETfXcYJyu91hziKy2ea7s7DC5GxfoEdyuY1LLO3Bq6JUr9JBe5SMvtNrW5NzHUXnRavv6REvwmpfkZW4owypyjZJ+atWuDM0pJJp8RaTWsl9yKcpqmSysnZqRkivqrPoJSXv94JqSYxqKlqk999S0YpXTV7lrLoRNy2nWIbS+yiItvQlNMKyIZ6tbW9yE17xcEVKYc0irlYq3f3FPiJqOyXBX4ERnpd3shJ3sQ1mv0MJ9skZXjcqqqle19CkU46folXTy6pu5cms3cTKShUy236tlZVMzvGT3FpW3tX4BZVpYJlQpeZv1KOrmtKOlnZ3Jy+fmE7W0RV9cBhf+Zg/7yO0i7U/uOKwv5+P7R2Sl9Wr9A/FPXqrUg/6bJ8Wl/A33NqUUuJ5kXJY97stlfsPVcVKK03cTvWFqVW6Wj1JeZO99E7mOKyvc/uMl8zV1ZIxnvpi6tKzcdSW4R00TITG8mRcTmj1EyslolfgVyRa+yVcLLS99+8ZKmar57dsqv+0XjK7SaS6eO4rCd5LM7WKq6k5RV02XL8Mziz6aWktQrXavqijhenZfdfgQo5bvVt7zO1Zb9meTi7pJrq4mSLTqaaLLcxpWT03kqLSjZ2klZimLwmqjmkvsuzIpVFUTdrWCjFa2Kec6lkmle76B9pNZdL2K5nyjhp2iP6Ta37hGynJ8WRohpmXQ9C5VWSD6mBN0L3I94SvuL4XENvP9qytfcSpXu3p1EZlmTtuDcZKSaepln7TGaluLqTzyUrW0sYElFtxbu7XbLunnd30WFhWbMlvRWpOEV5ztcq01Fve7FZwz8nf719w8S/HhyaVVKV2nu1LuNmnFWsVtmkpLgiy1Biy4MOMW09dOsqnZIOWqsQSov9LX7woRjwJi78Bld95Szb6lK0r9RYqtN+ouQTciWqXvDZXVvV7iIvo96F+jUr95KKqW7EXd1pYrFST1d0TcC97i5VBbiIsM1irY3oCbhN8WVbsQ78AqzdwmVF3ewRZsJlSNzAvchu4RDAJt7is9IssRv0KmJWiIkxeyKTZC+OBw6+ui+s679Be45ChpVh7zro6017jX4vl35PMxGOo4fGyU6tKM8qdpytcyx+UEVpy+Ft/3f/aeJtuE3tVONKM/q1vbXSYaeHrS/UqL/wAUvE7Oeul/KGk/67Dfi/yH5Q0uNbC/i/yOeWEr+xUfxJeJPM63HA0vxJDV2uh/KCl67DfirwH5Q0vXYb8VeBz3M6vsNP8AEkTzOqv1Gn+IyG10H5QUvXYb8ZEr5QUnvrYb8WJzzwdT2Cn+KwsHU/s+n+Kym10Hl+j67DfixLL5QUfW4f8AFic5zOp/Z8PxWOZ1P7Ph+KxptdJ+UNH1mH/Fj4kflBRt+cw/4sPE5zmk/wCzo/ijms/7Nj+L/InibXSflBR9PD/iw8R5fpelR/Fh4nNc0n/Z0fxf5Dms/wCzl+L/ACEw2umW3qXTRf8A+2HiS9vQ4cn+JDxOY5rPd5N/9VeBPNJcdm/+qvAeGule3Y8Iw78fEjy4vQj34fEc1zVv/wC2y+6ovAcz/wDLpfirwBtdN5bT/q49+PxFltpeqj3o/EctzP8A8vn+JHwI5l/4Cp+JHwHlNdX5a/6MX/ij8RMds33UV3o/EclzJewVe/HwHMl7DV78fAmRNdd5X1/MLtj8Q8r/APQXbHxOR5kvYavej4EcyXsNbtj4Ew113ld+zxt714l1td8KH714nHczXsNbvR8CHgU/1Kt3o+BcNdktsO35h9q8SVtlK16G73eJxfMY8cFW70fAcxj7FX7Yk6w12r2wmrKh/vtIW1mk/wCjt/795xfMY+xYjtiRzCHseI7YjIa7V7XTt/R5KxD2trph5HFLAw9jxH+UnmNP2PEfuLkNdqtqu+mHl2Ms9qtv/l5r7mcQsDTb/wCUxP7g8DT9lxPYidYa7hbV/wDDVH/hZbyovZp91nC8xp+y4nsXiOZU/ZcV2LxHWI7ryrH2ap3X4DyrDjhqncl4HCrCQ9nxXYvEc1inpQxXYvEnWDuvKsPZqvcl4DytT9nqd2XgcLzZeqxa+7+Y5v8A9PGdn8x1g7nyvS9nqd2XgT5Wp+z1O7LwOFVB+hjOz+ZPIu2scZ2fzHWDuHtinxoVO7LwC2xS9RU7svA4fkX0Yzs/mRyP/wCb3f5jrB20tr0pPSjVX+GXgW8sUstuRq3/AGZeBwzpyvvxvdfiFCXp41f4X4l6w13PlijZXw9Xuy8B5Zo+z1e7LwOGcZesx3dfiRaXrcd3X4k6wd35Yoepq92XgPK9D1NXuy8DhPP9djex+I8/hXxvdfiOsHdeWKHqandfgFtfD+qq9j8DhfrPX47sfiLT9ox3dfiOsHd+V8Ot1Op3X4EeWMP6up2PwOE8/wBpxvdfiTmqe1Y7sl4jrB3L2xhl/V1ex+BC21hr25Kp2PwOGvU9qxvZLxIzVF+t43sl4jrB3T2zhfQqdj8Cj2zhOMKn3/8AwcPnre14zsl4lXOrbXF4vsl4l6wbVB3qRd+J1sH9WvccfSXnRXWjroP6te4z+N2rxdoq+0E/7iM9KF4PWxTHK+OT/uo2KMdNDpXIjLKldb1cundmVU9LEKmsz9xFQokNPMlwM+UhwTIMUY3QleJlUUtBaxVYVuvLQtlMkqcZrzlcnKRGCXmvUmUWkZcpNgNZOyu4vViM1JK0WbNlYKIRrrW6s7hqSV7blqbCjqS4jRrK+bK4mTIZLJk5SDEo66oZTJxJ0RTGLIRk1MzWu4T81J2Q0YsgUDKl5qbW8xxknN2vYhqOTIyGXPHLfUnLpcDDkIcddLmXW1xbVLiXRjyXGQyWeey3LeXykGu4BQ0M+QZbIDDk6hkM6iMoGHkxkM+UZdCIwcmMiM2UZCjFyaI5MzZbDLcDFkQ5NGbKTlsQYOTQyIzOIygYHBdRHJroNhx6CMoGDIuhDk10IzZScoGvya6Aqa6DYykWAwcmuglU10GVInKBgdNdA5NeiZ8oygYOTXQVdNW3Gy4kWCNfk49CMVWnHLuNxrQw1Y+bYo5ul+cXvOrpv6te45Kg/PV+k6unL6te4z+N35NDFq+LX7KNnDrQ18RriV+ybeHWh2c2Vb7E20LqGpZRIrFx9xK1TdtxkeVbwmgMF27OzRfK1FWRlsSZ0YWmrdAV+Ua4WMmVdBMtJLTeEYZJyVkWysyWH2d5VYskm1bRF3HXRF0iSajEqas73IindqW7gZeNkSQxijBK9kRyV5Ny3dBl3Eu6s7XRRRU4xd0iHHXcZEvNXTxC324kGN01LeMiaSavYu4u/Es1oiaijgiIwSW4yWbFukDHkXQSo6bi2V+4lq5RTLpuGWN721LpO+7QSg292hEUSXQTZdBfKLNBWKVkrvgR5uhllFOLdtbEKknvRU+1MuujL5RGnaV/4l7EoplGXqRe2pD13BVcgymS3ULERjcSFGyMtg1YoplCjfcX0LJWRBjVOwcC6EgMOSwymTiQ2o6lGNxCj1GPF7RwmBocrXmld2S3tlMJtrA4trLJRv6SsZ3fh0/j/wCs+QjKZK1SlCDqKSst5RvRW1LLrHLjeKFEZQpXLX69xbGdUyk5TJYJXIrFk9xGW28zWIt1AYXHqMVWGhtZTDXVluKONpfaOrpfmo+45Kk/OR1dKVqUfcPx/LtWvVV68f2TdoLRGnPWtH3G7Q0sdZWI2IktFZSyq9mW1zWZMyhbRkJWnctYgv2qLPc7+8iN/fcyLpIdkr8CeVFYQsrE5Vmv1WL3SK3vNJGd0Slp1iye8kEEKytcWTldbxm6USgiEtW2TfUJ3drbiJOzS6SxViH1ErW6W8WbTstUREqNkRZaMKWqi973EQTcnfcRBNX14ktW+8NcVwJfWX7X7Qosm1yrzRlprcJVLatIJq17LUNa6EKL466hKV7X0aIas2kyH1ERi1a+tt76S0tEtBCF7B62sJxuMl0gHDQrBp8b6CGbM77uAp02ndhErcw0rauxe1ugrO27gFVU079RZx6CFBJF0gkY876GRGd/0WZHG24mPEJ6xqV0tHd7yzUtdFZE6dBkSIuMOV2vZ7y1832VuMiXSMtgVjhfitWVnTle6k9eBmt1AGMLpyTvo2edtXH0cNQlCU1y1l5vE9axz3yow1Hk41pUqcqk5ZczV2kh8/JJ64/amMqYqs5zle25X3GlDEzpvRs28VTgoysl52ukdx5srp2OkzF5Svbw+2JKk1OUm7W3nabKqPEbLw1WbeaVNXZ8uUj6rsilyWysLTe+NKKfYLJDd+W3yaW7puQqaTutOkyWBz1nFWrC2jsW3kNaaAQ0VZe1t40fAoqYa+4zmKstArhaX2kdTT/NR9xysX5ysdRSf1MfcPx/LrVZfnY+43qBoX+tj7jeoSXSdMYbDjdWJS1XUrFhfoG60iSvoRZ2txLEl+BRq0VG+4nLmikWsnvQ3E+hW2a1+BayTbCCJ81MHFS1dySeG8gzCIcbu7FknddhKdyeIEON5EqKtrqRcsh6glYavXcL6kiqrlV721JJtZEq17O1yCrRNsxNnwKx13ATkea7ZE3ZXvoXMbtK6XAMjkk7MhySsS7b7dYaW96liLJWvxKuzsrlo+6wa6UQTdO9uBVTWqd9CSFGKlmtqQHKLdktSYzWW+tkVlbNdKzsTZW3FP7I1FN6J26RUel0mySFdb2BGZpWtu49JMJ5lusGGr7gLXuyVusYYys9bmSTdlYYuLu1hGSMUp5UeTtKPKuM+UqwcPVzcdBg96NnxElY4OrtXH7LxCnQxE8RhpfZdTX/AGz39l7VliqUasp3vo0+Bmt5K9tuyBiVWMkrl86ZXNY8P5W029lqqt9OX7noe1e63lK0Y1YOnOKlGSs0+IHy6U5VIKLbyp3SNepRzant7awuAwWNlSw+JvKP2qTTvDjv3HjTrSqT5OhFtvdZas3GtjBCjFTTqSSXFH0nYG0Y7SwPKQpumoPJZu+6xxOG+T2LrpSquNJPp1Z1mwMJDZlN0YzlLO7tvpN2eMx7wZAOIm5KaKFiokEaixAMNXcZb33GGtdIprg07SR1FKX1MfcckpWkjq6TXIR9xeDrT+sj7jew1rs0Yp5o+43sOrT+46YzGzeV9dxOZWuLO+4lwb6BsUi9bWLW6Ckadnv1L3fSSxSUrK9iL+bexNtAyefAq5WjcmDzX0Ja0Ctq0rF+kS+BRN6eb2l94lpYzhiFoQnveuhkstOsNDZRSndK8lvIs8ytuL3IE8PhEk8yfAn9O9rlrqy6wt+gvoK7kyJXUrpFr7ukrfMRMQpybtYu2knZBIh7xmmK5ZunvdwlJR6y436DUzIr5zilu0LK1t24pN3sl7hDRSS3CwXum+JC0u2RDWKfSTGV21bcRUp6XI1vcmTSW4q5brBkkm9xZGJuSje9zJeyvqKtOOjGvEjPpxK1ZNLQSIsWRijJ5VfeWjNN24jBLt0Ihyb3FYSvJ9Bb9G3EvwMM21vNDExbTN6qn0mtUWoHgY7AOvG8HZ9HBmthMRiNmVUq0HyR0UqSb0MNTDqSs0mLJVnLF8NtfC1muSqq/GL0sehDERlvZy2L2VlbqYZZZL9HgWwG0pQlyVXzWukz7G5nJ1ymnxNbaeNWCwFWvvlFWiumT3GnSxVOSuqm7oPPxWJxFbF1qdWUJ4NWcLLW/QONnK4nLhjmJYXGbQrTr1NZzfnSatc6TY2xKWHgqk7ubK1K9PDpaW42NCvtTETk4wqSjBeizvHN0k5Qpu10ugwrExzuzVzmFtCrm+tm5J6O+/3mWniZRqb+KYo7bC4hVqafHiZ7nibGxF6sqd98cx7Ebreznyir3JU10MrdIJrgZSLu73MPqI9wQX/hfoMVbcZdxhrBHz2F3JHVUn9VH3HK0vtI6ek/qY+4vB1rPT1lH3G/Rim03ftNCgtY+49GijprLOtEWKotYY0J21CebcmS0iIxtxJZoRlmk10FpaFsqvcrJXZPmp8qtO2m8ngrC1tSWyyLiIX1bWgalms7W4FlrvJf2rv7jN3UVd010Imbvu0sWtqRl6iGKRzPeuwW869t5ktYhovmmMbi4rRX95a2qa0LqNyJw1VyfKJtbeiii7KzZkIegi4q4tplY3je0UzKgoNO9xqVRJ2V9CckkGmyykuJr36VVRfQRKk3eztcyXIZhPRRsVVNRldGRahojKkkra6lct423e4vKLdrMsUYOTvFdRkymS2hDQtGJO4kk95ksiGuBBjsVypO9i8laxCKYJLoSDFtCJMDFUTZrSXSbctxryiXRgSaJy33ktWBRinA0MXs+niI3atLhJbz1JK5RxA5t4bHYOV6X1kOrebOKrU6MYyl+ctdpbr2PQ2hVjhsNKrLSyOQrYt1puUuJeM+1t8xlrYiVapq+tlN0DFR86o7O90ZKj4GmWKW64pVHub3aDgYYvzmB0mwaze0qMb74STOu32OK+TXnbVj1U3/AKHZ3MchciLvuCZN1HgQxZMm5WKLWIRXUxVTKjDXVogkfP6e86al+Yj7jm6a85HRUX9QvcXg61tYfgenR3HnYRXSPUox3HTz7Rkirl9AkWysrSq6ybWJSJsyCqTZDRks1vDiTUY2hlLNMlIeqpYskWUNCcpdlRCJsSlYsl1HOwrG0Lpb0WaHJ9Jcz5MUs76Mn3lsra0IcJIZoh2Q06C+XpRDjwQkEWGpbIwlZ+ciYitiGk9xdQcmTyeUvwKxQdo70XSaCjmut5nExVRsLFlZLiwtb6biZUsqhEot7i0U0yZebvL9mZVSL3JTzbkRLTeTPpEO/Agta5GVgYpXe4hJ8TI1lWpVRutC6uqOXHgUk77jKoNLUxWWtzUwVTKsyKD4lXHUlK15rUKNnqZXHXcMupdGNq6IcfcZspixD5OhOpwimyI5b5SYmVaqqEdIQ39bPAlC29m/i5uvVlJvezUlBR3tHRFsGl57XUTVvc1pRbaSdvcVVOtfST+9gxnbtFvqMUFqHysVlnazL00k7sD3/knSvja9T0YKPa/5HXROf+SVF8zrVGvtzt2I6GMWusxy+VSrFrak26gZQRYhq1iGm3o7BR6GGtqjYtfgYKkGkEfPYS1Oioa0o+452nHzr8DoqP5pe4vB15PQwe5HrYeJ5OGjkjGTnF9Vzep41Q9HvnS+xI9BQLqBoradlup98jyur2yw75rY09JUZEZDQ8saaZO+Qtr62yw7/wDIzN+016Cj0hx6EaK2tp9ml3/5EeVf+13hnq7G7k6UVUbuxqeVf+33jH5Saknnp26Cmx6mS28lU77uGp5y2uuKpv72RPbFloodrMpselkuXjTvpoeQts9UF95Plfqh2sXia9WNNcSHBLceX5Ve9Sgir2vLpgM99Neqo23luTb4X+88nyq+mn+8eV5elDsYsLY9fk2lrEiVPLa55XlhvfKH7w9sN75Qf3Mkhr1LIW6jyfK76afYyfK396n2MuQ2PWdNwe8soqV7Kx472tL0qfYyFth3sqkE31Mlm/KV6yj0mWEY62Vjw/K73Zod1k+WGv6yC90WOXHVuV7P1fo/uMbXuXuPI8rv1kO6w9rS9OHdZZIePaVLik7dZWa0Xm3R4/lep6yNvcyPK0vTj3WZ6+o9h0HplVhKkopXjc8d7YqcasO6w9sTe+rF/wCFjKj1VFLeiXTTjdrQ8byvL1ke6w9sStblV3WLxLj1nFOO52EYaaI8fyu/WR7rIe2Jeu/yvxJ1HqOnK25kuCS+z+48l7Zlb8+uxmN7Yfrv8pcNevybX2k2Q423pnivbUn/AF/+Ux1NtS4V/wDKXNR7vJ3e4clZK/A5x7dqr+vfYUlt+t6//KTqOmdJ8Voebt6XJbKqvp0PHfygre0Pumrjtq1cXhnSnVzq97ZbFkxHjTbTMTbZmkr3bME6iTtBa9JpCFP6xNvUy7mRF5IW4veynKLizF9bniKus17jNSoSqOMYq8m7JGBVFKd8p6Wy5OGMp1FdWdzcZrttkYHmeBpUWtUtbdJvxp5d+p5ENpJK3KVHbpSZm8qxf9ZPuIxVem6T4InkrLWx5S2rp+cqd1FfKkvTl2IdUyPWUehE8mzyVtSV9Jy7EUntGqnrOXYhmpkew4ZUYK0Wo9ZoQ2k5ayqSa+4vLH05qznUf3ImH9OJgjZ53U5NRurIrfZkMPUtUxk6zXmebGMb9erNHlJ7syM5Z9u2t+O0cTFZYuLS6UStpYuXGHYednl6SIzy4TLtTx6Uto4n0o9hVbQxPpQ7DBRlhHRfOJ1+VvpkStb7y6lgOM8RbqjHxJtanGVkW0MT6Ue6W5/ifTj3Tz6ko8pLkpyyX83MtfvKZp+mi+/tjx6nPsT6a7pDx2I9bHsR5uefprsIcpP9Im39nj1OfYj1q7EHjcR61d1HlXn6QzT9P9w9/a+PSePxPrV2Ih47E+vXdR5t5en+4a+muwvv7R6HPsT6/wDyoPH4lf1/7kaGvp/uFnxn+4bf2N/yhiPXvuoLHYj177ERhMbQw8nKeEpVtHZTvo+02FtijrfZmC6rQfiWf2tkYOe4m+taXYiXjcR7Q+xFdoY6ljI01SwtHDON7umvtGjr6X7ie/tHoc7xL/r32InneJa/PvsR5+vpi79Jj39jfeKxPr5diHOsTxry7EaF5emxeXpse/sejznEe0S7ERy9fjXl+48+8vTkLy9OQ9/Z43+cYi/5+RV4uutOXkaV5enIrlvvcmPf2N7ndb18u0ssVW9fPtPPyrpZsYKtDDYmFWdGNeMd9Oe56F/1Gxzmr6+faTCrXn9mtUfuZCxlFVZT5lSeZ3yvNZe7UyUtpyo4qNejT5G0MrhTbUX1iZ91qfLG6tfMlytXXrYqTr05ONSpVi1wbaPVj8qqsUksNDTjqYsXt+GMzSrbPoSqS0dRxvKxLn1VyPKdep66p3mQ61S356p3mbi2nhowUfJmHduLzX/iWhtahTv/AMKwk29PPi3/AKj/AFLI8/l6vraneY5ap62feZsc8w19Nm0O9U+IxxxVKFflVgaDXq3ncf43L/rLFys/Wz7zI5WfrJ95mzLH0W7+TcMu/wDEYqmKpzd44OjT/Zzf6thrIxcpP05drIlJv9KXabcNp5KcYcwwkrK15UtX+8U9qcmpJ4DBTT4To3t9+8vn7ZaOZv8ASfaVb632m7LaUW7+T8IvdTfia2JxKr7sPSp6W+ri1/qRcjFfrfaZsO0ozvdmo/vLRk8loyy6ljNZ6rctFpHiYbKPncOAp0XOTnKd1HVmGvUzS6EaSJnUuVTuysacpK5eMGuANZqdtFZI38NeMk1J36zz4e82ac7dZUZ6kkqsvPdr9JTlF6T7TXn5022uJFl6P7zk22VNek+0Zlf7T7TWyr0BlXo/vIN7D1nSqcpCcozirxae5mLG4nFY5RWJxFSooNuN3uvvM+zcOpYfEVMnBRT9/wD8B4ZosuJXm82Xpz7S9KlKlVhUhUmpQalF33NG6qN5ZU/O32J5tIvZGnykeiPYTni+ESLIolvMurJnj0RIzx6ipK3gTnXURmXUSypBOddQzLqK7wUWzLqJzx6ipJBOePURmRDIuUXzjP8A7sVAFs3+7DlGQAic4zlSQJ5TrGf3kEoBnGcEXAnP7xn95CAE5veMz6xcXAZn1jN7yStgJze8Zn1iwQRblH1kco+slENahTO+shzfWPcAIzvoYzvoZIAjM+hjM+hgBEXfQyMz6GWIYFcz6A5PoZJDKKuT6CjkWkVaCIbfQVbfQSCopKrKGidrmLV6svVW4iFOpUdoRlJ9SudIiE2pXu7mRVZ9Jkhs7G1PzeDxEvdSk/8AQ38N8mNr4jzuaTox9Kv9X/HUI81VpdCLwrTlZLQ36vyfr0ZOFTG4BSW9LExbXYbFD5KbXnTVSlho1acleM4VItSXVqS1XmKT6C2Z9B6cvkztmG/AVPuaf+piqbE2pT+1gMR91Ns5tNHM+gnO+g2Hs3Hx+1gsSvfSl4GOphcRSjmqUKsIrjKDSIrpdgYKVXYzqW+3Vb+5aeJty2bL0T2vk3hlT+T2Eiop5oZu3X/U9Lkaet4GrwrNs3HD4f5Pxw+IqVoym3PenuRsz2c1Byy7kdcqEMqzRSfUYNpxp0NlYqrZebSk/wBxOXGyM9nyplVxLsouJl2CUQSgJZVlmVYBAIkAGAwIZC3kkcSixBJBBJBJMYuTSS1Aqldm9hNlYzFu1KjJrpsehsXAYZ1YzxM07cDp3tLDUEqVK1luSFa48deJg/kjN2liq8YdUdWb7+Suz8uk6l+k3Xj4ON00VePilqzG116cXhYz5I1orNha0anU9GeFjNn4rBSy4ijKHW1odzPHqyyyRZY3D4hOjiYwcXwkWcqxy4T6fO0D1tr7Np0K0nQfmt6I8m1mbckklSSCWVJIAlEogASQAAQLZGQ4tFxNQyC1usq1YASQCAyrLCKu7Wf3K7LCqBkyVnpe3WiGUUlvKss95DAqb2E2rXwtJQhGlZbs1NM0SCpLj24/KbHQ+y6EfdSR6EflJXmo8rjai01UVb+COViryS6zbdK3AnK/9X5dHS29CKali5yT38pKUv4lfK2BWuaDfTeWv7zwKOHz1oRa0ckj3a+yKEZaR4HHln3WlpbWwcnpXyroTkiPKmA0vVi2uLbua72ZQ6CvkyiuBn/yuVurbOFUrrFSv/3J+JWW1MLKo5raGIg3wjiKiXZc0/JtK/2SXs2iv0S7P2mPQjt6nTso7RrS/aqSZSt8oIVYpVMbJq97XZoeTqPohbOpeiXZ+zHq0flTyMMsMXp1xv8A6F38r5ccWvw/5HjrZ9H0Sy2dRX6I2GPTfywnwxT7n8iH8r5vTnL/AA/5HmvAUvRJ5hS181DYY8dlVxLFVxOgEogkCSAAIRJCJAEsgAQyFvJZC3lFiCSCCS2bItN5Uxzlc3xjPKtiGIlH7MmjYhi5p3lK558JW3l81zWMyvXp46pPRPQ2a+LSoJJ70eLSm4u6ZerUvFO5Mb7M0sfUT0kY5Y6rLXNqakne5jzFxntW/LHTnHLN3NeTza8TWctTJTkLE1cAHJsAIAkkgAStXYltQWu8jPkkYqlaPA3xjNqXUk2VeImjHnIvc3jLYhiFJ2n2mSUtbP7jTVk0XUtyJYazAReZXBzvjYdL8mtk54xxVepySqaU+mWpzR0myoOCwdVVJOMbO2bRG/xz1L8NzE7C57tWrRwWOowtHM4uGZ77M53bmzZ7Lx/N6laNWTipOUY5VrwsehV2Xjq1epVw8lFyk3mzWsjydp4aeExbpVKmeaScn1m+VtnqRpPeQWe8qcmlSCxBUWpK9WH7SPanSVzx6C+vp/tL+J0VSKu7I5c2uLXoU0q8H0SR7uI+0vceTRjarD3o9jFNOxx5VtqtK+pWS1LPUhmVVS1KvpZcrLVgGYqtanRV5yUTDtDGLC0bq2eWkUc/LETqTc5ycn1nbh+Pt6xy5Y9ue0ItXpxf3kU8fKSu1HTrPGVaVrJ6F41Onedv4+LHavdhjKU3Z+bLoZnb0OYqVXm3nq7NxbrUZQm7yj/A5c/x5NjU5fTzmyq4mnzyp0R7Bzup0R7Dt1qdo3SUaPPKnox7Bzyp0R7Cdado3iDS55U6I9g55U6IjrTtG6gaXPKnRHsHPKnox7B1p2jeBo88qdEewc8qdEewdado3SFvNPndToj2Ec7qdES9ado3gaXPKnRHsHPKnox7Cdado3TE2a/PKnRHsK84n0RN8ZYzbKz3sSpmry8uhDlpdCNI3lULOqnGx5/LS6hy0uohraciuY1+Wl0IjlZdCKNlbzKnZo0lXkuCLc5nfdElHoA0eeVOiPYOe1OiPYc+tb7Rug0ueVPRj2DnlToj2F607RvIk0OeVOiPYOeVOiPYOtTtGWrNuT95jvqYnWk3wI5R9CNsM3EXtIw8pLqHKPqKMzepe6Zrco+ocrLqA3qL1aMpp4THTwuIhWVOlUcf0akbxfvPTfyorPfs3Zv4L8THKXWpWuzNSlek4cpTSb3TX+v+95P5T1v7N2b+A/E82vj51q86vJUoOTvlhGyXuVy8Nl9TlddjsmtRwOz3U5ODm4SWeO+Xnaanj1aHOtrUqdSTjy8oqUui5qbP+UWJwEFCOGwleKVkq1Ny436SuJ+UGKxFWrU5DC03USVoUlaO7de9tx052VOPjtX8g8M/s42r3EV/IKg92NqdxeJz+G+X218Ph4UuTwtTKrZ5wlmfvtJFvpA2x6vC9yXxHP8AxuWPZXyEpylZY6ovfR/mS/m/T+ztHXro/wDuPI+kTa/s2B7k/iKT+cDbE3fksJH3Ql8RPf0bGHH7CxeyMbRWJinSnUSjUjqnr+497mcJrSomznsX8s9pYzDOhXo4WUG0/sO6t95qR+UeNitIUex+Jz5cLyWcpHXRwShJO+4nFazVug5X8qsf6FDuy8SJ/KjGzd3Sw/dl4nO/i5VrvHTK/EiSOY/KXGerod1+I/KTGerod1+JP4eR3jprecVkjmfyjxnq6HdfiPyixb/q6HdfiP4eR3jb+UMWuRlrxR4psYza9fGUlCpCkkne8U7/AMTS5WXUen8fGyZXPldrYUrby2c1eVl1DlZdRtlsN3N7ZErYiSfGJ5XLS6jLQxtTD1M8IwbtbVGeU2YsawANIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2Q==">11 年前 (2014 年 1 月 3 日) — 37:02 <a href="https://youtube.com/watch?v=6JMiMdXjbrE">https://youtube.com/watch?v=6JMiMdXjbrE</a></p><p> 11
            years ago (Jan 3, 2014) — 37:02 <a href="https://youtube.com/watch?v=6JMiMdXjbrE">https://youtube.com/watch?v=6JMiMdXjbrE</a></p>
        <h2 id="summary-10">概括</h2><h2>Summary</h2>
        <p>本视频讨论了类型理论的基础，特别关注平等。罗伯特·哈珀 (Robert Harper) 展示了在意向类型理论中平等是如何对称和传递的，并将其与外延类型理论进行了对比。关键思想是，在意向类型理论中，平等的证明具有结构，而外延类型理论则将平等视为一个命题。视频最后介绍了预群的概念，以及如何将类型理论中的平等理解为空间中的路径，从而引出了环空间和路径同伦的概念。</p><p>This video discusses the foundations of type theory, specifically
            focusing on equality. Robert Harper demonstrates how equality is
            symmetric and transitive in intentional type theory, contrasting this
            with extensional type theory. The key idea is that in intentional type
            theory, proofs of equality have structure, unlike extensional type
            theory, which treats equality as a proposition. The video concludes by
            introducing the concept of a pre-groupoid and how equality in type
            theory can be understood as paths in a space, leading to the notion of
            loop spaces and path homotopies.</p>
        <h2 id="motivation-for-induction">归纳动机</h2><h2>Motivation for Induction</h2>
        <p>好的，这就是你进行归纳推理的原因。动机，好的，在这种情况下，归纳推理的动机是 x = y。好的，这就是动机。论证是 x ⋅ x 的反身性。这是归纳步骤。我进行证明的是 z。现在，检查如果我取 sim 并代入任何 a 的反身性，那么根据定义，这就是 j。我会忽略动机 x ⋅ a 的反身性和 a 和 a 的反身性，因为这就是我正在做的。事实上，j 的定义相等表明这是代入 x 的 a 和 x 的反身性，也就是 a 的反身性，这是我开始的。所以我们是对的。</p><p>Okay, it’s sort of the reason why you’re doing the induction. The
            motive, okay, so the motive for the induction in this case is x = y.
            Okay, that’s the motive. The argument is x ⋅ reflexivity of x. That’s
            the inductive step. And the thing I do that proof on is z. And now,
            check if I take sim and I plug in reflexivity for any a, then by
            definition, that is j. And I’ll miss out the motive x ⋅ reflexivity of a
            and a and reflexivity of a, because that’s what I’m doing. And indeed,
            the definitional equality for j says that this is plug in a for x and
            reflexivity of x, which is reflexivity of a, which is what I started
            with. So we’re right.</p>
        <h2 id="symmetrization-of-paths">路径对称化</h2><h2>Symmetrization of Paths</h2>
        <p>好的，我已经展示了如何对称。现在，一秒钟后会发生一件非常有趣的事情，但让我们继续。现在我已经向你展示了如果你有一条路径，空间中的任何路径，我都可以反转它，我将其称为 p 或 p-¹ 的模拟。</p><p>Okay, so I’ve shown how to symmetrize. Now, a very amusing thing is
            going to happen in a second, but let’s keep going. So now I have shown
            you that if you have a path, any path in a space, I can reverse it, and
            I’ll call that sim of p or p⁻¹.</p>
        <p>是的。如果我们只有外延身份而非意向身份，那么我们就无法展示这一属性。</p><p>Yes. If we only had extensional rather than intentional identity,
            then we wouldn’t be able to show this property.</p>
        <h2 id="extensional-vs.-intentional-identity">外延身份与意向身份</h2><h2>Extensional
            vs.&nbsp;Intentional Identity</h2>
        <p>我们不会……哦，当然，你会。是的。原因是，想想看。如果我在研究外延类型理论，如果我有 a = b 的证明，那么我可以说 a 在判断上等于 b。判断相等被公理化为等价关系。所以，由于 a 在判断上等于 b，b 在判断上等于 a。因此，我有一个元素，即身份的反身性 b = a，因为……在外延的情况下，因为我取了 a = b 的证明，忘掉它，将其转换为判断 a = b，应用判断的对称性。所以我得到 b = a，然后我将其重新插入形成证明……b = a。</p><p>We wouldn’t… oh, sure, you would. Yeah. And the reason is, think
            about it. If I’m working in an extensional type theory, if I have a
            proof that a = b, then I can say that a is judgmentally equal to b. And
            judgmental equality is axiomatized as an equivalence relation. So since
            a is judgmentally equal to b, b is judgmentally equal to a. And
            therefore, I have an element, namely reflexivity of identity b = a, for…
            for in the extensional case, because I take the proof that a = b, forget
            about it, turning it to the judgment a = b, apply the symmetry of the
            judgment. So I get b = a, and then I insert that back into forming a
            proof that… that b = a.</p>
        <p>好的。但是你会得到更少的信息吗？嗯，从某种意义上说，是的，因为……是的，你无法以同样的方式谈论这些证明对象。这就是我所说的。在外延类型理论中，你对平等采取一种不懈的命题态度。它要么成立，要么不成立。如果它成立，它就具有某些属性。</p><p>Okay. But would you have less information? Well, yes, in a sense,
            because the… yes, you don’t get to say something about these proof
            objects in the same way. That’s what I said. In extensional type theory,
            you take a relentlessly propositional attitude toward equality. It
            either holds or it doesn’t. And if it holds, it has certain
            properties.</p>
        <h2 id="loop-spaces-and-path-homotopy">环空间和路径同伦</h2><h2>Loop Spaces and Path
            Homotopy</h2>
        <p>所以你没有提到证明的结构。证明的结构被抹杀了。因此，外延类型理论看起来就像传统数学，只是它是构造性的。原因是，正如我们现在所知，从同伦理论的角度来看，外延类型理论是同伦集理论，离散空间理论。因此，在离散空间中，传统数学就是在那里完成的。所以，当然，它看起来像传统数学。外延类型理论是一种更简单、更熟悉的机械化推理工具，因为它基于使用集合的普通传统数学。然而，如果我们想要使用更丰富的空间概念，那么这种方法就不再适用了，我们需要一个更全面的框架。然后，当我们这样做时，我们必须做很多与证明相关的结构。好的。是的。</p><p>So you don’t say anything about the structure of the proofs. The
            structure of the proofs is obliterated. So in this way, extensional type
            theory looks like conventional mathematics, except that it’s
            constructive. And the reason is, as we now know, that extensional type
            theory is the theory of homotopic sets, discrete spaces, from the point
            of view of homotopy theory. And so, in discrete spaces, that’s where
            conventional mathematics is done. And so, of course, it looks like
            conventional mathematics. Extensional type theory is a much easier and
            more familiar tool for mechanizing reasoning because it’s based on
            ordinary, conventional mathematics using sets. However, if we want to
            work with richer notions of space, as we will, then this approach is no
            longer applicable, and we need a more comprehensive framework. Then,
            when we do that, we must do a lot of proof relevant structure. Okay.
            Yes.</p>
        <p>请再说一遍。扩展恒等式是否大于意向恒等式？我的意思是，你能证明更多的平等吗？嗯，你可以证明更多的判断平等，当然。就像，根据定义，你可以马上这么说。呃，对于碰巧是集合的类型，恒等类型的居民将是相同的。我很确定。我必须考虑一下。它应该很漂亮。它应该是那种保守的扩展。只是类型不是一般的集合。同伦类型理论的教训是——我正在——我正在为此做准备。这堂课的妙语将是：类型是弱欧米茄组男孩。我必须讲到这一点。这就是我想要讲到的。</p><p>Say that again, please. Is the extension identity bigger than the
            intentional identity? I mean, could you prove more equality? Well, you
            can prove more judgmental equality, certainly. Just like, by definition,
            you can say that right away. Err, the inhabitants of the identity type
            for types that happen to be sets will be the same. I’m pretty sure. I
            have to think about this. It should be pretty. It should be a
            conservative extension in that way. It’s just that types aren’t sets in
            general. The lesson of Homotopy Type Theory is—I’m—I’m building up to
            it. The punchline of this lecture is going to be: types are weak omega
            group boys. I have to get to that. That’s where I’m trying to get.</p>
        <p>是的。在板子的底部，您有 sim z = jxy x = y。为什么是 x = y 而不是 y = x？哦，可能应该是 y = x。我可能应该是。现在，好吧，让我看看我的笔记。好的。这是我警告过您的一个例子。从技术上讲，我可能会搞砸一些事情。是的。y = x。抱歉。因为您要将 a 和 b 代入 x 和 y，所以您希望它显示为 b = a。是的。所以，无论……谁说的？我忘了是谁说的。你说的。所以，你说得对。我犯了一个错误。好的。我还会犯更多这样的错误。对不起。</p><p>Yep. On the bottom of the board, you have sim z = jxy x = y. Why is
            that x = y and not y = x? Oh, it probably should have been y = x. I
            probably should have been. Now, well, let me look at my notes. Okay.
            This is an example where I warned you. I’m probably going to screw
            something up technically. Yeah. y = x. Sorry. Because you’re going to
            plug in a and b for x and y, so you want it to come out b = a. Yeah. So,
            wherever… Who said that? I forgot who said it. You said that. So, you’re
            quite right. I made a mistake. Okay. I’m going to make some of these
            more of these mistakes. I’m sorry.</p>
        <p>好的。昨天我费了好大劲，因为我确实需要向你展示这些东西，以便你理解。另一方面，我在董事会上能完成多少事情而不把事情搞砸，以及你能消化多少事情，都是有限制的。所以，我试图在这里走一条路。好的。有点棘手。但我确实需要让你看到细节。</p><p>Okay. I struggled mightily yesterday because I do need to show you
            these things in order for you to understand it. On the other hand,
            there’s a limit to how much I can pull off at the board without screwing
            it up hopelessly, and how much you can possibly digest. So, I’m trying
            to walk a line here. Okay. Tricky. But I do need to get you to see the
            details.</p>
        <h2 id="proof-of-transitivity-of-equality">相等性传递性的证明</h2><h2>Proof of Transitivity of
            Equality</h2>
        <p>好的。</p><p>Okay.</p>
        <p>现在，下一个是传递性。这要难得多。好的。所以我会向你们展示这一点。但我们已经处于一个令人着迷的情况，即相等是对称的，这是一个定理，它将成为一个定理。因此，我们在这里要提出的另一个命题是：在形式一中，我们会说 a 处的相等是传递的。因此，通常情况下，你会说，对于 a 中的每个 x、y、z，如果 x = y 且 y = z，则 x = z。我想我甚至说得没错。好的。所以，这将是通常的设置。这意味着我表明这种类型对所有 x、y 和 z 都是正确的。如果你不介意我这样堆叠量词，我会说以下类型为真：x = y，y = z，x = z。我说这是真的；也就是说，它有一个居民。好的。</p><p>Now, the next one is, which is the transitivity. It’s much harder.
            Okay. So, I will show you this. But already we’re in a fascinating
            situation where it’s a theorem that equality is symmetric, and it’s
            going to be a theorem. So, another proposition we’re having here is: we
            will say, in form one, we’ll say equality at a is transitive. So, in the
            usual way, you would say, for every x, y, z in a, if x = y and y = z,
            then x = z. I think I even stated that right. Okay. So, that would be
            the usual kind of setup. That would mean I am showing that this type is
            true for all x, y, and z. If you don’t mind me stacking up my
            quantifiers like that, I’m saying the following type is true: x = y, y =
            z, x = z. And I’m saying this is true; that is, it has an inhabitant.
            Okay.</p>
        <p>所以我真正的意思是：如果你给我——让我稍微写一下——让我把它写下来。A 中的 x、y、z，你给我一个证明 u，证明 x = y，以及一个证明 v，证明 y = z，我希望我做对了。然后会有一个称为传递性的证明，u ⋅ v，它将是 x = z 的证明。它至少会具有这样的性质，如果我取自反性和自反性的传递性，那就是反射性。</p><p>So what I really mean is: if you give me—let me be like a little—let
            me write it up. x, y, z in A, and you give me a proof u that x = y and a
            proof v that y = z, I hope I did this right. Then there’s going to be a
            proof called transitivity, u ⋅ v, which is going to be a proof that x =
            z. And it will have the property, at the very least, that if I take
            transitivity of reflexive and reflexivity, that’s reflectivity.</p>
        <p>所以传递性——这个 trans——我要定义，它将由 j 定义。所以我要——它要被定义。好的。我们要定义这是表达相等传递性的最好方式，就像这是最有信息量的方式，至少据我所知，对吧？它是——它不仅告诉我们是否存在各种证明，还告诉我们是否存在其他一些有点松散的证明。好的。它告诉我不，不。我可以作为一个程序为你计算。如果你给我一个这个的证明和那个的证明，我就会得出那个的证明。好的。我会告诉你那个——那个连接到底是什么。好的。</p><p>So transitivity—this trans—which I’m going to define, this will be
            defined by a j. So I’m going to—it’s going to be defined. Okay. We’re
            going to define that this is the nicest way, like this is the most
            informative way to express transitivity of equality, at least that I
            know of, right? It’s the—it it not only tells us if there exist various
            proofs, then there exists some other proof that’s a bit flabby. Okay. It
            tells me no, no. I can compute for you as a program. If you give me a
            proof of this and a proof of that, I’m going to crank out a proof of
            that. Okay. I’m going to tell you what that—what that concatenation
            really is. Okay.</p>
        <p>因此，我们这里的图像是：我是说，如果有 p、q，通常写成 p ⋅ q。因此，在这个符号中，这里的符号通常是 u ⋅ v，有时写成 v 和 u 的组合。这在某种程度上是不幸的，因为出于同样的原因，将零路径写成恒等式有点不幸，因为它将它与函数混淆，这有点将它们与函数混淆。它使 v 和 u 看起来像是函数，而你正在组合它们。</p><p>So the picture that we have over here is: I’m saying if you have p,
            q, it’s often written p ⋅ q. So in this notation, the notation here will
            often be u ⋅ v, and sometimes it’s written v composed with u. For
            the—and that’s unfortunate in a way, because for the exact same reason
            that writing identity for the null path is a little unfortunate because
            it confuses it with a function, this sort of confuses them with
            functions. It makes it look like v and u are functions, and you’re
            composing them.</p>
        <p>好的。但这是有原因的，因为马上就要发生一些事情了。好的。这实际上是有道理的，但是让我们——比如，我们倾向于将其视为一种数据结构。这只是路径的连接。是的。好吧，有些人这样做。所以在《同伦类型理论》一书中，我们就是这样写的，⋅。好的。我试着坚持这一点。好的。所以它只是意味着路径连接。换句话说，我们——我倾向于从数据结构的角度来看待身份类型，该类型的元素是路径，你可以用它们做的事情包括将它们自然地连接在一起。图中的路径具有这种结构，不是吗？我的意思是，这就是正在发生的事情。应该清楚的是，图中的路径是边的连接。好的。</p><p>Okay. But there’s a reason for this, because of something that’s
            coming up in a minute. Okay. It’s actually well justified, but
            let’s—like, we’ll tend to look at it more like a data structure. And
            this is just concatenation of paths. Yes. Well, some people do that. So
            in the Homotopy Type Theory book, we did—it’s written like that, ⋅.
            Okay. I’m trying to stick to that. Okay. So it just means path
            concatenation. So, in other words, we’re—I’m tending to take a data
            structurey viewpoint of the identity type, and the elements of that type
            are paths, and the things you can do with them are, like, amongst other
            things, slam them together naturally enough. Paths in a graph have this
            structure, don’t they? I mean, that’s what’s going on. It should be
            clear that a path in a graph is a concatenation of edges. Okay.</p>
        <p>所以，现在的问题是如何证明这一点。让我给你一个想法。希望我不会把事情搞得太糟。</p><p>So, the question now is how to prove this. Let me give you the idea.
            Let’s hope I don’t screw it up too badly.</p>
        <p>好吧，这里有一个你可能知道也可能不知道的技巧。这个技巧在很多情况下都会出现。它被称为 Una Lemma。</p><p>Okay, here’s a trick that you may or may not know. It’s a trick that
            comes up in many settings. It’s called the Una Lemma.</p>
        <p>当您处理预排序时，您想要证明 x 小于或等于 y。这是一个非常有效的技巧。令人惊讶的是，通过使用此技巧，证明几乎可以像变魔术一样经常奏效。</p><p>When you’re working with pre orders, you want to show that x is less
            than or equal to y. Here’s a trick that works a lot. It’s amazing how
            often proofs can be made to work almost by magic by employing this
            trick.</p>
        <p>要证明 x 小于或等于 y，只要证明对于每个 z，如果 z 小于 x，则 z 小于 y 就足够了（这是必要且充分的）。这就是诀窍。这就是范畴论中所谓的 Unaid 引理的预序形式。</p><p>To show x is less than or equal to y, it’s enough—it’s necessary and
            sufficient—to show that for every z, if z is less than x, then z is less
            than y. This is the trick. That’s the pre order form of what’s called
            the Unaid Lemma in category theory.</p>
        <p>所以，你相当于在范畴中说，要展示从 x 到 y 的映射，只需统一展示就足够了——这就是自然性的概念——任何到 x 的映射都可以变成到 y 的映射。如果你能做到这一点，那么 x 和 y 之间就存在映射，反之亦然。</p><p>So, you’re sort of saying in categories, to exhibit a map from x to
            y, it’s enough to exhibit uniformly—that’s the idea of naturality—any
            map into x can be turned into a map into y. If you can do that, then
            there’s a map between x and y, and vice versa.</p>
        <p>为什么？因为假设右边的式子为真。将 z 取为 x 并使用反身性。在自然推理中，你首先说证明是考虑恒等式，即 x 小于 x 的证明。然后你会说，将其取为 x，你会得到 x 小于 y。</p><p>Why? Because suppose this is true on the right hand side. Take z to
            be x and use reflexivity. In your natural deduction, you start by saying
            the proof is to consider the identity, which is the proof that x is less
            than x. Then you will say, taking this to be x, you will get x is less
            than y.</p>
        <p>所以，这已经足够了。显然，由于传递性，这也是必要的。这是一个预序。</p><p>So, this is sufficient for that. Clearly, it’s also necessary because
            of transitivity. It’s a pre order.</p>
        <p>所以，我想知道的是，如果确实如此，为什么会这样？</p><p>So, what I want to know is, if this is the case, why is this the
            case?</p>
        <p>嗯，如果 z 小于 x 且 x 小于 y，那么根据传递性，z 小于 y。这是一条非常简单的注释。</p><p>Well, if z is less than x and x is less than y, then by transitivity,
            z is less than y. It’s a very trivial remark.</p>
        <p>但你会大吃一惊。我可以给你出一些难题——我必须自己想出来——比如在格子中，我要求你证明这一点，而你似乎并不确定该怎么做。做出巧妙证明的秘诀就是这样做。这种情况经常发生。然后类固醇版本就是你在类别中的自然引理。好的，这就是我们要在这里做的事情，好的。所以我只是想提醒你，这个技巧是存在的，好的。</p><p>But you’ll be astonished. There are some puzzles I can give you—I’ll
            have to think them up—like in lattices where I ask you to prove this,
            and it’s like you’re not really sure what to do. The thing that makes a
            slick proof is doing this. This happens a lot. And then the steroidal
            version of that is your natural lemma in categories. Okay, so that’s
            what we’re going to do here, okay. So that I just wanted to remind you
            that there exists this trick, okay.</p>
        <p>所以这就是我要做的，好吧。现在，看我把事情搞砸了。我想我能做到，好吧。让我们小心点。所以我要做的是，我要说这足以证明以下事情。让我看看我的笔记，好吧，因为我向你保证我会把事情搞砸，好吧。所以，好吧。这足以证明，假设我们有 x 和 y，有一个函数，我们称之为 g sub u，好吧，它的类型将是，对于 a 中的每个 z。</p><p>So here’s what I’m going to do, okay. Now, watch me screw this up. I
            think I think I can do it, okay. Let’s watch out. So what I’m going to
            do is I’m going to say it suffices to show the following thing. Let me
            look at my notes, okay, because I I guarantee you I’m going to mess this
            up, okay. So, okay. It suffices to show that, given well, we have our x
            and y, that there’s a function, we’ll call it g sub u, okay, whose type
            is going to be, for every z in a.</p>
        <p>我要做的是说 y 等于 x 的所有东西都等于。所以我希望我做对了。如果 y 等于 z，那么 x 等于 z。所以我声称这就足够了。为什么？因为如果我有这个，我就可以定义 trans。Todd 无疑会注​​意到我可能会犯一个错误，他会告诉我我的错误是什么，但我相信我会取 g sub u 并将其应用于。</p><p>What I’m going to do is I’m going to say everything that y is equal
            to x is equal to. So I hope I get this right. If y is equal to z, then x
            is equal to z. So I claim that that’s sufficient. Why? Because if I have
            that, I can define trans. Todd will will no doubt notice my I’m probably
            going to make a mistake, and he’ll tell me what my mistake is, but I
            believe that I’m going to take g sub u and apply that to.</p>
        <p>所以我必须选择 az 和 y 等于 z 的证明。好吧，我的第二个假设 v 是 y 等于 z 的证明，这就是我需要的。所以我会选择 z 为 z，也就是说，我会选择证明为 v。如果我没搞错的话，这将是 x 等于 z 的证明。Todd，我做对了吗？</p><p>So I’m going to have to pick a z and a proof that y is equal to z.
            Well, my second hypothesis, v, okay, is a proof that y is equal to z,
            and that’s what I’m going to need. So I’ll pick my z to be z, so to say,
            and I will pick the proof to be v. And if I didn’t mess it up, that will
            be a proof that x is equal to z. Todd, did I do that right?</p>
        <p>好的，是吗？好的，很好。到目前为止，我还没有搞砸。问题是有很多方法会让人感到困惑，我设法找到了每一种方法，好的。当你这样做时，你必须真正基于这个技巧，好的。所以这个技巧是，如果我想显示 x 等于 z，这就是我在这里做的。显示就足够了，对吧？如果 y 等于 z，那么 x 等于 z。</p><p>Okay, is that right? All right, good. So far, I haven’t screwed it
            up. The problem is there are ways to get discombobulated, and I managed
            to find every one of them, okay. When you do this, you have to it’s
            really based on this trick, okay. So the trick is if I want to show x is
            equal to z, it’s a that’s what I’m doing here. It’s enough to show,
            right? Every if y is equal to z, then x is equal to z.</p>
        <p>这就是我想要做的，好吧。这就是我的想法。所以问题是我必须定义 g sub u，好吧。所以我们同意吗？所以我必须定义 g sub u。你同意我的观点吗？所以如果我定义 g sub u，那么传递性就是这样，好吗？顺便说一下，当我定义 g sub u 时，g sub u 将通过对 u 进行归纳来定义。将是 u 上的路径归纳。</p><p>That’s what I want to do, okay. So that’s the idea. So the problem is
            I have to define g sub u, okay. So that’s do we agree? So I have to
            define g sub u. Do you agree with me? So if I define g sub u, then
            transitivity is this, okay? It will turn out, by the way, in which I
            define g sub u, g sub u will be defined by induction on u. Would be path
            induction on u.</p>
        <p>当我定义它时，结果将是我们会看到的。我还没有证明这一点，但结果将证明 g sub u 本质上是恒等映射，恒等函数。我们会发现 g <sub>u <sub>(v) 将等于 ruffle grefle。这就是我想说的。对不起。g refel on raffle 在定义上等于 ruffle。事实上，如果我没记错的话，我甚至可以证明对于任何 v，grefel 在 v 上将是 v。我最终会证明我还没有证明这一点，但结果会是这样。因此，trans raffle raffle 将是 ruffle。好的。没关系。这就是结果。一旦我完成对 gu 的定义，结果就会是真的。</sub></sub></p><p>And when I define it, it will turn out that we will see. I haven’t
            proved this yet, but it will turn out that g sub u is going to be
            essentially the identity map, the identity function. We are going to
            find that g<sub>u<sub>(v) is going to be equal to ruffle grefle. That’s
                    what I want to say. Excuse me. g refel on raffle will be definitionally
                    equal to ruffle. And in fact, if I’m not mistaken, I can even show for
                    any v, grefel will be on v will be v. I’m going to end up showing I
                    haven’t shown that yet, but that’s what will turn out to be the case.
                    Therefore, trans raffle raffle will be ruffle. Okay. So that’s okay.
                    That’s what this is going to be. This will turn out to be true as soon
                    as I finish defining gu.</sub></sub></p>
        <p>好的，那么我要在这里做什么？所以我把它写成 gsubu，以强调 g 的代码依赖于 u。我要利用 u。所以我要做的是做一个 j。所以 gu 好的将是 aj，并且它将具有一定的动机。好的。但它要做的是它将是在 u 上运行的 aj。好的。这就是我要做的。好的。</p><p>Okay, so what do I want to do here? So I wrote it as gsubu to stress
            that the code for g depends on u. I’m going to exploit u. So what I’m
            going to do is I’m going to do a j. So gu okay will be aj, and it’s
            going to have a certain motive. Okay. But what it’s going to do is it’s
            going to be a j that runs on u. Okay. So that’s what I’m going to do.
            All right.</p>
        <p>所以现在我想要的是从 x = y 推理。这就是 u。所以假设 u 是反身性的，并且这是 x = x 就足够了。好的。所以我需要的是——让我只写 w。我们需要 aw，它的类型将是 Πz ∈ A。如果 w = z，那么 w = z。因为我的动机将是 x，y，Πz ∈ A，y = z → x = z。</p><p>So now what I want is I’m reasoning from x = y. That’s what u is. So
            it’s enough to assume that u is reflexivity and that this is x = x.
            Okay. So what I’m going to need is—let me just write w. We’re going to
            need a w, and the type of this is going to be Πz ∈ A. If w = z, then w =
            z. Because my motive is going to be my motive is going to be x, y, Πz ∈
            A, y = z → x = z.</p>
        <p>这就是动机。所以如果我需要证明 w 和 w 的动机，那么就意味着我要证明 Πz ∈ A, y = w, w = z → w = z，这就是我这里所写的。哦，但这很容易做到，对吧？因为我可以在这里写 w 的函数只是 λz，λ——我不知道我的字母用完了——r。好的。也就是 w = z。点 r。取 z，将其纳入 w = z 的证明，并返回该证明，因为这是 w = z。我完成了。天哪。我想我真的做到了。好的。这是——这是完全正确的——我确信我会搞砸的。</p><p>That’s the motive. So if I need to prove the motive for w and w, then
            it means I’m going to prove Πz ∈ A, y = w, w = z → w = z, which is what
            I have here. Oh, but that’s quite easy to do, right? Because what I can
            write here as a function of w is just λz, λ—I don’t know what I’m
            running out of letters—r. Okay. Which is w = z. Dot r. Take in z, take
            into proof to w = z, and return that proof because that’s w = z. And I’m
            done. Holy. I think I actually did that. Okay. This is the—this is the
            exact correct—I was sure I would mess this up.</p>
        <p>好的。现在，只需检查一下，由于 j 的定义，如果你在这里插入反身性，j 的定义等价性表示它计算并将其反身性的 a 插入到这里。好的，看起来就像这样，好的。你知道，是的，顺便说一下，w 出现的地方，你可能会说，“w 去哪儿了？”它实际上在这里的类型中。这是类型：w = z。然后整个东西是一个类型：w = z。所以这就是 w 去的地方。好的。如果你把它插入，那么它就会插入，你会得到这个等式。好的。这会起作用。好的。这就是证明的核心。</p><p>Okay. So now, just to check, because of the definition of j, if you
            plug in reflexivity here, the definitional equivalence of j says that it
            computes and plugs in the a that it’s reflexivity at into into here.
            Okay, which will look like that, okay. And you know, yeah, where the w
            appears, by the way, you might say, “Where did the w go?” It’s really in
            the type here. This is the type: w = z. And then this whole thing is a
            type: w = z. So that’s where the w went. Okay. And if you plug it in,
            then it’ll just plug it in, and you will get this equation. Okay. This
            will work. Okay. That’s the heart of the proof there.</p>
        <p>现在，我想说几句。我的发言有点长，但我开始得有点晚，对此我深表歉意。让我用一张照片来结束发言。好的。</p><p>Now, I want to say something. I’m running a little long, but I
            started a little late, which I apologize for. Let me let me finish up
            with a picture. Okay.</p>
        <p>那么，这两个……是的，继续。这是一个类型，这是这个 λz λr r λz λr r 的类型。</p><p>So, these two… yes, go ahead. This is this is a type, and this is the
            type of this λz λr r λz λr r.</p>
        <p>现在，事情是这样的。传递性有不止一个证明。你可以在这里想出另一个。从某种意义上说，这是最聪明、最不聪明的证明。我不知道。不，我甚至不想这么说。这是另一种方法。这是一种使用单位二难推理的方法。还有另一种方法。就是说，“哦，不，不，不。我们将对 u 和 v 进行双重归纳，我们将说考虑 u 和 v 的反身性就足够了。”所以考虑 a 就足够了，然后展示如何定义什么……展示如何定义它的传递性。把它当作练习。你可以这样做。这是一个不同的证明。传递性有很多不同的证明。好的。这就是传递性的证明，我说完了。</p><p>Now, here’s the thing. There’s more than one proof of transitivity.
            You can come up with another one here. Here’s the most, like, in some
            sense, the most, the least clever. I don’t know. No, I don’t even want
            to say that. Here’s another way to do this. This is one way to do it,
            which uses the unit a dilemma. There’s another way to do this. Is to
            say, “Oh, no, no, no. We’re going to do a double induction on u and v,
            and we’re going to say it suffices to consider reflexivity for u and v.”
            So it suffices to consider a, and then show how to define what… show the
            how to define the transitivity for that. Do that as an exercise. You can
            do that. It’s a different proof. There are a bunch of different proofs
            of transitivity. Okay. So that’s the proof of transitivity, and I’m
            done.</p>
        <p>但我觉得向你展示会很有趣。知道这个技巧真是太方便了。所以如果你知道这个技巧，它就会一次又一次地出现。你会明白的。好的。所以我想让你知道这个技巧。所以我把它扔在那里，只是为了好玩。好的。好的，很好。</p><p>But I thought it would be cute to show you. It’s so damn handy to
            know this trick. So if you know that trick, like it’ll come up over and
            over. You’ll see. Okay. So I want you to know that trick. So that’s why
            I threw that in there, just for the hell of it. Okay. All right,
            good.</p>
        <p>所以，无论如何，即使错了，我也欺骗了你。所以这很好。我要说……现在我要说好。我们认为这已经完成了。好的。</p><p>So, at any rate, even if it’s wrong, I fooled you. So that’s good.
            I’m going to… now I’m going to say good. We’ll consider that done. All
            right.</p>
        <p>现在，在董事会上处理细节真的很难，因为我……很难让你听我的话，也很难把所有事情都讲清楚。好的。现在我们有了我描述的这个结构。现在有一件有趣的事情。</p><p>And now it’s really hard to do details at the board because I… it’s
            hard to keep you with me and get everything across. Okay. So now we have
            this structure that I’ve described. Now comes an interesting thing.</p>
        <h2 id="pregroupoid-structure-of-equality">等式的预群似结构</h2><h2>Pregroupoid Structure of
            Equality</h2>
        <p>所以你首先注意到的是我所做的，可以说，相等是具有证据的等价关系。好的。这个结构被称为……好吧，我们在这里。我将其称为预群。到目前为止，我们拥有的。我将向你展示我的意思。所以当我有一个预群时，它的意思是它是一个代数结构，其中我有一个单位元。引用。我可以写出……的引用。好吧。</p><p>So the first thing you notice is what I’ve done is, so to speak, that
            equality is an equivalence relation with evidence. Okay. And that
            structure is called… well, we’re here. I’ll just call it a pre groupoid.
            What we have so far. And I’m going to show you what I mean. So when I
            have a pre groupoid, what it means is it’s an algebraic structure in
            which I have an identity element. Reference. I can write refle of a… All
            right.</p>
        <p>像这样，有一个逆的概念。我有一个复合、乘法的概念。所以，这是我的乘法。这是我的逆的概念，这是我的恒等元或单位元的概念。我们称之为单位。如何避免过分强调恒等这个词？好的。它看起来很像一个群的结构，但它不是一个群，因为这些东西的端点不同。它们从一个空间到另一个空间，对吧？</p><p>Like this, have a notion of inverse. I have a notion of composition,
            multiplication. So, this is my multiplication. This is my notion of
            inverse, and this is my notion of identity element, or unit element.
            Let’s call it unit. How about to avoid overloading the word identity?
            Okay. It starts to look a lot like the structure of a group, but it’s
            not a group because the end points of these things are different. They
            go from one space to another, right?</p>
        <p>因此，我们从 a₁ 到 a₂，然后从 a₂ 到 a₃，然后从 a₁ 到 a₃。因此，它们相对于这些恒等式来说无处不在，但它们具有这种类似于群的结构，称为群胚。我会说是前群胚。至于它之所以是前群胚，我现在可以按如下方式进行设置。我可以画一幅图。前群胚的概念是这样的。因此，这就是这些结构的存在，我现在已经向你们展示了。</p><p>So, we go from a₁ to a₂, and then a₂ to a₃, and then we get from a₁
            to a₃. So, they kind of live all over the place with respect to these
            identities, but they have this kind of group like structure, which is
            called a groupoid. And I’ll say a pre groupoid. And the reason it’s a
            pre groupoid, I can now set up as follows. I can draw a picture. The
            notion of a pre groupoid is this. So, that’s the existence of these
            structures, which I’ve now exhibited to you.</p>
        <p>是一个预群词，也就是说，我通过展示这个预群结构，以与证明相关的方式向你们展示了相等是一种等价关系。好的。现在——我不会——我要结束这个话题了。现在有一件有趣的事情。你们已经可以感觉到我要说什么了。我希望它们满足一些代数定律。好的。所以，成为一个群意味着它们表现正常。</p><p>Is a pre group word that is, I’ve shown you in a proof relevant way
            that equality is an equivalence relation by exhibiting this pre groupoid
            structure. Okay. Now comes—I won’t—I’m going to finish on this note. Now
            comes an interesting thing. You can, you can feel already where I’m
            going. I want these to satisfy some algebraic laws. Okay. So, to be a
            groupoid means that they behave properly.</p>
        <h2 id="groupoid-properties-and-higher-homotopy">群胚性质和高阶同伦</h2><h2>Groupoid Properties and
            Higher Homotopy</h2>
        <p>好的。它的意思是这样的。如果我写一点速记，raffle 逆必须等于 ruffle。所以，嗯，好吧，让我把它们写下来。你会期望那样，对吧？你会期望单位元素。所以，如果我乘以单位元素，我什么也不做。如果我在右边乘以单位元素，我什么也不做。所以，我期望那样。我期望逆性质，我期望结合律。这将使它成为一个群胚，除了我所说的相等是什么意思？</p><p>Okay. And what it means is this. If I’ll write a little bit of
            shorthand, raffle inverse has to be equal to ruffle. So, ah, well, let
            me just write them down. You would expect that, right? You would expect
            unit element. So, if I multiply with the unit element, I do nothing. If
            I multiply on the right with the unit element, I do nothing. So, I
            expect that. I expect the inverse property, and I expect associativity.
            That would make it a groupoid, except that what do I mean by
            equality?</p>
        <p>这就是问题所在。所以，非正式地说，我要说我有这个结构，现在我想展示的是群胚性质成立。那么，这些群胚性质成立意味着什么呢？所以，哦，我——我漏掉了一些东西。我——我确实需要它，但我——我——我——我——我真正需要的是什么。我漏掉了一个。我漏掉了一些东西。哦，是的。我漏掉的是 p 与 p 逆组成的是 ruffle，而 p 与 p 组成的逆是 ruffle。</p><p>That’s where the rub is. So, informally, I’m going to say I have this
            structure, and now what I want to show is the groupoid properties hold.
            Well, what does it mean for those groupoid properties to hold? So, oh,
            I—I missed something. I—I do need that, but I—what I—what I—what I—what
            I really need. I missed one. I missed out something. Oh, yeah. The one I
            missed out is p composed with p inverse is ruffle, and p inverse
            composed with p is ruffle.</p>
        <p>你必须填写所有的小 a 和 b 等，以确保它们都正确无误，但这就是——这就是想法。所以，我需要它。所以，让我们专注于最后两个，因为它们很适合在黑板上画出来。所以，让我们展开。让我们看看这个。让我们看看这张图片。所以，让我们画画。我会画一些画。让我为你画一些画，因为乐趣从这里开始。好吧。如果这还不够有趣，我们真的要打开加力燃烧器，我会给你看一些可能会让你大吃一惊的东西。好吧，让我们这样做。</p><p>You have to fill in all the little a’s and b’s and stuff to make
            those all really correct, but that’s the—that’s the idea. So, I need
            that. So, let’s focus on these last two because they’re they’re nice to
            diagram on the board. So, let’s expand. Let’s look at this. Let’s look
            at this picture. So, let’s draw. I’ll draw some pictures. Let me draw
            some pictures for you, because this is where the fun begins. Okay. If
            that wasn’t fun enough, we’re really going to hit the afterburners, and
            I’ll show you something that will probably blow your mind. Okay, so
            let’s do that.</p>
        <p>让我们看看这样的东西。把它们想象成空间中的路径。如果我从这里走到这里，好的，我们可以给它们命名。我可能不需要名字，但让我们给它们命名。我在这里做 P。我们已经说过，还有一种向后走的方法，我们称之为 P 逆，事实上，还有一种留在原地的方法，叫做 refl。我总是很难画出来。好的，如果我走到这里再走回来，这里有一个真正的自我循环，也就是 P 后面跟着 P 逆。如果我带着这个家伙回来，我在 a 处做了一个循环。我们就把它叫做 a。我们把它叫做 b，但我认为我不需要名字。所以这是 refl，a，它不会去任何地方，这是一个大循环。好的。</p><p>So let’s look at something like this. Think of these as paths in a
            space. If I walk from here to here, okay, we can give these names. I
            probably don’t need the names, but let’s give them names. And I do P
            here. We’ve said that there’s also a way to walk backward, which we’ll
            call P inverse, and there is, in fact, a way to stay where you are,
            which is called refl. And I always have trouble drawing that. Okay, so
            if I walk over here and walk over here back there is a real self loop
            here, which is P followed by P inverse. If I take this guy and come
            back, I’ve made a loop at a. Let’s just call that a. We’ll call that b,
            but I don’t think I need the name. So this is refl, a, the one that
            doesn’t go anywhere, and this is some big loop. Okay.</p>
        <p>我要问的问题是：去那里再去那里再回去和哪儿也不去之间有什么关系？对吧？这就是我的想法。</p><p>And the question that I’m asking is: What is the relationship between
            going out and back there and back again and never going anywhere at all?
            Right? That is the idea.</p>
        <p>好了，现在，我们开始启动。好的。什么？这些方程在哪里发生？让我们看看。类型是什么？让我们用类型写出来。P。好吧，让我们把它们都写出来，尽可能明确。A 在 A 中，B 在 A 中。这就是我们所处的空间。我有一条从 A 到 B 的路径，还有一条从 B 到 A 的路径——哦，称之为 P，P 逆——好的，从 B 回到 A。好的，这就是我拥有的数据。我还有一条从 A 到 A 的路径。是的，所以这就是——我只是——我只是在画图。我只是想总结一下那幅图里的所有内容。好的。</p><p>Well, now, here, now we hit the afterburners. Okay. What? Where do
            these equations take place? So let’s look. What is the type? So let’s
            write it out with the types. P. Well, let’s write them all out just to
            be as explicit as possible. A is in A, B is in A. That’s our space we’re
            in. I have a walk from A to B, and I have a walk or a path from B—oh,
            call that was P, P inverse—okay, from B back to A. Okay, that’s the data
            I have. And I also have a walk, a path, which goes from A to A. Yes, so
            that’s—I’m just—I’m just charting. I’m just like summarizing everything
            that’s in that picture. Okay.</p>
        <p>然后，由于组合，我有 P 后面跟着 P 的逆，那在哪里？那是从 A 到 A 的路径。好的。所以，在术语中，从一个点到自身的路径称为循环。所以我有两个循环。显然，它被称为循环。这是一个循环。嗯，抱歉，零循环，你看不到的循环，以及一个大循环。现在，这是有史以来最伟大的东西。好的。这些东西是类型。</p><p>And then, because of composition, I have P followed by P inverse is
            where is that? That is a path from A to A. Okay. So, in the terminology,
            a path that goes from a point to itself is called a loop. So I have two
            loops. Obviously, it’s called a loop. Right here’s a loop. Well, sorry,
            the null loop, the one you can’t see, and a big fat loop. Now, here is
            the greatest thing ever. Okay. These things are types.</p>
        <p>A 等于 A 是一种类型。这被称为——这是 A 处的循环空间。好的。根据定义，这是基于 A 的 A 的循环空间，这是基于 A 的 A 处的循环空间。这被称为循环空间。好的。如果循环从 a 到自身多次遍历，人们会将 a 视为一种基类型，一种具有独特点的类型。然后您讨论该类型的循环空间。但在这里，不诉诸基类型，我只会说：对于任何类型，讨论基于 a 的循环空间。好的，这就是我们要做的。</p><p>A equals A is a type. This is called—this is the loop space at A.
            Okay. This, by definition, is the loop space of A based at A, and this
            is the loop space at A based at A. This is called the loop space. Okay.
            If the loops they traverse from a to themselves many times, people will
            think of a as a based type, a type with a distinguished point. Then you
            discuss the loop space in that type. But here, without resorting to base
            types, I’ll just say: for any type, discuss the loop space based at a.
            Okay, so that’s what we’re going on.</p>
        <p>所以，这是 a 处基的环空间。这就是它的正式完整定义。这些是类型。是的，因此，讨论这些环（这些类型中的点）是否相等是有意义的。也就是说，它们之间是否有路径？所以，我们现在要讨论的是——这个环是否等于环空间中的这个环，即 a=a 和 a？</p><p>So, this is the loop space of a base at a. That’s officially the full
            definition of what that is. Those are types. Yes, therefore, it makes
            sense to talk about whether these loops, which are points in these
            types, are or are not equal. That is, is there a path between them? So,
            we’re now going to talk about is it—is it or is it not the case that
            this loop is equal to this loop in the loop space, which is a=a and
            a?</p>
        <p>因为这个有那个类型，这个有那个类型，所以问这些是相等的，是有意义的。好的。如果我出去再回来，我想知道。是，不是，不是。这个类型就是那个。这是这种类型的符号。哦，是的。它们全都是——我到处都是等号。所以，这个符号——这是那种类型的符号。这就是我的意思。是的。抱歉。是的，你被那些等号迷住了。对不起。好的，好吧。</p><p>Because this has that type, this has that type, and it makes sense to
            ask, are these equal? Okay. I would like to know that if I go out and
            back. Yes, no, no. This type is that. That’s the notation for this type.
            Oh, yeah. They all—I got equal signs all over the place. So, this
            notation—this is notation for that type. That’s what I meant. Yep. Sorry
            about that. Yeah, you get carried away with those equal signs. I’m
            sorry. Okay, all right.</p>
        <p>所以，关键是：我们在做什么？我们在做的是，看，我们从类型 a 开始。现在，让我们看看——这一切都在 a 中。我们可以在 a 中查看它，但现在我们通过 a 处的循环空间，这是另一种类型。这里有一些点：其中一个点是 a 处的 riffle；另一个点是 p 与 p 逆连接。我们要问的是，它们之间有路径吗？或者，从图形上讲，我有——让我们看看，我有什么好方法可以画出来？我有 riffle，这是一个点，我有 ap，另一个循环，p⋅p-¹。我在问，有没有办法将这个循环或这个循环变形为那个循环？它们之间是否有连接它们的路径？</p><p>So, the point is this: so what are we doing? What we’re doing is
            we’re saying, look, we started out with the type a. Now, let’s look
            at—so this was all in a. We can look at it in a, but now we pass through
            the loop space at a, which is another type. And in here are points: one
            of the points is riffle at a; another point is p concatenated with p
            inverse. And what we’re asking is, is there a path between them? Or,
            pictorially, what I have is—let’s see, what is a good way for me to draw
            this? I have the riffle, that’s one point, and I have a p, another loop,
            p⋅p⁻¹. And I’m asking, is there a way to deform this loop or this loop
            into that loop? Is there a path between them that connects them up?</p>
        <p>更一般地说，我们感兴趣的问题不仅仅是循环，而是是否有一条路径 p 和一条路径 q 在某个 a 和 b 之间。在我们的例子中，我们有 a 和 a。这里有点难以形象化。画图会容易一些。问 p 和 q 是否相等就是问这个单元格是否可以填充。是否有一个证明项，我们称之为 α，它将两者联系起来？</p><p>More generally, we’re interested in questions, and not just about the
            loop, but if I have a path p and I have a path q between some a and b.
            In our case, we have a and a. And it gets a little hard to visualize
            here. It’s a little easier to draw a picture. To ask whether p and q are
            equal is to ask whether this cell can be filled. Is there a proof term,
            let’s call it α, which relates them?</p>
        <p>这里的这个表面就是 α。另一种非常有用的描述方法是，你可以把它看作是两个映射之间的映射，称为 α，它是路径 p 在路径空间中可以沿着它移动到 q 的连续变形。表面表示点 p 可以沿着它滑动到达点 q。如果没有表面，也就是说，如果没有 α，那么它就相当于空间中的一个洞，人们用一种符号来表示它。</p><p>And this surface here would be α. Another way of depicting it that is
            very useful is you can think of this as a map between maps called α,
            that is a continuous deformation of the path p can be moved along in the
            space of paths to q. The surface indicates that point p can slide along
            it to reach point q. If there were no surface, so to speak, if there
            were no α that would correspond to a hole in the space, and there’s
            notation that people use for that.</p>
        <p>我认为是 Peter Fried 做的。它被刺破了。我想他会写一些类似的东西。我认为这是符号，接近于那个符号。有时人们会试图明确地表明那里没有东西。好的，只是为了帮助你。好的，如果它被刺破了，如果那里什么都没有，那么你就无法进行变形，因此，它们是不同的路径。但声称在这种特殊情况下存在这样的 α。所有这些都会有见证人。</p><p>I think Peter Fried did it. It’s punctured. He would write, I think,
            something that looks like that. I think that’s the notation, something
            close to that. Sometimes people will try to indicate positively that
            there isn’t something there. Okay, just to help you. Okay, so if it’s
            punctured, if there is nothing in there, then you cannot do that
            deformation, and those are, therefore, different paths. But the claim is
            there is such an α in this particular case. There will be witnesses to
            all of these.</p>
        <p>路径之间会有路径。好的，这让这些方程成立。在这种情况下，我们有一个群胚，直到所谓的高阶同伦。因为这里有一个有趣的事情发生。因为 p 和 q 之间的变形这个概念被称为路径同伦。我可以将 p 变换或滑入 q 的想法是路径的同伦。好的，这就是术语。这个想法被称为同伦、路径或路径同伦。</p><p>There will be paths between paths. Okay, that make those equations
            come true. In which case, we have a groupoid up to what is called higher
            homotopy. Because there’s an interesting thing that is going on here.
            Because this idea of the deformation between p and q is called a path
            homotopy. The idea that I can transform or slide p into q is a homotopy
            of paths. Okay, that’s the terminology. The idea is called a homotopy, a
            path, or a path homotopy.</p>
        <p>好的，这就是这个特殊情况下的 α。好的。所以这个想法是群胚定律符合高阶同伦性。也就是说，存在见证者，变形告诉你如何从 p 到 q。这是一个同伦性。所有这些都有同伦性。也就是说，我们可以填写——都在热门书中——我们可以为每一个填写代码。现在到了令人震惊的事情。我们会到达那里。所以这些都是。它们都可以填写。所以这些方程符合高阶同伦性。它们在定义上不成立。</p><p>Okay, that’s what α is in this particular case. Okay. So the idea is
            that the groupoid laws hold up to higher homotopy. That is, there exist
            witnesses, deformations that tell you how to go from p to q. That’s a
            homotopy. And there are homotopies for all of these. That is, we can
            fill in—and it’s all in the hot book—we can fill in code for each one of
            these. And now comes the mind blowing thing. We’ll get there. So these
            are all those. They can all be filled in. So these equations hold up to
            higher homotopy. They don’t hold definitionally.</p>
        <h1 id="type-theory-foundations-4.3-robert-harper">类型理论基础 4.3 — Robert Harper</h1><h1>Type Theory
            Foundations 4.3 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2MBERISGBUYLxoaL2NCOEJjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY//AABEIAWgB4AMBIgACEQEDEQH/xAAbAAACAwEBAQAAAAAAAAAAAAAAAQIDBgQFB//EAEwQAAIBAgMEAg0HCgQHAQEAAAABAgMRBBIhBTFBURORBhQiMlJUYXGBkqHR0hUWF0JTYpMHIyQzNENEcrHwY5TB4SVVgoOi4vGjNf/EABgBAQEBAQEAAAAAAAAAAAAAAAABAgME/8QAIhEBAQEAAgIDAAMBAQAAAAAAAAEREiECMQNBURMyYXEi/9oADAMBAAIRAxEAPwD5+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6y7H8U/wB5Q9Z+49HDdg208TSVSFfCJPnOXwmZ5S+muFjMAaep2C7Tpd9Xwm+2k5fCTj2A7VkrrEYP15fCaTjWVA1f0f7V8YwXrz+Ef0fbW8YwXrz+EHGsmBq/o/2r4xgvXn8IfR/tXxjBevL4SavGsoBq/o/2r4xgvXn8I/o+2t4xgvXn8I2JxrJgav6P9q+MYL15/CH0f7V8YwXrz+EbF41lANX9H+1fGMF68/hD6P8AavjGC9efwjTjWUA1f0f7V8YwXry+EPo/2t4xgvXl8I2JxrKAav6P9q+MYL15/CH0f7W8YwXrz+EbDjWUA1f0f7V8YwXrz+EPo/2r4xgvXn8I1eNZQDWfR9tbxjBevP4RfR9tbxjBevP4S+041lANYvye7Wf8RgvXn8I/o82t4xgvXn8JNhlZIDW/R5tbxjBevP4RP8n21k/2jBevP4RsMrJga36PNreMYL15/CD/ACe7WX8RgvXn8I2GVkgNb9Hm1vGMF68/hD6PNreMYL15/CNhlZIDW/R5tbxjBevP4Q+jza3jGC9efwjYZWSA1/0c7Xt+04H15/CL6OtrXt2zgb/zz+EnKIyIGuf5O9rr+IwXrz+EX0ebW1/ScDp9+fwl5RcZIDW/R5tbxjBevP4QX5PNrN27YwXrz+EbDKyQGuf5O9rr+JwPrz+EF+Tva7/icD68/hHKGMiBrfo82t4xgvXn8In+T3ay/iMF68vhGwysmBrl+Tra7/icD68/hD6O9rXssVgb/wA8/hHKGMiBr/o52v4xgfXn8In+Tra6/icD68/hJyiMiBr/AKOdr+M4H15/CD/J1tdL9pwPrz+EcoMgBr/o52v4zgfXn8IfRztfxnA+vP4RygyAGv8Ao52v4zgfXn8IfRztfxnA+vP4RygyAGv+jna/jOB9efwg/wAnW1/GcD68/hHKDIAa/wCjra/jOB9efwh9HW1/GcD68/hHKDIAa1/k82uv4jBevP4Q+jza3jGC9efwl2JsZIDWfR9tf7fB2/nl8Ipfk/2tF2eIwXry+Ecorpi3FqzNhsad8DTvyMgrWRq9kO2BpvyHn+P29nl6XY5vIv5kdFJ2p3OTHzUaacmks2rZ1Ulmpnpc/tbnjJ9yO6TTcblMaevdcFYtirR5GevTP+Gnn3K2pKScNHlIj372zNi4E/MFxX5e0TzW0sy5VNyS32Q4NN6tdYna+tiMYJ5mrW5oe0qyVlLLpcT1lZIgs0oyaavoEpNNPhy4giT0V9FYanHgvIQhfK1LeShBwpO+8tzCpNd0o21sSaXIi2nUu+KIwTg5Xd7u/mMId1wBu70SQRgqbtvu7XsCXdNPgXdJdSbSdrIS1bSVmJrNPdwJNq+6ztwKFAmQi7Dvm3GVqQqsopXykbtXYpSvBjPtMXKceWvKwTsrFbTerdyutOSmllbtZ6brEk1mRapRV27k8y5IjKUZRkoxFGTk9ySQondS3ohNtK8Y3t5R5rcExQm5Td13K03A9JKc2u8VreERv3TukuQJ99bdcYIhGEknrq+JKn30r7h3GlfdYFRytLubN+UUVK6lJq65EtUA9qb7p33Bu3MG1eyVgir7iIJWdraCaSTbAe5O4A3y0FxuJp8CSas9NS4puV92ggSuNqxEK75k8yE1yE9d3AiG5aq1x5r7hZWLK+AOkkmt4O/Ag7riPNYYYmBHMMjOmJtIBMB2QCuG7cApK5RUjdl7KplivnrRrNj67PpLkjJxd7Gq2Q/0GA+L+z0+S3GtZEuTRfRrU4wSlNI8rb1WvSwrnhmlUU471fQ8yS2n0lozw7Vt7oxPQ5b21yqU5bpIalTX1kZDLtPi8K/+yh5dp+Dg/wAIHJsM0eYKcb6sx/8AxJfu8H+EGbaX2WC/DfvJ0cmwzR5oWeK+sjIZ9qL9xg/w37xOrtTxfB+o/eU5Njmg07sjmVrZzIqrtTxbCepL3j6favi+E6pe8kyHJrlk5jco80ZDtjai/h8N1y94dtbUW/DUPROXvGQ5NfnXhJhmi98tDIdubS44Sl+JJf6h23tHjg4+itL3jIcmwc4aWaE5Rb0kusyHbu0V/Br8efvJdvY/xJ/5iRMhya28c18y6xucb711mQ7ex/iT/wAxIXb+P8Sl/mJEzKa2LnHml6Qzxtvi/SY35Qxy/gan+ZkP5Txy/gKn+YfuGJsa/Mua6x5kt0l1mPW08b/y+r/mX7h/KmN/5fV/zH+wxeTXuSfFdYJrdddZkPlbGLfs+t/mP/Ub2xiv+X4j8dfCMTk2N01vXWKVtNUY/wCWcT4liV/3I+4Pliu/4PF+vH3CTKnJsk1zQLfe+hjvlnEccLi7fzR9w/lmv4vjP/D3Ew1sLd0nyHpZpLjcxr23V+wxnqw9wLblVb6GN9WHuHFNbJK3AZjfl2VtaON9SAfLz+yx3qQJxXWxHHS+hjXt1/ZY38OAvl7/AA8d+HAvFNbIDH/L6S1p438KPvGuyKNu8xn4MfiJxXWvHfkY/wCcUeKxa89FfEP5xxfjS/7P/sOJrXA9UZH5xx54j00P/Ya7I4+HWX/YfxDia1zlfgIyfzjhxrVV/wBh/EHzjj4xP8CXvHFNjXQ4gzJLskX28/wJe8fzji/4iX4M/eOJ9tak1vEnYyvzjj41L8GfvE+yGD34p/gzJxGtehFu64mT+cdNfxf/AOMw+clNfxa/CmOCdNW2hPQyr7JKPja/CmL5y0vHF+FP3F4tbGsVpcESMiuyajf9th+HP3D+dFHxuHqT9w4VnprbAZRdlFFPTGUvVn8I/nRRf8XSfon8JnhRqbDMuuyel41R65fCP5z07aYqh6ZS+EcajTWK5LXcZ35zR8aw/rv4RS7JU1pisN+I/hHGjPR3o1Oyf2KHpMvHQ0+yn+gwJ8ft6vL0r2zrhX/MiEI3aJ7W/ZZfzInRjovMelx+yVMMl9x0KBLIuRlXN0V94dGr7jonJU0tG7u2hzONap0icWouPcq1iLPHTypvTgHRllGjNSc52u+C9hdlXIFmOZUx9GuRbUeW2WKd3YcYuUU3Gz5ETHO6SYuiOrIDhYI5ejYnTOxQXIThcaOXo/IHRnTk5jyXC45cmu4eTyHV0d+AdGEcvRidMvdm9GUqTdeULNJLS/ELx1FQsCjFycVvWrRN9ytUQhTn0qb+snw3AkSdJW3EXT13HUqYKnfeGccqgm2lvQ+iXIsnSmqrcOKXAujTtvJVscc4qEbtX8xLo7ovnSc6qSbioq9+Y6VK0LPhoEyYodJLgLolyOtQXIMiCOTolyF0K5HZ0dxdHYaOVUVxQ+gjyR19ELoyJjl6GPIXQx5HYqaBwXIari6CHgj6CK+qjs6IfRcxqOHtePIOgj4KO10rbkJQ8hdV5zp/nnBUoNJJ3bHlpNpZVdpvcdjwydVzaT0SV+Au1YLm9bryf3cdLkcSyOnnVNLyNEk6UWlKnG97M6nh4x1twtvKJ01Gm4+S1x0dLo4em91OPUPtaH2a6jiqYyrsrArE3Veip93Fq8o38p20tp4TFJOipNNJp2sYtxrhqLw1L7OPUVvC0fs49R3ZU9wujLrm4HhKX2ceoi8HS+zj1HoSpi6JjUcHaVH7KPUHaVD7KPUd/Rh0Y0ec8BQX7mPUJ4Ch9jHqPR6PQOjGo835PofZR6g+TsP9jHqPS6PyCdMarzPk7DfYw6iL2bhvsY9R6rp+QTp34F0ZOL3Gl2T+xxMxT0WppdkSvg4sx8f9nq8vQ2t+zPzovod6ijaeuGl50X4bWmvMeiuX26IIllBDJPeKptFycZpOXC/IIaSkr6JXCTjUqSjKOkeLK10dOpadnGbvHT+t3qRuTVvSQeqlF+kak39SXsJx6NyvHK35CYZxRKM5Wso2TT3jtUvpl8xdYN3Agp7tfVVvIxOpl7+Mkue8uXlHpZi9VFMJRmrxd0WK17PfyKXCnVShlbje91okTnSlKanCeV2tuuFxPLcIxV7FiRHLZ3MsFlHlGkMt6MV9FFbkkR6NLgW2KM0umceC8gWJxpZnfQeSzHFOzKafSuc817NaeQpi3LcE03l4oqdR0bKrd5na61sSq05ueeDtdWsDFkURnaL13+YsgnYplC+Ku+CH2T2nHukpJMNM2V77XJ20RVWpTnNShK1k0RFjigykXSdSGVtac1chCeWq6OXS2+2l+RMOKxpR4goORGvQnNpxklbVJlkVJJcGEDj5wcLE3uECI5UGWPIm1YLrkREcgWs9SeZCkEV5QyF2iW4ind7hq6g4ojKN9yLmrlbTXIQUTOLEXs7HfN+Q5akLlR5eIqVYYarCMVKE1acXxRw7DTpYnJHvb7j2pUrHJiI9qThXgrJu0rGfKdN+Pl329mzg1fii2LujioV+lUXnzJ7jspvhYnj3E85lTSuSyDjusSKwryjcPMTDggKlEMpaK2oFeUMpYDVwKrA4k7BYDDLcjRbI/Y4+kzcHdI0myv2SPpHx/wBnpvobUdsNLzo6cL+rRybU/ZpedHVg3enE9Dn9utDbI3HNmftStnl5F7RVKUZu73rcWJWQD2suIxSlBZtfOPJHyr0ijpKS9JIUtUVJuNSMc0u65WJxg790tPPclkfSKXJWJkuGodHDwUHRwe9X8+pNhYbqacbJWsCQrWJIn0gjoKW9byTKqkmk2ld7kie7qT2sQO5XQc8tpXutNS0fa32SZC355vyIssc0pyhBz1fdWtyV7XEIvbV7BpGzluOSKlnhKzy5ne/9S+U+kUXDXLLUq3xTkoyluV7Ds7FMekck5q0k9Lci8jOYStHVhl7rN5CGIpOrpFpLyoJQzOLk7Nckgq+2bcQzLNlur8imjOrneZZYtaB0Esymp3d3vQwx0XUd5GUoRV913y3knZaWTZCcXJWUnHyxsRmBVE/C5apjndRdt/AI02lvb87FUp1MycZpLimrjpelN/zXSKUnK3PjysdCTfEr7Xai056t5rpEKlOs5R6Oo9NW3/Qute05T/PNP6sb9f8A8FSrQr54W3eUnGCbU2rSsPLGzVreYjPRUW5wTfDS7HUjrmzPyakksmi0RGq8uVvdmH2n2knpqT0XA5q83FwSdrvXzB2zB2y3ld2shi8a6HYqlcVSso08yT9xzSxlqalKNm3aydxITxq2RCUVvISxEnVUMmjdrixDqpKEIXzJ633A42lJK1+HMoxlNTwtSLV9CdanKVBU0ks2jXJEopujaW/LqSpmPK2dVlGm421jqvKe5QqRnGLX1jx6KhRrWvo9514KcpVnBWywdzHjfp08/Hp6ididOoqlOMlukro5JqrKrpJKnbWz1uWRi1RyRdmlZM3jljoXmGc+HpVKccspJ+XmXrfoLEvQYAwSIgFKUYK8mkubHmRVWyzUU/C1C4k3oiSFYaVgz2wEXZ6Gj2VK+ERm6Zodk/sqHx/2em+k9qP9Gl50dWC/VJnHtNrtaXnR2YDXDo7sfbrC15IlEF3/AKAqQJDBtJXZOxC351+YkyNNp3d1dvVchOtBXteVuSHS2J7t5JoLARMIaQbt472Jf8RGw3oNK4PcN7A7iUGxx11JGU9IxVrgSQWAjYVuZM5sl8RLhazvxL7JF0pQva63biFFUoq1NK1tLEHTbr2e6yfpTOmKVm7CreohK/ATajFttJInku9LEK9JygkpJNO+4aiUZRmrx1T4kZTpqVnKN/OKlB0qag3mton5BOjUlK+aFuWXX+owyLErhpFX/qc8ZVFVtGKVJOz8/uLp0nUp2TtqKWf6lGcJx7hoc9Fu6imnh3G7hNq7u7riX5Wo6u7Ilk1CFW9705x89veWZuLIU6UVom/S2yU6cnbo5RXO6uTo6U9/DPma057iyDyxWbe0JUtJ5pazXBWIVsNUnZdJdb237Cr/AIsqys4xXFlXSxqzdNNqS1TRcoZorOlcSjTi9IJPyIQmCk3KPdb1oyOJSlTytXTa09JOK6Nd1veugTg5TTusq1Iz9ozoxmrSjF23XK5YeEYq0UrWXtOpLQUkrO6G1eVVSgnvS8hXTSUHusrs6LczztvVHQ2Li6lPuZKm7NDU5I4faGHxdScKE1Jx4o6bxa36nzvZG1O06l+Z6c9uOUtJvQnl499PR4ec49tLjMfRw+IpUal1KpopcCa1MBtXalTF1YtzfcbtTeYZudCEpb3FNmsyOPndvThqUk6knItwHc4qS5xO/tOE1mnfV30OdxhSxkIx4o4+Nzyx2s3wdyatuJIgWI6vMnElxIRauTJUBGTcVotWFWThC6TfmVyql0l30l2r3TfLkFkWRhfvtRuMMyjlWvkJu9u5SuQd045subWwCyW712Iyq5F3cXdciyCl9a3odxygpK0kmEfPIPcaHZT/AEWJnYqxoNlP9Fj6R8ft6L6S2nftWWW17o78B+oRwbQf6LPzo7dnXdFHeuc9u6GjsyUlfdvW4SXMaUlu1XlDRXn4Ht0BRbd5vdwW4lmfFDzImqqhBdJOTV2np5NB0oKMZab5N+0nePNArD2akg3CuDlfgSWoY7kdeQ7MvQfmEAzOBjFv3CV1vZMZSAjqNjAyDjarm5qxJSvuI54KVsyzcriAcbzUuSsS4b2MNxAr8gT5jdhJkQJNtkl3IRs0Da5ioajqKei00G78CL03iEKnd3LFoVxavoJy85qy2rU0rgvINzSBrkZTf0KLW9j4O5F3XEkmmKUknZ3Yt5JuxC6SbbslxGkqTim7hmV7FcqueN6LjL/q0IXl0ibta2qLJvsxdCWa+lhydiMJK2isKbXElnafYnd7nY8Xsrc12P4nV/VWnnR68p2VyDkppq3WWD485OEiztl28p39kmB7U2rXjBdw5XXp1PHOntFik5zPpOxFOGyMNnzSnkTtvZ87wOJlg8TCvCMZSjwkrpmzwOMxW1sHUxFCcqNSnKyjC26xeOrK9+tLFwp9LKUo/wCHki0vJfeVUpxxWKjVStljqjhwG2Jzo9HXm+ljLJJSWVs7sNaWIrZJW0T09Jny+PxzY1zuY71YmmcXS1s0YrK9Wm2i2inKrNzeaKksqa3aGMOK/j3PsLIX4shGOl46XdyWqJWN+kraO4nHudN63Duh3IeiU+aaYON5RlyG0pKzRz4jNTpuUG7rhmYWOhtLjYrm8/euStxRGnFTSl33HV3LrAsx86W5Hv7KdsKjPX0Pe2S/0ReceHt3qzaP7NLzo9DZmtBHnbRf6NPzo9HZX6g9DnPbvQxWBuxnWj3BcjFSesmvMT3FB6BX1F0ked/MEZXk01axVTTQ3ZeUW8VmY6ZpoNUNWFIS9hqzGtCNmNaEsn0hikAyS5QN2FOcYWzO19wOSIzjGpHLJXRcVGm+4ebda785GSpVY5Lb/Q0SlFtSS33BU2p9I3q1Z8rBrpaneOu8GQj3nn1JXuTGKo7Z0jLJdS72z1ZFvNCpJSva91cuhRhCCildRd1fgS6ODTWVWfCw2NbFVO7p0k/PYOk6SpKnbS28nGjlXfNrhd7hzhmWlk+ZbidJ0W5U03xSFXk45UpJN81cO9Xc6ISvLiTPtnPsqeaXH/xaLNFvVyqvU6OKd0r8WVLEVHSpyyKTkrvf/omTumWutJJNtXFOVnbUplXvTbjvjvSI4eq5RfSayvua1sMM+3RfPu4cxrud5FJ8NB25kRTiIudVR0s48eBKtFqhNJ8AkmqkW3fRoJt5JFioUVZtt3lLyFsmktxXB3VwcrvzFvtLe0pt37nQgna9wk7srlLrIixtNFVSpGlCU21FRV22RzvicW1cPHGYOVGpNwg99kMRitv7Re1cdKWGpvJFZU7ay8p5KwlZvvGvObCpRpUqahCKjTjuX+px1J0Itr/dHUeLhdnN1F0t7ct3tNRs3E08G1RoWSavo7njSrR3RVv6DoVVSxNOTel9Syo93aPR4meeCUajjaT/AKPrLtiVqro1KuVzlJRjZen3nlVKyfey8iZoNgwjHCXjuk2yeXpqPRp0rRXFrX0l0IKLvzd2KO4knqcrVtTWjvwfAHvFq9zG1rvJUND4aEQgmlqwhrUVWHSQcb28pB1rV1TUOF2+RbcEmFTioQSW5Eg0Ag+a5rHv7If6IrmcV2aLZT/Q0vOPD27+XpPaP7PLzo9PZP7Ojyse74eXnR6myP2Zec7sT29G4t8iVrlbvnaHTS1Ipqqq5OMUsrst3WTjIsWu4lWXHNGjrKMpd1ZPuVuLoU1BJJt6W1Iz7mXSK+m9c0WrUnpbSGNoTuOqxpLuXbmR6VcISaXEJvcyEKnczjHusuqsTFzVqZGM1a8mtXoRjVipRptNNrS43QhLvldLdqDP06fcylFblqkWXIxik7ktOQxKE1yDTgEdCqblKqoxcorLfS2o+w53jPNFZuDSeoScp745Y8U3qymMKsUssrO95K2jJKFR659HvTGNZHReNm9LEU4ybSauuBTDCxSi/rRd78y2EMtSTWl7dZGbE4psGKfcRcm0kuJGNRSllvqt6IzE07gANFU0lNeYVnEe4bV0iWpVc9XruCytZLeTuo70RWu4u9GqqWHySbT1e+73l6iFx3JfK1nlSlJR3i6RMckmjny6ybtpzEwmLZTTK3NJWetwaglbLqUylBO10akjS3MlyQnUijnniIq9qcnZX3WK51p6ZUlvTi1d3JiYuq1d3cy9AlOMrqPDfoVxlLPHNo7O40+6ky50WJVJqnTlN7oq5mcbt1VrwdOSjfme7tGqoYGq72bjZGGru7epfFlfXxFRyazaPVPmjmdRvRu5XCd1kfDcJyNIsTJzaVihSC994HVSqNySubXYf/8APpmEpTtJG52RUisHTv3KtfXcTy9LHqxJFfSRST8qRPgchNSsx5lbf57lSmr66MLOUry3Lcv9S4uJKTl3unlZGrLLa+tyVSoqcXJooU3UyuSs77vShIsizJabavr5QpSlO9p6oqjGv0kpN9ynpe24rjOpCzgt1m78dxWnfTk7tO91zJK/Mocr5Z960R6To6dO7sr215akxnHz1bz39l/sq87M/B3se/sz9mXpJ4e3Xy9JY39nn50evsf9m9J5GN/US9B6+xv2X0nZznt6KVyMtHcmJofbZJJkkQV4Pmv6E7p6rcAFeaNJKCazPvU2SqQzwaIKmnCErXasxVmLYKVu6tfyDY5NKN9xBtz3XS5kzUJd1LyImEUoqySsSysf9FeSLk3bUmtxKyYNabjNxNJWY7IjHeSbF3URS1BaklqRbSIIVFJweVa8CFNytFOLXNsuDRllq6i3lcVrq7aCk3kmoO8raecdNZY232CyTbXEvd6FbVW7g3mjl+tpdhClKFRzla7tuLkrPUbsT/DRfQQtWN6EsxAGfLvuCZFrmJNqeyk77hRTe4ldcixJLchbhbipxnmtm9pKCa3u5OwmnwM6zqOZFFXWEt2rR0XjbcVtq25F9K5KkZ6vVu73c7KxCOGcYxeVZl5S+ddRXcpb98tAqZ50XkajK28121qlUrxSdu9syOXI7ykm278hVVUcKcU3md3e+4TpaXi2r2d979pRJSWZLVu28T75hOnaCSXdpWT4jffvzIM/68PsglU6WjHXo8kn6f7Zl6r1Npt2Me1E7a30MVV3lnpmqal1quBHNclU7xlMCouTJXK0ySXFgTpyvI3eyot7LpSbUYqN9Vu8phKWslyPoOzISns2gk1FZF5yVY6XBww6ULyy2t5bF9GUpwvKNmKjRVOnkjuLFc51bVMqMnWU8ysuBbTcrWe/jYaeYGrarQu30b9JuzVmrlLcZTi1w5lqbsrp+gqnGDqqWq5rLvZIvj7WVpZad7aW38imNNupFp97vXPQ6LqcHHLJp8LEIU5LTnxerEJRVaSssyfCwuhdWMekbundPiXRppeV8yViakr5nTPe2bpQR4ULLee3sx3oL0k8Pbt5elmMd6Ej2di/snpPGxq/Rp+c9zYsb4Rec7ufj7d6HYkoEshXRXYjkW+1n5C7IGQIqytbn1iyy3ZkvMi7IGQCpQV77/OSasTStwBryGZu4KyyO7QWVk1FlsRXlfAd7E8oKK5EsMVpCdy6y5A4pkm6KcrFZreW5ROFzWUVkdxa4MXRtmZLKIrXcCjfcTUGuA8nkLmCFrA4NFmQaS+tqTLIVUtXZaA4tPUl0fIeRly+jELw5MUlbfqT6MnkUt5L44mKbx5Dac+9uiTpWE4yW65OJgTT3Ec1nrcVmnYfRzbt/UcE4jK/IUvuZ6tIvnGV0kmiEoZt8b+gmX2TXLZZruSa4JElPyNl06Ur6LQiqTtqaXVGtrWYavgXypN7rISptX4mWa5u6e5L0siqcrtytd8jo6GUuBGVGceZoeF2R1Z0cFGSoyqJS7rL9VczF1MRCTdoyR9E2pSlLZuIurLIzDzUE+9Wg3F4686dS8bZXZ8RR3bmdGKa7lLQqijUYswJ8kNJveOxKwRKj36N/wBj8+k2VQlyVup2MNhIXrJeDqzb9jkJfJFJrnL+rJfSx6sboJJ77kqcJa3JKnJx3HP0vpCNnuROwoQkt69pZCLl9ViwsKKtayOaonDFwm3dPS3Lcdii8mazIulGo7uOq3CLOiUktyJvRrQsVJ8FYi6cr8SdM2yEFhuEvKJ0Zt216xhO3zBK8ke9sxWw6PFhCz1PSwuLjSpKLvdE8bN7d7Ono1qVStSlCEbt82XUKNeMEnJdaPPp7YVG6alZ8ify/DnV6jtyjGPT6Orf9Y+sl0dRfvfaeYtuJrR1eoi9tvlVa9HvHKLj1sk/tB5J/aW9J43y1bhW/v0kvlu/Ct7PeOUTHsZZ6LpRdFP7T2/7HkLbVt3Tf36R/Lflrf36Ryg9Xo6n2nt/2B0qvCp1f/Dyntt/43s94fLb/wAb2e8coY9SEK19ZtedlmSov3i/v0HjvbXFut/fpF8tr/G/v0jlDHtJT41V/foH+c4VV/foPBltteBWfV7xLbiX1K3s945RHvpVF+9iH577Q8F7cS+rW6l7xrbqturez3jlFe2+l+1/vqIzjWtpU/vqPG+XE98Kvs94fLq8Gt7PeOURXip7b6eapKeS+lnEq6Tb+61T1o+8v+Wo/Z1n1e8PlpW0p1fZ7xsTK69lfKM1Ptxyg9MuZp/0PSUKn2x4i22l9Sr7PeD259yt7PeOUXHudHU4VV/foF0dV/vF/foPDW3m1pCv7PeP5dl4Nf2e8coPbyVVuqL2+4Pzy06RHiPbkvBrez3i+W5JawrPq945Qe0+mf71e33Cy1vtV7Txvl1r6lb2e8Pl6fgVvZ7xyg9hqt9qvaK1f7Ve33Hj/Lk795W617w+WpeBV9nvHKD13Crf9aup+4SjWjuqL2nkPbT8Cquoi9tSt3lX2DlDHsvpn+9Xt9xCUa7/AHy6meR8tz8Gr7CEtt1OVXrHKGPVfT7umXtI2rfbL2njy2zPlU60Qe2alv3nWNiPYl0q/fr2lU3Ut+uXtPIltio+M+sqe1az+tPrGxHsOdRfxC/8it1KnjC/8vcePLaVd/XqesQ+UK/2k+sbEeljK040XeqpX4K/+p5VpTvIJYmdXv5ya5NkJTd9HpyM3uunj6UYiWaeiIxvyHJXm3cnE2532kopElEatw3k+5jHR6hFuFhljJs02zadXtKkqdRRjbdqZ6lZU3qjve0p4OFPI5OMlui+QWPeUMRa3Tv2klTxTTtW3ec8BdkFTwavWSj2QVb6Rq+sYtivd6PF/bf1HkxSWlVnirb9Z/Vq+sTW36vg1fWHKLj1ZRxkfrzl5v8A6NQxS+vLq/3PKe3qrWsavrB8uVfAq+sOXiY9eKxTdlUmv7848mK41J/36Tx3tyqvq1fWD5cqtd5V9Ymz9MevkxH2sv79IrYlfvJf36TyPlub305+sW0NrQm5Ou6lKnFaytm9g2Jjz6Gy9oVZZVhJr+ZqP9WcMq8YVJQkmpRdmiu78NdQnG+uddRz6d+03iIc5dQunjwT6iDi/DXUChb957BkTtZ21Dk+oO2oX+t1Fbh99dQsv311DIdre24cpdQduQ5PqKWvv+wdvvrqGQ7WduQ8GXUPtyPBPqKmvvLqHZ+EuoZDtLtvyPqDt5cn1EMj8JdQnT+8uof+TtY8auT6iPbvKL6iGT7y6h5F4fsGRO0u234L6geLfJ9RHJ9/2ElHTv8A2F6Owq8pySs1fmjuwmDeIUr4ujSUVd9I2v8AQ4ba6T9g9fD9g6WXrt6i2fHX/imD08svhKMfh+0YQn2zh8RnbVqMnJrz6HFb73sE43+u+ovSdk8S76Rl1Eo4rnGXULL972Bl+97CdJ2n20vAl1B23HwJdRWoLwvYPIvC9g6XtPtuPgT6g7bX2c+orcecvYRy3ffewZDtd24vAn1D7bXgT6imy8MWVeEMidr3i4+BLqEsavAl1FGVL648i8L2DIdru3F4Muo7IYWrVwUcVGdJRk7KDnafUeY4rwn1EoWT759QyHb0qeBrVFH89h1fg6qui/Z+Dw2NoputUpTu9JxS06zyX/O+oV/8SRqeUk9LP9aalsHB530m0U1wskv9TzcTsfEUsv6RhpOT0Uah5WZ+HITlp38hsv0ux6U9i4iKu62G/GWgnsPFOjKoq+E7ndHp43Z5bk/DZFv7zHX4zcdfyXi+VD/MU/iIU9n4ipXdHNRjJJ6yrRS672ORvysT87NbPxl2PZmKvvw/+Zp/EVVcFXpStPov+mrGX9Gcr87Ivzjpdjoq03SUW5wlmV7Rle3nIKRWtw48S9fTOm0uYJ2EI0wtU7Bm4sqbtvZF1Y87gdMajva501qq7WjreSkeW6z4IlTnKUu6bJfSx1qu/BY1iGvqMp9I1bmzlkb7dCxT8BknipeAznVubHZc2TIvbpWLkvqMXbk29KZz2XNkklzYyHa7tqp9n7Q7aqfZe0qyx8JjUV4TGQ7T7aqfZPrOiPS1sJKbjli5W8tzkcV4TPdw+F/4Xh09c15e0dF14OSfhkXKcZWzewtZVLWoSNjNPwvYO8/C9gMaKotK18/sFaS+t7CzgQkQRakl33sI3fhPqG95KxURu/CfUStLwmJImiCPdeEJ5vCJMTKI3fhDV/CYR1GwBN+E+obTf1mK2owYVnfSQXl4TBsVwH3XhvqB5vCZKwhoEpeEwtLw2TiJk0QtLw2HdZrZmO4ovun5ioGpeExxjf67HcaGmIun99h0b8Nk7DRNMVOL8Jis19Zk5acRF0Qt95jUX4TJWHbUaiLUku+ZG0ubLbpoi2NELPwmRa+8ywg0XRFp+ExWfNk3oRZURt5RNeVkhMIg4+UjlJsVrvQqJKOiOetNqdovcerXo9HTfc7keM3ds1DymJKpLmDqSIkrmmEJSbCL0FPedWC2fiMbftempZd7clH+rB7UasnTdpI9SPY1taXe4aP41P4jpXYntCEVOtVwlHyTroLleSvSSt5WevT7HalSpkjtHZzlyVe7XUjqj2L5Hlr4+Clyp0ZS9rscrcdGet5WP0s01XYez6a7iltGt95TpRj7WV4bYuDq18lanicPCz7vp6c//FIls/RnesaXlZp59jmzm+52nUp/z4dshLsZwqhKcdsUcq33pNW9pNgzlvKwt5WeytiYSX6vbmzm/vVEiyPYzWn+p2hs+ovu17/6FHhWfN9Z9Jw+ynHA4aFtYU4p9RkVsDEYfHUIVKuGmnJN5Kq0V9d9j6LC0oJxnFxa0aZclg+UPcVNfnPQWvcVPv8A0GI6BjQhoCfAgyfAiwK3oTuRe8kVAhoSQ0RSZFkmQYiHAk2QgS4gO4ADCkxALiVFnAQxEEloJsBMKQo98wCL1ZUMlFaojxHewRZmVxNkeIEUpasEJ7wKiV9B3IX0LE4wipPUYahlfIWV8mN4ucXdJdRF7Qqp6vTzGuNZ5Q9xFlnbEKyzXtJcBNwnxdxhqpiGyJACYAyoiy7BQz4mN1dLVlLOjA0K1eq1RgpNLc3YshuO3FzccPUvyM9vPXqYbEZpxlRlrvS4HlVKcqVVxkmmuDNyWJ5+WkiViK0ZMrCqb1J0puDTXAU46ZhRA6o4mVsrckuVzvwO0Hh6WVQbTd955J6eEoZ8NGT4nPzzG/HdeitvtL9VL1i6HZBUy3jh6jXNTPM7VPf2VhIfJvdJXuzz+XGR1muT5w1bd1hqr/6xfOBrXtWpf+Y75YenfvUQeGpv6qM74fi9uT5xye/DVPWGuyOXi1X1jpeHp+CgWGhyQ3w/DK5fnCvFanWiPzh10w9Rek63h4cIoTw8H9VF3x/DK5Pl7lhp9YPsgdrLD1F/1HV2vTS70Ogh4KG+P4ZXiPcVO/S+gsTKn+t9B1iJAhXBBVhF6AJgRaGJjCGNC3jCkRe8kyLAUCQocRhDEFw3IBAAFExAKSbWhBIixkWUIF3wCT7oIlxJEGNATQCBgJsL2B6iAtpQjLWbtFFOIqxcrQ3FVaq+9T0KGzp4+Ln5VZKbIPykZMbdzbKadrWJKXIqi95JaEHQ5Z9URI0pa2JPeYsblITJEWQRNt2M4PA0KNHpKsKuJrpSyp95/uYo1Wy6mHp1MJXdanSpRjaUpSSs7eU6/H7SuytR2DtLalR4qtKist1JzUIt31Mt2T4fZ+G2lGnsyp0lHo03LPm7q749R69DZK2lKTo42grPNJQak0vMjwtv4alhNodBSm5qMFmb5l232zXnBfQSHYiJpXhYqXIvjuKZq02SLTNFs2F9nUn5/wCpnUarZcb7Ko+Z/wBTn839W/j9jo1yPY2ev0FrynnKJ6mCdsFbdqzyeV6dlbQtLDlLVkeBhUQtpoMX1QqK0BgBURItkm7kJeQqM83oV3/Oeg4e3qvKPUxduVL3tHqPZwrlzj0OI0ef27V5R6g7eq8o9THCrzj0Quef29V8GHUxdu1PBh1DhTnHfxGef27U8GHUPt6r4MOpjhTnHoIa3nndvVfBh1MO36vgw6mThTnHexXODt6r4MOpi7cqco9ReFOcd8eIzz1jKi4R6h9u1eUOpjhU5x6AnuODt2p4MOoO3avgw6hwq847xHD27U8GHUHbtTwYdQ41OcegM87t6r4MOpj7eq+DDqY4VecegyLODt6r4MOph27U5R6hwqc47iP1mcXblTlEO3KnKJeNOUdxOO487typyj1D7dq8o9RONOUekkGSUmlFNvyHnLH1V9WHUzpo7arUV3OHw7fNqXvHGnOO+GzsTUcVGG/ynV8hYi3f078rnlx7JcZC+WnQV/uv3iXZFjVujS6n7xxqco5sRFxrTi/quxU95XPETnNykldu5HpZckdGFoFXSPkg6WXJFRch30KOkfkDpZeQDqg7NMue84FWkneyZYsXUTulFNbrGbNalx2ZXyYnFrej0KXZrtOlTjB0sLNpWzShK76mSfZvtF78Ng/Ul8RjKux5bR006lPocrxE4fdcbrcdMuzLHy34XBepL4jxq2OqVas6mSEHNtvKnp7Tp4bPbPl23Gzsb2psi1JqayNQdrXu2Z7G4KeIx9KpUi+ik4xqzTWjb19hTsvsoxuy45aVLDVY2slVg3bqaKsZ2RY7FY+WM/N0ajVkqSaitLXSbeuh08vLWPGY3i7Btj1IKUFXs+Kqf7EX2BbKe6piV5qi9xktndm219n4boE6NeK3SrqUmvTdFr7PNrt3yYZeaEviOdt/HSZWkl2DbNUrKeMtzzx+EUuwDZk3ftjFr/qj8J4EfyhbXirdBgn54S+IjU/KBteasqODh5Ywl8RO2t8XTtzsJr4KjPEbPqOvRgryhLv15rKzOnYdClPZNByk7uP+p5Uezva8Xdxw0vI4S95wfOTGKTapYdJu9lFpL2mPOeXlFl8fGtmsHC2kizIqdCUUYyPZVj47qdD1Ze8l87ce42dLDerL3nG/D5N/yeLUWHwMn86Mb9lh/Vl7w+dGN+yw/qy95n+HzP5PFq7C+qZT5z437LD+q/eL5zY21uioeq/eP4fM/k8WolZat2KJ4uhC96iMriNs4rEO88qXJXt/UoeNqvhE6ePwfrN+T8ayO0MLKWXpEn5dC+bTSsYjtifkOrD7XxOHjljklHlJPT2lvw/iT5P1wAAHocgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/9k=">11 年前 (2014 年 1 月 3 日) — 8:30 <a href="https://youtube.com/watch?v=IWzXAyuuR6c">https://youtube.com/watch?v=IWzXAyuuR6c</a></p><p> 11
            years ago (Jan 3, 2014) — 8:30 <a href="https://youtube.com/watch?v=IWzXAyuuR6c">https://youtube.com/watch?v=IWzXAyuuR6c</a></p>
        <h2 id="summary-11">概括</h2><h2>Summary</h2>
        <p>本讲座讨论了同伦类型理论的基础，特别是弱无穷群。罗伯特·哈珀解释了群定律如何定义这种结构，直至更高的同伦。该理论允许更高同伦的“庞氏骗局”，其中真理只在越来越高的近似水平上成立。还讨论了截断或严格群，并将空间的基本群表示为环空间的零截断。讲座最后展望了未来的应用，包括拓扑结构上的可计算函数。</p><p>This lecture discusses the foundations of homotopy type theory,
            specifically weak infinity groupoids. Robert Harper explains how
            groupoid laws, up to higher homotopy, define this structure. The theory
            allows for a “ponzi scheme” of higher homotopies, where truths hold only
            up to increasingly higher levels of approximation. Truncation, or strict
            groupoids, are also discussed, and the fundamental group of a space is
            presented as a zero truncation of the loop space. The lecture concludes
            with a look toward future applications, including computable functions
            on topological structures.</p>
        <h2 id="proofs-of-multiplication-and-inverses">乘法和逆运算的证明</h2><h2>Proofs of Multiplication
            and Inverses</h2>
        <p>好的，现在最棒的事情来了。好吧，当我写下所有这些事情的证明时，我将需要这种乘法、逆元和反身性的结构，比如循环空间。好的，这就是将要发生的事情。要定义 α，需要在循环空间中，逆元、串联和反身性将在循环空间中使用。</p><p>Okay, and now the great thing comes. Well, when I write down what are
            the proofs of all of these things, I’m going to need this structure of
            multiplication and inverses and reflexivities in, say, the loop space.
            Okay, that’s what’s going to happen. To define α, requires in the loop
            space, inverses and concatenations and reflexivities will be used in the
            loop space.</p>
        <h2 id="groupoid-laws-and-higher-homotopy">群胚定律和高阶同伦</h2><h2>Groupoid Laws and Higher
            Homotopy</h2>
        <p>啊，那么问题是：这些东西应该满足什么定律？也就是说，如果我有两条路径，α 和 β，也许是反身性和某种东西与其逆元的复合。那些 α 和 β 是路径之间的路径。那么，它们也应该满足群定律，这意味着应该有一个更高的同伦，我会用三个箭头来表示，看起来像这样。或者，如果你能想象这个结构，你可以复制两个，把它们放在三维空间中，然后就会有一个——用什么词来形容呢？——另一个面。</p><p>Ah, so then the question is: what laws should those things satisfy?
            That is, if I have two paths, α and β, maybe reflexivity and and some
            composition of something with its inverse. Those are α and β are paths
            between paths. Well, then they should satisfy the groupoid laws too,
            which means there should be a higher homotopy, which I’ll write with
            three arrows that looks like that. Or, if you can picture this
            structure, you can take two copies of this and put them in three
            dimensions, and then there is a—what’s the word to use there?—there’s
            another face.</p>
        <p>人们使用“脸”来描述他们的术语，因为他们已经词穷了。脸之间有一张脸。好的。这些低维边，你有好名字。这是——这些是顶点。这些是边。那是一张脸。但是现在，脸之间的脸呢？我们需要一个词来形容它。很快，我们词穷了，所以我们就把它们都称为脸。所以脸之间会有一张脸，这是一个更高的同伦。</p><p>The terminology of people uses “face” because they run out of words.
            There’s a face between faces. Okay. These edges in the low dimensions,
            you have good names. This is—these are vertices. These are edges. That’s
            a face. But now, what about faces between faces? We need a word for
            that. Pretty soon, we run out of words, so we just call them all faces.
            So there’s going to be a face between faces, which is a yet higher
            homotopy.</p>
        <p>所以这意味着你可以得到所有的群定律，直到更高同伦，直到更高同伦，直到更高同伦，直到更高同伦，一直到无穷大。</p><p>So what this means is that you get all of the groupoid laws up to
            higher homotopy, up to higher homotopy, up to higher homotopy, up to
            higher homotopy, all the way to infinity.</p>
        <h2 id="weak-infinity-groupoid-structure">弱无穷群胚结构</h2><h2>Weak Infinity Groupoid
            Structure</h2>
        <p>这被称为弱 ∞ 群胚的结构。也就是说，你有一个满足群胚定律直至更高同伦的群胚结构。</p><p>And this is called the structure of a weak ∞ groupoid. That is, you
            have the structure of a groupoid that satisfies the groupoidal laws up
            to higher homotopy.</p>
        <p>所以当我第一次了解到这一点时，我想，“天哪！”我问了彼得·拉姆斯丹。我说，“是的，但这有点像没有任何东西真正成立；它只能对更大的谎言成立。”好的。好的。你会说，“嗯，这些东西真的不成立；它们只能对更大的谎言成立。”然后，“哦，好吧，它们实际上没有群定律；唯一的群定律就是对更大的谎言成立。”它的运作方式是，只要你把这些谎言带到无限远，你就永远不会被抓住。这是一个永不枯竭的庞氏骗局。好的。</p><p>So when I first learned about this, I thought, “Jesus!” I asked Peter
            Lumsdaine. I said, “Yeah, but it sort of means like nothing ever really
            holds; it only holds up to a bigger lie.” Okay. Okay. You sort of say,
            “Well, these things don’t really hold; they only hold up to a bigger
            thing.” And then, “Oh, well, those aren’t really having the groupoid
            laws; the only groupoid laws up to an even bigger lie.” And the way it
            works is as long as you carry those lies to infinity, you’ll never get
            caught. It’s a Ponzi scheme that never runs out. Okay.</p>
        <p>于是我问彼得，我说：“彼得，耶稣，我的意思是，这有道理吗？”他笑了，看着我，说：“嗯，那会出什么问题呢？”我说：“嗯，你知道，这是一个非常好的问题。我不知道。但你不觉得这很奇怪吗？不知何故，我不知道，这是一种心理因素，但在某种程度上，它没有充分的依据。除非你截断，否则没有地方可以完全成真。所以，我们要谈论截断以外的其他东西。</p><p>So I asked Peter, I said, “Peter, Jesus, I mean, does that make
            sense?” And he smiled and he looked at me and says, “Well, what could go
            wrong?” And I said, “Well, you know, that’s a really good question. I
            don’t—I don’t know. But doesn’t that feel odd to you? That somehow, I
            don’t know, it’s a—it’s a psychological thing, but in a certain—it’s not
            well founded. There’s no spot where something utterly becomes true
            unless you truncate. So, we’re going to talk about something other than
            truncation.</p>
        <h2 id="strict-groupoids-and-truncations">严格群胚和截断</h2><h2>Strict Groupoids and
            Truncations</h2>
        <p>例如：如果我要求这些符合定义等价性，那么我将得到所谓的严格群胚。因此，您可以在任何维度上严格化或截断（正如它所称），并要求，不，不，在那个维度上，我要求这些东西真正符合注释。这就是术语。</p><p>So, an example of it is: if I demand that these hold up to
            definitional equivalence, then I will have what is called a strict
            groupoid. So, you can strictify or truncate, as it is called, at any
            dimension you wish and demand that, no, no, at that dimension, I demand
            that these things really hold on the notes. That’s the terminology.</p>
        <p>在某些情况下，这样做是适当的。</p><p>There are scenarios where that is the appropriate thing to do.</p>
        <h2 id="fundamental-group-in-homotopy-type-theory">同伦类型理论中的基本群</h2><h2>Fundamental Group in
            Homotopy Type Theory</h2>
        <p>具体来说，使用我们最终称之为基本群的符号，你可能以前遇到过。同伦类型理论中空间的基本群是环空间的截断。它通常定义为基空间，但我们会说基点 a 处空间的基本群是环空间的零截断<em>。</em>这意味着我们将所有高级结构折叠到一个点，好吧，并将它们视为相同的，而不仅仅是相等到更高的同伦。</p><p>In particular, to use the notation of what we will eventually call
            the fundamental group, which you might have run across before. The
            fundamental group of a space in homotopy type theory is the truncation
            of the loop space. It’s usually defined for a base space, but we’ll say
            the fundamental group of a space at a base point <em>a</em> is the zero
            truncation of the loop space. What it means is that we collapse all the
            higher structure down to a point, okay, and treat them as identical, not
            just merely equal up to higher homotopy.</p>
        <p>那个基本群是——就像代数拓扑的起点一样。</p><p>And that fundamental group is—that’s like the starting point, okay,
            for algebraic topology.</p>
        <h2 id="algebraic-topology-and-winding-number">代数拓扑和绕数</h2><h2>Algebraic Topology and
            Winding Number</h2>
        <p>这就像代数拓扑中最基本的构造之一，即基本群的概念。它可以在高阶同伦理论中定义。我还没有真正说过这是什么，但这是零截断，它表示将其视为具有严格的群结构。因为当你处理循环时，群胚就是一个群。因此它将具有群的结构——就像你在《数学与编程》中看到的群。</p><p>That’s like one of the most basic constructs in algebraic topology,
            is the notion of a fundamental group. And it can be defined in higher
            homotopy theory. I haven’t really said what this is, but this is the
            zero truncation, which says treat it as having a strict group structure.
            Because when you’re working with loops, then a groupoid is just a group.
            And so this will have the structure of a group—a group like you’ve seen
            in Mathématiques et programmation.</p>
        <p>丹将要证明的是，如果取<em>a</em>为同伦圆，则基本群将是整数，好吧，在加法下。这就是绕数的概念，你可能在复分析中遇到过。好的。这是一个典型的例子。曲线的绕数概念——它绕某个点多少圈？丹讲课时你会看到；他会告诉你圆的基本群，我们会讲到这个。</p><p>And what Dan is going to prove for you, and he’ll show you, is if you
            take <em>a</em> to be the homotopical circle, the fundamental group will
            be the integers, all right, under addition. And that’s the concept of a
            winding number, which you probably ran across in, like, complex
            analysis, maybe. Okay. Would be a typical place to see it. The notion of
            the winding number of a curve—how many times does it go around some
            point? You will see when Dan lectures; he will tell you about the
            fundamental group of the circle, and we’ll get to that.</p>
        <p>好了，我就到此为止。下次我要讲的是这张图片，好的。</p><p>So, I’m going to stop there. So, what I’m going to pick up next time
            is this picture, okay.</p>
        <h2 id="transport-vibrations-and-higher-inductive-definitions">运输、振动和更高的归纳定义</h2><h2>Transport,
            Vibrations, and Higher Inductive Definitions</h2>
        <p>我将讨论传输和振动的概念。我将稍微介绍一下所谓的更高归纳定义，因为我可以使用这种身份类型的解释来表示空间中的路径，以表示更高维度的对象，例如 17 维球体，好吧。这将有可能在同伦类型理论中定义。我将向您展示如何做到这一点，这是一件了不起的事情，原因有几个。</p><p>I’m going to talk about transport and the notion of a vibration. And
            I’m going to say a little bit about what are called higher inductive
            definitions, because I can use this interpretation of the identity type
            as representing paths in a space to represent higher dimensional
            objects, like the 17 dimensional sphere, okay. This will be possible to
            define in homotopy type theory. I’ll show you how to do that, and that
            is a remarkable thing for several reasons.</p>
        <h2 id="computability-on-higher-dimensional-objects">高维对象的可计算性</h2><h2>Computability on
            Higher-Dimensional Objects</h2>
        <p>其中之一是一个非常漂亮的归纳定义，而且，它表明我们将能够开拓计算理论，研究迄今为止从未被视为计算对象的对象。所以，如果一切顺利——这部分是程序性的，而不是结果——从程序上讲，我们将能够讨论从三维球面到四维球面的可计算函数，这将非常有意义。如果这能奏效，那将是我能想到的最可爱的事情。</p><p>One of which is a very beautiful inductive definition, and moreover,
            it suggests that we will be able to open up the theory of computation to
            work on objects that have hitherto never been considered as objects on
            which we compute. So, if everything works out—this part is programmatic
            rather than a result—programmatically it will work out that we will be
            able to talk about computable functions from the three sphere to the
            four sphere that will make perfect sense. If this works, it would be the
            most adorable thing I can think of.</p>
        <p>好的，因为此时你已经将计算范围扩展到了以前从未考虑过的范围。</p><p>Okay, because you have then, at that point, extended the realm of
            computation to reaches that have never been considered before.</p>
        <h2 id="conventional-computability-and-new-types">传统可计算性和新类型</h2><h2>Conventional
            Computability and New Types</h2>
        <p>所以，你知道，人们经常谈论图灵地毯，但原因是如果你只考虑自然数上的函数，你确实不会得到任何东西。你永远不会想出任何东西——我预测它的丘奇定律不会给你带来任何新的东西，但它没有说明当你使用其他类型时会发生什么。所以，不知何故，你知道，传统的可计算性理论停留在自然数上。他们不知道其他类型。</p><p>So, you know, people often talk about the Turing carpet, but the
            reason is that if you consider only functions on the natural numbers,
            it’s true you’re not going to get anywhere. Nothing you’re ever going to
            come up with—I predict it’s Church’s law will ever get you anything new,
            but it doesn’t say anything about when you work with types other than
            that. So, somehow, you know, conventional computability theory is stuck
            on the natural numbers. They don’t know about other types.</p>
        <h2 id="geometrictopological-structures-and-computation">几何/拓扑结构与计算</h2><h2>Geometric/Topological
            Structures and Computation</h2>
        <p>所以，我们已经取得了进展；我们有很多类型，现在很快我们将拥有与这些几何结构（我更愿意说是拓扑结构）相对应的类型，并在其上具有计算概念，这样我们实际上就可以拥有更具表现力的编程语言。它只是与狭义的不同。如果成功的话，这是我的希望。我希望在我职业生涯结束时这一切都会成真。就像，这就是我正在做的事情。好的，今天就到此为止。抱歉，我超时了。</p><p>So, we’ve gone ahead; we have lots of types, and now pretty soon
            we’re going to have types that correspond to these geometric—or I would
            rather say topological—structures and have notions of computation over
            them, so that we can, in fact, have more expressive programming
            languages. It’s just in a different axis from narrow end. If that works
            out, that’s my hope. This—like I hope—by the end of my career that
            that’s all true. Like, that’s what I am working on. Okay, so enough for
            today. Sorry, I ran over time.</p>
        <h1 id="type-theory-foundations-5.0-robert-harper">类型理论基础 5.0 — Robert Harper</h1><h1>Type Theory
            Foundations 5.0 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 5 日) — 37:13 <a href="https://youtube.com/watch?v=JcRdLAlPE88">https://youtube.com/watch?v=JcRdLAlPE88</a></p><p> 11
            years ago (Jan 5, 2014) — 37:13 <a href="https://youtube.com/watch?v=JcRdLAlPE88">https://youtube.com/watch?v=JcRdLAlPE88</a></p>
        <h2 id="summary-12">概括</h2><h2>Summary</h2>
        <p>本视频讨论了类型理论的基础，重点介绍了相等性和路径的概念。Robert Harper 解释了类型理论如何使用身份类型来实现相等性，从而产生更高维度的结构。群胚定律（如结合律）通过显示路径之间路径的图表来说明。视频强调，类型理论的相等性被解释为与证明相关的，这意味着相等性是通过证明建立的。介绍了函数性，即函数性的泛化，展示了函数如何遵循路径。视频最后将类型理论对同伦理论的综合方法与分析方法进行了对比，强调了类型理论的建设性。</p><p>This video discusses type theory’s foundations, focusing on the
            concept of equality and paths. Robert Harper explains how type theory’s
            approach to equality, using identity types, leads to a
            higher-dimensional structure. Groupoid laws, like associativity, are
            illustrated with diagrams showing paths between paths. The video
            emphasizes that type theory’s equality is interpreted as proof-relevant,
            meaning equality is established by a proof. Functoriality, a
            generalization of functionality, is introduced, showing how functions
            respect paths. The video concludes by contrasting type theory’s
            synthetic approach to homotopy theory with the analytic approach,
            highlighting the constructive nature of type theory.</p>
        <p>罗伯特·哈珀提到，不去任何地方，然后倒着运行，然后运行它就和那样一样。</p><p>Robert Harper mentioned going nowhere and running it backward, and
            then running it is the same as that.</p>
        <h2 id="groupoid-laws-and-equations">群胚定律和方程</h2><h2>Groupoid Laws and Equations</h2>
        <p>所以这与此相对应。然后我们将有如下定律：</p><p>So that would correspond to this. Then we will have laws like:</p>
        <ul>
            <li><code>p = p</code>，即指<code>p</code>。</li><li><code>p = p</code>, which is <code>p</code> refer.</li>
        </ul>
        <p>您必须填写所有内容才能使所有类型正常工作，但这就是它的要点。</p><p>You have to fill everything in to make the types all work out, but
            that’s the gist of it.</p>
        <p>我还想知道什么群定律？群胚定律，我还想知道结合律。</p><p>What other group laws do I want? Groupoid laws, and I want to know
            about associativity.</p>
        <ul>
            <li><code>p q r = p q r</code></li><li><code>p q r = p q r</code></li>
        </ul>
        <p>然后我们花了一些时间讨论这意味着什么，因为真正酷的是，这些都是方程式。</p><p>Then we spent some time talking about what this means, because the
            really cool thing is that these are equations.</p>
        <h2 id="iterated-identity-types-and-paths">迭代身份类型和路径</h2><h2>Iterated Identity Types and
            Paths</h2>
        <p>因此方程本身就是另一个空间、另一个标识空间中的路径。所以我们得到了这些迭代标识类型。这些事情往往在一般情况下发生。它们属于
            <code>p = q</code>表示某些类型的类型<code>a = b</code>。形状……你必须写下每个的确切细节，但它们通常谈论的是路径之间的路径。
        </p><p>And so the equations are themselves paths in another space, another
            identification space. So we get these iterated identity types. These
            kinds of things tend to take place in general. These are of the flavor
            <code>p = q</code> in a type representing some <code>a = b</code>. The
            shape of… you have to write down the exact details for every one of
            them, but they generally are talking about paths between paths.
        </p>
        <p>例如，我们有一张这样的图片：</p><p>For example, we had a picture like this:</p>
        <p>``` apb | | | | cqd</p><p>``` a p b | | | | c q d</p>
        <p>```</p><p>```</p>
        <p>我们可以在这里、这里和这里设置路径。然后我们就有了这个结构，我们可以将这些路径组合起来形成这里。这是一个组合。我们可以形成一个复合路径，它在这里。然后我可以将这个和那个组合起来，它在这里。然后我可以将这个和那个组合起来，它在这里。</p><p>We can have paths here, in here, and here. Then we have this
            structure, which is we can compose those paths to form here. That’s one
            composition. We can form a composite path which is here. Then I can
            compose this with that, which is here. Then I can compose this with
            that, which is here.</p>
        <h2 id="associativity-and-higher-homotopy">结合律和高阶同伦</h2><h2>Associativity and Higher
            Homotopy</h2>
        <p>结合律说这是一张面。这里有一张面，这两条外边代表了我这里给出的两种构图，一个可以变形为另一个。</p><p>The associativity law says that this is a face. There’s a face here
            that these two outer edges, which represent the two compositions that
            I’m given here, one can be deformed into another.</p>
        <p>好的，这就是这种图。你明白这幅图的意思了吗？或者，如果我去掉内部的杂乱，我就得到了 之间，
            <code>a</code>而<code>d</code>我有两条从<code>a</code>到 的独立路径<code>d</code>，由这些结合律给出。然后有一条更高的路径将一条路径与另一条路径关联起来。当然，它是可逆的。所以，如果你愿意的话，我可以用双箭头画它们。
        </p><p>Okay, so that’s the sort of picture. Do you see the idea of the
            picture? Or if I get rid of the interior clutter, I have between
            <code>a</code> and <code>d</code> what I have are two separate paths
            from <code>a</code> to <code>d</code>, given by these associativities.
            And then there’s some higher path which relates one to the other. Of
            course, it’s invertible. So really, I could draw these with double
            arrows if you want.
        </p>
        <p>好的，但我们可以这样想。它是可逆的。所以这个想法是，有一种变形可以让我们从一个到另一个，也可以向后。</p><p>Okay, but we can think of it like that. It’s invertible. So the idea
            is that there’s a deformation which can take us from one to the other
            and backward.</p>
        <h2 id="weak-infinity-group-and-equality">弱无穷群与平等</h2><h2>Weak Infinity Group and
            Equality</h2>
        <p>这就是我们所说的群胚定律。</p><p>This is what we mean by the groupoid laws.</p>
        <p>正如我所提到的，这些是群胚定律，它们可以这样写。那么，问题就在于我们所说的相等是什么意思。这些是……如果我只要求……最薄弱的说法是，每当两件事应该相等时，我真正的意思是，有一个证明，一个证据，将它们作为这种所谓的更高身份类型的元素连接起来。好的。我们可以称之为更高身份，更高身份，或者有时我们会说这些方程在更高同伦、路径同伦中是正确的。</p><p>As I mentioned, these are the groupoid laws, and they can be written
            like that. Then it’s all a question of what we mean by equality. These
            are… if I only demand… The weakest possible thing to say is that,
            whenever two things are supposed to be equal, what I really mean is that
            there’s a proof, a piece of evidence, that connects them as elements of
            this so called higher identity type. Okay. We could call this somehow a
            higher identity, a higher identity, or sometimes we’ll say that the
            equations are true up to higher homotopy, homotopy of paths.</p>
        <h2 id="iterated-equality-types-and-dimensions">迭代相等类型和维度</h2><h2>Iterated Equality Types
            and Dimensions</h2>
        <p>好的，路径同伦。所以，当我们有这些迭代函数（对不起，迭代相等类型或识别类型）时，它会很快产生这种更高维度的结构。比如，现在，在下一个阶段，如果我再迭代一次并讨论路径之间的路径，那么无论如何我都很难绘制它们。好的。我不知道如何很好地绘制它们。所以，你不再依赖绘图，而是开始依赖代数。从某种意义上说，这就是代数的作用：它将你带到你无法真正描绘的维度，你无法真正绘制或轻松想象的维度。</p><p>Okay, path homotopy. So, when we have these iterated functions—excuse
            me, iterated equality types or identification types—that gives rise to
            this higher dimensional structure very quickly. Like, now, at the next
            stage, if I iterate that one more time and talk about paths between
            paths between paths, it becomes difficult for me anyway to draw them.
            Okay. I don’t know how to draw those very well. So, you stop relying on
            the drawings and you start relying on the algebra. And in a sense,
            that’s what algebra is for: is for taking you to dimensions that you
            can’t really depict, that you can’t really draw or visualize very
            easily.</p>
        <p>因此，这个想法就是，这个结构可以无限延续。也就是说，我可以做身份类型的身份类型或身份类型的身份类型的身份类型，一直到最后都是这样。好的。</p><p>So, the idea is that this structure continues, so to say, to
            infinity. That is, there, I can do identity types of identity types or
            identity types of identity types of identity types, and it’s like that
            all the way down. Okay.</p>
        <p>群胚定律成立的意义，最普遍的意义，是弱∞群胚的概念。这就是我们上次讨论的内容。弱∞群胚。这确实是我在做的事情。这里的“弱”是指只在高阶同伦中成立。</p><p>And the sense in which the groupoid laws hold, the most general
            sense, is the idea of a weak ∞ groupoid. That’s what we talked about
            last time. A weak ∞ groupoid. That’s really what I’m doing. And “weak”
            here means holds only up to higher homotopy.</p>
        <p>另一种可能性是，如果你只看这种图，你可能以前在范畴论中见过。你可能已经看到，在范畴论中，要求这些方程式成立，可以说，这是完全相同的映射。这个映射——如果你把它们看作这些路径，一种映射——我们说这个映射，这是范畴中的类似事物，是映射的组合。所以，如果我们有这个组合，我们有那个组合，我们要求它们是相等的。但在这个意义上的相等，在通常严格的一范畴意义上，要求它们是相同的，它们是相同的。所以，这就是弱和严格概念的由来。</p><p>The other possibility is, if you just look at this kind of picture,
            you might have seen before, for example, in category theory. And you
            might have seen that instead, in category theory, the demand is that
            these equations hold, so to speak, on the nose. That this be the exact
            same mapping. This mapping—if you think of these as these paths, kind of
            mappings—we’re saying that this mapping, this is the analogous thing in
            a category, is a composition of mappings. So, if we have this
            composition, we have that composition, we demand they be equal. But
            equality in that sense, in the usual strict one category sense, is
            demanding that they be identical, that they be the same. So, that’s
            where the notion of weak and strict comes from.</p>
        <p>所以，这是一个我们如何解释平等的问题。但在类型论中，平等是通过这些标识来解释的。因此，在类型论中，我们生活的自然世界是弱化事物，或者达到更高的同伦性。</p><p>So, it’s a question of how we interpret equality. But in type theory,
            equality is interpreted by these identifications. And so, the natural,
            the natural world in which we live in type theory is to treat things
            weakly, or up to higher homotopy.</p>
        <p>所以，这就是我们上次讨论内容的简要总结。我们讨论到了弱群定律。现在我想说一些必要的内容，以使其他内容和理论有意义。</p><p>So, that is a sort of a brief summary of where we got to last time.
            We got as far as talking about the weak groupoid laws. And now I want to
            say more things that are necessary to make everything else and the
            theory make sense.</p>
        <p>那么，接下来我想谈谈……</p><p>So, what I want to talk about next…</p>
        <p>（所以，这张图片是为了提醒你。我希望。我认为这就是我想要通过回顾来做的全部事情。让我检查一下。我对自己说，“画出关联图。”好的，所以我这样做了。好的。然后，好的，我知道我们在做什么。好的。所以，接下来我想谈的是重新审视这个问题，即我最初称之为功能性的问题，现在它将被推广到功能性。</p><p>(So, that’s the picture to remind you. I hope. I think that’s all I
            wanted to do by way of recap. Let me just check. I said to myself, “Draw
            the associativity diagram.” Okay, so I did that. Okay. And then, okay,
            so I know what we’re doing. All right. So, the next thing I want to talk
            about is revisiting this issue of what initially I called functionality,
            which will now become generalized to functoriality.</p>
        <h2 id="functoriality-and-path-induction">功能性和路径诱导</h2><h2>Functoriality and Path
            Induction</h2>
        <p>这就是我想要表达的意思。所以，我现在想讨论的是函子性的概念。所以，我在这里要做的是使用<em>j</em>的消去规则，即我们
            上次开发的恒等类型（称为 j ）的消去规则<em>。我们开发了该消去规则，将其视为</em><em>恒</em>等类型的终点，即归纳定义类型。
        </p><p>And that’s what I want to get at. So, what I want to talk about right
            now is the notion of functoriality. So, what I’m going to do here is I’m
            going to use the elimination rule for <em>j</em>, that we, as
            <em>j</em>, for the identity type, which is called <em>j</em>, that I
            developed last time. And we developed that elimination rule on the basis
            of thinking of it as an end of the identity as an inductively defined
            type.
        </p>
        <p>因此，让我们以非正式的方式提醒自己，这样我们就知道我们可以正式和非正式地做到这一点。因此，正式地，我们有以下消除规则来提醒自己：给定两个端点和它们之间的一些路径，我想说一些关于该数据的内容（我们称之为<em>p）</em>。好的。所以，这是<em>u</em>的一个元素，这是一个类型系列。但它是一个，或者你可以说它是一个关系或谓词，这取决于你在特定时刻想说什么，或者是一个类型系列。</p><p>So, let us remind ourselves, in informal terms, so that we know we
            can do it formally and informally. So, formally, we have the following
            elimination rule to remind ourselves: given two endpoints and some path
            between them, I want to say something—we’ll call it <em>p</em>—about
            that data. Okay. So, that’s an element of <em>u</em>, that’s a family of
            types. But it’s a, or you could say it’s a relation or predicate,
            depending on how you feel like speaking at a given moment, or a family
            of types.</p>
        <p>但是我可以想到，如果我尝试从命题的角度来思考它，这就是将其视为归纳规则的动机，我想说一些关于空间<em>a</em>中任意点之间的任意路径的事情。好的，这就是我想要做的。具体来说，我想说的是我想说一些关于<em>a 的</em>事情。我想说一些关于特定路径的事情。所以，我这里有一个<em>p ，它表示</em><em>a</em>和<em>a</em>和<em>b</em>相等。</p><p>But I can think of it, if I try to think of it propositionally, which
            is what motivates the thinking of this as an induction rule, I want to
            say something about an arbitrary path between arbitrary points in the
            space <em>a</em>. Okay, so that’s what I want to do. And in particular,
            what I want to say is I want to say something about <em>a</em>. I want
            to say something about a particular path. So, I have a <em>p</em> around
            here, which says that <em>a</em> and <em>a</em> and <em>b</em> are
            equal.</p>
        <p>好的。我想说，在什么条件下，我们可以说有证据证明<em>p</em>对<em>a</em>、<em>b</em>和小<em>p</em>成立吗？所以，我们要给出条件。我们上次提出的想法是，考虑反身性就足够了。这个想法是，你说，好吧，对于<em>a</em>中的
            任何<em>x</em>，请向我展示小<em>p</em>，<em>我会</em>
            写出<em>x</em>来强调它，这表明该属性对
            <em>x</em>、<em>x</em>和反身性都成立。
        <em></em><em></em><em></em><em></em><em></em><em></em></p><p>Okay. And I want to say, under what conditions, okay, can we say that
            there’s a proof that <em>p</em> holds for <em>a</em>, <em>b</em>, and
            little <em>p</em>? So, we want to give the conditions for that. And what
            we developed last time was the idea is it’s sufficient to consider
            reflexivity. The idea is you say, well, for any <em>x</em> in
            <em>a</em>, please exhibit for me little <em>p</em> and <em>i’ll</em>
            write of <em>x</em> to stress it, which says that the property holds for
            <em>x</em>, <em>x</em>, and reflexivity.
        </p>
        <p>然后，如果你能做到这一点，我们在这里使用一个叫做<em>j</em>的东西
            。然后，有各种符号约定。所以，我们写它的一种方式是，我们写<em>x</em>点<em>p</em>和<em>o </em>
            <em>p</em>。抱歉。我在这里超负荷了。我们把它叫做
            <em>q</em>。好的。还有<em>q</em>。好的。这就是我想要说的。这就是数据。我们有这个属性，只是为了提醒你，让我写一个速记。如果我们做 x ⋅ p 和反身性，如果你真的把它应用到反身性上，那么它在定义上等同于 a。这是正式的陈述。所以，非正式地，我们称之为主路径感应。
        </p><p>And then, if you can do that, we use something called <em>j</em>
            here. And then, there are various notational conventions. So, one way we
            write it is we write that of <em>x</em> dot <em>p</em> and <em>o</em>
            <em>p</em>. Sorry about that. I overloaded here. Let’s call that one
            <em>q</em>. Okay. And <em>q</em>. Okay. So, that’s what I meant to say.
            And that was the data. And we have the property, just to remind you,
            that let me just write shorthand. If we do x ⋅ p and reflexivity, if you
            truly apply it to reflexivity, then that is definitionally equivalent to
            a. That’s the formal statement. So, informally, we call this principle
            path induction.
        </p>
        <h2 id="path-induction-and-motive">路径诱导和动机</h2><h2>Path Induction and Motive</h2>
        <p>现在，我们要在这里连续多次使用路径诱导。所以，我想谈谈路径诱导。所以，这条线，这里的这个东西，被称为诱导的动机。这就是术语，好吗？</p><p>We’re going to use path induction several times in a row here, right
            now. So, I want to say something about path induction. So, this line,
            this thing here, is called the motive for the induction. That’s the
            terminology, okay?</p>
        <p>因此，归纳推理的动机就是你正在考虑的关系。我们暂时称之为关系。这就是你正在考虑的关系，它定义在空间 A 中的任意路径上。因此，我们要说的是，这就是所谓的动机。第二件事是所讨论的特定路径。所以，这就是我们所讨论的路径。因为，最终，我们想知道的是，关于该特定路径的某些东西是否成立，好吗？</p><p>So, the motive for the induction is the relation you’re considering.
            Let’s call it a relation for the moment. There’s the relation you’re
            considering, on that is defined on arbitrary paths in a space A. So, we
            have one to say something about that’s that’s the so called motive. The
            second thing is the particular path in question. So, this is our path in
            question. Because, in the end, what we want to know is something holds
            about that particular path, okay?</p>
        <p>还有这部分，好吗？我叫它什么？我在这里写了一个术语。哦，是的。这是充分性，或者其他什么。所以，我们可以把它看作是归纳步骤，如果你想这样看，好吗？写在这里，或者它是充分性。足以证明以下事情。如果我们想证明这对我们正在考虑的任意路径都成立，那么证明这一点就足够了，好吗？</p><p>And this part, okay? What did I call that? I had a terminology I was
            writing here. Oh, yeah. This is the sufficiency, or something. So, we
            can look at this as sort of the inductive step, if you want to look at
            it like that, okay? Which is written here, or it’s the sufficiency. It
            suffices to show the following thing. If we wish to show that this holds
            for an arbitrary path that we’re considering, then it’s sufficient to
            show this, okay?</p>
        <p>所以，这就是充分性。如果我们有这三点，那么我们就可以得出结论，该属性成立。归纳的动机对该路径有效。因此，我可以非正式地将其写为动机对有效——我只会写 q——我的意思是 a、b 和 q，因为你必须指定 q 从哪里来的部分。但我们就说 q 带来了 a 和 b，好吗？</p><p>So, that’s the sufficiency. And if we have those three things, then
            we can conclude that the property holds. That the motive for the
            induction is valid for that path. So, I can write it informally as the
            motive is valid for—I’ll just write q—I mean a, b, and q, because you
            have to specify the parts of where where q goes from. But let’s just say
            q brings a and b along with it, okay?</p>
        <p>因此，我们将进行大量证明，或者几个证明，然后，当 Dan 接手时，我们将进行更多遵循此模式的证明。因此，这是路径归纳的模式。我们将经常这样做。我之所以这样写，使用这样的图表，使用这样的对应关系，是因为归根结底，你知道，我们经常会写一个证明。我们会说，好的，定理或其他东西，这是动机。证明将通过路径归纳进行。实际上，定理是感兴趣的属性。然后我们要做的就是选择一个动机。这通常就是诀窍。然后，我们将在某条路径上进行路径归纳，在某条路径 p 上，无论 p 是什么。你选择问题中的那个，然后进行反身性案例，然后我说，好的，我们完成了，好吗？</p><p>So, we’re going to do a lot of proofs, or several proofs, and then
            later, when Dan takes over, we’ll do a lot more proofs that will follow
            this pattern. So, this is the pattern of path induction. We’re going to
            do this a lot. All so the reason I write it like this, with the chart
            like this, with the correspondence like this, is because at the end of
            the day, you know, very often we’ll write a proof. We’ll say, okay,
            theorem something or other, which is the motive. And the proof will be
            by path induction. And really, the theorem is the property of interest.
            And then what we do is we choose a motive. That’s often the trick right
            there. And then what we’re going to do path induction on some path, on
            some path p, whatever p might be. You pick that in question, and then do
            the reflexivity case, and then I, then you say, okay, we’re done,
            okay?</p>
        <p>这个想法是，这些数据中的内容最终会使用其中的 aj 编写一个函数式程序，从而为我们提供了我们想要的属性。编写证明时，如果需要，可以使用数学符号。这很好。但是，当你沿着这些对应关系将其拉回来并使其精确时，如果你正在机械化证明，并且你真的必须指示机器，你就会非常清楚地知道你在做什么，你正在编写一个函数式程序，并且你经常通过使用 j 进行计算来工作。现在，我稍后会回到这方面的一件了不起的事情，但是好吧。</p><p>And the idea is that this, what goes in this data, is ultimately
            writing a functional program using a j somewhere in there, which gives
            us, which gives us the property we want. When writing a proof, you can
            use mathematical notation if desired. That’s fine. But when you pull it
            back along these correspondences and make it precise, so if you were
            mechanizing the proof, and you really have to instruct the machine, you
            know quite explicitly what you’re doing, is you’re writing a functional
            program, and you’re often working by computing with j. Now, I’m going to
            come back a little bit later to a remarkable thing about this, but
            okay.</p>
        <h2 id="functoriality-and-definitional-equality">功能性和定义平等</h2><h2>Functoriality and
            Definitional Equality</h2>
        <p>现在我想要用功能性这个概念来做这件事。</p><p>So now here’s what I want to do with this notion of
            functoriality.</p>
        <p>所以，总体思路是这样的。记住功能性，非正式地说，功能性是什么意思？它意味着一切——好吧，这很宽泛，但你知道我的意思——一切都尊重定义等价或定义平等。因此，例如，如果 a 在定义上等于 b，那么我有一个函数——我会说 f(a) 在 B 中在定义上等于 f(b)，对于任何从 A 到 B 的 f。例如，这样就行了。因为你看到了定义——这就是我们所说的一切都尊重平等或专家尊重定义等价，这就是我们所说的功能性。</p><p>So, the general idea. Remember that functionality, informally, what
            did functionality mean? It meant that everything—well, this is very
            loose, but you know what I mean—everything respects definitional
            equivalence or definitional equality. So, for example, if a is
            definitionally equal to b, then I have a function—I’ll say that f(a) is
            definitionally equal to f(b) in B, for any f which goes from A to B. For
            that was, for example, okay. Because you see the definitional—this is
            what we mean when we say that everything respects equality or, expert
            respects definitional equivalence, is what we mean by functionality.</p>
        <p>好的，所以它的行为就像一个函数。函数无法区分定义上等价的参数。如果我们非正式地思考，定义上的相等性表达了意义上的相等性或某种简单的计算。它对应于这样的想法：你不能定义一个函数，它是二加二的一个东西，四的另一个东西。好的，否则，它就不是一个函数。好的，这就是整个想法。</p><p>Okay, so it behaves like a function. A function cannot distinguish
            definitionally equivalent arguments. And if we think informally, the
            definitional equality expresses equality of sense or some kind of just
            simple, simple calculation. It corresponds to the idea that you can’t
            define a function that is one thing on two plus two and something else
            on four. Okay, otherwise, it wouldn’t be a function. Okay, that’s the
            whole idea.</p>
        <p>好的，所以你想说我们可以尊重计算或定义上的相等性。一个相关的，实际上是一个特殊的例子，我们知道，a = b，意味着 F(a) 与 F(b) 在 U 中相同。对于 F 类型的族，即 A 到 U，这是一个特殊的事情。所以，这就是我引入宇宙的原因，因为这实际上是对 B 是 U 的特定选择的重新表述。就这样。好的，这就是我之前提到的便利。所以，当我有了宇宙，捕捉这两件事变得很方便。</p><p>Okay, so you want to say we can respect the calculation or
            definitional equality. And a related one, which really comes out as a
            special instance, is we know that again, a = b, implies that F(a) is the
            same as F(b) in U. This is a particular thing for a family of types F,
            which is A to U. So, this is why I introduce universes, because this is
            really a restatement of that with a particular choice of B being U.
            That’s all. Okay, that’s the convenience I mentioned before. So, when I
            have universes, it becomes convenient to catch these two things the
            same.</p>
        <p>现在，我们还指出，当我们第一次讨论这种形式的功能时，草花粉肯定在增加。因此，当我们讨论这种形式的功能时，我们指出定义等价仅仅是计算，不会——你知道，它们不会给我们很多东西。对吗？这不会——我们不会——我们经常使用它，但它不会给我们提供太多东西，就像人们天真地猜测的那样。因此，我们讨论了著名的 x + y 和 y + x 作为 Nat 类型的自然数表达式的例子。</p><p>Now, we also pointed out when we first talked about functionality in
            this form, the grass pollen must be increasing. So, when we talked about
            functionality in this form, we pointed out that definitional
            equivalences, being mere calculations, don’t—you know, they don’t give
            us a lot. Right? This doesn’t—we don’t—we use this quite a bit, but it
            doesn’t give us as much as one might guess naively. So, we talked about
            the famous example of sort of x + y and y + x as natural number
            expressions of type Nat.</p>
        <p>它们在定义上并不相等，因此这些原则不适用。函子性所表达的是，一切都尊重命题相等，或者我们可以说，同伦性。</p><p>They are not definitionally equal, therefore these principles do not
            apply. What functoriality expresses is that everything respects
            propositional equality, or we could say, homotopy.</p>
        <h2 id="functoriality-and-homotopy">功能性和同伦</h2><h2>Functoriality and Homotopy</h2>
        <p>例如，我想传达以下想法……我想说：如果 A 中的 a 等于 b，在同样假设 f 是这样的函数的情况下，则 a 的 f 等于 b 的 f。但这个陈述比它看起来要强大得多，因为如果你从普通的传统数学角度来看它，这只是相等，被视为一个要么成立要么不成立的命题。你会说，如果 a 等于 b，那么 a 的 f 就是 b 的 f。</p><p>For example, I want to convey the following idea… I want to say: if a
            is equal to b in A, under the same assumption that f is such a function,
            then f of a is equal to f of b. But this statement is much beefier than
            it looks, because if you look at it from an ordinary, conventional
            mathematics viewpoint, this is just equality, treated as a proposition
            that either holds or doesn’t. And you say, if a is equal to b, then f of
            a is f of b.</p>
        <p>就像，哈欠，好吧，那该怎么说呢？但是不，不。这里的重点是我们真正要说的是有关证明空间的事情。</p><p>And it’s like, yawn, okay, what’s what’s to say about that? But no,
            no. The important point here is what we’re really going to be saying is
            something about the space of proofs.</p>
        <h2 id="proof-relevant-mathematics-and-functoriality">证明相关数学和函数性</h2><h2>Proof-Relevant
            Mathematics and Functoriality</h2>
        <p>我们真正要说的是，当我写下这句话时，我的意思是这是真的。所以我说，如果你给我一个证明 a 等于 b，那么我可以把它变成一个证明，在这种情况下我称之为 app，如果你愿意，有不同的符号，但有一件事可能称 app 为 fp，这是 f(a) 等于 f(b) 的证明。</p><p>What we’re really going to be saying is, when I write this, I mean
            that’s true. So I say, if you give me a proof that a equals b, then I
            can turn that into a proof, which in this case I’ll call app, and if you
            want, there are different notations, but one thing might call app, f p,
            which is a proof that f(a) is equal to f(b).</p>
        <p>做与证明相关的数学，重要的是这就是行动所在。好吧，行动所在，就是写下并描述现有的证明，并理解这些证明是什么。所以这个叫做 app 的东西可以用两种方式来理解。它可以被称为，可以被认为是代表路径应用，也可以被认为是路径上的动作。</p><p>And the important thing about doing proof relevant mathematics is
            this is where the action is. Okay, where the action is, is in writing
            down and characterizing the proofs that exist and understanding what are
            those proofs. So this thing called app can be read in two ways. It can
            be called, it can be thought of as standing for path application, or it
            can be thought of as the action on paths.</p>
        <p>所以，对于你们中的那些人——这就是现在——我会……这激发了我提出函子性的想法。所以，如果你熟悉范畴论中函子的概念，它实际上分为两部分。如果我有一个函数，我将从一个范畴映射到另一个范畴，那么有一个 f——我们称之为 f——我们有 f₀，它将范畴 A 的对象与范畴 B 相匹配，然后有一个对应的函子函数 f₁，它将 A 中的映射映射到 B 中的映射，这样某些相干条件就成立了，也就是说，它保留了组合和身份。我通常很直白，所以这里也是一样。当我在这里写 f(a) 时，是这样吗？所以你可以把 f(a) 看作是一种零单元应用。我的意思是什么？零单元是空间中的一个点。因此，如果我愿意，我可以将其称为 app₀、f(a)，将 f 应用于零单元意义上的 a。</p><p>So, for those of you—and this is now—I will… this motivates for me
            the idea of functoriality. So, if you’re familiar with the idea of a
            functor in category theory, it’s really two parts. If I have a function,
            I’m mapping from one category to another, there’s the f—let’s call it
            f—we have f₀, which matches the objects of category A, let’s say, to
            category B, and then a corresponding functor function f₁, which maps
            maps in A into maps in B, in such a way that certain coherence
            conditions hold, that is, it preserves composition and identity. I’m
            typically on the nose, so it’s the same thing here. Is that when I write
            f(a) here, right? So you can think of f(a) as sort of a zero cell
            application. What do I mean by that? A zero cell is a point, okay, in a
            space. So I could—if I wanted—I could call that app₀, f(a), apply f to a
            in the sense of the zero cell.</p>
        <p>然后我需要另一个应用概念，我在这里写的是 app(f, p)。</p><p>And then I need another notion of application, which I’m writing
            app(f, p) here.</p>
        <h2 id="functoriality-and-one-cell-application">功能性和单细胞应用</h2><h2>Functoriality and
            One-Cell Application</h2>
        <p>有时，有一些符号表示要做什么，但有时用香蕉括号来表示。好的，或者我在这里写的是……我也写过 app、F、P。但如果我以最一般的方式考虑这个问题，这将是一个单元应用。但这将是 2P。好的。所以，这是一个单元应用，在这种情况下是它在态射或映射上的动作。好的。所以，这些单元可以被认为是一条边。</p><p>And sometimes there’s some notational thing about what to do, but the
            idea is that sometimes it’s written with banana brackets. Okay, or what
            I’ve written here is… I’ve also written that as app, F, P. But if I were
            thinking of this in the most general way, this would be one cell
            application. But this would be 2P. Okay. So, this is one cell
            application, which in this case is its action on morphisms or on maps.
            Okay. So, these one cell can be thought of as an edge.</p>
        <p>它可以被认为是一个映射。它可以被认为是一个态射。好的。它可以被认为是一个面，但它是一个面，就像一个点是一个面，一条边也是一个面一样。我们可以继续，我们可以将这些应用到任意维度。我们可以开始讨论维数。所以，但这就像范畴论一样。</p><p>It can be thought of as a map. It can be thought of as a morphism.
            Okay. It can be thought of as a face, but it’s a face in the same way
            that a point is a face and an edge as a face. And we can go on, and we
            can do these to all arbitrary dimensions. We can start talking about the
            dimensionality. So, but this is like in category theory.</p>
        <h2 id="functoriality-and-infinity-categories">函数性和无限范畴</h2><h2>Functoriality and
            Infinity Categories</h2>
        <p>你只需要一个范畴论，也就是你现在通常使用的范畴论。人们对无限范畴论非常感兴趣，它类似于我们在这里用类型论做的事情。例如，函子的相干条件不必完全成立。也就是说，一个函数，函子应用于组合时不必给你精确的映射组合。但它是可变形的。可变形是什么意思？</p><p>You have merely in one category theory, you—which is the category
            theory you normally use these days. People are very interested in
            infinity category theory, which is the analog of what we’re doing here
            with type theory. Where, for example, the coherence conditions on
            functors don’t have to hold, so to speak, on the nose. That is, a
            function, the functor applied to a composition doesn’t have to give you
            exactly the composition of the map. But it rather is deformable. And
            what does deformable mean?</p>
        <p>这意味着存在一个态射，还有另一个更高的嗡嗡声——另一个更高的嗡嗡声——态射之间有一个态射。所以，这就是我们得到这种结构作为无限范畴论的地方。这就是现在人们对范畴论的看法。无限范畴是人们感兴趣的情况。好的。而从历史上看，一类范畴是让一切开始运转的东西。好的。所以，我们有这个概念。所以，这有点像一个单元格的应用。所以，我们可以把它看作是零单元格的应用，这就是 I——F of A。</p><p>It means that there’s a morphism and yet another higher hum—another
            higher hum—there’s a morphism between morphisms. So, that’s where we get
            this kind of structure as an infinity category theory. And that’s these
            days, that’s the way people think about category theory. Infinity
            categories are the case of interest. Okay. Whereas historically, one
            categories were the things that got everything got the ball rolling.
            Okay. So, we have this notion. So, this is sort of one cell application.
            So, we can think of this as here’s zero cell application, and here’s
            what I’m—F of A is.</p>
        <p>我的意思是，当我在这里做手势时，A 的 F 和 F 和 B 是零单元应用，app。好的。是一个单元应用，它表示函数也是一个对路径 A、P 有作用的函子。当给出参数相等的证明时，即 A 和 B 之间的路径，那么映射将转换它们。所以，如果我们在这里取 A，在这里取 B。所以，这些是我的——让我给这些家伙起个名字。</p><p>I mean, when I gesture here, F of A and F and B are zero cell
            application, app. Okay. Is the one cell application, which says a
            function is also a functor that has an action on paths, A, P. When it,
            which when given a proof that the arguments are equal, that is a path
            between A and B, then the mapping will transform them. So, if we take A
            here and we take B here. So, these are my—let me give these guys
            names.</p>
        <p>这些是 A 和 B。然后，如果我看看 F 做了什么。好的。F 做了什么？它会发送这个 A。我们会将这个人发送到 B 的 F。这是零单元应用。此外，它会将路径 B 发送到路径。好吧，我 — — 让我在这里放宽一下。让我写 F，P。这是一种略微滥用的符号，一旦您有任意维度，它就会非常令人困惑。你永远不知道你在哪里。所以，我们倾向于回避这一点。但在一类理论中，这就是你一直做的事情。你只需写 f，知道你何时使用函子的态射部分，何时使用对象部分，你只是不以相同的方式表示它们。但是一旦我们开始在无限维的情况下工作，这种符号滥用就变得没有什么用处了。所以我只会非常谨慎地使用它，好吗？</p><p>So, these are A and B. Then, if I look at what F does. Okay. What
            does F do? It’ll send this A. We’ll send this guy to F of B. That’s the
            zero cell application. And moreover, it will send the path B to a path.
            Well, I—let me let me be loose here. Let me write F, P. That’s a
            slightly abusive notation, and it can be very confusing once you have
            arbitrary dimensions. You never know where you are. So, we have tended
            to shy away from that. But in one category theory, that’s what you do
            all the time. You just write f, knowing when you’re using the morphism
            part of a functor and when you’re using the object part, and you just
            don’t notate them the same way. But that notational abuse becomes not
            very helpful once we start working in the infinite dimensional case. And
            so I’ll use this only very sparingly, okay?</p>
        <p>但图片是：路径转化为路径。</p><p>But the picture is: the path is transformed into the path.</p>
        <h2 id="functoriality-and-maps-from-interval">区间函数性和映射</h2><h2>Functoriality and Maps
            from Interval</h2>
        <p>这里有另一种思考方式。我们稍后会在本讲座结束前给出一个例子。我们将有一个名为<em>I</em>的空间，它代表单位间隔，它有两个点，0 和 1，它们之间有一个线段。所以如果你把任何映射<em>f</em>带到任何<em>A</em>中，<em>f</em>会产生什么？如果我按照这幅图来看，我们会在<em>A</em>中看到什么？如果我们从这个场景、这个特定类型中取出一个函数<em>f ，我将其称为</em><em>I</em>，它代表间隔或零圆，好吧。我们有间隔。我们如何接管间隔？它是什么？会发生什么——f 会做什么<em>？</em>这里会发生什么？</p><p>So here’s another way of thinking about it. We’re going to give an
            example a little bit later toward the end of this lecture. Is that we’re
            going to have a space called <em>I</em>, which represents the unit
            interval, and we have it has two points, 0 and 1, and it has a segment
            between them. So if you take any mapping <em>f</em> that’s going along
            here into any <em>A</em>, what is <em>f</em> going to produce? If I just
            follow this picture, what are we going to see in <em>A</em>? If we take
            a function <em>f</em> from this, this scenario, this particular type,
            which I’ll call <em>I</em>, which stands for the interval or the zero
            circle, okay. We have the interval. How do we take the interval over?
            What is it? What hap—what does <em>f</em> do? What is going to happen
            here?</p>
        <p>嗯，它要做的就是在空间<em>A中生成一条路径。如果你想在空间</em><em>A</em>中挑选一条路径
            ，你要做的就是定义一个从区间到<em>A的映射。因为</em><em>f</em>必然会做什么，一旦我完成了这个函子性的证明，
             f必然会做什么，它将 f (0)，零应用，作为路径的端点，然后 f (seg) 将是它们之间的某条路径。让我以一种疯狂的方式写出来，以强调 f (seg) 是你想<em>在</em><em>f</em> ( <em>0</em> )<em>和</em><em>f</em> ( <em>1</em> )之间挑选的任何路径。
        </p><p>Well, what it’s going to do is it’s going to produce a path in the
            space <em>A</em>. If you want to pick out a path in the space
            <em>A</em>, the way you do it is you define a map, okay, from the
            interval into <em>A</em>. Because what—what <em>f</em> will do
            necessarily, once I finish proving this functoriality thing, what
            <em>f</em> will do necessarily is it will <em>f</em>(0), the zero
            application, will be the endpoints of the path, and then <em>f</em>(seg)
            will be some path between them. And let me write it in a crazy way to
            sort of stress that <em>f</em>(seg) is any path that you care to pick
            out between <em>f</em>(0) and <em>f</em>(1).
        </p>
        <p>因此，空间中的路径可以用从<em>I</em>到
            <em>A</em>的映射来标识。事实上，我们最终会得到这个结果。我们将研究恒等类型的总空间。在某种意义上是等价的，我将解释——同构到同构——这个总空间，这个大和，将等价于函数空间
            <em>I</em>到<em>A</em>。如果你们中有人曾经在经典环境中研究过任何同伦理论，那么你们会将<em>I</em>定义为实数线的子集，并且路径由从实际解析单位间隔到空间的连续函数给出。
        </p><p>So paths in a space can be identified with maps from <em>I</em> to
            <em>A</em>. In fact, we’re going to wind up with that. We’re going to
            look at the total space of the identity type. Will be equivalent, in a
            sense, I’m going to explain—isomorphism up to isomorphism—the total
            space of this, the big sum, will be equivalent to the function space
            <em>I</em> to <em>A</em>. And if any of you have ever studied any
            homotopy theory in classical settings, what you do is <em>I</em> is
            defined to be a subset of the real line, and a path is given by a
            continuous function from the actual analytic unit interval into the
            space.
        </p>
        <p>因为它说这确实是数字，实数 0，实数 1，而这就是它们之间存在的点序列。然后你就有了一个连续变换，称为解析同伦理论，因为它从分析开始，使用实数和实线的拓扑，并使用实线上的连续函数。然后你从那里开始建立路径的概念。这就是解析同伦理论。我们正在做的是函数式程序员会做的事情。这就像汇编；如果这真的是解析区间，那么它有点像汇编语言编程。这有点像说，“好的，是的，是的。如果你真的坚持，你可以用 C 语言构建函数式编程的所有设备，只需手动完成所有操作，好的，就内存管理和移动东西等等。如果你能坚持这样做，你就能做到，是的。”</p><p>Because it says this really is the number, the real number 0, the
            real number 1, and this is all this, the sequence of points that exist
            between them. And then you have a continuous transformation called
            analytic homotopy theory, because it starts with analysis, using the
            real numbers and the topology of the real line, and working with
            continuous functions on the real line. Then you start building up the
            notion of a path from there. That’s analytic homotopy theory. What we’re
            doing is what functional programmers would do. This is like assembly; if
            this were really the analytic interval, then it’s sort of like assembly
            language programming. It’s sort of like saying, “Okay, yes, yes. If you
            really insist, you could build up all of the apparatus of, you know,
            functional programming in C by just doing everything by hand, okay, in
            terms of memory management and moving things around, and so on. And if
            you could stand to do it, you could do it, yes.”</p>
        <p>前进。</p><p>Go ahead.</p>
        <p>所以，当您说……是的，它是任何路径？好吧，事件……好吧，我的意思是，如果您想要挑选一条路径<em>p</em>，您可以选择<em>f ，这是一个映射，它将是从</em><em>i</em>到<em>a</em>的映射，以挑选出一条特定的路径<em>p</em>，或者反过来。如果您给我这样一个<em>f</em>，它所做的就是挑选这条路径？嗯，它是一个函数，是的。是的，是的。它是一个函数，是的，完全正确。所以，它挑选出一条路径。这个想法是，它是集合元素可以通过从单例到集合的函数来识别的想法的概括。每个这样的映射都确定该集合的一个元素，并且该集合的每个元素都可以以这种方式挑选出来，好吗？</p><p>So, when you say that… yeah, it’s any path? Well, event… well, what
            I’m saying is you can choose, if you want to pick out a path <em>p</em>,
            you can choose <em>f</em>, which is a mapping which will be a mapping
            from <em>i</em> to <em>a</em>, to pick out a particular path <em>p</em>,
            or the other way around. Is if you give me such an <em>f</em>, what it’s
            doing is picking out this path? Well, it’s a function, yes. Yeah, yeah.
            It’s a function, yeah, exactly right. So, it picks out a path. It’s the
            idea that it’s a generalization of the idea that the elements of the set
            can be identified by functions from the singleton into the set. Every
            such mapping determines one element of that set, and every element of
            that set can be picked out in that manner, okay?</p>
        <p>嗯，这是从零个单元格到一个单元格的概括。所以，如果我……我可以挑选出集合中的两个元素，而我真正挑选的是它们之间的一条路径。任何路径都是以这种方式出现的，好吗？这就是我要说的。所以，是的。那又是什么？我不认为我……我的意思是，我只是说也许有一种方法可以这样看待它，但我自己现在没有看到它。</p><p>Well, this is the generalization of that from zero cells to one
            cells. So, if I… I can pick out two elements of the set, and what I’m
            really picking out is a path between them. And any path arises in this
            way, okay? That’s what I’m saying. So, yeah. What’s that again? I don’t
            think I… I mean, that I just mean it in the sense that I was saying that
            maybe there’s a way to see it that way, but I’m not seeing it myself at
            the moment.</p>
        <p>这个想法只是一种概括，即集合中的元素可以用从 1 到<em>a 的</em>映射来识别，因此集合中的路径可以用从<em>i</em>到<em>a 的</em>映射来识别。这就是我要说的。对于每条路径……是的，对于每条路径都有……是的，这是真的。因为它在某种程度上是一种初始对象。是的，这里有一种初始性。是的，这是真的。我必须考虑一下如何正确表达这一点，但是是的，你可能是对的。</p><p>The idea is that it’s just a generalization that the elements of the
            set can be identified with maps from one to <em>a</em>, and so the path
            in the set can be identified with maps from <em>i</em> to <em>a</em>.
            That’s all I’m saying. For every path… yeah, for every path there is…
            yeah, that’s true. Because it’s kind of an initial object in some way.
            Yeah, there’s a kind of an initiality going on here. Yeah, that’s true.
            I’d have to think about the right way to say that, but yes, you’re
            probably right.</p>
        <h2 id="synthetic-homotopy-theory">合成同伦理论</h2><h2>Synthetic Homotopy Theory</h2>
        <p>好的。</p><p>Okay.</p>
        <p>不是……好吧。所以，我想结束一个小点，那就是：所以，解析同伦理论始于分析。我们正在做的是合成同伦理论。我们正在做函数式程序员会做的事情。好吧，看，路径的概念是一种抽象类型。好的，我在路径中关心的是有一个平凡的空值，有一个附加值、它们的连接值和它们的反转值。我不关心你如何在汇编语言中实现它。</p><p>It isn’t… okay. So, I want to finish a minor point, which is: So,
            analytic homotopy theory starts with analysis. What we’re doing is
            synthetic homotopy theory. We’re doing what functional programmers would
            do. Well, look, the idea of a path is an abstract type. Okay, what I
            care about in a path is that there’s a trivial null one, and there’s an
            append, a concatenation of them, and a reversal of them. And I don’t
            care how you implement that in assembly language.</p>
        <p>好的。对我来说，你为了实现抽象做了什么工作并不重要。我关心的是抽象，好吗？在这种情况下，这被称为综合方法。这就是综合方法。因此，我们所做的是所谓的综合同伦理论的一个例子。我们不依赖于分析。所以，有趣的是，正如你在 Dan Lakata 的发展中看到的那样，我们能够开发相当一部分，嗯，我认为是基本同伦理论，但不是平凡的基本同伦理论。然而，其中没有任何地方与实数有关。没有任何东西——没有拓扑空间的定义。不知道什么是连续函数。这一切都是类型理论的内在，这是非常重要的事情。</p><p>Okay. Like, it’s not important to me what bit banging you do to
            realize that abstraction. What I care about is the abstraction, okay?
            That’s called the synthetic approach in this setting. That’s the
            synthetic approach. And therefore, what we’re doing is an example of
            what is called synthetic homotopy theory. We’re not depending on
            analysis. So, what’s interesting is that, as you’ll see with Dan
            Lakata’s developments, is that we’re able to develop quite a chunk of,
            well, I think elementary homotopy theory, but a non trivial chunk of
            elementary homotopy theory. And yet, nowhere in there is there anything
            to do with the real numbers. There’s nothing—there’s no definition of
            what a topological space is. There’s no idea of what a continuous
            function is. It’s all intrinsic in the type theory, and that’s the very
            important thing.</p>
        <p>所以，我换一种说法：它是类型理论中捕捉到的内在观点。我不知道还有什么更好的说法，或者它是我们从中抽象出来的综合观点。同伦理论有很多例子，不仅限于拓扑空间和连续映射，实际上还存在于其他类型的结构中。类似的路径概念和路径保存也出现了。类型理论就是这种抽象理论。所以，这就是正在发生的事情。</p><p>So, another way I’m saying it is: it’s the—in what type theory
            is—capturing it’s an intrinsic view. I don’t know any better way to say
            it, or it’s the synthetic view that we abstract away from that. There
            are many instances of homotopy theory, not limited to topological spaces
            and continuous mappings, but in actually other kinds of structures.
            Similar notions of path arise and preservation of path. And type theory
            is the abstract theory of that. So, that’s what’s going on.</p>
        <p>所以，从某种意义上来说，这是很好的计算机科学。比如，从计算机科学的角度来看，将其识别为抽象类型并识别路径归纳原理对我们来说是非常自然的事情。这是我们几十年来从类型理论和函数式编程中继承下来的遗产。事实上，事实证明，数学家们从未注意到这一点。好吧，因为这不像是思维方式；就像他们不是这样的。</p><p>So, it’s good computer science in a way. Like, from a computer
            science point of view, identifying this as an abstract type and
            identifying the principle of path induction is what comes extremely
            naturally to us. That’s our legacy from type theory and functional
            programming for decades. And as a matter of fact, as it turns out, the
            mathematicians never noticed this. Okay, because it’s just not like the
            mindset; it’s just like they’re not the way it is.</p>
        <p>因此，这些进步之所以成为可能，是因为数学思想和计算思想的结合，以及它们之间的相互影响。所以，这就是过去几年发生的事情——对这一事实的认可。</p><p>So, the thing that is the thing that has made these advances possible
            is a marriage of well understood mathematical ideas and well understood
            computing ideas, and realizing that they each inform the other. So, that
            is kind of what has happened over the last couple of years—a recognition
            of this fact.</p>
        <p>所以，我喜欢这样看待它，因为从计算机科学的角度来看，我们在这里使用函数式编程等的方式非常自然。好的。这就是想法。好的。</p><p>So, I like to view it this way because the way we work here with
            functional programming and so on is very natural from a computer science
            point of view. Okay. That’s the idea. Okay.</p>
        <p>所以，在我的脑海里，我应该说服你，我们所做的一切都只是函数式编程。事实上，你将会看到，当 Dan 接手时，他——我已经为他做好了准备。就像，我花了整整一周的时间来打好基础，这样他就可以摘下一些真正令人惊叹的樱桃。你将享受一些精彩的论证，你会发现被描述为“数学和编程”的东西实际上只是传统的函数式编程技术。而且，同伦理论中出现了新的结果证明，这些结果以前从未被给出过，因为函数式编程思维从未被应用于这个问题。</p><p>So, I’m supposed to be, in my mind, I’m supposed to be convincing you
            that everything we’re doing is just functional programming. And indeed,
            what you’re going to see is when Dan takes over, he—I’ve set him up.
            Like, my whole week has been spent setting up the groundwork so that he
            can pick off some really amazing cherries. You’ll enjoy some delicious
            arguments ahead, where you’ll see that something described as
            “mathématiques et programmation” is really just conventional functional
            programming techniques. And there are new proofs of results in Homotopy
            Theory that never were given before because that functional programming
            mindset was never brought to bear on the problem.</p>
        <p>所以，反过来也是一样。但两者都是。是的，我要……我现在要证明这一点。是的，是的，没错。好吧，我马上就解释一下这是什么意思。好的，但是是的，是的。所以，现在，我要解释一下。好的。所以，这就是我要说的。所以，这将是一个定理。好的。这将是……这不像一个公理。这将是一个定理。</p><p>And so, it’s going the other way as well. But it’s both. Yeah, I’m
            going to… I’m going to prove this now. Yes, yes, exactly. Well, I’m
            going to explain what this means in a minute. Okay, but yes, yes. So,
            now, now I’m going to explain it. Okay. So, here’s the thing that I’m
            going to get at. So, this is going to be a theorem. Okay. This is going
            to be… this is not like an axiom. This is going to be a theorem.</p>
        <p>好的。这将是一个定理。好的。我要这样做。我现在要进行这个论证。这个想法是……但我想说的是，因为这是一个微妙的观点。</p><p>Okay. This will be a theorem. Okay. And I’m going to do this. I’m
            going to do that argument right now. The idea is… but here’s what I want
            to get at, because this is a subtle point.</p>
        <h2 id="path-induction-and-constructivity">路径归纳与构造性</h2><h2>Path Induction and
            Constructivity</h2>
        <p>如果这是一条定理，则意味着路径归纳的概念中隐含着一切都遵循路径。这有点不明显。好吧。换一种说法……另一种说法是这样的。这就像通过传达直觉一样。路径归纳之所以有效，是因为类型理论中可定义的一切都会自动遵循路径结构。在类型理论中，没有办法写出一个无法满足此要求的函数。</p><p>For this to be a theorem means that it’s implicit in the concept of
            path induction that everything respects paths. That is kind of non
            obvious. Okay. Another way around… another way to say it is this. This
            is just like, by way of conveying intuitions. The reason that path
            induction is valid is because everything that is definable in Type
            Theory automatically respects the path structure. There’s no way to
            write down a function in Type Theory that would fail to satisfy this
            requirement.</p>
        <p>这有点像说……类型论也是如此，我们可以在类型论中写下的每个函数都可以解释为拓扑空间，并且您可以写下的所有函数都是自动连续的。没有办法写下不连续函数。让我给你一个直觉。这不是……这不是任何东西的证明，但我认为这是一个有用的直觉。如果你想想你的大一微积分或其他什么，以及不连续函数的概念。</p><p>It’s a little bit like saying… and it’s also true about Type Theory
            that every function we can write down in Type Theory can be interpreted
            into topological spaces, and all the functions you can write down are
            automatically continuous. There’s no way to write down a discontinuous
            function. And let me give you an intuition about that. It’s not… this is
            not a proof of anything, but I think it’s a useful intuition. If you
            think about your, you know, freshman calculus or whatever, and the idea
            of a discontinuous function.</p>
        <p>那总是例子吗？总是有定义的吗？它总是这样定义的：“哦，我有一个函数，它可能从零到一，然后从一变成一。”这是一个阶梯函数。那里有一个案例分析，你说参数小于或等于一或大于一。如果它小于或等于一，答案就是零。如果它大于一，答案就是一。</p><p>How is that always the example? Always defined? It’s always defined
            by saying, “Oh, I have a function which is like maybe zero up until one,
            and then from one it becomes one.” It’s a stair step function. There’s a
            case analysis there at that point where you say the argument is either
            less than or equal to one or greater than one. And if it’s less than or
            equal to one, the answer is zero. If it’s greater than one, the answer
            is one.</p>
        <p>这就是不连续性。函数从那里跳转。好吧，如果你从函数式编程的角度考虑这个问题，你将如何编写该代码？因为对于实数来说，你不可能告诉我，对于一般的实数，它是否小于或等于一？好吧。这是不可能的。为什么？你可以考虑一下。这可以证明，但是……你可以用很多方式直观地思考它。</p><p>And that’s a discontinuity. That function jumps from there. Well, if
            you think about this from a functional programming point of view, how
            are you going to write that code? Because there’s no way for a real
            number… you can tell me for a general real number, is it less than or
            equal to one or not? Okay. It’s not possible. Why? You can think about
            this. This can be proved, but there… You can think about it intuitively
            in many ways.</p>
        <p>一个是考虑十进制展开。你看到的是 0.999999999999……只要你看过，你就会发现所有的 9。但就你所知，它即将偏离并得到 8。但话又说回来，它可能会继续得到那些 9。所以，这是其中之一。所以，你看，这不可能是一个非正式的论点，但没有办法做出决定。这意味着，让我们这样说吧：类型理论是建设性的，这一事实阻止了你定义不连续函数。</p><p>One is to consider decimal expansions. You’re seeing 0.99999999999…
            and as long as you’ve looked, you’ve seen all nines. But for all you
            know, it’s just about to veer off and get an eight. But then again, it
            might just continue with those nines. And so, that’s one. So, you see,
            there’s no way this is an informal argument, but there’s no way to make
            the decision. What it means is, let’s put it this way: the fact that
            type theory is constructive is what prevents you from defining the
            discontinuous function.</p>
        <p>现在，我所论证的并不是这一事实的证明，而是一种启发式指南，对吧？你是否觉得，要定义某种不连续的东西，你需要在某个时候做出三分法决策。好吗？建设性数学否认你不能免费获得可判定性。所以，在实数的情况下，你不会得到三分法。如果你没有三分法，因为没有你可以编写的程序来计算……</p><p>Now, what I argued is not a proof of that fact, but it’s a heuristic
            guide, right? Is that you kind of have the feeling that to define
            something discontinuous, you’re going to need to make a trichotomous
            decision at some point. Okay? Constructive math denies that you don’t
            get, for free, the decidability. So, in the case of real numbers, you
            don’t get trichotomy. If you don’t have trichotomy, because there’s no
            program you can write to… to… to calculate the…</p>
        <p>做出决定，那么你将无法写下连续不连续函数。这是启发式论证。这不是证明，好吗？但这就是正在发生的事情。同样的事情也发生在类型理论中。我写下的一切都很好，因为它是很好的建设性数学。一切都会尊重路径，因为一切都会尊重路径，所以我可以做综合的、共同主题的理论。简而言之，就是这样，好吗？这是伟大的事情。所以，想想这个。这意味着，在我看来，受可计算性考虑驱动的构造性是一个基本的计算机科学概念。构造性对于获得一个清晰的解释来处理……是绝对必要的。</p><p>to make the decision, then you’re not going to be able to write down
            continuous discontinuous functions. That’s the heuristic argument. It’s
            not a proof, okay? But that’s what’s going on. The same thing is
            happening here in type theory. Everything I write down is good
            constructive math, because it’s good constructive math. Everything will
            respect paths, and because everything will respect paths, I can do
            synthetic, common topic theory. That’s it, in a nutshell, okay? This is
            the great thing. So, think about this. It means that constructivity,
            which is motivated by considerations of computability, in my mind, is a
            fundamentally computer science notion. Constructivity is absolutely
            essential to getting a clean account of dealing with…</p>
        <h1 id="type-theory-foundations-5.1-robert-harper">类型理论基础 5.1 — Robert Harper</h1><h1>Type Theory
            Foundations 5.1 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,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">11 年前 (2014 年 1 月 5 日) — 37:02 <a href="https://youtube.com/watch?v=Z8dPC88XhXA">https://youtube.com/watch?v=Z8dPC88XhXA</a></p><p> 11
            years ago (Jan 5, 2014) — 37:02 <a href="https://youtube.com/watch?v=Z8dPC88XhXA">https://youtube.com/watch?v=Z8dPC88XhXA</a></p>
        <h2 id="summary-13">概括</h2><h2>Summary</h2>
        <p>本视频讨论了计算数学，认为计算机科学是一门主学科，数学源于计算。演讲者强调了构造性和类型理论在这种方法中的重要性。他以函子性（通过路径归纳证明的定理）为例，说明类型理论如何允许开发丰富的数学结构。演讲者还解释了类型间等价的概念，强调了它与范畴论和同构的联系。</p><p>This video discusses the mathematics of computation, arguing that
            computer science is the master discipline and mathematics arises from
            computing. The speaker emphasizes the importance of constructivity and
            type theory in this approach. He uses the example of functoriality, a
            theorem proven by path induction, to illustrate how type theory allows
            for the development of rich mathematical structures. The speaker also
            explains the concept of equivalence between types, highlighting its
            connection to category theory and isomorphisms.</p>
        <h2 id="constructive-mathematics-and-computer-science">构造数学与计算机科学</h2><h2>Constructive
            Mathematics and Computer Science</h2>
        <p>数学是一种非常抽象的数学，你可能会认为它与计算毫无关系，但正是建设性的观点使得 Dan 将向你展示的这种非常漂亮的发展成为可能，而这种发展也出现在你将看到的热门书中，即这种数学分支。建设性是核心。所以，在我看来，这在一定程度上是计算机科学是一门主学科的原因——你知道，我可能以前就跟你说过。</p><p>Mathematics of a very abstract character, that you would think has
            nothing whatever to do with computation, but the constructive point of
            view is what makes it possible to do this very beautiful development
            that Dan will be showing you, of and is in the hot book you’ll see, of
            this kind of branch of mathematics. Constructivity is at the core. So,
            this is partly where, in my mind—you know, I may have said this to you
            before—computer science is the master discipline.</p>
        <p>好吗？数学源于计算。好吗？首先从算法的概念开始。算法的概念是一个循序渐进的过程，是证明的概念，也是构造某种东西的概念，就像几何学中一样。数学大厦就是在这个基础上建立起来的。但一切都归结为算法的概念。这就是 Brouwer 在 20 世纪 30 年代的杰出见解，好吗？就是为了建立它。我坚信这一观点。所以，实际上，这都是计算机科学。好吗？因此，与其说计算机科学是应用数学的某个角落，不如说相反，数学实际上是计算机科学的某个角落。好吗？这就是我喜欢思考的方式。这是一种偏见，我的偏见。好吗？</p><p>Okay? Math arises from computing. Okay? You start with the notion of
            algorithm. The notion of algorithm is a step by step procedure that is
            the notion of a proof, which is also the notion of a construction of
            something like in geometry. And it’s on that basis that you build up the
            edifice of mathematics. But it all comes down to the idea of algorithm.
            So, this is Brouwer’s brilliant insights in the 1930s, okay? Was to
            build that up. I firmly believe in that perspective. So, it’s all
            computer science, actually. Okay? So, rather than computer science being
            some corner of applied math, maybe it’s the other way around, that math
            is actually some corner of computer science. Okay? So, that’s the way I
            like to think about it. That’s a bias, my bias perspective. Okay?</p>
        <p>那么，现在让我们做点什么吧。好吗？所以，关于……我想履行我之前对你们的义务，我提到过，那就是告诉你们建设性是这一切的核心。</p><p>So, now let’s do something here. Okay? So, concerning… I wanted to
            discharge my previous obligation to you, which I mentioned, which was to
            say to you that constructivity was central to all of this.</p>
        <h2 id="constructivity-and-type-theory">构造性和类型理论</h2><h2>Constructivity and Type
            Theory</h2>
        <p>如果没有建设性，没有在建设性框架下工作，整个事情就无法进行。所以，这也是类型理论至关重要的另一个原因。我无法基于一阶逻辑或集合论来做到这一点。没有办法做到这一点。好吗？它从一开始就包含太多错误的假设。现在没有出路，或者你走进了死胡同。好吗？类型理论有正确的起点，因为它基于计算，它现在允许我们开发非常漂亮的结构。这就是我想做的。好吗？</p><p>The whole thing can’t work if you don’t have a constructive, if
            you’re not working in a constructive framework. So, this is another
            reason why type theory is of central importance. I can’t do this on the
            basis of first order logic or set theory. There’s no way to do this.
            Okay? It has baked in too many bad assumptions at the outset, from the
            get go. And now there’s no—there’s no way out, or you’re down a cul de
            sac. Okay? Type theory has got the right starting point because it’s
            based on computation, and it allows us now to develop very beautiful
            structures. And that’s what I’m trying to do. Okay?</p>
        <h2 id="proof-of-functoriality-by-path-induction">通过路径归纳证明函数性</h2><h2>Proof of Functoriality
            by Path Induction</h2>
        <p>那么，让我们看看如何证明函子性。我想说的是，这是一个定理，也就是说，它是路径归纳原理的结果。好吗？那么，我们如何证明呢？我想我必须在这里掩盖我自己的工作。所以，让我们重申一下。所以，我说的是，路径在这里上演。第三行，你称之为归纳……是的，我不知道还能叫它什么。</p><p>So, let’s look at how we do a proof of functoriality. So, what I want
            to get at is it’s a theorem, which means it’s a consequence of the
            principle of path induction. Okay? So, how do we do this proof? So, I
            thought I have to obscure my own work there. So, let’s restate it. So,
            what I say is that the path is staged here. The third line, which you’re
            calling the induction… yeah, I didn’t know what else to call it.</p>
        <p>是的。它完全不依赖于第二行。不，那是对的。是的，这是真的，因为归纳的东西会说，凭借归纳步骤，无论你选择哪条特定路径，它都会坚持下去。是的。所以，你可以这样写。所以，这是人们阅读的另一种方式。我上次可能这样写过。而不是考虑到这一点，你要做的是说：给定任何<em>z</em>，它在<em>a</em>中的任何路径之间，那么<em>z</em>的<em>j这里是</em><em>a </em><em>b </em><em>z</em>的证明。<em></em><em></em> <em></em> <em></em></p><p>Yeah. It doesn’t depend at all on the second line. No, that’s right.
            Yes, that’s true, because the inductive stuff is going to say, by virtue
            of the inductive step, whatever particular path you pick, it will hold
            through. Yeah. So, you could write it like this. So, here’s another way
            that people read. I might have written it this way last time. Rather
            than factor this in, what you do is you say: given any <em>z</em>, which
            is between any path in <em>a</em>, then <em>j</em> of <em>z</em> here is
            a proof of <em>a</em> <em>b</em> <em>z</em>.</p>
        <p>这是另一种说法。是一样的，但只是另一种说法。所以你是对的。有时你甚至可以忽略这一点，隐式地或将其视为<em>z</em>的函数。好的。然后它看起来就像那样。所以这是另一种写法，但这与数学归纳法原理相同。我的意思是，我……我……这只是一个问题，就像你如何……如何传递信息，你知道。</p><p>That’s another way of saying it. It’s the same, but it’s another way
            of saying it. So you’re right. And then sometimes you can even just miss
            that out and implicitly or think of it as a function of <em>z</em>.
            Okay. And then it looks like that. So that’s another way to write it,
            but that’s the same with the principle of mathematical induction. I
            mean, I… I… it’s just a question of like how you… how you push around
            the information, you know.</p>
        <h2 id="path-induction-and-functoriality">路径归纳和功能性</h2><h2>Path Induction and
            Functoriality</h2>
        <p>好的。</p><p>Okay.</p>
        <p>所以现在我想做这个路径归纳。我想通过路径归纳来做这个非常简单的证明，它告诉你眼前的一切都遵循路径。所以我说：如果<em>f是从</em><em>a</em>到
            <em>b</em>的函数，并且我在
            <em>a中有一条</em><em>a</em>和<em>b</em>之间的路径，那么我就有一条路径，我们将其称为<em>app </em><em>f </em><em>a ，它是</em><em>a</em>的<em>f</em>（零单元应用）和<em>f </em><em>b</em>之间的路径。好的。这是我能想到的最简单的、最简单的保留属性，或者尊重相等性，或者函数性属性。
        <em></em><em></em>
            <em></em> <em></em><em></em><em></em><em></em> <em></em></p><p>So now I want to do this path induction. I want to do this very
            simple proof by path induction, which tells you that everything in sight
            respects paths. So I say: if <em>f</em> is a function from <em>a</em> to
            <em>b</em>, and I have a path between <em>a</em> and <em>b</em> in
            <em>a</em>, then I have a path, which we will call <em>app</em>
            <em>f</em> <em>a</em>, is a path between <em>f</em> of <em>a</em>, the
            zero cell application, and <em>f</em> <em>b</em>. Okay. That’s the
            simplest, the simplest preservation property, or respect for equality,
            or functoriality property that I can think of.
        </p>
        <p>因此，作为第一个例子……换句话说，我真正的意思是存在一个映射<em>app ，它具有</em><em>app </em> <em>f </em> <em>a是</em><em>f </em>
            <em>a</em>和<em>f</em> of <em>b</em>之间的路径的属性
            。这就是我写这句话的意思。好的。
        </p><p>So to do this as a first example… In other words, what I really mean
            is then there exists a mapping <em>app</em>, which has the property that
            <em>app</em> <em>f</em> <em>a</em> is a path between <em>f</em>
            <em>a</em> and <em>f</em> of <em>b</em>. That’s what I mean when I write
            that. Okay.
        </p>
        <p>所以我要定义它。所以我要做的是……所以我要做的是证明。所以这将是我们的定理，证明将通过<em>p</em>上的路径归纳。现在，就像你一生中做过的任何归纳论证一样……好的。百分之九十的战斗是知道你将要做的归纳假设是什么。归纳的动机是什么？一旦你弄清楚了，剩下的就水到渠成了。但找到答案可能会非常复杂。好的。谁知道呢？好的。有很多计算机软件被编写来猜测归纳假设，你已经开发出了很多技巧。但最终，你知道，面对一个新问题，你必须想出答案。所以这里没有什么魔法。我只是碰巧知道答案。好的。</p><p>So I’m going to define it. So what I do is… so what I’m going to do
            is the proof. So this will be kind of our theorem, and the proof will be
            by path induction on <em>p</em>. Now, just like any inductive argument
            you’ve ever done in your life… Okay. Ninety percent of the battle is
            knowing what is the inductive hypothesis that you’re going to be doing.
            What is the motive for the induction? Once you figure that out, the rest
            takes care of itself. But finding that can be arbitrarily complicated.
            Okay. Who knows? Okay. There are lots of computer software that have
            been written to guess inductive hypotheses, and you’ve developed a lot
            of tricks. But in the end, you know, with a fresh problem, you have to
            think it up. So there’s no magic here. I just happen to know the answer.
            Okay.</p>
        <p>那么……那么动机是什么？一旦我说出了动机，那么一切都变得简单了。所以我必须说动机是什么。好吧，在这种情况下，你可以得到，它非常简单，你可以弄清楚动机是什么。好的。所以这个想法是，我想要最终证明存在这种类型的居民。好的。所以这是我的……将其视为
            <em>p </em> <em>a </em> <em>b ，对于</em><em>p</em>的一些选择。
        </p><p>So… so the what is the motive? So once I say the motive, then it’s
            all easy. So I have to say what the motive is. Well, you can get in this
            case, it’s so simple that you can kind of figure out what the motive
            must be. Okay. So the idea is I want to wind up proving that there’s an
            inhabitant of this type. Okay. So this is my… think of this as
            <em>p</em> <em>a</em> <em>b</em> for some choice of <em>p</em>.
        </p>
        <p>这就是我的动机。好的。因为我试图证明关于路径 p 的一些东西。它应该是大写的 P，好的。试着让它看起来大写，好的。所以，那是大写的 P。所以，如果我试图证明关于一条路径的一些东西，好的，我要陈述的事情涉及——它实际上并不涉及 p，但它确实涉及它的端点。所以，这是一种受限的情况，好的。也就是说，我只对端点感兴趣，因为它们只——换句话说，如果你看左边的假设，结论中出现的唯一东西是路径的端点，而不是路径本身。</p><p>That’s my motive. Okay. Because I’m trying to prove something about
            path p.&nbsp;That’s supposed to be a capital P, okay. Try to try to make it
            look capital, okay. So, that’s capital P. So, if I’m trying to prove
            something about a path, okay, and the thing I’m going to state about it
            involves—it doesn’t actually involve p, but it does involve its
            endpoints. So, it’s kind of a restricted case, okay. That is, I’m only
            interested in the endpoints because they only—in other words, if you
            look on the left at the hypotheses, the only thing that appears in the
            conclusion are the endpoints of the path and not the path itself.</p>
        <p>碰巧，还有其他证明需要你关心 p，但在这种情况下，我并不关心，好吧。所以，这就是我的大写 P。所以，你想，好吧，那么动机是什么？好吧，它将在 A 中给出 x，在 A 中给出 y。我希望大写 P 是我希望 x、y 的 P 是以下类型：f(x) 在 B 中等于 f(y)。而 u，这就是我的动机，好吧。</p><p>As it happens, there are other proofs where you care about p, but in
            this case, I don’t, okay. So, that’s my capital P. So, you think, okay,
            so what is the motive going to be? Well, it’s going to be given x in A
            and given y in A. What I want capital P to be is I want P of x, y to be
            the following type: that f(x) is equal in B to f(y). And u, that’s my
            motive, okay.</p>
        <p>我知道这会奏效。为什么？因为看看路径感应的结论。它说，等等等等，无论我们得到什么充分条件，我们都能够在步骤 3 中得出结论，p 对 a 和 b 成立。所以，如果我在这里代入 a 和 b，我会得到 f(a) = f(b)。也就是说，我们认为它是真的。但真实意味着这里实际上有一条路径，我将其称为 app f, f(a)。</p><p>I know that this is going to work. Why? Because look at the
            conclusion of path induction. It says, blah, blah, blah, under whatever
            sufficient condition we get, we’re going to be able to conclude here at
            step 3 that p holds of a and b. So, if I plug in a and b here, I will
            get f(a) = f(b). That is, we think of it as being—as being true. But
            being true means that there is actually a path in here, which I will
            call app f, f(a).</p>
        <p>好的，所以你必须始终记住，在类型理论中，你知道，当你写下任何陈述、任何命题时，它实际上是一种类型。当你说它是真的时，你实际上是在说它有人居住。一般来说，我们感兴趣的不仅仅是某物是否有人居住，我们还想知道它的居民是谁，好吗。所以，这是一种非常丰富、更丰富的推理形式。它总是一种类型吗？你的意思是什么？</p><p>Okay, so you have to always remember that in type theory, you know,
            when you’re writing down any—any statement, any proposition, it’s really
            a type. And when you say that it’s true, you’re really talking about it
            being inhabited. And generally, generally, we’re not interested merely
            in whether something is inhabited, but we’re interested in knowing what
            its inhabitants are, okay. So, it’s a very rich, much richer form of
            reasoning. Is it always a type? What do you mean by that?</p>
        <p>是的。我声称我将把 p 定义为这种类型。就是这样，好的。这意味着取决于 a 和 b 所在的位置——它在内部。它们在某个宇宙中。记住宇宙多态性的惯例。所以，a 和 b 是类型。所以，它在某个宇宙中。宇宙在身份类型、路径类型的形成下是封闭的。所以，这也将在 U 中。所以，这是一个特定的——这是一个居住在 U 中的特定类型。这是因为宇宙的封闭原则，好的。</p><p>Yeah. What I’m claiming is I’m going to define my p to be this type.
            There it is, okay. Which means that depending on where a and b live—it’s
            inside. They’re in some universe. Remember the convention of universe
            polymorphism. So, a and b are types. So, it’s in some universe. The
            universe is closed under formation of identity types, path types. So,
            that will also be in U. So, here’s a particular—here’s a particular type
            that inhabits U. And that’s because of the closure principles of
            universes, okay.</p>
        <p>所以，这就是那里发生的事情。这就是使用通用场的诀窍。我证明的定理恰好是关于居住的。我说，如果 a 等于 b，那么 f(a) 等于 f(b)。而我……我不……我证明的问题陈述恰好没有提到 b，但证明会……证明说，哦，这应该说 f(p)，对吧？所以也许这就是让你困惑的地方，对吧？我在那里写错了。好的。我……我明白了。我搞砸了。很抱歉。</p><p>So, so that’s what’s going on there. That’s the trick about using
            universal fields. It just so happens that the theorem I’m proving is
            about inhabitation. I’m saying, if a is equal to b, then f(a) is equal
            to f(b). And I… I don’t… the statement in question that I’m proving
            doesn’t happen to say anything about b, but the proof will… the proof
            says, oh, this should have said f(p), right? So maybe that’s what
            confused you, right? I wrote the wrong thing down there. Okay. I… I got
            it. I messed that up. Sorry about that.</p>
        <p>换句话说，它是对 f 路径的绝对动作，并将其应用于 p。抱歉。我写错了。是的。</p><p>In other words, it’s the absolute action on the path of f and apply
            it to p.&nbsp;Sorry. I wrote the wrong thing. Yep.</p>
        <p>我是在说什么……我没听清第二个词吗？我在说什么……什么？是的，你……那是一个宇宙，对吧？这就是我的意思。空间栖息于类型，类型栖息于宇宙。这就是我们本周早些时候谈论的内容。好的，因为我只是……从技术上讲，说你呈现类型的方式是作为宇宙的居民，这很方便。接下来有一个原因，我会讲到。我希望我能在本次讲座结束时讲到。好的。这就是动机。</p><p>Am I talking about… what did I not hear that second word? Am I
            talking about the… what? Yeah, you… that’s a universe, right? That’s
            what I mean by that. And spaces inhabit types inhabit universes. That’s
            what we talked about earlier this week. Okay, because I just… it’s just
            technically convenient to say the way you present a type is as an
            inhabitant of a universe. There’s a reason coming up, which I’ll get to.
            I hope I will get to by the end of this lecture. Okay. So that’s the
            motive.</p>
        <p>好的。那么充分性是什么？我必须展示什么？足以证明，给定任何 x 和 a，存在一个针对 x、x 和 ruffle 实例化的动机，即 f(x) = b(f(x))。是的。我需要在这里找到一些东西。如果我有它，那么我的 app(f(p)) 按照定义将是 j(x)。将我在这里写下的任何点应用于 p。好的。</p><p>Okay. And what is the sufficiency? What is it that I have to show? It
            suffices to show that, given any x and a, there exists an inhabitant of
            the motive instantiated for x, x, and ruffle, which is that f(x) =
            b(f(x)). Yes. I need to find something in here. If I have that, then my
            app(f(p)) is, by definition, going to be j(x). Dot whatever I write down
            here, apply to p.&nbsp;Okay.</p>
        <p>好的。那么我在这里做什么呢？嗯，这是反身性的一个例子。所以这是 f(x) 在 a 中的反身性，在 b 中，对不起，是 f(x)。这是该事实的证明。所以我在这里写的是 reflb(f(x))。我完成了。</p><p>All right. So what do I do here? Well, this is an instance of
            reflexivity. So this is reflexivity at f(x) in a, in b, excuse me, of
            f(x). That’s a proof of that fact. So the thing I write here is
            reflb(f(x)). And I’m done.</p>
        <p>此外，还有这样的 app。我可以这样写：如果我们取 app，并让它作用于恒等路径或反身性，我们称之为对 a 的反身性，这在定义上等于……我们需要知道这一点……这在定义上等于 f(a) 对 b 的反身性。</p><p>Moreover, there’s an app such as this. I can write such that if we
            take app and we make it act on the identity path, or reflexivity, let’s
            call it reflexivity on a, that’s definitionally equal to… and we need to
            know this… this is definitionally equal to reflexivity on b of f(a).</p>
        <p>所以在证明定理时，你会说很多。为什么那部分是正确的？因为如果你计算，取这里的 j，即 x.dot reflb(f(x))，如果你在 ruffle 上运行它，即 a 中的零路径，那么 j 的定义等式表明这是 reflb(f(a))，根据模糊的板……不，根据这里的规则，根据那里的定义方程。所以这一切的美妙之处在于定理更加丰富。对吧？我不只是说那些松散的东西。哦，如果 a 等于 b，那么 a 的 f 等于 b 的 f。</p><p>So you say a lot when you’re proving a theorem. And why is that part
            true? Because if you calculate, take j here, which is x.dot reflb(f(x)),
            and if you run that on ruffle, the null path in a, then the definitional
            equality for j says that this is reflb(f(a)), by the obscured board… No,
            by this rule here, by this definitional equation right there. So the
            beauty of all of this is that the theorems are so much richer. Right? I
            don’t just say the flabby thing. Oh, if a is equal to b, then f of a
            equals f of b.</p>
        <p>相反，我有这样的想法：不，不。空间 a 中的路径可以转换为空间 b 中的路径，这样如果你在空间 a 中取零路径，你就会得到空间 b 中的零路径。它不会去别的地方，因为原则上，如果我不这么说，那么你就不知道什么路径——证明是什么？你看，不说这个，我就不知道。就你所知，我在 a 中取自循环，并且 app f 肯定会将其映射到循环上。</p><p>Instead, I have this idea that says: no, no. A path in space a can be
            transformed into a path in space b in such a way that if you take the
            null path in space a, you will get the null path in space b. It won’t go
            anywhere else, because in principle, if I don’t say this, then you don’t
            know what path—what is the proof? See, without saying this, I don’t
            know. For all you know, I take the self loop in a, and app f maps that
            over to a loop for sure.</p>
        <p>但据您所知，这不是 Ruffle，而是其他应用程序 fp。问题是：这是否等于——如果这是 Ruffle——那么我们就称其为 Ruffle。那么问题是：这是 Ruffle 吗？它实际上是自循环，还是其他循环？好吧，定理告诉我们，当完全陈述时，定理告诉我们它将保留零路径。好的，这很好。好的。然后我们就完成了。</p><p>But for all you know, not ruffle—this is some other, you know, some
            other app fp. And the question is: is that equal to—if this is ruffle—so
            let’s call this ruffle. Then the question is: is that ruffle? Is it
            actually the self loop, or is it some other loop? Well, the theorem is
            telling us that, when fully stated, the theorem is telling us that it’s
            going to preserve the null path. Okay, so that’s that’s good. Okay. And
            then we’re done.</p>
        <p>所以这就像另一个简单的例子。我马上要再举一个非常相似的例子，但这是一个与证明相关的数学的简单例子，对吧？我们写出，你知道，在这个例子中是关于相等的定理，我们实际上将它们视为数据结构上的映射，因为相等的证明是相关的，也是我们讨论的主题。这就是我们感兴趣和谈论的事情。是的，嗯，是的，本质上。</p><p>So this is like another simple example. I’m going to do another one
            of a very similar character momentarily, but this is a simple example of
            proof relevant mathematics, right? That we are writing out, you know,
            theorems in this case about equality, and we’re thinking of them really
            as mappings on data structures, because the proofs of equality are
            relevant and are the subject of our discourse. That’s what we’re
            interested in, and saying things about. Yeah, well, yes,
            essentially.</p>
        <p>我不会为你证明这一点，但如果你能证明，作为一个定理，app 本身在 p 中以函数方式起作用，那么它将保留一些组合和逆元，直到相等。为此，你需要将其作为起始事实，因为你要做的是假设我想要证明 f(f(p1)) 是 f(p1)。比如说，我想知道如果我从一条路径开始——我们认为它是从左到右——然后我通过 f 将它映射到另一条从左到右的路径上。</p><p>And I’m not going to prove it for you, but if you can prove, as a
            theorem, that app itself acts functorially in p, so it will preserve, up
            to equality, some composition and inverses. And for that, you need this
            as a starting fact, because what you’re going to do is suppose I want to
            prove that f(f(p1)) is f(p1). See, I’d like to say, for example, I’d
            like to know that if I start with a path—we think of it as going from
            left to right—and I map it over via f, sends that over to some other
            path going from left to right.</p>
        <p>我想知道，如果我从与该路径相反的路径开始，我想知道我得到的是该路径的逆。好的。那么，你怎么做呢？你通过路径归纳来证明这一点。你要做的是，你说，好吧，这是一条任意路径，好吧，p。我们看看 app(f(p1))，f(p1) 的效果。我们说，好吧，通过对 p 进行路径归纳，考虑反射逆就足够了。</p><p>I would like to know that if I start with the path which is the
            inverse of that, I would like to know that what I get is the inverse of
            that. Okay. Well, how do you do it? You prove it by path induction. What
            you do is you say, well, here’s an arbitrary path, okay, p.&nbsp;And we look
            at the effect of app(f(p1)), f(p1). And we say, well, by path induction
            on p, it’s enough to consider the reflection inverse.</p>
        <p>反射逆在定义上等于反射。因此，应用这一事实可以保留反射性。因此，我可以得出结论，如果我取逆路径并将其映射到 f，我将得到路径通过 f 映射的逆。你看，等等。现在我想证明它保留了组合。我现在不打算这样做，但你可以猜到我怎么做。我要说，好吧，如果你给我两条路径的连接，我将它们映射过去，我怎么知道两条路径的连接中的 f 是路径单独连接的 f 的连接？好吧，我将通过双路径归纳法来证明这一点。只要考虑 p 是 ruffle 并且 q 是 ruffle，然后揭示 refel 是 ruffle，所以它无处可去，所以它必须是 ruffle 就足够了。我们再次使用这个事实，然后我们就完成了。好的，这就是论点。所以你可以自己检查一下。</p><p>Reflection inverse is definitionally equal to reflection. Therefore,
            the application of this fact preserves reflectivity. Thus, I can
            conclude that if I take the inverse path and map it by f, I will get the
            inverse of the mapping of the path by f.&nbsp;You see, etc. And now I want to
            show that it preserves composition. I’m not going to do this now, but
            you can guess how I do it. I’m going to say, well, if you give me the
            concatenation of two paths and I map them over, how do I know that f of
            the concatenation of two paths is the concatenation of f of the paths
            individually? Well, I’m going to prove that by a double path induction.
            It’s enough to consider that p is ruffle and q is ruffle, and then
            reveal that refel is ruffle, and so it has nowhere to go, so it’s got to
            be ruffle. And we use this fact again, and then we’re done. Okay, that’s
            the argument. So you can check that out for yourself.</p>
        <p>因此练习是：证明</p><p>So the exercise is: show that</p>
        <p>而 1 app fp⁻¹ 就是 app fp⁻¹（哎呀，这里应该是 1），而 app fp concatenate q 就是 app fp concatenate app f q。你可以把它们当做练习；它们都是简单的路径感应。</p><p>and the 1 app f p⁻¹ is app f p⁻¹ (oops, that’s supposed to be 1 up
            here) and app f p concatenate q is app f p concatenate app f q. You can
            do those as exercises; they’re both simple path induction.</p>
        <p>好的，这就是函数性的一个方面，我想讲一下。每个映射都尊重路径。现在请注意，这将产生一些很酷的东西。让我给你提一个事实，即我们之前讨论过的事情，我会带你回到这个话题。</p><p>Okay, so that’s one aspect of functoriality, which I wanted to get
            at. Every map respects paths. And now notice there’s going to be
            something cool that comes out of this. Let me refer you to a fact that
            something that we discussed before, which I’ll bring us back around.</p>
        <h2 id="congruence-and-unicity-properties">一致性和唯一性</h2><h2>Congruence and Unicity
            Properties</h2>
        <p>这真是太棒了。</p><p>This is really neat.</p>
        <p>好的，看这个。</p><p>Okay, watch this.</p>
        <p>好的，这里有一些您想知道的简单的事情。如果 a₁ = a₂ 且 b₁ = b₂（我们称之为等于 b₂），那么您想知道，例如，a₁ b₁ 对在 a × b 中等于 a₂ b₂ 对。这是一致性原理的一个例子。好的，您想知道这一点，对吗？您想知道这一点。请记住，相等意味着路径。但以最宽松的方式表述，我说如果 a₁ 等于 a₂ 且 b₁ 等于 b₂，则 a₁ b₁ 对等于 a₂ b₂ 对。</p><p>Okay, here is like some simple thing you would like to know. If a₁ =
            a₂ and b₁ = b₂, let’s call it, equals b₂, then you’d like to know, for
            example, that the pair a₁ b₁ is equal in a × b to the pair a₂ b₂. It’s
            an example of a congruence principle. Okay, you would like to know that,
            right? You would like to know that. Remember, equality means path. But
            stated in the loosest possible way, I say if a₁ is equal to a₂ and b₁ is
            equal to b₂, then the pair a₁ b₁ is equal to the pair a₂ b₂.</p>
        <p>为什么这是真的？随便说一下，原因是：我们把 p 放在这里，把 q 放在这里。好的，然后我想要做的是，我想要对配对构造函数的路径采取行动。所以我想说的是，如果我取 app 的 app，如果你如果我柯里化配对，称它为 p 和 q 的配对，那就是证明。好了！所以一致性是通过每个映射（包括配对映射）对路径进行操作来表达的。这里的配对现在被定义为您知道的当前形式的配对。好的，我就是这样做的，所以这只是一个快速的草图。好的，这是一个有趣的事实。现在，履行我之前为您承担的义务。</p><p>Why should that be true? In a very offhand way, well, the reason is:
            let’s put p here, let’s put q here. All right, and then what I want to
            do is I want to take the action on paths of the pairing constructor. So
            what I want to do is I want to say if I take app of app, if you if I
            curry pairing, call it pair to p and to q, that’ll be a proof of that.
            Ta da! So the congruence is expressed by the by the fact that every map,
            including the pairing map, has an action on paths. Where pair is now
            here is being defined as you know, the current form of pairing. Okay,
            I’m doing it like that so this is just a quick sketch. All right, that’s
            one interesting fact. And now, to discharge an obligation I acquired for
            you before.</p>
        <p>所以，这是第一点。所以，一致性属性成立。第二点是这个唯一性属性。</p><p>So, that’s one. So, the congruence property holds. The second thing
            is that this unicity property.</p>
        <p>那么，还记得我们讨论过配对吗？我们说过，如果我们有笛卡尔积，就会有一个从这里到这里的映射。换句话说，这实际上意味着：给定<em>z</em>和<em>a × b ， </em><em>z</em>的第二个在<em>b</em>中，给定<em>z</em>和<em>a × b ， </em><em>z</em>的第一个在<em>a</em>中。对吧？</p><p>So, remember when we talked about pairing? We said if we have the
            Cartesian product, what happens is we have a map from here to here. In
            other words, this really means: given <em>z</em> and <em>a × b</em>, the
            second of <em>z</em> is in <em>b</em>, given <em>z</em> and <em>a ×
                b</em>, the first of <em>z</em> is in <em>a</em>. Right?</p>
        <p>我们说过如果有这种情况，然后我们还说过如果给我来自<em>γ的任意</em><em>a</em>和任意<em>b</em>，那么就有一个唯一的映射——当然是在这里——称为对（<em>a</em>，
             <em>b</em>）—— <em>γ</em>证明对（<em>a</em>，<em>b</em>）在
            <em>a × b</em>中，前提是<em>a</em>相对于
            <em>γ在</em><em>a</em>中，并且<em>b</em>相对于
            <em>γ</em>在<em>b</em>中。
        <em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em><em></em></p><p>We said if you have that scenario, and then we also said that if you
            give me any <em>a</em> and any <em>b</em> from <em>γ</em>, then there’s
            a unique map—certainly here—called pair(<em>a</em>,
            <em>b</em>)—<em>γ</em> proves that pair(<em>a</em>, <em>b</em>) is in
            <em>a × b</em> provided that <em>a</em> is in <em>a</em> with respect to
            <em>γ</em> and <em>b</em> is in <em>b</em> with respect to
            <em>γ</em>.
        </p>
        <p>所以，这很好。而且 beta 公理成立。如果你取对并执行第一个，你会得到<em>a</em>。如果你取对并执行第二个，你会得到<em>b</em>。</p><p>So, that’s good. And the beta axiom holds. If you take the pair and
            do first, you get <em>a</em>. And if you take the pair and you do
            second, you get <em>b</em>.</p>
        <p>这些是这些单元格上的定义等价性。</p><p>These are definitional equivalences on these cells.</p>
        <p>接下来的问题是：唯一性。</p><p>Then the question was: the unicity.</p>
        <p>好的，所以唯一性看起来是这样的。唯一性表示 — — 我会这样写 — — 现在我们要说：如果我想显示唯一性，我会说，好吧，我有一个映射，称之为 pair( <em>a</em> , <em>b</em> )。</p><p>Okay, so the unicity looks like this. The unicity says—I’ll write it
            like this—now we’re going to say: if I want to show uniqueness, I say
            well, I have one map, call it pair(<em>a</em>, <em>b</em>).</p>
        <p>我正在做的是放大。这项业务就在这里，但我没有足够的空间。因此，我要做的是，因为我希望周围的上下文相同，我有一个映射对（<em>a</em>，<em>b</em>），其属性为对（<em>a</em>，<em>b</em>）后跟第二个是<em>b</em>，对（<em>a</em>，<em>b</em>）后跟第一个是<em>a</em>。</p><p>What I’m doing is zooming in. This business goes right in here, but I
            didn’t have quite enough room. So, what I’m going to do is, because I
            want the surrounding context to be the same, I have one map
            pair(<em>a</em>, <em>b</em>) which has the property that
            pair(<em>a</em>, <em>b</em>) followed by second is <em>b</em>, and
            pair(<em>a</em>, <em>b</em>) followed by first is <em>a</em>.</p>
        <p>好的，所以我有一张地图。然后，为了显示唯一性，我说：假设你有任何其他地图，称之为<em>c</em>，它满足相同的要求——如果我这样做……</p><p>Okay, so I have one map. And then, to show unicity, I say: suppose
            you have any other map, call it <em>c</em>, which satisfies the same
            requirement—that if I do…</p>
        <p>所以，我在这里做的是——这是缩小的，但我还是把它放在这里——我说：考虑两张满足相同条件的地图。也就是说，这两张地图都从定义上满足这些要求。我想表明的是，从某种意义上说，这两张地图是相等的。</p><p>So, what I’m doing here—this is the zoom out, but I’ll put it in
            here—I say: consider two maps which satisfy the same conditions. That
            is, both of these satisfy definitionally those requirements. What I want
            to show is, in some sense, these two maps are equal.</p>
        <p>我们要做的就是将一个元素变形为另一个元素。因此，我们假设这里有一个单元。</p><p>And the way we’re going to do that is we’re going to say one can be
            deformed into the other. So, we’re going to say that there’s a cell
            here.</p>
        <p>好的，那你该怎么做呢？嗯，你这样做的方法是有一个公理。这就是这里真正发生的事情。公理说<em>c在</em><em>a × b</em>中可变形为(第一个<em>c</em>，第二个<em>c</em> )对
            。
        </p><p>Okay, and how do you do that? Well, the way you do that is you have
            an axiom. That’s what really is going on here. And what the axiom says
            is that <em>c</em> is deformable in <em>a × b</em> to the pair (first of
            <em>c</em>, second of <em>c</em>).
        </p>
        <p>你应该检查这是否给出了唯一性。我声称如果这成立，那么给定这个公理，这个单元格就可以被填充。你可以展示如何证明这等于 A × B 型中的那个。这就是唯一性。所以，这是条件。这是乘积的通用条件。我想，这是我在第一讲中谈到的。这被称为乘积的通用条件。好的。</p><p>And you should check that this gives us the unicity. I claim that if
            this holds, then, given this axiom, this cell can be filled. You can
            show how to prove that this is equal to that in the type A × B. That’s
            the unicity. So, here is the condition. This is the universal condition
            for products. This is the I talked about this, I think, in lecture one.
            This is called the universal condition for products. Okay.</p>
        <p>所以，它的意思就是，回到 Todd 可能在第一天说过的一句话，从某种意义上说，我们说产品的每个元素都是一对。但从字面上看，它并不是一对。它可以相互关联；它可以被映射。它和一对之间有一条路径。这是一种形成一对的廉价方式，因为你所做的就是说，“哦，我不想看 C。</p><p>So, what it’s saying is, going back to a remark that Todd made, like
            possibly on Day One, is that in a certain sense, we’re saying every
            element of the product is a pair. But it’s not literally, on the nose, a
            pair. It can be correlated; it can be mapped. There’s a path between it
            and a pair. And it’s kind of a cheap way of forming a pair because what
            you do is you say, “Oh, I don’t want to look at C.</p>
        <p>据我所知，C 可能是某种过程，当你启动它时——你知道，用适当的第一个或第二个答案——我不知道它在结构上是什么。但我知道的是，我可以通过一条路径将它转换成该产品类型的规范形式，也就是说，我可以将 C 变形为这种简单的东西，它通过说 C 的第一个来响应第一个。它只是把它交给别人。这是一个间接级别。它通过执行 C 的第二个来响应第二个。</p><p>C could be, for all I know, some process that when you kick it—you
            know, with first or second answers appropriately—I don’t know what it
            structurally is. But what I do know is I can turn it into the canonical
            form of that product type by a path, which says I can deform C into this
            cheap thing that responds to first by saying first of C. It just hands
            it off. It’s one level of indirection. And it responds to second by
            doing second of C.</p>
        <p>所以，这是一个间接层。现在，C 可以被认为是一对，因为我可以放入一个代理对象。所以，这是一个代理，对吧？所以，这是一个代理。它所做的就是，如果你向它发送第一条消息，询问它是第一个——或者抱歉，这个网站是第一个，对吧——它将只是 C 的第一个。它只是说，“嘿，C，告诉我你的第一个，我会把它传递给问我的人。”好的。如果你问我第二个，我会说，“嘿，C，C 的第二个是什么？”哦，我会把它传递给问我的人。所以，这是一个代理。好的。</p><p>So, it’s one level of indirection. And now C can be thought of as a
            pair because I can put in a proxy object. So, this is a proxy, right?
            So, this is a proxy. All it does is the pair is the thing which, if you
            send it the first message, ask it’s first—or sorry, this site first,
            right—will just be the first of C. It just says, “Hey, C, tell me your
            first, and I’ll pass that on to the guy who asked me.” Okay. If you ask
            me for my second, I’ll say, “Hey, C, what is second of C?” Oh, and I’ll
            just pass that on as to to the guy who asked me. So, it’s a proxy.
            Okay.</p>
        <p>所以，但是对于这样的代理，它是可变形的。它不是——它不是字面上的结构明显的。所以，这是我在几次讲座之前欠你的评论。所以，我想把这一点说出来。是的，是的。</p><p>So, but it’s deformable to such a proxy. It’s not—it’s not literally
            structurally apparent. So, this is a remark I owed you from several
            lectures ago. So, I wanted to get that in. Yep, yeah.</p>
        <p>嗯，这应该不清楚，但如果没有它，在类型理论中，有多种定义乘积规则的方法。实际上，在<em>热书中</em>，有一种方法可以定义不同的规则。这最终会成为一个定理。但另一件事有一个公理。所以，这是一个气球挤压练习。所以，我这样做的方式，因为我接近——我后来注意到，在<em>热书中</em>，他们对待——我们最终积极地对待产品。</p><p>Well, it shouldn’t be clear, but without it, there are various ways
            of defining the rules of a product in type theory. Such that one way to
            do it, actually, in the <em>hot book</em>, it’s defined a different way.
            And this ends up being a theorem. But then the other thing has an axiom.
            So, it’s a balloon squeezing exercise. So, the way I did it, because I
            approached the—I noticed later that in the <em>hot book</em>, they
            treated—we ended up treating the product positively.</p>
        <p>但我想从负面角度看待它。如果我从负面角度看待它，你就会按照我说的去做。那么，“一本热门的书会得到正面对待”这个公理就暗示了这个定理。但模式匹配构造是一个公理。所以，你知道你可以用任何一种方式来做，好吗？所以我只是想把这一点说清楚。所以，这个想法是，正是这个关于两个细胞的变形的明确的想法，好吧，将这些东西联系在一起。</p><p>But I wanted to treat it negatively. If I treat it negatively, you do
            as I said. Then, the axiom “a hot book is treated positively” implies
            this theorem. But then the pattern matching construct is an axiom. So,
            you know you can do it either way, okay? So, so I just wanted to make
            that clear. So, the idea is that it’s this idea of a definite, of a, of
            a deformation of a two cell, okay, that connects these things.</p>
        <p>在我看来，这就是唯一性的含义，好吗？它不应该意味着这在定义上等于 ab；而应该是它在道德上等于对 a、b，好吗？这就是想法，好吗？你要进行推导，证明这等于那，前提是 c 满足这些方程。这将遵循这个公理，但你必须证明这一点。所以，这是一个练习。所以，练习，练习展示了那个单元格，假设这是一个公理，好吗？所以，你应该能够做到这一点，好吗？</p><p>That’s what unicity, in my mind, should mean, okay? It shouldn’t mean
            that this is definitionally equal to a b; it should be that it is
            morally equal to the pair a, b, okay? That’s the idea, okay? You’re
            going to do the derivation showing that this is equal to that, given
            that c satisfies these equations. It’s going to follow from this axiom,
            but you have to prove that. So, that’s an exercise. So, exercises,
            exercises exhibit that cell, given this is an axiom, okay? So, you
            should be able to do that, okay?</p>
        <p>我想再说一下关于函子性的另一件事，也就是我们之前讨论过的振动问题。所以我们仍然在说，我们正在画出这些，我们正在做的是解释路径诱导的后果，其中包括眼前的一切都尊重路径。所以，这是我们尊重路径的另一种意义。所以，我的想法是，我希望能够说，所以我想说的是：如果 f 是从 a 到 u 的映射，是的，那是 a，那么它就是这样的类型家族，好吗？</p><p>I want to say another thing about functoriality, which is that about
            the issue of a vibration that we talked about before. So, we’re still in
            the business of saying, in, we’re, we’re drawing out these, that we’re,
            what I’m, what I’m doing is I’m explaining the consequences of path
            induction, among which are the fact that everything in sight respects
            paths. So, here’s another sense in which we respect paths. So, the idea
            is, I want to be able to say, so the idea is, I want to say this: if f
            is a mapping from a to u, and yes, that’s a, it’s a family of types like
            this, okay?</p>
        <p>然后我想要，哦，是的，对，对不起，我需要一条路径，还有一条路径。我有一条路径在 a 中。好吧，我们现在就这样写。所以，这个想法，粗略的想法是说，现在问题来了。我想说 f(a) 在某种意义上应该等于 f(b)。我现在要讨论的这个问题是同伦类型理论的核心，因为它涉及到所谓的单价性，好吗？所以，我们马上就讲到这个，好吗？</p><p>Then I want, and oh, yes, right, and I’m sorry, I need a path, and a
            path. I have a path in a. All right, well, let’s just right now write it
            like this. So, the idea, the rough idea is to say then, and now here’s
            where the rub comes in. I want to say something about f(a) should be in
            some sense equal to f(b). This question that I’m addressing right now is
            the heart of the whole matter of homotopy type theory because it gets to
            the idea of what is going to be called univalence, okay? So, we’re going
            to, we’re going to get to that in a minute, okay?</p>
        <p>那么，我们在这里知道什么？那么，我们知道什么？所以，这就像非正式的想法。那么，我们知道什么？换句话说，我想说这样的话：如果 a 和 b 是此类型系列域的相等元素，那么 f(a) 和 f(b) 在某种意义上应该是相同的类型。因此，我们多次有过的激励示例是：我们想说，因为有证明 x + y 在 y + x 中，我想知道 vector(x + y) 在某种意义上等于 vector(y + x)。</p><p>So, what do we know here? So, what do we know? So, this is like
            informally like the idea. So, what do we know? So, in other words, I
            would like to say something like: if a and b are equal elements of the
            domain of this family of types, then f(a) and f(b) should, in some
            sense, be the same type. So, the motivating example we’ve had many times
            is: we would like to say that because there is a proof that x + y is in
            that y + x, I would like to know that vector(x + y) is in some sense
            equal to vector(y + x).</p>
        <p>哎呀，我没有让我们说我们在什么意义上有这个。这就是我们的目标。请记住，这不是一个真正的定义权，因为这个假设在定义上是不正确的。所以，我无法得到任何定义等价，因为我不知道——这在定义上是不正确的。好的。所以，但这就像是激励的想法，好的，解释。但我想我明白为什么这是真的。但为什么你不能只使用<em>j</em>规则呢？</p><p>Oops, I didn’t let us say what in what sense we have that. That’s
            what we’re aiming for. Remember that it’s not a true definitional right
            because this hypothesis is not true definitionally. So, I can’t get to
            any definitional equivalence because I don’t—that’s not true
            definitionally. Okay. So, but that’s like the motivating idea, okay, to
            explain. But I think I see why this is true. But what’s the exact reason
            why you can’t just use the <em>j</em> rule for this?</p>
        <p>你知道，通过摆弄宇宙层次来改善这一点……好吧，我想你已经预料到我要说什么了。那么，如果我继续说下去怎么样？好的。我很确定你已经预料到我要说什么了。那么，让我们开始吧。好的。好的。那么，好了。那么，你可以看到我们在这里做什么，对吧？好的。你跟上我了吗？好的。好的。那么，这就是我们想要的高级事物。还有一个问题，这到底意味着什么。</p><p>You know, improving this by fiddling with universe levels and sort
            of… well, I think you’re anticipating what I’m going to say. So, how
            about if I just go on? Okay. I’m pretty sure you’re anticipating what
            I’m going to say. So, let’s, let’s do this. Okay. Okay. So, here, all
            right. So, you can see what we’re doing here, right? Okay. Are you with
            me? Okay. All right. So, that’s the high level thing that we want. And
            there’s a question about what this even means.</p>
        <p>好的。在这里，因为我——两种类型相等或可互换是什么意思？所以，这激发了类型等价的想法。</p><p>Okay. Here, because I—what does it mean for two types to be equal or
            interchangeable? So, this motivates the idea of equivalence of
            types.</p>
        <h2 id="equivalence-of-types-and-univalence">类型等价与单价</h2><h2>Equivalence of Types and
            Univalence</h2>
        <p>这就是我要说的。所以，我想要的是，我希望这些类型是等价的。两种类型等价是什么意思呢？所以我要介绍一个概念。好的。所以我会这样定义它。所以，我会说，嗯，是的。好吧。写出来有点复杂。所以，让我考虑一下。我的时间不多了。所以我要即兴发挥一下。</p><p>That’s where I’m going to get at. So, what I want to get is I want
            those types to be equivalent. And what does it mean for two types to be
            equivalent? So, I’m going to introduce a notion. Okay. So, I’ll define
            it like this. So, I’ll say, well, yes. All right. It’s a little
            complicated to write out. So, let me think about this. I’m running a
            little short on time. So, I’m I’m going to improvise a little bit.</p>
        <p>好的。那么，假设我要做的是，我希望这是——最终，我希望这是<em>f(a)</em>等价于
            <em>f(b)</em>。那是什么意思呢？这意味着有一个函数，我们称之为小<em>f</em>，好的，从<em>f(a)</em>到
            <em>f(b)，</em>这样……好的。这是一个等价函数。那么，那是什么意思呢？这样对于<em>a</em>中的每个<em>x</em>来说，这都是等价的……哦，收回刚才的话。抱歉，我错了。我想说的是，现在有两件事。
        <em></em></p><p>Okay. So, let’s say what I’m going to do is I want this to
            be—eventually, I want this to be <em>f(a)</em> is equivalent to
            <em>f(b)</em>. And what does that mean? It means that there’s a
            function, let’s call it little <em>f</em>, okay, from <em>f(a)</em> to
            <em>f(b)</em> such that… okay. This thing is an equivalent. So, what
            does that mean? Such that for every <em>x</em> in <em>a</em>, this is an
            equivalent… oh, take it back. Sorry, wrong about that. What I want to do
            is I want to say that there are now two things.
        </p>
        <p>好的。所以，在我担心之前，让我先考虑一下我要在这里做什么。我们就在这里写吧。现在是一个等价。f <em>。</em>等价是什么？它将是一个可逆到更高同伦的映射。也就是说，它是一个具有前逆和后逆的函数，如果我从
            <em>f</em>开始——如果我从左到右，然后沿着它的后逆返回，那么我应该得到一个同伦。
        </p><p>Okay. So, let me—before I’m worried about—let me worry about—let me
            think about what I’m going to do here. Let’s just write here. Now is an
            equivalence. <em>f</em>. What is an equivalence going to be? It’s going
            to be a map that is invertible up to higher homotopy. That is, it’s a
            function that has a pre and a post inverse such that if I go from
            <em>f</em> over—if I go from left to right and then back by its post
            inverse, then I should get a homotopy.
        </p>
        <p>假设我们有这个场景。这应该是这个往返过程，我在这里是这样做的。这个组合应该与身份相同。应该有一个更高级别的单元，它将这个证明转换为那个证明。反过来，好的。所以每当我们有<em>f</em>到这里时，就会有一个<em>g</em>返回，然后它们的组合就是身份。反过来，我可以采取——我可以反过来得到身份，好吗？我必须画草图，因为我的时间不多了。它适用于任意类型，好的。</p><p>Let that is, we have this scenario. This should be this round trip
            thing, which I do here like this. This composition should be the same as
            the identity. There should be a higher level cell that takes this proof
            and transforms it into that one. And conversely, okay. So whenever we
            have <em>f</em> going here, there’s a <em>g</em> that goes back, and
            then their composition is the identity. And the other way around, I can
            take—I can go the other way around and get the identity, okay? I’m
            having to sketch because I’m running low on time. It works for an
            arbitrary type, okay.</p>
        <p>所以一般来说，这是一个任意类型<em>a</em>
            和<em>b</em>的概念，在这里我们感兴趣的是<em>f(a)</em>和
            <em>f(b)</em>，好吗？这就是我要做的。所以我想在这两者之间有一个等价关系。我想在这两者之间有一个等价关系是因为我想能够说——我要说这种等价关系的含义是：如果你给我这个类型的东西，我可以把它转移到这个类型并向后转移。
        </p><p>So there’s a notion in general—this is an arbitrary type, <em>a</em>
            and <em>b</em>, which in the case of interest here is <em>f(a)</em> and
            <em>f(b)</em>, okay? So that’s what I’m doing. So I want to have an
            equivalence between those two. The reason I want to have an equivalence
            between those two is because I want to be able to say—the way in which
            I’m going to say what this equivalence will mean is: if you give me
            something in this type, I can transport it over to this type and
            backward.
        </p>
        <p>换句话说，尽管<em>vec(x + y)</em>和
            <em>vec(y + x + s)</em>类型并不相同，但它们是等价的，因为如果您给我任何东西 — — 举另一个例子，如果我们在这里取<em>vec(x + y)</em>并在这里取<em>vec(y + x)</em>，我们会说它们是等价的。那么说它们是等价的是什么意思呢？它说的是，如果你
            在这里给我任何向量<em>v ，我可以将它发送到这里的模拟</em><em>v'</em>。这样一来，如果我将它送回这里，我得到 — — 我们称之为
            <em>v'' —</em> — 让我离开自己，让我腾出更多空间。因此，如果我将<em>v</em>发送到这里给<em>v'</em>，然后我再将那个家伙送回<em>v''</em>，它们之间存在一条路径。它们是相等的 — — 不完全相同，但它们之间有一条路径。这就是我擦除的部分告诉我的。
        </p><p>So in other words, although the types <em>vec(x + y)</em> and
            <em>vec(y + x + s)</em> are not the same, they’re equivalent in the
            sense that if you give me anything—if we take as another example, if we
            take <em>vec(x + y)</em> over here and we take <em>vec(y + x)</em> over
            here, we’re going to say that those are equivalent. And what does it
            mean to say they’re equivalent? It says well, if you give me any vector
            <em>v</em> over here, I can send it to its analog <em>v’</em> over here.
            In such a way that if I send it back over here and I get—let’s call it
            <em>v’’</em>—let me leave myself, let me make some more room. So if I
            take <em>v</em> and I send it over here to <em>v’</em>, and then I take
            that guy and send it back to <em>v’’</em>, there’s a path between them.
            They’re equal—not identical, but there’s a path between them. That’s
            what the piece I erased is telling me.
        </p>
        <p>因此，我们要做的就是，我们将一个向量从这里取过来，然后将其发送回来，然后当我们将其发送回来时，它们将是相等的——这意味着它们之间会有一条路径。这比说它们是完全相同的东西要弱。这就是等价的概念。这就是我想要得到的。所以我要通过以下路线到达那里，好吗？这就是计划，好的，通过以下路线。</p><p>So what we’re going to do is we’re going to take a vector over here
            and send it over here, and then when we send it back, what they’re going
            to be is equal—meaning they’re going to have a path between them. That’s
            weaker than saying it’s exactly the same thing. So that’s the notion of
            equivalence. So this is what I want to get to. So the way I’m going to
            get there is by the following route, okay? So that’s the plan, okay, via
            the following route.</p>
        <p>现在，有人向我提到——一分钟前出现的一个问题——是：请注意，如果我们在<em>a = b</em>和<em>a之间有一条路径，那么</em><em>f</em>通过<em>p</em>对路径进行的操作就是<em>f(a)在</em><em>u</em>中等于<em>f(b)</em>的证明
            。
        </p><p>Now, someone mentioned to me—with a question that came up a minute
            ago—is: notice if we have a path between <em>a = b</em> and <em>a</em>,
            then the action on paths of <em>f</em> by <em>p</em> is a proof that
            <em>f(a)</em> is equal in <em>u</em> to <em>f(b)</em>.
        </p>
        <h2 id="transport-property-and-equivalence">传输特性和等价性</h2><h2>Transport Property and
            Equivalence</h2>
        <p>这是自动的，因为，嗯，板子——它在背板上或擦除板上——我刚才对路径的操作做了什么。如果我们把它仅仅看作是从 A 到 U 的函数，它会自动对路径产生作用，它会将域中的路径转化为我们已知的余域中的路径。但我不知道的是 U 中的路径与类型之间的等价关系是什么？啊，因为等价会告诉我们，我们可以将事物从一种类型移动到另一种类型。</p><p>That’s automatic because, well, the board—it’s on the back board or
            the erase board—the thing I just did about the action on a path. If we
            think of this merely as a function from A into U, it automatically has
            an action on paths, and it will take paths in the domain into paths in
            the codomain that we know. But what I don’t know is what’s the
            relationship between paths in U and equivalences between types? Ah,
            because equivalences will tell us that we can move things from one type
            to another.</p>
        <p>那么，等价性最重要的一点是什么呢？如果我说 A 等价于 B，根据定义，这意味着存在一个从 A 到 B 的 F，它具有一些额外的结构，我将其写为 equiv，这意味着它有一个向后的映射，它具有我刚刚描述的属性。</p><p>So, the important thing about an equivalence, right? If I say A is
            equivalent to B, by definition, it means there exists an F from A to B
            that has some additional structure, which I’m writing as is equiv, which
            means that it has a map backward that has the property that I’ve just
            described.</p>
        <p>换句话说，两种类型的等价意味着我们可以将一种类型传输到另一种类型，这样，在同伦性中，它们就是互为逆的东西。所以，它们是可以互换的；这些类型是可以互换的。所以，有一个……</p><p>So, in other words, the equivalence of two types means we can
            transport one way, transport back in such a way that, up to homotopy,
            those are mutually inverse things. So, that they’re interchangeable;
            those types are interchangeable. So, there’s a…</p>
        <p>所以，这是……我们……我们……我们已经有了事实，好吧。</p><p>So, this is… we… we… we have as a fact, okay.</p>
        <p>所以，你……没问题。我听不见你说什么。这个概念和范畴论中的同构有什么不同？</p><p>So, you… it can be okay. I can’t hear you. How is this notion
            different from isomorphisms in category theory?</p>
        <h2 id="equivalence-and-category-theory">等价与范畴论</h2><h2>Equivalence and Category
            Theory</h2>
        <p>我在这里讨论的是范畴论中的等价概念。有一个范畴等价的概念，所以我说的是，等价的概念，当专门用于那个设置时，就是范畴等价，好吧。</p><p>It’s the notion of equivalence in category theory is what I’m doing
            there. There’s a notion of equivalence of categories, and so what I’m
            doing is I’m saying the notion of is equiv, when specialized to that
            setting, would be an equivalence of categories, okay.</p>
        <p>如果 A 和 B 是类别，F 将是 B 的函子。等价性正是如此，因为你所说的是，如果你执行 F 然后你执行 F 的逆操作，你不会得到相同的对象；你会得到一个同构的对象。它是同构的，所以它是同构的，直到同构，这就是我在这里用路径概念解释的。</p><p>If A and B were categories, F would be a functor to B. In equivalence
            is exactly to be that because what you say is if you do F and then you
            do F inverse, you don’t get the same object back; you get an isomorphic
            object back. It’s isomorphic, so it’s isomorphism up to isomorphism, and
            that’s what I’m explaining here by the notion of path.</p>
        <p>所以，这本热门书中有一章是关于在这种基础上从理论上发展类别的，所有这些内容都讲得很清楚。所以，你可以看看，好的。</p><p>So, there’s a chapter in the hot book about developing categories
            theoretically on this kind of basis, and all of those things are made
            quite explicit. And so, you can have a look there, okay.</p>
        <p>现在让我回到刚才的话题。让我看看传输属性。好的，我们要……这只是一个评论。所以，现在，我们处于这种情况，在我再说点什么之前，我唯一想对你说的是，这个东西对你来说目前还不是很有用，因为仅仅因为……</p><p>So, now let me get back to where I was. So, let me look at the
            transport property. Okay, so we’re going to… that’s just a remark. So,
            right now, that we’re in the situation, until I say something more, the
            only thing I want to say to you is that this thing is not so far
            terribly useful to you because merely because…</p>
        <h1 id="type-theory-foundations-5.2-robert-harper">类型理论基础 5.2 — Robert Harper</h1><h1>Type Theory
            Foundations 5.2 — Robert Harper</h1>
        <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2MBERISGBUYLxoaL2NCOEJjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY//AABEIAWgB4AMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAAAQIDBQYEB//EAEUQAAIBAgMEBAkJBwUAAwEAAAABAgMRBCExBRJBUWFxkZIGExUiMlKB0dIUFyMzQlNUcqEHJDRiscHhFkNEgvA1ovGj/8QAGAEBAQEBAQAAAAAAAAAAAAAAAAECAwT/xAAiEQEBAAICAgMBAQEBAAAAAAAAAQIREjETIQNBUTJhInH/2gAMAwEAAhEDEQA/APn4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOm/0NtP7/Cd+XwkrwE2o/wDfwffl8Jnnj+rquYB1H+g9qff4Pvy+Ef6D2p+Iwffl8I54/pquXB1P+g9qfiMH35fCR/oPan4jB9+Xwjnj+nGuXB1a/Z/tVq/yjBd+XwmHE+BG0sNSdSdfCNdE5fCOeP6sxtc0Ddf6Yxv3uH70vcSvBbHNpeNw+f8ANL3GfLh+tePP8aQHVLwA2rKCksRgrP8Anl8Jb5vtrfiMF35/Cb5RjjXJg6z5vtrfiMF35/CR83+1fxGC78vhG4vGuUB1fzfbW/EYLvz+El/s+2sv+Rgu/P4RuJxrkwdZ8321vxGC78/hI+b/AGt+IwXfn8I5Q41ygOs+b7a34jBd+fwkfN9tb8Rgu/P4RuHGuUB1fzfbW/EYLvz+Elfs+2s/+Rgu/P4RyhxrkwdY/wBnu1l/yMF35/CPm+2t+IwXfn8I5Q41yYOs+b7a34jBd+fwkfN9tb8Rgu/P4RyhxrlAdWv2f7Vbt8owXfn8JL/Z9tZf8jBd+fwjcONcmDrV+zzazX8Rgu/P4R83m1vxGC78/hJyhquSB1vzebW/EYLvz+EfN5tb8Rgu/P4RyhquSB1z/Z3tdf8AIwXfn8JHzebW/EYLvz+Ecoarkgdb83m1vxGC78/hJ+bva/4jBd+fwjlDVciDrvm72v8AiMF35/CR83m1vxOC78/hHKGq5IHXfN3tf8Rge/P4SPm72v8AiMF35/COeKackDrV+zva7/5GC78/hJ+bva/4jA9+fwjlByIOu+bva/4jBd+fwkL9nm12v4jBd+fwjlF05IHWr9nm13/yMF35/CH+zzay/wCRgu/P4RyhpyQOt+bza34jBd+fwj5vNrfiMF35/COUTTkgdb83m1/xGC78/hJX7O9rv/k4Hvz+EcounIg675u9r/iMD35/CVl+z3a0dcRgu/P4RyiOTBv8X4I4/ByiqlbDO/qyl8J5/wDTuLtfxtDvP3E8mP61MMr01ANzR8GsZXqxpwq0LvnJ+42cf2fbWkrrEYLvz+Eszxv2lxs7cmDqavgHtSlGUpV8HZcpy+ErS8BNqVUnGvg1fnOXwl5RNOYB1fzf7W/EYLvy+Eq/ALaqf8Rg+/L4ScoO+RZIqlYseV2WFyAQWIuRcBY9FP0Dwba/g31o91P6s1+3XbCL8yDeHbSR1Lw+sj1mJPMvS+tj1nB6a6qkl4uKstC7jxKwyhHqLyd0eyPISStxWXApup6Xy6S1xBZNl6idIVnz7Sri76vtJduCsIrma6aTGL9ZkWt9p/oWSIy5ERG6/Wf6Cz9Zk2aCz0QBwkkvO/QndkvtLsIysCArvVrLoDb4NdhBZK6KI3Z80Gp3+z2jes8yya4jpPaicuCj2l/P4xj2/wCCqCu9AVk85LRdovL1f1Ii8sixllW8k/Qfahd+q/0CbTzLICrcvVY3n6rLNgIrvPk+wje6JdhdSIbzAjxmWkuxjfS1T7C28iN4B4yL/wAkb8cs0N7kHNkEeMin6S7S3jI6Noq5NtEuzYpTfjfJospJ6FW4pejchyhfJajQu5JC980U818ExeOm6rjSLkK6CcfVQ3o8iHs3kid9ELcfAlKASjkUlK6LWi+H6lZQj09oRze3HerT6matK8TabeSjXgl6pqbtaHDLt6/j/l6tmfx0F0nWp7sUcnsnzsfG51TTcUdvj6c/l7jFjX9BO/QMHZ04tIrjknhpKSum0mi2Cgo04RirJLJI3OnB6GYnpczOLXBmNxlyMwYLZEkIlaGHUYQJRapYgkIgzU/qzWbd/hY/nRtKfoGq2/lhIfn/ALMjeHbSxMlH66HWYYsy0H9NDrOUem9Ospq9NdRbRZmOk/MXUXeZ7HkVnPcrQju5Svnfj/64lNxnCPrP+xSs7zovlL+zFRr5TSXGzNSC8kpLRX4EUYz8Uo1JRlJatKy7DH8oUqsqahmn5uev/rMlVd+EakXuN3io8HL/AMmNXQzK5WbaaSV2zHTxEZJZNebvSfCP/rCdSKjSr73mO6v1lkuzbLCanBPQnNcTzUK18t2yzbz0zJWMpSUXmru1mtC8LtNx6I24lt1PQ87qTlVlTp7t46uWiE67py3bN2tvWelyWVWdRZ58VWqUnT3HbzlvdV7f3M28+k8NStCrTxEld5Wi0m1l09ZcMd1K2EnG2hMN1rNXPPKvGEFOcWoXs3yIVVylBpuEZNpRf2sv00ZnjT/Hp3o8iySR5pYqgqipuaUnkr8WZVUTbjvq6V2rkuNRd+b/AIJKwqRqQUoNSXNEb13xILJpolprUhRuVz5k7RbgTfIhIiTsgElvJrmTwzIvmQ3mXQs1ZEdRG8TchpDWZLV7Bq2d7ktMIhLkTaxWLs80X3lxQpUZZlVHVosVeWXMFRa+isVkmn0stayyCV3foARDzLNPLqEVfiRP9Vtmi1+gm1iGESQ3kERLQiOa8IJfvcfymslmlY9+33++r8qNcpZK5wy7evD+Xt2Mv36L6DrINWSOW2P/ABytyOlTsjth05/L7rzYuXmSu7LfSzKQrV6cUoUotriqiPH4R0nX2TWgrXdRWuah7EoOhStdSaV+w6T24OmWLxeniJPqmiXjsQv+NV7Y+85byFBaSaHkeUV5taa9pdQdWixUsuk4uqGidBcgKkglX5jiFZoLzDVbff7vTX8/9jbR9BGn2/8AV0/zf2M3pv4+2k4XRmwrvWh1mJaF8N/EQ6znO3fLp11Oygm+RWnVdRNtbtnkug8m0cV8l2fKotYxyPNhMfCdGnPfV5RTPVvTjjhybapS36binZ6p9JSdGpNKSlFVU79HL3mGGK8c04VN1dWpmip2+tb9iN41i42drrDxUoSS86Ed25j+T7sYreXm1HNZc7+8yWl67KuMr/WPsRZuXtNMcsIn43dm4+Mtfjb/APRHBxjS8W6k5U1pFsypTek/0Fp+uuwvK/ppjWEgm92c7y9K7XnCeEhKUno5w3bGS03pJdhMYz3r7y7Ccr+ppidKrBqpHdcnFKab1MU6dbxvjZRUk7Nwi+XHM9b3pPzWuwr5/OPYWW9ik51JUm6dO0nklLh0kVaajg5UqcW7QaS5mS8+SLLeu/NWXSToY501UdqnoW9Hn1mOlQm3TU07UnKz58v0PRJt/Zt1E3l6rJyqPCqEpONGdF2jOUpSayaz07SI4Ga8XnvNyaqN8Y8P6I2HjHazi2RKp/LJew15MkYcL5tOUrO0qjtbsPRGLzMcZ015qaXJaGRSuYy9hfIEkGRa9iqavmrktNorG1ukA9bk2umA+RdoK3JBpWyGa5BGQ4DgGyCgSk3xK73WSm+ZVSs9CGgNCCXkV3rcCWss0VlZ5IRNLbytci/IhKyL2V+gidJzDAIgVm/NZJjnnFg9OW24749/lR4Hoj2bYd9ozXJI8mtjhl29WH8xsdi/xn/U6NaHPbGX717DfvJW6Dth/Lj8s9tftd3wLt65hhF+KpLlEybX/gkucy1NZR6jr9OSFAxQqUJyahUhKS1tJXPZuHir0Iy2nR3oRl9HO910xJPaNpdJk3zKknPTvpIIJJpRMnUhEgZaa801G339HS/MzcJ+YjSeEGVOl1sldMO2mvZGTDy/eIdZgvkzLhf4imuk5zt1y6bbbsHU2ZLd9Wxz2z5ToxhCT9E66cI1aG5NZNHM4nDyw+IcWsuDPTetOODdYNZPlqbejL6NGm2an4tbz4ZG0pTtK1znj26/J/L1N2LJxfApB3XMsndHV5tpVlwIyuSpJaq5LlHl+g9islusXzyDkmV0Kq8mloVzQhne9jBvylV3k/o1Ld63/wDuRZEepw6iq83UlybK1ZwSXnKPXkSbTf0tlLMhuxihVpyyjOMup3MuTtYWaNJSYS6SM+Z40479V1KrTUsnvWsrIsx2PbxCZjoSlKjFy9KxkaM316QuLhmGVSMKtpNreWXK4nsZ3l7SjlGOuVytSrCFN1JS82OtszDWnGrQjKPrxVnqs0WS1HquLN3sY5VI0m1NNWV78CvyhOgqsM4t2/Ww0M+qKtW1LRzTZDdzKIlwJWZjrVFRpSqT0ieXCVP3hb03KVSOeeSaNTG2bV7pai1iEm2eSOKlHF1XVdqKdou3FaiS0eu5FSpClBzqSUYrmUo1XVTluOMb+bfVlcXFSw03JJuKbjfgya9+xanWjVlux3k7X85NGVRPJGhiIzVVyhJ29FXVj0qW/BNMZSfSJTSLIra5JlKZi9yQBDu9Ck77jL3VjHVb8W2gOR2nK+06vs/oedcTJtGV9p1utf0KLlzPPk9OH8tlsTOs7cjf6mh2IvpZ+w3sU1qejH+XL5O2t2v/AAkOmRnpLQ8+1vqKS/mPXR1NfTkyWPNUwKnX8a69ZZW3U0kv0uetLPqJsmugkojiESQc3bYTYglBTQC4AzQ9BGj8In5lHrZvI5UzReEX+wuv+xHTDtpeDM2CzxVPrMXBGbA/xcOsxO3TLp0qj5qPLj8IsRQaXpLRnsinuJ3Eo7yPTp52m2bXjZ0pZVI5WZ7605QouUVeWiyuara0PkmNp1oqynr1mzw9WOIoXT1Ryv8AzdvRLzx0vSq4jxct+6drqy5MyxxVSiovdlUjK+7lnr7jHSlFuzXnLmz0KEXwXsPTMo8+vqstCq6s6ks/F5bt1brMkJZO93nxMcMo2WhfgZFuslK+hUaEFcRvqm1SV5vJdHSYZYaNCl5sqjcecm1qeqN3oRONsrmplr0i0lY888N9I5U6VCKed3G7ZmvbUlZ8yS6SvPNuhFTqLeV7ebHQzwqwlVlTj6UUm/aUxFGVWMVCVnF3zV0UpYXxM9+M/Ofpt/aNW42bvabenieKdJ79ReJUnKV1J8MkezPUhmJbBFGLhTjGUt5palw+ggm9+xOXIwVMNTq76qLeUmnblYzAT0jyVMFQjSlbeUbXavkzJToJU4ptt3Um2XrQlUoyjBZyyL7ria5XXYw1aDqpqbv528r/ANC7XmbjimrWssi97hcjOzRTTUUr52zLPIjQn0vYQYqlPx1SnJt7sc93myakHKVNxWcZX9lmi4XQXYsjDu1XJ2nT3eC3H7zNZX0IdlwJKiEss+HIVIKrSnDTei0LpCIGOmq0Y2e7LLW7RalScG3KV752Lpkt2Y2K71mS3YxzdkWWSzBYlSuTcrFFyJdK6lK2VORkMWJypMFricbK+0q/5v7ErMrXW9tDES/nEbpHDJ6cOm32LlKb6jdyzRpNhvKba4m6ensO+PUcc+2u2p6NBdPuPXRPFtS+9h10/wB0eyk8rm/pzehei2IvzUStLBJK5hFbhEEpGXcBFyUQGL2RSU4wi5zdorW5r3j3Ob3XaHDmyumONy9Rt3NRpK7NLtqM67pOnFy3b3t7D0xqKbV2T4yipbrnFPpYmO3efHMe3Oyi1k00+kzYDPFx6zcYmhSrRtJJ8mtUavD0nR2gqb4ceZjWqZzU26WGcEJJJZCn6Csy3CzPQ8rV7cw/jsBJr0oPeRrtjVuFzf1479KUXxVjk8M50q7iuDsYznp0+P1XSbyjNTTyeTPXF5muptzpJp2Z7KUnuq+pML9L8s+3pyehZGOL4FrnRxXWZOjsyt2Wvdt2ICTT1Jb3mRbO3EhqxRN+ZOVyiyZNrvIGl1ddIkOJD1Iyl8CEhe5MbcQJvzBAbzIiOAehNiCgrriT1hAgjJcAs8yWrah9AEMaCxLRRFm+BO60SsrksztNhWWlybpsiTvkUkErkaEx6AyH2JoXXIhrMjjYoE3IRN1yCiaXMtvIq+hEaahF7p58jBin9CzJmYsXJeIZEriHJvG1vzsyXVzCv4uq/wCdmbicMu3pxvpt9iJ7s+s3D0eZqNjZQl1m1k8md8enHPtr9p/xGHX/ALU9lFeaeLaP8XQR7aPoo19Ob0o16r1KO0azm28O3GGvoSt/Q96ZgpYayrxqqMo1Zt26C42Te02ypoXyKOQcjk7rkXKOV+JG8gNLt7HShXp4dO0bbzNdGs3ZqTXUefwhrNbbkpOycFY8nymMI23jrxdcM9NpiNoulTtGWZpqmPnKpvObZ48Ti3N2ueZVHc6Y46cvk+W5Ot2XteTXi5tyXTwNpdSxEKy0jr0HGYKq4yu9TosGq+LUYb7pU3lK3pNf2MZYze28M7cbK66m04K3FcCxiox8XRhC992KRlbT0IwiaujmcZSdDaU0llPzkdNJ3PBicNTq1oTlrHIzlfXt0+PdrHhPRzPXDJmNJR0RClaqlzOOHbvnN4vZDpMieZ51PmZLtHo1Xj0zS0ITKpk3EWLrmWlmY1KzLipU3S1RCd+giSb0CTB9LXFyARDe5IkgsBCC6SW+RFyIZ3sNNQrkqL4lEC4TuErgHcXzHWQ8wJTJbKlrX0IJuG1yK5rXMOWVyaTSUxJELMlpsp9l0iWVSuxpqTRpPErnxFybMqrWRDsiU7kSVyMoTRDd2Q3nawad8i6a0lM8+Ma8Tkem6fA8uPaVDLIjNcVHOrOX8zMsXkYKLzlfmzMnmcMu3px6bzY6+ifWbOo1uvqNXsh/Q+02Mr7j4nonThn21+Pf7/R6j30X5kes12N87aNNcl7zY0lajHrNfTMenVAR0JafAymnkbDkUuLmXZbeRG8UepDYRyPhph5RrUcVH0WtxnL+NlfU+hbcwb2hs6dJO0150etHzycJU5uM1aSdmnwO+F3GMkuTbLQzduJjWZ6MPScpI2zPdbXZtKCp2nub83lKXC3I3mBnuVYXzuzSbPrU6Dmq8N5axyNns+p42tC2SvfqOV7e3HUxdkn5keonePNXxmHwdNSxNaME9N56nPY/wxpQbhg6W+19qWSEm3n5Rvtp7TobOoOdaWb0XFmpwvhPgcRW3ainSv8Aakro5DH7Sr7QreNxErvglojy73HiauEvZPluPT6lKUVFSTTi801xMVDz6jqPTRHP+C+NqYjBSw05N7kvN6EdNBKEUuBxmHGu2fycsV0jImYbmSMnzOjiyJstezKJkphds2XAm7SuikHqIkZXuWuVJWZBMfO0IbJi1EgCIsneCD1KVOpC1HEN9BIMhSzlo7BS5i/LIkZhoSnYSKhe03zDBDKq2qIuSiqVyMrekN12Ii7LMs5CiN5ItcxsmN2NFi0U1e5E9Oki75sPMGgmGmYyvYizB2sHfgCJZkiQUUm3zGjzIgS1cqo3lyPHtR7uGk+SZ6WmuJ4NsS/c5/lYqVx+H0vzM6zzPNhsqaPRE4ZdvTj03uyMqCNhLOB4NlL6BHvnorcz0Tpwy7a3FZ7Tj+X+xtKavQiarENPatr5pf2NxRV6Meov0wyRzWRbQiOluRYyNeQwyGzLqhuxSRaTMUpZFFJyVrHIeE2DoQxMa0ZKMp+kr8eZ59s7axdTGVaVOrKnShJxSjle3SaeUpSk5Sbk3q2ztjjpi1LaTyzJVWa0duooDbDNCrNfaZtdkbTp4aTddvLNWNKE7DSy1strbVr7SxG/Uk1BehD1UeG+RUhMDILlN4nVhHY+BVB+Jr1no2kjqG7OxrfB7CvC7Joxas5LeftNkznfddoaFoZsqSpciDLHNF3kzHGVi29ew+z2yZxLKS5GO9y0GgrIiU9bFUsi1raEZE7okq3YXT0QEhAi9tQJuN6wsMuQmhN+QRKstUVbzuiIkW43IuTcA2CGxcKtfmRKz0RZ2SWRV2egiCeZbVOwur5IkiVVa5k66ZE2XIh2bssgdotmRa5ch2XAbNp6QiG7Ep3CDIJbS1KN55A0slZJEkLpJIVSaujV7ae7g5/lZtmsjT7fdsHP8rA5LD/Vmcx0Y2hYyJnG+69OPTf7Lv8AJo9R653yz4nl2blho9R6pWy6z0uFvtrqq3trTa13fcbqg7Qiug0rz2nVfQbukvNT6C3pisi6CwQeRga5lWTcrUkoxbeSRnTqrPJZnM7d8IYUFLD4OSlV0lPVR/yeHb3hFPEzlQwknCisnJay/wAHOt3O2OH6xciUnKTk3dvNtkAHRgAAEggASSVJAlHv2RhPlu0aNG105XfUeBHV+BeGvUrYlr0Uor2kqzt1y82KitFkWTKaljDraJtssVa5E3yIi18i6dkUSLFaZEZFqUi01kWMs7XV0W3stCmZNwJSyzzLFY9ITzdwLIZ20C5kcQLLWwaaIWovzIh7QLZEFVNwN0WsREqy1K6F007ZaiaBtXUm64kJWdy148gIi7ak7yIedrEDs7Xd+BCaT5kK7vmPRWZEWlfgVUuZbVFLWBF00/8AIirEJrgiboIPMJC4IJIejtqAEHoaXwhzwskvVNy9DS7ff0EuHmhY5mloWIjoyTj9vVHQYD+Gj1Hqvmus8+AVsPHqM0vSj1nqee+68C/+Qqs3tNXhHqNDDPGVuv8AudBSVoIl6YRKrGNZUnfecXJdSt7zHgqtWtSlOru5ye7urRXIxGGlUxlGor2UZxlnbW3uKbNpOhCpBym7TatJ343/ALl1OKsBpvCrEyw+yJ+LdnN7l+s3DOV8Nqv0GHp31k32L/JnGf8ATdcgADu5AAAAAAAABJAAsd54JQ3NjqVrOc278zgkfQ/B+cZbFw25oo2fXclax7bW99CyuUUkTvcjDa90SjGncunbUmjTJoLlL3JLpZGePQWRijdFlIiM1xroY1IsnbUSGmS/Ii/MqG7E0Ml1ZWTI1FyLthF00TdciiyJ0WZNGhu6uiI3EmuAhNcUUWIvkT7UyrdhFXTsW3k+Bj4kkTS+RXdZF3wG80PYtFE5J6alXNEK7SYRaNsyJhcQ2uKIfYpWQbvoiryIuXS6WTzJbElyJStqRE5ApLJFHO3MuiRm0K73UVTfST0EQvkaPwidqXsX9TdpWNF4RPzbdCJSdtBF5C5XgRvZnGPS6fBK1CPUZW0pxMOHdqS6jJe84npea9tdRf73Vf8AN/c6SGUVl+pzmDtLEz43mjo46IuVRcjJAMwNQ2cd4ZzvicPHlFs6yFanWhvUqkJx5xldHG+F8r4+kuUP7m8O28unPkkA6uaQQSAAAAAACSCQJOy8D62/gKtJv0J37TjTo/A6ru4qtS9aF+x/5JVnbsC11cx3LIzXReJZmNX5mQgldDMjRVF0wbFlxLJEJp5FiG0LPiX04lUi9irtZJ31JcSNS1zO0QyyZAKBLvxIWpdolRSwVhbItqyqJoWzFiUrakRKVw1Yom1zJUr6sC1r6Bq2ovyCa4kBK2qRLy1/QhST4FlZkZUSzbuyJJ3yZdLdWZV5lX7Q4zWepMbPgXZSSs8sh2b2tIq2+ZG9vaq5F+ZdLF5Z2MZdO7ZNkTpN6VhpcstEQslYlBA5zwknZ26jolpY5jwmfn+1GaTtpkyIZyRXMyUl58es5Tt6XTUfq1lwLJ+eitF/RrqIb89PoZ6XmeLA/Xu3rnSrRHN7PV6qf850sdEMhLIbsSY6q3o8jA4rwVb8mz/Oafwt/wDkaf5P7m38F8tnS/OzVeFtvllLnus6T+j6aAAHRkAAAAASCCQAAAk3HgxPc2tTXrJr9DTnv2PWVDadCbyW8kwR9CXSSncrcsjm6LJ5l4vmYyU7MDNFlkY48S6Ausi2pVF0BKLLQpYukBZW4k8CpJFSpXJTK7rehKTTzLdCb2zLKWRWxNiegFwFkQWuQtQiURC19CHGxNstbFpRvoAWY3b6FVKzL6BL6FEha5BtLTIJpAXKKSzuizdjG9CQkWtu6tsh+dmkTJXZES7FL8iVrmTukPJl2rJYqmmrom6XDUrvJaIjKSIyvoE76Bx5ZATY5Xwld69v5l/Q6ps5Lwjf07/MZq49tVwMlH62K6THF3RlofWw60c529DoqT8wLJy/KKeUEQ/Rm/5T0vPXm2bnUXTI6SOhzuyY3rR/MzouCGTN9RPErNXLESSepzVxPg3SnS2c1Ug4tyeTRpPCt/v8Fyh/c6/eSRrtp4Ohi6TdSmnJLJ8Ubl97a16cKDYw2epPOVjL5Pp043zk+k6bTx146eEdTCuaXnXyPKbqgrULdJqKqtVkukRmxQAFQJIJAABASjJTdpJmMtHUD6FszEfKcDRq8XHPrWp7TnfBTE79CpQk84PeXUdCjFbWTyLJcyqLoKurIsiIouiC6LIoiy0IJui6ZRIssi3SrEkE3zICug7thdJdNchtAJNkE3IoyVlwIaAQJWtiC0VcKmS6iLyHBvkS00BG6RfnmZN0pNWsO02rcss9BIJNaAWWciJ5WsBU4EPtGb4kxTVw4tciN9aPUtSidnmRJp6EXJVlqgqY53uTKy4BRaEukifaH52gSfFiKsSEVadlmcj4QO+Ia/mOvZx+3c8S/wAzJb6ax7a2Oh6MPnWh1nniejCr6aHWcp273p0EH5qKz+rqNeqyYZxK1GvFVeo9LzVTYudaPtOgtdI0Gx8q0X0M6CLTSa0JklnofQVs3xLyaPNi6lWjGPiqTnfVr7Ps4kk36Y7rQMxVHdMyMxTyJHeOdbjGrK/CTJlJTWRn2hgXJurR9LjHmeCnVtlLJnR05KqcqbafomuxH10uTdzZ1UpRNZX9M1HHKMQBJWEEgAAAALxKkxA2/g9ifk+04Xdoz81+07iJ80pzcJqS1WZ9EwFZYnCUqy+1FN9ZnJqPSi6KpGSKMqsiyCLJBUlloQiVmBZEohItdIf+KkWb0IuTcgJFrWIiywFk1yLZWyRTiWzJpNIUWw1YsgBVInQtKz0ViLBUJEvQlxsyrVwibvmyCS27fTICsn0ExVyJxaaJQEzysUz4svJNK7dynSJCLKcXwKOz0JSvoid2xfR6VXMWLKDeZO44kNidyPSWRMWuwm1kiMosRKSjqWsHHmQUlocZtmV8W+tnZvlyRxG1nfGe1/1Jl0uP9PKj04T+IieVuzSPTgm3iYoxjP8AqPRem9i7QVjFW/hqudrozRsomOuk8NOx6HmW2HlOOV7R4m9h5izWT0Oe2biYUGpXi3a1mbTytDjCn2jJdtgpRfApUclB7kd6XBXseLyvT08XD2SJ8r0vul3/APBln7aSxjmmencKuGRnbo19RZGpx2F3vPgrS/qb2pTPHWpM1KrnXUccpao8VeW9UN5isIp3drM0VeDp1ZReqZ1jGSgAKwAAAAAJJRAQFm8zdbIx1eNJ0o1qsVHNKMmkazBUlVrreV4rU3FNU4K0FGPUYzuunTDHft747RxS/wB6o+t3M8dq4r72XdR4KdpaMzbqscLnlHbhHtjtfFL/AHH3I+4yx21iOLi+uCNbulkrInlpwjZrbVblT7pkW3JpehS7H7zVKIlEeWnjjcw25zp032l/LUHrSj3jRKmXVMvlPG3a2zST+q//AKf4Lx2zSesLf9/8HP7v/mRutSHkTxuljtfD39F9qMkdr4a+cZ+y3vOYsuRO6raDyf4nB1S2rhX9mp2L3l/KWGfGfdOQfjOELmSClJcUPIcK62O0sLxlLulvl+Fb+ssvyv3HKKEkvSfaWSmtJS7SeWHjrqljcN98u6/cWWLwz/34HKXqevLtI+l+8ZfLDhk694mg1lWp94q69HL6al30clvVremyslVc4zc3eOliz5MU4WOxVSm9KkO8i0ZLPzl7Gcd46uvtBYisuKfsHPE4V2clvEOLs8jj/lNXio9hKxlWOiSLPkxONdi3daMxta3Ryvy/EJZNr2kraWJtffl7Jsc8U4X8dQlxRZ65I5ZbVxPr1O+zJHa2IX26neHPE438dPBbqdyJ3fo5HOLbNf16nYiVtyqn9ZNf9Il5427Tje9Oigui5droOcjt2qn9Y3/0RPl2T9KfbAbxv2lldBuy5i6Zo1txv7UPbGRZbb6aXdl7ybhqtvLRnDbSd8Xfof8AU6Ly1C1n4vPpZzeN8/FNwd47qzJlYuM1XnfM9eAj9Ojzxi+J6sG1Gum2kukxjfbtem5jkjFiaVWvg50qLUJtq0npqJV4xWtzNhsYvF2SXtR3lled4KWztqxWWOoK3V7jNHC7Wz/fMNLrt7jY/KbrSD9hCxNvsQ7C8keBUNq6+MwkvaY5U9qephX/ANl7z3yxL+7j2GL5RFPOlFl2rnltrEfyP2FvLVbjGD9hzHy6p93T7H7x8vqfd0+x+85+OunPF0/leo/ShFmKe029aa7TnXjqnqQ/X3kPG1PVj+vvL46c8W7njlLWBosZU8biZySsmyXi6j4R/UwN3bfM3jjpzyyl6CADbCQQAJBFyb9CAklRbIU2uCJ8Y+SA9+zsdX2XV+UYaUVUzWavkbHB+EGOVJwlXlJ+tNts591ZNWsi9PESpqyjF9aJf8aldbhvCbF0pOU40K2VrTpq36WNfUxTq1JTyjvSbstFc0vy2f3dPsfvJWPqL/bp9j95zuNdJni3Uajb9J9pbel67NKto1F/t0+x+8eUqv3dP9feZ4VeeLeKU/vGX3p/efoaHynWX2Ifr7x5Ur+rD9fePHTni3/jai+3+hPjavrR7Dn/ACpX5Q7H7yfKuI5Q7H7yeOnPFuayxFSSamlbk7GNU8Unffb9pq/K+J5Q7CVtnEpaU+x+81JlEtxrZp4u/pfqZadXERmt7NdZp/LGJ9Wn2P3jyxiPUpdj95bMr9JLjPt0kcRJLOD7S/ytepL9DmfLOJ9Sl2P3jyziF9il2P3nPw1vyR0/yuPqT7CflkfVn3Tl/LOJ9Sl2P3jyziPUpdj95PCeSOpWKhfR9hPyqn09hyvlrE+rS7H7yfLeJ9Wl2P3jw08kdSsTS5vsHyml6xyy25il9ml2P3k+XMV6tLsfvJ4aeWOo+U0nxIdelfU5fy3ifUpdj948tYj7uj3X7y+GnldP8opX1J8dTb1Ry3lmv91R7r948s1/uqHdfvHhp5XWeNg1kyFKBynliv8AdUex+8eWcR6lP/7e8ngp5Y6zeiLR5nJ+WcT6sP8A7e8ny3iuUP195PBkeaOryItfkcp5bxf8nY/eT5cxnOHY/eXwZHljqkiySOTW3MYvu+wny7jOVPuv3jwZHljq7LiRupnLeXsZypd1+8ny/jPVpd1+8ngyPLHUbiPPVSUsjnnt/GP7NLsfvKPbWKbvan2P3lnw5HlxdCkHqjnvLWK9Wn2P3k+WsTe+7S7H7y+HI8sdC3kYpO/Fmj8t4n1KXY/eR5axL+xS7H7x4sjyYt55y+0yVvp+m+00T2ziX9il2P3jyzifVp9j95fHmnPFvnOdvTl2lXOf3k+8zRPbOJf2aXY/ePK+I9Sl2P3jx5lzxa8AHpcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB//Z">11 年前 (2014 年 1 月 5 日) — 20:27 <a href="https://youtube.com/watch?v=3obCo8n7VuQ">https://youtube.com/watch?v=3obCo8n7VuQ</a></p><p> 11
            years ago (Jan 5, 2014) — 20:27 <a href="https://youtube.com/watch?v=3obCo8n7VuQ">https://youtube.com/watch?v=3obCo8n7VuQ</a></p>
        <h2 id="summary-14">概括</h2><h2>Summary</h2>
        <p>本讲座介绍了同伦类型理论中的传输概念。它将传输定义为将类型之间的路径映射到相应类型之间的等价关系的函数。演讲者演示了如何使用路径感应来定义传输，并表明它是函数式的，尊重路径组合和逆。讲座以单价公理结束，该公理指出宇宙中的相等性会导致类型之间的等价性。演讲者强调了该公理对泛型编程的影响以及相等和等价之间的关系。</p><p>This lecture introduces the concept of transport in homotopy type
            theory. It defines transport as a function that maps paths between types
            to equivalences between the corresponding types. The speaker
            demonstrates how to define transport using path induction and shows that
            it’s functorial, respecting path composition and inverses. The lecture
            concludes with the univalence axiom, which states that equality in the
            universe induces an equivalence between types. The speaker highlights
            the implications of this axiom for generic programming and the
            relationship between equality and equivalence.</p>
        <h2 id="introduction-to-paths-and-equivalences">路径与等价简介</h2><h2>Introduction to Paths
            and Equivalences</h2>
        <p>f(a)、f(b) 和 u 之间有一条路径。到目前为止，在我的开发中，它没有给我做任何事情的能力；它只是一条路径。但是，我将能够将这些路径转换为等价关系。因此，实际上将有一个映射将其转换为 f(a) 和 f(b) 之间的等价关系。这被称为等价关系。因此，它将是 id 到 app f_p 的等价关系。这就是我们要得到的。这样，你知道，如果你有一个这种类型的元素，好吧，如果你知道这有一条从这里到这里的路径，那么就等价于从你的传输函数中提取，好吧，这样就可以来回进行。</p><p>There’s a path between f(a), f(b), and u. So far, in my development,
            it doesn’t give me the ability to do anything; it’s just a path.
            However, I will be able to turn these paths into equivalences. So, there
            will, in fact, be a mapping that turns this into an equivalence between
            f(a) and f(b). And that’s called into equiv. So, it will be id to equiv
            of app f_p is an equivalence. That’s what we’re going to get to. And
            that way, you know, if you have an element of this type, okay, if you
            know that this has a path between here and here, into equivalent,
            extract from your transport function, okay, that goes back and
            forth.</p>
        <p>现在，我想谈谈传输。所以，我想说的是：如果我们有 p — 我必须稍微即兴发挥一下，因为我的笔记中的内容可能比我所能讲的要多 — 所以如果我有一条路径，并且我们有这样一个函数，那么我想说的是，有一种东西叫做传输。</p><p>Now, I want to talk about the transport. So, what I want to do is I
            want to say: is if we have p—I’m having to slightly improvise because I
            might have more in my notes than I’m going to have time to cover—so if I
            have a path between here, and we have such a function here, then what I
            want to say is there is something called transport.</p>
        <h2 id="defining-transport-function">定义传输功能</h2><h2>Defining Transport Function</h2>
        <p>有时我们在这里写 f，好吧，就像是它的一个索引。哦，我们需要第一个元素……好吧，你可以用不同的方式写它。因此，p 的传输将从 f(a) 到 f(b)。这是写它的方式。那个东西通常记为 p <em>。这种符号有点不太好，因为你真的需要知道 f 是什么才能知道 p</em>是什么。但在很多情况下，f 很清楚，然后你只是说你只写了 p <em>。但实际上，它应该是传输——通过 f 沿着路径 p 进行传输。但我们经常写 p</em>，好吧。</p><p>Sometimes we write f up here, okay, as a like an index on it. Oh, and
            we need an element of the first… well, you can write it different ways.
            So, transport of p will be from f(a) to f(b). That’s the way to write
            it. And that thing is often notated p<em>. The notation is a little not
                the best, because you really need to know what f is in order to know
                what p</em> is. But in many situations, the f is clear, and then you’re
            just saying you just write p<em>. But actually, it should be
                transport—transport by f along the path p.&nbsp;But often we write p</em>,
            okay.</p>
        <p>所以，我要做的就是通过路径诱导来定义该事物。</p><p>So, what I’m going to do is just define that thing by path
            induction.</p>
        <h2 id="path-induction-and-motive-1">路径诱导和动机</h2><h2>Path Induction and Motive</h2>
        <p>这就是我们要得到的。好的。那么，我们该怎么做呢？所以我要声明我们可以定义这一点。所以，这就是动机。所以，我们要通过 p 上的路径感应来完成这件事。好的。动机是什么？那么，有人能告诉我动机应该是什么吗？好吧，我声明动机应该是：给定 x 和 a 以及 a 中的 y，我想要 f(x) → f(y)。是的，有人这么说过。我听说过，但无论如何，是的，那是对的。</p><p>That’s what we’re going to get at. Okay. So, how do we do this? So,
            I’m going to claim that we can define that. So, here is the motive. So,
            we’re going to do this thing by path induction on p.&nbsp;Okay. What is the
            motive? And so, can someone tell me what the motive should be? Well, I
            claim the motive should be: given x and a and y in a, I want f(x) →
            f(y). Yeah, somebody said that. I heard it, but anyway, yes, that’s
            right.</p>
        <p>所以，动机就是这是这是在 u 中，对吧？所讨论的命题的类型是，对于任何 x 和 y，我都可以从 f(x) 传输到 f(y)。稍后，我要展示的是 p* 实际上是一种等价。好的，但首先，我想定义这个映射，然后我将展示它是一个等价。我想我没有时间，但我会说它是一个等价，然后我将以单价结束。所以，让我们开始吧。</p><p>So, the motive is going to be that this is this is in u, right? The
            type where the proposition in question says for any x and y, I can
            transport from f(x) into f(y). Later, what I’m going to show is that p*
            is in fact an equivalence. Okay, but first, I want to define this
            mapping, and then I will show that it’s an equivalence. I don’t think
            I’ll have time, but I will state that it’s an equivalence, and then I
            will finish with univalence. So, let’s get here.</p>
        <p>这就是我的动机。这是一个很好的动机，因为它会让我得出结论——如果我可以填写第二部分，好吧——它会让我得出结论，对于我插入 a 和 b 的特定路径，我有一个从 f(a) 到 f(b) 的映射。那是什么？让我们把冒号倒过来写。这将是 j 的一些实例，根据尚未填写的一些参数的动机，应用于 p。所以，事实上，我不仅知道你有这种传输，而且我还知道 f(reflexivity) 上的传输是适当类型的反身性。</p><p>So, here’s my motive. So, that’s a good motive because it will let me
            conclude—if I can fill in part two, okay—it will let me conclude that
            for the particular path I plug in a and b, that I have a map from f(a)
            to f(b). And what is that? Let’s write my colons backward. This will be
            some instance of j, by that motive of some argument yet to be filled in,
            applied to p.&nbsp;So, in fact, I will not only know that you have this
            transport, but I will know that transport on f(reflexivity) is
            reflexivity at the appropriate type.</p>
        <p>而知道——或者从定义上讲，这应该是定义的——在定义上等于那个。知道这一点将使我能够证明传输是函数式的。</p><p>And knowing—or definitionally, this should be definitional—is
            definitionally equal to that. Knowing that will allow me to show that
            transport is functorial.</p>
        <h2 id="transport-as-functorial-equivalence">传输作为功能等价</h2><h2>Transport as Functorial
            Equivalence</h2>
        <p>在 p 中是函子，即尊重路径结构、组合和逆。谁是谁？抱歉。哦，什么，抱歉？身份函数。身份函数是这里的身份函数。ruffle 的传输是身份函数。是的。所以，这是我倒着做的一个例子。通常，我想把 ruffle 写成身份。在这种情况下，我把身份写成了 ruffle。好的。那又是什么？因此，是的，这就是为你准备的。我只是——就像，我试图严谨地帮助你理解如何使用路径感应。</p><p>Is functorial in p, that is, respects the path structure,
            composition, and inverse. Who’s who’s what? Sorry. Oh, what, sorry? The
            identity function. The identity function is the identity function here.
            Transport of ruffle is the identity function. Yes. So, this is a case
            where I did it backward. Often, I’m tempted to write identity when I
            mean ruffle. In this case, I wrote ruffle when I meant identity. Okay.
            What’s that again? Therefore, yeah, that’s there for you. I’m just—like,
            I’m trying to be rigorous in helping you understand how to use path
            induction.</p>
        <p>步骤如下：写下动机；你必须建立某种充分性；因此，某种东西。然后，某种东西始终是 aj 和 b，因为这是路径感应。而那个 j — 等价 — j 的定义相等将给我们那个定义相等。而那个定义相等足以让我们证明传输的其他有趣属性，比如，如果你进行多跳传输会怎么样？嗯，这与沿着组合进行的单跳传输是一样的。</p><p>And the steps are: write down the motive; there’s something
            sufficiency you have to establish; therefore, something. And then the
            something is always a j and b, because that’s path induction. And that
            j—the equivalence—the this definitional equality for j will give us that
            definitional equality. And that definitional equality will be enough for
            us to prove other interesting properties of transport, like what if you
            do a multi hop transport? Well, that’s the same thing as a one hop
            transport along the composition.</p>
        <p>你可以证明所有这些。好的，通过路径归纳。所以，我现在不打算这么做。所以我唯一需要做的是：充分性是什么？嗯，这很容易。我需要证明，对于 a 中的 x，存在类型为 f(x) → f(x) 的东西。对吗？因为将反身性视为我的路径就足够了。没有涉及路径，因此端点是相同的。因此，在这种情况下，当端点相同时考虑它就足够了。</p><p>You can prove all of that. Okay, by path induction. So, I’m not going
            to do that right now. So, the only thing is I need to do is: what is the
            sufficiency? Well, it’s very easy. I need to show that for x in a, there
            is something whose type is f(x) → f(x). Right? Because it suffices to
            consider reflexivity as my path. There’s no path involved, so that the
            endpoints are identical. So, in this case, it suffices to consider it
            when the endpoints are identical.</p>
        <p>答案是 λu λu u。因此，我在这里填写的是 x • λu u。如果要写出类型，那么 x 就应该在那里。λu：f(x) • u。好的，这就是为什么它是 x •。我们完成了。我们有了传输的概念。然后，作为练习，你可以展示这一点。我只会简要地写出来：ruffle lower star 是 ruffle。你必须使它完全精确。但是如果我取 p 逆 lower star，那就是 p lower star 逆。</p><p>And the answer to that is λu λu u. So, the thing I fill in here is x
            • λu u. If you were to write the types, that’s where the x would be. λu:
            f(x) • u. Okay, so that’s why it’s x •. And we’re done. We have the
            notion of transport. And then, as an exercise, you can show that. I’ll
            just write it briefly: ruffle lower star is ruffle. You have to make it
            all precise. But if I take p inverse lower star, that’s p lower star
            inverse.</p>
        <p>如果我将 p 与 q 下星连接起来，那就是 p 下星与 q 下星组合，函数组合。好的。你可以写，你可以做所有这些。它在热门书中，但你可以做那些练习。这些都是通过使用传输属性（现在是身份）的路径感应来证明的。是的，是的，是的。不幸的是，我处于匆忙的状态，匆忙永远不是一个好主意。所以，另一方面，我正在做的是我在脑海里和你说话。我正在回溯我要涵盖的内容，并试图找出如何到达我想要的终点。好的。</p><p>And if I take p concatenated with q lower star, that’s p lower star
            composed with q lower star, function composition. Okay. You can write,
            you can do all that. It’s in the hot book, but you can do those
            exercises. Those are all proved by path induction using the properties
            of transport, now as the identity. Yeah, yeah, yes. I’m, I’m
            unfortunately in the position of rushing, and it’s never a good idea to
            rush. So, on the other hand, what I’m doing is I’m speaking to you in
            the back of my mind. I’m backtracking and what I was going to cover and
            trying to figure out how to get to the end point I want. Okay.</p>
        <p>所以，现在我想要的终点，我想要的终点是这个，因为我们要跑了，现在时间已经到了。所以我就让它结束吧。你也可以证明，一般来说，你可以证明传输是类型的等价。好的。</p><p>So, now the end point I want, the end point I want, is this, because
            we’ll run, we’re out of time now. And so I’ll let me just finish it up.
            You can also show that in general, you can show that the transport is an
            equivalence of types. Okay.</p>
        <p>因此，可以做的另一件事是，此外，传输是一种等价。p 的传输是一种等价。这实际上符合我在这里所做的。这是一种等价。我并没有真正地，我在这里敷衍了事的地方，我在这个讲座中欺骗你们的地方，是我没有真正开发出等价的确切定义，以便真正向你们证明这一点。所以，这就是我敷衍了事的部分。好的。</p><p>So, another thing that can be done is, so moreover, transport is an
            equivalence. Transport of p is an equivalence. It really follows from
            what I’m doing over here. It’s an equivalence. I didn’t really, where I
            glossed over, where I’m cheating you in this lecture, is I haven’t
            really developed the exact definition of equivalence in order to really
            prove this to you. So, that’s the part that I’m glossing over. Okay.</p>
        <p>但其核心在于，你有传输，传输具​​有足够的结构，因此你不仅知道 fa 映射到 fb，而且事实上，它是一个等价。而等价意味着它具有前逆和后逆，直至更高的同伦。这就是我要挥手的部分。时间不够了。好的。</p><p>But the heart of it is, you have transport, and transport has enough
            structure so that not only do you know that f a maps to f b, but in
            fact, it’s an equivalence. And being an equivalence means it has a pre
            and a post inverse up to higher homotopy. That’s the part I’m waving.
            Ran out of time. Okay.</p>
        <p>所以，这很重要，现在我们来谈谈以下事情，好的，这就是我要结束的地方，这就是所谓的单价性原则。</p><p>So, that’s important, and now we come to the following thing, okay,
            which is where I will end, which is the principle of what is called
            univalence.</p>
        <h2 id="univalence-axiom-and-its-implications">单价公理及其含义</h2><h2>Univalence Axiom and its
            Implications</h2>
        <p>这就是单价公理。我们知道，如果 a 在 U 中等于 b，那么 a 就等于 b。好的。我们知道了。接下来是公理。好的。</p><p>So, this is the univalence axiom. So, what we know is we know that if
            a is equal in U to b, then a is equivalent to b. Okay. So, this we know.
            The axiom is next. Okay.</p>
        <p>所以，我们知道这一点。也就是说，如果我在空间 U 中有一条路径，那么这将导致等价。还记得我告诉过你这张图片吗？我们可以认为 U 是由这些点组成的，就像 a 和 b。好的。所以它们之间有一条路径。它们只是空间中的点，但空间有结构，这意味着这些点不仅仅是点。它们本身就是类型。如果我放大并增加放大倍数，我会发现 A 实际上是一个充满人的岛屿，而 B 也是一个充满人的岛屿，所有人都在向我们挥手。</p><p>So, we know this. That is, if I have a path in the space U, then that
            induces an equivalence. Remember I told you this picture? We can think
            of U as being inhabited by these points, which are like a and b. Okay.
            And so there’s a path between them. They’re just points in a space, but
            the space has structure, meaning that these points aren’t just points.
            They are themselves types. If I zoom in and increase the magnification,
            I will discover that A is actually an island filled with people, and B
            is also an island filled with people, all waving at us.</p>
        <p>它们之间有一条路径，但路径只是……一个公理。身份类型的概念是一种抽象类型，所以它是一种抽象类型。我只是在这两个东西之间有一条路径，但我可以通过传输在这两个类型之间产生等价关系。什么是等价关系？我可以把这条路径变成这样的映射，再变成这样的映射，这样如果我往返，我就会得到同伦的东西。</p><p>There is a path between them, but a path is just… an axiomatic thing.
            The idea of the identity type is an abstract type, so it’s an abstract
            type. I just have a path between, okay, these two things, but I can, via
            transport, induce an equivalence between these two types. And what is an
            equivalence? I can turn that path into a mapping this way and a mapping
            this way, such that if I go round trip, I will get things that are
            homotopic.</p>
        <p>它们之间有某种等价关系，对吧？换句话说，如果我取 x 并将其发送到 x prime，然后再将其发送回去，我将得到与它同伦的东西。反过来，如果我取 x prime 并将其发送到 x，然后再将其发送回去，我得到 x triple prime，它将是同伦的，对吧？也就是说，它们之间会有一条路径。所以，这是一个弱的逆概念。</p><p>There’s a—there’s some equivalence between them, okay? So, in other
            words, if I take x and I send it over here to x prime, and I send it
            back, I will get something which is homotopic to it. And the other way
            around, that if I take x prime and send it over to x and then send it
            back, and I get, you know, x triple prime, it’ll be homotopic, okay?
            That is, there will be a path between them. So, it’s a weak idea of
            inverse.</p>
        <p>这是正确的，因为如果这些只是点——换句话说，如果这是一个集合，那就是这个想法。如果这是一个集合，比如自然数集——它就不是；它是一个宇宙。但如果这是自然数集，就无法放大；它只是一个点。因此，同伦就是相同的，因为它是一个集合。但宇宙不是一个集合；宇宙是一种同伦类型，好吗？这就是它的名字。这意味着我可以放大，单个点本身都有结构。因此，路径的存在并非平凡。它对应于——它至少会诱导这些类型之间的等价性。</p><p>It’s the right one, because if these were just points—if, in other
            words, if this was a set, that’s the idea. If this were a set, like the
            set of natural numbers—it’s not; it’s a universe. But if this were the
            set of natural numbers, there’s no zooming in; it’s just a point. And
            so, being homotopic is to be identical, because it’s a set. But the
            universe is not a set; the universe is a homotopic one type, okay?
            That’s what it’s called. Which means that I can zoom in, and the
            individual points themselves have structure. And so, the existence of a
            path is quite non trivial. It corresponds to—it induces, at the very
            least, an equivalence between those types.</p>
        <p>那么，单价公理说了什么呢？它说的是宇宙中的等价和路径之间存在等价关系。这就是单价公理。单价公理说，不仅每条路径都会产生等价，而且每条等价都会产生一条路径。因为你知道，在我强加单价公理之前，你的路径可能很少；也许根本没有。因为你知道，如果你写下类型，你就会想到我告诉你的。到目前为止，我给你的身份类型的唯一介绍形式是反身性。</p><p>So, what does the univalence axiom say? It says that there’s an
            equivalence between equivalences and paths in the universe. That’s the
            univalence axiom. The univalence axiom says not only does every path
            induce an equivalence, but every equivalence induces a path. Because you
            see, until I impose the univalence axiom, there might be a paucity of
            paths in you; maybe there are none. Because you see, if you write down
            the type, there, you think of what I told you. The only intro form for
            the identity type I’ve given you so far is reflexivity.</p>
        <p>因此，在宇宙 U 中，唯一的路径是 a 和 a 之间，直到出现单价性。然后单价性说：“哦，不，在宇宙 U 中有很多路径，好吧。每个等价性都有一条路径，好吗？”事实上，每个等价性都可以变成一条路径。如果你把它重新变成一个等价性，你就会得到一个等价的等价性。我知道这很华丽。它有点复杂，但很华丽。反过来说，如果我取一条路径并诱导一个等价性并将其带回一条路径，我就会得到一条等价路径。</p><p>So, the only path would be between a and a in the universe U, until
            you have univalence. Then univalence says, “Oh, no, there is a boatload
            of paths, okay, in the universe U. There’s one for every equivalence,
            okay?” And in fact, every equivalence can be turned into a path. And if
            you turn that back into an equivalence, you get an equivalent
            equivalence. I know it’s like—it’s—it’s gorgeous. It gets a little
            complicated, but it’s gorgeous. And the other way around, if I take a
            path and induce an equivalence and bring it back to a path, I’ll get an
            equivalent path.</p>
        <p>它会相等，直到更高的同伦。好的，单价公理说宇宙中的相等性等同于它们所代表的类型，或它们所包含的类型。这就是单价原理。例如，如果我有一个宇宙，它的元素是——我无法在这里解释——所谓的同伦减一类型或同伦命题。同伦命题（h props）是从经典角度来说，要么是空的，要么有一个元素的东西；要么是真的，要么是假的，要么不是。好的。所有……换句话说，无论如何，所有相等的空间，这就是它的说法。</p><p>It’ll be equal up to higher homotopy. Okay, the univalence axiom says
            equality in the universe is equivalent to the types that they represent,
            or that they contain. That’s the principle of univalence. For example,
            if I had a universe whose elements were—and this I’m not able to explain
            here—what are called homotopy minus one types or homotopy propositions.
            Homotopic propositions (h props) are things that are, you could say from
            a classical point of view, either empty or have one element; either
            they’re true or they’re false, or they’re not. Okay. All the… in other
            words, all of the space of equality anyway, that’s the way of saying
            it.</p>
        <p>那么，这意味着对于 h 个命题，可相互证明的命题是相等的。好的。对于 h 个命题（称为 1 类），那么我们将得到可相互证明的 h 个命题是相等的。</p><p>Then, what this would mean is that inter provable propositions are
            equal for h props. Okay. For h props, which are known as 1 types, then
            what we will have is that inter provable h props are equal.</p>
        <p>因此，如果我可以证明 a 当且仅当 b 成立，则对于退化程度极高的类型，它们最多只有一个元素 — 它们是子单例，这就是说法 — 它们最多只有一个元素。如果我有退化类型，即子单例类型，证明 a 当且仅当 b 成立意味着我有一个映射。如果它从 a 到 b，则只有一个地方可以去，如果它从 b 到 a，则只有一个地方可以去。好的。所以，这是一个等价关系，因为没有不等价的空间；没有地方可去。好的。</p><p>So, if I can show a if and only if b for types that are so degenerate
            that they have at most one element—they’re sub singletons, that’s the
            way of saying it—they have at most one element. If I have degenerate
            types, types that are sub singletons, proving a if and only if b means I
            have a map. If it goes from a to b, there’s only one place it can go,
            and if it goes from b to a, there’s only one place it can go. Okay. So,
            that’s an equivalence because there’s no room to not be an equivalence;
            there’s nowhere to go. Okay.</p>
        <p>因此，如果我有可相互证明的 h 个命题，它们就是相等的；在所有情况下，一个命题都可以被另一个命题替换。哦，这开始变得非常有用。事实上，这里有另一个想法。如果它们是集合，那么对于所谓的同伦集（h 集）或零类型，我们说双射集是相等的。也就是说，如果两个集合之间存在双射。</p><p>So, if I have inter provable h props, they’re equal; one is
            replaceable by the other in all contexts. Oh, that begins to become
            extremely useful. In fact, here’s another idea about it. If they are
            sets, then for what are called homotopic sets (h sets) or zero types,
            then what we say is that bijective sets are equal. That is, if you have
            a bijection between two sets.</p>
        <p>那么，我们所说的同伦集是什么意思呢？同伦集是一个路径结构退化的空间；唯一的路径是自循环。它可能有很多点，但唯一的路径是自循环。所以，Nat 是一个集合；它是一个定理。这是一个零类型，也就是一个集合。它是一个零类型。它没有非平凡方程。你有七，你有八；七和八之间没有路径。只有从七到七的路径；就是这样。为什么？因为直观地说，元素没有精细的结构。好的。元素是小原子，它们要么等于你所说的同一个原子，要么不等于。就是这样。好的。没什么可说的。这就是集合。</p><p>So, what do we mean by a homotopy set? A homotopic set is a space
            whose path structure is degenerate; the only paths are self loops. It
            might have a lot of points, but the only paths are self loops. So, Nat
            is a set; it’s a theorem. This is a zero type, that is, a set. It’s a
            zero type. It has no non trivial equations. You have seven, you have
            eight; there’s no path between seven and eight. There’s only a path from
            seven to seven; that’s it. Why? Because intuitively, there’s no fine
            structure to the elements. Okay. The elements are little atoms, and
            either they’re equal to the same atom you’re talking about, or not.
            That’s it. Okay. There’s nothing to say. That’s what sets are.</p>
        <p>因此，集合是一种非常退化的类型。它们被称为零类型；对于这些无限高维结构而言，所有类型都是完全退化的。没有更高的路径，因为只有——因为我们在这里切断——只有反身性。那么路径之间的唯一路径就是进一步的反身性和它们的反身性，追溯到上层。这是一种退化的情况，称为零类型。好的。所以，单值公理告诉我们，如果两个集合之间有双射，你可以将它们视为相等的集合。</p><p>So, sets are a very degenerate form of type. They are what are called
            zero types; types for which all of this infinite higher dimensional
            structure is completely degenerate. There are no higher paths because
            there is only—because we cut off here—there’s only reflexivities. Then
            the only paths between paths are further reflexivities and their
            reflexivities, tracing the way up. This is a degenerate case, and is
            called a zero type. Okay. So, what the univalence axiom tells us is that
            if you have a bijection between two sets, you can treat them as equal
            sets.</p>
        <h2 id="applications-and-generic-programming">应用程序和通用编程</h2><h2>Applications and Generic
            Programming</h2>
        <p>这适用于所谓的泛型编程。因为，你看，假设我有两个相互双射的集合。假设，你知道，什么是我能想到的好例子吗？我能想到的好例子涉及 22 和 2 × 2。好的。这是一个函数空间，或者说是乘积。我希望我说得对。它们应该是双射的。我希望。好的。这两个之间应该有双射。所以，如果我有一个 22 的列表，它等于一个列表，或者可以传输，在高阶同伦的意义上相等，并且支持传输到 2 × 2 的列表，那就是泛型编程。这就是泛型编程的全部内容。它是类型构造函数的函数作用，就像列表一样。就是这样。这就是泛型编程的整个主题：类型构造函数的函数作用。讨论结束。好的。</p><p>That has application to what is called generic programming. Because,
            you see, suppose I have two sets that are in bijection with one another.
            Let’s say, you know, what’s a good, off the top of my head example? A
            good off the top of my head example involves 22 and 2 × 2. Okay. That is
            a function space, or the product. I hope I have that right. And those
            should be bijective. I hope. Okay. There should be a bijection between
            those two. So, if I have like a list of 22s that’s equal to a list of,
            or can be transported, equal in the sense of higher homotopy and
            supports a transport to a list of 2 × 2s, that’s generic programming.
            That’s what generic programming is all about. It’s the functorial action
            of type constructors, like list. That’s it. That’s the entire subject of
            generic programming: the functorial action of a type constructor. End of
            discussion. Okay.</p>
        <p>所以，如果你处于一个类型理论中，而这个类型理论有一个宏大的理论，是的，是强化版的函数性，那么我就可以利用它来进行泛型编程。这就是让它发挥作用的关键。好的。丹还会讲到其他事情。一大堆这种风格的例子。他会向你展示。我知道，我知道他要做的几件事，所以我就不多说了。但单价公理有很多含义。好的。他会为你解释清楚的。</p><p>So, if you’re in a type theory that has a grand theory of, yeah,
            functoriality on steroids, okay, then I can exploit that to do like
            generic programming. And then this is the key to making that work. Okay.
            There are other things Dan is going to cover. A whole bunch of examples
            of this flavor. He’s going to show you. I know, I know a few things he’s
            going to do, so I won’t say any more. But the univalent axiom has lots
            of implications. Okay. And he will spell those out for you.</p>
        <p>所以，有趣的是，我们将命题视为一种类型，我们说 a 和 b 相等的证明空间，即宇宙中 a 和 b 之间的路径，等价于 a 和 b 之间的等价空间。这非常美妙，因为它……它……它概括了事物的传统数学，即当且仅当 a 等价于 b 时，你可能会说 a 等于 b。这是真的。但我们要说的更多：这种事物的证明之间存在等价性。所以，这是一个更丰富的领域。好的。从 CS 的角度来看，这就是所有行动所在，因为我们正在讨论某些类型的程序的结构。好的。所以，这就是我们正在做的事情。好的。</p><p>So, the interesting thing is that we treat the proposition as a type,
            and we say the space of proofs that a and b are equal, that is the path
            between a and b in the universe, is equivalent to the space of
            equivalences between a and b. It’s quite beautiful because it… it… it
            generalizes the conventional mathematics of things where you might say a
            is equal to b if and only if a is equivalent to b. That’s true. But
            we’re saying more: there’s an equivalence between the proofs of such a
            thing. So, it’s a much richer field. Okay. And from a CS point of view,
            that’s where all the action is, because we’re talking about the
            structure of the programs of certain types. Okay. So, that’s what we’re
            doing. Okay.</p>
        <p>所以，我昨天下午准备了好多内容，但我不会讨论。所以，接下来要做的事情是……哦，哦，是的。一个小小的收尾练习，……好吧，现在让我就此打住。我就此打住。我们的时间不多了。好的。我会……丹，我要做的是把这个交给丹。他今晚就到。我们要吃晚饭。我要把这个交给他，然后他会从这里继续，讨论同伦类型理论的各种应用以及在同伦类型理论中的工作。</p><p>So, there’s page upon page of things that I prepared yesterday
            afternoon that I’m not going to discuss. So, what’s going to happen is…
            oh, oh, yes. A little finishing exercise, which… well, now let me stop
            there. I’ll stop there. We’re running out of time. Okay. I’ll… Dan, what
            I’m going to do is I’m going to then turn this over to Dan. He’s
            arriving tonight. We’re going to have dinner. I’m going to hand this off
            to him, and then he will pick up from here, talking about various
            applications of homotopy type theory and working within homotopy type
            theory.</p>
        <h2 id="homotopy-type-theory-and-agda">同伦类型理论和 Agda</h2><h2>Homotopy Type Theory and
            Agda</h2>
        <p>然后他会用 Agda 做一堆 hacking 工作，我想。Ian，你在哪里？你在那里。我想 Ian 会去，对吧？实际上，Ian 将成为你的编程导游。你会使用 Agda，对吧？是的。所以，用 Agda 来编程。Agda 在做同伦类型理论方面要好得多。它现在还不是正确的东西，但我认为，在做同伦类型理论方面，它比 Coq 好得多。所以，很多进步都是从那里来的，就是这样运作的。所以，你会有机会这样做。</p><p>Then he’ll do a bunch of hacking with Agda, I think. Ian, where are
            you? There you are. I think Ian is going to be taking, right?
            Effectively, so Ian will be your tour guide for programming. You’re
            going to use Agda, right? Yeah. So, programming these things in Agda.
            Agda is vastly better for doing homotopy type theory. It’s not the right
            thing yet, but it’s vastly better than Coq, I think, for doing homotopy
            type theory. So, that’s where a lot of the advances came, is working
            that way. So, you will get a chance to do that.</p>
        <h2 id="summary-and-conclusion">总结</h2><h2>Summary and Conclusion</h2>
        <p>好的。以上就是我的五场讲座。我讲完了。非常感谢大家的关注。我想这是我参加的第 10 或第 11 场暑期学校，每年夏天都是我一年中最精彩的时刻。所以，我非常感谢有这个机会。</p><p>Okay. So, those are my five lectures. So, I’m finished. Thank you
            very much for your attention. I think this is my 10th or 11th summer
            school, and every summer it’s like the highlight of my year. So, I
            appreciate very much having the chance.</p>



    </div>



<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>